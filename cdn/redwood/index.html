<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70e42b13b5a741a238f2248dcad5f4cb737559938b6637ad51b1fca70a9a8dbc8cabf84987ce4b52d5334d7c6faf921d9e9218f97bd24f2dc21aef0e756129d31ee00bb18cab7497705d8cacac1405893cbf2b02d07a294b70f32d17a38a97dc3f2076f8614641f96df96f1d8543b5d4dfe05dc7ab0ec0ae9bd8fbfcc99826338140b5b34759b774a58e76fca2e13562e4e0d05dcd2b90435c2b59678f22a50df0e790941d6b0989bf6c68dcb87a31eefcffc2be399c0316d12687dcab5f5470bf53d5efa7a3ce056aefbdcee1cc7df8c70dd2fb642af408371452258627673f38c40507e449253de95a0bfc7f72f77850d1a677002b84633b02ad43a3013c1de8ab5cc570b8d25b5cefbe27db30e842b5a93d8d571a1d6323b9b8c40b0cd105cea274e1004e68cb1ec9a4e17045c9a0ee640bbb51a8ab382e3946884b386bbb5e75bf7bda24c6127a376386c377bb90a14a120435896e0fb97e50cb0220ce870049940b8ba541ff0405c575b67d54ad8f1be3da4db8a85639426490f6a6411af08c7b36f8d06ce78b20cb1286eaab894d9115d4370eef8e56eb18b44bc4f048c39d6047d27554f97531796791f17328aa0a9da8430edc6b7ef4da7f2b238acc1a64629ac722331d80f33d1f504fe8004fd7ec7d9847bba3a36aff1540db40a7922e98addfe2d2dbe2c07a5eb880454a5c3e831f258f08380452fb25f0e169663e1f8ad68ca88797af44697be97cee848cd089628415c08f3371feeb6e8bca837800d40fed4df8df3937a06970a94aef0e328d7a74f1647a175a30fcb8d0f9e29dd8691d2c2c486cfbe28fce2b80f7cd75cfc4654bdbfc1b893cad8fd8400f044de2dbe0d147569b7bc85c43066bc25bc79c210c509605c81ba6fb2e12a8e2cf298b1af541826dceb5e36284df52d0da2c5fa06920169102280baa437f66758e3c934471bf69444de6fc9e54d881a595d11c4ad3f8553a3cd843304d7112e77d45914b352820f6e6ba2b2707bfe8646255258ac6cfc398c60c0905614f3348b8cde86d4717600b7a8668a68f8c3a88e433f6a5a48911b790f9eaf5c759c14740591a274ea86a899c0590deca4c1482445225d0328dcd5935e6620a952b660cd44867de704179ac174811df40a8770864b841d215aa81936d800d87520c2f53061699df4e78e38469314f2e254fde7491ad739bf4c63e444ca194f27dc30e3c62b9cb108581f8836eb4a6d0b3d9ab7bcd5270d578c202073a8de8d08cda67695fb26dfc49036bd24c32a60075a18928f0c52bb357222b7bea4d89d82d4d2c85ffcaec7dc46c3c2040b91f5fba06d197f05f5c0abb14ed26dfdc0a9fec0254784167cd4ad6827387a04b318f62c54f403fa3f503aa8872fc466e63a1f919fa10cacf85bc20c4a87930e3e275e4c49165f21688136e32a5958ab50940bde618526dd9beab6cc6f21630480ead791425c1f2edbb49a1d5de60d5e7defa411aab5275434fc3ba0ae9b13a7e74b29c8f641865c8f043acbbcae6188bbf2569f795c325855587450a1572ce34a40010d51bbb79c6bfb6a3fdc98c166a7e6e09034b4441e9a641127523a35ffbc37cff749319357ddb022adfcdabec033cb364a450ccfb756204365cb3688695a4d9369c892e9a42e63c7df8662e89514fec13c38c9c8da0cb4f3149b20576070cb893dafe6d2aaac126b569fa27a5114a0b56cd665f280761f32fc54bd5bd8ef15f07f5c2f03f4c721580948fc499fb95b539bbeb3e6f17e80ebca4133c6b4cf942a5afb39fb5389fe623abfcdc464e9e26df8e07262e0dea52654059c77144737ed98a8d441e187876a8727e19f7a8176a43264e0cf1fc2ca632e4edf9d660bad21fa4627cb2ffbef808e2e7bfd892c1d3c8fde271bb75dc5642c5e246a988b1a44a030d0a3b68c45925f382b1bdda72c1d7aff1bb749038c1904e0a97919b7aa34b0d03acb07de70a1264cdfce02c30a45403f5a3c9cf434b78b3bd7c348326d82ffbb8ad02fd932f1ff69935571a307ce84ede42fb7424ef9e56f3f8304fcf615e22434b5202f0bc68674a60a4f639e6001493e456afae9c09dbc5306d730677ccfde6f59b075fe7186a6e5dc56ad32480cdb7704e47eb4e393ba6c7978c81142a841fe471881860abbc2eb12f48b40a9970c40c4803ed97ef02f4d8827794f0377d9ff39031dbf28c030a673b4a377f168ac17e2a9d3c2d9e250f2600c19ad49aa52b93c669fe81ca560c788d90895504969ce48c88293213b495f2f30fe364fa78c5458f5f7bd6d25453220130b494ad7d3ebef9b9f7251cd7b1687da31bbbcc035790565d51a7cee975cd0465779a459574894722104b90c8c3cbd136572002b6d1a9802ddfcaa78146a902e8b32581864d16dd5fb37db3715bdce0466a1d45e5ed45e9a9ba9941e8965b2ea8e055baf0e998a7619c9c4c88281abe9928a90a02d4638bf29288d18d6821e02a4f90841bdf70f7edc074997c175531253aebc297f85bd37891e65673c17829d9fa696e76aa57d0828fef75654be8a7b8949cd273ceb7a0af3064e1781952ebbc963f4ee9dacf975d0a0ad90c28bc27ac6dba1065706cd40177ea2531e65b70b3c6986b036526b04e6417fd823a3cfcfd688c2017c060130b7f8af65bdf32a54acd43bf0e551718e2cc4f537efdb4419b284f8de62fd30ca0692f337d33b3d0191ed5c4e134c1ebbdf7a55f8402ee4517ac54d63557c2f0510f652535ef6b20ac1b9b9a6e8dd5bcab58ccbb355e26ffc5d5d4e7b806148920e6d8c2394d213d5cc8074d65c6df91d57a9ede38d4ecab34f91aedbf7c5e3323b6437e322c1ab97cd62bbbfb72292db669ceecdab00f04c5f5cb76db7d548957f8e031da5ebf36e0753586fe997cf680881d105548bae4fa2e021263498dbd74f926a5fa36827954ff481ba9e753e5a097ebaffa4d85bf8c401f3dfbf236194507d09419e3706ecfff0f3f1fe46d106a99c02a1cc5c3267a15d87eed2bcd1f3b5f68f3f90ed599a67aa080270a362753be9cf4c350d8a90a2ea8e0c353cd6ec8a232dedca1bcf9b09e7e38e4eb850b2612d094f9cb050e1fd3d6ad411fad4eddb42a3ee1f6a6d56a541dcb5feaae46e7e828c4f608193a62f9d325c7273c5734843b8828038269b16e303e77aad1b68777059572a9a13f981338921530a7e1a64d0c40c6736cf9f628eb1ad9e7376238f373d7869c7abbc90bd46c422b939311fd7ee5719832c90c4f75b013c6b0b4f3ac74ebc622538634ef3deac9b53ceb6729649afe08c40ea21d5866cd44333c08a32cb99f80e87934c28054a76a0efca285a8928813dc79059643ceec44dbebd6c408bb7a2962bfedd11d4b4e61ad78139e23df6fd58ea2a5b161eab056a7c72787ac95525b03ddf07702138705126fef48d1f3f85ebb77c763aa43ee47097593f1a3164ceaaaec528d728c1e433aa29bb6e9b70284946626aca2aae2032e6d0f8c864d3cf84c78651790fe9fe546edfe85afc05da70424e21dc2e08d92828d5f09323eaf32222e0094c02aa975415e7f28b6f0224b94913c4015d27630494c6ca111009272b40cb7b69b6c035f9ac5217c8b74bc0ce6ae4c1c9e9948bedc8d635ede8583847b4830480620b17f437b94812b44ea67c66b4cc6e42e572d2d097b95819cc79a1170db5faf4b32ad0f067875dcff85ff983a4415c70f868b33111258f2631810c23100f557f4ac19c78dc597e9e150772d48069f9fa612ef3da6e683b33025ad63101cf3c27c26335edc4fa586e12356c6fff6779bcd4a7abba84bd32929aaf32acc8f5d722b09128f8e44904a76cd956d3ce38d05c359f2159fa5d4079b7d8b6825a15e41f5d10212b567f29508798e952ae81e0931cb22840b7901d2ea20614adabe648c46d1b5d8848e2ddd14b6bec11a5621cb8040e23d1baf35dc0ccd8674eea4e8548d602216de15abc50c70ad70683b9b30b53c31f1c803ca2c2f06e3239494b1f9842d906a7f79d02bee3c9435d6172118c07b3998206823b9b9bd311b83151af5d41d27d462e1833005cd8d2a213e367399ff5b867304ad351a1bc125d5d335b646038da2e9b5c9614e3340d21834bf8287ee03a73bd682e3869e9b0bfe5df9e6d51af174b9a6c8eac7112789edd1fc02f215d618e68f034b1bf83a85fe8c2ad078c3c606cba70779f790ff62f44c023a7a4495aacf59ca02f3fc2fc65bf49b4375bb93cc8a0b81d192cedae687943e7d1a1d67322998b463e6bd481026bf2a29d84173276e6ecac45016c8ec47e1463cf3aa46496f4f96c6ccaeeee26b9f3b978da16458bbd108e9497c986fabcda9cb6ba226e56ce185f26aa4239fb20361821a0a71f9147b426d6e377e7d6bd20988dcf670ba02c4c13729c4789e9b59245b2aff7bcb9db540d0282acb192782afb1af35c39ab237241c956ba7856cd888ec81229c3635b94698c3b791fcbd84a454ae2a6e79a3e00777d292b1643a83f80c1c262b3ca4f55a4be5c57c706a5a499b17748be348c620367e252d1a48e7cf44c04da8c14d3f84da9e4a1938077208ef8b99e31a5e16c3aa43bd22b926a8e479d111fd6ad6f858adef6a539067a04a9cc635f8468c94809d08edb48e093bd377f1a1d263debd0d79001ab906ee9267c584ad232a894b91480b1a1d39f6d7d3e835e810983253fdb7ac070a2d108f41506aac0c285a546b71a4b31a6873e130bfcbb9729fdbd31d4d2d8392891ced4639308bf70397e0252503a8717c415a1e2545f3ff3e0efcc4e1d8984e9a8fec86055072ca9ac6133e8035ed283e245afe0c47bde24597f3e9b2ec93d3c45c15bcbf817d70fece73fe3777b029c15fb8f41ac6a9cca81c34f45fa9a4572d6f47c6ee1c537f0dc84d559c8e9c6a3a97d2e496aaf46a1ac9503a90de593e13d2fef55e5bfee1819fb1e9f0f934e73feb86edaf62fbfbad5ff0e6cf020610455fe9c84bb00305978a8cd54217693dd6b8e1d67cf75fe84cb66bbdb957d83e2faff73f63228af3dfd4a2fbccfa4fd61b5adc4a968a39926a4e7340e381a66115c8ca9bbea4de819c906fed8441c2f4e87470ec5a3c5595c517c99231a497ea91eadb7a868fac6957b72dde713fbaef2b28a61ad37840f625b25debef4a3529300d000c57a3ee501ea88cd993017bf576e5ba132df8fb57d695c5459af1472bc5a1552c17dcf95c5396096e69fb6418070b4e908a16050d03f76cbe4d596a0d67f165efd56e111f3ced39abe7050ab0e5e555519a6ba5f78bc77db12cc863483ce12d4c89b07cdf8747f8e17e4a7ffdb3334a9e9fa82b272756b22366ae00fd37a0fa2deb729dfb26f48b04c932f6061502d057df4bd90f66731cf56608efe9b8cd277e627eb44ff59253a669ff16ebf232fcab3fff5ec7f4bd5f7b68ecea0486d3d460e75ccb19baa01677ce7fc859ea3afc66ac85f5ec776d667bec198038dcdee6311bb1154a47690618c524c91410cbdb3ec221cc7ce5db94be47d33fe55dab5e6890d89c5e48165a8662f9c3e92c41023e7aff558bcdd8c35cd7e47392b2dceed730213c32ae17b2c1cd7cfcb2cc91a0c5beb2320552d93d351a70cff16029167abc3ccb489b2dee7948e7930738c6f3aa79126933a96bb3efb1d8942572377c1e2c401f4d928b4b136a06222a0190baeec5e7ba6ce95cf91a4eb8114b7c5fcb014f3cd0da68e2c0616ec3fdc5f9e9cadfcb617c2e250a2716755e1c5b08140fe923786f3cae06c0dddedb46548449fb58febde65fb10e2901021c7eb6c192592ad1a21feab3b477ca45f2c70d76639bb10bba6ea09435e6c8646621d2a4a5d057a13e687edd7b26e1ca36cf6635ae9f34c03b916b0dba79b4c6e71851477b7aa30af2be62693e9f86a2fa324370bb7b9e3d0c9ebc02deb983211eb7ec7d1ac5a025844010fd032258e4614985eee3ba75267f07fe9e75993017f2d2c1d3ee40266f946bb3acca488355626f31cd5a763c939e59740c15058bd0c21d793906731b3e98976761bbfe7844269573e344da0fbd7d76f1958f4b8168bbc9630da7c84086ad8500fc1f3be09bcafe1c3de38c2428251f130c9c0f3914d3bd0ca1ffaebb47d03d732b01c87d8667007e145b58dea8c4e987325b0bc016da170306912b91c4917782a03d27a0cf72222c7785284fbaaee9338fb3e88fd97287db0ddbcc3625c60f8faaaaaa64cf427f5f54a0bd6b809f35c0318da58eec6344de633a131410b5db2aefe8fabe7251a97dfcc0a32a51d6c7d4b1e277921664a2cef1e32e9a043dfd2f5e9afffe4ea59323745e68edc61823033898def9547aed39bd97f79d7e54e5136faa09f9a492af43877b962f734cd7c2b89c4912a21ff9d765309db99009cb810f4119c86976dab2d5921895ca4413ebd45ed0d3982fea237040d533f0565aac3040c44a71a89940851694fce4c7e8b1f7d0ecc1994a6ef60c24704f0e6abeae3d6bb1db708c667fab11fe3f453342911a66cecfbdcac448cf3904ad5dcfe93199b95b06098d146f8688c5c3092905eca32146edd6b9b334dc38d1fe286f5fa5fd11092805ace3cad786e7ecb0da021ed1b28dff4f72535e17c6ec8af6d92396cfa5153e0dab3b66996a63c503a0cf8790de2d1017cfe0af15f4f3c7e3c1ee1c3ac39f93b756d0015d50188c616d4419e4f0a35f9ce28a6d7b887c82a9e0c70ca10ac4eab0f9b0c4e858f8bdcc21992d28fd5a1ed0915e02b374f6f0413e87561e3afa0c93a68e2978ad1610cc990648ac78c6e2fd228b88a3ac62099bf545c71edf3a0575aabd5e8519aa5cc52b5d74f235be11183234ce97b6e94ce8c8c93a314eb2e4eb1b7443f1fbf6b23354bf5928006a3a710e8a0419d7f458d98a897d9695da8c472f5e5e3d1899a4387d1c9f7d1182308d105edcaabe99b8442c41a7d078f5e76da429e159bbf60b65d13109b9153188f317c6b5d5fbfd517bce37f831628e1693f3262a309f627b7516c7a595aace1826f1962b2fc0b4d33cbd98b4f025496e369e4a140279c35509a4f79214d1feb1de13074be303c0533b7ec459fd0a35f1d8f49a7c7c5244ede93b4d174f86165a61dd6b47f3238b4935c6bbdf73bb565207b70c0f626a19066818fa41a77faa90383d2c595169f9375545f70e43723af4db1ed13f26e711a9864892d8c6f60f8abf26c737f69b4aaa913fac8f1f94c79d21ed1644e828b7cccb9c2ed31d5f9013d2498ccd6ec88d41cd17378d0167e450e5b2083ca834612725e1719a88d93c1112b96568028ec4d0f46964fa693d1ffe5177afd8be191ac79f7f02684827ca35b6f9070aa8707b2bdf94207e9bd539b9c18ab59b9bc24d0caa2cf522da61d38f443849960d515fe3435b6192492bb2137bf35773dea224144b76189fdec6940a360c3d64fe49ceab2d9f0771108ecad97e885e38525a17ecf0bf71ad7bb4db0fc6f00bf17c3424d593945d166cdcad8359da83d62aec3bd8a5556a30e681cc2cb63c89be58a1d7097c1bdf255fcc21cbc45c702dc637fd68ac68857817142959f0ddae92741f3cc1f6dad950c7a591e9462c2454a0945a059fcd4e1a8f8398851e4cacbcd862c6554ddb2af1a1c1050a72e81933f7a33dddc567c4eeb1eb5184584e6c598cc6e61b1cb853b3a5103fbd1329488cf04f9948d227061c173132bc3a7e63851b93facbf90a47754277e7a7e5d213937fe75b94bc4b2ec66886d10963072ded548ef3f753b26b8e118beb3247a2f9d28f9b0d01df08a1916ffa04fb376e913b7180b7ce15430d0d3a3c696e1a8b942ad582ccaae0df8263510e25ba388c4b99f5add87e8db55c12a7a5b8b14f6c1bc11ef2fc02be209484ba28f272f4fc091dd07beb0addfc35fde93deeefe56ab3fe923a5444b03bdacfa8dc507c627230a9d85aec42e56263e1b91e7fefba4c73fdbd594bf7e55d528f83860afe81049054096c5fe1dd3bba834c4933db8169ff90834693294244648a4d36c005c739efabbd89dc277b34832d2f5337a57cc67840ed1eb389773722c0e0204d484721b64f9d5050ffa494d283babfb9f455b2607c605a982823fda8b7699620fd7f2bf088f894739152758d2609ad399c777226b7e67f8a8ad2a3c9d766149b6d5b1664612af6a59644344f11ea24e9ccf7132e72525e51f8f58010b93112d347c5521b5806464112f283af99aca3c918558dcf01c0665bcfbbf1953c04b2b28bdbd86567f71685a15d12c6592066fbadd67fc8fe70c417ca3a8ea775ced066c1d9cdd65150160c6f16d89dfc41afd48be8b84d5e4a9ec27f9a51036059aab76b9abca9fd403bed3ad7a6f6a5222ae88df6f3655b1e4f8ab8c1d04d310cf44adb52c332765902a69b51052b4093862189923581ca36a1b789c7c376345897bd5a2fa5c4e9e326bea298970571e17309b7331a974900ae796d2f50031b6d2cf5a55fc05b09251297a385f71b2806b93266bf56412e8278ca5b1e6a82b842409237843049388635823e65e98bf6d1d89714ff723d3f636dfbbc0481e8282d1c6e9ec294c140e7c26ca0ab70698548219cd63efe704be71f6370a1580fcc98f4c1ae3a1be54d0c0bdd28bc426c659f2c1aa8e7d6ab70ae0865e50c838d94252fd0c12222b20d3b0fca85fe9cc1061ff5830bd0e9ec527872b82eb19d8deb0705a9f02a5ea678e29410006c127b13caf88b669d89c543c0136185d0c3b7e4570a407be92a8dcd05e414bacf6a61e5a18a5e91def9edb84b45f2e537d8c2fb28084e7def484532f92270eb09c65cdfc145981e77a7307ff09555778958e4f2970578fbb53588629c468392300316070a728d8f7d808b9de1a7a839dd6d0ff0a4c829aab891c71812c27ef19a33b5e34c6dd4c5817176b6a6929a8e3eaf1479a758cd09ecc61f5ad3331d7c6b5017f42da1b4f67e029a233767661200da6169d7eae5f0e3975533e8714be0634ddba7c0dd499c81a0b5cb68e271ef4a3be6c1cf1fa25223b089a276eaaaac414104cffa6619653cded669fbf5bfbb25ed77c258e1f2facad51326745608f040b8d2885fa10fa4d87598bd220e441513712f1b596e27c883aaf7d01dea7fbbc960d5a7976777e42bdc9242d26488b3cbcb13a82309bc4e1c93568e9156de93cea6e5705c7ac813a1fe8a6d022e3bf41cfbb48fb77c764f3d14029a0428beec69f7e9e450f2a9701eaa92dadde09172c515894732f470fd975e2e051dd4a07c5031216ddea7272552c0dee15b4c7011a99131d618b40a69841fd20c95f7d0fd28d2f72c683c355f194cdc68d0972b3f6db9e981e769e089749b05d96694fbeed19d35ecb9bb84aeec9367af9c1fdc1df93f2c536ceb284810d03cf25924cc5b191cc30f6fae0a3b924694ba73817429ae860f976367bcab87ab89771022ef055d2e16ee8bc3a13fbf1d926c174956b4f38eebca9e73b37ccba34da0ddde7c69723de93cc9e7b57c2ea78ad5f14f3e563224d92276419c7bdb5c0fddc6cfa78e52496134d530eeace0ca5a12e6a2fdd8ac382590da32ea337e347099fed46d6bf582141cb8d2954e8639e2ffc1d9e1558e1005ea7f1d47b0bd3fc39a24e5030b5d952f665e2e482884eb6071483d4fdfd5ef9e7ce066ea2e222df7418de23ef501f321ef13d81dac967713d1ffaf08ae897d9afb596a55f97926aa439de23fd3211b768d44ddb8f0668e7925e7b3d42daeb98357b38641f5d052a271c1e63da20a1545a6f235cbaa5b6cf75c7ea991149e7b539728d2bdb96c9d3f7a4363936a5c01930c66b6fb414f2954e0d2a3d14cf17841fb8b8e2ce9f83b3453d4c90aba770b7621726fc0de51adafc6d76e3a8e6f3c73fbb033501825a49395f338d19fa182ae999ce3629aca315ef03f629e3af32ef8486f63e65dcb38e637de69343dede8184d092cb5ca7b6467ba3b77cf317c3d8b1cd0a7a6f68ed03211ae95509d691cb31c5622e2acd54d7e813401a5077afc50881c22df8373d35171d01662b7b7279741139c412e5e833a3ce06cb1e617e732c01c5456b5fd945d5b5789b8889adcff910747465e3650744de70c2efaeea057707a045ff6545d458f63c48825da346ac898902fc730bb6d6fe6d14be3e5357a3c01fccdafd3ac137320df257cdf4939b5ec7cee60179892c0826de5ba34a65b43d25b296b6ff863d1adeaa276aef0d971895bfe753dbabb93b8be72a67c952f454ac0f57622194503fcfa5a3943567155313c1c45fa0c496e4ad400ff90d9ebe2e421a88e1c79bd1bdaeeb6cf8ae5c2387d3af9af2979b188e559206fd7b1923e9c54ceaabdfcb28a853ad262817e284ef68184640833157c9c2135f9cae87fd7d0fee8970542d398bedc14d855fd023ebb8c056687d36de873ad5ff2bd6deb404ad792686af71abe3b5168ae1f15faa84b43c47332fffddabdc92cd84627440f26c04d10d40b77d0d3086c7ad143f3babd46a3c64d9286696a4b50f883ef1cc855f9badd4c5b94ed20bf010844e84132cfe70e7a1d556294cc6ca68b13ae99f1d2b240a1771526c1a9536b4c3cdef1b44284889c29b3c96e18dc9bfda2b6854ca60ccbe1702acad1dc0e3dd4cd68400844edfec2ebca3143b1b69732c0c16e2363d40ce824e9cd53d1e277c2785c926786464d57bd16c27d7c5e4ebb1d7f7f5983a40ff89e8d6863ca3b141338cddf8e61a019c5e1fe2319095bfc66ee7c0a23ee18193ba33bc2a8ca8d12c4fbae270433f916006ce7a93db90f49dd5c3f22d937afab8e7375c149579177e0c87e220317e83c5a4afc1d53f47debdc013951b1022883ea8dabf6a8e7048b4b18e5f6ddab1a089c7f0b8f9582e192335799a68cefafaae50be143dc3f79a15e4c0a2c2efb3b6aa003ba85f929f989885664cb2249d6c41951e5cca8104fec8deea2318093d96ea0fced30f0e6d8587bda45f9793daf03d3ba37acc8944337e5ec7e20153ee37989a625057bb42a0d183588f4efe104cd0e91cf7ecb9fc4daf16d6cef3f9fc0dde2538df04c29be6ec3823c47de74eb9059bbf2468f2be4c998c55b02cf9d366ff646c7d4e649bbbb003ddb4bebce0f489379a53f7fabab4142b86a89d994bb3a27201b4c20932a6f912d12e97065acc4de06a0373f33a0a04f7b18f13395f48fff0157f0b751b7dc851a06f2c38503b1347bc16527f58d69fbc858b3aa81d72d710776716d59d65fea9228fc5d0c1780aca1cd558c109fb2c95c34870f69ab9e4f88f64995c1e0993778f490e44286f664d0ee82763e35a39f8084cc65c69f985ca8fce3e50ac708edafb06da10f2a6d1bc88592bc26e0549cf38013128e8c5bc83bcc3b6a27e3c98874425b90204c47cc917fadf2f3b1e7a1e7293b3a8f9a8f40428c4fb616d98e87bb0f8634f92682063da38732bab76f313a10b8892b48207b9f1cb991f0ee79892168390cdde9b5735461c2c7761c2cd48c99e2b8846b9fbc97c2f70e613d4ab72ad81658520a5042722a7303037d7709d64dccf7306d78bc018f768cf1b65d808a8cbbb3d1baa24a49a7925a020ab0565adbdbb331015c30ccc5769a234a777f011d3c41f9f0f5350abc295f54079ce89be4ed7494842f9b05ed07f938c20b8a3cee56dae66a4f206aed2d6fda846b1f9d59da81dd7e6e038607eb4e31c0e032d85a33ae13d9a40b0da40a724afa53a17d03138c328401a91ae3861a478e3405dec585d165a75ca60d8c9028576e3e2e3a1b4b5573ac415c1a6d71ff8737147eefceb5aed93ef7544ac8a017a3778543a0860820046b1320145e185237595d2fbe156320ecdb16d19f7593468eea17779b0ae87a25f8c93c305277adf3ca4dfe843c6e2d77a92ce6a3c95cc2cbfd693839cdc875d8690b5d5abc045842ca6488f653e5dbc6cdbd430b0a8369f5d63d0a74ed8a58e845929a928a445c603c07996f5a4879957ba06e83745349e590370e31d3226b744d2811ebd5d9ceccfa647c5f335d591911b7d0b226475f2c92d6e03c6ae47ea2dd3f1be3bd6c5d80f3e946dfda1d3925dd337e12ca8b27173204b4db7a4f538646322cf6bee7edfb342acfb47ef6a6c24c5b1d1e429ca990d48eec953e9eda350c52db90197abeb295611d956b526e82701f636d5c4762df9d3d2b85bfdbb10dbb97537b7be7f7efb38a0380709439bc822b2d8cec3a16b80da1762a6a62d69f1cf2b1ee29a2a5ce0c1d18bfba249ede5c3ab8e22ab8306e90a8f88e512b2a7e703af25f8201a3228c61034a208fbb659054ad159341a135b0e2129859a545d306718868e743d4fcc2b2f216c8db6054d43b19abfc1d877469e83f3045dee4192f41c523c27428965fc39992cd056e93019f1878c9ca3c1ffe3e1ae4d4dff72149ec44a227aaf3aaa39cd80eadc9d69c5f7012862ae690f06a92e450de1b4fcb2292d6bb860256f63b0e2b2e0ae40615d27331eef372f7832c4466a2a471477c37962f4abcace608014e5b405839bafb27ae9e5762600a4898f15c5ff1eb3cd1ea71bf4a13c04c76e2edf9951b701b70b63151cce29156fdba169c346637b2238993e8912ae9032252aab2db62649e267a1a414124e38c569b09d1e20548b8f2e685e01456d2415fb078294a2a5116e6c9a960d4bb99a59216a0d489e986f15d6360c46f5956f7a26f46ef7b29cbd18aa8b4cb3daa396c02d493d39a1f523411c638096d8874a975ef49b072a3c96e7950a037b68d7d01fb41d00a0751e1c95c9968627e8f267f4c874f04b4712a10db6f0fef0dce31a960eb4600e50bcef3819c7f2e1010e6969fdaebda6c08eb5ef918651a97e8bea8440e9284d37c0f211976e3c8c42597a1c81c94958df62c59fd06f7cf429c9ec97e5a1fa5ee1c9a60f7fa3e16b6b3c01d423475f434eb7fd22321edac468a1162509d29ac85f42e9b5b34f57408a2a30e1b959298a59b8f8cafb7d432b0d8312b27ddecca164dc540e387a3a56453266a24a763a5eb5c50a9cf2d44ee38b4ee76180662feb657a967225509dfcea334e6a149cccd11e3b40192cf923e2208661bee2531b7d89017d88448a4bde9558fb1d59617d74fc9ac256c7edba265e28d6125f94bbb9d37babd2ab2862618169898586c594a238d13d1112b1ce03cef99c84d0c5a41d592b2339b85b0ad6a512497299fad994a7172f3edb5f7c6ac6c52302a48c1fa51e72a1ef6d694e2729b84ab22acd479bd937836a102fce201c3fd7d6326f8e9a18cb10c848b6ffdc7eac2d82351f4c958237d383a1d2dac41b50ea76b415896f37b6eed2ffc11fd2b9c6fdf2c85ddfcaf09859aaea82fdd044efea52110779644a80f5ca91c6bae262c37f691d060d23a030410a44295c427277de9d2331c6d113f6170a49da0d07068cbf82e98006a2186cc724da99bb845a1055c357f52818e74864f5811c3162c34744f3563914698fe038f957035c5a9e4f3655584d82e9320da45e808bacfcbd4cca01228155d4e43e7c564f5657ac0cc20485340aeb5d86925aa4676ec713250fc04c00cf1f61d3f11801e5100be779eb32ccfb7e028fda429a37d0a382735673e9ecc37bbcb2342d1c534683dc634b4b7d1af0bb4f5399afd7b5ae38ac402629a0d4a6ed072c19a209e28bcdb8231ff1691a0aa59faf014f11af95c9ee74577e4c0fff307c7d4f705da35ea0d40f4be47121b48aa39689664224d10792b12e5e2b7a03538fe67631fbbb19541903a5c8be2b3cd0e4740c1723dc47cc11d79aa541c14cc232d97ad9dfce6ff3dfcee7d882b7a8b200dee4e5eaea50e80bce7af46911bbced2f18233ea676c5432f8cf33d216b32a8b8a243c312f31e24dc51f19750bb215cfa0be8df70180bc22f529ceb29bb33b1b6e38b1581fbb52663027a8720560c299a6c13112e38297833891562ac03bb9174ac832a29c59daafd05b58085d84835049ebc59a55c08a9587c5f8bec87581e87c530d223d99fb72b3cb99c52bf06dcfeb021a3c5e607c833af6ca563625524967a8325e46c4ade3d5ca0fea83b2e945d8cb028e62660ae2a8124e8330b02dc37cf9f397d423d2ff8da3a39103cb6ff4aeae137883867fd7376665a13a098262cd1b4a2c8f54592b4e7281bc127023a37eab66837063d899cc8af54b29ef297a1886aae96c2e55ff95e854c52fa4f2efd583e08641755943ebba26f9c2474b99267e36a5134053472eb2a839c411fb179fd4b1d38dcc83fb355239b60491796bf16fc007018bf8a4495f4b3e52a1f22d7d43cda14facd3c6f5988b655a8039d25f8e63580ef6ed33a27b2d814f8a278bba678679f0ace9a3807febe743316a8065888d8f2a1d133eae8049cb700a0bc476a81457cb5e56aa6b03b10cc91804aa3dd3e1e9f3e8dacd01e44cf6ebb3cb9e2b504b10c68a478a275fb4678c201a179793a09dc93c9371d849472522a7314906015b321dfe91a1b8466cb1c10393f757f9ec19aadc248f60df892cec37dfad80795d0845c054b0bccb3c3ba8e5a094e1a0d41566b8c18575418dcec5edd0c35a8c79c3fac5f67ff8a5dff71dede66582e9dcad5a3706d96ff2df9f3df3063c34abb7bb99acaf411d6212cbe45f5f4c00b52a62b69aba5b1a3a4569c233af036c0f4982cb94758760e561e19cfa02cde802be8411d0088b1ecd3d19fca4ce3fb3a46481ebd91cc6e7e81472ea8665aa907ff7a4815a0f1d906e81dd76e8578d57d7d051fe5c40b50be1bc33df54b07278e640abf2b22a182ae9ad6cbfde64c282e515565e0c75252af3f4304a4a7c03416eae21fc329f397a0c9a4b6cb48f9c241533739fba2dcfce623f2e6471b6b2f63482f76f3e6e69f96b98dc68f0acd0dda6c80dcf9c0ee04ccb9b80b78c4f5aaa58af71cf1a68d0bb2f4930afd6119ad82b3d071d98132a51e72022d4ff4a7c216fc55900d04b143a8f0761da88f374443a046865b62cf9aa10d0eae0f60a241bb979fc5946a493c7a6146594a7722bb164de24fc31dc91742edee6fd3a08ec8a13973e70a4599497e99a4515b03d8d2296dd30e0f731dfeea85491dc9cd382b213a1bcb5a18887d7418fb69f7e75ed9901a99ee9a27830a34bfbab16b7ef706de14165954425c0190767d35c19232e80643e394c53096d167bcf221926fbbd1d1ae2f8bcbe0271d7d4121c208c5cdef5cedabb43afd4acfb6907cd80b731ff0be80fb3c596f9154882dc53898d9b8b08b1465f4208c2e2293fd83a01e5cb5bac2a9774c0dc78878d8135fb96c4632d0dddab2b12aae409b3ef51c1eac184a0b2820e03ef949f9d0a330b715147a2e94741228fe0b188bb61591dd1c9dfed7b8ddce5eddaf3184c419374beac7641140b60f864f24e2b74e1abdab4e93fce8106edf8b62a2280c7b63516cb5d62b1119149e9065991f5b14d960b8226ac976a34eea524f6a265076fbb2819a3a91172bf2b71b135b495b48af629cb118e307f2d7d82c073afae6bc870b386d20be1338ea18fa6332c8924cdc54a0aa5a5eff5e0492f140566e2e27fcb30087a463b4b5c2917d7a339f6a2889c768f8a5180f710a00a4a865b5d582d91f6c3979579dfa360c6a802eeb3997a691efda218995b04055c7530ba89fbd50827c4d1833e496ee52a45ec560fecacb08a13b8a5261147f6b3b34ac36c3d9ee0643e8fa5dce7bbfca05948b3407087e673ee0c54149effbcda34041a1c42898a39a47d9925244fd8430c194d3512d69ba99a6c3fcb4779612e8660b077fccf9f26f56af1147c3f2817e82744aa4b06c26dbaddc4b02fd35665bf1a838418ac01fcf3b22b64eb2b25123e45b6418133c47e6e48069ca49bff2f51b3ccf44662a52ddea3029bb809a29dddc83503194387129bc37d5b69f02c2c18d570d754444b87f19385b3daab2d54a306603df1b009fd38fe5a4a5fd13dde02f4439ea7c167d4040b1965411838b2060d808d03cd3a6bacfd1bb97f2cb925064b2d3eb933aeaa120295a81beead99732d5479406c2a849276738161771a5879e31cd21be4de482802b679899a9a6fbc80f1756ac8934cd8a38f8921d0661265936325b26d425fa75c4309d9a72a6458b258477fc10a0fb565573c1e0145d1d4c5dfe1dce01a0c4dfe9b74602ede27b4e4b0b6ce183b980c708f58324b7581958f0db3b92d83a5621bd193ce941c00f74c234f14e5b2a89fdfdec84254349f25c11023a4aacb0d476212785491a8173b3a9ea739519253e44b299c4d8b3ce6fcae01588771564a30ce78d28f52192ef9a91f69d60611c33e18a66926441d505bfe5f7ff4d417d1e761124cf4cfcc668dfaa186276b013b7c46ccfde5cbebd04fb40c1c3e39cf8c4751318bcbc1c8869c7236948d844f4085081b8976cee799c86803a59a46c44dcc729338be0a4c68356c02dba12d2830d8f8b3f698c87d464467e3c72b2b44902536ffc1f79b6e1df20d0be7477826a2817b18bc8e62aaaca020a90e793ea58705831af09778eb86b3f7e5eb7ddd514dbb5c8c8fea1b46547a236ab3e7b13f64bf30b8288ad2defbcf5924045fd816bc9df5fb8728d075dac56728234f5814274e7e9f3ccd951e41d2bd692efabf35eff5e8ef05a00090da41f19166e9e886667059511c7447f8ec6606ea418e3b6d909bb91f69ca81931665c1d76aa076a266dbde4919f2178bc3ea3f4afc087d7bf4c35f863bc30132d1b28197356c6be7a164734089c9c105e9ccf05700bfc36f57a441cdc35e5a71688bc0840989d3d9229279d4b2c30ea97cb4f386205ac62c5cae085636c31a3790131a89d1cf8b76c3f73b51d4b86546e7fe990e17e8c08881337ec7b82e7b2246bfc9837d191d52d8bc123ad7265f9684f9d370aff3ae65170ca8dff4ccc8eb581fbe35dfd264dbdc29d28d8307f9d841ed2c4026a6dabdf725c6fc8ccc7996c4ca389d2b4d5323eac88b763b180fef4d2aa455970fec80665e7eec2fb893a3e8d95cd6f4df675f3b9c6b95a1976fca70be5f381d38f535dfd0b0a99cc909390d55b6eaad518a3974d023f41b9956cc622e7ecb5b7a2063e18e088c696371399399c47324f9a7c87dd4099641b69b3cac08d68a56d46bdbb8617f3ce0119a002ae49a2a84aa87f945bec733859671a52ab772aade8f9cbe683a9032a692dea6032eff66c1c2e58aaeb99b29258d9fafeab5370b7a9cc54817e5b6279e9affdd17b24689ad30717dc27ab880e649e7aea0b08d0e47ebf3de0cb9916ff592428f862059079e608451d639afc5c16b7ed0593a289cefa4670553b90f4e6e5bf0a4fe4b665830a9fcb68962e833179c0d39d9de66a6e203eb20b9cbbe8d9400fd4d85acd2d55982be88a4f1fc8682ac68d9b20afbbc32a732303460294588428586233740c74de414762d43dc5969f2b8bcde395e2611de79f0a066f04caf642e0f084b28437ee2377a2ef5eec3d07dd3cc904958205f1016255ce47e881b0a8bacba15554802e3ffedf609640078a055604a02fa969f79de1ce3e4c4bca3889d90b1310c09f9357747b96eb19cd9b61711c4e468210b2004ddd22ea2630e3c25bf31bccc6005bfc319876a03f8512acbe666f1b3f62b13d2be3a8c21beb747210aa5db2386284572afd6b04807886364021dff725db37a432f923995f9210f07a966edf2d968078ac9112e11eb3e8e948768dd1b3fc5a28f696261a6fff3da71648b9105cf19239e0bb39568c53605f39fbdd9fd920f76bf9218ee9fe37dbbcbb69013081f4f3b7f55b7c441e8ead000b3aa055b7ef4f08b313b0896bea2387bb4e0ad8ab8fb63011d82aa35eefb64dba37a1fc6b4d2cdec23dae1451d640d5dd069969a989cec7918b8255c35394d844c54bc0404bb5dcadc06a7d7a69e815fcc1fc04ac620f9cca4436992924cb78b3b82f56f6505ccd144f57fbf29c617d4801a73313bb4c02b1a49dd4905bbdc451e448478b1cd652fad85bd98e68f0ea1366a048a64287295f71af11e11616c768c38debc6876eb2ea675f71d0e0867652c2368c6172b2031c1b6a678eb45ab3a289d6d3d4cc6598b078f8d175349e36926a8f2b00a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
