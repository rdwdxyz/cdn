<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46af0cefb05c19c95525fcf9717575c95fc4fc0d54f772d4bcf4d196fd1f312f29060ccd6b7aab06ca4a976a471229ecf306a372c9d6b70749f437748fae39e39d60a0acf720695d912993c3a1bdc277fe4cbe736bff543997645cffb45aa9ff81d11e53e32729c9cfe502f57b7580eb6af64210780ff59c83141f856ee6c178181b56ddee2b1a96f8c164fc1ae49d9775858b1adff175fc5add5eef59546f4ac0de3b07e458dde35b6bd379237615bdb6f9b788009d18894f462bd7a14d0d595d83fd18cbf8030ad2e12df0613e61eba1ff7621d8f68a38a41fa1c2a1792cc28b9ba48dd637bdbd976f92c52cbdcafcdd65c01ea288c1c57e1f78fe5447be9bdfb4c1fbf102886bc10f3b4485bd24ab013fe871ea7143926effc93e1f82793bbaeefeb4c735da231b26ca3dd31116b2256a1b231d3f90aba73bec9cec28db7ed147a5ec5997c633fdc261c2ed8a5a7ea6ef0d57cfe801f96c59b72ce1ac3d6bb096539770e5902554a5107ced914945fa6b211825a63928bd268536eae9ff1c7a7a61b168c8a39112dedcfb98a09acb7faec1191f664b5fcc7ac8b928692f3c8820d43c80e7b10fe74f54422ecd48d9210b358f2c44b2bae0df7f724a8f0d9cb88f93a8c0ce38cf65aed8cc7a9fad52ff5744689916e7e084c25e94335c309161dd06aedbce9a8eaff63aed068d8d22a8f510862b42bf95e6400e9c216969b38863702e6354ac63f10bc5b77030ccf71068ce096669670f2d7f4285afaf170484e03c029f403ab81a868856516751d070a90168945439a0d4a61419c33a3b8832dc088eee7b6b44669049bd718fc989abdbaa72d30bcfb1cc501171dab1e66c168f9085e4372992e2554b55014feae8a5add68362d854de21da35fefc2710d3da829bdbfe1241b7efe3f9dd1db6816bd038a8a3943770c264f7844afb0c904116e6e784778a3c86c63be4257f3edbce9e611bff3e2052e34240086f3c88af51cbc8bed7145eae7c2e2b31d24d63cb715057b690eec6fcc377d1056f2311b9a1a50aa8dcea36a49009e8492310984b2f2b14415fb630552b1df0b3532902e149729c34964b809e440e4b4874fac8f6c7ce9267d0820cdf4ed9e5f4a32952b72bae0f826c44a7bcd9b31683b9ce5d52c3a91907ecb9e48f7e4fb388bb0fb4ae5bfc2b12ba9f91c6db59a20438397f9f8967423fd0910efef36a81cd915289588bdc60ff1bf790b8f1fe6807ca3243abc6da1012e2fb78659bdcd1db9979e2fd1b0831fd94e1538d3d7cf805e37e6de1e095aaf8f8f27a4c4236e6d0307641c78503604400bf127b6d88e112fefae9de6cc92fc39cf69dbcb4704af326b93947efd09f1e055fc5b41c26babc71c49e40872a87f5a2d68b1ccd6ead96c62f81a5dfb76e67324947872dc3b59ea614c9d25486696d544abfec9bdfc4c50e9ef5236c4b8e7a2dd53a81466d5a3d96ce3902cc0969d3fde77261826a507118b6f4a64ac713a21e44e4512cd730c7eee3b09922f9aae9fb384dcf41d78538f320025a6eb8bdb42f3fe7f50d19e7289c73f5951520baecdee1c7ed0c6b3b2b42b57ebb5cc9e396669ccd7cd7e772e6356b5a6202d09e283afd9b03e9b985afd275f7a1640bb17674d401723f160725eeff515f1cfba355baf55452f8823fb2a9be9a2c6b193c96764f3da034847af42d01cd87679de6f0f61fbd989e803a66935c7bc30b285420201c896246a46c662f1e80b616814c34ed92fdcc465b0505f401f26a0630157c3e1e8f9529b21e302d1b211b98261c4e1a1c976e15b6693e3719144757f362676b4253dbc33dc442af9e1b55747374692ca42d7eeb78c6ca70d51362f4a5b276ffb593c1f93162fccc5e66074a055774633a6a8ccbc40dff52c58384c3c0758def2fdf909120bcf6c7872afefa00d3b0bd9557609be6be167c1b21e165d991428221ad3d2285407b2ed0ac1deb8f0acf8a00a5c072de24e4bad34698a29dd1aeae7c4d23fbc054c0fa0d92d9478c83946d6b08438f73d9abd6e22cb88eadb35c2c882afff1d5c8c7ff4c20f4e94ae64e6fe5a62966de8a23bb96c1aab5a17d5e6edb8f879b4d58a9899557d63b7a1a843f7fe34fbad491ae214a17031c79d68d8da13124c1bd158f4d57be6d909a2a707151136647762a71896360476d64f306a574e98b8c4c320c2e9603fed1eee8f6a5d3af1d519c2ac031d80ec52998e075a579a81d468d234f290cfd8a0e223100d71171d2c34fbdc165af7b9b0d4c1572c2e504c16b02fb0002915f63d61c3f10704a72ad1b16c75a840127f7cfb866a057ffe822cd66043dd0fb8984f28176eb71633882b4877fa80a1dc12c4130abcd973fa9feb493bdad2873bb1d17b525a538d3cdc978ba958913bb6402fddcccfc02c8bd9921c9c0cbb514eb6a75547c5e2100fe74329fd2481ef95c0c2f226d37be5f430b0599acff4d4b82e5f10fb70183248c984c695e730610ee79cd02a7dd75057c1281a6d6b5f01bf195bfe5c78a3697d4860ef429ab20f72d72b8de0c91bbebdf156b02be91e669a6739fd56e8f4efde48704a922ccf6d1a26c3df77cc72cc2f19505d3c21bafc31b5385005231848f4c3e93ecb6349da2557deeffc5ee1f7af4e11852a8b56e201f01f517a94ec8fed11c9cc3601f5b4d5005120b27b5f682802c6d38f122421bbdf68539b34e5c5c8af9d50489fab3392a82c1f9722880f1a1924a59ce30e6787aa60fa33f970703d472bc9ee87b2269c594cbd4fb0294d7f2f85323cea8730d13220e710c2001e5bbcbc341859b11a62272561a335e19e8f4fea45c0fca4c7a3957de64d69a05f49383fe9ebfa228791a287779ff4f2b48c9605718027ee3d0538de8df7b9be45f18b5799a4aa1acf14163c6230adf615e306bdc51c88b404d48aff185bb0dc40086196d616795c50abcfdce20d0771186dbdc91863b11a240ee6431a5cbe672cee6c0e72b4582f6c1552280ea3e5d8a1bb0d09604b582583506f0dc36ad78858daefb41bece654e95dcbc0cf5d0b416659c830bc625bd70fa8e2036f6f718711ee31f9399527ee1a651b1113b7fd0e93b293a955fa86fc3ed0d579baa9e06e4af623fa6d00a2ab238ba5b128dfcbbbc1971c0e292b6f5590d282736243b5269e4512757f1220362311603dee5174131be8759a2dc9997a979a42e3b8b6104e3fdfb7ccde8ff9e64b0f1f000c3992addac4890bb898f1368905b76498757dc7f8b1704d8e0721fa57518563319fb51fc300f67b8c701c3a6b80a65858464f8ecec64f09e0a27425a9558bd76cea574c4f334c0e95725e933fad03035bf5fa1451a4437afd335a775d1d36ffaf0c75a228c381c2a3093728e8f708b9330e537c14f5b61ccb699f1b82fbdcde68d9d54a858c870cf7a25b493d291f35f82ebe065b2db15cbd56a4667188b634716dd25c279555e125b2eb4c557048509313e8e049d9db06ecb5a5a638816e2a3f0015714007992c160120e2339f577dad24b08669e672ecdb7852c6b6e5b370a3a119ae4b6923d6b7d5764ede902f0652588cb1e577cb6326037ec34020aa938470111eeec396ff006c04a8e2bf58d88deccab46babf85e8fae779991d68f2ce757dfa1bf6ce3ac4060c02af70f8f7813206d9144f64d18e5be0b786142edb7c19677c748a7e9a1d3a08388b0a37c04adcc77ffb3a622b78d9ee4973f015b8d88ca158de7284915f8418e69bf499a48c6f973b55aa15b7c2cae3d693c5e925d24f88b9839ce342949174b853fd5e6039af6d22dda687f431a1382dab28140c65a41728c7bdb3cdfc60c4caa6563ea4e9fd7ce888dbf7201b9ee9a6c2df7a1d2ae1434bd1cc0769e39eb78d49f09f6670c67e9a53aec0f32770510ab1c3efbf7d8f22f9b6499cab33ce4beb840785a9bc2deabf3d738769951db4ec049780d83c5a41ede1d6596a949a03d0f535818578f82eecf2cc328eb4d787368bc86b0f23b87a1410cf2239f97c96b8a67a7fda67dcd5144b320af06c0fbd0c5baaaccc64c04150c01d48c0b52e5bc608d7a7ed21aa65541a1208cc0d38d672d95bd76b79f103c4929efdee64a9133d3963ab26c51f7bd2f21f1eadebe38e93e12297742d0f399a217f35aa4f489f509bcd123eee7d843f67e98d32cdb1430d366672dabe6b9bf5de428cd49315d24ab887c647920520935c98d854f1cfde5aeecaf519584cead0b4aeb80ff70eb752d5fa2bef6064ff398af6188aa9f749aaa94c1dd21d05ea92fc2c9f4b0b7af88e1c6e72c197022902111b8c3c746754f69bdd158eb95b35ae805978d6f7fb1727acd30c47402a3001c01cf520abf1d36d11e1d44f871e57dd96b8e434c7ee3dfe53adedda84ca338b34942bc5d98e33b5fdc8f106ac67a45f3b015b51603fdc2b664c8cf0b714cd99a2e867e9b7242229a0b6a4d81295f3c1c9f3560a6dba5d4ad3143b826d013750852c0e1e56ead95812b060516b91b753e0f27d5332de0f690a27dbcb3641808e405a499c1a13e24cf81e03aa0edc591327fb6c14fc9e4efa3ca9aa86eb9da832562ad4994f296d2c80fde19b81849bd05d654b969c38a124ed6dbee99070e3674dbb6d69b012a23c364d67196921097c9d919cd00bc381aad035b63ae8c4132cd341924047afd7f9ad28dbd22b6c9228d98c3252fc19dbf459e688a5fff5e12b834dd98c4f7cfe9c673e5ab49e1acad10f2a395764c456b31359daa88c433f39a75bfc9b8b803dd731f16cef1cbe170d21eb8116b16d5b46b102d1f1343873f64cad7f955e4b7e4437709fa127d627733abac7af52e7ef7b7b9ef35a61438c31c7121629bf9ddd74fbe2a64c8f2ff18d33fb3e7045f32fd975bdced555435acab61503f4fc657a898abfa63e50ea0068bc7f9e60e0052544a009c543d495e48cf4fec5e602b0bce139eda7e39c9f8069f38d9fd91a551dbdec15afd5ec4c63818f2dcf191e1ba4698a6b59e58e837442be9104fad5e242686f91dbcffd36853b78923b3b66537177c89fd1b25ad9ef993ca1a389b1934f14f8be127c060f1bdb46c521d81222eb2110a987145699578ccfea0d1e9a6fa3a4f2df9f2be92666c68c536f08503fe298b8175940431b03f0882f284ff2bbe3500937eb6081f68e4092952b401e743132d08ef4aa9d036c99480a523043ce96c1f4d0312a318b442837ff28706459fe04f51f791b9cd766f4122f5b4b2f04b7073ca04982604bc6c8cda256484ba080daffc1006b72e3bd5e101e388e59f62a62facd12b91a86606e759c171b744dc35806082bf75e593f257cf7bf1b519ce2d198a00846dbd32b590a15f2c248d244c9d1e481ed91a691464c185b5b1adbcbef1c22a35ddcf2311db82e8a2cad8cf8097ad58fae49e8256a2637c756354d6c7d69da2979e1462f0b7964560c92f85c569c7df30fe35411239ebc4abf919f1bb508d8c2d39021b9eb7544c43630b20f32e16c1e01fe298e266227b5ff8a54ec428616c6ad4a698cabf7550d5cfce2f3579c8d76bfe1ff6392bd46b77f72672a96ace3d85d5ae988aa9bfeb4de9b436be4a85dc7cb052a78ad8b586a133d598e53106b6a595ef3adc2955891686a730568b6513559e02132d04eba1d29bfb22c86731116f279b2153eb2abbca2a58b9bdb0f2368a5485499be4c67edccc2796d6911ec99011d9ea18fdf7a5fb06a0e4756a14d2a8ac1aa8cb78a3c4cb37fab4435c2e91fc16236e94abd4f560c88fca09733b6a7702e3ba0c21fe70eb3ff7a5779d78abb865afaf41726eed8075386cd080e1ef22834c3b315251a605f10df10cd28a2a6a9d83a5bc5ca17a38a3bb21a16bc90ec0c62f9a9fafa9b486f1a7d2090f849840ae77890e26fae0d60beae8ea36b96aeb2c5c6d620033c8ce4efef5d0c52aac4aed389782c39e15324d99260eee9613be9eeb11a66adab8ff8554ee6869657e6d7733f8fa50e236e461048ed1a9890b8543d53df54657453eb12b21d0a247360651dc2b95aa50eb5722e631cdd7f7a495ac9a982a459fc832d3f542fdcb8ab23bf2e514836885615d75db1c60a9ea9d24c6026d00d32586a8ffe984481a3a87517b79a08bbf5d0f3e541b83d15ea5d9a8745c13e80f23730af9aa00f34f10309d56139d4b76fc2c4188af418e0e9c789a58888b123e1a60df6b072a329b66d47295ac29edfeda744c5eec5316795e3f9f7068809f16146bbaa8455d6fee3d8c5aa715af3a24647d8a06d9f9b34713b66ce914af0dcfc08cffec725e1a159377671bc13776f0bced9008ff0396b5216befc0aa3942419b4bc3bac0c109e4bd6e19b6827414f472a244d91a8dec8e09c225ecfcd8debcad58e0617c4a63b0999a9acdcb02fd73d3d9e2e2b06f7520d405d9799d195fa6e7fdc94b38bfdcf6f863ee101d965072a6c03ae677af579a4f0ceefcef899e8e8db2542f9fad00f6f290a10b000466ab87ec5571013bd640dfe3116a0327b8bcb45f504fb6cafdfeb92e1cc7c687695eac4338d9de55945e9a2090de93e323bcaa14d58792aa51a80559bcea3dc9eecd932259f1ffa4709aae5620af76a589d02f2c231215e176618f454072b1e7e7691b46a172f6b53e26544b86927debe852154639d7d965b10a686eda349c098d7e79f9635f4181040556b4b0a4a2284d9a54bfb028871d49c6225db0042fb45740fdc9c26e496a8bf14438dfce27dbfc61366092cfa73a5e29528f394c6404bd9065b78c85121364470f23afde2aee142f7c8b0a751f64f6a2a75d57417af6404295fdce1fba1b84aba715633fc5085639680e9ed1152f5934b228f4250d55569ba8e8c34e55932c3891be98fa36a64989075aa6aa1112197bee31b827f89d40ee56c1e3b1aab3ba9de5b9295f0ad9b209acfabc314a28c14540c55eaa133c2ca38ca0455659ae398606f27585bc6fd348e29a670a27f64d7d4b8a093ed87f00b5ce02aa5fefeed32f38f9da9fcb035320fce4e6e0c6d379a16387eae25b38ee293b4da182278065e9add552a3167c657d70ac2a7df35b711503beef09afefe1e7078fb28d271d383973b524ed6e2fc92dfded71b684323e8449d89662a3e6e48e942fff14eeb1ec16b531d6a2dfdd8f9973528a573b1d1755d0cfadcac5e070dbedfa907a8268a35a51b3ff40ca443fa58061f7c74d86c6a8885480ff9a220763c0283378a4ead3e38680dd1f8aa438aee1b72aaa312e100288c064d7de8f11c22b57ee0df3a21dcb9ec3935a10d200736385dfdbe3a866f953ce0bd1140e25108ad4b5e3390e5c33614f0267f1b780e6a99fc4f39e2905893797ff83b4761d61f0adbce27a992792b9698a3d82569c872f418bda1b0a8893bbc09cec1c2b851918100428fa903622b0c09903303abc907281f70622017c8b84e159b030f432599fc22953b209e7e2b308e2e905811124e6c6e24113e978bff4d1c859161e0d5d4ca167406cdfe12cf00a5f833016cf8f1d551197f8f1bf04766b5adc435bb77e5de2b6b2ea23e610aa19e1926fe4e9c938bfd4d6e0cb3f36b8206b990318029309601a94c6adc3d2600951a852093b9dc836a04f9908a63c20cf68c0788db4dc67a15ae47d8b56d1d9bd1ae36125a569dd12c07f96d799583a562580eb76feafa99e3130d8b5dd17fcfa16cb6c2db255bab9215e8ee79aac23c939746c25c138c092c48a84dbe96023d46449a2b954144c3843336974770a0940a2c7608d3e74211ff0a9d5395f34ff76728b641f6cf2bf68373fdde3a9c0bbf231d45e67a64b42b457dd9daaa1dc135ed136b3b2f1e09548b09a4f9870e0aba26e5a88857fc32c1dc9cfbf17ebbc50275e1ae5672151b86783061dc624e1c14ba114a5b1f8ef2687f62bb74d69f6622128a9092ae1803a0466968a0e33de97b8977e4177de26c4724bc2570dd5561e63d09bd6810e08a4677caf413192e7c689b00cc5ba81ba11ba8937fbce19e64501fb68cca0c65053e87ad49450244856bfedfea19748ef44384dbc4f12f4adb354ced237e2c96a7d3535dcd8f090bb5e4268d078f92dc350d99e2ba2656d26b8c43dcdbeb2143309c96cedcd497ecbb77bf14ad3695b266e6d08a0950716dc885bc740c337f0c8c38103eb67c4bb5025f5d1f2189013f9c421ae79cf4298193d94104e20f574a6aba6f0e5938ae234c01be48b78c8ffbec2a9e91023e1429bbc59c8e03c31d16db1414ccf6f01c95dd25d0abfa1f248eb6f0ffcf9f567e9466e577e95527f4d5bea58098cb4cf415a6064fc6c800c1fa12a3e29ac38e1ecda953cba088572fa3e5d0b863fa0078912678356bac3774b47dadf944c1855dfb77a35f29fd06fbcfa8356d2dcff8bb1c8b3939ebd21d411407ff3fc710badd1497b838242d4e1a0d56e76f823be8cd524c749f048fbbca3874ec6d94deb1d0ef3ff646b6b8acd4f46119d92cfb7a7fa3beb5755e1d0e69759ee616ce35c497d8b6630287c10a8ea5826fbb799588483a55e0733ddb09d840ebdc198ce1bc28c1675cfae9f8058e9ce013c819408d6b6cbc45ad9f7b4fafa9157b3858464ae925e90eda7b3d3b775dd672dc02d3e4162c4d5719eccdf4f40709ad767745c371c0384ddbba32886de5e51a485286c6e12861c08ac5b50b455cbf6d88fc1611e33e2b74d0cfce881560b17219421a7f398b48c55a9988b73bdb18d3373e949beb87e0a3bde06b3a81d4db316364fd5f4541796af7dbc5f6b588b433a69f477c6ebc1d2b0eda9967c348c25bdd09a1ad922015296e8df9922d82bc067d2c1c727e1be0e48b3f46424c40b3b882fd4fec2ff146b3dec10bde8078044317602a772108e89c5e3129129b58f869d745889cb063d5a6462f827d6fdf9680439cc988c69015809af61e3275d569ed96ffc3fb485e29077223f2dba8bf0e197c32500a808014e4e7006937262b99b3a9115e7dec423f2bc271f28d9555833f71b42b87dc563bfffe8064a825fe76a93ecad260962965f6e0a3ec876ce5b8d41c7f90465c773ffb3b4ab5f61dca4336d437c688b59d03d5c75e3d0b6c15126428dc561670d7e15b9ff47bf4a61f07a5d72fe4faca4325d16f1e76e6863f4e7e8affb37a0e7dd33c6c4f53ca2560b4e8bf14a46ca2c3eebcc52aaa9b7e12b7ed6eaa1c471c5380aeea3d0a7ae082ff8cfd428ea2c39798644427ad4e50377c7703d033acaf2dd92313897e9ef51af845b4e3c87282fcf098e6a45543625f1ba961194c79ed9995cf5a17d9dff5df0b98f5dcd7f93be00eb2a6942aebd32c33515b338af72a0066b19e6424305eeb54d7653f3f35eef36b1514fc180ef0d95f22b90d24c4f8b2f9c96c7279cba725db93a067f3a0cc58a4c5739589845ee8dd9810dec7a7a1db84c09e3a8b33fd0b42464fdbd0c33aba31dfa7e4f7fa452408e65971aeec00dc0095b36cd9ca1743f9f0f14a467178217c155d583728dc8a729c5f122e47049661848b24b1cf8e27549745cbb2445bdc69518522b29a469932e920dfcf775433b75cc4d003b2df63f01860a71b3ad6b8044cdf8039faeaf491492118d1e529fe91a245bde08d0d3ec6c810b6870a56cba7ba453f6a0aedc25a7838fcb5dc44469e9bf618fcfb2d63d1e1d6de1e7e4fd1b9e19cccf06648af88f59265e5a1172e4555d2ce1a8fc0550989cc6668c5c7f319c919f82b7bed4756aefac3ae9d9a4a9ee9e3e484d807972e34a325e78c534512e717ea056d567eef0c4205399a37fe07fa9935077f7614d74e7c375cfb854fd2e60b42e13ba1c7df905ed79eb0be2c90f23c2ef520a1682201aa129ca129596e4a3f8ef7b6e945fd49faa49fb014f0b5c072ba142750c1bf4f99abdba7c64221cf5a9ac4147f62650fa701ca12b2fe6c1d08ce3bbe381edfe9fb96ed8658f69eab3294e195ac633dd31aa589b048941da1687df9018397810ec82605eb87be8ccf674a24eabc7e3e92f0cfd195b6f55b8c509db354799a51bf9c589e536a0b5db9e66fb88178dc9f2072a35ad67951d8f3de70a5d348176a205626997c19ebc26a6c87b8b11bc953c726279f8bd233a2d69620ab595db1f07a88c5a55de50f1a11ac8c51a5387be5a392f0e2ac6eef51d5701e3af0bb2a2c7d577a3158688d87f54e4bcbc88983c2f8dcffad03803d345639b048c1c58f5a42252d475868d895868283178b24e1c30cfccd57daabf554fc046bf41f0c07579e545ca56b4f71eaa7ececbe213496a63172ec15ecb9e973007a4f9cd9ad6744f6f1303f29fcb4f81b927805bc1be9c47033409581ab028025735a2458a456aa1a2ec62081f9a62926bfc077b0714c4ef208d72b1c56f18c1555d9a27d7a8dc9747e1c2be0c86702606537daf57aef9fbff5e39fc3c5a7f8e6195d890a026267f96b0ad9efd490c5dd4243d39894ad7c22ff5252e437d2b14379a0e0a9bc9037aefce0e719b6378620e6ed5ae0ccfd715c851773b1a0363eeb830891d0a3b16df928c48ea384ac91c1f05882a6753608fa8525a0dcc395fcf7ea66e772d62c1e479f81a11813256c774edb28ea1bdd0624cac85c4fac039615abf889621693e9b7940ec0c528b78698416a8b24a00a566d0bae54ae31ae9ded904935f00496bbcc4f034e6dcd7c668c7b48c53372b0fd7f2be0cb301785cc610bef0404729dfa3e7908f4dca25a87aee90b9ecb84e5c79f9018b264d049ebd7dcf3e9af13aafe761c5186fa1aea92384de9df713d63daa72497f885eb0b012617f089df2c29e22fa1734b8367c27f1eddb019fff3ded57312cb5c7d5c13963baadfb05294c77c6f31f68fc80513ede7f951864e85e927507bf4bb7c51634ab484a4d7b532c6720c7e18bb8299a709fb747865961ecece2ed8e041fafd3e137bb13d3abfcce8b004aaa873184b495d43fbcd514f1112495d4f90a9c0bfa5a0dcc901b52431dae294f92b473c7361497ece146d042382398b14dd2c61259c65b6a2e06fdea3ff9126222456e44e38fc1762c8b96235973bb25913023807630d51d29256299f97ed9ad746b57ac17dae03d1c8eec06fcd6999139708f4126f961ea095c68a8b4513c57860dc1b56613120e413a1473c7d22cc497662240fe7228ed52f5c9a331697629dfd3ef793128cb32d5995021af005fb29b964c305bd1e93fabf6b759f4b2974b49ce3df7c55f268096a104ba5625b19212a3e17f9a95a37f7299b646bcd344edc88f3d4e31e71b08bae3b9e106975598b508fa5f25e37d040976fa8684fd42609e004f2e055a353eea2f338bb4dcf81aae9025f070d721561017e6b904dc26a0a0c83f8f46005689091daa3585a426f5849d278a910128d39b78789fdc8509bd1586013e0a9d2d69a5880627874e86f248a5ff72ff95afe948f0804ceee231b41c44fc1e8e38af464cf5be9033706a04d7725aa385e9a0e9b0d657070fc9b874ac819ce909b0705ea303297a4f6f42c58a728306bfdf99db770d5fb59c470f8ccc4675ac9669ae99f5f3e3bfd0ff1a590c47aea8d4c14253447c4bab9ba1c121b33309b314e027efd8a0f1ecb03933b5180d757b1608fdc9effa06adba73d9c0d75781f88bab72d0a821f2a61f41f8986b404d9b70941bf190a76f7ca186125f9b72b5f3cff6cb6945661b8a28a24997282870ebdf25ca9bcce2f1a3a52127bf6d07a031a6a71996af8074726707894e3b5cca010ae5cb3806e76712d7077c90ff9091d6222babb7a51a8c9a0ba40c4374de4c658d3a2987c62e7a71149d8dc94617768d2e5a4f0bdf783556ec024a3a144a8cf3717927b5c8103db2fe773fb45633dd5bac71c04996415996e7baea1814fedfdbce546f25ce636aade3141b21d38e9b04588e452aa1e780d15e9ac423e812ad8d182599a09a7e7f430f1a5166c09f1cf1723d8d60ea5b9f3ec8507a9a94a0b6219bb9f8924bcd76f50b480428533782daf6fd3e3a7d427c04afb95c7ede62ff9d1c17e6fac37a5d8ee1234f6bf6b142503b38772ee5120d3e46ea811c5ef8a67912e9387cb298d4da7318b93b0c364fd3cc4aa8824cd33e912d155923f5508900608b89ca4786bf415de60d67f29042ba2eddeee3a89d264f76613b31de5557359ae5b2ab5b9737abee0e74dc3e79feff44b9dad0bfac7a5863c4cb4cb01fa5a8cee04356ccb3f2236f02673be452b9e2d916f6c7dc1facddb44bfd593480f45628bc8157b3d223219274fb0f404345525b0b82e5284492f2171846ec27a87e77d336d38844359dbd54e38b043b458ebbfab6157ea6af6e0d2688a619d0bbb1aa9dcdef1d7479d9b9a8902b4683cf15d1b927398ef04a72b215d3a5013a6bb45a5e2fda1b401a1c86266422eb63316a916cf98971d043b1a30c158ecd591845f975620d08f73f7575ed63edbe7f90ef24e9bd25d590591cb2209e95a10e1112ae2f2cb508b5844a0c9ae549eb375bf566f055a1ef2bc809d95ac04a558af2ac1d50dde46f0baef6f1b252f0f9518c3bb61a1104a13eba204eb0fe4d69fa9504a18f60c73ae243bb8074bc00252f7602a324bf7944b640d2b4a26527a5b7a07454987c62cd9f29cf4931d18b0c4b1c58a10e0af91586d383c78337ffeb6c420ab260054e6f29f57e656db5f7408aa18e79e4f2ac7863887948e82ea576ffab676f9bcae40b905b63bf3788630c671a33c7cb1b997743db17d565c057192963a6694a74c4e615574dd5ba760a4f80ae7d2938ad191e943b16b120ed6ca0b07defa47cc7f3628c3f5ba7a6c0d1365c8c22ab0c1495093f5b3ef7f131fd8dd0bf252918d91c110faeedcbd013057dc7353e1be504de6461fb45b280786de5523cfc98de2a219d2d6a5053a786b3e7e7c4a720c1365d8a8570c203e0c043eef711259332ed95781ef882604c5b188c1f3c2fb363b85174445a5cd4294d9bc8d26617e462ab74d7cb217c2598169a26c53baf62dc432e0701c1d0a8197b0c2329fe7cbc226d6d7bf594216a8ed9257f2e7919f6309c938696bba84c435dafe9f3b527d45f61d9d30142ee71e6292803fe2a32c42376d881ac529c7c3384971ec971f2ced0d52ae91d479d82cbaf126ddcdcef31aab285f38144b40bf3c741e6e1ac339f8b64dccd4233a679bdbfae159fdd2d94067b2bfef6c51ae74c39e7ae3cee26de336da53c34074609ccdd1a13eb248560adff73a03ef6af3e091b15a97085f80d8b97aea2c0066ec34f686cf6b4332a31ba92cd1ea27f0a6c7d5c668152493eefe597d8d86939a3e092cc26a94c3435b50240ea1293992b73b834436fba3e53eaf5497c6c8c0535fed094dffd391e5c857958d9f9632b062c02b7f38056c2206451164e6cab23421d9ce496724935ac2b5591080167024ce65cac82b24992c77b901f8e3836c02e579fb0fce1d084d12d24135e29a67d5790cedd7488dd058ffe0f0d9f7d372c6ab157039d684ba2a478dda89461893552dbb5629f7e99195269021a279b09de5eed06bced1cfabfd4e7cf9aab8b91d238c6fe35f9fa53a3fc318685a28bfdb9e99c52123f9291ad86f16b11480d546933a2cc853f0bc297bdec9e98ccc92b75b37842b89b531d2639cda01cb0ea6a0fa38cb8b584900e8528bb82871714dc1844e5574d3c49c1af37973e6573a18657342ebd51ca0bc789db50e0d228977117a2a1c21454cfc6c499273784d7d7da67eeb3ea8685f802a1470119a87b5c8bfac0889d2904db3cd169dffd84f5bb8d02655de0c98a101d09ecae352d723e7b44eeca5df8b689484ceb17da7d8f7cccd419dd7a779b470a9c434f1987e6afad885c0f90f750e6508f941bd044901e7ae9e3ea1e1ca0c93ce97e6380a66c1cf2d5068bde6646a842b7d3258cd58ec448b8447c95b72c7f25977b0a2488cf3be27578ae836cb8ed3fa5686d46ab2d05ba43e29429d54152a579857b9160a6a2fcd4f3fecab9e8d1e951c277dbf22b6f169c967d309135001312a287677ee426ae1f20a38f54f2a4b2a35ca3bd30cb661e6800add7705b2f18947967c59e450e75ce25abe8b95e535c7078804d5e07d7612d81b0a840d9e6570ee385dd8eff9b06ea25767980cb3559e4fb076daf54dcffd4718282ab2412444b6e87fe27382058e0619c6442fdd7fe65c066c681beefb206e765616c8b7c143973769d8411f017dd76490e263d793a2b9c88a5604d537a1ac290f80fe46aa1ee7992dc7359a7cb2ab69c683fc1e5d2ef0164c67a938daa05e012fe93680e85a32e16b3e5946f69778eb717c94d6de0dbc2c0bfdb450ef0034eb5384de9a0bdc1c9f72aa4113980c02d41c857dc998e12b76ff01f3d698741eb6a4081ac9efb678caa7c7847d3079cf3deb59a6ed3c6f9b718a406f55afeed0fde2b16e2d811354d1e3acd36d6789de52798925116c98e0935feed9c8e1050cdba2cc6b9960af7e3ebd6a1c2f895b3d0c06abfb42b9d7aeb50bdc1e594218ecf52d698a290e9cecfe39f2901351e223420c035dc398b9ca0eb59642aeed1e510f59d7a9d2f564caab20369ae3d461d4e9b06ea63bb5b28ed9ce90969979e3419ece9b460ad371c8fc09015c92143b4856faa019d3de119590f08a79ce49fc564fa97908476148ce30a0dbdb16ff5beab7c7c34d48123a9b245d4907c7d86c7df89be70171a356f12e8457168c170de7753391f097b3770f4ef541d1b32911243eb1e3d9bcefdc4b24495da0110d99871e0ed2dc2f6a2647a5261d4e87e8f01ea548fa7c9acc95303298215910f9d5a39c8d1df5c6f7446892df443027a4f0cc3198a10d25c5dd4876643051843633bd55149490b7c9fb9d1c43b346e7509e022c14121912fca873699f1ec3286a2bc58fbf957c51f9f2f89db28347ef9d564ab8a88870c269ecdb9305ba57f3445aa8c8b612ea4440de10c47fef14673f34c574f26038efbf61db78fac9028b9c0f49317c27a0724f9c3c09d6b4e1fefff3dc87537c7bf24471971ccbaba6855be2f4b049f2d0e29ce03d90667cd2a5cf7f0c3dc5998364ad939677a97f99421b024cdcdc6e19996af5ddfb63efc074553fc1735b3328e470e167232f1f15357041495f49444a38d5fd87132f51861007e4638b9c6cd4db1fd4f2ab3b8b57f7cc7ae5b36266b125cca4f6da341084b2b299d1e9bf4668c4236d68f60ef3af4bdb75c5ada79c2a5a2e73739e90519139a05c9659e1e7ed546b8fb9439d5c8a458a0a88a702926e6b9fb94f442601352a6984a3e4f34c9540f2ec38b7611a1099e01f3cae585918448c2550440c56e5137f96e7d8f2305149d4e62cca491466069103175773ff1c12da42643cab90a8cd5c4c7f00bca5bbd66341ff9196540595a05aa451e3bf0e5cb483fee483fd9defaec9ff6b3ac89322bd1f06a6200ebbf8ce1a02bc38d7938a02ab5b791954623961da3e54e5d752f473ad11991b414ba1606c0746a36190e38b7a4f449a39af9e874045ae2e3b67f25d65c55a38d76cf2a8ecc7ff733ece1cfcae2e22419ccc8195f449951de67466b7e0f167ffb7fd69b4748a13f0d04937ce76996e043e82b9d8b3734b7ad16ffd5c738d3dc4c0798c3853751e2c851dc9f58fa266408c6267859c7a8311ae66077bf3cb79080baa8705a8f14450ccab56fb73d8f25de0d33aade0863a43ac541b126bd8edcfbe07268bfe8f000aaeeefd01fffe2512d1f8b1a1e1cd82cac794e51b279cde881fd9b326aacef56abc30d9ec1c23b7fd64dc01f43dbc5a52a31a6d696c4847382540f7acdf578d282706cd7a691f1aa8908ce74b8921d35731bf116a17729f69f1425f99b88ca185932a729f53a959f204b71204a80c4533f53dbaba4fb9a40c972f84a9763ccbaa63d4ed803e18110b07d970bfbd9c95434a7fc1f18e148b7607db7220657a5a82ed5694a4c9d6d847a6e18b36e2533bdd4503af69348129c283e3a7dcfc8204eba64566a76b3f1bedc74a6b84e15696e39369a7d2e8aa8624954e09bd83e3d77b7d0d360414b00d5e00103f9ca7467d286776c5b884f61f9ec8ba1f993af0f2724104af764b7298e997960c6bd53e328eff7c25b74249fd2672134663235d3d2a483e02955dfb212e4023820d0ddbc933e24091579d1088db5ade141031b613bee6d906d492424b53a48d411e747f248330f45df8b603d521af6ffe68395c51c8416e21e3311bf948efcd80042a99fea04121b51c0b8a841013ad7511cf565d567219a47e9b578d6977606c6da2e29a0adf1945c11de795a0b9479a67a2745f471400982989b5df179c62a7df3bed511345125cad581c7265dbc9e84c1e6b7fd861a7d112605f0dc993aa4fd0d1d282803894141d991056cb9ba6b65d1391e98ac8a9b375ab5ebbdfb802216735028595398ad74852176c86c932320a3b8e9e0b34d35e7f502e0e601077468e9e950f5018b161967a8e6fe65a4e0dcf0bb35f9ef4a490c0b7844409a757c6da8faefdab52caf3a81795ccf729e0fe84b27f91848668c60cf57e452d8e86776e3f521aa84bdd0a4788556fa7daf1985034bd444a6ec6d56595509082363584c7d5a0660da17a6600fb5c99107d954f82fb02d5bcf6a65dcb6d8b12c2c3dfb1d465c8073bb1b3fa58dbfdd616df634afbf01efc55f9b7af59d99a1a833df3b025918a9ed840075de00932679d6ee1a6a8ce29691f5cf914063fde151d907f4ba9889d2d34362d24cefdd863b3144b6adbf18a58fab0b4af32f869db38838d9425aebc8cf1406f18f60e02a44c46bb0ebd17f1568fa3329098ad72176dd05925224ee4bbfbd67a4365532cc0ec4c02eb0e524b76e7fc4795d69137095e7e01fb67ccbeef4c707c4a11fe38db3344816e15dbb0c2b0e86d1c8df49ab03869a5c95e8d9b7550c72de28f3b5fa7e6b8fb3ba75be00f2461a6416267f16854678c5b8518907119cf8d6bee74b5f3ed1ca7440b37fb2a9d9e1cc9d95459e4d8667a217edf9e083c564fb4b83328a96e3698d960b2099b4aa010f2be52bab1b505d39294ae9ae0a55ee36d267858219d53f76a74b5e1e6c107625d0c33b5303a20824d49fddd43d43a664698539e5acffb13b6a1ed1bd19f3ba6a8aaa3a544bce07c09a3023891b5d4cd03059884135289a114d400a86b3ac716fc96b620c9ad4c0a276330b7f0fedfd4b8b07183055d7499c77bc66c6fd79f0ceb718cebe16a0b4ac18f3872738d8f4b93f3d3a755a4731bbfabfff5e721f84ddffcd62850feb82755de43ec91171a1b85ba4c4e6685c3e641a20c64d77c34b8cecf238011fdf9d6375ff428b45f8ca703c37d8e0a37e194d6c10573df6e0c4d53129a050b440bbc28d2f3f0cf801f50bc1bd5c2f6df06046ca53a212a46360afdafddb8aedac5d33320ca9fad03c44a4fe4084e5e8dd5350808418fe4b73c77188dbf37f7e304b5a16e1999f87b61055515cd061b256639b84dd94b8ef2a180929e0f50c9b56af053d71ec7f93ac5c10b6c9e1adfdfc2156ab916bf541476382d99d084bfec4b3bd6f09100221979ac0e357305592221323ead95da81a90a2b255e38ea635d02a98b00b3c138bde7a3e74c6efa52bfb08c298a78ccce02acbf794e1268bf1d7968a75a67072f4349ed66888355448298f15eadd48b3a5bbde49a8c7e56d56791ab96bf985420ed4acf3534ca8c67327df01c1ee81640285922ab0a50ca6ce376c6909a57a9c6288f0d92f17982b4a7c40dba9433a75b3066a6d1faab31a66f853a281f647f76baed47183377db12615e04d6277674b7c7d7d5fe01d46b26d577e2fa6a8b04ea0d98a995d464838d323bcd8abecd21061986755e1608bcea2a346d0f53159c90bad3289871405fa7326f9084766151d9d3ee2a5f5a951cdf1741b1d93e6b85675043e0ea52867d7a446174531f596d3ba604e1daeef8cd4e9ac35e07a8ab611b6765f330d831913ca7e07dbf75a0b64193d2b70a6dad0339cbb92aba7b8edb50180a02af9807747a25342dcae7fe1d2cc383b07b559399746ee4d3d0317c5faf9c518c73d9b5b6a5b6117be78ba5e00580741d5fbc8183bef0e730e5a4f82a5f8798c5e12207d54be65a182d89a1cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
