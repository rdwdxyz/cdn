<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6b0a8cab0facd6b38877fbe890b5952ef57220872c9deed5fe2c27f61d66acfbdf731d7d53894aea181a4d000f95220dce0a7af0ca5bb8eb7dd105c05dd21a8c83afe44c40dc36ee39ea1f40a18d1af522f8a7cd43bf2f0b0f2940a06ea866c1bab66761ca8ad30dbe8a1ca7653cfaf185810b86674512898dbf902bf937221ac51bea1661e479e9228860b8f71539d9360615fa335de06fe9191c9c65c9c05b6572bec3165347785e6ba0c3cbe1fafe06c7c592d393a3db3fd528e214fb3dce02bfa29e43296644436a14209eb1617419e68826fd4f799d97b38e8b385a866a72d01c29bc1f369aec1441ac8353501927dc7f08cac9eb2fc30ed5f0ce58f4c24a0b0176a62c179cb7f9acc643df4d80799ddd9e051f8ef9836f27bc51158ca7469f1507d541897bda24d21758e6eb13c16f9d35a677181865d09d92b6475884eb4b8cbb5c91807df1e6fbed7e9d841295c103482135a1872ceb3645d51d65cc1554e712b35a2705bc547e3d4d83bb397297822d186f95cb7210d7f3a868d39e067bbb91e033bf5cb3ae7f8f5b560ff9db8a9542f03861ac2d452c674b5d94823146113ec8433d5e2943d04f9f79cd56377f2a7c3f9e02788918c1ff9e2b57c00a2e2d7105acee7776693a824fce8df0e4d7366828615019b23e32e6083459aa9cc54aa7b9616f0cb6b436d5507b94a61ec7466f47d4fa103d64ea217b01c564ab3a89c266e0831cf633677394176e7eabe7996279dd2d2d14c106f56abe4e04db85e3199d8a546088a4618f4cc06826b8434f09c30d8bba0b2ebf47dcf28746503edeb93b9e2d37f093642fccf9b7ead13d2adea22f76893db0ed74e6a3af005ddc1e9469cbc0130a1c90acc7063ddf5b46550ef80c47a7a2ba7e6ed6a8f195ec250f49a281ec0e7d7e8d11d25698120265e74f245f0553efe6dd683e3ab037d286cc894c81084f1c5eeba681932f50e2dda07459cbafe2e2c8563bc469224d7f05e4fc36940dfbae8bf7d8b54f6849a3f2ee791e7a78fc92e217ea464feec2a32e4ee4aa639e78dd6fefa0bb95bb50443e72e93cd0a41d35d6a188d1c51855e4b106a6c68f702f9dd4c27c896b8b5a0bf7437049a25ef82fe9fb6af88a1347f3eca189896ccacff60200bee44f053c9d75ababd730dde383ff104eaf352aad6405bd13452252edb44b96d8840fc0e26e252c4aee2905e5ecfd45058dea4ec9a5cffec8e06a3f9870b973a16f7e35af6686f078f06fb65a880c425056ab915bba877dc2a77b2ca5aa9f45ddc3d72b49c1a4700922630307f74d96eb57a445859ac70e17c3b8cb7f7a4e55d1c8430b78040aaaf9835ae8d912f898aed09c390149a75db458bdc28af5716bf802803da637e24de1bd45ba727f21c3cee511b46f9a62b3fb86e4a11e219b207c9116a6f19588b2341cd226e78812462100c13a04037c726e3565b10ace88abe1305400ede710808362a09f944bc1c61837ca4e549626408d101e10b1db44b266e903e2a7f0b4173531819f2538a3807c531015880ed2a14d9edb4bc97b44aeea39b00653c53d51b4aea1775018bd89a3723e0b020fb678d8d920bcbb85ebceb7368c3892b5823255e13abda5f99e550acdd9189331b1ebda6aba0d7a9248cff3a9e3f3bbc4c8b826c36ee33402dac83afdabb3929e765426bf957617713e481992a37aadbe453c28ece191d277e507c4276f67bf53bf6d2b25212129f86c16a6b83ab72be39722ff111092a2c94b2c5f2bd1a512f4dd21e7a8a4498909d56f281ce85155639df72007360a9896a4f4a01d8012305c53a1d8b0d6f779a0315d543e8a5143f56af0aaf54eac926b40a212fcec3903f2f9050e747180f418571b06aba3c339b2e7cdd5b1fc3ef7590c4ab7b0f7cf586cc91bbe61c68b7fd8cca5b9d9c0f546e5ce68640aa18a5267a2799d6d23f1ee7a7eee759014a517f50c251bc4a3213cb6e9916e8127c82a68f65163bd7b8be1803680b13ec346f0876a712455ba077dcdb12c4e2c02ff145a9badd452cc51013c588bd2de03e7ca34a28ab2ac53cdfb7a7619ed3f9ee4886b6193c53602dc93fb56ce8cb10111edf5f2f3e2830ad2c417baa672b58bbb98d99757120db84d2e63de7be837ef08f172a751da940a6acf0d0f91963b638ee106416504a7ec9b936a1943ff5e494d744f325ea23551b7ff4d6ab60feab0e9eb8ce6a40a649467ad509cae1b956958207396dc51cc8be9d7afbf19f6f9905c266af1bd0f5d0728d37ca614f3c8fc83e877ab64092401ffe0b3ee4464376f70a43fa8e8d5f236d4afd6026d2ef619675adb7696a9619bdd9c0946146f3dd7207586969b5aad3af80dcf24c83b4c36a4c704289014fefc77547ef6ec32865e77b5a78a031b1a708eec3521815f048ba28badb9d0a307d79e9832ba95b5a6a58ddec3908a6d0bda3fbd0add2cc4bcfb00d28537dabf4d925d2d6d6856bd9ed33547aaa8f20ac4d24dd3e87a5941e16db94b28d125870640d19e7d646dd44f113b09079a61ab6f0ec1818228202082c0545575de3bfde1da83924f83f94f221d8fed27262af28de9da571cfa8d6fd3ff373be113282d6e11b5d17cd6d2d35f2e5e25c95e3e9fa7a2f0a38cf6d1a3ca5d8f79234481d3ee72e06b9954e8b8e9cd49383b296d5bd188fb17103c3d84bcca833c84d9a0306d55749e0cb43dd5bbaf316a88298712c6b00d42cb8f6f546acfb0f4a694a84c8c2c960e8541aa5b79fad5ba877b861482a9ba05b3899e46b53d3bcef125ce19cee3c4b5a5f2a0fd1fc442de72c214435b2b2d592dbb12dc33507dc98d59a0f45d1c3c63dd5a5ba570aef750a2fd2187c5f8d68359ea7cfd37a62a4b4e1ce714991727d0d1d8711b2f94d4631732f57bb27951c9103feeb7adf2e587794ad6f86d2b19caa0bc87f5166525e84a2b37913ad61d6aa2351a00424a8f1edf367df438b16a4983730ac0d512c3324c8b90653115984cc156702123442f0910b69c69dc8ff0b032589efc312dfcdb34c0ec0e288dab900caf4b3fcf9955500d13c4f6b1cbf8e08104b918c0f583bc5d88e5d897a4ef69a796319a796e9c08af2c88599174ddb0218a3c3e9dc1083679443aa456526ed77f9a76cea433b05a7f3cf0836c687aab6d718320338f4a66def1225e31c86b71d2c21a780153622d5128c5eae081e7ec8d8091bd01625ab70851d5dc0202fa7b3ddd7997fab75f0f08cbe5ae638bd7ea93653f10d0971ec0f48a7284cdb19538afcee570f4fc9fb2b938c9c5714227213e2fa9307fb11e6962e77148e0f637c0fcd79a345536d89d815f8d1ea2bb856464683d659c8417d535388b321171723ac1195e898d9b319211126518463935968ea5e33d977f8e864321e39890be2cab93728f89b0d0dc546844f1d215d98bb1a4eba2a7756d24aabe480ebf25c9bb8e3bb205ab28af6e118eb90a366b4695d9d2c7f5e4a5f17f1f2f9a497ef749f27fd2597830f0c11c0964ac9cf8fb75b47799d99737475165ba3973ee9b6409880f5a49f4716db77fdcd5fc65a1b8330e75c8371fa0ccb89e248403b746a12ca1f9d236d69cb1a6a7bf2bd5396351a1d16c23ce5abf12349328d276fb1273592bbce385c546983963292c28429ceeaeafedd402ca5f9c70673b025fa2a445843ea7cc991be4cf8e688a3c054f48fa23f6b7679012a4c06445b8c5c5cc465c3f2166dc41e91a57e6ec188e997ca9ec97d2c3c1ffc4129920616ca7e84e008aca4d6ce383cc36d18eb53a94c4816bfc128828dd6448b3ed176d9991c1cdaabd33fe04bffe90a98eca3c865fcdc3f967bdecbcb4c872723c79f1b9d8cef6d3610a1cd135a0d85317bf34052429c1395eb9316ca199c7318d10c8f5b61650d95aaded640c40c8c329ed79f933849048a95d68c3b775ca6ce5fa2207ad4dc3cd6c84858364084e186e4a02703d7e104f8ff3093051c175a05e8f47145623beb196035602986196cb727270af6f468ade088e863bc6617858a465bccecede93492bcd43deb221ec7b438fc0b7245d6b6fe6d88caac15b41ae9ac7e22fd3c81bf0c38e951b208f36d424df5d75db5114e8fc33d11aaf91e67b648a28cd7c009e1a1294e832ef638d1ec52abda375456bbb27bb5bd2b8be16bcdd980eb0231de64f03f3c0f8a1390af593612b100f54c063c07d67f2059dbb5981f0f2cbb0d94309c7cee706924b225238b4db763881b40c34d97de7eb2f261b6e7eda7ef452bd937d0ce3b945ef0c8c5e36e83db5a85b57cafc0511c0dd6ea246e8d55061c182792533250ca2174aad43f6844c70b31a5ae300af9a7dc360e5fc154a418a1e23cdbab28ff09ef9e61e87f45d612c716bd5e6869b77be15f8e06eb0e65d9d23a0c32da12df8b70aab09f1f2761bebb9a50d9543b68b4340e82b84c923bba295fb4f0072a84b1bd2a664dc4c9f8ea0bff1e0a6581c6e1d7903b1dc2b4fd733ce928d2f878c2ee0f731dab2db49b0bb8450f007b8d7364c07efd9bd06a8e21c0c4f6d656f09953e392fb4e5d6a7466d4cff5b2eb1942e1f6bbc56668ca6b63af4183811ec3a4fda7236aeeb969ea04f67ec0044e8d4610f5e8ac2c9abcd8ce16cf4c3f2bee838ee6451b0d93c77f21fcf64568f334b7e0358b54435ac80de344e36d8a5a9274b141861b0e105019f88f472bbe86fa20abdd3b18e00d7d203b12a9ecbbfc7242cb1a84b5f812c372cf71597aee2843c27da5411a33f80fc077f680a7a09e78560a55cd7b787b740c21bd6bb886934b2b651912a37f9003c5b6d12fd2609d0dbddc28ffeebc636eccd553099c8e2075e54859639dbdcd293aeb6cc8562869536c155cd31ef76e8ed271b8184734d0b2c74be2c08d9a6731c72ec3db66c081ccff58077fa05a6f93e1e20764f9456498e8d3aa1c58db72c5de62684e1c7c16e0631317e8f1dd71119bf2329e2fb870f8ff4781450f5bd8465c65789c0f5875d29fbe99d325d61a17f807dab39c4efb6662f5e831e29f56083473be448ae17069fdc79d04abd06f231b6c768540aedf70816314680100992aef42c8bad89f1d015b5c1b5bb1baacb55aed413e3230f06d6247f2a905481efee316e36412c0fbc2e490b373dd83dbfaa88b1d291fbec602e5305b5d8d7738b7326777d635bb1b6ab1e61672c92b7087e1d7735a4c1a47157a2310ca425d1fb8dd3fe4d727b39465cef4ef79084772bddef0aeb26234c2ddb8ed7f32d0f06e7f4408dadf14313a27f35d2b4b46d77431a4b023fc73e4dbe27b17b1ab286ac67dbc62e8815caf14d6222ae766412590174226fe2efa35a1a0a4666112bd49da5e7f757faf9aa147e3d8bdf474a52c95f49d5b6756d1bae24f0bfca5fc4de7ba91254f2b1a9013ff419af10d7d9cecb27d8096e53147f68c6ac0ee5b64a0c2c65371e72439611a9c29f4fd1d76da787e491c8fd72c4ea4a2b36f40cf4fc0b0fbab672bf97a56fa236ab1c14b0a78592514724e466b37ef9d5a5f4acf1f23630598e466e6d56f6e54a275d850ddc33cbccacd53cd0ded4e27f16356561a2340d4a1031fc96510f9a8204087727a4a78a16905e180c2e7579ba7a1acff087870e533d13f4f00a73bced7e99e0df768da1230b5d2426c558e70771c05d8418105801581d1372d232937f4fd392ed447e19a5e1bd7cefede1a86b48476a8857c0aef58686ede196b41d24382be54a40e81b26c9d6a21ef84cb6721462996dd3486a6a5cac3eb6555db2b148e853acee446c85136458eb6240e12a8b8c5c2dcf68f2c4f436e652f69de890ba211f2ae718904e799116a49c9f3fbb8657388d98f7a1dd830e256ddd9af7f498c4dba0baef45cf7ce910edc4fd6f1205abf08b31a33e0efe2f920085f3ee6a6b06bbbb2a1350b5096d0609b2c61bb37898f0a87044fe7cd1d01d0f00293d1d8d6966cdeed194e090cc82d169e50000b9593397a9111daebc3aa188607d95e3fbdd06ba2262e194a2a10bb2cb6c78bd94174e9063563b59715bf115d32934a7e5a548679965b7a6b7cc58197ca507057015d04a15cec4c574b4960d0f7575ec7437c4c6f6883b9877562c675a83ce1551486dc44e11d53443c70afc09990571f23dfef0b3ba98ecf738a78c7cc6b51a039769fa97d4a974ea1e428f9d3b8785c4d3a01c64d16115c08503c557397d6525a41ba624af40206336404c4a904a581ed213d33d92ed1ef460f0270b69030dded4db9a1df4a1d07112d8bedab7034ab19124025c09dead2c5244017dc9fb9237cc0aa4653f420ed54222039e03e524be33d0d483451356af047be6f16b35f3d1221cc2600c0084ef5c2a990470825ef295c6fdcaaa73d8c8232cd30ec8a2dc38a454481a348f0f3a2b87183aa1a5ace1663e214e471443bcc00c3677bad327aca47c015039c73d766f656d950807dc271cd3514b35093a101dc91ba2893b90eda54958c7ee09ce2a61b8f046a65ba2759a8924a3cf370c46490d118de07f99f203fbc1971ec92d14833d6869091e2d05c36af0fb3979e32d1f85e13a246ed1e9df3abb21a52d576c70b0f9afdc95d8eefb4de19bca7612304b728a65fc8078f9935524d6f7d16466260eb1a10250b9544acd0722c4cac2b85e60e099519f0bf9da90c033a8ad1e5488c08a32261af927eb0f32728f29c2b8e88788a2d95dc71494ba253cadc47f9bfa2ed818ab97bdd4b12f6a1f565d30c2d5dda329ae2505be568c83f900cfc27445cb87b81a75de16651ca50fa94d270345e9a53e735efa30d235e958c1c053422cf981c36c9221549e0c8c9b35f878463452ba86b0f812c0e4330817ffa4e5aaddd76c9444599ec4fb5b501624af89a5987cab981321b65f131d0af9a908ecca3c0d0545256887b6185b9e7fe2310059fa93e3bc6164ce1de04d0bea663f3680365a60bf719dfb2310fc2199901760a88d4cce72818967ddd3738adab9a0f4ffb55affcb19f6bb19c12e07c7dcf8e61bbb5ec1f97452482646cb8c5c5ef72b84899efd9d4ddf425fc83249412ea91c8c7af3429528c95f8bc77e50d5a6d5fcb7f9ce8ed1bba08027045b3f608adf86d79bf857a81de6e899276def740aa9eb59c90f828d21bf2d6724d0355b8eb320ac4f58615563ede471a5048d31945307277981de625ccc4e0bfb043c1a4c174ef37359e084092a4e5957d4eef61b61cd7dfdf11b1f0146ae8fad4281a14d0457c10f5079e60e10fc43a264e7dc857809e6c6dfe1c9796298f28719b7c1526319083a0d59c95981bb09d3dd85db53de470a8f572277796fe99638986e194f397e833d409b3ef093192dea7b4ae137751194ebce3a185eea55c85371b4b4f0c1e5689cfe8ee2b8b46dfb5d8463b9fbe7291cfa65753f38cc9c0e3b4463d34cb89ad4efa2bada10c175cf0e9dab62e3582e14e100bb8cf9b75631574200729822f856e29c85ac56309d744dd75a0e946342cd2dfac9fe28cab687eb6ece66e88fdd5117dba9e62b5c5e2ecbb6c894028d4aa2f0dfa67e67e9e2038540ee5c71ef2ab51e32f0dc7f86f4fb3ac4a146043d292185831fec1c360e528003a810305d2ff60412cb765b6be7dc50b5362ab761758d43eedec8a2c782a3e1a20f5f148084ef5ceee08185e512634b6a81952f975bf60341dca495ac63f688697b0f20c593748ebc3b4c4afe0c133622c1875b04ac3916ef0d499da0336f93a890e6ff41f6a4e403b21cff94280d4458c97afdb3c897fafe84dbc710dc15bdeb569fd22a200b917a94f3631870ac714f9f0b2ca39c24aa705f5af31f4502cd8dd7df9a9e3e10c0d843abf638b5468e936102355d729e12cea6b52829c288e251994c020c3fd7b731628054d8a378c2e37f7afd588d0527169af52e4c4e18147845f7ee02e00d522f132294d64f0add1e93d881e2e6e160f322a983caedeadb545c5452a80a24d85abcbe28f3e84f565667028496ac0fab3fc7a8c301293cd35b87e5383788daf34713b6c7254db9dfff97913ad891f7eade3475f10f8b6a9a4c33196a4fabf80f9155c9d17401ac7d588c171fdda3a32f2353d74133198edadf590e2937ffcb1c7eef9488e3991dd426cd9b3bee8cb9ab6bd8cf06fc437d24262bd2923d11a3bacfae08d5bcebbc101387591b1163965febcccd77fac479dc43997fad8b68e64e05a441e2cc30b4e32407561c27465cdc4840fafa346864ce5b49519e6fc336d8d7bfdfa19c85f746e8ebd612e659b6dd2201b6e2daa908eeda4aae220e439c36cfce7aa01b4e273adbf04fdd225dabdec66041b78462fda299de311e83d9f8c7cbe7ddd33f9dd6e2c424ab1d435dce7c901e8f0224777c0c32f3aa8fe1bca0f25d275b3309bf64ae67936d613bc797e07b70a1f721123c6ba2b652a43a91d51f892b8b13356188635240acb5a24405da089d4b1c45abfecf91c404f9624f2b8190fb544f0f98bff1e0e06e0d11546ab9f9581ccfe64de617b45fe1f4b719a5f1dd6b6be710a64e9fa703aecaa26b6e6d235a5a86e7f539553891a14cf7774b5b19922237aa309445dd7fa8e4128701eb0f8bb7f62889dfdc85efd0a83a2746017e2e4b000bf6fee399ff3585c78d438aea23fe6d065e9ad97970426256dd10971b1870d9b4cb690e0433f5fdaf8ebd941a57166343bb68d9a36fa8ddf197ec4391b08a4dad1a73d96c782a2a7c9239479abd42eee07cc2a2480ef2d15f52aeccd3e39cfb84543066d508371753a0bf3124faa589bcbc502f29478390faee3dbc26643803640bf36ea5527fc82f3f97d6670bc9cdf0478d028e4e2f460218bf53c88f23531b85055ec47dd006373a23fcda06ffd608283830ae3670eb404c1fdbe57ec551a68abf2a9ae9f11701917bf40d0c622c8b0501815620d697c4c600e67a9a4e24fa2287607eafd5f09b6ffb40af5817d83a91f3f26eb789b15ef0acd98c15ca41c844b9210913b1083a9552206ec095d2e81ff11d909e67f38b60c121f472a80a7b47285a095a4d594239bcd6309c203600d5522849c37e8834c920fc20fa8f1eb17393b42d89ea466d89518552ae12f36653907d168a093914a9d35a7c1c140e06ba44f509fd07b8e14909a39e91d87d4174c13d2c564b356b8f9fcfba214f84c7516fdb30949c514880302118193b69d6545616c4b888697e2fa1eed85d5fd1b29467a7faf4fad6fce6f4c79807c6499897d771c6b24cbfcd577288a3ea91a92c15ee7ebf64aa962932c409b603588aa45c8700dff4c77d6c7d8c16675f4c1e8d738c4ea2373b8c11c67b0a3d97f14836f98a618d67c5986171357796b277291b17b21b769f45d3ad0c127a88725c5418d8f9ca42a6e440e3adef7b7263d83f0bdc61c071333dbcb13be8f84a5dab29081e0098359adb0cf2c6bd850805705a457f735975e4f40bb7e1f17a6134662d0642a8a7bdbec62f65749226bc709cfa91af29c40d2fc7b191cd701bb2dc81d20ab1959a75aa433c219448976cc3cd33940ed9d3802a3e851e3a397eb9d55bf42c2859a1b99f2a2116c79f97806895d1385264297e28b175af0ad481c9517b824cd407d86cf1306d5c89cd6a94347424607d7b148c661833bc1cec1b07295bcd2d4d862ee0e7c03b3c6c68e5e9f1734ef8a51269036b2bf80e09b0db9905c0f37cea606fbb55f3ab41cf78bdacfe82586c25272ceee8f27196fcf992f2d5406822f9fc9104fcf282cff2dca341b327d53749570c3f051a77a9f00ff060eb6ecb2af03d88b91c8d8ea2833bf98866a7328fccbe5deb79bf31e7da6c7bf2a80948ae5ae5f3291245d3d785ea3c4116e2e82fa8909cea643d8db34b11d681b9c15c1173d9ad038f089bad4ed994f52b2b689da6d4faebfe27a60baa6d69e73465a70e29eb9da1b9ea08df8144aa02464f3be05552d48acf43c3ec717f3c6282677a8e708d66c3103c7817da718e00cc337a3fed7361eef19d83a2863be8972531d663a58b2a109b70672a6fbf95c669e63d8cc5b1e0f47b92c046fb5a5be58f67ee863e4462b45c727a62c2d67df68e4477c1fa29ee77f1ba8fb113d3981120c7553afa016d556781c341d188562f6efdf2ec0a5e78a932ed6cc4f5490086893142c29a85c84536efd5f9aeff8f4f6b73b78586c8e4da850984a49eeb7603b1d2be95e5d8d606807b566176a162d980250a6211bf14e22f86a9701c184cf28a6aab94e7a7b019aeb40b2d254d92c0c9a26b4aed90c83ada9d8a5e4b2325123b3339825f73796e350680db4b59f1831bde9ff2c9e13603c75ddc2d4f949e257685d9a38d7a4fc6b14cd212e1647975440ab08d22e99dcc821ae9a7040c8f31f76edae07cef08b2f52019b3cd344e864012d7fcc38c4e9ccdd5aea815e3c7e303d4642ac4d8803f5143ae59bf28d03c743e18c5a5a37aa1cd3a49c8d5fb20926b0b1f8ec5c9847a9e596211739958eb95f9c4868c7effab2341d977c52a10b6d011c9512f716b1da1d3a97dfdf70922c36fb09c2497a790b1ab3eda4ff47b55775a4fa9de6b7bc0e5c05bb78c81bc6814782d3e0760c332dd779c2b8fcd0be75f86e38628f4b44618b695777c2ec60c65ef9e56395fd963ddca9c84e2dd4ffe8620c625b96a0af2438feecd4a3a4ba96769667fcdb36facaba40d51f70a511eba4d4b6cda2dae4b38b5d6dcaf5113631cf4f03499febeca3a48b6c78aa2cc00b5d11ba8fedbcb2f883e6214f7f99b5081abc4bcfbc43cd615469b9fb80c51a33fa48ad553b68983d5e764293addf492587774046927492f596e4e56f5313f97cf3236d859655347fb91de18ac4b9923e9acb282f0f2c185bdd61ea8bec13b236fc7b53a94390a4c1a4b40502a9e051c6cd9d4cff03e3278bff26f1b910abc025464486940a694af393028227eb7d6a6683f7d10881930f43cf7e681a267bbcaeae88f96e0b32da715be57da09de9107ef61110b8cbda292e4ed4edced3b042bd56281b4fa169f5d7688a03f4299bc1a6ccd56df1e006beba9799b253e12498b5448338221ced8e5476fbc2ed5f3db1197fddbc4f7bbc4a4050e43e06694b3c645ad23fc064808f658f308814699263fce0eb65ac8cd6e003817bdfcd1584af09ec7eadf2591b7b6d88b03b04f840f711edf035c65e37869724afe6e0f3e66f8c660e187616e4b4a7efcb7d45b491d8f03a900c0c10ef1d2db4291e41c9ef218b3384444c1d62693dc258ded9036a9ceb69ed37a89fac76c61f1152426dabb1358034126038461495eef0a4425713dedbed372051b402c0a14472a0db4c50f0c109558f118670d2932c98f6a944fbdc9c476777b9af25dd4fe0a9dd288d3aee724397d4fc0a98040304f2ad0b176fad432f68ce3c141e8fbc3bba5b88e07eb13332798d1e96543aa9ea202010f972ba675f66ed60c907b1c183b3e85fb3866efdca3c86315a5061001b640234fa851c0fbb7e86aba6c8143f6f57e283acfb40c83cf9ec458770f52f58dcb65c1480c45c2b727c99cbfa616c69f6757603e5bf6858f7d6657f352b2b3cac0f8174b9c8cce996f7ab1c1f0dc5621bd8bdf5ccf975b987f539c1175ffca40b360ad144e4201d1c3784f92de25bc563c8d2060f199900d4ae361a591f3cdf4c6fcd137a23e92fc9495cbf497cdc16213b0adcc35abb00abede0bcb33e46f662a8171734825cf1fc5cff84bf3f1336495181e159c3153d8cfc41729657def7ee01ef1a5a15f5cf115d398454da71d43257305e4a2c3839ee492387791daaf1db2b373314e94ec58f531584dd10738c864dee9cca653de24289cade6f94e47d32b2ebe311e52e967b3490bb4887148d5f1ff1792f860ad647d2bf6dd51c2f32f445eeed507bca983fda96143fcf6ba0ea3cc8b2ddbd01ac85418f13c9a321818a3c86f233d4a42c157b305156042cda13c3f6e7f0e435dbdc0db365848aabfe35865be7e6ab73c47953df6ffcef7d9e00d828332b67cfb6d908a76276dc4e87a4e6700ab55d6a4b02ab41085d2d9912b2ff6dface648166a5bc9696f03b3f69e4776cbd4cf1d4b3aa25597a9a828c56413ab66c02d061c003478422eddcf68fbb38f30dc5dad630fd41661ce6cc3b2136bd7bce53cb30aa46b7cab5427372ac4cfa434378a8ac6a0cb3c3ae9b2b7d2776f0d39d88b59eca1519b9eb3de5959f273c23e3098102c80ff1fc677931a3c6d222abed6b54b5e9ce39481765ab0a0cc525dea1b9a5e26b718a97554e4de38ee25c02e689870fd760814f7b8438ba290d8073fae674155d804be9ca95df0d4c246532e94908d6e924c4d8fa6c69ab6a7745091f5a393aec2545645943730208a3fb1c731d88fb833a8b00fed246b39d29ae344ad84cf9b3ad4729190fc7e0108b7350eb0afc7129d096544e941380305a6a10f28d87c6c7ae1f5f6ed8b5b20bf85aeffdea36b78761bc8e67845385a3d72c6f7763026a336bb3631685756a1ff8fa681d31ffbbe64dc67ad9869e4b01a1f2c6519f9557c923b43f28d8747c92022467832a0cf76adf221b8dfe808863445d704f70473bc739feaa173bb6170b1b710827332319d31cc5165bea60ee229de7422a1370859ab9d49c902e5256db24551b4830c75b8e05af7698217b21303c6724024c34d5000494aee66b6bd18c0bf94e48e51bb77287047a62abc26f7b65bf947db15ee2b1e135d774102e53eef8f2f5ddbf464af710071c0077a0fa7e1905b44d6f1366a98017c510bec5339bdd051f201d46b8dba1320fbd5a9ce7dd605649e2da3e0f3475c6fea889000054c7a4cb86dad0bac68acac8cdac94fb5db9b0cdfcb66e6d203e363e736c3dec6892a782dc9e56f9d0afcbd956338287840ca3a68dbff7833aa1db223e5f2996294603ee0d723b3be4ad3f7cc1b14550047b1203a2169529c2e8c102711df95ca20b4cdfb9287a4fc5955ffbc9b92276e86278b0bc1194cc58d1ee63c7566861f90964221372b6d614026fd8321e4ecfcb88e2cc55bf1f8e5f5afe752279317a30b77ff5a45ca23498ffc6402a6ede86fca6f851370ad792d5674a51827b11a97f589012ae04bf39913c41b84a89e8e53b9eab3f9b91ce562053e124db43e1c24b303a5c7bb99d28b66a30c7e5bc5d2da70651c63c579ecf7b085429e3ee59f020d6bf240b2ec7200367b7d23f149da01454f1b44e73128f676af5cb8540b7ba5f9d65ef84b763900c3224763458e9016cf9a072b76d73d79475675173517e59d073e58ee527fff8aceb071507d16b8f373ae4cf6e7d9ceead91321368382c6f42a399b558e82b7bbe7c1c095b619105a4701b6b39d31e99c0b94bf21f17d2a34cb9d81377ee01915793dcd71a91f70287f5814d7c811421e7fc9bdedbf608dd367e7310b3437c28fc2b40ffe0dbc45f34d6016f2504f21f6e23c4cfecc42fa890d87e34b83d7cc2f0b1562be3ea8616216ce88a5605a17c8fb080246a9d8763fa120ad96c51f81569bc2ade1540608afc420ca704cb9ed9225b416afcd3ba56ebbf1466fa13f3773fa540cf4d11686710502209d69bfd834d43e8feda125e550248926956fdf1e1451af07c5b72fa08b3e6bfbd4d4b4f1fe8b4700115f0352c950a6e6862741288c86bea6ed626a7ed642504300105ae4e0008eb9ed9ea5443a0697745937a3d43e9ab15c1470b2acd72607f731d5b15fb2d6f267f82787cb537ff23c65ab0d49ef8882603d63edb7c1aa488038b068421dcae357599a9fb46d65be709b6ef643c2ca5ed700ddb9276aa4d5e63060ac467177ba10d2ca4059990fe9b981d1c249f4609d6849580e65915eb9523b19f92b128c1e8094caae60d60a97ecfda8bff6d529e6cc9f3d1e318bf9f0044ab3a3db6ccba3c8c7f9c7977a380b6cd98a0771274c20ad16a8f3c0cef753c52c946472e6e1ee868e443fa785f64a6da9da7b17e89b7df7f40b198b6a181443fe0bdb7b0e0fba537837d091fdf876abe774df287564922b9240baaace73d989a19ce86b14ec9c798c3e25a099ec569bd94a04f68581940d235e9d5e62e610be0e78fe5ca1b7ee43815741ba9256479041149ade1c0ae3a69451e81379812d0c6a715e81c76c684cf99bcbd781616ed5d5ddfba185c95037e28fca680b7f30a940b55a0deacfaf3f9ec290291ffef95b36755d8cae9f1d2ecaa08ac7db50f5c4f1b6c2b0a5209572be0cbe3b545dfdce0da9c9e9663234a5cbe52d74877af5eb6af9860a470fb56bafd6d7826995e083d3f1fdd4f31523b5b01adb7cbee08482c01aa7776516a5d168831f4394d8adc1cdd837b4a7095e09493a6dfffe7935dffbade462e1ec8c55c6ccf9c4dc8383c99f660d98df4fbcd274dc1b2c3d022bbc0cd17b50ef705444bb6503db9ab163f43cf0e68eb3f764870c005e941535d7ae6a8196ef6886f84480dd908d778908ddae9118e2a1ea7d6c1090785d594ef37c75114f0969730a4da2ce56ec7b21e4f78c2a73859d735f2e58a3f32db4a25c0390ee76fc91053429195be968dff8a4cb120f20b71643f8fd0972ef5b1a1ad5867e1ab928cd09ac92bd07af5521ef3669c621b72b0c1bf2a49246e27d16b88eae1992368217c5231fd04c4549efbdb5d3b81f2469a5e56c0bc439aa525698cfdadd843e96d51714c4fd274064e91e0fe5136d44c33ada4e562adc3c8f9e6e216d91af8d045241b23bad8866b3263fca9067179e14e541f33986f054bcd5f3045c4a493fe8d1a08cdca9b1c66744cf3b9e9fe0f4b0010ecc5f80e2948a9be1110cd9cd2b154297aa1f64f7fcbc901275e84d562d2cad8a87e96553fc8ae89a71fc127c4cbfd8cda1a5c8560196660780c3a656649d14172ab7e928a21cc07051e80e304601d858e28fb02f1cd01495fa3308d11548cd9d48ebed04c949cb987da375ff94343622941f364f8c1499cc51e8a1324f4a74984671562c16b9c1aa9cf9e0b917d172857eed75629a74222e3a937e0ee162349ddeab5defd486499537f9ad11b22dda545ac7f2bbc450a4b5b37f5fd5823c9c5e6dff4109e1deba123048e785d836a000ebc9421c25c0b76283a057aa924fdcbb3ca62c802b9cfbd6830e6c8c07844f0acfead3235555d1423b45a2a52b799480d097a3ef6ea4ada32556f674cad7595adf1b182d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
