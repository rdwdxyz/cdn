<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf1c85431e8c97a02deafcd29fb13a9836cee7e8bb0a836b06e8e2214b0b8d890c90776a70bc26fe951116731a9cf934e349918543e15577331b3511db95ad4caf71e6b8474959cc034f23d8c8046f0a00c4280b6fe36c44bf1823b937d9d00c5a31a5d467b8719a3a4a7ec7d9b27dae64f74c182a03e35f030107b7d74a3e3b78cb41dc9ac1b4ecceb93644b43ded1ec7bcbc95f2fba9cfa904b357ac34f1f33afc0d504b1df73796fba708f0deca8d14f1daae590cf542edc16829c0fa8fae96394db9c1c57324585df0989c1c7d564499c916715af98884594378c96a31a5cb8728fe93f2b97ca4e5e18fd133d313e1aa612e381d34f7f232c4edd19988fd3d71e117d361c6acb3a302f191c649852054419b510148224c65132391861aaa2c0456bb4894f2d6808b2c848bd296b8b5dd71c792b71c816764f1fb408f475fb7868535b5e8c307a7587b59b4763b73595ad190562d8df4970105361bc3cf2aabaf59c29bcade804ef8be9340ddbe8bb63a029a2f4819451922437e2a70d0222d4ba755f0e90947edb62876701c4a47d55056fc8470bdf9587b5958f7b8eb1bf446aadc2f1f6d61133259a20ea7aa5b1ecc72afa71a8ded76d2937be88af7d0a735d4bcb3a7e09f294c1ee64e6cac18fd5d32496f759de36ba1c50d55b662b55b5a6f2324ce8070e08ea977e0e08a7099a9a28669efd7b644760f39a322d89d3c7b697c7d423cf42d3bed921e8a2c3e3d4496d80708f67e5ffe48082dd5e294a9e2c8d20788da933b41ddfbde9b67799a11012626756281da9faf9b82b9bfefcedda11737cc85923e1dd667a445f63befc105eb7f42eb986dfd2a19493ca7cca83f4a7179db077c4cdb5d68c1a022b2c444531a7b93523cf3a0a00ad44d6a9031a5e7c34ee5e1764843a437da5c7f5fe8c69de01b8082de0f9342645bae9c06cc74f0a95de60443fef212c7bb1ebeb7c08390fbed95b8e25f4c62cfe6e6b8210c05c38138a79197f4ab100efe57282c80630a56ba1c7142d65c7be11f9e79bb1ee34316f30c8c5bb53fcce4e16b42ef32eb7171d14b98d865f2c2100f4aa1906bd1f17d6942d209b1cb8ceed7e57284e498787a936000636c5f7021256f2079ba730d8e0ccdd12bb615c02f05be1693738c686df17fac4af3eb3b7c1fa32d31b182e44db2f8ad3affe9cdcd674cb2b4b566e7b26b4b34459172ec67c6c0458415b665df5e1dfa710e51a6edea435dd29481d7c8bdfa45186a00316e80b354ef5660b872ef4c05799e491a07a4160f0acf3507393629db7637ebdbeca1102a195da5b1c8a937cf51c0f1dc2e87d41917f255b189c1848409a8dc1183b90f6d9e22099bb135a3b1193769692ffa8d845289527609cd16840afe60164b46d5903ecd43d31744c78adab02b87f95d0e7ef0b3b42e1a1c7d57af1b5ca9ed3a1761174210706703255cf1ff03e8950363503ed95c17ffededf5b44ed9e95d0a720c70b7b044569f865c5055ce5fb3ce701f02f6b38bb0b4f319427b32c376ef651b9e991e2be20aa640971fbc3f4538346ed07cb608a2d4a6f4bd865c79557f860bc1384091234968513de38655b2febdf7a0b3acccc1e79ad3710ec75c0ae981fd77057e613a423082b5a62cbb8ceb6d8a75dbf3f38201c3e976a9f7b8a8ebb5bfd9c36f0f859db972e73581ec7276d466944aea70ece76e75f34e3dc9361de58d77bfda2e14d38fac388b950c13bc8e375399cda55691689b940b2e6b838ce9dad733a34893203593520ab6470c5159d587fc045c81a71dce6625c3291734c2a24a9ab8816793049d69af8d6fbf96d00696a43aecd9a7fa2ca49d65ef283ce486fd7b1a829ea2086df547565b448881ded5f51d78de6c99d5a519a11f07d817f98f153999253ad2d78782e911912e0c3fa99e85091b5433a879cfe59aa85cb5bba7b14503bc6b0869242afc52b7f6b72154a3bc93dc4e24772d1da30684141562fa476c7ea55a3335f988b309db058e6057a38d740f26d662438e64dd595a4ccf985ea0aa51364dfb6c60d3b8901ad5ecfb8635779222fd5e261f702f34977be5d0a154fcb586bc17cfaee030ae00fe9b283227925d3397199afbb11174458d8360cf71abbea1fabccbfa234db7d14d30fcf5349d239af10d2157b17899b83ce9210ed1a76e58014fb45b456af1614668805c2491490e05c4e1cbd8eca093926c0a9821fedc3e09a3cfb6cc50063075297a99d01db2ede5b47fa97fc48ebc08841bb862ceff579ecb930d40d3821c8db7ed0dcdbb1283ff0284a669e575829e111ed66145cb97d2bffbf057bb5e464c34e97df737d97d9c088b44c1264b104e1b3023566753d2829877d761996792fcd26de0493b55527ff69ac73bbbe7b3b2af95af1d13ec59781c50d8484c651c3f9980533a7d261fffb40fe67659945bc5fa57dc4d069c10fd19d97ba47619c4583b0d003e448a5ecd92aa14fbabc2c84d508bad4f14d673fc3790ffc9627470e5a4b49fd685a9906b9b32d3fb018c15cebf6027d200de6f04e2bd22703b7aaf1c4cfeab9920c356ba3cf88b3fc9dff16148f3f09da6830b67eb21f8423aa2a05e1e824909e5245ba5a566e7305c8128ca4ffdbe705c3ebf6200d91edf1c3f4f014186a89c7f9bc8d688bb5bcbb92a67bab6402944cf9c0752f7753e397ebb6101d8ea67edb326b18a19bcccd554d3d2582b4c5226c231cfe3170adf5056f50b935c8aa25b6f8a9401b5c865ce84efca55d9db1cd7d5c6e807c5fe5778f9a0e4bd5c9af5db2282a7e4ded84764776a624e8db9dd1316ad8386e0f53c89f186b94c2f8bad6d500763324145d0560a927844893fdecf3193b564341be7d1f355cdcf9024d7901afe2f251a75325d682307fa3ec5125704ce9c5a32e43f5a1f12a608fa3943bbbc1886da7fb3659ee60ec1e8c4e65b9ab672e72c492402250ab8bed5e9e560df0607fc76945e88ef894becd5d9b16c8764685e0adc6084fb2f3e01f80b4e8b513054a5f250667a2f3dd4f40f8d9763f77fb12792a8876fd6f50c1896c70755f48a8f2037e39e8b51fe7f353d1d41e2ae11a17a9b2e4bd01be0940fdf971d874aa9cc4698c7f11977685e0d6480c739662850438f7aa99999b97ad489035ab4fdde3a4a447c2fdfbfa14693a7f410a942481e566fc6f435a8d5863e645bd831c32162caca6410995fb9d8f2dbd4da2774ef15068b96886d4998a924cc9216330d32b15ef4a221469e0647bbe59dade1c5366860e1d1e6e4222657f7bff8d92a0ad59fe0a0a4450b25c6c278e9126ac3a496f5190c7c19ac40c732ce0c9d19cbd2dd694b2d3415fc3cd0d5ee208b3d1eaba9d7e9f5b243b69a7d32d448bae4ceb476b05538bee53f7ed91e49374595820749a7388355dda9cd538e33a56e357e4b5090aac30e3d4e33cc00348d444410dcfae64033d6ed7cad72e2310f455b9cf05c33a3c98b995ea72526d5f30fdc799fe3e898ab17322375c6bee1a378463174d0b78ca43bcb1417b33f5eb54bbc9be30c142ca41314fdb2f546d52801acd459df7ca11f0d036b77462b309b95d394959db96f2df93ea75a28aab96c0335d347d2686e28f0c7ecf39837a31fbbcf0e09b0546fdf16b1393cd45a2f100df84161cc54cdd4b8dc37683843a15ec0710c9029d970046b237e3782c8c65ad078118146de67cd627093e2cc05642be35a1589363eecb4fc1f5eacc83da4519b9d74b06459768c38b0f07dee023d94ea1cd5e8d551064a1a30153e7e6538e5f212b2b59a74aabd435b36cfc91306680f0561df252d29fce0a690da5570d21c2a040525ac2485ba4d7348abd4e88a4df54e1a3882c7464a2cb1f6130c66ae5255f6504348ee58fe6554a8cb991cf97cb652ad4b34c0529af03c60c070937bf8cbc7140ed02d70b611d526a5b58095ac01f7837059caf415d65b2c5643dce2b808453889101c2467d11846dae1119956376003c06d87fbfc363d79ffd4609670a50aced0770534a278c703d9d6dea30cab4344d63f7dd705241e560cadddb5cbafd25832a13244ae25179d1e2f6d5e8d92e6c53403201573741f31109383180add9d016a7aac2add58865c34a9caaac3b912e5978155d64caf98585ab899a2c0cff77b61ad816532198386c050dd410c056ee904737c7617947dae34aa817a4b2dac82bba1fd9a53538fa29ad43526cf31dd1df1b7a4b46d92a8223aefd566727132957258343176b29ffc27061b8ec66d8b656462e87eba5fa12f1ed9981522d33f4feda09f90fdf7c7c985d098b4e37a83ee9e1f367b5ad0951f1d33843d6e17912e7cb77e63658c9477b29caf92295dcd0b0ce77143a716a395dcf7568d4d1ee3ab3e4ce823083fc7bfbe91fb5f3b5964061f74844acfb52a276b2831563230be81741ae18367716f4ac76ecc1b51af1f38a91ea85a94957b80881d785ecbd26c4115ab8c980375e2b104e1e68a62eb58b7607341b97ab92cc2ff726be2edf2c5c396fc72f4a78dd7fc6d6f31013a2f0d55fe7448ee73ed72b243782fc48c74d224548f2b2da2ca60ad5fe5d3005607fb8231602396e90089864cb473205bd03b5a69876f5e079fcea393411a29d0895522dfba272ce7184e8f11a5f18363bc7ffe908fd790fd77f112cfb218190f049e4591027aa6185dbeb33e21a4af69f9c1039cdde53e974a044f74c10b850cd381291c688cbc8b1c29a9b73040c838711c3771098278b6dceaaf9fc73bfb05ba452c2100ac95a2d16b465a1ff0206979b2e443e4ff2320296aa68ae8c24f3026514ade311139dbb2f0e5f0a54ed26531f7c12b0443b91504e7a8821a3832caf6b77ebbce39d03755ac431b2dd898a8e4f1daf0b4a54d34959f11c00487a4fdb672b354c5b20eb8c2aefc813f91f8e3df0466d843370fa469d49414787cd9a981d76a268f4cc3fa84e05e8405a74ca01392ce1ab4b747677c61905f5bb61fbd1ff8fa5f00efad60c59d3b277d87c9499e0ba8c538edd0d55f29ec1a028847485c17a960afe8532d205d525b3274ec82da6a7df0a3911458de9c897588b27a49a871871799d5402ffa41ee2dcaa561276eb6bac2893b08debe9f3865f43f501159d8a941209a257910e42e4c9f09e2e2433baa13b6336fd7f20d9c86263826d18de6a4dc6a739349c051b2828beda45792be9e5b5e00dd3aab3b185611a5070a91fdeebc2fa463a319e328b77bc336ff9eb682a2f18e5e5c01268e1b3c5571cfa2ac689c4a61413922f947113c4977ad68abcd55c9021896168f6ebec9db68602461edb023b8e90aec9024fde5c1c373e0c27a8021e61bdfd61092c0463a6b609903932f011319e7ad20e5da06ece0c8deb5b71287fad68458259a83be6226241f3d65f62a726e1d686b0199d2d2c9dba1aa062b607f4370553694be3ce76752b24d91b50ac7c952d45ff8add79b1ff9bb375703ee69639907f0d3762d8389a761b91eb60e8ac06bad221593baa05e601b31725a9d55deac6ce56a75239951232c78e03dd3bced01804b39cbf5bd58901299c0c87ac2611acf46afc7acc1fb99c60bcd016b09cd0f27d1d1701b4b283fb618474d4f98ea8d6a56fd048bd4ed3f784dcb19b01e077062f91812b5a3c3c0070c97f1bf90d392ddcd068c2e1a90e6483550d7426a7aaebac2f1cdcb28f9862d1c514da9d78794edbc51848b7f9e3ded5c16cbf4de2ed1f934d94c42a3040bdfecb2175c09727b4a3e7ecc214584f05fb4bd5843bb708a3b457b1b5d9112e87bb968f630f4e858f1b5f8a983194018a75afa95105d8c1d5e6ded579c2a3d71384434b36c566251f918bf54740fc709982fd10380ee28d1be6decda22e9ec93e7a48eeb1c8b527592fc0f05e85c5b57082ea4eb08d8e8c80a792d2f8b1be83fc0a0cb3c06421643647e6946db6c9a2b252f9685fee866a6ca8068dcb71da801a7b904ca5516d1b50973c224856fcbc9ac0410915e77dd8d5c4d856df8f84daf9c1e01dfa1afc618f5c2879bf9b64076050ec6831c1d0cf219a9db0f6c079e60b1e16fe5b9f92f64b9bff1d61e18286f4c9bc576b51b458e275267b3f6a1c1586d5cf66ca5dfd5f432f968ad242f5c03bb81b09e829576b14620d52889625a88fae2fc2b4db696cb049252d3979eefe3e22f1f568b229c65448ed3b337310622dd2b98ccfc5db36e0ea78ee78b45b6ad8bc01fa76639defafecf370621e0d1e41eb121d49c3e463a28bee727636e14769b582a4f75b02ad342a0609a9a11e04f0500fd2bcf7e302b4fb979bd4cc67c569ae95013418dfc65f8ab7415f6484b7e77cf0aced9deea53ef61b24da80d3c7705ea5030c25b428bab8898c7aa93038c711193275f0d203e14bb898fdaad47ef80e76b6f44c9b4a59dbad80001026f3168b7c4c8f4748ecf51e3b04102683157a624577eaf7953489e8c030bd2defa07afed8026a70795b8d57eacd323fcfbe029e01fc63315d4e9513bbc2949630cde250719982a1281ed7b57f8c40910e6f26c4b76735ac8227b979f8869a03cdc8b9f9f46af22d2c4ecd3d2f6ca71098303671af2f71902b3c8bb986b7323a76c13e4d5474ea8882145836fcdbb024a62c46fdccb1003a52988223ad7852f38803db6912692f3d195fde29541b9cb4b5a827e7ffac8c024c3e9b96f29157d454eee5aa1d49caaca52e2ac4d1036893303cb312b6577800d5ddb5e2f4eb537bdb4dfb627f03dbc66ebf1160e122dc219a13800e7546420b5d5e1ae33c240892633e02c841e66b1195defbae23f92c12e5a7f58905e756d96e79cfa99ba070d422e082d199dd066e267ece4fe49eb89e983cb9d96152c7dfd1bec6b237d0142b027ec9a8419c002e9859d24bae478f9cea64dc1258dd680440fb5312f375f3f50912a7f91edab708738e89ff5f79de3519f142c69faf305afcbb4ba4a8d3d1110b9fc9e12d39eddc82a00301cefc8f057371252869dc2aff9c4e1ba560df619a6f87023191265c3df7e1b56d1400d124b089c99e13b61cf742a1d05dff15baaa6899eab9738950eae851b0dbfaef48475b3afadfe1b39d17d6ea4a2231e04ca77cc4ea12d88974c72ee29adaba94745f80ee671cbf4f5fcee96f0f2d0a6fe40c9bc655987412ec2d3ac8090fef340469fc2b9341cb2577bc970fbd4a5e190ac15a643be7b22feaee71458733294acb39d9a8757ccb213e612c2faf2e1f0e1b4c77536ec7a9d9a58e7189275c5e5b02fe21b0d76945c29ae804481fc0b4cf02c1dd7a17d2c10112dd380959830885d7505d54ff4174d5178a0c0f7b47e531454cc0a492251fc9a290b51bfbc71937d42c5f58ff1efd87409d6050aca86ba57db6ccbff2d1a7885db9897bb8d39c50796ef89fa8886ff214ff14c7800b87d26fc35650a016605bc17390685b6e6b5754717b72de38856feabc5bd8f6c6bd5815397d25a5c3c1ff0bc5661744ff14303e87d175afc94166812af4a12db1ee03731e2dbc77e98401c6ea331425cd1be575661cc38cf67a2bd68df570c8f075b37674f1607b9964eea8372a2c620bb074d530822296ba0f94bd94755000c061848c3737ec2e05f5489bcd3b29e2918e1cbf27465a4258bc229f3afbb52ac0e59b5e64c4e46890a6a08a7c675cb1a9abacab8ce9a24b70385ac5f3d39ef8dcef41294f118021113ed637ca55e9e61731e80a19df17cf4200367939e34e3b38e4ac1fa248a744b75c252a43ec040cb1979b5207319ece23c8b6761fd60e5079ea1783d366450f2ba699f8672081961b3a87dd876844af9ed6dd5e009d9a97570d7e6708d78875cca04f79fef1330bd25b373300d451d2f3c15f710bf0e195f2ef3393a778da400f12e951c4aeae5ecd7ad19c9c08740452c0f97d109d8629cc36139dc2d2159a5cce0efb1238bc0e3ed72c94a782ee2f1962e3a157d9c6e65dfba6ce9d36a123b23b0e30c734002189c1216a86e9a295df3436b2c6107bd93f8062654915514cfb56cc8d11a8c24844d4109e5c2da47c4e2cfb182bb219517ffa51713b03ca0f3d1d8a9e34005250bfcd84c283b26f727ff424ee6964c0be0d492ccd7143cf0285a46e0cff1c5afa3a6db7bda39306a30dfa913dcf814291a23817ef46915edc589a0ace13f48846b6d001bfd1bcaae833d599090b1539028cfaa72250c7c9c74a7c66faa70359beede260d893107db478abc62b9427a45254c3b9a8fe3eff3c8f6d4a7262a56d95404aae9b10fc388162338bf20179f72a4f469ceb74ec820e54b9c72249a57258516287d9f6c0d6c0a4a500405b75a32362278d0e9c07ff25dbe9c7523ba78adedcecb959333f639d4d510c9195cb7a67fbf2e788c6c354b3499e6684d2fb8573e1c5c345d1033d02afd82ad7553681c1aa8ca716e503095d68686147ecc78e846920f7bd5d7ee52579eaa73102fa3a3efbc026dff59949c526cea141c828914a460f214c66ba882c11300c01ed5a99184247cba31974cda95f68015551a135e6b2faf34e3e61506cd56669234454f11e18982040947452e8ab779c78ffedad65b10fc4d91e590a08fbabecc35eea444ea2264466acddd2ce7f5e306f5ea0ba1af0c126012efc26b99dc3dfa8f5a11ca8a5754f33c9855583faccffb0423bbc03d037f9cafe6f7c83e951deb14de7d95bb9a496c4ae559f17d1e6e59ee61b92f198febc2bb79712b59e7e62845ccb3dc28bb304d072facd34abf12ce575b342942e9c6cd6eb858641f304889cb7509b6455fdd9d44e9a3c168bdd90da9615b558a62b5f019024dc460502296c35b1bf6fbcd713c9c7dbfae21cfb446a694c3a5928d1a44bbf82ea593e374281f6d82c0d2279f8f809030f6ce6f3e85568c784f4e8568c591645d6d2f09858404377ff35c8235eb3749b827b88c4e65f7ab2bea72ec0af29dd05cccc8aad04652a5f7c27202c55901f141f21b0b51dc01592708a1f558ac914e53ed23199aeebfb7546e46577e879310ffad7a5f9f09985afb2197209e1ffa4dfbbc51f405eea0659b3a00ec4432857df705ff1abb7d856bceddaf717a398ae9746b0d25d7012745d2e8b10e8a894d84f8d67a59e7a97ad8380d8d6d2ce5a1b2227f896d356d9b71ef865a45723668be74d56ce725ab90c4958501a77fcdbb75efb57cb06fddb9308d57cd571043d4b13122a95ad5cbed00ecfc78a165c49b5cafcd7a7986b2ff3eb39d1fc1e16d00198695ac48b7c90fc485578b930dd47c39b58d56e02412a45f264dc0890c20765646640a6a4b56861a0f0ed6862c47c1217aaa7007988a10bbfc5ea73d9de165d42b44543ebeaf04d3345ab8dd48da261212971889125f913e7ddd2e994e9b3ae6cbfdda289b9d675d2b419d4ed6f72005fba73343fac893b0a154d489e599daa80c2f0916b07bcde0b6b6bfb89914453ee427124a3b8a8f1065f09e54c8ea61ab5dbc99fab148b64383f97dfb55a853ea7222fb78a57ee5703595ff1d7a0d8fe8dadca592ca7db9e590f49cdaf2bcf3278d1cc61f0d39d5b7bf3000ebf503ade47354ef69e370b8ada04c3c4adb2e7efb47ef5c96a47292d1cce5def3d6be49c489643de6ae6bf059fd85e195e4ed4499f007234cff4d70f53ea8b41c3ea6d3a94f8b049f8d5a7d72ddc9a5af48263460f7dbcd547926323bfd89e13c2221bddd19ebac9972fbf63501a6b404ffe3c7f200fd846ccc007a7539a91c0e06083c73b4d1532d334d6690b0fd218946e207fefd39119711a35591fdd591085ae81585e5bbe024cbe9eada6ad5b96067248a6e9275831c76d94004efd8b60a432062a278511b6f67a80b813ee6b259dfa474c0349229d3a7834f7189649c34bd6785b1adfe5d690b455d9857e26d7cb26fc82995d8b46017c26ef0c6ccbbfada01ea61a827bb20c3e208a1e07912b8afced4577ad283eafde41245d03003f7515bc50b597ac76db9c3d17dd3687f8c60b414099fd425bf3fb4369d8a5ddf243ee8a7e9ffd4adbb0de262d9044cf43edf05581eb4880462695c426bd30a2491b8ddf7034566121e6131136f2b7866fba9fc3d3df3e2739da2e391b5de4843ed114a768fc70ca208664628c6366c73b24505c4b0ed530c831d194b53b777e7940b60e79b8a6845e273a37b87c66b2f80ee5aed07fc9326de78d7e52946b1121815726923da1756a823d79629c937643cfe4e2e1851c52c50a942995e5cb9a8a1d9b28a0592ce202b613c049884607ddff77e2bb60a99571e868983d2f6b48c52680356b44d9d4395e05626ce4c1552e54192568a75ec28dbe8b14a914372957715cbeff8e3746eb655544b9e9508264d11cb4970a80386e5a869f765cdd387701b436aa74280c96ab5bca2c5ea7dd9228a60210a82545bdf9c0cfec9724c325f9e0b43b198c59daf04038c1fd4d4aa9ff15710abecff2a71e243b6a45b39a3eb2c9fc891865a03425b5574bb4ed8e89b57ae2359e01aa9dc5cde7f29de7b6642334a69ec5566c621e07e772803bef2b106eccd2916902df5f757127c4be2c7463a6a5905607eac16ca4e019efaf9245aefd79fe1639cc1cdcc6b3f2f3f291bfef4e7be6b20703cef30af69241f784e70110be40d81df8317dc44a2277aa2c55fdc6d0eed4c3fdb879880ee83740b3a112e9b89b4616bf3628660b89f6384224b7f104483f800d5d6e64dc571e45927b31529c0a9bd61429f0e0ce1f0e8cde4a9b3d48410652380ed7af7c8db9be69c8eba1a0b0f118d1eb46ec2e64b463a23722ca7e900ca700aa7305cb478fdbd782190430ceed92c6866ccc92cd69040894419786699d9da5fc538b478477462c4f6dfbfc96c35bd013c508674bd398837097c73d9bea23ce71609e8e5294f781698406b1371cf5f10c6e768b0ec1c0be93d3ae8257247b44269e38a88bb0eed71c36206282930ff21026c57ef64303b6f500db8b906c8843506cfee1cdbc471fc3a1e759eb38a22bd48f4bec6c0a001497729d9276ed55d0b7773e535fba3e9154c611f63a9e1fce703e52331ef88d800790dbcdcc4196c52311513720889d2a0e1b817e367ecd4874dae94a4dd3d67cc7e9b90ed18ed8b942451d9a3c3a8a35afada7a4be76a1dff9af366a3e3fd3e55621bc75bb3175df926ba5af962050107c427597815ad9e7fa998c8a7cb682b2fc65d300fa638cc0fac93d25f68a53d2c8a68d46b58c621d5196a58deb495cf5a6b5eda375d597c220623e74af224d49b7b5a21524630db660bf00e695843efadff239e5d3f335de48f686e59a17a0fe9b8c566b4dedc32de7a474338e7ef61492cf868d3fbea2419aa0fd2dcd739119cec7bef37da111ff2077a4b2552d4e7acfade9148649baea3354429885e6e51dc77c7e99ccd1b0741af3e3a6708b3acfd695867ab8bb32b8aa7f5c0bbd88332244231f0fdd36b8a15e05a53fa60273dbe6a0a4da47f3f16aacdc76227baf6288e4db27da3cc57e42e6ca4ed93a1a3e698d37b682b7d5e9a6a50a98c289545ccb82e9be55294ec6306962a182ce4c4e57d51c9f8e497d56d5be9b8aafe93a1b142b81b4c47ddf1d25826280f1c5b90fc7cf1f3e666e48987fee290bd20ef4e2512bd91531314a1d4a4d4d75df83041c2622d8910aeef7529ba58e95c5b6a7462d2ef6895d81196b03206f5b913639ad24de34ade2e3acc39b4110e6b43934959847e95a1ae29da0c7866fbb78b38464c4dbd13f1dc47b2b7d1691050c1b689c0f49cd577849478f552ff1f48554e32170530987fd6ea40a3fc579fabf216a78532541e1d5f7f8c833e9e6fd8b44af7fd56ba359ffc1a0b3afe15af2d77ea76428fca6e53d7561c63ce007bcfe0223f184eb0e2301923f76360f6549d07c2cf994adbd2dab7d5bc375695205bfe2543dc15a183e78df91296dcf108186444945aec89d6bdb9ffb4c8051e6fc9963c5d23581916e6bd2d599cdcd9a2111f75d02bfa87aac60cc4539513a0fe3eb8e37f5f73bec38b42640b227400911391c1ca89764cdfa444d98b16ad3d3e53a70fe9ce0aa491619dacb5d1d84b95d8097cb940ef6c165b479977b30edee5df9917634d2696ac9527a0f7bb25560594b116788ff3e085d5944afffcd82ac0a76176e6d104f84ea4dce8e063c493c84eca68b629d23983b8db37fddaa6e8775cfdd1f8247a4b3e7ef27de01c7330b85a033f395d7c80b549bc1b6597ca0c56645ac7b01dd8007a383ab783dd6f319a5b46d1f5a52cd22e6a70a03834d455b4336ee1d9f1f87bd6692b8ef7bd8875146ffec4b40a95294dcc13f2a2b99831db49d9f92035212ec0f1ae9c96cec6edf27cd29c1821f37ee83813317eb2bda122d641846c58e1d4dc16ebf654ee552d55bd046fe6f3eb4a9842c4c9e42fc9fd7bf9435fcd58fbdb97285ff893b2aa7a6d87e74762a81459c870d2303a6e4b62cc7753ff4d36df53d29174eb7d561dcaa571cba8ee6e4c12f4d76cbb9a26347b88f9979ec080f5e40ddd16933534c66d6b2b354d564792fa446054b8c57b3b2177c3c3aaf28e1db2f639f18488c7d5317a2d3939ccdb3b8ae38cbc0ecc9b77097a64db1056dbe646249017f0e90ad7046a27d969cc4e2ce648cd5b1b2363bd2a026b42328cc340c6b9afb712537760b4104c0d2d5adb51fe4f649fe638985064d861229a9078e0bb24bff0cb85cf2a5ebe7b1503a402db013ec760c4903e771c84d33c57e3c06df68392e35c03732a146b049d6f07332515129a9de4c80dd067e91d4438cb01fc26dc64385e4c4a13d37d6a53a81b3f9f19d1fdbc9c24503463d4d8d7750253b47117adcff04dbf496aee57953eb924a75d2d951495629001c9f64dee3410f8a6ac19c302f49cb0805e75fbe7ced805e1acb6a1ab0e73652d60b986ee7850adfdcb5418248235369a8dc06e0abd0353b99d7c250883108850253337fc1649ead1ea3078ffd35b778df836e5bf0c8b1beb57134d29258466536761bf8edb9947283847b78dd247860994f5f50b35402a48b51290ed8d0484bf7fff14f335fd3a365013ad157754a14ba75be6d49961f9613ee5860e3e8131202dc264b314db69cd9a65e7985059ba74549ae0d7957f2d029ae938b1945c87a4035348c473c5c061cd724319dd93c4d973497f3497dc7b89c9fa3a1c5230bf53f52c29d1d103b0b7329011f742d66898b47a81a8981fde3edf2eb88d5a8fb07dd4ca897168347e8ff5c453f9689217877b816fd0f09f13bf884e3ace75897b324a44f9161a77278a91080753798bae133bd45d3573de12bfbd05cd24602acffcaef80908473f3f5a9b7c09e4bd52acaa306d3c996071d098793362e19c9fa06529eda72c086a57bb4bd51845bbef0b43e59a24e88527aa516b47509e83ab9c93cef5ef56bfa33994bbe93be6b47c89167208f81d49d28822d1976db02f9b73f080cbaf57c06f0a7db7c8ec984dcb8f63842476aa0d8b5377113f69e3db82ea32d268d18bfa05ed59e93ac498e85e857c347bd10d734255cee22bcf55e304d18da245221b29776631fbdd6b75865381312ae36e0002d8a58abcaaf9e814f1d247355cc00f26ab8df1c8b79b54c9f88d7a7b593b9b9f37cb04a9bfcf61bc186197e928763f0ed17736fa11034570accb2bae1fc1dd626d75c325b3f2c96a0876721af4a58b3a95ca6ae93f6101b0d05c1d5608d4338cfc1e177295da0bc97d6eae8e974ed9a3626902f1ea5db0c045c2b4e985a42bb3b49d053534fa2308f76a1673bfa60be2bf22e62022ec2abc7cdbd41f5e9a5efd76c3f71ac8bb52088e51cdfc94bd703f95a2e06b723e3d1af91ae0ed5d8ad8c7f9e026d89d38dfffe7b2fa90834eb4f670ee713758e817c896a71ed777f8bf5c90d35cfe3cced9575e1f0e7ef28abaaf37253f3cee0e066d48a8fa355497d91d45c6fabd95dd0cf53832d8982df3aca424b9431ba72bb16fc825f1aa97ec351cb0a2ce54c8fddaa0eb47ebebaf79c868264bba937a08ec5af44cba82d332420dbe57f782c1fdeefe809e5e0490d218757b31b1489376559e7cb3710515db808cbd7717f3b974b57be32d54188d6fdcf83f3e9b062b0179a024b3f03cf6fedfe61cad43768779cacf4c9fcbca811ccb3293cd6d31d65aec166011da1495501f620132bebe04e76f04bf839d622a6af6f36efa3148fa517e546e58df252a6faca73de8eb953df336c554338198be1d7a7faa95e34259c942610c22b7966ae6a141ea2c9dbc311fd0590399771f81ec0e71d2a2f263503dfd5e4601b6fa4dd08f881d2f5be0328ed459010c240fcd5d978bac560fd058ff90b17b458d0ef76297d8a0ad825a3d4ca5dd37963240f60fd7d2aaf111ae84cb83e25c8628d904886459c3de1be5dc4d98aa7007bacd4f5a86cbb69ef401857fcc657ebd3eeef4a717eba741a51c2659ca426326d62a94e5083c6c8050e01c71058dbb5e50baa70d3f8262348082390ad1849e5467fcb1172b07cc5acc61dc84e6f77ecae2b14aaa31ea2059c3a32436d6883b706dbf391c1e7534c463d2402c1b563cb0c91d298d8b093b12e35eff684a89c467bdc206f7e84f32c2eb34fd16e34524b770844642b53348837f5ea9c7f91a7a1ea0c1c33833da38ec2511ec60e9f78ddf64317050c435283f66d50774d6c4b9e8ef847812d117942fe4f9f63ad3df0a747d4f4a8d800f5d45bc64bfb16ff1c3257b12f1b218f58916d2d3b05b03583697827299720e83e6eefa9b250135f59e75d7d57801ceca9ffbd2ef95f29cd4377e2da0b2c646a5b726a871b50ca655185aa9f262390305d8ac3bd696b560625eeef3da1c1c21cf2cd5b64a52a7f3d43fbe28a6523cf7e8fa8817fd2edbf50f844e233d7d0de318d52726a146394648790a0962425081386db87c1e196f3277b484a2f4120b084443745eeb83f895b51ffc497ac082000647517aac32379830453dff4c8cc15c5c29498b604c47a21e1a33d2a6b94b9f06a005a0ebc371b9d029f3487078214add106a20e047f55a00280736c9a1dbaf28475ac73a87bca1aacdc073ae420a5c11a0958c073b1b5ebf3deb5ed3740491421acdd508e9d1b06305c482e7a4f9ba2b83bd5d1d85e7aa90f35169b7e6d1c014c7d0b16b25c78426a4a0bb8e2ba620f7f12c22920323053721ab1905dede2a212f612e3a4f9dd44d361e666dd8d4e539f1f5543310664c75944905074f3f1b8052244ad03f45a775b3aeb10b0ebef2f00255f07e97db024b414017ef063799e4f09f90df24de5e2b3be6445567ac36442d001d75ec34cf53f7f9be3749152786ff9a21baf309f104c0933821282b9f6e0e3d77b43f341999a5e8419c98b84b2cc2501fe2d9c6b299a50099b659c65a6f582fc9884bc7aa9f62bab2186e107c7841da8eb3d420da974dccafbd24a2a0644fa806ffb2bf68177b35a71bed74fbc8ae5012603a6f61f7bc230a0fc80f82900498a7ae279b720cbc4113cdfeb7418ad50e0972b781695cc623ef65de6b475b3fe75eea7eaf31fd0f0c235cd59bd9c70aed07f0552ebc97af983a61adf8b8ef62014034058d292ee35b6c2330c40ab05151e28f86b5eb0a37f2ee9c7993da77fa2104eadad8ae82ce24ae53e5cabeb5e97f181d4cb7617f0002ccc7aa7c40cd1edd08b10e8854328c278017648478234c0ae3ddad210df19e6a0d972056393efed3c3699e2994aafd730d08b08119cd05db5ec4b3c4cf791b12e52ab0ddf0b52c2126c05992ca559f240ca31b8267887b6f778944fc71053ca89a16a2911c0080f5580aa7dadda0a37bd680919b17ccd7c571e2b62cf53ad3691d79c8d369d58685d1551c9ff84af81ed8df0fdc6ece3ef4b730d37fa183b946eacc767d2f2591ed45fc2280739ac8b9c4a88df84d4beb1e268284d26b9c019a4e95c9caee2bf1e8dad84a9375cc05a9767f0c518dd1b07e5d7e6aefe66bc3131374d2f587b80fe785ee371c08fcc92139607b6e1f4517a75d8c1e0d87d6bfef7fe56dda0a08570cf7302ed183c4b773e070ef74f7a93327538bb0086233e29642b2bfdad910c2397ea95fe2f7bc7bd616981c96b32c25b73ad0de944d10f3b215be068a46d0b96dae3bd900549a92eb4d5d0a66d39ff60ecd93ed1706cb07f7362fa3547c9b17a60006813ce2c8dc3ad2bb17d3eda4ab87826bfd10def508c98fc7d4e96f0cdfb0108bbbd00d9ce9d301ab4e00ad922ba05de2f25d403a882ce0238da7443da8c37846f7293f0ae217783aa68b05facbbc9932a7543efe8d72a72410916072d28f332ee9cedb37ee6ab30f300ba7a0cb2a544b8a0349d0caa841c235623e42d485a58e357580f57cb6c9e2e81bec34282751390b130a23a26b5273b952d4a0d83954bec1f098f6942c755e282c0fc4f2b0a27a2fc52d7dd61eae9c48aef894e5e8cacf6d1ff56a62ed3300fbface1e5dde3a55c9c18fc8d6501666405ff072a38066c9acd8d7cafb31b325dee1e5b8a5dcedf877b7cc3731cbc8ad25fcab437e0f13cedaca67168f4fef805e23c2bde30d25ed3e665e995b234cd15f08c0fb4995e5cb15d7bf9dbbd3bac9f797e0c6dd3d490705f11021df3dc885d264834a68abb43560fe1532f67dbd6b7e6bd3237ef2621d7d40f3b0b1300ea0e2a1e1eed6a352c1dd0118aa764b4c7cd4d8f55afae7406d3f1f823565a612b187d2ad2125532ea9b2d49dda5be95d6f6a52ea67922ca5ca5c6d0d76874abb4d84ebcabda5e7f58b8a34ede5c1d02853568f7de0d96c1e672000ee437ff364aa994acacee192ee628cabac11f864dd4abe4b2a4dd10e5f62a93a2960d1e4c799978548de6d0ad868d877d45dc4b7ad63e645c4aa2810582fc23e922860552a54aae8a45e69c94c076b67777ac9659bbcb4be19bbe1540d1d4eb2f7a81eb18cd82b11ebb829abe42f965a0b7178830dd39a05764ee65efceff663e325ec079d7392a9846d4eb380b0de1c7dcfbfc532af0ee91e4ac9f806cdd96cc9c2ff79a7d5cc0a0c531349e86d84e18a2e6b61d0971f742540746e8ee10fb878f282e89515a03b797402cb052d18819df45987d12fec6099e616023be4897e80dbcd8d4ed657a370395cdd01bb2ad2341f4b9785162891fe2a9f31fac3d3e18b4f49d3cd80f45c8d28a8c2a9d2beb927c86c67fa400776da46da137b933353a7ae629dcf0a034dcfda0d26ce7e11cfa881bfeacd8868a818850f202fe25c5069854c0e66a52ba95bbd42a0633ca7dd5aaa1f9f1b5b766155a3600685ee74016c25213e2ed8ecd13ef9e3251eaf428630b859a3730b76aa53ea80a4ec243d18786b34a07ca5817cd69f8caafd50e398bb6b77b64271277daf127216dd77f3fddda83e86f6e36ad5a0bae11d4f91b0a526357d74ec4c969c3c69e102dd65d1a28b89034c0ee742e1af36f5fb894b9b00a3d5eaeb3632933ff3224b12d2ecd368b30886b6ebe2701a6f91b140b40e6ac89496ec298fc0f68c5aedcb0e654825689b0366f50a1d3c94cee69f9219ce686341903a5f6c1cf58465fbb57bd986363a982a41877c013fd3643e5d338759c2486a5a38d19ae3322fca3f627c02daa9ac7537a90393e233261af961884b20098a541f272034883ea796b2cb259595708782382ef0b5b82d41d096e04c85738b507653cdbdb2f4760a4c0d7521b837c107a4c5b6ec003c081c05b8d52534214101bf619b1a6d758252300426a88c37bccdfd13bb9355e74326ffe4e8ef38cd54d2f334bf86428631de7113534e60ef4b8722bc2d20e2549f9728dd21f4daf9a757bf9c783f401824e712b8fe179c97f5780e59e0dafea23db056fe6cb221142f88f67a2bbc43221ad9b7b0ae63692aec9980a249983bb3b93b2aa30bd486ad8ff83124c3228a43ced5a25b4e04a90a6a2b128e597ccd4eacbdc5d54dbd137e530cf6f50681cb45c56b08ee5fc01304ea8db166f56ec3d573e7dcf077815f7f1db24d051700b88c3b38e7b4c179a2476dc3b2701f3554896926c8bc7cc0ef6396edc59a33d19a7ba91488320e0678cc2ff744ee1485fbfbcf6e502cb940de2ff11121e00f863d56","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
