<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"677e19f5be0ed02c1c084f01ce578aecd16ab8c62eb4ae52125aa23afe47681f9bd6626f81e67d92ba259c8ee6b27cec79665b7ba1cb6e1a2695a91f58e72efd72f79cd6d1282764f3efb4e51e47a98567f415ec92a2e152cb4ad82c251f04f3b94d9b2f7b8731455f69dceba4d1aa961edcb69ea1e27f4f90ed9a7613d655c4fa0ba463e5a9acc172944674bf8a019f04b126c914aec3d507e4792da14aabd1fedee2a8332f9690e44b5300d3a6db2b6870b154e7eaa6dd645252ad1108a4d4bdf8e5f45e1b406a9405902d9e0812222ad2a8ffe2987c12468da6382b5871d9bfd930964b793d5071af9351807077f54fe37e455d0f1969d5be0704fba52e9275e3baca0ad14fe86b61d653d26b9c014e8f9e779e95d1ed497520972071f1731bcc32b418a8e77af2492d7ad71f440ea1a805e4ae051ac020949df24f11cb7e81d7d2251ce6f84d02cf856d0e3cfe9e4e0f76a49f2fa46008abde4e60b80590ab79c224da4ff3d8e429253d8755ff0225dc3dced973b7c14c9da01758670dd9e90a2573ae8037bfeb525be57c341c0ef360ca09927e418abc9235fe8c5c89b615cfe3365a079a516915d092d5a7b8103e4f0f8528c707add57cedad3535eb959552053bb8a934ba02906d4a29aa599251f13b52b6ca93f9bfe5bac1832040ce840f6d59c35d1fbeb35f878240fcc7ca0401122159435050db865b33720a2a085bdda72193c1ae14d6dd2642e23e56a0b1978e07e1905ec8fd43fc9a40944a4bdedf7c45bd82f815f1df6086d39c0be6338e4fffcdfa4f1e69b8df98224c27608db7a912a9e104c9d750841256bbf6173d8923f2d36964a0f49885124771e87d54f08d032b533c7d312f7533a0b497e0058914c0bf8d062e74e831c81ba715de8a96e5052d96e11a47c649af08f01b65337b828fa4c2d2ccdb9ba6638a2d1e94fc8906c492ddc55fa37af0b16a5efdcc57039d1a86327ab09e5e2a3353007064631cfeedcac9d124929f44e5ae5026cb5574da99233d9e5fc909fa242f1f89e95871faa985b9121a4e9cf20de92d9b2be3c87ec35794520af3e0c97a3540dfbd80b19d5294995d3d30f28531b63dddcbf0e05d5d6d6f6cba65204b487a00aed9313afc851a9679fd1c6b980c1cbf6244dbae74e25066881978fce40d0305008cbb75869ea1dfbda7b6306861ab0f9c20d5e7658cd5f617a21232b1a049d2b4c8afd08befb9ddbbc923d921423ad2aa5ded058399115a4cdd017d5e506d7b9d14997f820cafef74f63532e7ea91e3cc76e60e8804c33cc26ac602f144620ccc25ecd75d1649b1a0857f33eaf113390d57fe48548cf05c64428c20bbc838ef2f39f4228e65ca2b70dde60b0e35713a4916bd0da55c1cf32f36b10aef98d3c8b93a54ecc7256f3da99e45057cd21b64497b048d000cad211c4675518551f6344bb45667483b03302ef1a3c08d3c4ceeaa085ec0450dcde048534781b359695fa5717f7f52a1f590492bb9ba4891beb5e2898f4db3f01441f4ba45ed414932cdb3c9f9894a1c41ad345f57c7a70aad267a23ce18ec28599fc517edbcc45bc8e9074748c8236f09814004bac9b916d3d21d32dadbcb872f21961dabbf2e0819adf18c16b6443a41b529114cc73a8725241bce32faa6a1ae757c72611cacd69ef4505ac07c3c6886f8303eb329102f700422b85e4c0f58aadf82856c95b854bdf820cc40943b940bb4ea2e70e2a4b2b43d2d3089c2611cc502adbcada87000c91f2cb9d6feacb860b586c5fc00e45d6ea97f676e0c3d25d6f727b3f8ded09e87814f6ae879e58473d77fb4620f2cc5e8c72f63c614084cf68581756bb0cae73ecdd599954346430071b963d5d06cab3d4f3b2ef246dfe96e2a28932e22afa36689094b3f47626b82a2336242ad0a2dfe3c6ae9d613dff30f05c537acb54452293127cdf51ec5d018a8a7c1257be5c3deb78eadcb9a034c0a57db9340c1cee497c40f176d5431ab51acc9558bee38bac2ff2e23cfea522a7ff75cadbcabcb73630a12c1842d1aba5790c3c8f0813afe973c89fdbe0f10f6dca461766e4cae3a7a8e7d2cfdc294702023843c7f3e897b4ade5fb4f5dc5ac47b7daf678eb1172ae022069033cc47bc942dce38a61ef58bad3cb5b10fa1b008b188b124be2b82a897be0d57bcc632ff6c9c6b125172584ccdd935f08fdd9818984c9504bce65415589f6a9ac5ec19d836bb31038b50e63820930f8eb3216e193f54934ac66f54c74c13d470ce5d3508d8d85ea530280a00fc8074e297ff9c4e1da44270b1a472c59313448763985ee9ac20bcc1912b906c4dad3cb6a503f00ab3b2f60fdf535bda2ee964accc14c490fb15d0c5bc29f3fd574c143675a62cdf85f5b774e4071bf209a38bf887dedb4c991918081c409605447aaef326662b9a66fdf68fa000d0a6002d56d3e01f039d5d513488d6d507cdc3fb8b19d075f7986e1d3ebdc14e89884f35e6a0585a003361f8b89c57496801053798f2ab2ca894720cc7f144c5098c1a39e438df6a933f28026c4a1a64cd35026c72c3a6eb065e3fa1eb698a063cf3a8f2a2df7f8775c6bc4c9986479bd04b612a54e3bf389db72c5a32f7f74ff6ec158331b840e486bd1d4782d33be1e050615e1aaafdc0da987c58c71a95b52b4893cb629a816fa49927224fc3276b8aed6b4f33454a576202e69ef0a6a27f1d18ee7ffcab598f4dab270f85545ac1fca89d9425c467c2e20ab727a7415c92b8fb8e3607999c8a6b9ed3d7d734662cfc02b1ea0acef76992e1c04c979d6f186cd097a2cfcb3dd54a9938df173e80555eb14b6dd4f91b30270b1e71026c9b9e7fcf8fd0c25ca7dcb00d92f021a3a4f7f7ca9df561cbd6d263b0d20fa48625600625e7aa98d6b1ada76fd7fd341caf78f127a59e194df7bc66f50617f12eec6bb15c0f05f15973be4faa0fa3f858406d778ad498ff2d85ef17c4e3436f8f1bf4905bfd2fed444970d6b02748d6ff9a719423971cc5765150994e2d0666a64f94316a17cb1ea8a7293e6170386b279b52fa29a2c4e70dbe1196b82b23a96d9e290e3d0d5b31d478c19274336ec6cbfe562d9b5a67e9641df6fdb3334d0cd30ae84b1b2c83d7bf5bec89d89f972a9163a63868002374e96f608e1980a6a5e97b339127ccc6fad7cee5926a62234e06126cae04842c9e6a9a78a737cbf525c59d4177d37136586c59ceff6974eb4ec996bc145eea594550733c69f7363c13fc1cf5aac504dd0d951c5e72ad10d4ea0710cf55c142c4dd94d6b967a6e718dd66317d7b270d5a82c403ce29f42dd6db850fd0c00513983e52f8e3128e6e3f05d7cdbd3939227ebeea34111791ba5c19da8b67d7a7fa5a40cdf60e97d3a26821908b52fc2431a51f378a2f02f77a7757a364424340a293ea929e84d3b7bd055f25bc9368faa7a6c0fac1a02e54c940a52ed4367c3f9f3bad0bb4d1fe7112c830ebf87b356fca372351d70bd0da23cd529de7405f05d2581f98be5bb7e2e6c176552427afc5364b8574cd7399ac83911273c3f843719f0c2bcc194a551d777c7b24b3f1428e35a8bd9e39366c4836f4ed48fad266c73c343ae7a2e5a3a377b6c97756dde439a5b35615cae08421b6f0fb84a85cf8d2b889a5903c84d361af1bb547042f3720b53976b89728f352c4e426773d0f758d1c4bc693de077e1aad17edea04408c4839d9e439d4b18a965403ed6ceea0264f8146adce79b2fcf890757487278ebb24dd08ab6104fae4a4e80d70af0931765942728022ab8bafecf41af40b0392ab17144b99d945b15c66a6917bd59f2b7a71feb88acd4709727e1735eabda11bc2a2c74e74aeca454a01390879e25db0e59b83f6597dd10020b57137cad2b60efc22df87619b77f771b6b076ef5dc0e1bad3f2b7b47d27a6929b213c21f7227b711c5394de8b716e995f13aa3bca0da8b7d5528989dc35ee627b57f1afecb6b955c97bf61fe34569fda32c24dadb9753493cb808fb56afdd3df6275b295f1665db2966cc82f0abb93506f45c831c2480474f91184e6231209e33937aeb21217c4aed0c8ae99941694e98bcc514c47543906a04635ada52b791070efe3af530d3f8042450067508d19be19390958d0e9e7999b17bc2bb98b3c087c8644e0d9d3c15c955cb102beff455b967124ea17b61cbfd4186959221d2f65bbc967e98d96940f30736ccffdb15139b78e756a5d054730395d228b36ae8814394c638e74af58a63c9c073406be16b60bb344043dce08ec33c5590e0bff216d3eb7049d115bd85eb2bad09cc67f89b9bc2ba51a46ed2dc882f9ac673ee7c0d543493fec42f63417249e4651936d32ea75c24d8e07bc4d97ce2475da2217cd12e0a9caae255d694061a615ccfb4108e3b05fb581c153af572f43da2a99a0a0fe9be294784eef33d15b6c1b125eb68380453ca057bb3f41d8a7a431f442057804e99bb6705901ff66c1bfa9e7cddc05cdc5625f9ea01c91fd54ab19c401b4d9b2efd431413e29bb70001e44097abff8756d86dc20fad82f0ea42d7b9549f86811bfbec8d2b050b07786815e980c508ff86256ea30427b52107611aaae55f579efdfe1238a2d7ea5f020e32bae30dd26f1ba43af9971dec4e1a9925adb1e60a4ae02104f6f86df12d866fa5c6bc2ce1da6d6201428d0ae7cb6756f4575f29a449831e25b69b6fb51c56be60a2ec2465220493849705410c1b42dc160dfecaa25f6996dfa724585f0db0421681150cd20d005caba7ac30e33971fcafcc63df8aebfbb65f16233b6ce7d6be80a9eb995be28aa7f3bf6201d38e4601334e76dd35da4b5c9b417725d8af7516794cba2c9c21dd2e9409e6167a514e5a6f73905be17a735da080f3fa4710d117b831990d801d91dc5bc16ffb2396c321ab73dd10fbe4b5de61c2d8db95740cd84fc694ee5509d8bf2030d9c1bd67d17709ad49c6e125b7e8e8bf1ab1f8cbaa0163958cdd1153be41b1dc45a6a787af2e8f81193e098c0a114427bb5ac1802fe3b270f1a862ba261c4f33cf8c2a9dc72ff7dbf10bc3c8f03fcea1fcd0239bd86cde37fd03f01749f0db4fd19e042f555f15005d1bafe6bd637017a82322a72535145a9a4509a96c1cc82a8a187ae4f6edf3b271c0c6b5895c678ab354fb8d02a22bdf37b0bc3d1a851d6019f61f54e401d4f54bebf555e669a6a91808bd4bfdcadf1abb878ba6d7376b485b35868d49f74aa011b8234bb26261469d2ee54983e266039848b8e193f6868b8d40a885400f43532f5ff77f072ace811d732b1526f386a19f814b08efe43c2ab8dc379baee8b9aeff27fffb729e6da83b601a9faaec3861f293af4a28b933ed7fa749d8ed872ade3937fc761b3c17c54baa290c7c701320662daafc5c29703643a474bbdf6986270157f9159ce5766ca4f218a4b60212a32eafcb3530f63c1bfbca0748d525b901aed17fe1116b093fdfd21c982a3684ce4a739910a120dadb40c9381e019a496442c9a0cc23d34b99793ca34fdadc9a37abbd92ef8fe244f0b43c434645eed043159d9659844b5f3239cb6e92f78d1d19db6707e380ec6cad432e90d0e5541e2533b7d6664dcdae81f839105bcd53716a694a3eccfdefd6b04b62fa1a87ac23b6c3f9ddab25df12c9f07dea63e25623126c77d7b1b000c9b805b3e8b5e23ff6ca2e5142b480657a0e125fe3d9e171f361a016bef79ba7571a92616bbbaecda9d2bcb522cbd4eb3ba9ec72335c42e3ee7586919566e0b5f191ea06becb2479814915b11d4f2aff52895085ec879a04d837ce2d99c925c18d19b2431ecb9d51e6d516771fd40341d1391320591133b9710892f85a84f40fbefaa853f88ff11d6544a854ba7127db04f9b678afbc4e135066d613875fc6921e5112c3526414328181ce20e099d35fd2b3c78dbc03999f2d4f491db7e960c144bc8e3f117f21c61a5263151e8415a102e96ebd7eb9f90a187c02d708505ddd8475889ab10d0998a627ceb40939b3003a6f6759995d98bff981a4d483d910f328d04dea6de12548f67ec0f176ddaa41a8de5e740c2fe43e70982b33942ecb79804e064f9dd0231c5421644d3f0e91c719b71891545561910a8aca3f249cc3bff556e177797b65203854d53465591f0e593fb581be792ee5a194102895c3ad5f04fc4d57322d8c6f5bfb8df9fef3fc2b1fa58fd2682718b6e96578c31032c7cc3d85c00d5075b4a8a828eb2adcfb044f4bb0862f38060ecd088a0db90517606e523f915247ea4c9595cf870f7fcf61ff4a905ecf3570b9c7b2b13865a2d9e9eb8b3779db655534e762d9d17f472d53913da6817263418de73b8be960a191c192229a6738ad36fc3afff886c8e1234c815a1646fe1d8265da70d224c493b894e9088a78f14a5689fb91458eb4ef9f035595f49ac0c58fd91d8d11ff385e391b96815bddfd91fd3a76bd0128e1d27e5e793dd9ed109571264f79f60226324b7df0fddfc2ed23f16ecb4a7adcf03f0b56e755b019429d63e2149b0631b329dff747b3b5bc68565cba9eca5ce355e50c964507640dc130a783bd743da554a8060e292730d0c29f28ffad69e9ff76bbe6a1ad0e837d175849066d994071174f1abfb130aa20313f1828da22307e9660210dc881afe354a02232c8fd604a1e576bd1e1ca40d9eaed033485bc53147de66f52727c63f619efff9d01f4ba8749471b55947ae118dcf0a2db6d5c8e79a0d7283bc8b551796dac2747cf2901f617742d9cd69fe2a610036f771ceadd42c6b05c2cbbdc065193c2e95536bcfe80e4995dc54443cfdf56e750feff35ca6406acbafa0d2da59ebf8ae7eb480c388f9151ce7ebcc71a8f6317cbfc72d7bedf11baca3ef5494971cfc6307e10f9fb7a3aae45770ef24a12a9b38d2444c3b46ce3ed6312da596fd962e72005fc5aaa94b2de87c4be8d06cf2418ce439c74bdc5267dd69e471bf3a77ec9d2f79375f5ca2265c965a312f6f3fc93c28321d3665b85d27a6f0beceab0d0fc8efbd40ee1caa8016ab1a2f1fe35a1b98381a00bd2c33f1668b7b8f05ddc01bdedb0aa311c2091c1baf229c5f6280bb14345383644315b425e533b16b54079cac55e9c03d8148905f9a1105072f6f4d4cf307ed8efb5520324565c3f153104bfdf7d1f9c01ebe8599f78a09aa6eaa495a229213b7adc4f8ce3c833df3c2af161012320f383f101571cd895825beed019553d1c84920ff780705bbf4c2a5712a7ca2d8b5192a3fab7a51a347ca128d535db94e9de8cf5932bc5c3b599fa1403f84d1d97e03d00b52cbfe6b5d4eacd87c91d378a90e8c843780528f9623cd16f4253023a3804efcf7e4d85d0061602ed51e1392763d6042255d2911d7d045327ab2ac048c3dfac22e388d278e116bdcc68fbb01b5fed20921fe16daa6f5f47e3b3e9bf1d5b2de23205d7112340541b6178b468147f300253b8fa9b69beefed35dd0bd4b44f224e1f88e4cf80c2abf6692bdee198fbfbc97c7373af5f8d2770abe7866d98714ff953d618e55ca00bc4d3b41027b30c241d7a42b6b00cfe188f526d4a9c3918b8bfdf443f99abb703d734eacb81701710c6d4c25cce00675208dc01bb719742c0eb9b445c6f4f6f6bacad80e9330748abcfd11fdc4569ce7b2ed62d148f0c0c45522c5159846f6a27a1c16ee9d2ac5e4f2f12fd9e40b7546ecd7ddd18917e901b7944cd2b70ed585b176f66b86677e9d977b00925819c66c6f9dbb35e441288af709dbc26dc5f8d4d55e4212c2a8094a02fc291586e82b405e6a120e26df3b92311ea94e07ef1ea9ca6dfe86d8fd74953bf7777d43ffb0f4662e7e21c342204576961485fd5465e264fd8dfb271d2c91659a5c76de15fb4628a962500757641579a9750c6e9f999fb3e9b6b938d68e1d3933b149470d2926e0b96cfc6901decf92056149dfebae3fa2d8440be2497772b8d1fa8e1658d88410f6fc02445a47647b3037c18d1cb8bcc3f26b9f10a121b70ba85904b95320262dc8dbf852e7c824b429dde703f3a8c83fbbbcc5cdeeeb4a4816c7bc7a88c228a8085346219402259d1ce43ebdd26202f306972eada472214af537285c81db20d55609f4a0d214d42ffdd9ab23bc31c8f898f84346f06630bde010d57276b4d54f6214d5786dd6b47cc7f1fb22ac105c78f1fa625c60af81fde1e605fee05a33a391cb9675dc05c282c4d0f597b055c34400236b1b77d832469457273c2d4f3005f3dac232702b7e7cde20ab61a889efbee5556e2c8161559282b2845cac0f9495b6ce79652f25e226cf6931944a54b3894fe7b454312eb5a744eb3779f85540f3982ac04dca9ed787b94c4f60bb05966daac8f1e568a5f19124b18b253fb491656f61e5ef4e285f9a197bc07bb61ec87d2a83a1501b52dbefc7504baa8215f37f6d3d804bae6abbb9fdb2a07295746ebf5e45ccfa0ba9fbca106afffe193ab8b777d40a4f484fdcfaaba2fe10e2364f35ef4106d417ec46a9a5bfe4061c1c1caa00cfd205002d1ec9562adda43021b66aa07a3ed0239d890a9a73abfed7dc61681af232a31ae336f6c82c516e822eab99a56907f5f9e7575a66d8f4042546a1b1bcded3fe2b4804ae6d2922e5e9eb77805615aa055cc1dbe75545f75b1b4ee38049624a452a3f2609eae046d8cffe550cc7e4c15d6415a4e71b56be786f4205e8f64c5efc35a1bedb021ec2e8d623f87791b88e624a7559535985f6aae4ef06cb60c495e0840cacf4e98b052d0db944574ad43ed281ff7f22fbca4c0d926a2c1df5a8206e8e9ce3af52124affbee25a27f499f95267bdd34213e9cb87968181d9bca290d642d8a0b08b05d2defd2d53137e320b160c9a9fcaec354614acb1b0e69ee58facbff2f3820ea960a0751d2e6ee19e0b673fcf0c03acadaf535512f238e98a562a110aff33b76870910cf86efd117397c64cd290d896a6ba8b4311621d61b96d67c90f914b27d826bfee81103c54f3029fc52c26869fc7103ed46400fe02ccacd12dec78969342b88aee4bd2e71d2895091de4385adffb60aab51591000a4e642c5a398b90ec60a423f3d3d1dafaf0ce14af9f03673457d2770089e0b1337fb99d2a21ffe64fecc65b8a74097e6eaf49b3f92a6afd3abea5ef8b4b638b04ccec95c6170b4884960f22a893a703aa6c8faa045226773e4c61bf08b919de9fc3d87a341b15b53ca94d3b2ebd5def4e09b74dd1c9f9bdc495518b8660eee81e2365136a71a62b86b0ad6f6f4357dc5222b5ec0e4c48b4d967fc5e9358eb9fb10ab690f7088876c37591c8213fc0e8f74c1f57f8e280636f13528b8211bb29a451b9b4c7ef7926c9a49159907050e952280d87c0a3fe8ba9ec155b4a2a964d03b5a098bb73076b95ac53a9121bd2ab3f0586565118eefe4a3c7a807217b6834394f12a943a5f9bd327b6c1d7aaec6536fb521890f66ef6ce0c7b0426148f8f2a56a8f46044578beae0762678e230055c7b78b342ac67aa35b68477c069efd63017c4cda99a501250730efce763cfb0c2b2607635bb1bca99373d0cfd938a6cd6aa6cd84cfa7df649661ab5ccf52087ba848a36259ec273b30a92ef8da33ac02c1501af7b0580d132f750e9b1eb0c8efad2eee7b5a5ee04057033e959347278a0f5d1c004160c2d5156d7953e8f7fe71219dcb6df2b5f2e2d756cb1a4889b6ebb4fdb7a11b4c58ef151c9a653ec39618a177e41f0161ab0401d4d093f680363700a5f1fa84c59261507efa861d90757bcf89e817bb7bc0afeaca3a2a83441c4d8fb4740124f513149e9864a858fcc6b8794994ec6e8a80cf2c53a60cc258c1328e04f6e3a2849f988b350a6994cdb83541e4c529b85c9bc0f3dc1998e0abc6665865c208654d15284304326e5b7db6b28ebdc37baa7ce511ef52408e08b3796e5987a2d6414407e34c23cb98204be78b36df05aea90347ff78f291707d6fe506e5d305d2d6981bf2a3574e9e91fb37b5c911910837537d7ee00e95c05aa6d7b364c1c999255ae46780f5684585c5bce8838f7e34a1c7ff65cdae92c27fb251bc8e339bfd2add8c5ea14acf19357c50a85e0bc11eb56429255b0bf4bfc6629a8d6f44aeb51cb2b2bc89a55a6d3b2a7b08b1f318094ba7907456b1458928fa438fbe39e5ce112bea2638334bc19d283084e755cd1720274d9f5a0f3907433310287e149e43f5dffe44dd0dfd1b44c3e0194eed51a612eb6403bea5db0e3e50c3ed07cd95fa19fa6f045f4f75253ea620d7e424cf121f0f254eca833a798080955f7cad7aaa53f46c5900b9c6f00042345490823fdb586657554b715750c4f2017d5af203b3d59dca7cb5ce520d861caf6a1acb4af3bd2171f98032237e57cef51b75e01f8aa6e59fda833584e68466bd417f0884d4097cb1609e46563286d1b527d5d12708b10952be372849de179ca0d1dc869a59c803f0991e2956332db7d2cd13664ce6a87ce6d08a997e74c1524052d0100b520936aa8c46a75c8fc22c3b6bd1f0e64694ea5123cbf1e39f8a7c14a60d2147ba7f712f53a9a99f55085f2763f3f74dbbc0b6fa924eb2377c9ab992b9e3383f710382bc6b2dceea93ca66ca069a2867759291ad764d34db0530e793daac87a97721b697e076abdbfdaf05aaf4c42e802642fe7696fb2182e0118b7089ae5272e256c776b1732298777069993b7e5d654d917e759439b09ecd803463c7605823ebb1acff1630550ac09084c3a77e4a98138a86017c3fd218632d3de3b45dc72bcfb7724e350c216873895e6ee86950181abfa6ff95f8e8fce0aa87b7ec806d69cf79af853e04fc07c65429e2f5567975986469e7911452ebf6bfde5047f5e0c2240b38deb39b0472a42ff3f092ae90e3ba8b71f7eef9d7bf77e3108ccb293d8233eec861faa7d3d508cde8dfc0070b7c9c5fb9980d3fb6b362427a752e6607cf6b71e9a09cae05a4d364efab212765646fcd2211098917daefd6c209172a47fb6a994294ca2586b50a1419f844c1a96e42246bcdf83da180fa2a19858a0cd6249f890add41c98bc149681359ba2816670e38249a06c9e317ebf7a39476c1fc5f262daaf6002cf6ba0ec94dade91da8dd78d7434c86a447c03ec551a055623cd0ca65688b02c82b493da46ad244fbba2ffb6461e3ef0875ef6e4cc29d59e635c47155420ade9143000ad1899349c00fc08008c9375d31c872d248421f07a103a318972c26e32e80da58ea206788c2be280eff027a80234a3a01d8858f937b1e4a677e4759735b8cbd8ae2b3fdf50f77d1a04c620be8ee4e457a91466efd15ad14d8360c0b0861cb92406ab68188baad952a2a772d13ff5b4d0bc9e2250d7d761c70963b7a845dbd1ae9e66b2216aba11d72814c24770a218e7883d159b516369f1bd03b8c8c008c5b4867ae78ffa411bd82b402b4034861c39f9cc1a493266ed2b4d6a8ff8945e0184342c7d9e8b775fe8fb0c33e48285f9ad251bb420177c2865d4685a6638b728c4949ca2c5d2457ee509ff19a178b2d196378675bc4a65b75fdd415d25bb111ff702361636749ca79a54c8b0f54be318819500dccff8c4fb0f42b97175bd98f4b1458cab3a9023af024e9b10cebd9629a515d574f611ceca27b5c5a92833e230a1e13999070747cb2b6deceae0dcf981ab86b74dffbe35f112d6ba65202a7622afb5e4e9b94b1a58113eb68ec90b6ae54e8c4a5000abe5202a58a4c145412a52740e5b553757283f992e80902d68c46158d9b1a20d82212f163560d31ceb437a8dd2a4e147f35d62f3bca2aab7f42e4fd606209a5285a679b32c251b7ac48bf38e3785e9413c6e0341e84aac44f45739143f4d3a1c243c505f8e0aa25db03b99b8ec1c1ee406e9face472c504e3fe985027d344343118eb6fe7836ff786188db92997b8b65ad3d9d771511f2a6666dc6aad3daf87165e978de79001a1ef1e82143f40c436553249d47052b6e9d6d3e9ea30ef84d636537d3f14c76e87336f8445fc6cad7c7766e1c98ada17043d687a370b6a79dd2f2f59c1c27d414df0eebc2dbbc2a2990b3615643c4583309ce0ceff657fd063bcebaf54e50e89331ddaedfdeafa925500a8f952437619f7e79259ed86d2d2a9f0e5cb773c397fc49056bd47d08e72cfab70d3f5db64ba4276eedcc840e034fb622712217e4a2317091d833c0b9c05a9723e08ecf1d6a05b4ad91ace81c308a4b936a9cac7b7502e882d5a8ff896e03e2391d923d3716fa0b75ae8f84b0afe5cfdfdbc9ff951f0d5bfe785c732d581582dc1f33d44cf9e30db20fe6bdb39249424466fb09a4153230d8729020f9befe6c252a2e073e51a5f41d63574b71cb86c5e3e43fc16b8f839e7f980d85091226c4ecb6bd65878449e21e327fa50080967ee53919d19901711d18d33c1366f9d2e12326405cd6dd386e71642a1e373ed5ce22334579b8540e478c4caabcb97e8bf801762ec67791fc9cbfdcdc48bf7aa87a8824962d988af731f43843011901cf655e66faf906005155486d848e5295b2af5458db90acf5440c8048e35f4afcc256371e186b9ece9677922f056f28897835a73f0db5a2997a3f9ddf51962137421820cec33473279559b9c9c35eee0cd6c28511eb104d8cec33b75dbd7db89f4f0caab1cbbe88cb848baf76c45eede6d5e4b0a2137126cac81173111820f9993f3312fc7d309a0cebaa90a7ee4ba38c733c364dac2f5cbbfc27c35646cb6f95f8b3d5fcccf30398edab305f2ee9e622aac5480eddb9a43222cb2c86cbd21fa01c2e6521f35ba9abfbc2bff5246d23b04642703b0e0fbccafdbec59e83d74821f77e1a221d70f4ee4033366819e44d9bc105546ff74ddb1c9c539c3b85e422098ff47d7178dfa52a8374b264082c8175ac4899a6e41b4b7eb998845b85d6f53dcf22897c4867cbc8d7707cb8aa2795602445dc7fcf89eae55e0a4b0c49ecd47c4165f7eb98c0183519a33297cae098aa673e6382975e3dabeb078cfa5a048114d14c069a47d5e80ac36d8a339bafbeed87e5a7f92e16b65f052e0cf5b02f4b47712a6ef1e3a69772554226ae71854e86300ffb3d550e66e0afa9ac26fee9988d008bcc58b044f5d0734e10dbb1f2f0a5cf0cdd9f9a618ee6fab8cf264f3f2d61080a10666e30aec3d27bc773e0a96bbc4e27e9cf5ed9e5f1173cd48e5318761bd2366441d62b126caaf8fc58d535ab9ae82ad60f3181c52fa5142eb3cf868d3c1480a52515af7e00ec7d0bfaa72d8bd4ffca4453dab6c91519d00845f406b0a86650c1638064cde97fedce200f2a101de44d6e96ff65ff70154e4fc6b37a10a7bbc4ce87af74130c4869ddc7e346f9b2655ef3d4f3e324d161c904b75eac65899f8d13a3314f5be39a90692ec7e6afb51c2b954edef6c01c1aa959f5cd0272c075485fa7bd50488702ba08629fb66b97e670dbedfedc9bf4720b0a6f2d6316aa3d05bd157355cf2a23edadec2f622ae50579326efed321d100cbb20214187efa575221b6084fed000f1593df97969d8c63e2012779874b3ade74a02dd5cc2f1444d2e3af2a0281d8b0ae062402d4ad3cfcf3bb8cf8f3aa2b9a08275c6137fdb602ee3fa330a6a9954f4629b965cc9cfc290343709b7dce464441d01c7ee64e6b7d571ab14b7e8edc170d3c39de6b36af2f8bc9d590fe1a9fa17a0fd2469849110a3c8695214af4601cfe56ef6c419868669dd00452ad4de13b0c7631614afe6fdd1817bf5f698f303a27339eb75f9867d5900057ae2f74ecc909af25ca55335bac850bb6b1c11a7c0981cf4b7ee9f823b8cdedbf2f21eb34ed125b8f9513d49805e9ac90894c2b59e381dcef7d31321b911acaaf3126eef91141e3befce81ea79aabed906dcc5c11142e0eaa0ad47f388ba1233aaa8ce01ac1f23b8fa06195a2dfa6960c4e473b13606681c299eceafa07b0b53ec87e77b62e7d82ab568183ee3f7f3b39728c5163f1bc90a5e3648b5f1a8870990d0e5c2b7b476d43bdf6ff98c0410479401fbbdbc4d9364880f8c4025e18d947a0636cab8110a84c0c205c74f9daf25fa5a441bf7a61061d7178a9e1c6b734befa37ac0c61136f2ae863b793e63576d58df170a21babd86ee45f1a22422f91a19c258781106acc0da5c1f6126cdf5f1145e05d26bf5e88b73803a563b276b5d08d55cf8b653563ae2f4822e9e4dd3a8927d280b94f66af556bc49e51520f703c565e5ee374eaadea19ab259d9f3b9c2369d6a95143cfaf8bdd6150202e79f5bb7de93147a634934aacb99267d3f940567d6a61c28c5e5a83307f38791bd4cbd6f4b63db5717c9ae45d62d4c1edba785d4883e05606a07ba1a711e4b6f1affc70501a6b467843988f44a6d8d3af1b526758d32afbcccff4ee3e68b06b410afb2e219a66ba008b1324db64541ed2f04515c2adc514c7516ef46f6dcf6b36eb3b6c920c6fd0f153d2f31d209d510606e0bcc96d94c74b045e66156501c47a645985d23495c0d7660bcf50779ed05af304e6206d759f94b80860867e85c4bfad959e07e5855eca6f210e497e52142b3ec38be24d86fe0b17db26f98b29a060314f7255db48a50e3c2b12fe044be188b20d4175f01718ad2ebaa36028a17e9d19f264f8851c4f003405a2c214689aa184f7eebbc182b564cd705a939595149e6e7588b269b3e6d7e1f5c03964b936440e297af8c04e96dba9e12b2e5d70514ac742f362602c2213cfe5e5ca1af9d316f1aa742c9193826bfa43f6003a8f19cf773b9d70733064e938e9295129b63f56b9af7f3ff611846e6153033acb519049e26b459df4aeaf0bd76dbae24c495d7b02371c0b3657d0878da721c54b864cbd6f82d2f8f36070e680d3272520aaaa6e220d02dcefb53dd89e56c5d8a2834cb436eac3443cc60bc81fe168331257165651748d6de50d0c9435f97a01ee08c86154eaa284ed7727d79c9e8658195b700bc0c36db4c11676d9620247c4044741b526d66434b190e94cf8f9e915790037719aa028387a87bb351b47cb2a66c12d795808273f79f2330d27251d6d1796425fb950784b410f843137f5caadbae486fcfe04c18fad4404c7867f08d7e054ed44269dbe7d36d54c5c424dcf474c0c6532c172d87cce2ca5cfbb24cccd2a7370bd7adab00e1595903182df41fd925f92db8a53e6d9772587041f97e6e2ed4191b1d7bdc40aba2c2f7d2711453595785852d68946a3b8e7c82efdd1f060c7935342ec3dd6f06cd9eaa8c9b5b40761c18020b998aa8e07011f76d9bf5255aff261505d1667aa1795f8d590d58ace458267760e1c3467ad1587e6da2f5a1bb009461a9e27105ada874f7fc68357bf2e726cc7eaecbda2cf5c505a332ef06fdf56c765e9635091e59b38ab7de7a86e17c40e2a6351aac86f96ca6065cac54b7391296cf448842bacbfa70c4c89dd43a03c0e0a77506d400fa604299557827d19db8fc9794590b9e6f51f1ca395c3f4ad22c067b604fed7f7ef8c22521398ef1677bd8e0b6f9b1dd6f2eb30ad3f2e0b92862d1d9e755a9eb6ccae69bd93380fc5ea558b09406ad4d459f780257c40ef14436cda0a8072782ae958a862776a9bda06711f92ea0d979f13b5c9223a271463ca54c09b1f251913d9fa0030bdb1e885256dc258eb6343a8cad5f83c292c04e057b406456672419338ab527420b0008aa93730fb701287bddb1227b8bf16c0b942681508239bf07ff302f9a20f6d49e4d9281cb489a2dd4365b71a9c2a6d188f44d2b2f3e96924dbb3d28751eb5d5a952d36ff44449a8c75ad9efdc32c9dade42429896872e2a9558b6ebc462ae9989c74b1db96b1ebbb25bb0b5996153a3fafd299a4409df6fa6b63957b06c67ab32863460bcbe9ed7644fd8ca702955f66a174d524a909df1a2a8c46d9ba95b15edb915efa25613257f458798497200fa7b8d0bfa6d74f91cc53829e5be0dc964f8af0d743524cfa5ce6229342ae1f02b434b62253202d0b5e0fbe2f5faf7c275bcb8751197f4514c68d9b6bbac18778afb718105554e99beb45391ea9b4860d3ea48b07ac3217894c283effec708c17ccc3982b3659fdfa38ca13c4ac74e6f7cfb695000bb656a180a104c2e8d5b5b67e88586a0b3146d744dead4a6aee55956bbeae6e4c0cac1d4c330cc934da31d397a9f2d63e0ac5d032b9ec158c54b23e54dc547c09bcfd72684a30ae75da55f663e6e6aaa38818dad309aa3191f3ac56cb8233dc771658f31898b23f5e147bf61a147939cd504a6482b53f409bd04b849a5dc1e14664fbc426152f38f2b11b014925b580dd493e972d77847430813e89ae8f398b213e8005e25c0025a68634bfc3e65bd7b07b63d39d695a78fe344385cf4bc904cf8513ab7436976561765648b35a299ebb4229db81ca081017abbb4df7257e2dea3ca5849f071c998b56ee5e8226e564a9606ede8ec6e53818a5094d0da6798ce3fd4d61f543af7bb6beb4a0278ec071f71aa9e1976f2d9648b9134f516e920a3e8e500098c72d90e28811967366d16383473aee536db4b0ea2ae96753d3556be8733f3f9ffc676f25140a9c41afcebafef90f183b3936b85e7d6f9bb76197f32ffdcf1c30a56438b421e60b3439c90f33c3c0cd8d723301c77773715109c2ca7da5b30fa6a51d97dbc2145e32dd1bb637081fe8622ff380dde5df5103d105bd5fd87636690519156aa04f5be16b95ff7e5fff6fa07b1975e0d8728c3a57908cd7f28ea2ffe28d57d25d4e9d02d335c23a138f70872a676aa55a63dfdf5b5ca95bf8353d02f87a1b10c7599e10a7b23d9f86e10ad135d0889cd8400d21858c9b1610deef4f8186a63abbb69d58a6bdcf1e56c6723ece79c6697805140eeab6105da0b3e49b470a5a01dd85551f25e83b28f8d6baaa0d1ad049817bde8070f99fedf63fdb48f986e8d8a35738f012a342a6dc5aba7411078fb55e555c2dad09593ea54acd007408ac2bd7764f2061d0f8971163dae5baf461caac72280df29557029519bc451587ad52e70e299edf07c3dc07c3b54b9f1cbc188d25cfa303b52ac81372aea887dcc634b4ff52e96ed379effa919c38f056d6f0cba13a59a72f8aafece166cfcb2941b312e1ea2f0ed7a499f9c554dd3f7d91270faba85874519542a8dc17e021d6e8a82ec15ce50b9657702646c7d9bd4b68704d3536dd0d762f5f9d8442a61ad17121966d581306b53ffe50a261a14b6ea2552fa05472ea4d11eb2fd6e426c9e77c6af3b0faa8d8caacb5c038466420e010ba8a3e2381668f3fef8169fbe1dd04c43fc67738e2d9a80d269c0dc8a4b325ff6f4955dc7ba746374470158f9e501792a737158bff6717723648e34998e9df7419921cceb700b43652fed67f38311c13a9025c90e4a701f1c84790f96072c1c7b97d9c2bce9338b7d7d5b8eaffb07cd3ca312b4f0dcbb39be59a90c35d72060d109da7d9080855ff5f2b6eb549b071d4a23f692f98e840cfa557548448b531fcd5d18ef2ec6103b1d20d9332644fa50f5a2a9c84b7973c0cbf99ff2c8c434e96c3cf1b189ddb082870191058e059f749b48cd57d515cfd63f2ebb2b27f356b2d2cbe1f093069cc3e63c4549786f4760eac7605ed53ea224f26197d69b36dc0dceae10a470511126f2d875e1fdbcc626df19d82e4251dd712b143a245274c520d80b9082588eb9d00dd3eae957a89976355e62078aa62250c9e78f607488d0aefdd462d92390bdd76de73692e3d5daceab0e22c13fa21a6cd0efbbabe2cf0e25c1ab2125570c57813b3076398d9733e5fd52aad4e32c445df52567343014194dcbd7172546b7e53ed8cde0a53b6fef51b9480e0b66c3e9ebd4d977368bdb6986ece7e8d66f4bfba40870cb11c37811f9a1a72b16945712ae72c3c013bd5a5aa40d5d6bac752292ddfac12ec3eed0e7d6fd65284cec11c79d0fc22a078537b74b13950f22325d77a1d3cf5818b46005fe6bd7f9b9fec1c385998c7425cdb726214c0e74f693cdf071e5c4d161a5512562090cb9501339c76a38e0572034232ee2884192b8f8cd896a5006167fc6e20acdbad5be","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
