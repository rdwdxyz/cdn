<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb5a824536767529de6cf62bc0caac08ffb137b313ebd8500469e474b5b385f3b7dfc046b3d1298706fd867f6824ebf914b28fe6b82383139aff03d9f7387c81dd47ef65e48b776a6b9d4835f9bdcee3a42a5cfe587cbc93cca04d03c5688eb8f235f6bf76a959604b77621641b64e7ce816fd1d10254577d8e02d71203167c12a1a82d86bd8782c88ea98482cdf23f37378b0e84372e53e72ba7359150de575c6aad134c616c4fbe990a05db58ffb111a124d35a5819475994d72760adccfdb4c75a8708569a07682611d4cd2a06e1724f828291da3736e0acf384bf5e9bed2ccff6f17b808c16646af87064dad3537eb3391d19d426854c0ebf7b9532159147663b3b368aada83b64d002c2cf6276c8fac4090d3407a46b4a7780524656c4ae56f4e2e0aa5b89d38a0a7dc77cbcc3b39bb27e822d7159b65ca208e39113d05e9bbf8f74071541855602130786b9ad743e9a7e08158f2cc599f704af6c0ef9b6dc39db863d21217726eec2532cb559b922c2ff5aeede9fffeda9dc2d249e64752bbd336a68eb3da84c1b11b19e3336b00232196111e2bf793483044d735a64ce88e8db7cb7f909213b0a0a4f95eff6f33b58d3d8ba1639e964dcc8807c5d653baae547c57839e99c8b26c8445a11bafb59024641a643a43ea95fa2828da24f8abe51b2466b8496560dfb3350a26e07f446c408ab1c3f32c3ead2be0a9c4a1621cc1e02ab514975aa1c3deaacbb607b7a49e41f8aa59467014bac5593afa887fe92d7dcdfefbc46f6b39bc6bf28b3bbb2c6993a3762a1f700836fcba060e7761846f03d6ff8bfd9796e6e7b61addc836ba64c50a4cab980f7c86247018ef35a48262571309d3e620aac5c3d8dbbd5d67f6b700525aa7e035b7c6022b31c947c5b523b3097c9595310b64796253fdd07e465333e080cb727ec5041f32252ed090a97a82718840d8edb2e4e537a6448b1f73a442024ec1962f1e2ac2a6517b2d33f816c1563b7f8f73d8ed6ab61dc3166649b0500121034b2ab762054a978ca48f9432c3578d5d544322f91bcd59947ff43972933089f0f48209bbb12fa1ba145f5f1e9ed0ef41713e19cbe98e241a38207571d3d7fed45d53a3b11458cf9f0b964b0aecaf258274f77991370d8db9a23b5ab0d8d0b15f15bb49d4a0092a54230e28e733a58681e41b680e8232cf21238a41e93e73655983c755646165a4ea7e6731895e668692b05fc8fd248501691742b38855cae223cf1f1fa1244e1821f2b6856375d9540e3a7407c9b3986498f13312a7da894e4162a3385861db23e3640a24949481b14fc2aa3a935be220ffda955ce5a946e4b3a2a65a377790348a79274bf68eca479f8a8813cd5d6105858982cd005f781c1d48cebb822e32bd0c28cd8c74175082bef74158157ee29eba41e8b0bac2540346e09936d08ce108393211a5d3440e4d69f9bec3dd7b78b66e200ce3d6d6f7d5fc78601acb7576b664a80618e2688e2ec7036321315d1bbfa50b4764167ca1f959e02ff32157087b6b3581c8a15bb4ce70c27f3fc2483ea5d359e9ed8dc03b38a0c740fd266baa7f0e3cd29af911fef956ee5293276db7fccd9a5620abb396ecb06c7a26ce9768f5ccf66fd4317dbd8121e90c7bc83061fdc00e3f370ab8841ebbdd753ed71501be4042c7c8ad519e8f09cf931aa4ad0f43bd7a4ebbf8ce9209a191628199be0b0335f4f5ffb44673edbe1cd06baeac50abff1a2f4e5134f361b5701d1600fd64784a198e3672f20b8968cd1500252567fe21c6ed61f6a594561de371cd4ba555c8578d6a191a9ffbaeb4b9510be7735cd9e7edb7880b0f7de27c5faf42d9c22626e174336ba48ce1fd85c9f6c5a82a44b3c107ae8750dfa5e4f0bec43cabcd4bbf262c51d5e9833eeaf954d8e18a8d0013927ac2eaf8296e0476ed51f69da42bc2d668ef2a0b1172e39cebdba52ca752f9c1a2562d7bd31649fa1c50d1b0664d62d2653323c01fffd25aad849ae1d6d952ba2534518f1b1b6561155cf9730e6d7df333c84fb5fff86b39c8283374b49b1611a8fc53009ebd1a96dd213c5aa04e83fabf21b9bd05626d77df8c037bb56bde87417a048b7f927a399c83d0f31422725439eba6286b62f94736d45da445889e07a3a9e97babbcc431cb6d8c4cc97dab762ef2d19dc304f5363c5bd56677dce7826f22a55ca92b42eb23eb86896e7ba274fa6b4639e6027a2c886f72f267a1e1de558e211a149b5d94dfae8d0b0ed7900677585fe6f7e0efafe340690017707fef710f8e37b4a25177c07f6957df90b26b9dc01ef05ceec3ffee9ef2b6a7ed687136da6e2e651dbe8766d987e9698ec9aa3901e200ce5f07fa7925e99ee1a2206fdfef5ade171f5265d202fb4766e8b382e31cbe374063c8ed18371d42536955a7015467dcc757b2cb8d04d4e4753bb9cf48776fa19009850001b2b4a19da6f47144d7f1c5534deb0e792273e7791fa9f2c5d3bd394606e71c947948d3b4d7c7186d8ca90ff57ae625554afd85a0a68441ca90295514b5f47f7d3e88b7bf301a4bdd7761fd87cbdeaca1a3faac28694f369a58711dc6eb0ee38343d2da75ef7497b97f3b5491a5b589b365922362785055f5daae6d56b0729b369a101125170313d5c26d60577a8ea88caf4b446596c22b5b931a9a9287628993a92d216a11ce8d9d7f4ab2cc4fda9d7636db2b169190c0fe7f4c69c265e0e097ecd3337ac9f8802a7e9e736314fca4c07a346ea34863be263197cef5a7332f247a8a72095bae78684bdd4090fc4307df21e85573111979c0e9ad12f5b03568ede26efdb44a96e2ce25349130b79418b159482496c8653d0efead87b719e4e688bc3b76ee4a5fcfd982511efa7e3b40f2cd79add3f41a6bf817eb5ec9cf278e2a3755db8e69dc1593ca8b2ad1545acd3395e0c70032e52613438933b28e92d4b18b363ad9afd77b07b702136970e48f2714d9279763eaf4d8d3a3ad9248d886fd5504637e82bdfddf63f4b31159e115aa22a5b7a108c6831b23783572913cc0bcfe12a55c7c69aceb5ee1f1827d48ec0552b2b414506da6bf8ba6f75f61bdc784395ccb16db933d2696ca78d07daf97a6d235974da5172c19ce65f7544f3f4fdb52ac1de02e10e37e649fd0b4ee62a5bfb7fd37ff38549043c735e974c333710d00c52c78c41e0b08436e75e9471d175e22a0d74a801873571ebd73c3e624b73ff0c0177f4caedcd4d6df49a75462d0ae6ed70bde16b4789a2ef1e647c1ba8f65a2f3abc81044572c09ade5d782414241f28f69fc892618489f84d6581c092ad7b6c1b6c280e81ca91d368f7f0f79cfceadd949ea639d90be7dd03e7d24edee6bf77f7e39267238e9fd9d611815fa2ae62fe400b65df40dce78c79f38c14ad0e4aacad3e96b286724a0534fca199c28b6b4ae31fa310bf95fabc58c2891eeaadbde63a3060656174a156dcc34c5a8ac39673d30e2faece0ca41e7f619aaf80d5bf09ca01a7408c2b4dfd0ed3f609a3decc8d8da94c9c8ed5cc2e6071934ad3e360e6563c21af5ffa4b7be7394f1bcc318ec7b19751e9e591d5e2f70ea025e3b540f75e675e4919b6992df699814590fff17b7e71aa462484089496bba37872a83e6a4c1f1b56e4618ea551064f9055569a075ee97f8bf6c07e0e88f5fe038802b78cfd747db87f873e185640cadb29e266ee473fe15a018d6b9b9da5116934c9d3cd5e2f51e98554f1e40926a3f7a63a67e009fc48eeb68a0d8ae5aeddce8d94d4cab1e209d5ecac6d262cd3d9298316ed9b55f1257eedc52c3fd1eb54a72e0975c0acfa03ccdc9b5510d94325569f83f54037022e776a62a2a26722e180a13613bd62532eee3fe92addf82c34b181961abeca3924adcf079070005c35c8a7dd281af5fbc7515b0ff6bd9aba94429f7e96cbd31735a2030ffb004a34e985ab50d0ff2f0d67fbc886d70062508e8e3184a927fde5a942135ca1d662fa92de1144c95f96213da1ec55bcfd110864848aad4935478bf323085e0d3928f0bd7ec035534d5eae2a28905ecd813a1ac6ab9737a5d6f05ae004ef78764dc6e2729a62ebf93aa9ae51ec98a4a3b2ab69ce50c9c7f119fc38e7cf9c7c11f83df57f97dfceafc7b5ea0764dfd3a330a2df54ad7446273da10f0bf4da455448c8351d9c232c430e3474606e3611f1538afbc3b4160595f87fbfb5e4a0de77b70749ae6fc119a668590994b5d758fef94adcc1dc2017448a1e1c6a77a696f5c1430460cd3fabcc1ac0f03375edc02e2f84aafb974dc2bf472300c478c68cc5d05d13dffe8724e439f1b08464d6b3c57dc5205947fda98cb90d5b37a6a85fbacf0c66275771e2416cb5e5eb48be039e285bcd7101f436f84c7c6ab10749541c4e5346b546555a37f30706e7827f05ad790794be24bf76c5faf3ee3924c0f15b8abdc49ae1c1e78a6e51c922b56a94341ea48dfc85852c6527631acb38cf8aba1c2aaa8eafe83cd84f1e69ed5d9a82e3d27abbb733674fa78bed3be3f2294f36cb1b53f8ab2e4517472110632720db32c6027c015c9b463d2d1da35f9a465eebc446a902951e9a5d18e6e8e55f0d112d83e11a6dc22f1db6d270bf4e0921c720ce26560d8b57d30191af906602918add5b2d94e86b22f2bf6b895f32c32db4f0a9defc74a78bf22d61bf4f3a060ae3fc9676857038a144848829db977b04df077bcbeac4bc387127b463f89e0a4782be2b7719510dff765afa720046954bb433a378b79474b62f04b07ab59885406882375c5ede69bbd883d4b2f17f058668fc30321ed575a71a98085b1d1e5cbafd3a9b4cdc6a4ae70968b6cc340ab339663385ab7b8738c79e193d225d1b960639723fa2325c0628b56f3c2ead5fec3eee238b26479bc3e2ebb69e9a32a049ab4c5796eb887ce4cf6651d0123c30b2d48363fdb76edfefadc24e6b5f957d5afcd1ec94fb32a0cc38f996993229d453323f0cf1a6cf27fc59a795772ee1d474ae6835a0a55cc55817adea2007327c0cd48fdf911385a7c021f029f8528bb90cc47ab28cee40b492635186466b00fc98831243aaee2bb1ec5f45b25c72763252302385a8815f8bf018357d3152dba7478a23c896e01caea4ae1ae7eb6925d795029370f98453b542e4674e2b7fb03449932033ce023dfc7f068a905655dde8c957ed427852bd9141bafd6a08d49eeceb6c68473f033d7ff4599d3707d58f0b1754da1ea2c3cd4eadd3fb68553f55a40f9ccd5ff528a1738d49b7936f2c6e954fe6e331981309e593f288bb93e4f7643f7a89b83ee9637b3212dd0b6f760aa62dbb1684159e3a06a8b554c4b89b0f6bf43f61639dcd299e030bdb6c8b2a61ec8735c92694ecea3e9417682bb9e9ee58d3f247660ba3eb89d932362ed11ca1b9d1e93adf1cf209b75a44b145ef74d7fb42481e670fc8480028c280c25970e16809a45e1790dcc26d24952d9be84bcc438b574d13c01bb4174123a746af5e91298c801ac59a9098090baaf9c7870554bf88ef7e1dd73c4a1129521c98ddf7bbfab8ee915e3d1884c58eef7f573ccad5851a090416b5b79bee79ee4ef567fcf780df97ea47d002ffb41ca8ec87186dba45974eaec64b08a629fc7fbc9ebfe07ae69365d4dab82ce17a91f403e9d8df6cc481dab409f84053899173f1d091473f28f63a6c7613d0ea457bdf568287f16f75b64edfec9633fb774f2f7fa97dff30047d1ab344cdfa5d3e75b342ca4c70f624cc3354947d447141bcbc25310961c4b62ed56355c804c4d51526b82ec029ed667d045b12a87e8f0c7013eed79c9d063c72ba8dd1840fc8d10d520fb410fd09847f2e1c7336baea7985e247ba8e59d8f8825f767f679cf061e7f19242b33b19968a567764f8f25a0dbd3afc3c7d39d265659b39eac3a9c8117773e819ef23825af644547befd728cb9ed3febd66ecda673253fea0b0283ade3c05f2ad6c7a650070253de3bb393541e94a4215118f50d8efebe2075b30f97aca98f4d7b83ccdfc51d34a432374de044c68564ae4bcb6bd248f10593a8dd303ef7cd3a470e1ea8d92b910aed81b782e85a76374bab32626236ff0129b7fd73f5a80a5a827749aff35a47f89a0274200004fee5626403d921d2c32c35bb46be8fc3671bd0f6fe2cba27382453a8be4c5cbb5ae4f30d963a8c322126a97452551cc918bc140382268c280c521f68bfa70e15cd99b50147454d67d655ea232c1bca9c0866fd6e219be798664aba2b2276d29888668cd5d88d2f3f3ca0b796cb7d70d02b9dba668565812ed0185ad4d5150b78235be165097738ceb13f164ba298b129f5d11d248275e4c0fd1ce89dbcfdf7cbc67f3b7a1c8606cca4d14e29fff8161c833e741424c270c454c0bec19446b8ae87bf516877be07aaf9aa02fe55b001f5861542255efdff4870fd6fbe576fc917174d37ea88113383ff05f9ce66de55d9b6ec35945578b4825e1cf3446544cc7e2627d8f91d248fffc80715785ea269f1878b19f4848789bfa8c45c6bd85bbd945f39c9f93eaff728a00a2e5805e18864204f6b023178d198b6a880a584a1d80bc8b03221d96fcba71a075de2ff0b57ba4a07f44610a863c76058950c6d9c3f8c7a25f0ff099b15c3fb622f2abe42c077084ea1425294e90a99c8b322baa907951fa32760133148ec95bcedb4d94d354780bd81091f8faf35fc35434297fdf4a9dc3ddca1753f3ba31eb223ee5da3c960fee86132125f683f44ab9c38606a4bae0da020a17be971cdd54964aec956cb4c0acc57da2c98b1cb1b6a67528e469462d2bb3f6a032797417204b567f0d4d486ac9080cca8dc72fe62be68af59f2bb6e53250ccc195a0f3f101bd6d6d195975cfccccbc75a32b470d20aef62d59ca6cff464803b756a138bd47a5e5f4d0657acbb3756346236cd9890a922bfe4d50b28adbbe3f45e169e10e7c1067082e9e6084562ec3eb8d0adc01ff10ccdfb7f4ecfee1aafb9ab9884066efc5842bc9b27964eae219c0f70eb0aecf73dc292708cdf6485e03e73882e316b0db769ec6cbf73e59e1b7cdce1f49752a17fa97cc9ada8779c81a77997b0a0754f25e2af3f7e8388203b26f04c01de9644ab3f27a4ad921037cc093d42381998028c3baa42b41773a5c3694d24be2cb973a4a2ecf70cbc289b7b0b8ac7b4495e0643cba72374232b9821808e5c02352eece81faa2d406d1852463df5064a6ac7214941d8c902e93aa51119115a4dc500e235fbbfbcc7ef4ff899ba384d334fd38522aaa2a99831621bb8de43bc92f01715c54ade27963b543298fbc86e03c5fda214d03c219bdf5077f2208ff57d885e464d5dde9c68e00452258ded61d8f5f5934cea592401a3f6e4837e733750767d62f43d075127415c6cb95a5c6e9d102179eb40bf2c0a7264d92dfa70a8b3e96e943e272dcfeac8e91af339f3d33f3dc41f823640480e0cf446d57995b938d8b63e25d8530542a26cd41e68651b4cb3d0cc88e3a309b71c11faeb140f7f2ce1a618c812e9aa045b444db6bd004b97ec20f688403184bca226a33d653de983312a455c58f1a75dd3a27013c0879af905ea3a0ac10cf872ece2716b68b99e80ac6393ba2b5c6bf48736b9e1fddd4e457177e85023162daa13703d270f3b9abe1e96cf9640ddc0dff9636d7f0f8f7f498e681f0b0940f3af45ef54bb8846c22072afbdda0d6a60b1e055bc260501476b85bbaaa96f36b8d1cfa1a2e8345e83598fc3595020c17a1ce65c0fc35bf65d66a818a1cff9927fe99fed4ee0839c85d61b5bd7305ae01dbc57cf768fed8667ee836f30c30a27b1eb1c51c6cec71dd96d7e3db42bedbcbe9040c44a8da4d27326ea854a7fd0227e4a5188d0ff5cb5b6756c66864e0356936c260da85cc158a03b7bd54cc2ba5f7450924433b4f13fe787e28ba8f4e3c3c44646fa37da2cb2c3e615b38092601318310a2c74ff23cf4b9b9b3f3064536ddc6c424c72d1406f2b8d332d455cae7688697f338c59e80b81d39b29c8b9f71043dd7ec5b3202135da17b1a3f41c8b4ebd85442137acc27e45b377176e076b27a783775f70d74aed540b688469620a54a954c68686e063fe2521580dc2567b7978d73d31675b7a4745266271220d2307aac6d2ac532c7bf86aaf35e084f4b9bed825879120841e4764f231f4b00e390480bb6cb679e7dd9cda009e6f274b55a0563c0951e2a0cc55b90799855ee5ef0dae0653dadde019431eb1c9b0ef01d7acfda6d470a1845e70acdde5788891b3ea28c2097bdfda91037fa9486cbbc380d52cd1e6529b35cf3a88960116c63f4ee9176a5614e5c5db202cd040164515dc94665e180ab2d2070d3f99f94c599b84206fd776d385148927c3ca78e5cb8d7f8815777c02a24eea3ebb10781b0079346298c0aefc525208ab22c8bc8bf503ee3aeb36a489c1b652ed06e7a9801f6f9e0b4eeb975577087246cb8398f1963fa3f5fa6080b1704c2af7230648980db96ebc6ef40337623e257abb57c63478b82d5dd34071d0aaf38e7444ff20ea61bace73a9f4173277faa4f8fd6bb344fdb8c61a383c2ab54b6cb8f076688ffb8eb1f8dceb8148e862d78df5a4b680508968225054955f19688d525d1e7071ee24df6629c7bd7207ee11187c8e6672a08b7d3e7a33ff7d21e5b6daafdf1ce2e3b4c959c961637e7182767d3b407866b58dcc318e42b18b617a9d594fe517c849570f448334f0156c15562aca117a83dc813cd47ff93a8c1f72876bb28bdb1b0613a26739cc87593d164f8f01a8dedf7280bc56c88e8da98295653d343cd1fa579ed0f113943d3863e7e465c70a9af63a42c23e0f916032cfa8de85eb83c807b37b86db948ebb2f7a2aa2bd0c24602e5e4788260916b8e5ac78ddaa61d965d27b3a759ad3af3a5f0e213723d14a0ede530acde5302c980fbc6950a48a2de01a16fe5df5c90617b8fdc2e5d84c12b2a1c8f6eb73efab736436a5cfd2d59e0220ef663da5f9867fc1c0b4c0b634a620c23707e2da20c8877582cbce749ddca45e30b18ead3cf4080f108f2c8ca22a2e6ca2e8514f5ca4333eb012f79f395bb4825579cd937b939fdc9e132815b17308ab52eeb47b0038b432572dd96eb8a1f0688ff5bc8e2f3906abe61ccd57119a9c152a09b7be5828f7ec639807388dfba1f32acbaa3c327dcac15995ace73e1fab4d7aa13236520f21499001085d2e386c3ec9955caab0891c74632ead8b66fe0eb9d258e7c8232163ca54776d1272a7aba50d0ca1be31034e7d6e740746f12d1f812d48ad0da392c8ce416a01882175e8e3205963d19b2f7bcbcfca951e39ce5a38606e791c4ee559039abf555d27613c15abe7c97e87fc2e42577f1b48e8b52ea54b6cd2c5b9faf9b04f674b2476366ac9f3afbc38d3269842ae7bc780f7aeaf29b83c54585f9eb084432c0a5bd801b133e4d87b39db1b16634267cf758e653ac46df163fcdd101489203a6fe24cd76d13756673d178e43d462a19e674960141aa198c4d815cafad51a479b24e09f0dc48740bdd8ea2f9bdb6c2800509511bda8f42297e579c8256fb1b61f78e30153e39231b0166c58dee10606e04f387fec468e9a0efbf96ef829cfed56f8c00d1c7933875d3cdab0adbdd6fb48ee2b1cdeef12af20c6fa43cb0675795ab7287edcb0128d48a8d7b378f85dda31d65706e4f5c0dd8cd18a1989ac072e15e39bf63529e2fd672bfc3a658cb009e51a5d9e9649a160a0db425a712f4736e1d62ebb8c49895b07e024ddb54443f7e7be63046cce7a7dcc12d60082ad132052c2373b8fc25b3698bc46834407160d3319d3238bfb4be0fa894da5e6e728ee79dc3e5dc34b6a4c56aa9ef26c40aed1bd5fc4e539246796daa5e946e94198318d19f13b3ab6ee0f3f94790ac4774408419b4c659109de2408f5d0cd8bfa79a7e300eb86bb2eb256082672c5041e3f25cc051cfe87a93e1e1302a9985b03d19d9d9544da0e5a3222145557c09dbc666bc95bc432cb778b6110443e20eb69fbd96c55c1c09474c2468a687c902382383b5479fe12763931a22119068d11ae300f602556dec08a89e4e3be4b1699f209e6713c70d0ad273c37374cb71a9552daed17d38e057a0291554ac622c8f22fe643f7560131b9df94ce54c5454e3fcabaa80479c35fde14cb33d97157d22d3eb712fcc8f1b9a3d40f1d2a96d62e775858feb56e4425eed502cda48beb464ee1411735ab1643d65a099ff3c4ace2475aee563560934e27cd5a0fbaab352c99844beda27047748dc832e63d09f4dcc2821334b667b1821515aa9e2247e07d6f1444d9e64a5c4252c6a541dc529b5ae80a45b0dd296aa07538ce32f618d215367375f4ce42ad43a20636a9b2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
