<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f36e175d1d70c3bc7847ac54085e6de6522e187d14740f157a0dd9cc10f370d0941cb2686f56f9e98b59640f59264a62f97c930029daad36d1e028e0fb48cfd958fb00fa0aa90fcc301ecfdbf54ee3523846f1ac227ef9561df4ec19ad45e0eb202444f8a1b9e712d8109847cd464cdf346723028f4ee878e67020538b29ce03af4794ecf02599367104e4fc3445d1ee8a3ef1bf03fe1f90e1e2954449b78473b1af3ed27d517512068ed4cc9c3d667495b04a1a260e06a140a0ba1ba269793dda9f7e8c010f93e9befb8b8e574140c60d720ea29b0a2b9fbebcb802378ee22ac8ddeb7a02c4beef53d8a585f3b88b6dee9946aae5e46e1f121848d05294a310572cc151340afab9d72f9228fc4aa26bc43475fb97386a01829a7c45eb2c37f5adc9df4ecaf573d30c85f7082a55dc7ee395311afb84fbbd47968151a022e07e3c7e30f441b7847b2be45e591d16962b76a3eb8a79376d56baf10dd5167fbc3f8a62c1171b4b477b0e701dd3713b8a50c70d852be51d3b01b2e191aa405bf50e06c8a5106d7e77948bc1f01422a7a7f3f4eeff1c67c3b7d89669dd546f144c8f1d37874b50605989b8d751ad168f10a887fa94fd09100d427a254bc8cd6d4d86c1f9f43a409fe6afbb375eec27e7c9be2db975be31ba034cb1e48abbb7c26effd6c668706e32bbc2d0c5171ecff7d90b1d60bd2a97bd2dca56f55e089283e4ff0531399664293e83b6e30046c44d26b58a35ea364901e4b0365f36597d6764f7cf2655e512f497f70d477b390a47a69601a652690e31175f59ee7c39ea09fa0bb95e1549a76740e2c743a953f2998730ef904d1e2a5855ab0bb3daf5adf068e882345f6637a711a7a859b0ba30d6612cb1099db33fecf304033501d42f765f656fa05717d23d935572196c626f5c746a3323068e80f9ee5801d2a0fae333f072710cd1d8c8b06ae040b283e62449b1d35a43724728a7a8905f853207f6fa65ba97884b8bda596fa009f23db4c4c37d677a6ab025234d34a30ba337bf28a39b6343cd75ffc765d32435a98fce631ce1d710ec4fe6f4846dd4108df7729d59a122182cfb1c1bc5f903136c9489472a2e8e17d801f88bd6989cd19fc3a7f7047eb81c6e763314e83ac53c913957690f3fa6b7d752321fe2dfdd998fe8717ff165f0c760119038a6cf51e1e74bf7cb8d07e9bbc01e59d9f92ba08e21c6953c09bd07a2d6bbfbc46bad7edc30c0603df52db4dd6c3de95cc469b3933a19089bb9c327086b0d9c0a67f91c6e065e83086cc60dd78bb92b7dbca061902689d8990340f7f3b54a6b1115533a41e4fdd60e0191290518751185183fcf146a4548af5ffd3bae056dbb4aa83d2f3b95609bb3277263fa1eb34239779bc0a150dc9dbc27008054e0ce06690aa32793f033e3c61697465eea49a669709d4fda1d8522b56045ea49084841100d7c37745aedbf85c5cf5f47c7e794977b7c53b9ba807720d397df4ae113efbb0eb466bb2354fc272bba4b88dae40be12f6e380472ed789ef8f67bc01a26d65511c2551cb0b80772396c0cd60b71194167709f9c0607339b88759e3e6ccdebce259af017a5dfc29037bb15d06409ff62e2c47e5d06120826d17f62dc1a93d263333ad59ea44de85982fe25827897d57438313462b1383c5d639dc1c59e99ad816a6492fdea881d18d4f356d20e93509768cf00fbaf8c2aaa2f8be02a9c288d552ea7a695a7903c314e6abecb6035e0d24dc896c1c5017838dfc7a54573d29a4dcda9221856872a1c44ce77bdd2f1734e605ec247fefb06dd89a48a59bcab161502fd5a38bfa5d6d8b81756d3a8f620eba14ef69687ab505a2216833defab2f9679bacacb729a71616f788fb403154a81a62cb72bd1c59f59c9f9eab9a2f822f8a3d7c560417ff0588be4fa5b650dfa82ec2080a8b14178cfdca9e7c5e0a787b4541497889453777f51925223d2c72a289a0b9336e233e77f4adcd4e1c26d0657a94b0d66b73a5f1ef8d3d51b213032eb99bdfa8a923ea5b47549239ac9c0f20b5a9b3802aacd2b7cf7fe362f165e3e78ae3cddee3c270723c43699d3e576f311894dc94d162cfb6b972def625374b96d25b211daf2cba375ac4fc4e523bfbeabb0a18ee71a0be6d96f639fc5398d7cf18efad2473351fa1a82f5e23e26213a36bcfb609a37a3878b54a0848719c12c4dc340adc30ee7e4ec7fbc8e5f3b4ed07b8201c1bb95b14970c0f0a6b61d17e7250182bf68794926f97db1e583f919da3c131c56c9e31fa944797cf75ef4916fd4e1142d92363da49cc940610bf40be0f0bd3a0c8aebb6203841a9e2c57fd65e963963d5433b15fa01abc9ec0d789da5804d7ac86ee2f3fa1416f0de1376a7681a3cd0248e755687ab841fe7ca534f91613f166bd8f52d67b8971c4ed9aa7da510f91b94df37cd91577c822db0c05bf53009cbfd0188e5111b3395696c879df2d35350191f7a4c08c70087729749a368ebb5f034b30ee9ce8ce0d7eb05e9bdd4a9c7b14bbbb23216de359bc3391e4949383481e74eb65ec8117b1b5a672242bc1f681a5dc673b9d61d2699475ce95402a258bece00baf4f2a3edc28aa8e2109207a475d5f6b669126eb94d5526719b8f5394d31f9aa5d3bbb21f97a347dcd955d37bee0482f35c5a40bc29b516c02831e0c4af2edc30a749447592af44e27563c8ea9b916e6d2ff1bf62498551d023f04edce7135d60c8ede2e12987a70114461ba59141a38dcb1b3b11341521d81091a3e356f51efa755f9dcae1be57c380299aef6bed1ae122efa4ea9c5c04ef7d4b22ac96e938817cf4958aacece5e23031ae3d638c5855cf50d205748fb00f788b1a2dadee5b186e9bb295914cd5bfda6ab997e67ab677361f1fb98c98df139fe82057275dbe1cb04e6385433a9a894d544ec77bbad31591f4deb4f4f325ab04f6438e5522522010d7b6516ef2562df4184c91d6f92547509d77ac0cc851718650c67b98692f08024d4bad2899bc683e2ea758402fa1ec089bdabe60db15f9471888a76d8a770734eaddfbd31eaea3d5f9674d235645ff4248b3aa046df6b5f3140ebb74b41fbb2cdb9f40b95337c018aaf78a46a9095b109e25369c187ad34e3146a668edd31511ccad580de3807fc4f8cf2b7c0ba6f858d4117547aecabff0537ee7cb3a5f62c636eb52c209990548d3ed0dae05e7efa369f83bb0ec4cb21a407acfcbe29305c6261d3fbaf607db848752c9b23c3ea8262bcb02cb2c0eeadc5d73880eb7ea5db181bb64874b8934aa3d2460e49452bc06292332fa96c7642c7bd161b9492484de27dbf763dfd9e2f55a1fd611eafa87545ac83c9a23bc28690c3d5eeda8a3f11c594c29c36dfa351fabf2e05d5d5454369427e81fd6811d12bcdc0442da72fa6ef09cef78b1cbe073cd0ee0f0fa3ee3c564926ec95dadbcac18aad250541acc1cd917142473f356d8ab405bf14ae2be0be74f49b3fa80ce3f999c5100f5194b835000cfed128cb14cdb2ee0775b31902f64e16d251b185513fc9be6db874dee2c0998ca7a9703690ce02a217a340e6c802ff8ed3817553b102453b596cd72d241f6646c234ea75a8fc3d19f4b53bafe1a59858c2dfb345b0bd34b84368f0eabbb71200e7b3c924c5ab45e8034e3a11278a150648cb8beb16be2e3ac40d73880eb1e5ff8f0633c602b39476b65cc8b3706b957d073fcba442c149992547fcf340cafbc2b4743cf861622bf1705062611827d08059155e633bf89e9ec63c4985208bab0ef1a232ce0a2119313874b80ed6242de3df569e31399a02b87a3ff35b0df7b80ae85b4ae9165f58f1071a09015ed0d6eb6eab67495cdfe1cefa5627e575aa76c5ee9d5efb7a7139f508af0323a147dcfdab90f71b2764d101167f72c69bc155ddd63992b432736701925db52c674a8fc2401e71fd625982c4be88bed75f337d5fb8c6a76762d2a03064123f01714c2b3fb9ffb1d0a6fbee4308fdc35dd99df7b1d9087547383abd0f986107db9221b915ae36a70264813f021010ff75edd7ffd38f6b5ef9901550d7a1d002653a4c506e5c88ae015be7c5ff3c4b36823be2a4fdc95c431ec2d3e6449a6cc3a66a0bb7cd90916370ad18b7fe2af1c4c9004a012916bb58b02fd4efa44e6580073c673822ebde6282deeb5c7c0c9fc11f68db96a7ad903fe84cd95621d179a21ea581acca77490d1a4c31f0ed725d2a81e65f48f7ef26d7db76dc24e3502fc8ff4630b44ce2371951c02bfedc802730677574688cb040d423fa8d17f6d53a1b6e035772871f3f87be275db61e9d3ec796333f7e2125faed084a238a2377ae33c4c0ad053c402c7f3dc5bebc92b42ae24c3e5fbfdb5fdc4f03da04ad874c5065b854d889c8283cf08c7c22cf8a36f916c512618c263282def4a30291955a1de047873ab09633c21ad5c70a6f1d4727941dde325602d1c8920ea2db5018c2777e47754a8b8794f334cb7ef18805a3d56d006971315b6ed3b8910150ad8460a93dd7f8c60fa19ec657d462c8556ef1f58734c3cee48f46946ddfd47d88178ec2d79862fb7490f8d15d4ffe017a7e387fff51fea2ad2007dc3c4e619c91e5b022b1f67b36e46061a15243c02c951382342828343ddf06c735c5d73f4ad0747b49a2f63366522f3ca5cf33f3e795ef817ab16196ebe8bb28e05227a5742cdd0ce1ea4c9a094d1894bb224a48cff73581854f1d34eefeb94e9c2ff30d7c29b0b775d18293d50c63bea788c162e73f8582ad50987830840f12bdda94595754f9b1385dfa51599e465cbaf1255ae2fc49bbc6fa57f6fefb9b1bb1cabb0d77ebd6d702b4f27fe0e1d9c0ec24f6190b9ddccaf34d112ae6a7cb213e18678b7f93b39a04ecbc124f8fa99b291f4dc656d21ba65d493d23e6199be902d3968a975c98c2d86daf58b9181fd4ee3254ab1e3bb0379ecbeb1bfd7f7499a8528e75cd4eddaf55ec081d2a52a3dae6785eb746abd667e77ceb680e32ef1a424d12fbd0da8a9287098236c3bc40b7c79bc3b1ec6dd878d9c69461c1c4bfb34b92b92887c2e6aaa97637392050d8fcbf621254164f6d604238d04882ebb20f7aca00300f66bca0c0d715b87ef38258c5ac8213567a386d092701cbf3f8aac15e89636fee4e7ad493d439be4d4677c6727110b6967e61eb3804203f4b65417fdb2987e1912dad72749912afab8f958749435bf8bff2237e79812f573963082df3e1eac7c33854d94a9af7bfc1cf0a4a110b8fc383ebb6f1951402ae9938ec20e11069d23a7a58f68688fd1ad33a29ea97eb47888b6c33c53240721b846e16492a5bd29f01c7e9fb6cf5242d1dcc5c4a5868b6fac8cd7a20ebdfaddee912ae79d490775fa90573ff8cca9b7c5e5a4a4b24bf09b3add00cf09dbeac563c3b84a5e286b5499e66bd0285829c90e28f3137bd73497222915f35db01a1431405521b09e32f1e7788a9844a5538bea7b5fde79e6e848116dd11c731eb709c1ec0975f487f93a0a203f0cd4872449a0aa7b89775f5c76d11b82ecb8b2010f9c4e9ddd943a77cf10b578cef91684c0f4a5d0565aa7b2eb379bfe731c7f895934ec374f6f4276ab43a0519912a3362d41640310238e8498c899c13d65874e8e9ba2d39fc3f109d2222c5992d3cfa26fa12c86a1b8f646741f4fe8eab431d1bafb661d79b86b81748c40f3d10372ac006386110bb9f182a6c5cbb984c8c93697edebc23c0ab7eff74da904b31663635a0a36f00464953d86ac62f23235e7920739476cc832b3bdfd0f6c8ad9437ae7f512f46996a18f872fcd61ff75fdf6af6e8703a9fe327ee56a646f557205445f0b88e1891b21c7b6890ad4f9c4182872dc374d46b58c47ee0437670df1691edff7a22723af7d77462edb50451a31252fbf833b64d83bc18f2c694f21c0e7026202441fa19bb488eab6f2a19f1874f94d28d29d62faffa672b582098400fab26ee4606396f78aa9cd5bd0866c0e1f24cb3aeec5bc17a4a8ac82739fa1035aa2323246656841fb614143620ca33929d8e79700fb44f36ae326e65563cdb8af0166a1daba02d04ef6d8c6bb6979ae1492437e5efd1876ce94b17d0369499d62ab6368faa1713a0ffc210aef4e6637c08f00c83e00ebd49872edc6de411d2f5c9b04bc46ef30a9f8eb6fc195623893afd59a20779d522cce2850ba29d41d60f974ad415624626d03f74100296ea2859f9c5e3b6fce5021d665722d045b45cd9b30b0929d2636dc55617c4cf3eea1c2c4e79e42f2c06e28cad0beee54d1107a9e796e6626ee7553a00e39b554123225da8fc1d9f94b26099332ccfe2eb58e67997473a0ca19487703e2dcbef782044ff3e35c1fecf36e46d7735d108cd44ea72274ee2c0734792bb1e37e7b836aeb95ccf42b75b77a3b7e0afb4fa81103c1bea352a9da0a013d7c58751907967ef89fcea5a6ab06196f14af6bf46db4f5f1e319c76fac701b66cc924e52e8271028560465e502b8f826182b2734b411197327190e79824c22c8a412d36f564a5dfce1a62a5f1271c62da21085659c50527610e4600801cebe747be480d13af09e9be44a3dcec6fe5c26be4834e5154a0c8f8e43782414a7d1113efab4c8c1e791a29a548387dcc59ae9dc22b889b432c8f1be3d6f1b9543e9eef0e020fd81e38d0cc43add29afc6cffb318ea8de7ef27968bb020410649ae1763e8c4cd5a7693534e73d520321c9ce5aa23dbccd408c32c4740958a7902cc2a50f6ccd26718fc3cb2c734c439f341598370e6770f04ea23b5e3a1f524086c81d34c92f92618f0da299db619a4ff339cdcd84574bd31e4dcced213a5e6905d7c17de39bb6b92f6ec330fce2f66070a6dda2f43f877543ecb9b1305cfd72f250942aea5ec1e5348d3d1f5a97646d67bddd83a81a1d68763de381454e2aaebc8def0b105a2765351b8ffc46f48ecddd4d5997403f8655ce27d7952c5e9f5f327b560ac7d6c34c82ec05c8829d11d82c9b857a129cd93391c3abe5a1aaa161c623a21e1d855ba3218ce2de10459160f05c5a7264336a8563c11f9111f171dd1cdd4edf405f9a1177207b5c19d8eb6ea954331ad67401e73fd6a249e0943256777e752c40367ae0009b2e3296079907b69f0adc36d6fb904e46a40d20d84d990a7bec5092e45e2ebacdb8d0131975cdef39c006508d563d93175d07edd0447b75f24c0f42ebfef05806a8a521c0060d530dd943189f8d4278cf0d3a2124ead4049e5c0bd2c16b63cf6af2f40921c65dedab8526066df1fc078023ddc90ae2d84818dbd29490154c94e6aa74f1d62552758e0dbbdc15c6e02cdabd5838a6601868de836863e5fcaefb272b574dbf4e96ae223c5f75e735be202314fc30dc78e1b3be1444b9bb3c8eafe5ad5ad3a063c87f374c0fd521b84f5ebbcd4b784e5006a28e7aeee2a64a613067e844c821490244771973e422cfdcd5f2a9d13cab2cc0dad9fcf313eb37c8ef14e98219016a304ead1f81187da4e057940746514c50b53ce7b4657116215dd40435b4e7e4d1d69bce5f8372bb6df5260c655a6ac5ec3ce4eb7e00d175c42c20c6fa14b2961cec41d3de7a4fec63584c73907204c48aa4d9adec4bf0cd62a03974c3680935c1c785bc5f2de3da92609b6355e594d41a1f162c02a7e93c6078c6cbf1eaaa4f708462fa504be86fca2edd50580f3642a341636ca4e9c8b5990051613fb14efe1570ffc92dbf9a89c167344b17f998314a620fd7de6c7d10ee7b5ab0682bceb0066184cb6b4bfbf8b4656719d6c3b8fbc264b438b7a7ad1dd62a1ba8cb1f62df5c15feffb0571b39e34fa1845cdc82790dbe5fe79f15658c49bff88e4e903b465936dfb9da60698d7e232e0099495cfaf728bc0dfac90433b44bd0dc43791c2521a5ad73e4f92fe4a8a679efac3fc74ff103a17d621e11e1d66a05c90adfa013fd5d90f8c1c1e90bc225881a5c3bdca0b7a3d7221c1d4f125dc6271d5d8d0c89e5624714082738cba6d4b6d61a9485b45295d7d4ffeaa04d8b6553dd98a9bb83d1e45e6f4c4f056baa44b37dfd73806b736c0109b5c748c50d8d51bc825bd677de33914e800386aeb76632dde4562c5692d2d625f7efcfb2395b9cf9b54c10b94d3620fad27b407aec3aa2c08561ca93a448992781251b3a318a6cc590b78ba42b0f4f4a25930ecb5bf5234c8ef1b04f057a155e7e6fa2c56555bfc2e38dcd8f0fcb38f6b2af3ae077fc222452c1c0be489f02b3f71ad20f84bf146367cf1ec62023141903e0a4efeaca58bde330ae1fc361f29c9bc32cb39139ec857c4b1aced620b0e1df69c5abbc9746c9b9b8efbdabcf4bb549acc8f0c7c25280721b1f8b277e5f97a844b120c866650228dc2616f37b4f664856602a1335b8ca14a274823b4d2e1f8e4c307567b4146b62735fbbe1644cdad3dd95a50d13df43223eadcd35395c5b408413bd1b04546477cb5474924e4532ebe12b430599d982c665e113b2cb6b307e5778b6d37ae0350a7e43e1d8566f37a71b3cbf03ac9ea553457d1bd71d33aeeb87aadf6f2d2fd392af70be70dcbfcfd37b9148b25920dc5716506fd343e346f8a527f290f511dc1b293eca34ea27dc06fa91cb61836b90939eec7d07da1713fa214551e45cc1d037c7afefbb58df75cecfa1d1d7781071b2da91618934d640e3b171e829debb9377eafc601b3b564a88d2968f079dcc7b3807c1fdc7d19933310d43c85109812f5739fff85203c04dd31be34e3e3ef84f98066582eb1a655489e2fb21ea57176ff8f4d48fa179d4b7dc4735863bfd274542ec319abcc69110499df483abb996443c6ce20911e571f4d1c651af31bf2b7d92a025dbc8081f74b0cb0093beb3cc94d0acb38d0abe95fd18cb90af0f72b8f8e68be0c1e0d9f057a4f61762cddc1ccee6b8a3574b8151b1319092b66ca712e0b34c07b1c7ffce33d9acb9600baab0360d3c9108a141beda6b81d5b6aa9961379e2f205a32d82f1655fb551294e69ec38fd854ddef1180aaaccbd2f599a1a2143b7ae00af6a3c72838ca03c54ee2149ea10bf24371530590a2b6d2583abe419c32ee513b400c4d4038b252bfc74c2b6213184f4ba23f24eb4577a4ce8a3124b362540d051c757eb0e53239bd07e7d87d845604c11f038b762069da90a3f9080f7d9c06373d557e38a1159b899c991f2fc0978ea1a076c266db9b1fc909b873851814a0cd86e9ad2db22bd21d170cdecacacc8d887a07de71b8248ff4affc4078c6c77d71eee6711d751f4a4d2ffe6721b51f13a1532321ecc6e7a1844577d297b38e0ddff1ead8d4a449eec9f365987f7250829f0a141615215747b34c5f4ca5fb30e2980485ab81ad8ba3f30bcc41c3a0f764c0e8656af8d913afe7f60b243e59e547c4724d84abd532efc6bfcc64e27218b7f0bfffbad5bf6b1ade37b0cd57e9d9707884da5bc9f6ee75e7a708da3244417d102f32196ea29cf7274fc551f4c42b37e5409820baab5c77bcfcef4f601eb04a743a217e5e802215079da536086b53adf34aec3c6ad27f882e6780484784da2cd58aa9ed4f338d04ee40092d343b5cdd868348f4ba7d2312e3031402eaa0aa02082b3df3f653cd5ad6e33c11d555bf3ca950bb40e1432154ae40913ad5bb779a0032d3f7b6bb5424e859ff0a20a126ced0fb5b05f31c822892dbf569f6640a950e5d5b57e5aa6eb478ece3f672bcd13f38586de597b50e4f0edb472c1e90a2922e75c53a57f0685df39a3144e9a06d2a6df7e9250c5c7681cf2865c910a12af0e8729ad4fcab13ff3211875cb1716e1cad3bb4b0a6c029cd82a6580f2303b619f00c97364d6c6c9a43a1763063d3f2fa31e507ed1373d492d30f6a4cf2e20d2cd5888943800f807f95c9f0b8b435d25634fa9207a7aec9a081bce00b9cc8a12ea0187e905494e1644d0a644b5ce364634ece54ede82b3656c25c53554dceb922e357a323303c9e9a1958e8c69091ea0c008d10fd8e6190cd15d978190d4111cf46d46e3bb57f0a3f7079da999388eb2026704132d061e30c21169615b54cc43654fd70aafd0b9e5193cac7cd335e4d0bdffa6b49fbde0d1303c4c0b559979251e65415ea2325819649ca90e307143640c9cfce25ddbbec8a2a558068ffefa2acba2480250f94fe21d9d1f57fb9d1bd27cba3cb021fbc636c8c541fd623e02f519e227359e2dd7c2d48147b445a6ce67f0cb967041cb1ed6e0ca7ba5fcb87029fdddaee92da7c1ec7a4b734b7f830cc747326e4e92c870e0d8db2b20f37e2f4a72419076dfa487538e7beb8bb24011eff9bc96015a4bb182a28d61afe503346b2355d46c3dd570853451a86c18d5e193cd3de2ca83c2ef65bf0754fe0b481473b2ecd2b42dc7da8187025be442397ca16d59b3a4c615451db7fc093cdca8666c7ec136d4738fa9d126cdbadfa578ce0836c5a7550d5585dfbc4041bdf22c590a3d6ae6460080776c404f0a8b2461423945aa27079cb4b7c67d4e6f419642e377ccbce2332583c0821a06b3d51825b3ee73a726dd3f66c5794a13464afbf89597edc9357a71b7c9c10ec3b3cdca71b6e27bda1c0d57e8a35bf67620c7ab4693e33cf644679c38f737e4771100cd8b9b259f4b4c9635c894749d05802dbed48abda16a5554508e697ef7826d29c13451b5ff8bb307fe574a09ef1d73769b681b4b2eba62c209d4ce48437c865beb604654434f19b083c063827311db4e03766cf31cdbbcda136fae5af0238199c59ca2afcc8ec53561b06497ed2a0fca63154ba18c6b8ae3392a4ab5df75c1b0ae08cc053f4555b409b94a23d6bc19f4a2f16c6ecf8f24eb53903e2a21a79cdd41d2bef8f2563e6a406ebe5820066b68e8076bf74ad27c3909814c42806506a98f397982451ae769faafde9b70560983c591fd87c8a338fdd8b353df8e41ae33c4fdf38d495179d65f94e926ac46d9aa480d0a22b09c06217fcc42427340a6e39be729912583925b4427a185d2fed2f9f0af4ba6d96ac4ac096a5a4f2e36bbb15ee2354dbf95ab79a5c70102812215154c11ce5fa1e89321cb4ea6b342309a998e16d9c47c429ee6f30439f8387322237d5b013b90b04619ca28fe656cf847cff21192c2fac4f7fe46db2165d690a6ffad908eba13f36d9e08514da49c34842c3a6c89c31716064bd33dfc6d056f495e65804bdf0518ad84fed081ec9121a21f616b1153af06ab138c926b8f3b05634007328cce963d9cb66b36a25eeb011b79d7aa657ffc342130834306533fca6be968a11b20208534b6c28a36a67a6ca392fd926d5668684ea2e1a6f20d51f90351a542127431eb943885dae007da34f05d24cd0924b3f09184699880f66ceeadc6cad88358a9b4a69ae30fb30ee755ba51be2ec553e0099e4492bc4f3ce109dc5019b1bf0f2600537c6503af06e67f955819ac4506b98e2842683efe80e870a02e7280916fd9799331f9409a799621ef8c3847c1a33f5b380a55679aa44b9140f144fe7c201c0e94a7d2e9205c82143f3f52ed6b5b81028f689b84644ca31e8bcbcafee463feaa0862a91c9aec4c30f22e21f5089c34678128108341cd12f9d12aabffceae6357135b781cfa77d65ce92b835c82b1ae3a2ff52365b3d2888ce90a46a677ba4b55ae2ca44ba32ada083005cc2b3653e36e3fe8a1c9d1b103c1b9e332d5e180f4fdfca2e3e67088ecb4194470f8865e8885fe6dd294025f09a9af137f18cc237fa3701ce3a40cf52390740b9b57084f4fd9f45e583283c6cd301c450c2fad2d874206410a9076b611cf79da4fa58ca140135a4732c68fe0f185189515f019115bcba3a24deab1fdb2f171dff1c662837b28780d39578b15c50c8b1cf08dab375cc11b9611dab966b2b4dd46cad929f61ce3da850d301c842a5b6973a3f0bc24e78008d75757082a9831aef2f5b177ce74e84ff3d941ef9e80d20f121f61c1d295e51691d2d30f4d2278e2e8ab995fd80f38ef5b2107c8164a3325b10819c2fae630d1152b7cfb3b0f7ff0a36e888303faa203c8fb890fc889bcede49a448aadee8f3cddb3b13c01b28e0a4d22d01c18ae93ea1e597484f8dec45fb36b443c4635ae0e307e8e81eabc06fc6e661933b6fbb7db81720011b07cb8922bebb08c82fca95d246ece1e954b1c97e265d1db5edec27809c2612beb85e6f5c01e3217e59f4cd2dec83728f1d2c953cdcb66bb6aec50aec78426b44117e75fe664979e2ad825dbf2f852d201239046cd54a5a462a15e58ee8c04bceb7448670cdff5a0bb15e3d55b01183731553e0cbe1a9e9e9cc015689b81fd15b2974013ce4a4269f071fcbf6f1a5b2a9b2d733aaa6df798f8dd1f9f2ebcd7c01a748606ac241bab1b9dc4c82c459b6e993c25cbbddebda67c8a6153b8d125d9146827b586f0b28b0686d43a1633b8541886920dcaa90975d0c35fbe2411670066bd32073e97081ea38b48c29a76192571097f2b4331e3ea0787f5238fbd0b0c41c0f60666616bae90e6f17a7ab3c67818b697c2d313b983339d18d0f34fd7c628bb8ed7536f9f4873b85984603c81fdf7eb906dfdd6fc8fddd1ecb57a65277598a44748634a6959da17ca8619d8fa377b3b203a330814b9788a1cb10b2236eee3bb209e402360cc3bac76244028b0a039f3187a02dd2a8575924fac479b4b3561396b3cf881086c726a2f360d70a99c2369d92905be238f80b0c1882dd31e838f61be6554b624eff3f1dd44a4cbcd6c53599bf281fdb61f6973cb873cf3b73dc0f13bc34ec6809708ad28a730988ac703613cd7e697f29b0e79f8d7db3980a32522b1d7eef3abc9b23d84eebaf9c04cc21247db77cf5447aba18f2de3eebcaf7440cca1d49b003f858bab832118180bce53ff51824a78554973ac79e88a157b0a9ea7f0d0862f546f594a30d47c495e817c748f4d84641e2488100afbb7b4ce6feb6441805d153d4749d0010af1350d06539b54cbeaffd36768572505bdc8cd9c6aa19b64d04655477f84d7c4cc9232877e606bc1f723c131907e8db7cf88b6239552321e838e84c5b2cba52537128bd137e8fa95633efcb4a0f86c972ce30acfb89c1e6c54a33dbae5f17b81729dae8c4f2993c5edf3d9fee215f7dfccd6014936fa71cfd9e6ddfbd00709e5d4ae27893cfb8a2782c4f6704879fbba408e1de97197250e2f971b68321954ac19a3567bb806475aa9c4b808c26eb646dd85a732b6875cc14209393ee375f729660f9d0fca388641f397a303f4e0bd8e3688c4adb50688a00430977d5a7a08eb1051d7f380b09f4acb5db367971f450c9bf2690aaf505ddd838e841e9753b0bc2e5b7adbc1e5d32cc3d86d77e62c0aa1a8e0fe33eb62640d8918d81ee09149967640676889922f28de05886c059f23c7eda6f53ad0a8f122368e9fee62b8ee73dc2bc247afc81fbb19e2b35ddffea265fba6710fa19cc64f1f21372bd07ab8e52a03fffdc88b712be3db33dc2b1a010818c53640ef3dfad3c04217a9f0232108f86fdf2fcea2ae2257120ba88fd1f449cb900f5bc3b33aa493a1bde8e471babd61887098db7f571f2e85ece8da4b495e73adb685d202f1143c573e09ac884e74d510c9b29dc1f728c7f298b9073b58a854c14434d97ddbdb15192de4ea61affc17f284a38f2e7c659343ea8108f4413fe580f1011dc7cfa7a0ef5ebf2fd96c454096c88029c8863820c8bdcb91684492b04622131b13b93ca2644c16f5e81997ab82e8cea8c0d98e5c325509eb8aab42ee9dfa8eea7de383ab1dc063563258f5b0c3d1709369c4ae4fe3e0a2423cf7d96a0609465c166cb528c85cffafda2468a7545dccf4d2161ceb32f670156f7e83049c09a7f5166fee9164ae145b7631708fbbfe8f17b482c0fbf65b71222f4e466a7c96c6a27744ca7414cec44eb2c0d60754536e716b657d48574b9756fb7fb5c64555fb4efb255634239fcb9d85a25807c39d06fbf8446c2be26bc5746eb492d45899d44e426031c1d8cb8561fb57126b05bb9e3916a536c5385329d4057eb4c808383d015788efa99761a43f48670dfc1af8952500d841de843716fce6d94f5eb725eadcf07ec987ebc6595f19dc559015280ca9ab0732fd70baebfeb36f29c84d66f003d3a3747bcb60222bf52340c07c93ac93d4e60382e12cfbfad1039355582fa6aaf4ef974cd9340ef551030be194a81047d0a67f2961e3f0ec0db73c06df36e4a0fd4168cac9bac42158b334661c46cf779d86061ef51587bb024c072b2185901cd652217bb03ae08f4a610eae7925fadf6171402e370a2686d0007918227a4f518d6b74ff8bbbbb08b27038fd81ad6e79c0b19b697e290212328e68ea1094e9f62f3717fa180f4975171b2c4e94085f3de7faa59c1eba8aa056a6a93e34f5736fdd8ee4112416fc73e8d5c7d3fbf51395aca6d34246e1728502d8be0514a3eeee375cbf5a7e65f2f003d91392ca6e7efb22b5d4c7299b3d80e008261f5108f27db200cae2b54921d2bdbd52220ac4a65e10dba2bcb5db51ade4fd3d5d4e91f20f32fee7467ca949ef4ad1f9316fa7e84bec792e50c43f94366e8e39fe22a7f55037cb9ca428d1619a890ae71d08702d8a31b27fb43fcfdd78822cafe7bbe5270cac73a5917e961d72e3d662fd206b0b17090fe9e563930aa6a0a71ef9d61595ef5140634db29b07559431586676fbc4f3d056b187b1f9965b69045b416c38f6f869b36b681cfe08e0a31a083159f28f74eedc3afd7489c94cd44260e246f37150e599209608d515b57f0056889d47097fa4e35d70c8830498d21da690e0b16b6f21de49996eb53f3c3c4b8ce10cf51bc579b34fc420ad90f6a848fc84cb0ed956060681f83f66d4de15bd631dfff6e5c36b767c78a5a371b783f0bfde5fe1c68dde4d84e0a447ee8f28233138cd75d1841e703ff32d5ab43d6a1977c140fa76bbfa595e0f8e45d5b4e2d67974e991bcf1e08775011583aeb141ac78694125f96742caadb959feab2475dffa8a20f1de634b1a0677ff2e531ad2176515201066ef399ad9b3440b9edd39d221a13b4f621b634f04062d35c82e30b4e25b49b517ad568d4911d79a99d2b871e1189a77520f4c1b8c9cc0910f2a57d6aab86f56fc850c8db61b7648f0e1d9ba53c2da913f81f9bd2243aa70fd7b42b795f0115207dde58b83348fa1e33c4ed5593d46223af3e68f9b5adb886b5a12f5e55918e71d3f30262ffa82695a30f7e1a44630ec0694cdc3e97d7738e1f3cb1305c62b0bbf35eff9fed40ca6dd993472c1e3fbdfce588aeb3f10f9f5c1c91dabf3d456a344caf6850f87bbf5c59174b6c000296e401b782d5c0b9f3d21cbda02aebf7b9aa4f7aba4ec30dfd947d81e1cb2195a0b9dfc489b1233550caa839bb99bafbb64ecead10268c86aa526eaa4bcbd4a17fb71cb78e05c0393717164c92afdc0f085169f737326585651f5bccb6044c50e7187fefe3a1db327f393009755f16ba68b3911d05b19376245386d243d95ba757a7e365370b30bfe2d3aeecbe20b021d5505a3f571f2ba11f3d268a7d5d0a8a34fc62a06cb51fcd4f7b388df61d3967da203d5876694c80dede955dc27ddacb08fa416d55f379ab87fdc2565f4988b9f0833d72aeffd173ad1b55d8e9d7c881deeb52196556f74d45d660e0768fc8e5e786bfc2dcb4ae086445cb5e48d1db0ebdfad8618d7b9b78a05b6da172b532c3781c77d4cc8a785d8174caed12a6f2fb39c49dfebd9e395f302daa5fa801b175d6e5f9f16a6d10e4680bc42875d24b4c4449b14e75f620b30d06a42e77fdcdc3916991fdf4309bc866d4c44cd2e4c9c804e8c53af715ba059e65ae3d4f35833b70fe0912e6a5a42c04a51f65aadebc6b41eb53537f631483a99e11311a7f8b069a6f731e435c93f1208f4feb26fe0a633a71712b108d0006af403b084113e32f5e1bf7299a8b133f275b22b140d6accd71dfa8f74e39fbe69e95c1eeaee5269111dd113d1d494785b8998c26b31381ee3ac87ee17f77b57c35f17d4e1f3d23b2a7cf9349160f39b2530b4b2b884841a236d832d25ac9620cbfa8e559d82d64d0f8dcf8c81d5740fb27e6823102baae3fdba376afd04c09082dca6155264556d3f04895588712055bd7242b23e5e81166c50855979102e18c0829e0c55a3995c3c12935b3de48d4f3f3f652aebda037c9c9cf80faf43f3bec071c3d66ee0f9f0480362ce22724a4e210ff1d71ebc02ebb1e20ef7e292ddd01000cd92608252e95640e207f26350d0e9d759f25971a4d711f36132260ce59dcb0d3394cad1c45417bfff1584983ee8e5aac6bada1124931e5569e893d44ae545cfb99d040117cda0f83741c31a9e8843a2b1cdf8d4676287aae6f3c611760129f17d0dc5f2e98f7853885f12c24b63a11c77e5ad8bc18c03038c2a6a0a629deeafe4bfdb2a35bee6604eebfc87650f29ee905707237998d0767cd9ffdb19a7331fdcd7d24a0fcdaf4047ec19c9bb7a95a6b12f2f25f0c0028500e8a18ebefcabfbbd307a95f3f9790fd890664498ac508a0103cec3d39b0055bb1741f3e5cfde1735a636d1786aec838a00c533ee89c739ada2ad539672479487a8c609b45ee58aee50ad2ed034078d953d7f03edd98784694e52ae62cdd3d3627e29b861d2216760b0ecd37043771426edc5b96cd3487edd5774c4373e6e0e8c92d61237d7d540d98e46558800bec9e489654830fc7a08dfe2b4f22b93aeffd5a0d3416f62faffa4f854112fbe40e0bae5a6739f0934c9477d337df78cb2faf2dc64591f3025553fe99aa920e7782577ebc4285cbb7a16321612994accc5ba3c668f0e0d4070e3de7138adbcd0df88761d62aa8e76bf01fcafe0e8d64521b2c556194d9fccdfcbf6db8f250e358964adf95462d749611fc9640e4bdf62b5243153df7b8897686aa47bcad9bac26c9a14fe9a4265a2443c120adb7544afd35635f12f8b5547a346b6d2dd5e52a67bb1e4099a874e07354bbc18176d101da68b3a400f7fe3e4c90d57f535f16999adf4dc5e3df014799d24528c352f72d62c254c207b0bfa3e7c6dde731e1dc91ed5d96c2cd1bd1d8ffe8490ddc0c17098d03984af18e12cc28bcb84ac5a9558f29b48a1a8c077733bb27856ab01e76038a6bcf89c0c1f53264eba5dde8c0d73f721c505456cbe9f0b572bc2b75200940e49fbfe5aed5521e07e85e5339067e68535897cb84ecf80f6e7e71c0ef812bf13da78b07c44ebf57bc6f75bad8b357d799fb2e4eb60054ebe2dd0734f26ff4ae98d374fa201ca16b9d46d334c2bc7332b1828aac666aafbfb3e63a89799578c50168ffbc316b7dcef36b847f11decbdc18b65da2c8a563386075623f617d1a9b09d028dee582a15b9f288bb0b622ca15067514a58a155763f964f25680b90ed740b7e71669b7c76fd3530d54e134ab0c4c12b869959ca72ef1fc733c6b06727d7cb7f2df267549bc1410df91f8fabe74d596818e09ce5c53de087b827c9b47657ae36a587d7c0911862715d7bb41fb4fb414f5439b347ba91b136ec8f8bc28498cd8d85dbd622bea71cf56010da591966f549279bbcf97226921c4e3468fbf940e89975f92143471387e855a7f1d8c0d15128c975770237b4c842f472a74be67f1b3e99f8370760abba4f6555008bb2e73efbef7e284e9806772b1740ec6bfe75df22bb239c448739d85ea229554ff3f01025306c8d79e4fdeb7d137be50fa186625c6498ac72dbc42cb55b63c91aff51ea666571d2494798a17db499cf6bec52356d372816a720fca94862ba8d628aff0600d92895dd864be6722d0fabc5057059e63a9614bb1f024230d946a6bf2bd998911528a1ddb1f03b1b6c50d436a91835ac81bbc5139006129e477eaa2b2b8cc16bb6c5f4c70fef1c22d686e3645710163cd255621d6a85882db2b41e7b9ee6a40620a3fb74522b33236ffe245268c0bfe636408e4f23b3f048319a52f59a83e45440029eaf6cf1911e30beb72e97b8e54b177f0fa492cd6b076eccfe9a0ed3b7c08a4edf23e5bb5a916cf9d9a38c5d22ad09f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
