<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f84b3bd072203b7f93cb15bc75bbeb5e742baca9e5785de85789693f2b2a94961e85bb2bcfdeeb9ce7f17c5ad909366ba140ea49eff40e28a907b8b218cf14f7da022f68f8145189a8e4b31baccb16c3fd27301b75d67b128e8b43cf3610377b26a92398ad140af434874dab3d7f047635496b5be735187f2f3298eb44ca0a4b0fbc69bfe187e5b52fc8c26bafdd672e288913f67ba2dd6e6871961b85b149f7d56f7a496e3acd9da7835cec7b7890c4834d43254cd9ec46b6afa3e8913dce28fef6f6d2f11353b10741b67a46e1de41c77642185e639a950c24703f32e350f882a0afa6c9c8d985a6b42d68198a179724553ce38099df17894add2c16714ec8e250c07e4018b62d9906fb8827dfb3998c6cd41a5f259c120fbaa0d74bf6e4e2a7084e9159d817e1511d6e311538c5c5fedea7cc6e750480082c9268da85f50db93853dd5a40fee9671d2d63d04f0f6b9abd76cff63dd7c8a0238b999334f987c99021780710569b2ea14facf3053b78f3e5ed83c760893bb623dafa3205765b356ca6ea9251d52525fa6f39e703f4ff342e001fee02c95e0bdc5b69f76ce5c005dbef6cc8bafc5c938d936b2fe105cf8781e266017180ab11399806e37022bb2d0e5c24d8bec96c81e44988604fa39c19e9c4313a33f792b311d4a258839c1b5ebf6b03d27d9728d6f2a306308ccf8a74b2d4d4d51a724d51df4c16fbb03f73e7e0d5a41089be6c4ef34a7f713d5a57b9b186df8096ec4a604faa3466fda8362817914ffeadadacf3e9b3190707ed878dfa2a80227474fc65e15706d0100258a024cad3ddad8347d7abb594f19368b07a3960154b8dc5cb2db990591d33d33cb74d72adf2ca813a7e7f5215184a0e8f7e2e628ac8ac7cd46185bbdebc2606f8a1a17abcce45da484dc167b48fd3dc2664c048e35106012fd9bea1ac883737da2eb5ee6a70500b8e1bca82b23ce0da1f0bc3344f24c646c961601feba59b8732922c85dd0bf85c1e871be2bc26a865e53c228da81b5e8ea8bc88f9050ab2480afff221c5949ec1c7ea7b466c1c68096cf96f3a21e39ad3f48ea6a79423e5a24cc2a5bdd0cc92a5797d59142d8d04a85297ca78426f60398b6b171abb57ffd04460a2c6ea097487e08ed34d8f56c7b9084534cbeb66db2b190b445d38184bed7bb1c93301dec2f0b5bbd6e7350763ed9cf66c4b22b677bb80bfcbdc3d7bafd7d0d9c93550349b50e5f4242f766b0e40600324ec8c37a8396fec07a22ee3c92452bf228b547118c87b22332546ff42b258307f3c76d0e3737b12d520e3be1ad7bc4d7175644ecda92eac09cc978d758731af78e7823490a556142a661c63f5e278ce56e8aeaf8ca79521cf60fc23ed4d90924f5568163c349d48060b6d45e44ea1290b118bd54195635a3b5d1af1ecd8e93c5cdd0a593b057170ab2c70d4aed910bbc1b27710410d591d2ea007b9e0e1e0e9e5dd90a8ed85ba172067a101408522e3cdc37db29edcb2373db06b6ce53b1ee387cb76c7cf523dc21cf68aa795729bd9064c56e747120c9c73037594a3b9760ca101057a7658be27a36fd400c947dd37566f5235dae606379a1837b6b3a03fde60de670d6383d824a8545200adb169f14ac51c050b957d8713069888da04cf6d440575db9f37bf8edf9a1fc62234c74d6c26aab5775d2a5c60d674373eeae1297518d6cf1ea92585ee6c334954ce3afd13f3d718bba736fdecf4a6c2d5ec3685546f5cb1b87e1d67c57a4528bbcab7920d95dd6f00d3babf79755b4dafdfda93657a0dfbeceedd44a7b6ac6ae95e39560f153523b6126193dbe62ec2e05e2199f0dd18141f4fbad2db2c51ac888eb228a07e2ebb094533b59da5c7579ffd8e3b844071d46516ebfededfbf86d17e7a82227d0953e14d07853127e1c1ed78009952d1fb75a173619b08fe022323c672d42159269259e5049dc639f8719ce87d00a0383ae3e3a10056ff459dcbbbbf24ec1783621332f98426828c8e93574ba1859181edae2be96046b538e38c9f568d9c788e12f6e7ba256590b140ab1f46c888380718f4e70eac592b465a105de5fb3deb1fe5a93ef5a48fe9c23f0d3473ddc79b396d49aabdbdb9a1134e71e3a352e64b0559d5163afddb32efa57747df29b1a0ca955aeef1e229a64cfc9dc719cf5334c6cca9e26158d4dc7e9aeff2442323a96d2acc03068b3439ed462a3cbcb38b4ea9580183b7cb87f73a8e3c2653c9c75b7c8cea20b167f480a76cfb969e473561510f4087efc9b8dd25d035abf1d392413866bf193d73286fdec4ddd6ccd1770a6a953b80fecd248d2449c19740250c41ded92691fb65f63415266e591e4f2ba43fac4b7a377abd9529cb30b29e996e636e8edb3b65744f3ad8a69cc132abf845b3bccb2a9048add04b5fd7caab5bd11fcf772b1e2bd0b0c1258a023e9e8a093fd5b2e106f093850ff20aaa4053ddd36e6f9dba1ecdec6bff8cf15463d7eb51c72cf056f602d09129947bd13f262d6279085ddc5bebb32735d52cb65da83a650efbc226a2928a6f127b7cee9538aebc126e1977631b66e8d78aac3e0c8b456dfb6484af7178dafae4bc67084865be11725cec7a6f862c4f01a33db5421f84658ed7cea19c590b955998f8a32f59fa859f2bf0a2b0fa22ff795c59d06303b968fbf1b1e5236c98c9712ef0593c65959d9e957f0c865d0a9da54fba9d5daff0f904d80317f391cb58edbaa4c939df80c0be6d895c5575a65c3149dc5c6ac539afb1bd1817d1f274a0b4e7252ca554b2e81877ae00dca8be6d95f42e7516fe282f9f93d43ac41a0c76e428ab4eaa3ea45f8926783dc082191e4abd74becff58752392ba7cf0efad92ea5d4e71f9c95288bca526f6e1bacdd6d69df2d075b203756d9b87a4926d462e11ae0fb57f8625e9057fd8fdd69fc40233f450467e3fc2808b78db00d133790ff17e7d269d9571ba9d2bb8e5f92ba0f26f5ed98b4ed7ce1aa9dab7a0891bf4988f2ca26c59dab4e27179d53aa068212574d61789c3ffac95c022b126a322c683d10cf2badd3df7e9155d5f9cd12461c13174accdda38a1437d860994c332f179549fd3ece4889a0bf7d9810b94be855bfb516643c463697d45b1ceb56a8c03fc6eebe8877abde69010cda870cab3a85d67d3b6f985d13098f3289d124f30c4f81bca4c99f5a623522e435e2abc7f24077f730a32575d42855d7ab207e7134ed9fcc5a36e9b9fcdc9e52cffcbc7120deba3b971c5c64a84d1c6e5d2a368c7e30de22af34061e0734b50f667423893dca68fca9d9076b0a0bdfac926e7dbff487d124cd4896d97c439a816ca28a49adad49a6508267796ddb9f7bcd43a1f40acb75b0efbb3c699971bbcbe3281217f33a6ff0ec72792de95d232c34b29d425c6c92302e5a6feb4ed232e6bc4320bdc0ab24aad2448a0e56babf2d6bd0214765a3e21cb81921d13f0c1769bea07f83b2bebd7ebd9abd65a2064e29b17ea154d9133fe75f00c0f8fdd626037d9c0725d4dcc7e6034bd0ff678cc7a8ee5d0172f1f7c592c0218dbef01c7fb7c665d4a0e8c3dfd767c6f5d9da92088d04c3f40406aeaac799d0dcdff51bd96377e22d3afda93e77f2c6d89aec2668591596cff9d3daa89674d6348e522c4281d3028fb23ac7f7205e2f59d769473b909b8466d86d2717d4f2cb50680af37229a6f8799a3351147ce56602e2de390e6cb0c931bc64810dc1aaaa3b4513ebd4d6e7f094602922ab146e42f81f6e5965f9519a5d4418c9ac9543e83067dc5d4a25fceded5ace5e4a62bf2b1c7a883350c94bdae9fe1a2a15d702c99cc6c6870788768daaba86ce2ac1edb42d5ef09d8e1968236abdcb455b313598b0a046725eb41846187ea332e3f85230e43553faa30f5e0eb739b7e6f273345c32d0d5ea00016caba72186d418973a9ecf646f819b23366115cb8f66879f0ba068bfa8710bf8fec73a530aa7e67b15abd1677674f2c37da55d11c583de2a9298ccd49a77398df777bf8005e40361e94018ec2587fd019f9d55b21b309f73a16200a2e944eb53e586a9407357022a4c2fff1aef5f3a7818e3d12b969d0093a32e6c91bbab8ec35f2836fb36807298ff94c22f88be957d6a0cbe36a7521cd83a170026aabb9d6755f3b3edcaf4d276efaf1f6d0a3e7fcc9994ad01c96ae7f1deef9393c5a02d9a21cbee44f73d7cf931624da60e7b0c7c437c451e708f37b225f5e3d1cde94f3200da38d1a259e441594f439f2af617dbc255758471e1efc86bf632be08eb232c2c470b553b2316fa327aa7f05df8f67029452fb669e57b68c72b211202af4436c78608ddb0ba46c30d485a0624a0608ecfa136659efb3f984aacedff25c0df260a6011013b3495855fd64c45b7ee228790a8ecbb705b204689a19aa394db4e67057a7c48b4c3aef5ff8b966bf0eb2212436b1b182bf43c202d774497e3dcb02bde34d8ad6bc217e80f2c3570a0fd81051def30b7ca3d6530671a5fe2cf14bd4f25029506626cc855f855654d20a9eca43fef39cab373ecff3ac6418556f7ae804322bfb4fd7758d4a56c4428893d33babaf02990b47ae1af5fd39661a7c6bd304a875639f236fd89f26ebd5f3fa7164438b4467b842cb43aeb46ff80479567c95e42090f1aa8744a7b7e4b7b5b5e838671a6d69d1f9f0b68d323efd969a680ae5bed4029e33f7274fb69250e20881f270333a7589e08c24a4d77f6245f424983ef51878ae29c0ebed6fa355e8b15088cad862640ce4025f9eb36088c79ec795f61bd08fb53b1df555a8504fd025ada7cee2ecc2714fb593ad8f8f8851a463e7a3ea0c5a5542ad91bcd5ce07f84be117545b0c4c2ffb61598eea1c6c254568f288c91b80b3e457c25db052f1c37305991f168d764624c9658d9f0bba4f5799a4d501ea752d1a6d4c38ebe3137d8d501a60b0bb7e9f23fcbff9e0cc32fcce6dbe32cf03ecd48c77c8b42065d49e224fc0616dfcd134da29c125c507143587f2df6c6f9411d42569ef0e2b3934f4a6f0bd3327240d1b8d0912097ced336ed1bba4925cc52ace180b2ba3814e6f9a4138013795893a0aac088f9d5aafda6cc7df2befb737cdaf8869a8b456650dbc76a5b3319c3bd9ce646c891232e54a36bf5aa37a8e0b74a06bf6133f01e1f0c359c9f70c5669ebc08cb17f73022d3fa73e961e1b37ad5de511a92e109cc8f61d0a34dc2322851604336b56156e6f9995f69a6c3fc990ec55a9bbd14adba6a4ad18ae64beb6304e6062165587951f158217b62d0401c69d3aecc699cb999263830d5a5fb19ebeeaabe66ac71b4c23c625c8888caf865e8da4a54832d5c18186f837253cdfbe77b26d78a0bc00020cacac5be1840e1c0540582fc46358f5b14688377ca6b9871628cc93506d838756d7dcdc75e796e60f176fb4d2d8c4a4b7f915cf5e94e319a00874e74bcd229b38ff328cb051da2e50d337a0369a8dc70365d580f0d82b99a4e77ecfd69b5e12d603956bf7aab223ac5958d93ae4848db96beec1350a3af9060cd93ce0209f09f649de1dfdb662f07165ba7f61575dc615f9350254072f0d595c304f153515061be6db76a4d49ee3aa3997b0257d125539f844b61ff63f6c2ad6248c2dff96ac666d56f6c9d89463c82933ce1960e8aa3a113885cedbccc6914c108ede1d1dd57b87b23a4a76f60c421e9e69dc7f57e38fdd9c693ee5a1dde652b3aee3d477f4bb4490e38883f51dc7ff07f763585c34f1c9cbf79a0bbac1d8ca7389ade3569fc41501b3cd000a4fef9c055314a3d1643cd5f4be6f0640524912aba5bbafcbce607b0bb4771e4cbddbac39ddbec7d132aece1893aa6a5131e7b6c76b0deae79a9b399965485d2afc0e65df5b2691f91c5c1079bd38f7e426918900be82cc0db37f9e8290fb06b1c5a5c817cedd219745fe5e1194808d4e5460f54f8da6047fe55d40164e7aa99fb3e06959a94ad494c4d91f6572c521c57bfaa83162458b38f8e0e93a403fcf30b819f1e7fa72de87cb76bba92984b09cd6d6a2606cdfb292d24688fbee194106bbef4a0f29f86f828ad4aa0b88266f163fc4f0969e2b4af16173eb0e0d5d9c1e115c67f8e3bbc8f1987e943348d1d2e083b60197acabddaad90c1186dc76171dad1152fc1ff09d839c8c65e8cf934152005143d78f4085d164f95d05771872bfdcf75d0981c596bfb6e93a5dc08b6fe68b9396b9929294966092bea25c219e4be41e70fe0e731d7ab2be1c9ec816f367760f142fe8ca50ca4ed63fc95a5ea370fd768b8d4045ef32cf7e48aaca3e1e8267d4565cd931b8d4cdf10170f12b40bbf646fcfc0cae1d83036aa0f01be5ebcaedc8408de0adf5805ed5f5d0414c1cc52f76bae6a073a91c6a59913b19d9d0e8a973bdae12d1a25139521b656c9cbaf114ede0fc50b8393591612f53ac748646238bfec9a989c3e251c575bab2bd9a26cabe38f958d0009aca7a5cfb7f17252ec7aded954a9789b72abcaae88aef262b598c0c695a67999b2ca5e026130ba56e7aaa8ca302268f6a8d7c009e60fdef6673a84b609d0304574287009f8ebc93ef099460b1d15ee07fc559533b7de6dc98f8261ef550aa9b60b3dc81fbfb678dbd1bbe4db330e46f29ca261d8bc4bbd68df3f8ead26a5bcdab0084e97bc9acdb697d70be90848ba7baa05e1acceeeb436c2e3f3dbe559ac9ecc8b61498fee928edd0c4cb085a4a1a9cdadd8760629a8e90ad73a12ad15b3a701179948817a31ceedd60eef5fe4e8a2c495ab744b9e106c497cc4286d36ebba5358a7ae460ec78f88df539886fe0e24a0e05b79c364dc4b69336edb4af60634b87bebfe02cba32f22760bfd90d3d284e63293960c14e887ff83817a72ff95627dcaed5d24f4b766a627795bd641071d41c046727e94fbf9f8ff6a8002436815bafc66983feab42ebcc0a4cb0bae8f8745114b5b806ce4fd2da5aa002cceb8f3e8d5b0570d986d6b6593b709199f37ac5cdd78f10531b94d06fde19602b7b94b49dd7b81a8007dd6881514c81b4493b35cb65395cce95919c7ac9bbfb7df114a261fbd9b6c2de690a3e7c759c94b4e1e569ca19c739e6b502c237463d15291c4bd01c04d8ab81a05dcd73e17ef7c802423865d53afeffe547a4657b7cb602d64b0d2ea8be2646b1390c4d81719f9181e838bfdf5a4a505e3077e85b52a4fd2954cb78b0fea07c54dd6123878bcba1f676f4c1736022038f601603c05ad25d6c6c196ff05080a7f92a5a29f439016b78b631ba3545828b35f326518ccb72e5541ef0db85412889036b95d54974b1015c7499db9974bc503282199f05b26774f52365d268a98f6442a2149e6129a7fa97cec0e2f6fec03c8e6d47431ca324bd3f77ec64f4546b1b34eadf16687fc16e3604d19550cec292252ff83dd8ec121d2f5548dd7cace8c5365a92ee26aeb2b6e2dcca1e54e4673c270a109888d286452acf503eec76b3332e989261da1804a15f701fb6e594f1d6008eed9da4a9f2771db36db485a1d20462693315f20c95d2d13afe6692bfd31d93fd161681e9e2d3902ae2de6aee6c3546d625748de4b1115b0bda97d8afb7b516f4a21dce9da5f8f7b46f06d59b340b66f6e762267fba16ca22071272d73bf6869d0f759eb7266d5f172ce850967265ebf6c2484a5ba3102ee8f16fff857f1a6e248b87a73a13ea3ddf3867bc1a021f511493a35a092f0f9fdf7c6b1c58bbdce0a43475c30543a558b8dc53e4d5828c63cb0bd890f8afc0d5e3fb35de36af8fd7b00603ea1841d263e9da3f12c4543b3f6739a691147c8377bfb5c72b0ba0a5bb24d25ba63f5a23ee4333cf04edda5ecb7fc6bb6a3afa5e558c48226c4c4712f5efcd76e170e50fb96736a9dbfc82ca118f8dceb08596610ab1976ff7ee32d71e974aca08ccaea5350e0caa82caf3c75faf6e9406468e82e3e1f62716d4497f6573a01dbafeb35c0705b8e80c0d498dc1d710fb0f93a273598045b259fdba3e5d932032401013dd787b67c88c6037d2325501ec158f2edeb3834401b646142f79378f43f03cd5d924d09da795390fc5e39278b4c6009b0193def943085b6e53aa5032eddacb8493795187600427066250f493b48bffb1b6fdec079add9cec2d0cbf2d96e334a759ab297cbb71c2ac8dbe411d0b2642a24de00d9f70f08f5fb61e5d8ac3a12f82f2c313d762dac7168ef385fa309991909acf06383c8a8f7d666dd787c3ec332b854dd71e9d4c1fc42a4026616e8573f210af026424a24f5af4d72e794363f38dc806aba0d08498b5f76a08380e07a05cab9ed63dd3e18a1c0b26c2360bb92ed7f100f4422980d538962343604d587ac453d2d2ddf0c1736875dddb36b70b6713747909c036ea156398126f728c8ce5b21a670d7efb371b64d402d223ffb15e3027bc661033588bd6b9db97ab8c807056cb902e4c7f5f3a4bd4c4253f6268394eb44e280b3eb7c05362af4c8de42ac7a02053a1552172c18726200982fe3219ef9a765306dd0047dc7bde701b81967a7026f502d166118b0d5cc09fecfaffaec274f0172a1f52de080e7a21b6bcdc4b2e07cc690d2adae203aea0c04d86079d4b19d854800e6c40988e9116832f0ac18bb6cb51032579812e6401eb2373c0a5e4794d49c8583dd125817f7145ea2e5775c391f6837e265780eeab23291b8e375ecfee04f62d1f99a1c282c8343da25919c6ca527e63d45a6d2a0706fbf55aab269dc3f6737abdf6859c892bf5788b512c39c6e5fd4f4ab03662b6da8bfd92b60d3fdaae963c19b6d96a3d624cafb8cb3c277d22dee22e1ca608830a0c1c1d15cbbbe52acae3c26bc799484c16c65a08c5d591223240eb4d870318a28d0aff6d8af9f436f32c4396d52816d0123ed9b4b6329bd5e0258b8a67bb58512fb978e701ddc97a2847c944118a0d6c8806ed8e594dfe1058d1f473847072658c04f1ca662e463c5c5672d720b4b0eeb8d3124501c5c0688c8bee76071d5c675ef1045242d71eeab70fa50f562598f8b62835545556ba17102945895c332073e4fa3d004a0a9f96edc5de79f1f914bde7803abf6c764e93be4d820854c4d243e51d342f8e037d6089ae951cca9a047237d11e279c1fc1feb8b8e7e98513e2c4ed5b3cc884447111d3ef2229e262cf92185bafcae2f1dfdf0dd9f96ca8c161b6c334e762e442be9ed705827028ddfb0672d11f355c0737d77df1245c4a7cd54e71efb1c7a76e6e5d9674ddad975fbddaf5f91a1e85171fca35a74c0d12035efa5adc113cb754d59def2beeaf82d692f50527b6a3e25dcab678b4113b52ee87b35d52e41d9df18cc72015dbf1b77718001b347ad131e03e47f446f1f8b17527a5df8c553dafc616fe0c9ab4259ad55f67b86aaabac7d15b105a134074559c922984fea42f3a8c84c712de94e8fba1e3cbbf3b0bacc006c7c2ea3f46ff3d80c48faf91ddec6e2424758948e94f99963929b5a16388bbdbcab44a95233073bd2a4ac45ca39c2d3f8dd842ebba84d3d8819d6cb1d68c66c068a77964a7c1149258bc1d762692fc54b7fcaf30c143c413f97605925608d1fb5a9986568b103829c03783456d00d3ca3b0e6650f18fe0f64fa7a71e1901d79f70ba6153cc7b13ab4c831781130f4dfedd639c7230eca34d0ee7953382517854ca710b2eab541a964653d40707e7d6047486aa2d5c16175bd5404b920ba97aef919e639902cdefe7db54c411b50db7858dffbed06f1a20ad18714d2156a48d9b7853fbca288fe0a829bf239d6e344d8281c699e8c6630fd865b8cbefcec90a294e93eedae262e8ecfd10f098aa01338fd2b893a752378dd2967997d1d20f55c4ee295de9028c02531431176bff613d9ee700d2e380858bce094005cdd50abc8ea0649e3ebc5df00c18a8683829e782d1f72d78f2e8e0b14d156fb8cfa2edd8447eedf3fb16c1d248d5718f33f6445d7ae76b225abcc51fbacef5ab843822db13a7bcb0cef1d165b289f48e9830dfad6eec6d0cc9725d0c764a740c619dc4aa079af46ddc80c0c359bd06484d06f535e4c90e8521935682b81a4f680dbcbcf7cd4ca3878f7238136c3d460b099bb0ee4a95e2e8031760d9bf6847ea9eb414af4fdd4c7f03b4beb09c4911d6972706c18fc97980a86ee05aafce27bb5b7488b3f1fc46eddd3ab8a0e8aa44383be4c98379bed4a2cc11804258e51e68196cad65a3db3ad1e7edeead6cb88eec0f9bad75561cc232443dd67bb69c18c3b1603d7666d8ef6aaa1a3474693f0d16ea924f642b33e3cea553da5f7402ab6454991b5357fb68702357cc3a29f0d5f2f521c21fd48a30b3d904065a9d47815bef94d1a4b73b98277cc8d05386e9e2f9429d24a353e1efaaa8ff9abd2d7c81f54210a80e511049cf9403996cb631400a889fd7594f2eb37ebff96f50d40ba073ac9c55c1ecd356b3fb39cd841ededdb697dd1efaa590c88f0477848506d2eda54e86d0e0b8f610bc89ededaa28f4e3b96ef4f4c396c04fd6a832f76037b881ef744c2dbc2840d1377ecd796600902d09bc082259942db16ab71603e447e2896801d91f62c4980515d3bcfe00ee8c3ce13fd9b361a52ad7c5ea291a69263cf7cd229a46bcbcf1009fbf2c9629ee1ca9996b9d46d23e6ac4b23703b1c68096464405de872d3b150a4f24f695266686fe818297fc50e49799a73b92921e98253a27a24419787b0d18c267096aadac64512a6fb4a54a792e773f0b8f75a8d453ed07a86623faabf45d6cb322655f16a450df6e785a021e79de0970a2e4a9afcd10d0ec2cc7189e182bd2390c5987efb717432805cda1f3f5adbd1529db1d2c823061e8767229aa5115dbaed06baafe6ba8fd26270373c53a6abb54f629bb3320ca89f67397e5dc6040f7ce624a06deaa31aee8d3177663cb384e27ce378f03055564b8589ccff3090a9269abec48c1c2dc4120eeadd77e9df8f5a1e0460db7f75d3e4c9e8485250510abf9f9e85b0af40d5116194df5bccd9db2e71adc9c5d8cf063938e90b9883eb82807b4cf720c9c6f28ad0050ec87dc1125e48a8511019c27a7b165fe7a00bde7c33e673879f2432d4beff6564f6464a4d0424e7fd249c5795f063ee324820dfc61750c8abcd2c80da4fe3c3eec97bd48a45a1db42827d13e98a8fc2c5e2d0d4629d70a5446c202350670e4f0f728352536eb87e13add27f3f58a7df18455cbf3100f730f4f3744ef3cc8ee5da82c96bcd6c608d13f64bd86143feacba61770da53f69cd12e10b2c6b195bd43d995dbd342972c71c5b911582a34fc984da8fa45c1fa3ff51b6fa88b754bfc8be76fccbcc0c4a61d5a7ecb22452712dc44f442c4da1997b3710648d633ee29fb5b7b458ce0d817ebe07a444b5d1e7b111ce8e539cb9ffb81e9e662f7996d03ee3448a2239825dab47dd50815591f88b2f09318be0d1fb381dfd880dd73db170e9a9bc64e371a70970bbe55d01c445757107f5f1b2dc9e3d1318c3e6f449c1217859ac48293893af04411618cf22a3d631a128c67c769a4798c63776f9a2c9134cfde20f3839435ef797723676622576af0f4e34f5c4b7a7c91189a82d6e354b23f8b9459d40e5d12bd274dfb71d48a331ce61a660eb5386587847dc59ffe224a4488ffec94a735424f6bab1174bc31c53d2a09e6547f0a8376031f2e449dff95167378336b6ae53002e4b72ca700dc360ca04b98fcab0315116e4fda9f877af9face62346da405db49e199fde4791a424002b46007fde23082ee154809e2ad05066bed18b696b545fc57aeed7b82bc0ddf199c643cbce513270bfcd086905bfef3a7d8b51bd4076ad0b5359feab0edb0e3c690e17b3ce48f99e4104b5860dbf0be7d31d76c19d8213262d2b6a2ee2e5859ea81d90a279b14649a591862e2cfe2477ad2b631428ae81d55cc697b5586867029f18f624f96323c228115aa5c0b9f62783d1ecf1bc447296e14879b89043ee7f2524130573f69fdad3b8c52bbddf2e025f9df57b1b4f13cbcc0febe259718be82743e79a587dcdfad02d6803e4f1bb9d4366ae76a73259f5972a8cf19e8f5e6519034eaf6320bd6e48afa0cc727782b0d7bac1e6b7ee1c69ccb635660badaf86accfc9c4a5c34a88cc50d01872e13e7f574098d95de8fdcea97e48968fb85b1eb39d3e73015e0556c95fd8728224059fea294f7a2ea706f9e93e4fc64a1aca5effcdeb4f7306d1ea104242ff3f3bd2158870c53b2c39b512663024eecb6e224489a7de3bd36bb17906c4de635b845ed45dd72d2b58e6c89b65532404bd2cc6e66499f3b00e4d280e8f3297a441278e37208ec2dda631c731980862272db810a1d249efcbe848f4a50b3d5e1845c67ae925aef86e21e1d078f13eabf8d6a1034133889c9edc140e6adde3fc3bff9c0a3375ae140eed354cc1d72edcc3a4851afacbbac385444a97e03b6f9048272b4130da9efbc0d6bb0399970f32bb57a31975f428fbcb6d9e9b29782d6d4220d7ac7723abaa53ae5f177de6c658c71f47806a678bfd13870bb0bcc79b1b2fb657b1cd1fee61a6af201253b36acb6ae6800e9b5773797c3adec3e5337a22427bc6fdc87b95ebb70227017a38b1006a10b1f012f1d1934336d6c3dbeecab02cd5f2601933b5aa7c252c2705fbc502be7022df60a412ba4afe0aa22ce07befbedb079faf07b419e9a9c335efb31f798beca26088de312284aaf26001876c183eead4779fcf9d4f6b0d7ef515400910d2918fddf9de161fb7420333f0dbd65a28c525954c519c568164eddd394a624ff9a822700310fbeb79088d1f9555b875a49ad14a616e1bdbf28eaa4a14991e05aff22f421bd84f71f6e9eb610b9f0313cc25491f33f8655a7f5504d68cd4818465c8787ea3b38508f781145121e1d863bf2091d2da24545f73467e04e4b5fed84809addcc06f9ba1c777008d209fed90a0aabcb350d0af3838c3150d21987b04132150d8acf6c390ed176c2eec83342c8543fee3daf8885107ce2eace865527c3dd7b0a364741cca1ee0ae548fa4d520c023f27558dc90cfe215372b3d109fe3ef5edd3c1762a05330df56d013c01e208788af524d9cb86389b4b04e3f594c0a439c4d9ca95caeb66fab0585a6e41cce09e72575b00dbb44465f3951796162b87b5cef6176f3675024d2a52039510474f878aadf777829a0c49a7e82845b8ad519495ad7f40c992ed23679663bd778b03f5107d2a43799f253c4e5eceb54997045f396564ba2d063fda63fdaf0c9f635bce26cc2302c690ba975206164e962229c14e88e7dca72fc8f67fedbce05b9488133cbb3bc2c1ad6a253ddbe737bf67963531e59c87df2ec712f349d9fb6dcc2338594028f3347f88d78dcbd92d0400ad93bc871b169d18d7a8a2e7122a46766d51cf4403ec5951bd5da73146ad53fb083fe3b9505295ce2e9361a3d9db12c88dedbae25f92925bd52616dfd1232cd1d5aa601c8a855bc20623192b32de6f0875a92ea98819b0b5bfd9ba2400712847fc1914a8093cff2119cca0ddd7c0898868e289627409e23a1f63c2e959112bef6e8ca56ac8d23779c88e8493c659cbb26c196c7ed2bb1df961469346349e45f8c93ed8f79626bb176b2b0d0a37cc1b8c6aebaa108af5ec6907a70f23fc131f02f77c75b31e2e4719858544db628c720a8a22f3883c4143b3f11ca77ef283eb25b92e8f8d647a1ea20c1c58cdb910d95dffb5a8c6cfb5c85aadb46149d79a8e925e53f991bcdf63298214e7bb93bfb6df668567af78e1fe3014ff9bb35b3729a3c69bbde98dcd5178612c6b7783412b4c1ad653f5ee50620ce6978ca376db58c89455de186d50477094afbf054f1c3419df16be22e9ff21dbdd0d5430858e28172db8b9c3ceea93930e178f631eaebd5f8d2637955f5ab239e58d40738d350ac44d0a7496ba21ba0c44f83c0a01e1ec0f6685e521fc60447b9ef2861f99074cbe86e3850b0e2e9d5797090d5d65b96f56e347cda6819221bcf3866344de113624e96775f3950e63df17fe1c004fd84d4e6dc64b03c98dd83b2576bbd0db80a1d23b9015989fed48599cd5756b9669136d0ffa7865da4e35a174c74187d3abc7f65782f97e530159580cb5a6a7b9188ad42d98adb1ce052b2ab502b141d431fa452297185ea7ebe1f8328f19e5e152cbf670d22c5430bba84732db6ed7154f01c0b9e59d8dc9d5e4b8ac789a33508005086a93f046289ab267eaca1b8e6c8c1dc6121bd652bcb8369e600699c3eb9766d45978b1f46d2be7491d9ad407eb5400a7c6b76b11c213468e204e75b56cd514a2b84a74e37c77f64e679faed87ac360dfa34de5807888584f35c246c23c45a4910258a62403fa2d558c4f4d19edfd35d6e014866ca11ec86db09affb59a5f5216dcfb471ecfc9fdbcaa1ede630d6e606716a9c46a6e0127d3e07fd36623475fed117a5d21f750d5b76d3c375e85622634697e971fa8a5327c69ffdeb9a3e69c68e849456d8affec011b65d5c266794924769f66569ffb16bab6fad06238a895f576fecb5afb86738a11002db52d0a853400519d46008047ed06a6c1f95eb148d10c296ef39004e10e571b6c80f1240ba10110bcad05de9fab20aa361880348ef6928e8eb323d84735f523525944c8cded15323f2dd1c00b867886ac187a2b0cc4ee82507c718da8a45fe987f63dfd227c8892fbfcb33c0d34b8bf843d54018eb973e30b24aed44e9f860caebdb7686f551e543628aed809d8d42559660b88816f2bca4328adc64235f920207fdb9e8ca0a9cfd154f8b587ba8b94311ca64b03c04dc95bd58631f0600f10c9ac6bdffb68605de734662371e22809fbd28e56b0e474add36f5e7a6ce7de8cde60f15c16a8d75f6f85a253f6a78ec49f43f1250d69fcb248d0413de6208fda1dec0f0717ee4615f28fd2c4ae4822933309766f6d1443013d52ff777334865354a4cb61e85c73d4d0199be230bf9c8d160ef76acb6e353eb44fc3abb6cbc34609b67671be78ad85a5ad335da12acd664638dd7a9467212b62a1694aa14341e762fa3c9a85a503b69ce3f51d69a3e3d810ba8117976d96ffe47b2b95b737160a849f8a6911deef7c04839a7d84407bb5e72334c44468b143ea613507717f346382964613001c14f7b9f5e009aa516758d92602f423b56e4df9479ade4e67a387a1e901b6f6ff7aeabdcdb8e8af9463efed0f0019f351facfe796bd65e919c7debf56dee0a1d53b39a3c84e491a833b340ad67f6cca5c1a784bcabc8a405e216d87e180335c3c4ddd231f7ec942f5ea0c454042ad4a803771988406d358d56dd34fc900c0178f6deb354ea0ca949a53d51806c2cd28de630f7c9b709d31c83b9175afd42249757f8f270fb34c29f02af22a3201658b83aab17af7f0604ea95d13767b8943a95a98e4b1a25f71f7df9a352d70dab59b5e3b6208dbb475ec94673b1285828aea42a9cbd0273e6e19ba743e2acfbfcd1f1bd15951b392bdbcf83d92d3b2e5041d498891b1471e88366fd2bb02032eec282db4025b04dbe8313486f39417abe27cf7ddd01d08e908faca74bab8d396db56bc79d76f03b75508bf81df3534ba534228adcdfc692981a04bdd832f82fbee1a3d495cc63772f9c980ed57ceda707827e414574304d5a7e0de68736690664f0a5ab8ff6ec953c103613530c5e12d86e3dc0b9cbc3f2d5eae07bd08b5bbe9575e3b37b2cecd61a67f914bfeaee060ef9bf2ea02af050b15753663d3482a578730428175a948a857c541d433c32f84861cb6b830c25d8998f1b4be0ee1ff8abf763282ae230efef82140939a3011419e537f61073ba1b9fa419d1e8e583762caa97ad2966a5e51444268f853eaca4d7c543af2fabd5d97031c972192659d4228743479e10e0ac4329d95bed47adb5348729b92854d4a17593ae11c137656f6591597ccb33c8a6679891e8fade2bc79053dd8ff5e6e00c4d79b00dd0398cd6c9af7a7e88a86e7f1276f9e246a37c4b993c6fe211d893a2d66a88ccfee303774aae6e22a201e163c2728e793fa3b15eb0fda88ae4a819c8a3e7188963fe630dbab9210559735d955cf2c3f7d512cb61478061fb3146549e8e68bb23ca7476e70f469a6245d523ef1f49a2b5d0c70513df544eb6a73de5053b9464a2707372d115d608253d7567b76ca530a34a16078cd98773206c1e16f8d060cfaf3393a64673c3f6d776ba7e281c75c8f4d858bf923193327da5eb92030c58fee4924832b56685d8315c4147cb1e32cc9c93f4398f4be11c6b6636e8e1f5450d768a888ab37aa8e1ebb24b67c5d8c5a053b81a95b0a73888d3b40499992c812d85cd0059961ba40550d78716ebec2ba1f79cb30b9a00f6da3bf8a43578321041e0f6ca2b17140b8901d61805cb8d090a6dd6fc41a01d0c8171a202415a757814c9d21cf3500bfe0fbfd77112c8a9910e252c0ddc5e8d7b65df25217634cfde49d55b47fb22788311b2e4e1b0b60267d305f9de9ec0c2a8e1a9db4b8ca5da7eea6a602b66dc7ba69cfe48e2d0a9f5edaa076d25052be26ad5972375422762b20e08d02a1ea89d18dc9a8e4ab67877fc9f5f6483a45e486279ada34ace4fb3e62eae6512b3856926861384e585895af11468c7ff3b7af5b36ce82081cb7d81849a3bd28f0e960870c10e8a12582303bf8237f5091ab9ff1c60a58490dda5dd675554aa01a68cc8b6fbb61bfdc4bdd3224b46999f2cf557cebce562e8a911af7ce584898b24545f15d535b2bb98215062d92895c1bc91c55d9699bd982dda63f8e3d082a52e74e61b63575e4f67e752475e3d6163bdba6ab53ccf97b72c3c48607b61b7dd392bc58cacd6f81d08ac07e63a8df04f2a574ee4fdedfb45eea655e41c160beefa0e75d35589b30a6b7611e11749ae5016bd6424ae456c818993d5fbe3eaa8d850270def36ffa5bccc5e532b6c0de515e3ac8904e6ce8af59f2b00b08b46f1d83eb08ef41c6208496779b471bd65ea8a43a7f1ff690acba16cf96855b611ea403791b5af37f05c1c4c6531091a8fa77deb1ff4a2cb721d9683651862fafc2d9b4b4440816d0c902415b262c09b1ed4bcf0d02cde22b566682dfcea0c57a2c0d01d758c5f88365bdbbe92698ac7121de329df887b3aa0d9a86e03d231c7e1a84c86054af965ed1df77f29f01a94fcadf96315cb2b9d5ea92935ee770bbe136e23e577f923ea70dbe6ee7e90c2741022bc6d6a3005a745c1f2d812a862a8c3e903cd2753d8644cf704547a943bcbe0ba67f034f78a4b9b70c5f4290e61a4b50e68f851c13400bd036c27f7af4e82f207689239cb97f9413e2d012e89fe00e807b64cf218dcd7d15ee188f993b11861aa3dcf00829b2acc6eceb79a6dd050e274f714f00a2b158120c387b5e4a8c3f70c5b89df2b47037e1971d6b84a24e3fa8442b8f2da64aa1b934e7fecbf48dbd0842c9df0dbb2713c370a83489d98ea622cd7287c11b9a82377b0cb156d8e8844c047d265256097a2877905efe58ae2c67fa40d33bcb98ee84ad921c492133d40b24a2a8ca440918d99a5e839233c5572a1dbc5186fbea23c45ff39bdf30ab7314369ad0a1b762c7cec58ea13b6d9141a2f6de2667ba5e98d43e7c2b51de5b3b1aa31139a135e731ac7ff21ee6278ca6bd154afcce7063be301702c6a0685904ebb61eaac360401bd53a24a09a102582fa5e1a313faba4bee9e706b733280c7a0b05848e61da8308e63011c432eeb6560477315ea0d3e2b5394f8e1bae3a87bd29a4cff0e03458cf981a26fda33b7afd2d82dbbfac668b4788b54ca4c48cd2dc0ada29e00c12f60fe4a59cb5170e373a091dea452204231f3d93fe83dee77372c37ae851261abad8255b0822aeb47fc12e71f60f5e130479b51b275eb1e16b3e46f794953ea7f42f1f94b5e4108ce7a5d0af3cdb1ae1846e4f3c48be6fe74c25f36214f71fddd6b9dca5c797a08caf771c4eaceceefa082b5ec627e216889fffeecf642904cc167a92d2cb26703a5f9bea9226710920750dc56dd285d4135006b921a407730","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
