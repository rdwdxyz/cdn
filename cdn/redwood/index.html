<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d633ec9cd6f32d0931357b5008562c42334fd80dcd0d7779dee93875dc78c704452133127b26b89f529dead66c3cfec0945e09f75bd688f09afaa39fbb30bafad0feb9fac369b6d95f9d8952d75be48e12185619c95bb61cb982d43e9153417488275c5c6cccbda36f270728e53a139554d9d46bc39544e7569ab50f7d6cbe49c98dcaf285f75d7edf7941f6c3c63cc6cae58780364667aae2a575a9db6dfdf883e38612ad1bf94f009eeac69168a019bad0cd821428b1b1971dbee62f72419e82678f853b6f63abb0989ec6864ef94c58af211b773346f6f5fc644c5d7bec5c88c8a48d266e89e133d0b469a0cef4407ba9c6eee91b39be28e169ff11e02af2d242344373c000865b2aeedc55171ea4d6c436197b8bd0a4e79a4bba732171af33995b37219903e5b752e312b12d4fb08fa90b9722d704f7c23cfb45a317176605379ce60c41c0626f21327cd47d5d2a1791e424d3be4cfe8193262fdc57398d35bd2d2e46c52f1f958d2f59420ec006781828b09d387ed766dbb0e6d05cddcf6c5275ecd115ff6d3732aa8483456ee14527ecfde3a27e2b92ad74fbba34576ef36ca2577251346bd9d8d6fb09bbebf7d1d72764ce5c62d2ba954e9780d68cd1b30715457a9f609db87961880e6c415dd4658440bbcade1ef020f81879ac94c39dccf00c64d77383b25d083c1bbccbb8d6781f446f015de002da097ab90648ae1fb209d3d63bd81decde1474bcee2ebec181293697a1d2a2d2d392172a99586bbe3eb227a6f312c99c5a3cf6e86a35307262eb9931c58c60b3f674c5e285f097ecbac87ea892c5e4edbf70866dfc87038dafdc2fd1f1399338088077af9880d3342ffa99a8ad610abdb16130209cc390f1ea9d3ae9d5cc431ab5a6120c60bc4cf66bf9f21ce3142561a57759a747433a3d029bf4e31c43533d8bb449b9468ae84c824ec70921cda1999c8b6b8a7dbd12632cc076fb52e4eccc2d5a8c53a43f6fb642b58143109c885cd25837594446c21c0afe61e80cf5b757bbb07ad45a6896d156469365789bfc304f4752d80a5d60e7333694de1cbb63c7aeb9324c69f37cb3333a1a877a71fae1bf05f57899150c850417531bf58336516b5e638be78b8e9720d23249d4f6b9a7163383b3761167ef5ef9d4ea1237bb02d5a0bc7a0b5423d46df1bb2a11fbd3ebd209b35da86da914f6f0f3857119f0c4dc2c927419e507959ddfedbf4d30d8632fc59554628da588bbc536629748389b98da54233207ee80808bbb971437e161cf98643b21b9098022279717e39dd15c2c1a0d63922eb4da34097b326352b6e02bdf62f94f1b47b3619ed3498585b8bad5b6ca2b00c7fd16f6458986ea7615af52ef0fba78b662e70169c1eb2eb545acaec085fb5302aa83db89ce00279b01f9c23d2ea4bb9cf1544f4d08ccb273df307a3bdeb787e9f0b772da593db62e0f1b467827cc9544cf1addf17e4abf3592de5bc1527239bdd56e576e8db19b251b3e9e24d6848be6881b65d4f3badb7c56f93abb321cb9ff678c2addca78823a5fe4eac5049bce7173c413081326cd6690cc17b3a73f98dd6660f06683f336ae49688a7ae718a26e9a31fda884c11f154033d9dc16a054ff74102b749010a18a18b793a873ce4f3399687c36f2ab5b9dbb7d458d5b9ada734176e82c867984e3b0fe4e0f6c5577792a5583b4aace840b870e746bcc9f2322be3b38bf6da7c749cca45d0f50f831ed5325d15928ac8534a6d84d3306313fb830974386b7acf8ab6ae4295ad8553c615e9cf7a0e7c4a04267ac8d25a714251f7e7b9d1cd83d48c3a2482eb15adda9a38b40e9a20c38ade03ef5422759b132ec5f58b71862cf47d4cd5584c879fb975ca17a1fb4b00436aac20e569a8c122d8fdc7fca832457d15aedb977b4dbc65e911ca0310f364cea41144acfe79124f4c0753ae6f0a02b0c3785ba2de80abd1791a88f9ec23ea5adacc46c51cbbb728bae05ca99cc9b51917f29163eb29abcbc0896bfb36deea72e132fdf58fa05da74727177ec8e276ee429843f19ce101b3333a2ec1cb008cd73e430a90dee12ff42424e1cea3b8e24b080711e8d9fbfd80c54bd1f1670e7f3ae1b872558c9f3d8fc92aac0f3195c954783fd941f2fdcd694c7b37a0d8581b2419e9e2da7a8bd2a598c9e453934ad1febd86568a60754ce6f116c0f98a33c2b735c415f72213e9ddcf1209dc50e4430db5a369a95dadcd3179a39fa6515f0670992a399703b34b0d057162fd465b83f57772cc3bad89a644205bf7c4e3cc7e051ca5a1aece80f1416b6841fffbaef0773a3a260aa4ec165665c4c474646c756686b34a8845f14cf1132889204376c963299d7f5892a0dd1f2fe0a50aa1bbec76113ca7ad02273ce5c0bf4fc47d634a28d153117a9a3578739ea204e142f8eedda43fbe99854f6ba8fe3d2bbaf92581b735badacefe9ab9eaad098cb440fd629de63041d6d286d84314734243cefe072f4b8fb738b8561f565b0c0ff51388512de6c84aac5ec540dec11079480032c3864e0f017bc43541dfee48ad7066d817e59883fe206a2b40905c1a705739f65cc42feafaa588ba1013141db8137b09403e046ee0c5ae65938cf67d82b6bb56bda7db96a79ccac3f602ac3576c8de9dfd8e50060e2dc15264652d2149fdfee26cdec91c05cae5a7833f2b26089db7eb0d2e3970fab4a945d4b8001ec4f9d4e24e26d2ba907094cd88310d5e35178563a887e0c6c67988357a5b7bcbac29f6cef5fcf75e8b36b96f143ffda449cff3ae404c419a7b2e2edf2de286930c0c99716d72a2b313fdf21982a567583402e396fe4aa0023531b783039cbcbea30910f67d95dfcff4278439069280483828372afb21db81d8453100db151f618a60fba9496f4ca056b775a3713f6a6648d48e3978100738e410214f1db5928df753b66f855b246997662e35294a9e5db2c7ffb5871527a366f4fd457b253397988a26b660f0b23bc8f6bbc859f1b3b23dac6a73599c01bfafd9baaf99661da845fe889ef86b0b310d066895c32476079cb029c8766a90257b077b19dccb2298bd9b6d1850c579fbcdfe06079343601591623e8eef62f671088f283ca203730eb3035da975cbf1b22919332405712371f17ca0258f1b1ad2ebfaeee1b056c3340354f49b41fd4b32f6aa3a16145d51a4cb6c6ec0d0299162554c94c9f333240202d74bd0f1939a9f65faedc3330dfc21f7e52beab5f50e443d33190016e5e12ecc84fa852cfe749f15b414d0cfe7801d634a024a747ce0b96d90a3577fa722cd5ed5730e704d2ae62e4b7b8cd241980c93bee2f1fd4d410faef7967fc78001ac105147baa8694388b24fd493ccbf2791918bb264f34a0869ee689b0a4e2674b86ac3bf517b70a8426cab55a9d0aa1d6a9a1d9a8252eb726333ed2f487237436bd3494423057fecf698df5f804d4af4ef4092a62445b74106931080f116abc6aa068f5500a3c1161706f1e97b12ffe89774cffe70c2aef1f7f38af99d57681fd40ac7788d3c1b754f696d191ab99c7ddb84f27194698c74d0c3829d083ed589f0c12a8f83679eab7ef5da45121bf49d9de979c0062bc7979da8ff059ced2abc849e5930537f7bfa166a11da3c644ec6e2e645d2264213a749dab32dfd83902c05690f8ab8bff11b809a8ee8eb25b0161ee414e75dd2a9fde5c735c7ebb8c36e2bb76151b69a0ec9d5299728bd3d63ea63e45eb1c4bc123e21eaebb9813488d35f87990c47b729094f94b50c39d5b801a787eeb8c66772ecc48ce43fec155957b8660107a579bb091d5cb00f85f877127994fec8ef9ec4d98f7eed502dbc1366864895a1a077eda58075277e0dca0ad030a2399b0b1f42579c6c595c40b0f1a5b79738b882bcc1b3929f439f59e89b6e221979d396c84b7d4d46998b62354fbd9ef33c4d44d6fc4c47b6779551cf011adcfaa8c6d3caff4d8775aba3fee90ab59c64ba9a26fac8e37d23cc8f9196133d510d15b3afe921e5ded0578ec151136dc32f7d22d46071a1d9f9b09f921b1ce48b9cc77931eb63f24390c49b3adf581a9a4143cdff8206bf823c5e86f1837dc5ba4e36183adb1dc3316da70887f81bc20cf6d1f963d0128b73b9ad42e2dec50889641a937e3f94683489a9bcd002e28870d48f4783a2719bc2ea4a28f44710f87c19a5f71e46a649842253e49031f0f8d98a11dd524a4c837a4b7ce5091bda5dade22d8674ffec6dc7aaf1ec3d679d5117d2ad3bc994f0ced2e17bbb248302e1dd274acf89e0dc49f30663b6ea099284f956dcab64470db156c5e01a6958363d37e9e32d1dfd6c7c2b7d855e40bf196cff072959953f0ee86b72a38185a728d4b28a6933ef84d999cc0923598599ed8d8a086df9d987d2f087e2129ccc40c45aad9fd61ffd182ad719d69d8f4376749d831cc4d11efd8e38a2f9adbd6c52a870fd14555244eecf2b0d2c274769ac984b2825f874448e34cbfcda75d8d093c64cd8d9e7971622eaa75700477f009432306ea5c552520d8e18045c6e7c2522344a576de76b13b9d7c6a4e75fa73c70affeb06584ea3008b0334796fd168c2281a3212dae6e866182d05de440fbd9eebd89fbf6872f59eb0e581901605d33da13bf3d0ec12a5593784b9aa5daf437d208dd912061e05aff622dd1f80baafeba72be8b0eb5601faf01bb0cda72c77e378434bdd917fe92df61a9c8972a8c66fbca2f599e4c4724078fbde0f82fb13102144aa890c9ea955705e1192400564b7fe490ca9bd11a7f7b5e0624fae16381f414e7954bf63c2d4cc1cee0985f2fd5b44b18edd3e1d175d492bdbb0c99581f80ad3105f7508e89f3b1e9de2758d0da1b6be37a5b2d005cc8ff879b4b3a7ca0f7dafc313cef0816411eda4d65a4632939bd74491fa193fd0fd340dace73903e40e3c670b08eef4f97ba22f0952811a95d1525b445a772b8f75added09a44247456711e64573313094ba499c1c94fac63f6083c0a0431002e72a60b8e1b3f09a405763f923ddaa7e960bdf57c7c92f1216bb9cd97d99d1a684c699a9f20c65a9ca1dc3f106eeecd778bdb4d58e06b6efd6a8162a1cb2616e21191fe3bc676dedaf10347e609be70c35ccd1a79d506510497363d4c35165ef793c421f6cfcaaab3c1b9efcee788b6e2a9557447b246e41f6771807f5db38bf5aaa187f77b9a2064b64cc039083113c118309e420e041474bf55d26befd5af17224ed34962827367e81937def6892f09808505cc1457489fa4d2d7b6a663c7f08621da2f5bbaeded09bb72f82a13f7a3711c0d5526f930ba77ad048f6943b2876495212efb7db92b3f83eb91d5c6f37907a7b5a1ea5bcd92176501454000e8ae84fb60bbe82be47ae8e729a62fe983754fd2723d9b91a90ed72a7b593b98c38778b66ec8db3a1d553c88a1a713d4ecf446d3cc19c30262a072d4f06d7eedd628395e6bc3b2f2815599a0d623cfab039ccd604dea33ba50b2dcadaff4a6e7500074da5936bf4e316eba03c499b2a84dd280a0b40dca0a9e65855dfe38d3bbf63ddd44e36266ad95e3da68e1e4a7e89b0970d282ad351f9bedd1991e12648e2219412a0561dee44ba1b1b14526e7fb6c1d7efe589f4fef04ec49f1b4491b896af88a9c74eedbbb9e0851ce928a524c161577fa2dd9ca4759cb2ec679bb968221754a2dbf909c53716c9457ba9158e9c9263a4ede91879ec1c607cae1fb3fb99b3fbc8a2c615c72b172c804885e5bc08e537b9623f99bb527c71582d021eaf0cb0c96e967bff2f599d515d504b57a9c40e4669b53eeebaad9feeadb9f2acff21e35010dd27b945d39d5e189b6ab570568d397c3a663c6d71e7af19da7bd05691a12c78fc64cb3c0f92d5fed22b217e020c83bceb83ae8e3312762b9fb1d435484247c49b71b03ab6e5daa75c7a17944f3108420e35ab633b836459c2046005c7431c7ef2c1130a6f57073e9dd555eafe11481e3a8ca978b83ba4a843fb75c98a4aaf0d06310e3f1090889343024256a4ae962dc30da534882eaf869dfae9f32d30dd0eba11b6f9eb24e3228cb922aab8dfb6a24e6cb0fa68c5b60204bc9a5bba41d3c6ae2a866512ef629c8bebdb4acfb504f302cf09a36be439bda2d75f2f7fcfa6854f790b5bd8cdac11a4c99babbe8c99c48fcccb685b6c51be0b3410fb7647baa54c87079d5b87fa57f872b88a526aef31ae28db24cd9b657dba7598787cdf005c412eb11031b4ea809040dee4691e6de87dc65cf1be21f7f1dd318711fb77b41b8005a4fac4e001babe4e33923119f274bb783f8a795aca266222ef549aa6000bbb1d4d7dcd3a04656933d2caac37df755359dd05d97585e6e4a766e8e7291b672fb5582e08612487cf9b3515c53b96075a1c62d5992302ccdab4a537d30a6538baf5b1a94a1c6da0112a07f9c9799a8b1d693cdb0863325ce7e6bc394f21a32e085bab2776e76bc626469203a49d2f29788f6ed49a2aa4c16f71b60d28a7ca396f305ac115c9df607467e900a755bae696875cc2c9bf683d56461be7296017c8d27e8af7079e7f8a5fa5e6b3a857e87ca2ac8c1208af9614a00928677a04538b6c529af666f855b16eeddb901dc4f2cb81de918b6d84d3255090110d6d22aa09a6bd0139ab274e5ff9f133d34456cbb9494ea299b822c47d8a6bc09df5aed54816a8d544cb7eab36479b1e122b40e4844cff4978afc7567ee0b531d2dcf1f2831c254a3f395d208cdc2af2231783230ee36e7db2e6b554df1f2ede945d0bc8de56d39b3fe3554fad7e08c9567824c47403e0600a93f927853c8bd5dc3bdd416b4caff7c6f2d4c518e28d6a32d214e8c68fb86a7920d0d2a1267b926a3cb590400de0b242ffa4c8cbe96d270176eda8d345dc593253accf75945846e5cac3532ae862e3e7806356c8463812e4b38b4996542c3d269e3172315cbb438c5e983349045c1fb91d31798a0fd38a1f6a89d46b5fa6873321e69abe8eb73b805551aed44956fe9d0eae1cc5a9052289386d5eee3eb893c134eecf1b30b2ab47257fbe977c84d4d5d3dab5e463f279a64684ae69e6b6b17e069dd2d623830d08267924e8979a9f333ec551b09bdfff49191b509a7ef7b6617d46824099b64163f0563e96256027da85b01e29f38a8cfa8b8c68121d05b922c6bf4edfef9e49a49bfc5c3693bc6f26fd1a297cbd9555af9402f9d38c7bdefbe1ae69453da6847710d8cf65a2f6379a7a8040e0dec460fe6c4a99ac0bd0673e7c7c6b17a0bd5fb5a4e0858db34534a2138cb8364918cc1280e99386d3db1fdbecfbb2bb6ea44f2edba0ac71098ccbdb443b41d6f4eae00d81f56e94b47f436866e3415e2e8bc783f934a88c3920347dccd0368508561e69b1ad379002669a154e937feec64fa1146326b0e170d85a43a159777721bbd6075ccd3c5024c142ba89d16b918a8261f94f376bc384369ccea96f7febe55e25878e0e5e2e6f380b56eb646a93cbe258ce3bb8d811614d6d5cd85b982d005e38d0e80e91a8b40a21682f05934c04c7ec22702113f2f9d81f2038f6f9d5f21309db7677734e4f006b8e31e4170be5c5bf5272ab0715fce0e09e33e07046067c1a8218a5735e388e4b27f87b9dc3c485a38ed6d718d1c0380de9b657441c3e0027e6905a02a46b88a44f5a204f92773e2cc9a7640b9f81121c6d0ea056e08652f143b7c75deb24d73771a95efb99c60f199bef3c7e3b9e98ea6db433bb08e74ecf2e2a57f08fd1d6fc8e85bc86bd8f35b8a4f8ea12d8e0aed40d4397d3552fc5acda7651f678954837a99a2b81b443409ef1f8b564f14e69c01dade2ca6044a4003006677e68f6c7cc6cd819aed40a475956f0342289a170f16603036944218d4adcaf8248be0cf8d9108e8a4882c90c7122156a97fe1c35e47ae59397a53c6075ba60b7086c81cacbe662fed064f6caf16f509fa142ca08bc1bfd20188230800864bb181856e4bc447e48dbadc59b1c25af0401092cdcc06ca69045ae7bb71b1e83554a4d0956738bca1d80d25f90228bc2b4605ae3206316eedc90f240bf0de5b8f5105042b593eb6a9f0ae9b45f398ab590116023a4fb38f7d799e2d0003c683365d6270bf9fd6cb95b408d1771d185053b327a05d130a97b7d775d03826b3d523a09e029ed5330523c8d09dad94157418a7396967ded6f08bb4b9bc938fe9ce785a50a817e9ec9b07a3599d557e03aa062f6400c3f3ce0d838dc43477bc488de27da8ddd9c2a69f349c6ab7502ffe545dacef2a9e4386d76ca906abfe130860333243b7105ae0dcb3ef4ea8092c5536e08f718481ab4bc565a30fc51b5f076af76dd227d8e79a922aa26fed2c6385af8df0f01470f6479e839c7107e75734f1a01b1f097f5fa02c0c6087072b3c1d992eab098a44d7088ebb5a771b3fe960846ab0b90318b19f75faaf6ab4b78524ad51b7989fa1e9670eab303595bbc1983fceb5b85e56aef1d019249886123844a19e75e77d200d7b86e7299d0f39d580fa9737255aeb80b55988a30e4049506dd01c796b3f8ddc655d4423a3742d849f81a32fea3c2240917954d66142f47084f185fc858f13117b25191542fd3dcf7eab6a7d6a5975d0a01441eef1b2e3ff709644337b0f3e2f89bbf07c1411d9821947bf6f943cc24175ceb8ce784b663efe921ada69d002a6d41e987dba3f6a49ba2ea4fcf24e10b4bfe5f4b235511e7da452e5f8290e6bea62793f9f8325cc441ccbdedaad6eb3fdd15a1190751d89b2ac928622dc791ea736a3f128d377764e637aee43cf710333025b3dcdfa2e83653466de87f868e080ea69c5483fd6e9e1ccb9731f9dc678080540d0e35b87e850c32b81d44964b22ccfb53a7eeaeba9bb1fc9235a6f7249d24e28135ea0278cb9d6b49628ef4d3150d0bc418702abafc22ae1acb160c6a208ca31357afe9d13b47d64cb7d09da68b1e0c04522eb75477974d9f7979dd59e57cd9c4483b2781f6e3e47c2db3ad9cc53fdcb66564c23ab4ceca5df35e575704735d37a5fa5d8169c7ece724f53a6de0f29ccd88c7f9da313c12c483edadb772fe9cca75d8abd2da3e9b7aedae4a6b11f07d1aa57443b198ddb038de6ccc1621b0c4ed5973ffb2a25e6e85f965f5f78d1806fc36171c55049e050b5e552381f4e130410c8fa2a971d0951c0478a02538ff423a8f057d28d9e099ee072ed8d35fc3bc85cd0cd39c3395524e2aa209c5ac57007d4a7cc7359eeb6ea886b984fea187db8ade74180c55e76b11935de7f9eec3bf767400054d8cbcc3f75fc46998ee3b5e94b8554d83073347707301786457c2a63b2cff8e821e3a7670abd521147d8c0a7723cd19dd8db7e01d60ceb46d2298f1be698e57d6417d4e4ead424d439bf2c54e05e5fd2ac910ba16a2bd5724f3edc676c63f0af4c93c9d328f48749a2b60b44c635a3e3bdcb32f91572cc8b6f245007e5c4cb51efbb914140c3f65f8cc7578fc327cd8c0787d6cafbaed8f610377ce6f1ced5d0684f32dacc65d042ced4027d6b02d426bb75505eebfa67f554b2148f5e5e00aac02b130f7a56a1dc5879ff5c0e48f9a9393e811ad43c16638301e0df7e2b450bc6338096a74a8672d23c8e98fdb5f69187de2fdf2935651038a9daa84acde7349f1bb75d90911031c81306a89e9b73887aa88456ee15d40343a5d99f4186f959cabb614249bc30a48c51eb9daa37cc93c3c4feabb5b7818093e642ea02bd9e976b7b4ad43e1cd248030518572b5ead44c078bcc226230c6e518905df5a9862bd78dc1205a5cedd956c7da880a4385823c06011e601c1b77143d17337094645d71f9c332535dcdb2c4d434405b7284be61ec735e694416d6b2204bae5f0a27e8e8f70e256e731177e2b6a9577ef5b5f31415c144b40ef70107044abf9c8c7dd2b99c0778d077aa5456fcd22030ab08aace30dbcbb7077fcd7113dbc529c4d1ddfd3d88970adfacacbe52cf162507befd210f60e8c4ad778044fae222bc07eb414c8cfaf7c8924441cfd289862acccb9c1d73cf38994528bc43a720e2b533d5ffd5d71ffe72c62b271e290af754e876ad417a1ec98da975c8fc566a66e361d54d13c07921f719420bae6289c0130ed0167cdf9abcc395dae8eaa2df7eef39a6122ec22044ee8b923f16d32b0318ceafc8295f845550851aee854a08abfe15944a16f4a060e72c005ee8d4f3507a35cd84424daf5f5a3e9de9fce2590b08ae39833c324530a84f0987099a3e890a181ba9ccadf34a3d20bb61d9f7118d1619ea450fb399d63454a42f886833a4622435f5810ead93ba56ade012132140c87eec760f5b8e84454410cfd9376402983046b12aa9dca78926c8b63fed661b4f0e8b3b3b8a89b546f8c505904f1a17f1caf672994f22e4e31959821ee4e2aa17691b70d3470561cc1e65f58ad6548fa7cad3b6618e205f29992be7fc69046b250beb47519eea94de9f289cf3e4cf69a5aa7feeede4794142116bf9a8982f6b284dc648d5e04ff04205eab88e2abd0fd25b5c40c58d56cc791624fe86d5d8bd45b2072760a4145cb7d3ec338e7eb4e0cd3b28d7f15fe4db9f818cb289e5ec7054ba8d217fd8cbd3179ec4fc2cb653e54e778ecc3c2eadcc1f63f9abf3d51a6a2b112df155f2da054a74f3396fc1c05e79785da0d4b8fd56fb9826ab93031d75c54a5551f0dfbeae7df65cce3c32047ad3b30a1bff71331c8a6f1c1dce8cfc6b2b2b12fe38b1e8836e99c09d25d3f934da622ef4ec964ad44da5216e29eea1df5dc7ac366d320f9015bfd34c3231b9d5d9f3819b91018ab96bafb730906e578afce1f88ea42552b1901fed598d9d7dd52c32b7a89a4b4dac0ded646963c81ea7de0b822ae66cf9c818bab84a11b2172fa8c31ea0215aacbf65a2d12532a8a2310535c253b8520897705e887f7e03aa6daa0f24a8500ef152a7031ebf17a39024ecb9db11670ccf01fdc974b44f36d97cb7065f21d302f35cbb5a1ea4cb829082f3b9c2b7cbabab4c2c72894a05b072cdce0a509d601dd1ef58141ca8379b5a4233faed29df7a4d87ac375d2efd23c6ffb284868fab88d29c2084c06e86c4cddd20ed9aa0b3ca7f1e1c3e8d47d7338bb370c1252bfe20bba666d8916aa7915004a0e09ff496124c8bae7a6b5678dcba5e8eea4a4a2a75ff6abce832ad547e39d7e81205d00eff83b75d5b5d7675408fd10e541631ed4e7e2e8e4eb81bba8197f930b1b76d96bba7ce07e3b9cbe99ea981eef33a5088ea762fea35a0ea7c224546b85e38350f7dd60d1c01282cb5d47ddf369fc5289b09734417496137a7a3c6fc3109e80b40f7648677d55488f6a1ea3d0189b5cb79552f5e9973bd295b9c3743b49c717047781bce55d6e717d2093c7611a0dced03e632540bf0e5573755722fab2eaae41ac31a8576cf4fd7931065bddc688d1b0de3430ef4e7e1204b0ef6d6863dd057eff3c5c682c818ad9b3affa2449fedce3e578cd327310c982acfa699cc59b7a6ce8c82abd57e45aa3ffdedd0b837d0fecbca62e8d6e4e8b903b5be7780cca0275d2d1bf15c58b15a44798303a754a8ebbc125936d5160d09e30640c5b2e9108498c2fa393435e4f47329537f9eb87233501ac4f6bf671dd035677726135297b8819dcbda6d05a99e09e7dfcef369c83c5b035575cf2d7765faf43640d91708ef3098c156ba55c95bcbd8e83e85c794d8f50407444ababb6579541bfd6120d83c1b0850f8b5c0d3f42faa7cc6dfb90fea0bb56790635816a5d4b26aba08e97597fe2a805cca54ebb7419710fa418a07ea15bb57745892a129502de6044be3b520c17222c84017d2858408f7ed94401b6b74ebdd3c184b043fe2afde8ce389087ce967812609106c91f5660e2c50f8eaeceb398317d32a652be3c8c8fbdda2c9e3a4e8666e1401ad0ed468de3ead63a691735b24ad159990902e3e4283e33b40dafdd4abd2478138fb56f55c3b755a613e0cc27ccccbea178213119abe161a9f006ca2836baed5bdf8248a292a5e9c41685b9e373ec34dc7dc9ad8fa9b6c6a4abea1503e6b09eb4243d956669af6419c1ad444b54404e1f9a539f632f50b8aa0dc06fab4a73c35baa2aa2c8fa5590b81466dff1c24df199c9fbad7a899a3a43bf677ad3a80849405cfda43bdf9d271142208014d5080b12ef0c61227b34e45d6223ef91c6d4af69fbee78f7834fd9acaa77d5b75f2ef89c4139f8da0c54d5a316309acc435597761d99d624e6e3dab86ba89136e947eef801aa0c34dd86f3566ff21d50cd68fe4a1ad02b4964dafc390ccd76b606bc8a0489dc1b1f0230b51ba6524889aa87c7c98f91ed7039fee01940b1b5bd6fd124204d834f976cc205e6d875e20ec6414c77c1a2f525b958890a3061b676a518653c9320b738817abf81cd599399ce9268f46944a90916f3cb2e8392dc839e77d968ec76787f91627caa8166ec5733fcb96553951e1e9f213f8e89a9f00c2fa554025eb8299ac2e02e9d0e76de7941de8db642ac23bd406297675232f30b93b5a46511ac0ac236ffb77de853c85085c2637c7f0deb1a85450d1168b82e64b60103b0143bb1dd13c3408c02fba8a9e888c51f16f3da4e4ce3affa9ecfbcc3d7bcfa18764ac28606da83bda4ab9b1cc76a57bca18cf23d0fe8b6feafe45d8ab1012c7942fe2962ae0d628933399224866c5f130c77f56a43fceba103b89d156d61236c9c65447b3415e056feb6409185b155571c52734fdea7440879a39490938d6abfabcad3489449c1659bd1d65680cd3b9dfcd58fdd653dc092ea1dcbe7b95f75804d8e1532b04ce3eb0deb4594a5e2d5a7fea2772078cfb76280563aa1630cd590653e7e1a3af005736df95a3676b9e4a13d466c3f6ded702fc6c9b6adb32c505276ed087eeb01f6f8c8050b5dd720ef2165052fb57edaeda35633def4101856e5da3d71a1d46ab3519e3aacb6d1ec35ccf443c53f8e1cb00b27ab33ff4c026a94417f6f0042f14fc8c5e429aeeee3a6b9ea4f970db4c64fc5e3d087e83096c551ab973210a376e7e733f519d078ead6dc665ebf29e55294813f55a9ec8b9d99a212abec2edc700845547848d0a0386411aab4dd96e154befabe0970b271fdccdc9c18c48f57b89b282d29f44f364edbccbb93bbfda365adcc275779b77f38d4eaee7979f36bab4089b4b45e28adb22f8b369fe355b9fd4e34201be096bd4f9c0212d08f722bc6991b362ecfa4d638143e78428e050cec574b3346fd01ff3e07fcf6643f70bfaca9bb3c58cdf03ce5e403f9a1efc44d0e808356ad1d2ded891744b0bc98a8b32fe969016b83423b1a2e545e60ca4c891467f9102670614f3fd2695eee11a817e1c886496c7951e71c8c818674543cdf7fce5356d1ac0cae5aeffa180f3505bc0e0f599ae1ec0e469ada2ad332f3b7720ac532ea1909fa16290bf55dd2aa11da352da18cb64889b65b1968d88adc295b4357d79bd23b0add0e0e03929e8dcba0a117af4e67e3e16231489bd4fa6a6416c4b356f7c78555feb2c7cb59c9c49b5d8f799bdf529a93dee33b240f39667520461d9c5279cad4c9400006583be9bc3a3caac7baf66baef6de7e2b17ae62ae9da43eeaa6d261563e9b20e6fb4360ea77b76aa17a163d6f45ce37bb1469668a1a0975019f65ff84bd002b58e57a6021c6bd82574cb30407ebc67d1072be660ab930c598ad0abec1f63fdc2c54cc5402e4de679a6da18c0766bc37bc25a45b1b888b615971fa3918714c1db2f87a49d2d42ae1b67c7bf223be61a1079f4ac47896523f8a20d5dc541b7d3116ab3dc87bcdb6bd6222fbf0b684f639888626c3cebe6d475528d12026ae7f114b5b8dfaec6a96c5d8acd814f4d4dff7ad38bb165103a95f11732c4b7d12ab88ff9f0ec991a5d371a9b2a597e15419e529fac6d6d85c29c7d72b62af195e2fdd91bc765ad2e7d39c783340f5cf11e20b6de6c08340d3113947d7409a764582aec34b1bf3e8a4d6ed655306235aef2a9c58c7c6bacbcafe76598cf66e71640c7b7c129a5cdcd5629976b3b4d141b4c5fce2d749c5ea2532eb54ea36e80fb678a6209e83c379cb43d98a5c82143ed6a644ef5f95c2bcb4a438e7820040803673a26f3e0522b7402b55dfb1cfbfae9f597400eb9e623564b943e600e63ebf726fe45362c32fce88d8fdc7b2e79619a73e5419fe9bf95806c362bd4fc7c56080647df2eb40d01905b853279483d72f54302376d0facca4a4ddffda40a0fb123762e39137f1ddba50773d9b92600d8a67dccd452bd7a25f5c6ee5bdf8c6118d4e80f40ddef197c9ca8b14f89da29cbcbad8b6777d78a2ead62df2971c4975aede6a155c09c36352ec0a65393c212e08a6a2d071839715a72ac08d37b8d440c6807fbef2bdd16786ba23c1278b67c136e13eb87bef72f8d23b5ec14086b2afc862ca1b1f7ea5a61a6da8ff0981e692c2d5a3a8821ecd40f843001eb87807e6e1472fcacda7a641d45fd54a28dcd87ac2fe22d0ab5aa291b15043353e8a8212c0c5fd62e33f8f0c56df64d14bbe975d2e934bb1cc473b18c63f4020eba8d4e9e971f1e7f5de04fa3e4a111fbfe64c3fb3771f15b67afa903147437b52da65fa276dea162e3c6a67176c7dfbc4fff4f8b4055b59e8ee9629cfba3a83269d98109bbc5b6dfdd081fa5cd0dbf41da2324c8b73290a09102bbd14001a128b0b422b394456fb9eef4950f55baace2e2847f6699d4db22e1a7bc9b439666bc85a48a3bae0d356ccf9e6083f347277dd89bf925bcb9e3c24af858d8e596abc7c2d44da4d10a37188bda4c8de32ace316de173e2d5689c8044dbb285c029f6019e733b6a670f56f0385870664019f8469d8ff3abfe7462176e40ff5e3660a7a6eb1a5ba890f936cbddf58cfc02aa1d82389072591f1562ba82b7226d27261ad29d79a6e28d1a470c62eea2d4dd7f2ed3abb1dd4b0ebba7fe47934ef3c32bd66e243330aafc681a922f0ccf5a54ecba3f17169efefd5e5a1e3331fe97d730b90bd0b2c4eeb6941bd115de0da65fcbddac5bde2202d6a042f15c69caca6351be5e9608a0edaecc70025b1963d3a9442866d6039614c8b43dafed65852a79e4bd12c5e12c9381517bc616cc54d67d7ca9ed31b347929f982b59db747972b2a2ccb3d2db948e93e2e957e8aaa6c101fd3ea38de160a63f985d887c9309323683543c32f1be5855a8ac4322378ce057ea72040ca356aaf5a6e1a7ea109d93db8175880178ef48a4897c0d1aeaaac0a6188725819eef13e21ff472d12a6487837ebd394e31cd00eade861bf96ba39d991b76e65d00f8c70627cbac6247751666772dfae42ec0a93b62a212eb4e4e7d98c361e85979e83f8b0223490bfc6ee2c7fa5e57b4d621ec1268958d3b314acc52bb06d487a77a349d4dbc2e5f005aebe78d9426a6bd1d3539504beb123d94553c11c005edc2f4f79ff5c51cd7db221c7c9d28d2710d81436903830c4381388f9ad994372f66fbc4ffc3f402d172bf0553c4c413fbf5a0fcf9e86e317826a2c2c8c7873bff5fd56b11ae93caa16a8cbe54c12ae138c3ebd17103a3e5cdbfb3b529adc78eba704172b088c52d93d71a5920ec744719d080cae362cc3e6e508558d06c1436c2990b626b24573957cb83ed8b3d5ae5a632ac378c65f4ca0b919e268b9e8a2d83975083bb9920e065cada09907a8626287b9d4a3e21d7203e25da480ba74745fcf0d5d2f447d03cc4c5f51aed4deeb23617c678ad3cac86344f462a50d7528842d6bb7fb4725b30945552ecba2c451fa54a3020f3ccc0c16656d3df16d9856bb8b1b31cda4fd78a2495b0b1cb5a3dbd5a56696f17ebff625d9b5b88ed805ef98407f1a884e5e6fbbb2c16508f1bb1df437beb5e1ef10f44a818f06953f6178cedf2c1058e65bae69ed07a99c4ed44842eafcfb1c5703bba03177e27ea2216714828c809c78199856bec6530eea1ffe4ccf1f332b9a8c1daf7b72b07fa3880e0a67d3a1796e1bb32ca63b27bb66818e23a716f4a44815d072d5269701d013375fb1bbed8df51a15375e4160fee614ec70a03ce5913e157c6005c5f5a9aaeb0f7669abada806a26a1a2b87f4bbbc9c71ab88d93101bbea3b18aaf7ac932a4dd0957b81d48ca7c6d506d5a3a96f1768f31e1cd176afa1763874ca7295fb1e9d1663dd6fbfc3df79f4ce52d5bab2422a00f8c9d85a3b972a32cea998e9151b0b1933e756cd9dc91b1d1f56182fcbc8caa60342e11f520eccc5505184f6185f75bbc696773a48a2839c71151ef4e7c89b5b26145bb6752bba9722f2bbacf53a196e87c017f834a761984843d3a71a38373451d8e6e22fdf84c11c8ea6245b01b7a4c32075049374490eb786c9ae5112500569c2aca22ddfc1c205ab9637f9e23ee7e04bc4488be9dd508fb9ff0b6bbda0ecdfc2806a9b08803a38e164fc971b29e73aa52c5df1acef15c0ffa723733f54e8e86dc3b8c0143dad3664b5bd912806e799415c18730cd1ce5d82df6e6293e5675b4e9994043a947daa7b2f143e505365de1cea7be4ee75f5708bafe54ea0b2b95ad0f14d7ba118b9f09db5c2278397f3755f50ccbeadd1eafa8be65970b2300c03fa1ccaff895970b1cd8df9981c69bdd2dcdd5a838faa7ea96391209053a9c2ab291b5ddf5b44dc681e4c7e93f0e57bbdf6abf54eb68f8074c8853ac3ffbed520d0aed04bf63587e29f16ceafa1d013a50acdda8f361f7d4f38b52bddf47e37d9359aaa51baed4abea7ad3fb62e041a6ac931b3e1cece70aa39c1a72b2f712c782f4616c9244b47d798af242f73502d3d72e347bdb892c9c54b00a361b99174005e318b9cc7c11218e3c8d73685fc770c45757156ab7776ca3b0f144b6bbc2f7166bbd236525ced99ef62b544279cdf82e956c54d5cd29e82c27f8813d211c53318c8885cd0338b3966b7e466fc0b0647c0eebf8f0803228dc04145024a3aa7bbf10a032809073887c2b35a9b2ea877bbd454bca0f833f293ef607cd5bd253e31aa54c58c2b2a78d5d1edf10a25f98b654156ccaa332b9061f6aec4b7b5b3578341035ebc84449c99aefd5e64f3e6100b1e0475458e5d9faa131ecedf0626e4e228ad6a2d9363eec5b7df2df8d38dc5f466e15e6a6512c25c0f18299faf3ddafbb8760ab8d8f40adf59fbfb4b04e477da94b9385780076e42c57170523bcc9e055a280de866168936a1e7a1133f4350b2607d42f8e07ab21e3a2e4d9d004e4ae7911d38af11e5eb9022cc3d1cc78fc2f036b37697e5fa1808cbbcb1cb05f63c8d38806da9464fc8417715cf1eee94fe609bf15d8f34481d4d9cdd76df9e9f41258dd2d488716b6c0a73f0f3cf1319514dcc8eb58aeed593fbe3a404c246c2083919df8ccc95fec18d2239b85b41df542d1a6b3e51449e49e210f35abb01b5907d013e10ca7936a8c80e8cd34d0f17aa172c9c9800c7e4d0e0c6956585d12c741ded8e59411a056cc123c0d7d1f981d5d0acce9daed432f4d1514e48fb615f4c298c3a9423193c90136110d66d41b42c204d11e23a43751bf474b8bcdc9f2aa561909be2dd9b997d387482e9ed648f0e09c4c6aefa97fbe928663e4922b3ad21b8333ecb058be5991f10155d78ca58fb374bec42ababb5fea37829e1f6be70f2e03df879e191025b5d79f35d921cf8ccb726d0cbf3a8f67ca7e95699a9f257e2c7013a0126e510c7041384dbdbb4cce857223ca31d4b58a4a2221f33efeb10a1cf2fd73f9064b767b662703070dcfa7a986636b0c9efc5691565e8643ced224709ce5f6503798002827194246387fdc06b837fedbcebb4e3ff37b0085b7fcd5f085c36318a4afe7cbac14bb87c9e8a98f417cd0ec9427dc68945882548c1164f9c4a4561987553a0105da666a653bc25711618cc43d6f5c47db92112ac73145292b19d7ecf880455168a1de9ccd71c4c0b06c0cbb2d383060098c02263d2b931f367da51ca4a25afb538e5ab1389baf68172106ec3ca120104d0527694f1b232dbd40f23834abb693166faaf588bf7cea836b51178b7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
