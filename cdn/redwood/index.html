<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab314c8ecfd8db33eb11855e8acd8a849211b4ab770d8f1c7c28c28b2ce2849f4106afdcfa3a54c364f96f616e55abe82a877e161a36015a8cf2b72295414fe8f54bc04e1c46e215d053d6180919b44ce139b4d6e00dee34d184c0919f9d5e59754c997268920fbc81a6a4ba3c6beb858785cef71ee91b9789cdbaf4ab3fd22bdbec29e3b2d2c5c616f206d23815507b47dc7391099e54dead1c702aa4127e33dd6d5c15ed95d398512bfb71561f3543b56908c585cd1c7c55f4d1dc7ff4b46d3384955d5b7acbb5956d7f00c9cce290fd6a59effd5fc89af44ad8be4d40212daf7567183aec79e0ce6fc10e4a3c1bbf8ba4cc94237fb7d94752bc58459119d4723f74ef47642b0d787628c6caa42a9e452f62a07a6d6c071614de73007ad06881cb5b85647b81ace186ed94a250f104a7413d2ed5f9c62aaa7a1695e43e8261a661a77674baf173351b0f893797d4834ae4c2fdca9b51f74258171f2a2c4f9876aadc7a255ba8ae6902253834a543c0513a5fdd361177d5ae79d035e5e67e109fe6a650b93920ed85ac28ab84117b3253dcbfe2a6c325eddac0549ea22f3db105802e681dd2afe4fc845428748da2845a1f07d3a8fea9672f21ab995dbb3b8617e96c13819ec2d35dcea7b44b42292473c11bd75812f55672188480e361db80ba152722757ada9e2defe49ea585b5fcabb931f73f68b48678b69f231d603028b0996130b1b8cf27f80f4171a9c2811532c643a632ee8aa97e83afc4392dd76002554e5348b1c104f9afd4fcf5cb698a63a4dd9897d9354a3d25523f670a46f9fdf07bee2b24aef8e65a3a6530d93ff3bc36c8a8447bd90d010879b3511560c3eed8e5f464bc16f3e72adf3a18d702691029e81fa6dd9700dcaef6b64fce38a9efb45a1dd278f9677bd31e0c81b939cf7995822c9c99f94a2d165bcce4740f0d6aa0db20874c00f0db3b62065209afed670f13999328a6a225aded4980d95c3c225dd6c10510d8f699218dc8ea25198d2df63580260c03be0b088062ce8f7755c48227e149b5701c1f5a2889be8dae125c134900dcf1ea15578ab49c192e329eb3b732a97651bff1b0f856967f8c86866f5739e7c1b396db48af003eb3e7ceb7b80d9ca1dc775c939c7b39e3ae794233ebe87ad364e710b0399c9d2332121ec3776481104bfb0195219d157e6fefd0237bd57898a0bf7a02ce61855ccf167c7c13510610791b914d69f5671cb71f933a37e905e5f0be0523b0fa424ba6399c059ea7b63f519532f3099c7ef06cc34b76f139bda873d5a691c8683ffd443e13a350de00c7efcd5c4deb82d9c549ef9156327f9bce941899d2eeff80628508bc663f4ead7344dc41c6093da75158cce0ba5fa2b382cea9e631763d1bfa23dd612a773196c9334c134f2f596b647ac5700d91da940488e24031b631e840777d79153106aaf66137ae46f3b538a8d40ddc377836addb8cbb0f4cf3c37338af1c4fe0b90e094d267cb8b0bcbca2881c6dc1e412092949cc54258f17eb101008a434bd16c6a5fc5004074ebb252eed8ac2879ede5282ff148cbcfbfbf58aeda0d03ef9abb191bbc385b3d742b1b3cf405db20baea33cb6843891c69f6e9bafe79ab203c4dada0a5e9cdcf48f280336e520b6c1ce38828e618d0b0beccf31ebee63dbd83816967cbf0e9245d3fdd1c861136af4516a1a49497e9e0bf0c1f3364419bb2fe4e2053af141c21e68b38a1a7fb6098a756ff1b4cd42691f5029dd746e339c216c435bb297cd6a95b212df864d30cf8066d92c8ecac361ea1ed61b329f11592a9998817377d1df76a49c77985c4d990338311091b7c362b27dcfba2c913fa36e167d34781662e31a21e6280480301fdf5c0001ce8af295f8ba7b24ba8e8551abcc799ef866bb7d45677bcc4f2805ce39ad9acea16856f9d7d479736183f701ff3c734fe81408353ffddc314c9f019d0754d7c78fd97be778ead1d8662f52509afd45cb4ae1f102d8c55337192bfe9bfcb30452e88c41f28a972c7f670eea052c9ad52415588dccc710e68cccfff14addb798d8ba02af6169a6b611e7469fe6a78cfb472a99175c0aa66698c2185980c16b666303e78d841510516bba84fcf44f5cac5c25d22ab3bd97da8fa66d229aa1fc1b4b20f0a3baf2cf20749c4a951cab484c46ad651ed07f77b3edcc5c249d1870bf30d7175f1eac1e8e49b7e9bde64316dcc0e30bd1f5c1da949f7c65b5ce15d4a74d96b6b5726fc350d60a5c08efe388dbf8f1d68d41b30f697d4e94bc877840d1c30c4c117d5b428e5d83bc686825ac594e65e0d1056a53ef39882f7cf027f543693eb2c103917272c04c0e1167af2f84cd8408411a05ebe8b65b89d85c870b11b40d320cbe13c770da8e272c1ac29a637dc2e147c0f61cc24ab5bac2e9b1dc01c0a48188b6e6b8f459872acb01f617bf37a6fa2e34e6e83a9e54bbd35701390316e28ffd410e9e4539ed9d1313d8754b21edf07419830747ac07c936427bcba271de725615c0b55326e3ef5c4751e1b38fd09bfa09947ee00cb337b37dbc63738741140e76e323a4f3151266658c979b26e7f0bc45465f4acfc2caf90202d386a688b63ae71b05a94582b53223892621ea48c65485288e6c0d14c2dbb2ce0784f5ec49368917f981603de3fb9665aed361edbf302c1dee8e6a9f6595d4d425674931a7bec6b897635e688de1bc9e73331bc9770d8cbee8baadef12487e8bbbc16875852bc965c556e5a84109825c330b6e6670bc791bdc432432f0c85be7a75b5c3fa0989d9da37e1c9cb510f049a8867428f6e8e0fc172c8ffc72c08fcd93f8972f56fc019871cbc08028038e152f4c3bc151b8f51a334b5fb423af5c48bd1cf3a9092aa3c1ca8f6cd26ef76cabaa0db93f07e0e2728fa286c25fa982c50c8346fc1697fefc52d8fef9e50057dfc986a04325daf1c92abdad50d83446456749068cf5655271cf6e80434f8fa52057fc144298b925e5d210b4d00604b680597786b95eafa3a1d390ec00ec531220ec06a84f852e4915e60a300f61dd52699c2f563910f56b96f98bb86b87627434bffe6749fe60b0235d4cdbf01578939e9a414f3e56664cc173b2deb757dc70c65caf4fa63ab19bc0ea400304184e895e8445af9414fb2fdd147dbdb2a2c5877296fabfdb3dc24fac5ddb007561e8052ddc76e309ac2fbcdb6a0e54baa2bb7708e460126d647034d15825772b2290c1f8f6bcc78cede3237a1582567393c65bcfcd92edfa04cc78a3f973659b2802d127c3ada653f614df5da0f75be4af739dae19132490033c4d7a7e348813924b6e7987f62b0278fee2ee6aab04cccc2dacd32f47f4770ac21b95c0b8a4ea3a7cfb951f223732bc50c6bb36b50dcd8ce5456053747bb5b2a67569019f32936151f4ecee7e801d6ab2cfe4b52e9aefe9765108c92eb16175b47deae905a2ab8ae544f5ab2a93602e037d9a1cca9513c61df81639e9de8c7009843b74b01f4ddc765b9eff0954a24efd6a7e4dffdeeb0e1e026a27e3e4c1ad9ddf07bb91d5d4cb70b253d17bbdf826bda37772b789de5e49394639f56a7b720d36d58a4c1f55173f32888fda0a2db6f22aba730a923b9eac8a82375f1238490dae96b0b1e3d754c556479753d037a3c46ff840c1fc54c81c93f109dbbec75bb98007c5a2051f2c2d8e72750348df985321b07fa8bf9c19d03cbff700e6f0b2ff102acd830b06f9e72c5315d995e0ab24a8c6dd2cedf6d264bb99380fe5d6f871a24686c2f8c098f308f542b0ac08dc8dde01fa453c52b50cb381c0f1e1e22a0d9c3276c84ae94d56b851ef21f3a60b19973897f418f6dd15811ee98362aa98de2177d9039b2bef415a6662bcd31f9f9b31a31388b0511f552589a1e270e2d57d380610a2e0c0d33b276dffc9a29ced6398dd238526cfa37f9d5dbb4df9ee2fc02fbe68dd24c78dd16060ba6cc242618d3b3eb57e25788b2e64c68447b2d73acd25cf0011402a28655db46d6e976a451ee27e10695c8ab85564ae14c34ff04d3bbf651c07a25df806ffc42882a00eda6025ca5dd19e5df8c2ce05ba68a366664eb7602d7c125809dbf983beca1bc8ecdd9af8bf28b8e15128b5d231ae9914cd5a1977a07a4aad7b686f565008e90031a81479cad53247c6bba2b3b5b0b6ce9f28dd2a0f34548ab4f4d7aa2c4d286d6f1215cad9095d7c8de4bf6bb82d91b89023b406822c93de9d5dcb966998d1a44c7e2dd317175844b2afa3c422f982db99562ce8e9be9895a16d90f245e0c2f7184ca985ea2334b2dee42748a29a55e7a4e2b696cfcf1bbe30b360330b8238e6e00e07c6c566ab3e541727fa1ab20d55d1f237d1307287c43575e8343f2919370b61b564d417909af9e249b60f4ec6b7577aa095ed1f7ec52d5b1a7e5cd22b80afc84e656d6e4739b34745fd41201ddb477c137a96bb3fb70d5923f5c04c993a642b0d2caff78e2c407aead15a34576ae861ff82b9d77bc4d9a96fadd283f112e969b89de2de764ccecdcede7c2911930a5000d905e4b90679a659454f7cea17937eb28156b32554074edbb331fbc828459a2883c49e4d954afc54c68d5886b8bf403465be1b7d290bb67db857a10d47d7f380ddfa0079289426099098fc3ed8fc67d0a1ecd6962e4b67d122a5c62680dc71aca426f1d0f53174a1c5b33488a905660e52d43195d6e2965dba0eb38827fe05b0be1c3dac899bcc77769aeb26da1f09dc0324d7eb48200a2106b88b1cd39e25b0fc814e6c9a8b4b793b1cb3133da897ab27eb88bfa8f789400c2fafc3ec521ab1875253b164519916b7b6bf4c7962f15be70c8221c931e622f9d54137c8ad6d8f37d9f84af23470704827ec90e78a4b6c941546cae6e80070b9c3094be0d6d4ad0d1c6a9d19f388c674a1c8a35be59663365a0c1e5394cbb53b84cf5876b4e496f17bb49cf55156b5b1f05cc145ada0aa2a69c9057756f38176388e05ee8ff11a573f7956bc01f7ab54fd0a11e936d5b1008b1449743648af1844486c07f21e6ee040695a4d8b34d5af69d439c0c3d7c54be8e1a1e3a1509c3b93aa2c2724f32d7bf88797b3c0b65a16226ff054be1278fece9811d3885eb3a33ac4e789c43e02a572987a205abc09eaf620cfe71abfea54272d79561ced246a5bf5b99e7e3e291b63763da97f756c50eaebe6fcf5f00067771b62babbf8eae2a7a7c8dd046fa07fbeaa6ac07e213fb78e68c2f79e4c4e550c88d4b3c796afc11df291df6a8462fa07499c785f49f8a1a9507eba91ba001930339d2c5bb9ff2bebe7f1d9515513313f4064cc9b18cb50d0c581980c7d531a4bac15a343f249327a65d4560c67b915745e127585721ab99a0428e3ee6323dc4d0ab69bcdaf785c4fa1c207b17662572692c26499ab1b2bdcffdad66cfe30c3f5db29f97324bcb1baff4d3aee94352ac16b1407bcec21797881dc89fc274d6e5acef5ec37d9aa8cedcf5d171c76c652d8a4f28e44b71caa74c2dfa12f5f00e1d2614571df5a7d1c0fc6554d14c468a350c6c01932aabfcb214b47e27e546fbd8d65d95159c797c89d40f1446918162d8681f0af4e01aee6d6ecef4a543e0160fbcecb42c48f51a39a525cd04bd26db2145df6fb715c6ebbf01169365636c63848921ba87a3e80b8ce7dd0dc5e6aa9be293525c3f1ae26a2e3cac829fdd091efacc3f042eaab2c6f2dee636d7c176017264029dc84859ce82bac14816ea0f8fc9f36f6345fb5e957df88508713e1a0300447febba237c0eb910885854862c91e5e9774b5770d8bd335dc5c0d1c7ba977ea93ce1d27f2da733cd3c7b1ae6886a1a1f357f333ab0e97bb4726471256bdfead68123a8707ba15055bd8280477c36c14e8e76506823a3d078f5480686f8d985a6cbc1521b264d2b11bf8bcc6756393cb3f81d1d4ba9a7cab44ceb33e8e9964ecd90d481f04e9956a7d6ef50ad5d18ce2ab48bda4a9ad0cd7f186ae1ae646a11b52611c2d370341e7f77bbf9953cac74e14e4ca5c3db7a28f87be0ad9d8a1c7d659e576103e34aeaaba129e3a07fafbe06a9218aee76def52a52ce68314ea538e5f02b3deb48fd104ee193b4013738d09020a1d692e96f1107480b203b3541f1703115b781faba2b39cbc0158d91b45f95bc170bd8400b0e4e796a1e13ade49ce0d72a044b5b09567aafe0995f37a8533463a22f8fc66017730112add892a574ad8c3ce6676a4f0ee3e0fece872d0d7e2d929642e6cff42651309beb1f39283700855baffec93aff8c1c6967c5904128c0d137e61b7b9aed5e6a6b64009e2af11aafbfcd5587e1b21e8b6aecc6cb2d04c62027695a4b19d5c616f04993dd55a459b578d9ab4d3b5e1cfb42cb8df69a0d50c79765612821a7094f41a18a6d940a6ee8ede0a3e55ddb85c091336950b3cde5e7c595dcaae7cd37678c4d910bae5e7ba113796dd5a34a6b4c9ce0c23c68bfab5af78098f02020dd5f67c6a86eaff5d38191167e1c38cfe6984be39c9e779bed176f82a6ceea748b767d27fdf4eb9dc549f3515a11687c62cff1bdb277f0e1068e0cd141e36fce10ee816813a4c08d72c91999cd56e24a086c14bf5045f0da9032837d9449d5bda17dd2fa5805e2fc0f3059d4842c5f6c0ee28447a632d1958340ada75bbfbedb80af3632824116ad5be984e7a20012917301763324a9a9508c47b731adb193a7c8499313fa36bf0e3d0cd2906e87ad12a545f97c674da5a4de51d55953fcb4cb58faa92fa577480b30643e9ac74e5ac2d32a73625c022c3774680b7ef6eb682980aaf3808f68c98c95a9db3d90f49b920ce811740865f11b7440cadfb9fca2adb93b3e97703f3095205fe5d7617b6a2bae59b00b2ec629a24cb65fca8f4c66b35819eae5ced9372c013f0c712dc6147fb615b60754d3916ca0b22dc4a42faab0eb8b44318907aac7491d06b2893d62f78885f2a7d40c64a64ddac9e123c7cd7cae6199e1c252bbfbc637823d8ff28ba56e74b95ce41c6107844a49c20f88963f20868f8c45f90c91af6aac043e9930088823af6b4b0f4dbec5bcfb7a9d62644b3f8d12fe5c17dfff06fd52bcb30d4c5d4115bbef9995e81fcdf4ca6844b4cc71f5ac6ec26eb947880f0ee5e59668a4a4d42130891b64429398dd1caaf998193e3a054c9ac3bad32ef68910d9b7bcc4fd05736daba20ad2029dcf21da6506f1d813508042def96b0aa970a75746d3c621d23f77f0174aaab8a261968bf61b8a661f2b8266dd1b48d18206e752c155fe335fe16aa512a393eae1767f8852a87584cb94ecac000d38fdf53e44abada486c3347ef0f127e06b30d21f4097df08eceb7ef62535bbc006e9fa5acadf3bdaf9d5e23443feec6d0d79de4a59e01dea2d1c30a61798c55b503fe94b062773d600eee303fb2b3dff55e92f46ea3f3759bb4c7514dfb439e3a7d64407f6235452f437c0d716a6752e7840d6880a042129df3e0fb014625fc649ef925324ca40123f62ffac67a700a83c2d9c4599286d242e478ce97251421a806778669d841aadd1e527ab54c41eb9b800583c667a8e2f3382df580aa2b7b78ce5436bcc58b14052beab919f28612ddea997677b19519b8a942194056bc2ac946de45ab25427051de5fb342da2961a6a7343583de43b1cc473a5dcf3bfa0aa0904c0c927d93d23ef4aaeb16f5f61dd3cdf8f8a2981528cd4ca0d835c730a27f956430bb5ea175cc83a139e6b9a9d68b03899b4f21967ff6635446e76af3b645f06b87d082b37cc8684d1eb175fa16d7a30bf2002cbbf1a4a47ab8781ef32b3ddd6e1497ec54fe1fbb32389ca2d2a3bb38767b28f279ee38cf06dbde9a818a45ba9c06d0601873afed1f6bc735562d654515b52a833e984ce43e778119450e009e1daf31e73821a1a5461f3003ad2fb1b08236bf823d33ab507de034a661b045ef6bc32ff1dd76c231640fc90eacbd1a281bd16c06d0580c24951f3c339b09fe180ae441470f26090e071b390f660bf8183be00856b9d9fa8bd9417f21a117cb78082d76d63ff9580caaec275a8e52f51acf325baee63ab83ffae71ca336162c4fda574502d05c61a1b76b3145b6465526b90b693b9989223106684e8455615abc638c9d704706a06712edffc51d6ba68cc7d76def38b3258e27ebc54af2fd37ec3ca21985541551e42e42c862633ab16dde184e702d38bd8c8465d55d45c7ad76975b45fdec4f22d53e1c794b402c00b093f4a2e48e944a8103e6ba1fb61454d41702a68cd6b34fa2d057a50ad2a397101c149eab524575cfb5ea7459218b31865c563c4bf450e72aae87c5a0b0c239e72bb32e5e243082ae38b11ce0f9c0f1ecd9d50fc0c2d5f5e10769857cabcd7fd8128852df7f0ec6ec49794a89ccdcceb20b094843481af3cd723bc9f78d3b9039b65fa7124d3d5c6071162933986ae26cd4d78e03e443bc1fad01f163457b5fd7d611ce88c3f02036e4f0735bfcd68321c797659c76c13e6d6b9b2a52c574278d737a4ea58fcc0067585eaba4c0d100380f9a5293eb1ad210b03715d82404aa29414cc1aefbfc14bf70a56aa5f1cfab94fc4c66e2a7b7ddd24172fc9e235e954569dc47ee80d9f45983567ad0465debea05be4078acf1aadf2c2ed0091d6eb532ef8790c6967e1ddad2c207ffedba3fb2550233c5888cefb3498681e92f88e10c8e9c7da5f944d4bfc8129e82438fe31b22bea8c135753fa2fbabd2a746904786fcea3f444aa0e64c09ae53f6859bdf995b4add40d0f205d4c8ac9024dd1028d9e326e460847e14f4ec74541019f8692bd754b1fe890e9465eaf12feac6539bf30be44493065a02932db1150fbeaa9f69b5f037b5c726a30defbb0663304f370248dbcf8b4c04d9aef643e5c52cf9647341b9bf18c3f6de714eb5c9cd28294c5625dd93f972184e1edcefc727f80fc67221e5638583a44f3aa18bd0eb6acdb77a9790d2141a87eb8e2212a954a76bda810e842a103b5f7d173060f168d0d74cba21294161495ec6680fdc8e6d495520c28ea04481351f82a7fb7d223ba6415166af7c12411b23ffe09e90c1091cb6d77026ddf9d5f515253e99b59ff1c4ff64149f92a911309e3468ecb783b427d5ca9d10b346ab61a11649d3a7bcc760c6bac48104a155886c141788015d3bdac6c53280fbc91a5b36b3522ad77ec79da9d661cae19d6e8a739dd8325685a1ad80f0dd45604ea540947c2e36e9f2d01ca1e67961e24db62a37df1b48f99b5d08344985f9300f4cb7eeb13147c9e64b9fed29d8c468f92b48f8b9f3ebc893443adfd320207ac9dd11c37799ab62e8002ec5b7df4f4aa81d27449d27d77a84ecbc891a219015736c278338b5dfe1b0a71864ee0b5e3562eb6ca17721eed4c5482ddd8282e508453b3add76a020760b6b6c220f34d3e3536e32f8c5f9e2a724ea950cb9d5b57382feb8b8ba492bc362fb0f106b91e15f235e6fe3982571b330367983aa49cd6b438b230155c3580a6e66d40a1b309824f3a08c3e4b502770fedbd038502d991f4bd4d4f8ec2b88451a1c7938a9c182ca2c28c580082a586e18af9cd11240e6a46371145248b820d456d3060786b6064228d73b6fc5451e56a506e60c780f081ea184cc54c6cffa294676cc9737f7b46287bb57332ceae7f1b8e9985d7eb2501ca31d16edbb85b6baf9dc0433716e1bca5cd3a1993a10291e3f998408d9304eb0ed7b11b69c47470db6149962b7195ac58d623641e7f4da2f1b5ec565de05c8d9d8d0232449aba4cb7cb7d61dd3638458bbeba5bd3af5b89db8c3339a1e564ef6362e29a410b1ada29c79c307eaba36864fa7ad7f8124186357f737dbe270a1b8828bf43bad317958d79ebcf7570b41327f80041302350d617bf13d6337429233f7aba83e61b6cf71eb9aafee71eae2526be7c908233476e0e279a3835fe976a7e59c2e47d202f7d8fa7a6fa42e3af7f5532e80be5d42c551c96c0ff23c25509040949b49ce0636cd33aeb47abe1c9a6c5c12b65fefa3b0f96886a7d06e05381a65fb7b1e84810c7009d6b8658ab7b325fc47546dcccee8b8e7d71724f0edce1b1ba17bd47945f332638435b9b36555224f303bd352e637ccc8933f3dbb380729794b69766df05c4bdd7ce6d951e5e56461a7e7603d1ab3ff8f8cbd023dca52ca5f191579feda0ef71762fb0f3d6ca1360553c02181fd8a92e932f991eecebe689b31348323fac2e791f43d2eecda446c3e91a4dab872bda12b53e9fb48c7d04cd4884445306c9467a3d2e4f3568c267ebebfa8a8bfe4fa936da6520077666d6d9e39dc04464eb46408a57b3441ed60f878000bd8ffd7ec2b80bf510f762c50f4d19641cc217694dd17fd654dc049205dff0b89e072a65f53e7f001187259cc99fcf4525f6fea6333e9404123ae560f1b893e23942d7bd3f1a85725ff5a0e87513be098e4eaf175630f9ce48c30beb2a8812cd007827450287d7e7cb52126766c82f27c55c78b42d5ffb8fb2cd4af12d69d10ed9d158a8cd661b92ab75e94fa7ebf22ed42b19960b4e1e8d4ed3c859a464817cb6e6dbea1ee7d28d5cd38aa7fbec3554d68ffd7d4a5404c883a8560d473a726db847ad7bd3525c39398bafacddd75037a1c044188d930d33312d689d6c5fccae29b741166190bfec316238da87b80b3789eefc057638b0237fcbaf4163a2e63bea82d82792bbb18d1075382b423d1415e2b5253ac1306125d502bc59ba03a7a86c47b6238fb106da96916f1f5319f071464ca239cbf92aa752012bfa66714fc20d9ff8e242b62badde6ed2e3b3dc919463fd0123ba7f8c6a4030d854140d66c627372f5cd58af9aba249c6b1f7c6e0679e8f46e929086b388aec092ada9906f85e53392ac645468d9c0857b6945df39da73bda0c1f16ee417e5249fac9700c3d82e7326c7536fcda49177baaa47f4128c3abf691caa76b7431ed2b718933d5aa3d49d0f89f0cf1c5764544b904392793fc6cf56c6506feb50fbb4230f47716d80024b3e7ae26706eb9e28150e5150a6eb7cf241b257a41b404ceb585800468415d9eb1c361d1a5e7e4f5e49d08878a46c407582af83881bf1ec9c7ac7641e259042c692128ab8e4e5c1c7bd1f2d990adb2e6b6282253ceafc95cd67aa249308196783c750ee9e0c6dc49e9a561340a51ccb667b0ee14996e630b16352cc7b814126bf79b8463ee88e893f1c74cbcaed065eb19931b84286533b3dfa745ca035e7edc9d1add9f60ff50809c6435820b275c3b33385d02ece6d1d175d022ca82184ae66df7608064f1eefdc1d14ad488849615aa92e1b95162f208c0fa387727e1a1016a252be32fe323d7c60ae6825e098217487a68adc82cb4540fce6265151c119b88a98c648e44ba8922dd07e0f72f052273438cf230e75a61cfb6cee107c491e118c01bec92cbef64e65b888859f50bca5078f46c3985bb5775cac0f1ef0540d59c98b04a5bf2d553f228d9972b18d21cb8d71f0f8ce6ff624fb8d36f86ec0a27b81edac4619f4a550ed41eadda37ef939d21a5e3ad57e67b9c600db71de24330f44d9d09908c435cdb5dce7286dea8b1e00399c54bdf15206a956eb905d35a4c8a15680dc2aa3db2c0f8df44a45584cccdfc5a080a0587da047550a6d9ffe0f534b4397c7d0fa72ee065ed1db389ee6c305fed860bc2f879d62d7c3fe31e0763f535533aeab6b339a44748f252310bcc750af3c6839fb6950d40fcc6e7b78edc37c545303d3becbaa4c8aa88fa154e235282d361d0aae6b17c5038f9822a1da46268065777d44e81e934055f5b9f9fc78d149af88a4ebb987d2456238d2e3fe58a13e9ff5a57569796695baad358ce00d6fbcb194d2cdbefca49fe1ec47662c0087ec03c895750e5099e7ee7129c2feb061614eafc9b015d5685ee5a718a9661256346bb0223fe236814fc94db4ec6537bad903ca634d27d5419b0fa81d6a688824b4bef6509f29cd36688dfc25bd3c16b635955d38a20daa9df8e5fb32578e31e7f7a4da3d4386c1bcee47b28d8651faa48957f2855e9444e04219d1d37865c8180b555e8a7a3dfcd4bc7600d4e68dc857af2a30b179c8b12043fb1991fe04befc40614592a803fe7a589f2bffbed3445f49894a53548943ed99186fbb8d366d50d532f025e6660caad8fd4a4f607130b219dd7836506800453b397156e4e2f2e53cf3f91096dfdde3d9f19a9cf52bdcf0d83d0a7361f58d5df41a3e6fbf6e229232dbb64873fb4d40d902ae3a388eeff75d3447964b716c48008d1539cc8404f3f9ae542bca92efd0a01751c7b74857bae3602f54b9db32f4c972d9b6302f206538e4f5c2e73e9b70339a584cecb300425fff834014f8123faaa330c21094c7c7d015fcb40c51d64e8da1520cafcb7aa27fd3c92492bc8ae47c63b58ba8e2cda0aa2a1be632ab45923d792e220f37b6afe387bc047835a09013f0b4813b36dd310643f24c50d9ad7ce5292151160ad9f082c8c452d81aca16aab1805e8280f790264fa7ae64b832ea211e4eeb0707e1eb65b3750054fdc2bdbff76f228663229535136e671c7fd89df441677859f03056edab13714aeb5b33f3696eb1745339bb849f573911fc8c1e8b95013b2eef6b4e589f8367abe3743c9bcb152ae2911f8daffee633ad474f644d73312eaa51d0a5b673d2020ceb945afbf05ac11150979249989ad3c9e51a9260c03bd7ba14936c05a13823ce31e9ccd948cde50a991efb05652c23401a9cf46032296fa796996c167726eaaa44e07ed8e5aefa9ac9e47154d57fe07a6ccafbda5080ac9d428b8556b603a21691e5179526a1a1fa94dc670eaf39e1a91c2be00cbeaea254b713910d9bb4ce1aeaab03624cc64ab863ff8f3589665056cd332ff2f487d6d97b80ff7e08a59323572b97caad75ab98cfd17277c8028ec99264e49c1fe400d6dca4b7d47821f168b01181437fdd23b27c12225e04dc43f588fb35e82cbec3989022048faeb9ec76f62a684919aa907a8eda925ab47bb0529db6d850ef8ec5aa182d62b31c369dd9c17b29c0ee94defd059544131f756976b3ddcfe22150a168571a773b9f220d66cc1365a1c97fcd9a1034266a4b13a546cf1ba1a774ab2d26a4a2e3518346a5800e2c1b5ab6c821fb9b22405bfc236c15be22d70714572bbac123451c746795b7f79d3d89bf06e91c44ab5611e19a3067ba4acd8de91c92322aeca1a37e907695a3148f5ea97d4464a9c430d1881518c21bad6ece913f77e06c24a057e5f5301b707134edd785e013e34114de3acb3cae355b92405e453dbef40e0e85befcf7c0d456d6eaf675d644956b39c4b879ee5a65dfeb216d3fabd806a02caa365cfa834e871911a3a6fe9b860aeeab3aff65c550e24c2110c2601a3d9c515134fed19d642fee33079e1bf9dff1e8722b50b254fad7a748fdc369da087e3dd048f14fd70a951da7917a3bbccd4cd996c6cf8fe525f477bc214ac4ba8650dadae78b33fb7bba75f20d8323537976a13f5001024a22b4c8a641ba349a27876c8f23bc61fc7525ac2f83a70117482ec7cf1b9cc4dd448f731f057c2f92a77a227b3a5307db28628a5fffda931f8c390b032eb6f8655eebc4b3b99b6bcbe5e4f2c9b0dff88505ab9fdcb33618991c9365bc188e1be6f713fe213af208d3d1ac0cae86b7a37e1e196ac8caa274f9216d45c24a0f743961a8e512f932cd60732cfb348b7be15d1b0c7270dde2b775798e9a44e545b73d34887266418c5c3b50eada9f1a8c05f6f75815a28751cec2a81b5a3be7ca00ff4de6a7a81c6598834bb90d8b22236ea8012f737a34920003732403f93ee949311f4e90644b4f34973e7d4379e601f1295f6a72854494beb80532ec6609c9f315861a2ee2e02446a55cd10a8ddd6124bf37bab0b9abe8f02543c5bb5d79700df041e07cc5faec460a65f752e35bb5ade9eee8eb8a9b0efc87caeb870252c8dd02f408a56081ec33421d1c7c6ca96193d588276934f597d74087d9dc49e049f3f84fd86d9ff771e7f05b59c461c39c03adab63cb1e1b238e78a651d35b79f5f013a36456c9b84eab55adb5fdb19da16a27c97017675d509d9612e02955e494388b7937916fdb3b7e04c041dacd6e89ffc13a30946442f189708fab770eb50d2d859cf1d549c207a5ad57d2ea107ea5066c85f2c82b6992b3d7e92970fb661c2f43627b233ab2ce491633fabe3ab3d56666ab4ee1c46ba43fdd39ac45369ac52aa465cdb4bd12c740c831a91e1ca1be9f3bc9818ec254e7d5b976d5dbca3a63bc3e3c96b9ebcfa59770d0910ed8397afd158b3d8a78789962dbfb3424449b43c31323a513b38547616f720173165419f64016bdcfceac5ad4f2d227784fd9a8e225251dbd974fe0ce9bcdb001fe5ace6d5de1a98a8568dcb04f67e04b18205c6fd08484034ab0b1c3088cc733430323bdd98c0f5ed450da7dcb5876742dce90a3f39c7d672b89c563c8fb936971871e9e9e78b00d9f04c512484e7b1ac19e6d1c9304648215beb4e851006d658f57ea11f6a78ba057f04e26ee02ddf71059a5abc2ddf35808ec7c594686245bbe4b35217f3b3447869ce14a7ac11a7ca1cad49af1641b29cf1cd8469288406cf1d377c8d195fb38111dded44776d6c5e93c831bde8d6b5ce014602ba3586c8fbd2158f162423b0a8dc22a04433def1102f83d8ce5763c8d0197eaf7bad2ff1550f3fec6411d45e238dfd0b07a90adeed0ec7f9aef1e77d4eeb6b0d993ce9f38e0f1a1c51c1d4828fed34fb9fef5905fa4ea8013082a47dacf03f7b169aed4508d8de532b71ad003b25054ac9e6846945965443129cb4d977d930631d5175798f5203592f56850f9fcaa4282f2e2f5abe2cad17f9e58178ea0d6be859e4bd30886ded2304c68f5952ef228a0f51eefc556bd3decc4cde8a2857115185815b9ac63b07a3a01cf46eebed5b11271be0a27d4dd45a3725de8d00ca53103217ba441f120a4559a0ab6b8dfd51fb9e64cc34a36dc0317a3ac878daee98a6c86149f4b129abf67b5a2fd048d6b3fd052e7c2e4e560e435d496c93d6109ee92770f7c06b6bb087c251aac2204e8882f3cc1d4953cf5ff6518b840e4f8f9d0137a2eb32c23621b2642285eb55e597450c33ca93753f2a623fcfe78a18e47b1b679f80a12718dacc699619e999c89c6cd5f5a8239ad66a8404a50ccddf0c9365f4546b8f3c5790df1c21147767a41b1ba9d7b89875b3d4cfff2797c6fb77310cdce484e68249b93a799dcd3053dac1461d78f6d84e56745dbc801c0d5500de1622fa012abf6de30a624eedaca92075f6edaad69088e49ec2028adb5b7c1224c707c635e297fa3f4410e36c4eb0142fab1e47477d991c5848b25a801c9222c00d68ec5e9ba9db5e57ab71c5ee3215e930e1e0aee484d1717ad93b4b3513dd4b64c94c893fe1e0728794069f713c67b43ae8d7625ad5e3fd547deaad0c50ce0324913abf57d75afe071c3d27ab63bdf1a37a74fa89495df02d31feb15e8f83990dd91f149e52df3922b25a56b5337f019556016af1eca2eae11ff28dbb402c2aa0491f205f7577ce12e8fcd1f1ef36116de3e4d4d73f706447eb5faf2f14413f6a544a932a7bfb797d7a3859567b6be4ad3beff8209bd9c2490c34eb3f1cb8e2dd003636fdcee4a752d79cd2e5ee779e5adda16515c9cdc8f28117bf0f58659bfaeb6bb2107966888015b0e293640da5daa90fb295b7dfe46418af77ca9ab7f91390c9432d1df9183b064349f852be5c2b0695533a4983a5bc4141447bd02f753c41cdce8d2d29d7467f9d97c6fc331038de4c0ad023e5146e0b49e9bd404f700d9eb65448b557088bf1e5d08eb0c31d97b8e9b413e05547768d5b169051a00cfeff14cb7f188a42c69b34e13956001875b178c9476d22e885bcccdbf9eb69037d0b46bffbb843f3eaddc7ca68c72c50f2933a360e13269e7416ace7974da6366b72fe42d4bb146c6429063275dae38fc33b3cb512d4507c81a17b59091b7a5aa3bbd1263d3930b40831682c2046dc27fc1289e798b3f726b18ac8144da6f64f731433f86da2451470599b7472f6f9df9fa8870f32106d94e46780bc79d594f941da1bba1239c32de2072358a59de946fdcfe623a852c3330b4a9b22c95826a8039f3d276cae79d63a04f89bd6785b525f7a1c9f449c9079fbb782bf94e230ddf732fe85cddafb18e77c4ce7a67b3efbf715507616a6daa3b693753c2731d335e23f01dac293da2f3e4ce5956ea30e9dbbe185cd865185668d5fabc01e77f2dd5e271532d0277531c4d5e8fcba3d8c6aaaed051da374c6e1bdfe0effd4ce81aefeae9b60c8cfc3034f5e883b8ecb71aa01e1cda9a45eef045e99de386744155195634b49d6d4150ba5bf58f6e24f68e60671da44dadfeca000c9e30dee7ca5ad009e1dd3d8eb37ab9ef628a8107068db801b6b9c35dbf6d03d8f0796c65acb455fedc09c6571e8f94e4d41a1489178d5dd1cb042c93252895238946be666f0b1003fd859e2af1b9fda32b59ce7972c0b1796322f29324686514ac25a698684a778667b66519c7b4ebb34d6ea08da31b6c644fae92c4a07657e1b76c6fb3c5749e756a148ac7ddd6854bdea3a0473a15d23f15a48bcddf3dbe5f388cbbdb0831af083ad88446b1ded955bbccd5d7b325cf407540c1428bd2286c37a9e6af3c2a13712dd76ce68b01453a81796bae832c4d862d645de17e068743185faab740bbc39631d355cee43350d6c6e6ea7b6a6ca09af0d4da6329e6ae1f8b4ecbb2106ec5ffd5af2c20a091c55bf865ff3fdb7b0ec5ded03ea3da0cab512be2a316b9e378297d373bfeb77a27fba956dca5e5097326a201df51cc4c3b2c84d3170f4e543923d05bc1af44f74017e765004a2b1d9b0cf83d24b159ef07e31fe725f79bff2994f12ea3369f917e850907f9639677c1d0e53563dacd9900fe1c67cef5b87feb859639d625fa3bf1e27ae83508759677e784ee8c5cc5f99dc49e07abee0a9c0572b2f472ea17d7cbb72e3980d5fcb1825bc941bb3b9f8f5bf1acc95f307532ea1c0f0099feba4eddb4037c2a43597a6710c8d22dc4c9ab39a1e91431a51b5218493cd97ecac8af2923e79059818ddff363aca94d0b9efa5cdd99a1bdbe36c3cbd76e2b52378264975b2058cf724d204a8e5eb9e630785a9f9e58c64276f99facaf37cae3de896fafd067785de7faf647c202dceba6ee103d4ca54ffc0352d1c6db39dc711e7daf35b059ab806e086fd1d618dc47a874b5fb29a136eca7965c1feacf6a3d3d047500c10c2308ad505509b4b261e7ecf00bc224b256ed63f46fb1fbe6dd137618a057b81e9f42d9855f18a61104f25e61c31e738b52d572ee8055d312fe6bab066b839411ef4666f5ac8615c78ab52cc32314072f55c1c4f42cef4326cb209b55038e39e34d6ef14f9c38a4d54573b2d22758e00e465a43a2c88ceca522689fb703bd2f67808191d470031766f5c90be3f7dc468b0f68c50f4d041a940c3f11e074cbd79f51f90c3c99a84471f924448b9d232db7ea9da264e7c739cd2064915ca669336c9fdaa07383a72fec799276f8fb66774d6876f65a1fd9226f622a61aace4f43c2a3c5f93d677902a32d63d1d4ceef84ef0eaf440b8366234e855aa39c22a4bc5e6f17e6b72c78a2c7a2cbd615006a30da48803e5136e502c17e6a6fe88d339363011e562c500bcd4d30566518419dcac97d9459d895b4c2a0de8b4bcdc4ea41e3e7a2669394e0a7542505ff2f1c35254bb1e3a28dbce7a7d04866ef2f631e236e7125eb17954c6dab9f6fc1a4f3f06613bbb77c8dc9c6741e832cea1d7f2db8b96a2de56b781db87a82afcb58ad9d95e4ab33aa5704aeac6c507a85cce6f091926b50e2a6c59193516bf9f73e690dc8c22fe0576c9c2e81cb4c63fdf7ad42f57827de16b69d539238bc63ef0e986ccdf663e9a7a290995d52967519b713d354bddbd43f93f43f01a25cd0b05ef8288935506948bd5916bf0edbc99c7f425a3711c6cc2cdbb428ae0be8ddcd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
