<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d2066e9813ba50a0981673cd09717b28964740f3246e3ee1d4b96388fc519d8007f28b48f88b3f282753ddea9f1487dc77eca40f4ba6cb2831171b01f3351fd8b95ed059a0deaa519f18361f61ddf5060bc66b147afbe044e4c719f5de9ba120d20cc4446f18acccfde44c0091d3a03770480a4c065707fb4113e13e25cc9405e0651a7a6f9e67790808d8a5c9259f1be6187e7b7d19fe4df74c7d8cd4ff273a1947b0d7f71345356e1958dd0fdf513a10aca03bea43712158a7d271cb46bf4c54fc3897923ea2b7ec0b87eacc90d1e54d99f252a503f976883c328a2a9e0f6cbfdf9de9f229be9a7bd8012711f0c8f6c1b67cb23d865c8868aa080451dfafba20105e52907ebedc6e570126367d9411cd72ef50af49320b0d2971882ec57408d6bf09546ef376f5aff0c466de2e090aa21da790a5f702eb48526fee2d9c7ef45a3cf9a22be0e4226ea34a57513ea5048189828b7dae1141ffe5e960c688f5526ba45d024e3823d4ed6f29f73d753ab814c191ae0407c9145857dbaae9f339b77c1350fab37bcdb079f08e8184f1275fb18bc79676cd86563f0fda1d941b9f786db79a4a445a6edc1c934060cea7b1b0b07e3334460a71416e9f76f6ad255e3d90061c2ea298e619e461b6b49e2bcb5b3bb70d127d3eafe13fa33892a1e10581072cb90ecd716c255c79fd1a7ff9744a15d2ebe5ac4e31c0430d0ad25c6068cd1806d9da41890a31f044a70f562b0020d2875f4fccb8f8fcd8c045f07e69f207cfb3d624b3692d90e7399d01ace2127c8051ddd51efe14c7bbfc3dc304eb8048f1086b8fb30275cd9a05ddcc9a422eb3d812d7294eb0ba6422d76782495c1ad9701b490cad5c8b459ae85b791f5a8bdfe68f8f66606a428fd3bbee0059e6fb7e1c191212358d5223d614611efd2fa100b0ba55490dbe0803444084f7c00d9c2749d1dfb599245d4627a389772fa4446f31141556142c61c7d5d08dfcdaefb05cab37a58b47e57550cee211f197f69eea8b33dda79437bc98f043dbe665616b847deb76408f446ab3070bab0002a55db21ffd3437abead8f536dc7ef17c46e4fa478aa93634e12ca5163a9fb4a80ea558c261e9b6bec1072da4251fc55f0ed3e5cf27051191bd8466e1919ad5b6d56e4b4af49b4f0128f2ede63721d958e7e36076a030c8895c21dff218e4075eb5edc1a549a03eab54cf9bb0dbde48cbb8e785060c1493fb78f4b65d9c54bcbd9d73f0db16635eec3641f878abd06d2b271ed9781de91b0136d48e755b9b65078175fb893e277ef49fa04480d277ccb445ecafec04ea37874390ac548b050a20e16ed839a54d4ecd32940934aa9e8baba0075f311987d39623dba05215db0d56aaf922e5f2f1a416c1423a89e1e54578309ab380406ed41f06c791d511193cc3498beceeda3386a67abaa8079ad1473689b58103dfa075be78f9bd69c72ce0bf37e16c5b7f147e4ba07557baf197a586f47745bf5a5942a799a3e38a82be9afc26182e496a2c8611d917858ea99f3f50fd32c521b76807d459aea0101a46a7895a6a67b5dc3721de1359def4efad2270f47f03adec2ca1f0b285304267210c3db0aa80f8d220c56eebbb622c9e337c34e3320d15d049f386ca20dbfe669a5106febbde7fb87b0aeb9badb62a1f23a20d6283816c3df678702e831ebe8457f499ebd522a0b3e215f1446ac58e0566b53050101df6e3eb434901535ecdcca29d125247941e2beac2458a5b583b80b18fb9ab2ed6f12f0838cc52aa00fd0cb9a4dfc4b4588c2c130200d986229ee0b3935bd97fdc615c140bd888657d19ce8d261383962edaa71599ec7fb0b666210b79b65acc91bdfce4349263d4b47ec57876aa391f157d61b9876b3767f301047bc177ae0c54ac4a7d92f8763c0e4eb544690e031cd71d5e8a45691fdaeaf07ca285e3f683dc18c5cd1bb84e6afff86458085110cfeb0726d3ca5643bd96f989fe36fc548c1e3a38758aaa993ff4f4bd7ea5e8770ef0b0a2cadd6fe601895434cab7830890e285e379a66438a529e56f5861abc5ba931e7e213d293e2d40275f4c89bf356c57c2c06a93c0c6e5ba859e0308562e33cf05cb3fd3f74fa46aae67e62a84dda18013bdce72906b2117ba3c9d51d591748067fc312cd6ee64473d6dbfa404b130b6833bbb517ab77cea18a4f2a2e44fe501b6c9a4e75537380c322a7eac9d7ad1cfb7e6884208574b23e36ee0bdab402722919690dbf6e162a8c31d559cf7dc5de3e55b15d765428e84a4893978ffd9c30008d1a8318a61b32d4612f3415bcd1eccefd548c043075b0290b1585abc0fb2d5264fd63a70f09a40eaac68df851916601d619d075f36a31bceb04ad262be57b0a5ef063b62d5073efbc53554b008942dcbcf19275765f032df45aae9a828e5b91361c18afaf55423ade0016c33de79fc0856b1fde287e6e5bbd5985a6a216cb27b58bde772e5b63b8da5377bcab79590e3d40c7458493e84db71a02717774205535473f4e123464b2fb15466081d4d90973f4f7c57686162cb74fa594ca8ff1e47f90fac7962c97e2f7d9285f913fbbd4b39e67091544709e546f102be32cd62ca59870d14a836a8a03c95447cf4eddf0089a1aa7576ac72f53ab93d3cf5cc073c2218540069aabdc2d35b5ca018a2e60311507edbb57a449820b9e7a97d03e1e0622732413a1a30e0444799cdb77c94e8bfbb8310c05b3c3045deb7bd7f7ac51888e70b18618cbc20d15a658affe730249e88a6ebd5d36fd8314e4b6813cee5dec4a6a65de961fd1e99316d95b284aa3145ee982e4dfaf01bb529b90277632d821f9a9150e9438f3cd48e4e277adc250afe0a33db52c8b06604dca9428e82a09ba4425b6b6e9910e00a3273a5c25aa7db1d1c34aa7996b4e13e92efaa6b1a223cc916467c33493470727d7903ab9b73f6fe7d0019f69d83394b11572f4e16615b329127f4b010af1b9120f4fdf7516ce7c5b0dc58b0d702b77db415c9ae0109fc85d958131dd725b94e40371a5ab89b0ade65b0d26d89c38313824a1ee65446ae3f6e1a82481f57206b7a10c95b57aaef7abe05043b6420d103ab0e5cc7e1a8b6fca33c3a8dbc74ae7be4d42a48d59d5f39244e8c28b193f35af8c25492651c632a347a09e61cce1b500f93ea4fe9a7e126205c3dfd517362a9362cb353fa5847175364531b3a962300b95043b81509cc736a733520135eba4a2d155d57b674d12eb34c3c0c746bca6b0607eea4081d175ff620a7f249ff09d8c52184c0e4c36d00e848eff404ad4a673810f58848e511af09f63d762402407abc0f289e3179696b35e160529d37d3ee6308c29bd6dd8856f762f6c09c1beeaab371a46b966b6785b2b392c0adb60d975baef77768b6bc35c55b6ecadf173b27b6d616224d439b4935d90050f7a771c1464ba3508a9c3104632afc1ba1ee12fb05d0ed27ec1b7e390e02dca3327d63d4a3925b2d585121f5b68cc1713b20d17f557b623dea5515cb005d409920287d6b0027c5ff6914ceb79839e54e7bdd72491be2770a5bb76eebdf8f34072216c168cf7fe01e0b7d638697811d373e837e2e679906cfc4b3abeca5e81da1ffe1270c465d0a3e52815fd4fae8c543be95fb6e0b5c2f2f1f8f63fa22435d6b8c84a5521ebddeea73dc4b8dd86a91d2e5f6427296b7b2227ea6d8a97d44be7ee9ed9d4f01a134d5577a0fd74d27c93a3474ed5a0a9e7b1593fd78f28a2b4a19babd791234f994cb039f32e16bef7c299bd9b3989fc483c3659e7cb6a4b7a60bac769a645510d727ca2ce1d25b9d77903026df017792f1f0ef5803ec12b7e963c1e1310b968113ef93e6cf1f987452ced75b9f73040ceb874eff77c1c6527410e8ca04bc5df792ab43272130e18601610c19629d19277bfab4cbafc2f43db2eb23b84b29c797af9b2621bc26b38ed1d173ccbb0397898829ac799a8f42d9fded17e6cb13782b8a1d6e4e5374a6a5b6616756d8f4434c7801d19a435bdf9b8899cf73064408e8814e074fad320d7564b267af9c9b44e6530032b99efac53c5bdf99dbd31a95451df073e44e350adcef11e0b64692478fa60e82d1ce85c1b0ab2a9f6f238bfe1fa62b6cbbee19a10530d291e971d10b22fa501c10fcd0572db4e8e57068826dff191ecc2b7045e11d3ecfd865bff69e2c64dd40a171286b63bff6fa6205f6f018e5add8bcf1d4f315dae2bafa771f057f59cffbd59c242b6f6fdb592b2e7f21a2c6380a3cd8871cc3eb9fc318445b1c4338bf3cb96ec921e92e3a3bc10d85a51dfeed1b6742dafe0c83de346fb9a882c1d2c654beeef0a7adb002f2fc535d9d056c558281b47b5e6e71cbeea4c8362c7aabf860e1e916e80ba67ba9dfc5acd3ab7b953a47e95078bbc5b9f56d49fcd2ea0b9f649a5d8fd6073f27f8b31bf4a8305462ba118124547eced3e75c0a818272840e52735774281f420f5ec7f1a549b1394fc45fb8a641e1e9053a69a4ef82dd2a65bec2955f7cc432d3da85bd3825b0a1df90b68acbb25537f2337b8ab973c55c7cd6a9fc4ea6efee4ec9efc0e7c261543a4e6d2e0c318a315df18857904a748b1da70d48eec3ec0ea7ace9a8d99f4f5446dc0373ddb52ce15c72b9dba647ebc439de1b3415cc1ffe1e3b3d5e7f73c6a7e6521fe9ff7f6aba29ad7d4cc8575cc84a6c61cacc3734f8f5057c93559c124bccc058d25f653dbf2d9001dbe11f76fdcda4ab2bd9bbbbf30d84f58688163307c5413eca811ad75a578557a99c1f3a494e4c168052041090faece8871f797f013b2cd728a06dd75fed01b14b3afa87e908f392a4caa45626e0fb97bab3849f8ec729a2705fdc525c51b9069cf417884f17fd213683318f98eddf1a05f22509ee3329d2f3b5106732056e77aa0f3c9b17faf5e15f0e27908d2989290f746f2c12402c84b26131fac45f68f1e9bb7e0f80434d03a3efc443f1b5f8b754a4e3d7ace409602c72c86e5f3e9e27c289c9ae426e8001da182e0ac4b7bbe898c1dc7dbff345dd8e9d5de3249304c96625f20e7ff64e8cab31983d96e4cf3d8a479015715212bd2607f4dec8926bbbd97a448264dfd41b3bc51e74049ec8283cb485adee608acaf409bf12e61e7fe313a1ea2645de5f54d0f5feebfbe45c881b2fc395d7c7a79e4cf1ddfec50545e693a7131912a3a1525c1ac0e08e3066867ee78c3a2eb2548d69c03abe62a0e5d3237d0fc0342526c1d8df9f553d9da2a4daad2b2d7625155e57c996684e480010aab4c1320afd8419a8b2116f0f7273c35d064889ceb850104ecb743964224a8de2d3fee1c8f7614172b0a0950ff01eff6cb5924bdf49f9ec9d3f894bf226fc09a4979b934bf27bf064a62f1a776600762d7299eae1a45ca217ce3b0b1c4a6f1c39f06ee2a656d396aa3061fc8eb5dbfa5f3c9cfe2ba8aa3d688cc4c5b6f2e45e2f0ae2ab69665708befe9fe6f35b77867456d3c2c7596a5a3af42b3d03531088b517667d53c5e0078d18126fd1c0d0e6038de62088a53a7977537006f15bf6a598b77fd13a1e9c97b3451167ad1569bccb42bd9e124a0c0a64f0dd6863fbdac519184c6d62269cbef0c3fc65db50c4b4e9ee72942fe5ab0477c6c24887a183214945d149fb290b6481d27e227d4541c2371d448765b1c02a1283fbb674fc04a8d706fd55074c80769ddebbe0ba2b0d08712b82ca75f2afa7599ebd11247eaf99db94fd3c19df558fea6578681113acb15c80d9a914165489aeb4e7f7a02c717bbb4355573d103a215650a5fa5df1a2306d2fea38cb1b5be78923d0a5a5356620872a086e99235afc8c947d00b36df21d8bdbd24b5e658c9a666a1401296df07faa88375eb134777aefdc7331fc54c9eb621bec3a522c40a616151a278f8fe154e46032585997793a2fc9b6d2e9aab1d22f9d4b2e20ac208cb0aeef0a4d0b9766791c6b367ba143606b5cffca792baed6b554be4389860cf4660796fc3bfe7f09ac87c3b1c5afaccd7b57bb16f1e80fa104f94fb2adcadcf8b03f63c0c8b399a676e7259e826943b58ce857e977c5f4d0a747b45538e2defbf1ac5354e7587ce6a5b3b79b08ea41f6f0834b7053cc390267d28d5fb31929246895d4ac97f678e9b5164b104110b69639f490df589ea76bc2ddf2f132b825822638f15fb446e7349b83d95df0abb1f28d49a91029cac96ad9428fea3ae883a058e7daefa2497c5f8367b73525524e0ddc651c9c0bc1aec2c7868531dd241265082a744714485a0c651b329a9ec44b280d3818d14724065c85f5694aa0eab26a9a62f40e304141f93aefff582c808349eeccc1a7a9a1703078854ea3be226a583a24bfabda221ad5e98e07bb8f616a2c74bb9daeb9a9ae47ddb53eb55358c2e98dd12a36c94ea203ec2403cebbb38c7ea946efec6e2d95501af1da03392d7fcc01b347cae78ab926dc5dca6499a123a7814a006934f3b1d959c4b66a03fb43e8223037536f46d30d633deb17f70c24b04cc7f112a29738eef9a6daa8d377624d50eb10990682129d50d5c44210819c288c033f47bbae2662538490aeaea126d0ee8d985aa2fd564761e980855e8d060f4ffdd9f6cd20f7f4066e560308cb5a74c799a148eb1aac788e242e00cf8d347792665e0a9e346e5d71efde908bd85643ec194cc1766a43b6212ea2af4cec354f7bd7ea02822dac99bd89a17e54421bb735868631c77c8faee527be5c2b5f900a33beabf7f3ed7f77a0cb0eb63a083d0f01815d75fbe4a800c6f99d05a8b96ede0aabfff0acb166fd3f2406964910432fcfac82906c08f64b2ac8593eeb06f8ca532c3a19b74722ef29732476e9788e638417597097d302f747f14ed16694abe0b7b50dc5fea50b46a4d37b80cf189e21edc4591cc684029b32be803b58e0485d713e2ea21631b78703c7f014f67a06d6d5660c6e0f3f0b4708a2b33bf5c006a6b0759b3829f1daaa4642b7fcb5ef33cf720df3e25953078ac28e6a58956ad884dfc88041b726d182ba3882b195840a4b3992186fa16241bf01eb83b56dc1b145f918bb258aa06cbed243020ae1e666af578801e863d388d891412f812c1fe0b38dbaad3f58f49abb1a6ba0083ced1d3ba3fec5752d9b45b41fce4d3ffde9ba07b6c681ff1745155bad2560ad6ae9b6f19b45d6cf3ac4d0f923e968fd442fa970793c7cfdca8acbcb162c18d2d76ac7f8753b33d7df68386afd60882e9780ac5316d8e6717cf4fdf25cf2dbd78324df22aead6a1759163955c8da557e9ff989a97854816b19ad72f83358aeeca2f86471b4e36756c1c98193a4f3a9817ee3c2b65300c22c716b5896a7b2df9f9230134cd36e5fa6a3db3c22bce040d5f8f503309d77e6e501f13766d91421cbf871f37203b7cf828e094b9c836a41780ec7f76550b8edfb5f1bd8ca551cca8ebf4064488d1575665653a189acdd80c03cd805aec4533d9820a3c4ce3b5ffebd48e088fed00fd79917de1136a47e75301acb8ac8f86f1ff1a01e66b5c260985b1c666d5fca8009d64f87498053cb2e542b2de2b140e8cc3b03129c863d641e415067810f9b8c75f99d529770d1f19503f5bb11cb5251474f10a6c1ff9007944b0cf86896e9446ea911ec3501f7029bf85ef6e8eac3a95de762cbef82f2ee4d5bd8dbbf2b4bd0c3405cb21ac00d8d81d1c81b128ed1f89eb8ccfbc3bb12c08e77ae7c19f20ccc9824c440818a94b17b77f2d04753a6cec4b6c6e74d83cee68266ec455f228e201abc6b508eb06cbc04899da16b32782f8f867c8c06e994dff9a5bb7ad98673362937fcc6b617e32135a31dd3249cabba4b7a4b68fc38ec9cb7495600d42e14fde3643ce9645883d2d55554490ab8aa830292bd7533916a2353d6e01b81496382e85df08ab593d9e79b739a335636b7a965fa7be05eb8bfd62452d9d6b5f4f2d9e787149e241705621924ecd5f73fdb664001f336407b053fc89abc3d615a33f0e6abe9d9ed5c8c4aeaf8ea0644c5182a0c0cc06214645073606c300bc539a414fd1fa87fea44aecb94654e7b8ccea68cc2a19692099560338dcda434ee1c56721f58e9705dd9febcc7d5dbec15a3d11533a8dc6564a3ea2d3fab65dcc7501285f8fb62ec0ca43b33b8aa6160da3d1421307c30d3adb4bbf6cc304fa48093cd18a92b8baef73f342109b2e21dd6955ad4b200a235f77af9ea1ff7fd4cbd281557c9cbd9a56f35d59651107342c105f371ab6bd28e7989b0d56e26af64c4f514fe99780cacb4a6bfd4119eaa4694b1868eef6453e5198d376862a6fe3562dd26f64e7f898f9b907fe9be27d179cbceb59075f63bccb9f8464db621f9d7272b269bab83478ade963f040282e9d922a96c72373a76402697ac7b9f1be97283713d8e347337ec70238a2e21e03d442a2dddd1244d1143053dcaba935e17e08ac4436c86b6b30a171f9cc0e0f8a32e0d44d13156b7181f033d9c1f2988d7e148f957c304f4739abcc53b4130a422c0cb92dd01527b975fdae341e933d64eb538ddf1bd4b265ed45ee07e2e36c5c7da4c66fcfbac95a42ca581a82f1adcbb259fb7d0529b6b925fb6e835bd43a2b76bc59ef0bb03d6b9d2c78cc6320d0b8b188f171acea9de6053f6bbf4408e70925fb7ec2386ed940a13092445485b6e2b746a895422bf97428da37a81ddc2674db7735572ea4f5394a649674eb781456f573137453e499a9d4ecb6896667fff4fbe8011d398fdc9659e40a94357e6842e5fbe90acd8a6036ebf912b1bc4b196bbcb8308f4c8faeefcb30fd8c85a3d2bd3b3991723c8433fdeece4c810e668a707f9fe958a26871a68003b4473dec1528e27431d34137ee6ce31c722a496e4979a2a37664c24da9b389b738724763421a261c9efe38bc6b2e2ba2ec6c3c7c51d6b9bd25a72b160ecd317ff2f17f873dd195b1071205f4c2aa903284d1f3a6889f2c73fdc52544b5e967224dc5abfac9f254561f5c6b4fc9272ecf4cfecab492f2314119cdbebb1cc89b1abc865895b054041cac826dcdd061fa4652537a20190c0d91dff0ec7a4a0afd4a95fa0ea21cf5f102b43ff612ebf5236b4aedecbedbf6995ac7a243c8740c66843440da70b9de1eb42dd9e806efb0b150526e38317e2355043896c7174098eb337e0356e08f5ff06e67614ca3b68996615c4a6db5c4002358b74b3161e27d8bcf8807eadaaaa1eaf1bda33c5951014b165fbb7ed39eb238b25c2887abfc307ccc72928692ad2ad1e70a917a459d0d0036777d5321921a583aa0f93dbaf3715c522ba3197d721bc5b7f52a1b3615b31bbaa344c0e31bd1f467413fccdbd1158487cccc7a40f85b00ab0149e41b8f8a4c5f9b8c5456e0cee3c6294773ac8938e520bc208c3bd663c1d7aed21fb5ce46bf1c6925731bd00ad8a4aa8d16c62efe15efa782a971f13b936c65cb0ee38b40682a3552f74617c895cdd170651188d6c53e21b16b587578a6696900b9fd8cd39504fa24cc2d3eef9d523d452a174c3d9acac990541847127ca012d7122931cad348e7b0273687605e7d195f59bc3f36aa8144aecb090cb11df45fed2ebb767251a951baff1295d01e18a624e2f3dec599889b72a824faaf6be519cdfd5390101412e8c5254b8663272f405ca2c6c774205a91e2f06f6eb6087b88899b50c3e58c368d712cf9214db972d18b75589b4f80eac38caf4de5e726ebedc2b7e2c5ecab0c7950cdb3c0b97585025015c09974825174f53b72373478ca90d7411987864033e96a5f638fafdd27e9ea6acfb47c59f85eda15f5d88e3442ff39bdd7595e373d2761aab004f5040e14a4deaf51d5093899116763d418607b8896c147dad4482ce024f692ff36c47e662a66dd25668319ff0e23dccc485a8e8fd89f3c5d9d57a4259986e5cfbf06cf0efc7260facb241542f9941ed3287b0a4dd75342935434ae43f672a66497a3cb9fcffe1200740e36d252c9c995ee827791d98e877d528ca6ecb2e115145f3de4b54e5ee9e6adfdb6c6d3874f6c039f23527d587b0afb90991dc98268ed6936f344297469af9150454466e2703679e111202fe690d36bae7a1f2d967081dda503fa036fe45d0805361716353c63ecc77647f447f5a4331e925c6332d6d7f3db073f97c3b90f4b6cd6574a5bf65a27d3200c28d3f974c2e7502c8368c7cc5bc4f3512e3e358a45897f4eaefe06a96dd5eb50869e42489fc06871b8ea34806284f96e3d52c12e793f85744fcce04d42a63728567c0adbf296d8b6a3597d9836da0f98fdb9ba58708a93972cdf7fe086d85ddf1ecc9f49f7ad3e110e16132e6cefb6f8dd79687dbce568247a4b2cf2026ca0fb6acd7b059114ff61265d96b54ca23eedb511b06568cfd303ae982136690ae49d14eb1725c5317f03fe83c86962d56c8db8c72254b4ea8be7ea05aaa449ca7d26283b25037225a0120e0adda6b75c810cbcc982c616fba710ad26f983e16f507ac4e1584937e3470cdc9e6d1c37438c494152878f22f055c3ca693e6ba88089a24a8a8deb7da351175a7c4e9ec7a8703bdf919306168517549e9dd3fc01f83be44b293a83e57d65e7e854e96320fb6d2d30c98452119390b5aaeca1c0058dfe90aab691094c721328e518d637fe66f42c120ea4707855bf27791a6b6b307bda0f087abeb8a09a0d573630c62fa99f5d3dd96093d0cb6055d09ec9c0e9a6caa1378dfb224c13b1a29e50b25052e1a0a774cb0a7577dc91aef445b944588ddddf8503d85030e62bff6a995dee416dce78a84a7dd920954f3107bacfd2fd20b552ac5a32c87e55924accdd3fcca42d581b0164b84b3b9bf1749d2cfddce84079b8cede8b6fd1286f65b32df96d78606241ad04e6d8a2850108427ccfc1446f98780fc8a42f2a7fb0bb91fbccab9cb5909b36b975aba327ef0199f5d5f763b9eaeefa2a730c5ddda6601827b296b6dba2b0e19f85ffd2eea24b46ed7340266bc5e1c750e7867c399e40afc27f0060ae640c1af9e07f44c67e06f0c7fd49c25325be763942c1c6a8bb638afc677696f93af43db6980d96b66863316013c0a683cdbb1bcaa0e5bd90d1013e10098508d8e9bc6b298c73b747b7c0792aebf3c9a26e1ec2e81b77925af8f49b6c30c7821d7f0cf2313779b22d8b28a26ab4077f6f56c34ccfaffa79c79fbb141a3c3e5a28e3846ddd6b2479f2d9fddd4c3b06d9a4a5532df62648a7e0b74ddd1373eb808ffe3bc6f64115b9847c9b1c1a46fbe09ccd6a8e3d92e0655611bdf88050babfeda79ca2e71726a579c4b35d5facbcc076a9b351a75626456cb36a6fe9015e1436bc7deac1ab6a27a3e523c3543505d6ce8323e6a706d231cf570f0d114baa0bc3f5279cab140dbdd50f9d280110ff81320de9fb34ea9bdcdd34016b16c2a07cbae17c731b390e00869d8bb69b6748738291c52a1e3df9ae1bbbd156277e1e662d3d410a6be67ec5b1f3c9759a734d0a963dd06c05641be9185029bd0415e258d694c10aa556140730220b4c0295058a2119e6d931ab04cf458bc345483868541eb4fb604c7a2924b901d8a7250e9d7148623a4fbe536cba39ef7da6b7bc441542accc5d94bca1a2810d0a174d8becdf36a900fbb527111f3732c7d30da57ec0ff0ece7c77babc561e09503c7e0b41a8a1618545aa1a50db5dbd948bb74fc11f9da95f0b7ed8b77a7f8a9217dfe5cc5658955c5888d69d3a9de86c1210b0f5402831e10023868e05d429d03f358f1dc7fed9cea29d838a20d7cfc340f70c79c6efc5550bc2d1d0539921f37a3fd81091984f59fc59c694968f42de7f914cdfc9abbd8d420d16ffc4cdd28ca977b0de8ad7b7a10b78c999fcb2d69c836748783fd0f9c5d46f4d2a8fb84189e1c5000a7f1480801515b70fa508694db3ae98075ac73d90560a6c1eb89b5e46ccf31a428c3079ca5db6482bf4678e65028ba368d1daf18eb7cdeb5680d1d8a091a664212741c0988065b2185af25d9d8f5d95058711ece967e9ffc2caec92c767e2b795460faac2ef5003ab9700c99d8c109fc42766a629fc3be2aa93800212a722541546dc65d5f642140ab23f988266a4e44825f7ee165d77b9482008a770b7548ae0cfa35989d811871d1debaaa93bfd05d6fdb0e78c0bd373d1fe236215ecdbed385f09c78befe2ab276a2f2c8bf2fd98cbee87eda7bf0465595b11c8db8ad8b5034d40046ff1dc8adde02a465e4bd963cd7ce1d517e26198dbdefd3311d3cab4823bf44ddf557c6f2651b905f36a0e5f2659ab692cece5a7579f239367c7810e75c769b7bbb2873ae2096932b7171377b0b77104a042d610e31c30641b6dd51538f7511e3bba27549f523a13603c9e71f14dda55a5dd4b6831dd00744d4d11d99c5e6eedcd120babd9552c4a48e149154c9e8a8ecceae92857f4b0cb88b6a3f3b5560304d71ea6bf2908ee0ad6557680d31bcec8427a5a2afd3e2b4d4f79ed75df91b9e44c295394638ee5771c50ad0411ddf446ce337b2b830acd86e2aa72f050816d608d530ba20d87ef11593810e471bc4071adc338ffba1c4ef4fd7622cadf64715ebada2d4542a655d7b12e2a6c91d361074016aea55e6d81e33faff2e78a9afda86f9d4e0ac819576bd5fef4c8c5956ace44338cce6bb612ce1f22bfc3a056025651777dfedc61cff742ea2091d9ca8ef203224854e2b2437c3651b043217930453745e874f047eaee4baa4c7d1d54e8b414499160dd9919e7e9440601eddeaf3c85cab83e66e71d42a11015532f1290892be539181629d3ff432a33e173394dc8cb0b549e747b1ad5aaa6e4d5e2af4f4e179f1097aba518f0dd7610dcf6d206369ab2cca46f92db3457918611f8af6fd5e3bd3fffb68b46b4c402cf5b69462e3fd85a4d8393ddea8143a3d7eadc1e45078f98e85bcbb9ae02776922f471a24eb6b7265774fbc4b66f4bcd21496fafc8dbfb15e6a552876c1c8a146a88af2c51c964e785e343bceb81e1f10f6e67fd7b40165e29a9d6da8345913b3d1be87251b363c3e71893e027a30208241c26ea0530a2d13c0c8ef7b99350f9b61e57704044dc56640cc0a06583f589aa8a0b718136975829c9431998a8df21a470443d4b85f416054ff0808ea0f8d8d8557672726b6832e7ff3fe56ac0e69b22160031c67e0f9dcd33dc49ba0fc6028a5b4c9ce8e0d0d352c9f5fb7f1a3c55eea4f971ecc7c7cbc5e30422666c3fbe54945c2f2f387229e88a6e723a6650fc688db5deca061cc39d212fd784cf078de016486a27aeabe546a5188fee9f308043be87e2436770efc034bec84c48c8f12b8b181c3cb03eadf6c253499b371a46a08a6abd53f78305ee5b598e73ecb9cc7a4c4f68e7c82f77d3d7c4ea9d6c80c588152cf52ebcc8c508abfcc4b0191c9ee274c0c8bab5075fff76e368591205e17f3647b9e61e4f7075d718b5c2374c0b093875e12ddf5a4ea6063ce5d1c4fffac68ca823cb7351c63205ca6a2e596b7184cad5c9b3598ea4549ab9644a133ff6f854d98766274874be9cb80c7c27dd8873f443800fe39f955bb524244647a0f9312e76a0bb7fdd0e9b8d83a2af866e77ec3044a3b7f5b34c8c83de3ea48bd03b9df17bc107174d87107b29b14968be4743aa2e1d8c4b6c4ad10ff98e14d3036a035ad9b6eef7e4f1dc4fd26fd5dc6951b01304cbc8f6d5a778c45d20787341a0bc8e7db453d5dcbfc81becf3665bf80f17e1728ae7625f59721f273ad4000fab6526a44776f02b793059ade693c4f55cf99920eb479b9eccfff79e47e689bb5864943b7611560232b254cfce0e66496cc1aaaa21c1c96192cef4fb4f04c88f7c0de2cc5365ba56588cde89880804f1c432fa9cefa0a8cb2e978f30c6228e8adcaaa85d99b69c97b9c8e9f6cf52bd6257e57bb202c18ed6bc978331308a7f567e2c82fe3dc4fe475bd8d2bb31febe23a1d44684275c692af07912b52298ac84e6f020b41b6692803da1aeae42da32a7394a85d0db9eaad49f8ce4948abed74c5da23fceab51ff985c5b42031e431d23bcca37c5dec472d5e317253b4e42172924eccd84d32abc44b6465f1c0582918b978aa7a6d3868b002717382192ba30ac20d5dbe4a5fa88a407965f6d28ed68d614fc0ba0c917e5d6c4f39b2d073284c53ca7f28c339f4e8201dbb00ea98e8d8a049f3e30b94b1477ee329f095ea37121370abbdf25cb9849451e645b425065bfe7d4b590c59e0e080abc720fe9895931154af450b60e258ad13514652ca48663202792f420957a9e23e9bdf8a29bae0787232d3ca5aeb8cde6c367c5a29f97654315f53165f7d6256ada9ae8875a59a4e281d5255a0c89bb65ead1a265eca4f6189cae2753c39c8564271c9532aa33977abf5c557362a7b56138da9979a6a32713ef8f4c715370f1f58ceaec80a51a711f1943f0657e3600e27ff3bde6f5df5afc69a408f27b6690c77fde991d198763b302c5315e7c8f0a3c93a50c1b6d876f849464ca66c255409fc94ab6709ee11446122810558a959412e17885ad9d00ab818cca2d2202a31bdf3233504b5c25783f0e85620dc06eea73bd0dd62efbb7c02a911342723f076fb671a349f5e1163416057d14df31dd174e8773ed6ac1afc7cdbe2c9dca3947e71c9c9983ec0bd7d0d6265feaef667aecbb4e4bf4583e503659d7a10f4846f61d1682d59b32a5e721e5d9f1eef88d5276ddcc79d102696e46a63b223ba49ff7ca502db9decce71947fc528ae5eb911c8273ae3452e04c55293c5d36f81f289c469900b12e64b8b90fabb7c3ddf51cda90aa97f76f9a815296c1d207d3b2a2292b457112d6faa1cfe7cc4ddeb91b42b5a522d49da8ac70dc392c64034304cc82b2c3dea8ebb730d268c4fd7d0eee14b2e7f9645d3c12687c27a97b0b89c9f7bc2c8268cddc797ed7d9c96fd204ac42745a5547b5538293051a1987789e1c8ebb615ce11381a17efb6b2753597bbf711332affc80b5fd6dbc645ec38b949cb81755fc781f717295f4e9a79bc64d5c7b8cdd69fb15488e835f7402358774fe50ed4f550eb943f6437b53e16d354967cdcaa4e488b56a7cb24a670491c41881d0c051282dcb6e51635059abbc1ee7027a8d7010c9b8e88c68004a0c345754d7707be871ff71db33eba0ca6bebb13f842ddcc6a5e986b82dfbcbb778153b4e823f32eefd33a6b328910e801a45efc96f173f75053ac040a560a9a3c69490e591075a9c8688b8fe2f7c83855a0fc8d35893ccdeebe37896fc5ceb4800ee6780896552f1e6fd2638dffd19400d8c07f9de59e451d6065da3b34a493bfbfc52f8def7bae322859f84d98a6279564bd52d82dd86cf2976d97396be39b5a180ba6705293062bb81e0e4cd9be8a2d2618ef3694fcef0a089db4e2670cb0300407ef9f9750bb0311074329d916cac6f8d5000880965e9f07db877cbdbc60b40d797ca29dbe97614881d3be032e5fb80e84d576ef0aacbfa35f8c4159f228113f56dbdc06f32bd5c133cd1a9182ca42bf91232bd8707189f3c0109c5616601b852f9ddd5d8b99a98ec4d317168adf6ff3252fc8f311b17561d5f7427c0c1c7159e2ae8c4edd9a7bd5c7eec4b4b04386dff917812c7e3e5cf539590fba4aa4b9cc6d84ff1f389dfe160469839b5bd3b43b573fa8751f38cebe0678554eadd5140c6cefa8c724cf0b82394bfefc73b06381cd9e98db0f6927de15fa5fc8fb54b843aba24f1893e10899bbe838bbad18aaa7dbb84279c048fa02e919ca0b7278e5cdccf1f106be7b75bdb2ad216bdbc68ee5151cd3a1e68b874c42d5552408af34d667380567a565596f1477dbab3e69ab63b8decd0543cbedec8ffddc849c52714713b6e4d8ad49680fc88e4ecbe0a80398248a327b87ea2f65de069e84c081f28d9cd72500d1066fde203ed4b840673c9ac8912e3b32019ffe2d92a05323256f1f1d8c6e263b08e7cb4e65f8cb68edb1f63c24d1c028cffa058022bd491e2d0a23bcb2f58e6dcd6f358be53b05e51b1c6093dca48ca4c32c72d0cc7dddf200a58303200d7a879725a5e756c295848fefd01915dd98caf904306f038838ca1cb9e6a8f1e5edae3935abf676b90684917bb2c3a1f939cb25575cb996428376afa748ff44349e570cf970bb7d74cb1a8134be80d346d17d6258e75bdb8df92317f77a88097ebeb4df6c607bfcfc82e2af1d3adbe0aa05c86ffbba2ad2f4a62ab916cd9307b60578ee98f49247cb769193d168ddc65ae55c0d13eaa74ed5e329a3ec7f1f03c2f3501ca3063578aa6b36a9dae545b001503c4b7aab795288ad1f6cc0c6df067475d89583b62fa05819f04dd7591d8d0d1515727ea76db5e6d3afe3ae8bc38f9ddfcce04e3c5e48ec8af1fc8a5a37812a8ea6b062ef6a2a864bb458a66948f9d287dfd724c35a029dfdb793e6db613aba44902fbe03812b9fd5449d39c339ef25ef96c47929ed472e664f1d047f0a257455cf3e07849348e98d9ab5d673eb41158c413a08e1ac7dd3554f59fc4678b12321efdd77dc2754cf8d05aeb6ddc44a3e807158fb819c5baaf7f642508f7aa1387aa6618ec0236d190f97f540850cd72134f863c8edd5860fece852802168c870f66d7c076fd72c07e33ec8924182d2d2f2271524e023e7a36b0032ee0eb299b75b7afc70237613a3e0fa6959d4ae2de8959f6b2cafbdae8173d3737b286349f0763fddbac7c4dc2dcc71663dc2ee3e62b89e6395d54719821392799e590a59f2d5ecd8cb23a2bd7d3d0e07122a2bf1b7c9f23297a1ea9980b9337598547a6f0889538eabb3fa8c54759f27860193a203db4d1d4e1b080077268f2260335f448bc3b77919fa866c8eb437aba597558a706dc15e183e807b8522fb349c90fa9c6e5d89cc42b4cd616af4e0999bcb7fe9dd56464d150cf0dedb09d902d6820b34a73c534431096224b991526fd7a73e09972178e7106366a2f756a6ea8a48215d61214e97122500a134a8e40ac68b410fcc73bf2a7355e1b1edacefb42615ad76cd8fb437d8f504b1df73b95ad6878c641a9ca21b327bbe4e509b57e0f601c56b2a00d60a853845cc8ec9c7232ee766c75a7dead9cab02db3235a9d1ee704dcfad6ccf4ce509222d73b6b2dd058316c0b668e401878f9b76a3ed831ff0660c0463c356280694453bc65400e11541fa1cec0fa82262910d8088371ae7259a456f5a36f1392d7dc79e7edb1e03bc25131750f6af540776754cf7596027814bad10f0e14544fbe08bedebd12726d36016848d819730955ac02aee58a1f5666467a8f6bcda9bf6538a95618c29671963c30f781c85f2c5d14cf2932799cf8e6433ef16f0a9c3bdb79aa4c44bbe8ac447587f983dd640ccd8c3657d7140458edde4cfae49a87dd3a8312dea5b523e409840a4bc6a8c0c6f8312f4e498ff73964d427553fa9eda53073e24182270b21cd52622a12574a9c069e3b715f906d2afb9c999e0c6637dfacf352b028988759a50057bd1bc094848a861c09f1d87776f9253b871555b4dcee839310ab71d73bd147204e265d0cb715b7713e565d138af87cce256301a59891e29579ac79a070e3bc82197baa97cec8a67f3c8f1a88ad1a4dcb7821eadaecb62d0ae180ed6bba3b933f02ddfb59aef423c7d4640bf2c0710fbc47cff0cca33baad503e51bf615dcfa40a65f9ec0f7ef5e1091a8ab07424f1118592c9b5606a23d0785d403234ef660cfd2f1ebc90af2fe924826d33da74ebaf019744c77c95cbdedef9c31c9b1e60aa08fcadf4f0025b0f0557caf1666251294292ac796fcc9b809f28ae24ad0323c780b125bd1c1ad73583c3487ded93ccab7fdfae6ff5f62d6ed0538e44e87200c313487ca37fc654f58b6e6feecde647b6f280afbd37074b40b7db47597fe223eef6fc15c32d81102e06604a6490262115e3778b88916da41f2ef1f7b2832ec76558bae42d63d20dd4acb55dd7596aa6baaeeca4d8c6cb07a4b4b577c918be62aa1ad505ec51c4f88240f67ede4df442d28c45c7b8f81e197ad7b8eac9f53fdc13c3117cbeab1c96c5501cfa14b4e2fa8187b9cb037173c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
