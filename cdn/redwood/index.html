<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"766344f88760c0408506065266d9874ce87ac06170b7449ec6e87dd394664ea42475d8186e39aa481e0acc139361b3e8373c95ceff4c0ec5d66559ef00d97b1e98c48ac70edbf70ceefe5090083f3f87875d5a70959ae3b5599e882244042a9162f82f340d146e9ee173a4b49cbe5a239c2db5d651391afa38978284bc8de8691b099a4db9a2c2ac3c324bcf74b61067ef0ab65d3238d361fe68734dba0936f90d08fc838b3ac29a1433aa6a20d59ba0502ab556da8649200c168b6c1d0c77ad483de7194331c4bf52b3043e6fca99b9472f832497d5b958f1453fa5fde87d3a264d7ca45ac8b756a69537d46c388a80591f1ae80631759bb38b60c3dc2d68b88dbfe69e518ed59381613508e7c42f269d0a077a7bbc6f2b1986e7f06c66afb19aa787d8d2b923624591b8b27f38521d6794e7994b955da640dc48a8bc1b3f985bbed2a5e334e3db107f9c458c5eef8fd70772fbefb35f7e464f3c19ee6e2c48c733c6f86f68cb291d460d41825aaf176ff2e26985747bc315edbfc5786f96b264b08b9f69ce4aaaf4abdd3a03baa11e24f5f0882655733947954bb2d3956b6feba830733e923a9142b73aa7b4a42c87be3f88c6d3f058e25fd7b84b152aa1c9f231238755b2f28d02c9522ecb565f18f3fdf23cbeab7484ccf8fbeb67779b692207e18140e8639134c1e780ef6185ad40a61dacc4b326338c7828ebe21c05fea355a272cf5c4a7b71bd13bc3e3395f68f48ca564cf3b8c9d0c69091c491cbc1684efb4e22d3b84e0493b2f99e9383d3a4b8c94bb4148b10376871137eaa7f35896796eb0936c0329b691fa3fd5a0ca73e761e4c555520cb249890057aab98a16d0eab731e624d11a8d21c49ce654d1aacee6d285ee07665e5cc0c24782aab8da6ddbb36163c5987f2fb2a817af9a439296bcd9ed0c0f30b5a91185da58f1b4c0067482bd0e737526e32fcad75c10fcdd5b33cf18bfb9f61daafa26da3ad69a6f4502769a0afa87702f705c2cf62e6d80ddb841c632dc8b77a04455e48bf97dc3a4f3340daefd88d7df68ee9e6b27c48995c4c4be790d159d1b65652e2323cb59e7f017de5f74ca3a19b09417e47aebeb9713fc11c2085b344fd976db23f27e37688feb7557090c6420ef1baf5545bf8ccf28a2b32600f3552931b40ee02cef673e705d05db03a029e46d042982897f0a69f617081cb54a4c6ca86b5113b736d0f25ce520b9bcab8b5cd9ba983a51a9f5879310f2ac0e2be510ce666a36e10a02c3b56bdfb63b5442cd1067cad15e1bf7cbf0847c3b90df56e2e2391d14f9bf6b81777beebc20e4113462ac96010906fb46f3bcd0a63339546fc3d54fca7677eded5067bae7d327bb8ccdba622965da555b3f6252475bb2094210bcf474b3f62091ae76bc7fefc58364e72e7aafed71f742edfd619b0b8a0e671ab7caff0349c5b80cdf32de268a6c2355b31837103d33f1d0093ea2d0fbc12499497250ec69f6002dfd87ba73eb3dc7b5a9488c8fe49cb6c22ff20a0953294060a6a4ae6b262d1cb171d90de32f8eb0a0452f1f3ff97585056975396fe0a2ca9b341a8fafff0feb1c48743cb903de2498726ec612020fb9065dbbff2bd8b9e910d6d53879e2713887725cee9a630424e6a5a067b490e71f29ea6ac22ea1bd3e27418c75b5bf4c22ff71c69e1935d8a76009a69e947af453fdd240c0c84b5efd58295de79b1edf986c1551db512e212354baf864011869ec511fe21ab0dfc72b12ad69cb58856a751285ee59b2435e7a5602118c0d49f182215aed0f6e710239a4124915bc785bb57efb06ced8c09a601866c2f1a8416a25454e68a80d2087a4f354d8a50a0acae6ac87d9cb80f530d8f14e02134c894ad261052d332465325021338e8fe02905fd63a58ea723d304cb1950e849255fe39b5f0d083213e924546cfd21c0081c515de15cee035cd255ce9fffe8de65645d1aa348fc6697b5cb6dcbe696f1d5f875a1c01ae3082bc98b2c444aa918df2b24e897262673536c1c5958c702571c7fbc661173830896795ce9567a40a3c5cfd88d859905af7dd491dab1415a04f7dbe108946c64733b00842b6a4feb7a64c0dc21d3362a3855a89de67ed8047e3a663a538be6e5a68f9207fd58e376133b6397ede32fba47b7baea894e1e82753ffac5bc8fc84840a0ae7847ec0b786bfa38fca561babb2bbfdc68df83af6cbd86e3804daf9da3509dd97aa4640a9d00904971170dc7b7ebce765d0c5b0fad89faf3f063e8f49ba1489dd3ccf59fc7cc8c579a32b7831cff884d401f380acf1491bc1c5c966d06295dbb58a91d31d2062151e51c1c4839fb91bd32de7f52eb0b4ed7716f47afde72f940f825c3faac24d077aeb9b48967e5e517c4f515a2b95ea5bb432ecc2948921b1c6595f82358428461394b2c23762cd0971179d7ea0e530ee982d313dc9b557f1a2ed76974e338920db6adb9a86e53187b78f0e62badb019d6ba875bc1e70937ab0a58a706b03bbbc3104fdc6cb3d6cf3b8e5cb31ace55fb67802d8bba44d50ef559577c382486596e509f33f0b5273b32b510df6d8b595e4acb8b3b92eed8add95cec1dd69d07e0160db63ad70f2f12420b2c59018996a43d7b33d73014763b93342ae5b69ba2a149187589e77527f0367ad0a7a96ada8b32fe96a6d8b2e701384d59a4703bdc0a278549ee43fe572ec4b8642e86d632dcae3d8ca42f3a12e93f9a6b759239c1394615bc4c38c497dc7be1d8c7a72bc3144762400607cc8da08af4edcd32b325a67c4dd9d4ccd8b358ff6ea3c42ee96a2ba22fac703d70c9acaebf0660ad14167687fd69e9ac8e40d98f0b314a456a452eadf78f8906b9ce0edd065cb4ed7e265e5870c748addfecc2c4fa72d2711121ca23b302b2a04fe7d7caf192994ddbcd34384fc32d5492f4c9a3357d803f88d149a48aec9927467c65010e8360c8fc4669c0eaea5ecb0bd407c4aaa5547edf01577cdb7d1e0b3c2b933e974c068c5f8844a0da1770f3667ba64e6aee5e2d873243de3d3b5f4aaf720553bfc9a2c86ecd897e9cad46e8382033ccca76d901e78c9b7ba826c1334c51b2a4dbdacce7b6edd08b3c96f9d73068dbc7d26132809a1a8f117142770afb8675531bdfbe9b0e0bb7d1ea9f79ecb4e6c7a84bdbc68ce09d941ae47af1c6ea24878b977790ab36b5cef3a1d1c3fbb067abacd89924946c9123ae62dadbf29c17e2ea8c1bce927eb1b158015686275e2caa4a3ec9ed8de51b2c8a4ad4ccf92b290f572e5be4c2752113091ee9fb5c421bd3649b31f405ff345455e4b369fe121fe9cf502c858c5c6513d9744220369578b87fb6cb76c241b272495d14e53dcb4d9f0566f202370aad4d209db0283ed8d8391696fe35481ef988978f5d18f0e46374499293e874b31465dba7f08d0b2b6735119e16511ef6a5a04b2ecb434b0258cdc36fe6d7299484f7be93ef7403e20a7d66deb674c98582dea86ec9e7019f1131f47edf9cafac93e54464ce31061cfb045250fa31686ce46362f7bfeef2e7ba2dea730cb6f9b6ef6291583076149983c3e79174d4414cfb2ce0d12afe4a4590f1e76e16617431363243226ca827f2ef1743a84e528159df685919d24139ac2efcad89d7102dda5c04edaea79b819556ba8a12e2d5f63c9dff8d2a4da3065f40d298ae3a63d9a9cbda28d97cb4d0fb4b8a54da77a4cdfc858f85293608e95854f7abf1832963ae2cfa260e706dd6d5adb6fab53c3802d1f3698b63e6dc8bd2ed2ae04289c99079e0f7b926cbb8f8600a248a1f5a25d095749e6c8933ffd69829ff87353a44c92a34012e222aab3b4ccb072dee05b1614b1f5246844afdc586800413de25a07dee3f85ea7f8570bcd6f5bd99f7ef3ff60b67a0f0ef45d92d54906dd94c83a522af46da85d8580b016d3c72b132a7d7b1c1873b4167ca519fcacd0a8b6a86a30f0574caf516255451e0207b5049fb608ac438d025669917dde2ba3901be4250b8fb0b1f4df55ae9392080e6b5cc51a3e2a9923c352f79bf3c7279d2c00c72fc153078bc2adaa123859642ca343be165ca51894117a9ba19d46e7669c37e0455041fc806aed56b87530983b78dd26b7c661421c1404cfc456a2292dfda7670358cec6fc4b049e39f2f0e9decc62eb46ac8e168e0db12f3fe275ea6317d64f9bb668d629fe3017187956aefe9ac939ad3f3708fdc27c28331cf4c0a6009b2b3669a7251003ba076d1497da62ab639df6c1d724d392cdc8c66e0147df7b97a4415006096d5eb5c259e9c702f19a230d68e8852f02dbe526263d88e76751031c6f526ca5c28380bde8036b39e4701962c60a0e76be8017b72a4497907acdc7e32cc681ace9a6c883a55ecda3d787b176268968686f9706abcecb6b593d6a6c50ba46f5a47bcf5009f7cf7687be53a00f3d92d537bccec91c5d8c724cc0bd28b79501c4283ea0ae897d19f41bddda83c83eebfbeea052ac2724e426f8ddd3c9695f7f6ce565f83e700d933bf1818288aa9a8f7f08355944116fcf201941fdd96e80720d0832c704ad7bd8038f0d8c4dabd0d03f3212ce8e09d7a3d3d8d2d4101534157cd55ee3e4898f02143f76e8feb2e45f6f0c649b4f7283b0a2967dadf948e4a54b110ed2e75e3fd488cbbfab89a1b24e3ed512c5cb466838a5569dd9d256e482fd7997b867aed5a676f3a4e5c9b31361980a517a0480aa84019de1c1add113f97b86576a44cfe9fac2f497e40d5fabf41ceb4f63a01d0138481a712c892965c0f3abaa7df2b89ce7e656bcacb37b2bf83924be59fc2fb8c40e4b6af3b53cd7cc404c7567d90cfc88dd51315cae98620504313334e498e797b27b4c5214c013456f594031231ada4f44254e46bda13ddfbf6b686af3fa930f2f75014cb3aaba450176e27e1ef823d44c690cf63ca583e8565ff521f49e43d86d3b08d47e0382b958bedeb9741dfac5248037b21443be5ec083b0342ceaaf5d0b64a5160d7d928ba8ce3095e7f6f33436707f80af2c3f548ce9c12db2ccb0ed40f1b3d61cce6c8a701b21e8e17c791ada18f7eefc9562920659376183ca9ec39e02351b5ace6a53df898e5c0557ed0df729e0871a7b334ffaedd613b0523ee0b5abfebf497f0c87849ffbedd2908e2d5b58f4bc6b8aa14466454286a3c3e0cdfed3db1d21a42cccec9be31aa16733c1eac12f18a421e7115be2671915cbd36e6432d9650d25949024b09cdb85b1589106d988e0c475addcbc12945b9652b26d4a88818ce74795d1fd1828d04669f0bdb7cebfe274be802b0af8f981bb984525bbbcfd4493de3dcc3aa3d2b6b062b6b4ad5df00060434d504ec6579dc68282f81710d2a9010cf0e152eed892e19c6d981636f82d29109cfd8174fdf626557f103eec2f231afc9e008f016a1826ec160c41981a68c1e8d02fcdccbdd52a4ffee0b8e211fcc1752c5dec823e8bea3bcd105560a9ac0a63ad9500058324d2fdbbbafc4cbb528d5d17059dc2a6ea9c4e2dc7cf2660d45bc71834dceaa15238f27d30ed77bcf582e9d1159c706a9e487ca5c4286f06a723b0c0e4cf2371c520dfa72f83c9d6f7f711592e95873ca1de6fcd63e356b4dd92ffc1cf6c0834c382f30c8de4e81c2d6d9280592aae4b1dfc4eda777c32cfd0a001ca9ba69fafff0fffc274de31b5a926196a602850afde9e4ee3d70d008901221e821ae45bb0158518876a7ffd59b777cfc58171a249615a4b0a3d6f5592047c3d1c8d062c7f683f8392a19c7f14cd090eb32b8ec36ca5a04c19b41067dbe1242911cf1d69fbb490fb4563e6914c935dcc65f8252963055283ebc1e092e550f293837e3332e6136d298c05bd4fce3033aa101128edb87d030919a921f1695e0eb722006e76bf51cbaa5089504ed9c46823875139b6e3f3630064f0fe220dcc645a9249ddbf10a5210595e746ea11db6af0c9c5aca8679aa928f9f32ce86058f0a4ca5cbd899b396b0b81bf3ffdec5a13e1291adf4afeb6e27d39867e40e88bc8bfe533186ea7ece85c9e3c5fdc6a05540233f8a0a89aed0c02fb2e6b7e6118936b6818e489f8317ee11346151898af63b6f8417bde8c67527d4231de1d5c1ca76c4489ed90b56ae123fc941b3015b9c68849ae7a17fc1557b98adee61861e278a84e6417d41b380deea466de8dce841a589253b09afbe6ccde6c33e369e2476c71d47a42e50c6b9e5c21dd3c403fa7db503231d8852bff4d15d96ac0f6617f58543816a9a5f5b7cc28f862d5d073aa35010162def00614d990f51a80acd0c51cec3f7d262f4700f89cc92f3ef1f59c9512e5631cd4d772e0171d30b04928aaeabd81f14bc9ecae0e0d0c06ed406a36a608db739f4f7ab7d36a2710d9434ae66f95de5632c1fc4d6019b034280454f04fbeb6f32adead6dce6cb2fa87573017d379f9be3916924909caf2f5816089c29d319ce2064a95332c05b79248d7cf6fa3c8217acfae94289b60d1f456d66a3418b00121df1c01c92d00fba33932df724143186dae13b7917ba7799c6ccfa3bab22a1ec0da36eb552b5d53bcc3bf55a859ed7bba753f6f9c9c4bfd0ce6ff1a68f05a4ecca4f9bcf0c96c6ffacab523fda3f094feaafd5d1497f9b531511351a7b230e0f612600c5b8323ad867d47e749b562f5f9043a1398641ef218899d75fa1c4a8a01aa3049f37e55c2c6889ee2e204d3831f7caa08b187c89c1a196c946d5e08c9871c7b0a724caa5f999e40f7e94ae30c7514b35916c573664fc9d1adec06ca06d30c3a369a9b402ffbc876c69a3496c101ca82e331ab866ce97b99c07251c867ce2d8207815830aebb4b9e7d642e9bdd9f15394a5025e9acdd4c6b99fdfa1c1d2ba6f79d4afbb3b6681deb81ee0898939649db66f0621e798a03cb19bdb5117aaf47f4b979cbdc5a6b9397fef200ad1585fd25d9f072f044ee0e315719ac7b89215c75e4f8f0b130e312efdc00bff0301c701d3f86675d9f1e5e48614dc69ad5d96a164ca552b7d0f74d420c3b00e7fe782f0cf3e549b8218d8a3a3a28f8d71c90e71a69a9483b515998c24019c4e332ff6a34d1ab6e92880b876eb1252ee9c6c5b104a0e2f090f5c725e7cb05b27d9b9f185604ac3883a5e4e3a98943de051c31183add4f027a4a8c85f1b118a509789b95eb77bd5ca89bef4e928206a27fd708ec23b8b1873b6e33a86ddbcc2db26ff6c08b0a25f2911e6316bd6785b87db7abbd012d7120134bb1e7acb393bedddc57711742fffe0ef2709fe370d4b3bf02edd06d68150cb8bf9208d9878381029259df356ad4fa39a3cb23936a444cb3c2fe6f5852338cbd5f6653a449af58e698a8dbbae62b402c5a62d3459ae7959c3c29df271bd92795efc5127bb810062d3d06f969c7c7662bea1d8c030b565b278267734c6e23ab5b8f8fee3fb155c6c892ce0b50d71e4422e7a7c0c4c1cf3ad721f4ae46d2b8393b77cffb3c5dfbbcf3d99f92853f20092f3dd7e1af169fb1123d74d3c332c9e672c8a463aea8c07cf3fa5cfc849e3370210f0b36d4e90f6a6ee38e66d6cf53d572074756f83d56933fc6a4618df05905c5338f17672c512d9f626c93b9008d1fe42d4a6d537025bc48333ae22270829200377c501aae4ff20bff042c61b08fe8ffeade8b04a8471e215b45c91d1195076f7c2d4eb07778e152a78d49c6ab3fd61b8f94c83ef402cac4482d809c579719b751a5328ce5439910d828c0455da709079a8850818a825769421fbd426bbda48f6909234e88fbe08e607a65a00a9b2e6ab1ea09b3db879cfa1357333a0f8d7bb947190a98fff665f54b6804038f0f875439b884b3def562b2cd880f7835ed47f65a36105a6edcbc89ae4986a1c3d3e6032b196bfbb16c0caa17a02eedbc3402f51e0fd4d9224e8c73ff8afd442747537873af52466a4c4b01e85b9532d114421786b9199298a3c28cb18b3e6252e3f7fa444956e802e124bc1aa33f3ade8125fe6e2bb9a332c34365d6e60c79e4ce88c424279eadb15a8110f05156a154761297020b55b61fa66bbc360562475f1c23bc7dbca51910df45ad7a8882ee1cf90c09be6fa19cda2cdeccdfdfb8ef15b67c50cf76bcca6fcb7cdb8327ed9ac56a78219c0bf2d412d5b8633c97c3da6c6163081f671e6abbd88ad610e217c8361a5fd96a0db7da0aa8da827993000b4438a5fbf40170099efe5138265c2a76089a6452b072dfea36f9ea020a516f11790c091f832b7a03d243b636c32db6871f6b828588e48332ebbd2e04ccd966d7bb245773cd329fc99141fd394ea13de520513236cae50a749a0e27d00dfbb2b3a5d8331d865187ef5d11a27cc4e41f1966e602858726a3b6b1131c464040be9371525a9685ef2c4599ddbf88ab0bc6f6ee52405825b9714792d219b995837f6e91d3ed3958c04080d66fe4b0f0056efb375c59b20519d78611df0a69833b84092fe15ba9f60e0f17eee624645af8f0e351c1290dd572c9c5980d84e192906e41a1ed8545320bb0d03e38a2c73aa9bda61ac2b198e5924f9af8ba2b9c2f609b3cc6a78d428b8d3c4fc16c00446a25921abbb0c595707921e8d2d670820d933a9743f74fe9dd9db6c6d02ab0bdde508aec1c12f91031667bb57a08630c540de2b56ac456ad1f6f5e38d570eaa6c20f3ffda352c0e8a67febf497f74eb50c5cd9f33afdfac1ba99fc89a9e5180d1e22a790ac4dbed91eafedcaf827ed399d2b35bea6e236153f2278efd2fb672498c744c2a2442d9c2cff007ad68a2b50ba072cefbe5d2819b205653585603bd615767f2b0a096e74dbcaa2aef6978cbb83af1d93eaedbef2d76b24bbb423885d26ea54f403437b54f06f3f18f34260f987e6c8c2058acd137c6f2f65c5cf96bda5f7a3de11cfd62849eb7a7824811d81790948116bf7ed0c0650bd1143258f969850579453dbd483c6a0789a4655e753b58ae0fbdf2acc005fbde62c1ce161132f2553d419b8ae3d5c769a72adf91678bc1ce0da1cd5212cceae6204b1bc999eac5680163c8f553019514ab041568f1625a232ad1ab97389db6631e224450cbd6524c5cc65c75ee30f2997111055cc5e8426381dd22f3bc20eb5ac9ca008d3d62a02cccda014ff16b22b5bfbaef09a800454cfd905fb8419db523c2524bc458f3e9d1a9759cb9a9e2247a4c7d4ea42eff8398fd48f6c1ababbf378b2d21b0b204edbd36d782db2d1817033ffef2efabc3ed2be1cfe6492b452182022c100dc4977d50c557539a35ff7d93ced217b3fdd77de6e2c8f9723174a819f391e7271717dc5eae167717e6aa1cdc93feb2ae26ea02daad9dccb735fa0875919f1bfa7c56422562a582f85d2f1b8430d5bcb09acffa817c58a2cdffde7ade009f21159ebd8df209314b37418eaee4782ff2a1e1b7fd35f774d3f309a33b82c6f70d6e9b51f496bb8fd17dc8b03270abceac75504cf0d89b7f276e75987117b30dcf59e0952c81d03782bf5512df143a33f6ea2c42d76a1117a0c9a676761c26a8ea668c3489fa8aefb0914e0a88c84c2c54e8099890bfcf4677941505fcb39828937a87e4f5e75763e8db9f386457cb562543cfe204ae008c3d70bad53d00a226fff4fdb8e737706f74992b6e23ccccd9ccaa7e076a127df054e642248112758c60a816a49fdfd8591acb39c41dc09c4e0341ed808184c698597913a36d0ab4175c1266b9b6ab39ef145cd1ad6a5c8b331d2cbea52e42910cf76c3635e08055af393cf2ec2c8203b00ad046363da8424a4c55300dbfddefac3fd1950b5a059aefbfa13ac0561ff729f0d405d3b2f22ddc1433ed71e8e5e89f37750a0a2355d0038caf1bcca29882a6373ec759f49322aec389ce6f16d95dcb5ec93ea7eefdf8e9089c3abd3aec7a3387469e276f96a8aa6b6e67369a63ff6cc3c85ea4fa921746a6f19579f9e37b418605f8d69832a2fbe84b0f3907615f8ff58b86574e3ba4444f19cb94b2e31f5380b6b4de9ec75c781bc44e5e9e71f19b40d267c9ca896b07faaa436ad7c3cfdc6572a135beb1390dd68cd0cbb0e97802fd695f7ad4e5b9f3a620a8f4c83568e8ab651b2345234d9b8e5c7a5dce71f1f9b0ec475751c9aa6d1fc5370bd77ca8034b517b95010efee31ee63d5e30a0c6f64725714e8b6c8b0037587e0460d913f3704eaf35c31b5b26425897f0c17cdee40d1dd63a4dc869b0930a1e4a11481b69e779dfc848652746814bd3846f141e561665584e80e01d61e60306561802262bf5ae10c1e1f0c85a39d7e1c9af0efa1b04e99328d8907e09e15e3e98d8d0ec123558e901629fc72bffcf3229e0c19b27b6813d70e97f838abd5acbfa2e9b263eb34099237ccb81e2961ae90420e706352a1c2a1868ec8a588cc90aa274646219340be9c3d18185643cb4e38473124f166b0595a26e16197fd05a4fb9ed62dbbbf53ab0f9fb2e6ecc0246bb9c47996df1d7036706f661ac2d08bf2f25c526eff1baaf3239a1b857aa7a828013e906c0767e3e6f07fc633798a9d72e1ab4e48c96467d986bac140c82132277c86ad61590135e8eed6db3adcd8639e66369084d2a2c5a20f25f26b1a2a08f2ba9f1a56ac7842995c1ad7eaeaf0d421710f6d74160e731921df1e09d34b847713f80f839e5f5225412063f61adb6621fb73bfea541e0cadf52aa9772c7880e830a6777de0a33650a07c6cee2d956145a5de0aee59e88bebe81693af688b587495956ecc3921e68d91a9ae8c388d8f94881f45002695a169bd5004e95942046eeada6948a04e5ea0769dea26d78bcc4db8077ea7302b9386a26f37e5c989a77b5bf27029d962c721772e2a2a33cb946a40a589c997937d67274dfd7c74899fde2157ec9a69a46adaf9c58d8e37a49865b059253a93b86b901046e703c46528a1ce165248f5022c6b426133c467382824f2db816e95c086fb92ae0229feb07469bd379943558634fec69d3b7a0d0eb3988580d5337dd82dd61b281573df4104d15602c73b988e399967b5f7fb1a64d48cbbc9a66eac259d8ff8301b6d1620b52e475ecb4c2859b46c01e77f7d6b3278e9d62d29ead783cd0969d3de33c65ce19d15f393020fcd3897553388cd79835e31f75b3c6f47041b039dcc72e7c639b932b220d581b8e8a8eb710bf5e7b74e98c588209ea7716ff8ec81721852da7d929e80bfa40472b45e41f0bf4efed334a9964ea75b4c9f130a5743390fd1bfc0ce617249904f295920aec1387682b317803ecf5fee8269388b82d6d5050526620591c3557ac6406da06532024b3c3398c03394c72bde6cddb83f687a047577200218aa816533c6b3c6d238e444e0f763992dcb21590881b4cd84023ffd8da868843e93a756dd766080d73685dde41f64cfe6fd1132ea42cc11e5c1b6aaa275921da1641ed15d8521e1723c1ce3f7d106365b9a0898cbdb0f8f06eb84d739b11a0e67e447f91af0ef829b78d581d3580910794562698953b0d150a3689b1e701af2560c8b328617e99d52186d59d3dca9b21a96854fff17dfe1842909b6ff35f1187f66244a17ecdb833b3241d1734e94e9a1a6219f3fa093d0a213394801b13ba9cdfa63c384d8ec3b9a90cf1f5692daf264df9192d2694df8277f64a9a5241dfc92199b9fdc80ff68c37636e9b295a8ebdadbbc973496a41ca006254b66db0d71e9b713a6f86c2c30e50ac49d89aaf79d2b008605ae3c56ff43913fa6967ce9e08d25ede628cc9cc5f2103bf44496aee3f756b63849c9be1698c84b808b43c3d9e396755d548b637eb3d984f8bba32046c5672a3be1a0f711f674c027aaa1f5dfd930c907b3cd1f8deceb1bb317863bd8f366c36f37059ccd2294947a8f643cb195b355fe8e47ae38eadd237157d6f32a9eba923a3d57f2f4e7dce3e58ea70600309778125a1d98ee6092215192d712da83b4bdc6849b9fb46e2f7a651f48c758fd6b7b70fdc458af78017560c0d4c171c3321834f4692068ee3e12da86bc75a48e53de95ca9ad91f1ffe8f774e6058e0271d5586d761951826b098e8e07219f04c2c52eac6170ad97259cf7551b07dacd34b54ff8fdfa96874cec3201996c7703e2036b971898664c5f45412161ce906143d1f30260b71529df102fdea089ed37743f978549f11686cda4cbd4c830f9f98bde64b0a4a70b994222849cd905ba365d749f08e40be08e4753d1210c641c676ed868143e574b17050f871ffe77c829415af9cc93917881bfa4295308fcbe972a4a14aeed328f40e343ed77596b3a09420478140fd009be4f801f968c587a4bad5d44ae12821b18b21571e1aadd81832f1fe6457332f846df82686886bc86b879333fefdc9196b15f5b20ed767798e3b33d511120ea363679ab0893f70706cbd671cfb4cf5a5cce25b31f90f00eda2b7d17aa5ae5f9d4a2af3949ba7de39647ec62d286da7112d5c9bb3aa9bac34a65d94af8a7a84e789ce7358cd59aaf022a5d99efc5ae7bc12c59ba1859a807f6b99b5ef02752ddd79b59ff452a3ef344feaf24c147aa845bd8fe7d497123a7444c766e14926686446564da2994f7c87de71088bd6b0f03a00de1a018bbc56897f86648be45bd30c1658a12a2322c5a58594b204274efec57f53884717d44c7fba65f1c0824b1ec6043924f0f747e4a32932331514dd897e677eac8b0a2df34f4fca5f79b0acd56612a0149349beffed5d87f44f31d37aa45dbe5c7305897f6b232b3f1e867ab2789cb0f338fc087754211806218d914a605f35bba4d3f120d4375897654ad33b645142ae29fc3417ac6d352160e6299f9974032169b87a0253b4f1bdb3c0861db39a05bf3c3d00813b470b911eae8eba0fb487b3abda376ebf2ed70b95e61b38a2bd8efd4a2c0615e03a68fa5d3ce47b3aa299955d6cc84790f4c650aad01777d9ab436fd42eadd0639bf5af1c6ccb4434c64d08284b8a28a0b9d1662910324c13a3753984568a2d7196f554727ba7aa94ac04eca831a92dc356392ce926bce61fd6137ce136f72defbd0ca2b8c6e7ea5c55e68a46b4d8278102ddd1d09e1ce02619246ea77e157665fc6aa081d38926dca904c381a64d8bee3bf3ba7eb69e5ed3861a725b344a92b7ba4f978f4d51697e0143e45a08ceae132e8dd8365d2469c79f2bc2672a301ede54e5705d46e8f56df8e45132c2319586008e459e853110d8ddc2706decc26ee059ab18e0e3b4644e54806ff3d042e1c66f8f5693ce2e8bc93b90cb76cd941c89d1d89ffad089c4794182069282f8bf12048d20240d60e80a1ebd99bb3329bc98f5d6a6b7554deb8e5dd1daebfed828cf867a507e671d4b5b1087511d917c614cf4c1abc8305714221151b49dff0ab5e5ffa7300f7da94581f0ab4d8f2e6955663d0f79e1a524e1babe4786fa9438f2e5ecf6b3863d82b521f4c835429e1ae4b1cfd50194e00e3a3d028a36ad1476139864919de83ec9d2136ef1028f9a2b8a4e747d172577e4f5a159a59ec369411bb8077c19409bccb2be041cb54b79598cf39e6f4136c9c4ab1d4874114d2a3e468239565b84ac832c519b614965fb0f0ac03cb800d82a789819e6b1213cbb31fd440cdb258dd6f44d8d4c24c5ea8aab919b79b3ff83ff943443568546e10bc528c27a657fdcd6ce07061ec44d1257ab9fe5fa854c6ff1ee659b062fc3f248c8cae60d0e86806ffa2f008caae96cd8bebd858f93927dd6b110f0c39c6de4557df8ad8f9de02af8dbb5690fcb5d8a718c501c0bb14451b295a91d1a4ba9df0ad79f2a9bdb79223e8c1d5f26b62163eb8508f3c3b26cb228a4882760efc6edec9cbac4569387f75778928f3848f1a9406865fc179b2cd00109eace2e2183ea9d72ed14c45c360f3e3cd02e8b075caa382e99fe0dbc65103d62fd14e5895a8f95e725523dd40087984ccea19c7b7ed8aa018d44937a71d703390b43727b18f8c48b68f0456f180b3240e5bb234e996413f37de4793bdc56da0d0bfa54240242c17a29fa33f3e096157709a17d0e666253f11dd71c65af5842669378413787eb26187383ed1c295f621c9d6cd18c88f5f89e150de1d72edc4ec587f4136f34f0238f54328aef4aa818e28e7b04c0d47c99fda80a75e607f35a099aafe868e4f15c17d9d337555c55ff55d68e49e573ab852d19c489ce25f5ca514ac85321beaa0368a41452c95d715dd6da6018c08ee824fb31deded04a6e1a4058c2418455d9c4268fac1c17516422abb3cf11422322e512c9f64f6148d690eb01700f02eefffca002bd78da4a031da59ba984dd8e6d05a873917f7e252dd8af9caa780173bfa7c34904629f91100e31182fca419278f19c2cfb1343ad4986114b480213def8a7d6a491f333a2835633da34ce623cd22386280c4f3841cc8ab9f6b65c1fa69c237b512210391dd9dbfabe1adbf8d2193a5307bad8195705e9ddfff89a270b63f069afddc0aa0f7773a26474f643730324e32ea26e131d115ac6eeb3a50060e3c598d003b7b51466837b1a0d5e6373ed37a2e3f893c0129ba9d71cb4993d220c158c3a4f8bedede0bb84962b14793e34996459eab6891715bd513d58ced47ba96bf97cc55bcd4bb27dda35deea87b298c4bf9006e34b70cf7898e9c37ee20a33d30ea4405373f87a0caa9e24af3b0947a7c0826e50851c0e0aee596cbed6a93c08143ded790ad8a41ee2ad3130744e233644a96f6531089be0ecd2dd183cdad9177eac184ff2b430bd9c44f6024204584b7792642d756024956f7c77adfc1f4036c03512c230c0c86c29aaed7ed9338760bcd37819a56c3d134163efb6d3df84aa5336d4b1c53a705979c961e22bc9ebcc89505867577978d10ebaf40413b7a46b41f7d1be77471c89a3f5f84d96ff69422b905db61787256e12e6a7c4f4c2a90e932f8b1e0594605ddb2757dd779d9a476ea24b3b78985e0d3f79bb7e9e0a8eead3897cc614af8248efc29167089b5597b477c9bdcee871761f7233ab9bc4a49a8726b910a307e96eaf14dbd0f847e04254038e08896cfc741ce6d1d7db8e3802cfd351f5727e2232110581c870de46ab04e1400ac57c682159d2366ceca66a617a0e13a86f28118a4a26492c6e80c9fc3c51e64baae4271dd22e8d582fc3540003a73cc8d97aaca63c844496206de8510b48052be1d162a05a8049ad5fe04d54aacad92d762a9bd6652716b4a9fc76c3ffd0a7d3eb6a20e3d5bb9f648ff3d249ca8aadd02aec265988ed3ee50badce8dda63bf3ebef3c92f651ea0f0dd7f099c68d0716d98245323b6600a05a348b670fb9ddc0e622a0e7e6abd6cca8a4d953262ea800f5d860ee8e60f1c50de9f3b122d08c22b77ecbacfd19ae1c48a03915e9baa83f900f6e436d14b8a6ee213200d4f98afd5c5621d1d19407a595884fa9849f48005400718b42c14dbc706698ca113f155fdc352cf048e8d2c348be97d4abab8674c530c29eb35a6413a2b0d1b76ddd12f5f4fc10cd21dd8fe640fc1074618d73eafa44b3ad8b1d4a9b04f9815034ec645cb21e71f2ec4670a8a0c3419bf7927063cb72b506e0d4d91fb61d3357457ef8892e80cea527fe38d9f8856dc0e7ac78e520fc0d0cfbd7798f4cc9a3aa5b3ad431262e30c36b3bb118928f9c87cbcc4e675e43fa924262d831f1f5d74dd64f74a26cd4450190658424a35053b7b0d688b63888f23bb1391c9c17d8562da09499d34c9726db7587360d8657e9684a725f470a5ebd3a8f3a453ac67803da1dc96ffd8d715068d21829bc96125be6a19120214f7abdbc0a8f2410cf078a7014d181eb0a292799c061b61194304be584d912fc026f8f59a5a00969ed8faf580739ba0e2cd99993d34b526d25153c045a5d0a97251e2da1be7e638d1130b3ca8c26669be5aeaea450d8630622fef32b90072b01e2094346ccf489d32dd3fc5396ca5c3f9c89109186b1cd5ddf42f31c7d01d3ca583f26a8cc24d6f867f05585fcf8c7e74491d69dd4554b7b202227e2c414bc0476f07a6ce4a223358c2cd65763864ed94225f31c5980aaee7590d7345804395d19310e988e282502497099d6572c5d8f983cea851fd92e0a9fd622ef4b35e0d74a27729b15a674c7ad78d43cb5b871590840cc52b986cf488faab4baef0d45ecf569f9e177b4c8685c9cf5243ba3ee1c242f0080fb0dc9d5c4caf656e8c451d21dec5dca990be2a0cc62c1a7846f43e6384c05f58fbe05e4c272461e35bc390935a7cfa167b94baa4a95fdb87e0beb61feaccd9045f7afecf38c913e221698d5317bce97e4bad6deca041eb11dc63a889b1a77e327ab4e0611accc22480ebae4ac357275709cc0e3cea1b24ea53033698358aeb22d64a8f73c21d918778b5e7a4be8d0b852e8fd5ef739ba970d03e06f116373991eadede7a6ab8a1c50998d92ce75091f221d5a276e602e3730fc3ef9ab9e46a09b3f3cda696ff0a475c81309ee6b7bf3a71be49150fe06fd10daa61ffcdb051fe266177d39b692789049e242c534a01afd370d6d295ff50f57468d8c96e45884e84a1edd2e88914367bbab96a758b214afb689d2677937f1d652e0f244e98b1a1c156d058a7431bb30567e2178cfb2e2918c2bf5fea78bfd55c9c26a75304d1cbea9dfac871a85cd9a4b414b75b4324bef34a52c79bd51e9b1ccbf4c188fdd4c84b233459201a45b65ccac5443ccbbdd0aa1d2ac1b0ff17eeafc57d75f0fca1d752543663cf09a8d0fddf0812875a3557655f1e6bb7a1d10f30576ab3d583f20ab12c049547c524f4b51b3456140aa1b10903f7d4e2695a25e4360cf3c09d2891de079fa2901fce1cb2f3a7c83b563e0261e75c0eb00f02ad99de62ffbdbb829fde761b5bcdd7fd4d070b49a21e96e35e0817f4993a759d343a00f5c49ed37ff21225dc483ecec9838ec3218893ce482679371efb2646c0055876c759a4d0c5d6f518495dc50dcbc2a2615beabd15698f3e2ff467acf971ce1fe15a1fab2fa312850d789aee7802e9ccf08b351082e971624cd5e6477dbd26ae77e60ffa971e57f79c2e523612fff5012d70477361fcbc431566de6b85433407f19c80b465b33a825cb27ede183c3acf9829876e45852b042057138c37efcd62982dbff6cb34b933c5b8d2036ec2460626a666a6669f79dae460562ac7da411c7460697ad37709519ffdfed3158b9b9f200245a4406aafd32ea4a548e903dd5c3be614c7994f1902ac3eb33caf5ea0b9c4b316c4a96cb1a08c8ab7509ce197d2d940ec697a1e1cff328506555495af6853f846d158bc6d25c06ccc3e6b5784ad1846cde4726309fbd65536a8ec4c1138aae9405c4f9471e6f8fd64a3e429d94c1096b008e0eb54667b52402d861f69300bec7f50df772a46f262787a37872ef610e1b1b6a984f8795be4e79593f17975ffc16a4d6748eb376673e63ce1911ec24264517cdbb6af5280de3c9cebc2c124b7f1c066a02cb9fe14029320f312e88d4a0e97b542c971670eaa25b5ee7c78de0fa08f1a3fa5831840c1b24529c95eec661c1dca9d98cba8153f12a820a65ddbb13ff3b8fc2193021b4cd2a0b327c8c08548bec39886c384020d7300c9dc2bd513979613555172a09537ae125e11bddb97f2f6051947791b8ed9c5f5e3839472ec4df0fa88758810007bcb2ee5cddbc4d6e5a1d316fb6063d919250d9793581e5402348fcd9b5dcd9ecc03d7b26e1de9249e574b647604ef29f63d693dc7e51009bd0111c32654d091654bf9c8e40f425649c965021ed74c90c205c44374cde0c8651ae2f0d7ddd4dea510555622020ee083fce4d7ea5a2819f30c40a5bea5ff524aefb6202f6276958ec57c60c74ad582f34ba6a7eea7f7ed914bbfc94445be0942eb59ff1897ab29fddd7f8744fee9d0d505cd70e5f02c02ac056126d5dc0d9d54a70dd47adc374c1e852e8dd8b97d11b6c66450622f7ff985a350c62ceefbf6f91ee592dba0ff0dc274f8466e7de4021e7dc4be8047f8366b8bb795e41c97b9cb698db20e4ae5465a018c171b9ead9cd8c9f334f8bd3f7cf56d7095888d191cfc0e68e0edb316304950a619e16b5795254a5908be71c251a32a0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
