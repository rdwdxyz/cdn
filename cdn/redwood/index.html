<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a160b37a8468f0341fd16af76444c181fee236dd03edb3b1e2a9772a234a20e5ac5afd31287ced9d18ca2002811916e46a309a03c8e55c788d6424d3a1c4d04734e443b01bc396d4f0b25ad0766d0bfeaf62d0ebb4dc771cac0a255195d265570b55a598b1eda84f8ce3da8866975d1ec48bf24d15145e37ed3f25bbee7af1120e9cf773fea5a58b7222127c8b31e363bec25e1bbc88c2d664f3556af094f9ff3067088d4c53bdc6b04169c2c2c89261fef2ad981e5b4fd49ae481740ffea2f4971645a43fc9527aae58bda847205d0de5a069dc5c3efe02689bb2d880ed241ff9683584abed96151e0aa9e2bb393550972afc39b67576049633b35c9abaae5c3cd04b351925c68183d4dc74feaef8f3094190a2e4be72476a8b565bbedee1f46797312a1ad50be8faa633aaaf07a050158011fd8a82d405a085d845d2d4be8ad1a2c6386ad668fcbb60785f3418b5c4b4f1225b0aa68a42878cb1b7b6970b48fe57f2aeded183614d261c8f41d13b08a9bfc83204031360a2b78d3dd0e278fbbf68358180bca9cf953bcbce741d602dcf01bf59a5bd7e672443592ef195fa08c495f3f9c4cc7cd39f81c914e82c2a17e8b4a252ebec3911431f81a93af81614a83e4efb5a9feb30f15c1b23c93b87a82a7d0b451eb0f75edf280c27727b930302653a4ce139e2e234d92cca4d394ec5613354d06d7495c48a9f130cd2d7abbc2bc1babcfac1c5d90d0a54078a7203a200ccc422c49a17f81565628300715c693979c641efd02f37e2fda01ab2c51e3c8f8d377ac508a0657ed85ab52467cd3ad9f9ef8c63f18227dbc096fd41fe612a5907d3e97d151bfdc073314a58700b6ddf3848a1f846727f7a3791a21dec49c29305e6bd24c812123b501f9457cc57563f32b0d773de33be5198edf19d64b9e6f61e0a21c90470ebb97a53dea67a288927b9799db2c09f6034b289ff16e8dd92b3f32551ea1ec165342d00b8537aebddfb534433f23b8f1de9f15c1e248eaee2b7c3c15ff23a8d66c752a60512aff0180768946668a110a65d5ddc417bcb1668020884ab702df842e4bfe0f6070a702d4ead0c20173578408a8ee856cbae056e5be32eddb26c90103dbbad8b1b14dfc8ad3127e67384c3f2e6450d6a975e66fac2f1a37d5b9456c32f0ca12e52a2a251c33a4a231a3b2a50781568d2c1a7333e77abeda7fd575a9f6bb3c7f3481621b680295d5b2b19f94baf03bd77351e521aedeab28640fdfff95859ecf23dc91c18bbf37ff416c269e33b80549cd1bd130cb43e4f7340f61c1ff7f8989eae6f17b28e86016270f7add77e7023d1bedf22e5a9ccdffed0e2ad6c5ffbde0f62896e88ebc051c00a73fd4db72dac1f424340d92aaa8d1a491ae45eaab3a18f2f7a0eac0a9661576dd7f10424bdd9818b924409556660c42fd4382174c5c230c168798b6ae39bed4ba5162f175ff8d92e62dcdba3713f96fe0c5a6e9d900ddeb7aeb43d7f2ea971b30a4e318f53684628a42e6474c6c6c11847aac8bbfc7c0b367d344dcf3aee72ea20757d5d2227e544c237cd55ab2ad2d8c8e80544be15c0287f790a16a8ed7226879dfb4d311380d5ab1ef708ed2065f6aa5379e5244fd63d39618ae3d26b81069b68fd755c66ccbeac545107126c6ab8d6c817b4c38fbf6456d65883a2d862dd90d6e970eb89372900ec962e2a7f3f0caf1eb252e747866add5aa4182f5fcdbe252dc683445cd27fdcf97ebcc8f579c8ff49250783b561b19847eab79dedca404b3d20f5334f4cd0da901ccd8704548516ea1352524576ee56016f7d4892c86c63e8af4618414d1e725949e1eac87c563400ba45ab1190ab800cb245bd3b7efed0d9ab370902c1a2d81068910e84f875924b12f6d319c41a9d66c55e50c5d672ebf852156153f748c53750f6a9a265c27b8d845a7ab5f706fc099e0e7ac3a6be472268a73224c94e03b6538b4d47df98e6080491673a8e77976523a7d558189dd41d3829a4646a56c7693bbe5631ac5644afdd994109246c56df34e32e319e63ca308643fb514e93da97b1d8a9dbe59a309a7107130d6f8f206ab644d7f900a9268dd3d19b830e18469c9559fe86b0059ba419b2369e7bd20584baaa3298cf6747f824ff71b900259819c9727b33eb2ecce58d6c16331d00ba8b1241cff21ba8d0da74d5e79ee75c30cd4a54b69fb507e061b6b6cd0445231fae4d5056a73248b3eb94ecba3e215447b5830ca6cc7faf820fc496a02f99ce53a01f897b262568e69898f6675987c93d7a24f59460a3d6777584fcb415c23504e5aacaf66b8ab4f789e0c38c9f6d04c1766ca977890ae6f7d86977b21cc9c44dc905b78ffed70836500812aa5f5c23a38b9b8669f7b7e8e4bbede6b1e4e27ca6458d8f31194cfa65a3149ca4e193970ce1860129b3517483e6192e45bd367294f13000e4fb926885b6ff771cf1ca66bae81140c3457d8581a552dcbc6cc4f611319d32157c3d8eb6945d5d0ce986cb19c952a50e42f0d5c2e9083cba4b13f2e5b714b089a24837a4f1a60ddeea6d02fabcec157fd75b418e7e0f6c41937cf7cee24ebbfc45af1e30aea5312ae39302c5c3358fc3969c7a5578f2a07d7959492bba38a18cbcd4f75853a4365d39c04c00d02ce5a6be7753aaf9718980ea13e81002fdc603e745e5607f254481e1dcd3bf0da9fc4151dc0b80e97a7af19a5c9a5cfdd58b08f98105ac7ecc56921becb30fe54e5505f6ff47e9e795bbf4fb1a7cd5b6afd92ab2e37c533a048e2fdd5170fb0152cff7cbb6a81da66981f1f36009809cd444f151ecf51120b094d138a2c9aa8465f99fb3c730de7f8132d3a004244b4079d3600bce5f87a82f228deb037e5d3d336dab28e49dd6ed0432ba4c9664930726f4d8a239b831cd557d70f9a698b35cd9c3c2df154e87182559ffe4ef30862dcc370972a593d9b56f34c5d3e27f3f56cd2ab4e9da5c4a30afb064cc1984a3c66499d26e3be3c902609851e0db0d36afd654a5537750a56e2a50b584a821f747a9e4b65cbd42450dab1ed1225de3b1d7046d4daa63f237038c87ac4358ae3d5aa5f3b34f36fdba03a2d0ab0f348fb754b9747651b503d52c3f127c18d3d0447e86719f230273e54176e783339dd4eb0af3790730e7373417e613584c0420fbbcbd66c8ee7812cff1c0ca17817ff2409bce7249c896fe949608d6c42cbd4d1a43e9a35608184612906854c78a984933f92068d8bfad6813b9e113f0b8b1c10bee0b312c72ca1295398ea473d70519a128bbb45ba79797912df72fc598bfe6887dc233b7d4116051a3f862c57c3b6c60cf7ef2781fc68dba2f5e51d71437bd0fa810c717d9d069489295ee77199a839ee1f3447b0bce40262da752541b05b3de5824da58de10fd197dcd81f57e3a6fbd6f9c8c004a62c3f80b518e3924a65714ae0840bcbf8911756d2e19449af83ea3bb70ab1f3d838353fd8e3a2dfa82e689249769c25388c88b0687f77a8a897c7b7665ad51900acc09baa80177c9dd20ae4adb568168980be18fbfc3bd6848ab910f4de2f67a82c20a3ea4cbf676418a2b2ffd4ebe341fb7881c7fd124ac4a80589eeb239214b4b2659aa1cf0da7de4477cc9358eca8ed4c6386964ae39c1cf008cf67e768953fb10389951d2fb1b222e37105d4c4583ae965ebdef3c7712fcdc248cb841162829ad2f3a8c25d9d3b163495456107dabc721354b5556451461dc89797d568e31165c32428ba89e634efaeed1faf5e40595e1ae68ddae8ed2eb4d494cd045d6cbe429a3ad0e9debee36f269c17fe7d18117e09db6cf948408beeed80032a3a446bb1f0c9a00b45c3a248c3aa67a6520574896d9df3dacce6158bff8eb902a4b97b49f846d65cdbe2e9f444b90342c46cb6a18eb16de5d59f2765bc8cccfbbf169a9616435279e0d8bd5904541e0a5901a29623ec177d368ca24f5615ffd75c0b9927ad484a8e7de225814b30fbe05062781f118546a5baf341a9c9047e4a2230f8c3aa2951ce8f0bdfa4c3066bcf25e569add5d4fe21fa2d328efaebd2f59a613d16d8eca858563553e8861ba2e7e31fc60957e807ebdbd07b46f6f55cb509f04a4a8fa6acd73a948cb7e5fb74a371785247985ff8e88754f5f28c529240559af18f8bd3720382a8c5081c4ebadb51a7384a1c993c5ccfd6f2988cc40f4e4b8a1c8577ae15b2ba10c392ba73677ecd48b632669162dcee0b12e602c03a9d5aacddc2399a4f4b54d4c2a604c0fbe682d6742a9bfa4da5f0031c56abba75e4a1f06e3ee32f1ee89d3ef526d65777b2b76c6e394b2389cf18587963266c9deb56e16725124bd0ed665a7d2cc7c59ab014381e5c49ba2a29d9ca388b6e43bd3f9df42716b174a6e6386807b7f720e08bf2f8a98f507a26c32941dd6922bcf334edd3769176bdb156a4dbf9200ba4b0faf4da16554e494706f42079ec39940c7264ac6f5061c74e21b8e8f75318b452f466c6e3f9e79d0aa8c2973c9399f0ea32629f33e3edccf2978c4bd873569b4604d00448076139786435215b8b5091a80571541c30b0c401fe964dbe39905caa54061af20b51ed1df9b0d44f98a5ec7819318cfacf067c1d6c0bd27ea290d968106d96f333f492f76a7ec168d77f127ade7e641affa720091e1d99da0b9fe11162a07fe04ce9b1a1babc87431c0e1a0c6a15db01fb49cdbaa5062d3d15f34f46b067a2df2ca7ee02233363e71318ab46470fa75a598122fb892ac28bc4303796f63780b7694a8fa24fc2b3b67a7db1be76856c97381f9e9aa1298ef79d7574cad0a7981ee6b80812eb681207d8454ecc4db1bd3325685c03ad6f0532985bffb662a9e502a3b503e7736c7b1b89e5953613630dd6591aa96d239ce59b526050ddd63565aa1e38d904193054f4b9349c0405ae59e299287e44ad8996d54bfdc74a560c81a8cb2cc338796dd84c41c9baade875d9634ecf6683a103fa278f485598544936dfb59183d2c615cbea6fea1195f30682f44633f685357eec013cf8aba108b7f95a24a584a27a726f3de0ea48a3f01c94b636d2cfa7702c46f3c9f12e00870f4bd54f52a636645794c73ea3d7812a0aa49c366eddb18e600887812148b7b7f84bd8edbeaee9ed378c13b16dffc8ddaa7f92dfea7ef9873cd313616be2aad9b3c5dacb20d59c5185eea2c5a585fc8b8e1f2656cc4a3ea0c22218ea49e03c3bcd0abeda36fbcb120b707b17e27b225003b69543748603363e6caabac51d1e2617be917893f9bc375bf0220f9cd6d66574a0ef96189236b0ab6f1de417a6625c64837240ac10a6765bd2065fcbbb2d250300d2b260554ca61e787ee77302a26a659d1740578b51ec047a7f4a9a31aaf0136c69aca3c521ebf78a119ce28ee08d78756084b46d3bb546cfceae8a4f24314fc67397a974024cc31990594c7445f1470f0e8a1a71c3e8a04a0d264a15e39c92bbeeef6962a7911b9961a2074b19d2ec7a6460ce233d93b8bc6959bf1119c3660351df75d6c943865035b9afe28f9d99eab2311be4286130f2acda4098480faf3fb959c583791d51f7d4b015afcb5e23d2b8f873ef1df32a72bb741bab12775e0b31b28b3760c8877c90f3ed8a2caf0f8a640d19eab274a4dfaaea5d20c10368ad998862170e77d4ee6c0fe477be22c086b0b246514476ddc044fd3c54f91c7cdad40c3369542c8bc9a2cf58a8e00edccfeb482457eb16e20459247fb6c2f7fefcdb95478ac2221f491ba5c059d13cf7334f6028754d36b3daf1e1040bcd19c9d2c378700fb88dc630cdd4e3748b809843888adfa913a23591eca26a57ea6581c7b813dc93c23cb3b2563a8fe794672089ea39d30ce8d5a158d39267894bb45c911c4409b428e576d48aeadae84bf60506c216220c6d1d2f8969ec4bca015d1e4aab421671e69067ff9bc2c4ee18224d3291b533db14cf88aca3f27c3e0bbdcf7dc26b77577b425b5a7b66ddf4407128785ddb19cad7c86b018f7943b708e14e2e35c210e395926e6275c555b26afeb3ba8f1d8190548fd1cd21ad6ffc1ee29c7cf46c4d4877c3c82fc4e5acb498f29cf1bddfb079a8f8d63d9510b8eebc51204b611cf035b7de357b358a4151a8c0dd25624bbedff3c2bf52f733488e5086aaa3930397cabcb0e87c9cfcdd7fdc03cfc377f082ac09d7035d7b8ce5a69a9df7e0aede1ae6de42ce76d4c7b35406337155364b30b65b30ce2a98433d44f6eb98943d2562723763c65a451ab5c1dd6de7d596f3830c944094e541034a037255c1c051454d353833a20b9b8b02a9758ba0e0cec8458dbd0c8a545e94bbf40b2c6f7fb9933f8eb209215ed0f85abc8408b51b4c439a84c1a48c15ece57c4f867dd5797520b1475659056a63e3706666e3eefab488cfcc13e089faf8b8092f50404427a3f9c7c797946323d48659635137231664494fe492b51905d20ccbe66f0c9588821227cc4b910108e019ae0d04daab4e4420760418df63308f5bef7375e8beafcb52253674ac361bb4786c8fb7cc3337ebcad6b70bfa24e518d64e20ebd0db116903916525bd92bfe4f44138670196ae90317288004750fe342ebe5bf6f0ea16fc3fd5d9ee4091ff5ac92b48e97a1f660362af3c2c72c0bb381c683abe8a3b5618f226c2517b9b3d06b8902c43162e3e5e79742fe8584db51562b1f6b6faf6d563aec5cae5f79ecd1318232c1a97d1ec33f47b9859b8e3b6726115ee2b9ba69ebe497c64084739df251b416f59da4437cdc81e6af1743c7fea4b03b3a6a9f9fd5fc7715cb4616d15dae31ff1b7286de4d2ba98ad981fb17879454e7b4bef8d9a677001d0b58df59be5b62627dff4720636aaaef206ccc955ea35f07bda6bff474b396d0df94eaa31f4817709a9568bfbdde4cfe7d22b1c37976dfeb16454d054f0ca459ffab37aa38689a5d664f448e6373335b736e32bc7d8619defa38f62b85461900c03306ef3859288eb40a7b4369ccf227d84dc9570e768ef7d69a87fc899ee6b344a6999436316bde68fa0e13f3177e53a7e26be07a90f86e948d7c68f138bf61444b0ed65ddf7aa5bbe98a20a1de059dc6dc07813283ea2fd44ae7ddcfcb708720bf114f144a597464d2b59ec22a661717427009aa5f101c6c713585c8e5330eba732c5c534853578099e581b57757f4bc49c229f646ea4934c60cfafddc2a8240d713baaeceace39b31ebd193dcfaadb20d8a1e407b53517e16aa8f56caf84f46c97de997264a2d3d36bed77218b138313fd13791002fc768d1236c2f6c25f9293f900104621cef09e27ab9a1fd3d47e79d70712b59c8b2a01b35b27794f1f955a3e0c38cf8951a6fb460588d9c442f95211a9f34ae8db7b7260bdae8a403ef251ad734899d42edbb75541c9ba716f7e2fce444140696c2dbf407c7b70c1965fc8ddb8149d049ec5b449cf3141c0775ad7ac2a73db7aadcafc64894604a8e79563721b7a667ee60986b775e8c558b41a048e4cf0f227ff05b3472734acd8eba83d22559f2022db6de9d636ea6a2ada576e07ed89f4092863e35deb1e7d5b2db35fa4dd42eb210db78a9412992374e552aeb8fefb636c4477ff95a62d0de2ccca4e069474bcc082b2fa89a1d957411c7b5cced6627c98f1e8bd444b4d3149e33eb4c0b7665187429d999e7955f9aa07e9706bc171283055f8e224bfff412f97730b5828d6a4a322bc6be7e190fc8abcc6c665bc59d9ddb29e8d833d791917f7f90899c733cc0c45d9d902d969a2ed449edaf1729c671390b771e24f6d7dd127022e41ea9eb5a3846d7891eb84eb17f5c4969f71ff89fb13ed88887e6ffbb68355045570bd02850c8f9996863d2c5fc1ae12b5c5e6524fe2b6fbd2a91989f486c531b160047e5cff092e98040d73580489af3060a9ae440cba15332f35ba6518be70b3499622d4815c2d16a8bf5f72f9360885f94402f6f67ade9782083808e3fc0301d7b562c13a584bccab5bcf076f8f5580662e2bf3238ea9a0f6062703f1ef4e6802e8e37bc5bf07aa15bde5ba0748beea3943795f3921402be11ffbfcddf9f1ce0f6db65d13a20c2bae1010bdeea7af2fe429aff70d3f9fed610abf6c24908525dcb13b1eeb123346b22c0f878aac9fe464fe5c71f17fa10720543d7fcfe415a954d33a688d16f97a4d89b9131a1d0a59bedb66ee30f48ec18447d5ca3763ad933ac54b634a81b343627fd7878821462d681888f08c9db7dc1a0fc02c4d3ca9da629a7b4046ced3548bc9bdcb3a798f6769ee6548cd540544fdd63096dda2eb3990eae9d599d9c81836a8e427231fd714a23f2e964a8764b63557851312d3382a67c8153f554ab0631ca0f5a879e6a73a9c0f22b9e280d050cdfcc198288a3385d03250b1577053c685da2e270b08d2bc81063a955bb52487c0b9493cfa18b5f20038bbf17493cb58a3a0e3784194d437ef3e569746700ace9f7d0b5416fb4116c8d8483ced841453034e8828a1f1855ca85a36f96a624e5fc440beab4b8b603fcde3f4f4cddd530dc6efdb11ea39a5ad4b1e5fab75dbedf7a852a57b004a6ead8fe7b479c7ce30ed7089878a6e2e36d20bb705b27567792d477e82e304260c09cf4a09facf642e7acca91e1dd84375a4b8a6fe29f188ff1abd883d36610f29759b70ffa16f47d2b1ccfa710655488765fdfaf9b8db07fe83225a842a5891a30ca5e8cf42679b1f2dd7e91babc30ee8569fede01265a16c7d53859979915179c6dee6cc8d331b67293b710baa19a64204d7b8bb2c030d37a3dc80b36614b916e8eae42d59f8067759ec070e63549abfb1bd54865e5d37180dd67b883fc383f4252d0e12e8f1b08bb9f63377ae399e865812ae7e8f716539f3c8ee7db15ce6d12ba5d69eac7f778b20c278b6d311d2ec8e0316cde13dd3188afbbba1fa1ae9f2f01191214c2180bffea4d0f6e4d78d3b9ffd377c128f9ff21480ae8aff80c454ada4be4d9c2bb56d99eba0f25530d57d520d970d4cfd1a56df87f2e58f8ae0a7e3909ec01a8495cc89bf7eab8f9a7d50ab2715e07aa05c46d0335099ec575b3fd279c7348e4912799faf4e39b6d081aee125d1acf8d549fa75a3bca0ba08c3551f9c94a3081941de74c88836a51f6dab776b32601fc874fc429271c50a4cb8ba54cad588308f284587f31b90f0fe85c2d14807e591ec5fc40856a162e1c89fdf50a109808bc6985a9b51d560a05bf2e49edd84f987d6f8c23140bc52a20cb953692a2d480e722f36184ad1f758053f323ca64cf6bca6865978bb5a6015c7dbcc448aaf4c87397799284fb80e285973f92c90e76ca337d932371b5335dec0f21d9a50f395bde545301a404e9f57cda4f39a7ea2723cf9b352e3052feab1aa40c2422132050c6a99cef1a0a5cdfa41d3a828f54fab43ab4d9b789de28104980731564b08c773122645611529fdef4140eba7b03a083b6cd2eb55fbec636151847374c5eaf095959c0d96f8cbe1ec6bf74fc566570db663eca44dba1982c905e58262af7380608ffb3fa73e66d996cb7adc1baefbe3b2cabd120d7778f55d77eaa6fad48ed6ec29577ce3aeac943910707d520e6dd435271f1b59369b867cb53a4d658c91e3c8829715b09fe6899eeda61442b9e39311625f8eec7d205c9e133e2d951160b53b5fe74ef6507a37d87a831633b7d0f3e6c43e98836fb1cf0c40aa8a33a8b42f72c58659d7d74957a98b8c417beb82e36a8d2952a72beaa0b4d7fc10c9c2cb24fa656f4218a27c70ffe3b33a69773658ba3f249e40f7989895d0160da936c7cd43647a3edc80af6c0a183990a4176a7cd04ea0018431db1caec065a10c3b423d534a664f58ef4c7ce06fdb228710ca97c95e6ef6ffbaaa60e959be55705156c57e9069b9d2842ddc628e7054e0e93d0d5aec174525a71b2d2f69ea7da377179013981d6d5eb9871fc25fe3681923904128ae96f9f9d83b57af8131663b59c17ee2061d0b812314498f54350fcd41887c4570450a5ed5be28f4b5b1da2244fca14c95258397a2cbaa36a6b4994dbd0e111efcbbd734b84495189560d4c3e904b0d315af1098b52faf253494ee6d92159e88e63ba0b950eecc98f1029977b38446ba6fed7d6df4c812aee86fbc4e6a6b15afdc9a4fc504e6053cce1ffad9eaaa69c93180faacf940918c992f877f084a6bec0de1cd553e43a009ba394a0871c12509832ffab4c4dc33a9f2c16ff429f6f04f4b123624e701ea46efdd4a4b023add85bfe157b139e156311e1553f2659ef152040f5e6c27c615da5df0c2a70e42cf437cbc05e74004aea0744605feda529163f3523a1b58c6c593c3adbfe65ad933a0a2b96a4fdea330b1340e0fe412d530c0384513fc89a4378fcfc47cf6f5a4c02af0305436e839976cb04461731cc903190c64440ea94698f799bbf6e8bf06dc4f04d23ddd01629adac06b7391c7c04462579bd970f84ab2da67ccb18295bbc737625298098208d3c0d05bd999b03959b5a99bece70dddc63cfa9778e507370aa0c7c5f165e4c200e1de0ebd2420ade04c46f8ce8c78e8d6cef579335d88170584f3b1b3e0d88501e7e685ffb8f7e8730cc2fa569329b556b7a06acf634528b24951fee93ff93236b35ed8813dd536ed22483d584f7d141ea8a293e52476e1d76f609af13ba3fcfba8d63767f2245ef851812edd9f1e8bf86ce0dc6639c13a67a01c7bb1ca660efb2c7d59f7070da24239ed9804c574a9cd0e6774b4f17b927ccfce923dffef35b801c612acb125a720f9b260c1fabcf25e8add986b24f3f1990ce27b8a8c119e7759662236926e561dec7e4499203a20df9836264b516153bd9a3a2f0e3f4a1b7aad156a645acc8caae547fd4fbb07c8f19ee25cbbbb0f5642f57f67afde515e1b8dab59bf8e3f0e26e06f4f0a7b13b28feeba78d9edd95067c6b5fca9c3da1d61440a958e2d1a9b773ea8f0fc7099ac7e7e6ed936d2db3dbef838ef3698eebb880f4670b89ea8ce8bb34bcf1137a9857eda45424f7ab3a905f434ca2bd833573f9e004b4c155e6209b582fcb63b4944413196985fc265d9024070c6dde11c1c70dfb5c44a27c0bf01bf082a96b4a005db77d35a1e61226796828f553be9c31e10c57c9ba777bf4447a93473499e911b70ea8b526fa9f384a886e36e553e412dda4c62ee456dbe6dfbbfdc2834fd6f48f8567df460659c2c3faac8d1422189d85b6c68e466e5af8d01517176fd37cfc4f8b1c8536d75168d71670845064212d65538a3a3dee77282cd055589ec428f8e213629a242bfa6211cf2fd65ee8ecb138cff90a4e93d427d9f4d036de3080591be88203bb6e11b9090aac283169ea7cb002c9d01479911f6374036cf1d2f1870ea6155439f748e7e82c1a24623a3f2b0b544239ea7590357afeaad925d1774aeb6d4e73b402bb6081207c0e2034627a3be78ba6011a1094f975ad00f2d5b9d9e4b42b485cced4184348102e55b90c075f684c682df6df26281e21f059cff7d90c64d73086c349286fd5c0e0a0dac40b5a0665b86b91ba5a5242cb030cbb3caecd38fc8d85173979f190d0030275c95e1523ba87257e0899333c66421ad45b0ee6de91b493fe69810409bff2d62d005ae61e62e6526c35ff426837cb5fc340191f7c396798c05efda565c45e1f1de7a627e2b76b787e5b2fea9561440c405a46d813fe10a51c3118615f953bc260a020641c933d8a628d71caf7cd398b69e36e94825aa206625cae6cc145bfbbb2894d1e3c5e213f79c30126a559e59dc00967088efa9cfc8500dcf404cfdd8551f8fb3dd1b441fdd6386d7e0f93501315c9103560558583063f11542f5ccfab487314aad11f232eeda690564489c4e5a26d56aacaa30b033aa4428910fa07ab66b11abc68b6b1a11e7b59a1a2599e162454fdafbf3777a4842cb8d5a844108e94493fca48ab5de94da3327b1bcb61bb015eda1f924d6aea7f534ab24311398f1b934b14bf77b6feecdb5a8c5c8a5ad26a012dcab77613e5d6df43801d4b7c559104511416f2c4ad3eca990671d6ffae920512228638e973a43ec3288abacea4bdc7b367d155ad21b8d44689a7ab0683a4c1868d5f0f09306d70f966437f501d78fe804d2f6f65a1697d28c594c9bcd5e9e9ab1487099f38dbdbb7ebeda0e766fd5dadf1908383785fce339d2d2f3c20e7076f0dc9418eea0954a253ef3e4decd42d1acaf0c476054df8de6955599fc59429cc2472a5ec26eee92a2afc991c5f4a9fbb27516dcc6ae3c60235c81ae9565547d8b3db9479402c4700969239ec035ba7d6f85dcc70801071e57e667cb07368242886a339082a793d50ba8586585c37058d263d3f5bf937693ae79bbc1cfd93393f5cfb5e7ca5e96f8fab6b512b9f080b656903f6123bf23b3ec46c24b6cf8cb835df8b873debd3245d67fa03c2c99f90789748033ee5e88e72d3c65fdec0e1b3c1b6084e5dcb6e92f72358d7e8d392f1e2ffbe82f0fea604ebaefbf960153c708c344f7ae168d59221f380ddf13a9192ede8eeb84da725134ac54759ffc9e4f3ff7cf3ac530b00f748451393caf27bf12e3bf556c8f72de857868396b2f91e01783d9d27ab74cf1df424b65232f4f6cf35e4eb84597078872fea3097e19fd1575d6fd46fccdc8a11a1da531f1a5176ebd895a94e51c8447dc8224369b8dcb2231c4c54917f5ee4ef5f0314a5de818d1e997b4add1e5c602f3bda542c473c36dd80a08d5c62abb4d43e8b3e62040acb1edfe45748c03b00b6bed91068939a1e81247f47da6789589193c43e1fd90a0ac00c740b253648393009adbbe36ece5f29d5323d7b4ec314f595356aa2fefae02e72be9a16d036a1cc084b59918528bd677f3ae865bcd6a2ec7e0bfe51066306001bc2071def0d9ea56c5ddc04fe4ec047d4aac4d0209542892c64abf75abee93fbd6017a70e7bd1ba1f621a4e48ff6447f1060c5617842aff8aebc2897525542cc5e2c0815e9edbe1dd5e3815930b27b609d09c989b382d6ae1ff6159052570801076c68e4a3aeee9756b323f755503fa2e435343a3abf5686c8d19eb9381151737e75a93cf808e39611deeffccd27ea843a1e101c588244b81482e8d670dc63bd3e9e1f938a3bc7a57be099566060ddd90abbe99e04b9ecc01c34a814ddf8484eddd632dd2ded181b611315993387534211fbe0439d224adfc140f58e8d5b65d9e7a8536be31a309a855037643e368625dbef90c001f62142cab01d68cfa0ca3360e7b5cee06d06e4f7b787dac32e06a13e3018de5282a83d424c7f3e443a6f3587859470c29eab3ad8647807179eed4a1d2d289c7df65df5e36f33b3e213e39df38a1956e58e87b33aa9d32b9623b4e810812f430b1ab0be3af9b460eb93e24708f207814d7c2a44508571a260767a43ea1a2a129639a4a1243d8d8547c174669fc70e48db79518f3916741ed6954c5bd9b443371fbb6284572774019260847ebcecfdd7fe39f4ba176b661d84b54507cb8d90c847d24bccc3e7d0bf2545359a8118e77c4f092ada15b5608087cb2abe7c9facd71a4884a65090aa06054c65aed8b1d72323ad6026f86362bc18917144b8a62d7cb402e300cad5f610c26ba47462c0518e8a505fc338a2ed383d2d5ae690aed170ccf5b06e1757ab449b9f57a1989271d6a917e7cfe948208f856617e73dacbffda4305aeea90e0bc348b2c5cc95d8d409e0dc10bfb65cb2a237a6cbba889f1d363cdc515d8bb8b120b42db28aa336f35e38b38bdcd4872fa486c0a28471204f237c03484f21a10d63172b2e4cde415ab9de9769948f8671bdf14d81339a8869e56013a464879feb036d918f90a6c4ab8295c5b85acebe7bede5f2e95b8261e7720dbb64ab61b9add51dede370664655fded60c466998e391b10924d0beeeebe057dffb5bc6b418510c713fd2445e7d2d639916fef2d793bd2491e8eb421a01eaed53816276bb5a8d6c353a8a4c0393b01ac7196bc6ebd363331397ba130d891b2bc51dd6715d47307ba337e406dd13856691bd398c42ac54d5378e08b1b3f746a70abc6070a3ec2fc7cedc0dcec333954f0ecfb032ddb83406212b083b0cb643a7b57f5f2a56adf5fddea72ca1cde5792efedd867d3a5ae0bf5d657dc844d06a720bdb50060629dc68a91221d2486b905d2a8753b44d25f3a47253c79ad0b15ca1eea4e952fb3a74b090e25e1543910a9f77ed214f781b95cb516990bbdaae84d54088c31db05a62420f41f16bb91457de7c7ca1398c2ae16d5a2e8c59ba2bd882fe15ffdcd1773ea50a5e215e83c415c9f812d3aafea88ad2161c698f27ec5c05b5db7ba1fc43dc1dbd58f3a9b9b2fb52677a91b88e3da1410ef3db0bc2706f57cdbbcff970e0b26b98e4eee6a66dcbe87f6cb0671d16c0d9937229a2507604af7f250e173cbfc6efb6557da56d337e3c0472257d833aff520911d005aabb10b1fbe66654ca6ed31a3f8296a8ac8e2ce817ed519814393433a7b88406cf05f3672e97eb99747612c1b70178f3f3639797dcc7037b8844f2ac378be5290b81cdfa739729386b42cb0b9677e6d4b4a8c234b9a6fb39156c8be4b0e8cce471c68e506a71d7deeb7ab32f47f1a5712c8ea51044d66d8cae623630c42ac2ebf5fc6c7b51df812b800b0c019f725ca867414928ee04599e011207637f31819d88881e1db6d23e82e0edfc8c4a8f4a5ae6fcce2ef52a0a3b3206361cc35a40053b1172da8ce44c59faa56917adc00cd79087cdff1a194f01fd3105bf04ade811f15d39b9170967c9a71ec17c2d64e0fd162fb196e0d8426894736cc0947663c58dbf3fb757ae8b26053c46683ccd551cb1282d93fb7173851f6c8ff9b1dae874fea1e3b6eb4210b3bfd9807bbd96da316152dd9272bbd326df5cacb2cc0f3ec69da6b6d757b35ae37ddb5fd19c7519aeb74ecb398bf291c93bcd2e4ad2bf373cf7fdc8fb5e6e64f684101fb68ce91db76590aa4cba0ce1692b4c02e7226a4ca013dd5efe2b52ad988cdeab9a43715b7573cd28c2458ea0a568d28572c71cd84d222baf452e0585aa1048af968e6a1c3ce2908968800ccf2323383ad9ef78c52b047c594b1b48ea32659f7277a7f9c16d43262ee32f833c31fdd18137d34f69d67f4cece86deee1c09c5cc2263471b697c49a1a525d537c00b8a72fb097a79a85b61d66f4222d4ff47bf27be530364041724d3664a1b2f4d83e794fe9f5eebb35f57054fb48f4494bd7cec10e36a5672b4c478cbe76256ae1c1ce2225768543d076a2b4ddedaa8b036c8a214b239753c9a166337541e2572d215298e5cb62875761ace5301f2c276a870fb661c31cead3133132ecbd5c6431ea47166e0571059d37e07a1a6e30c222eaf06987637ed0f1829c534e462a1b520469fa225e1c54e7003cacddcbe3e25abcd2eaf2acdeb5fc4da4ff39156de214c0b5f2a075f5841c9289b349e26ccffadf67dd06f1450d8fd629da8d3a94d3b71e30313baec738b735ea1a4d6c9fc479b18cdb9447b995d785e54a1b3b64ffd23e2c3e075add574db1870871851bfb80d0331884c595dc8920788d1da3b7a1f80bdbf5e4e23a22d51f0d33dcb6e8d7871767400ce7fa7d0c023bf87e87230b6012be18aaeb04376090caa63c85d911eac202f68be8b8a16d5824382a1fc47898708b52831eda0106fa67a151558f368ecb9a93d62f1a2c2a3863769735905712d1c538ae7f69c4d5d20c6d16da15839ff18e58d02fab11c636036f2c6f50de0a3f7daa05dc941dd33197c930e09627422ffd41b035214d33a3dbe07f5b25b491fb4a21441d3b27f9cfdb48328048279addfe35682bd78d5eb3fece70fa770e98a80759cb17913849cc07a74bcbb3578c5d22f8344ea0dac35d1031c158e921e209224e3461a76924fd7fafd7c729efe141be182d69fdc7ad3ac4d4a85d12cccc04e55508d5754b2fc2d5fde3f12746f6e9c3459325dfc366334b9241656dedc6f14c1a61ddec013416c337cea9014892291dce210607ad860fb187d5d6ea33298bbf060602d1d52234120a4edd26f3221f032accad778cfe1ffa3e7e53156a40c229d85a7cd7861a9cb067b544c5aab0e35b8bc8f206c1f414021f4e3c5aa09e91175e05326a9f1369eb5e63caf8096e28ed25e834e2db5faf7498eb81260dd7fe5c7c4b448888584b7acc4d6406ef224dd5383eb890a12bccdd9fe6a0e10c445a0b557a3d53efd3dc60bc0f9069e6d0d358f445edb35189b346ac8db57b7c919ef6ca4da8d2f2491f50e46eb15629572c1fbe86c30c9ac2b209dcf48995079b2fdb96db0a96bad819c1314aa73f338d9b91d29ca5c843861cb2cd0e13907faef51908b5daaadd12e6bdfceb858f8b544281ccef071e8cd33fede887647d39093804b3991352fc29db54cbbfd5c41c7c878e1cbbc8a2bff28e06ceea0a49c347de1619136072fae614b1b6b8dfe150c08744ffb984f3ec1bb513aa29ffdbbbd4a381fc66fde3f6f016f0581776fd2e21de0a7d3b4feabae56ff61e8efaf15ad8a23d208aa4006d94589dee0e8d54d4ea78b22b245e744de5d936f7d005e52104f1f1eb970c288d9eb4362389da886391dfdd1c9127d253211aa3c50aa5089ebe42cfb463315795671d6c32d2b83aa79a81b2a882a3354a088a8f1f42c4f0f1ad578b21a4d453a181b1ece44d65c826ef352c39b8fc8499cc30fc5925ae993088004404a323a6e3cdc25afdbdfcafc9d92e13b78aa8f6843a056bf72d40a91826d0f3ce69c923f78f2113cf39a0675587d41409d65e5232d741abfc25e40b9795c46f1e9a8527cc95f0f4b4ce6e3fbc6853a01d6eaff621c71c8cad132917ce37370bb2aaf73f736a6861a3706bd3d9619c3c93a5294fb77dfb9d3e32897bb39fe665f1c65a7efbc271934c37f3ccd6f6c65982ae5b4271c1037d128851203ded37bd9816f67e1ebbbd6cace1a4c5d4df67ddca66ccabdfb8e0245f0811b4fcfce9a66adf3596c3d0dfb32125eef40a7d73e5111c139dabd8eb6a3a453f3de661067192d8c6da19c0cdc81b66aade6ce636f91861e7fd1916e135b4743d166b4ea4b664b21987a75df1e41bdf103930921a8f63bbd0701f6b92f3f11a847b3f9c546b9fd11420b7b082a5207996abc229bcf72aaf60563585fffd0e413660592dcbe27ef9e35ce694abf6e77e2a0cbf3b2187e7a1c7e1faed16549bcb2106c7cead6c52370271662785774d4c9bf771670b0ddfe0b15661a6ed34e275dd4976b7720816b2e898ba887bc0b1b44edacb47e8a08faf5bcd2c59b1343a3e7d83ee88ddacac3fd836624d980294011b0aa77ef848009552d7d8269ddd06ac7a2b016942a4d19bb5e429cb310cd7c2672cd741b5d202d85a1b245f0b890b306b60859c5ce5d04cb594d80a782105256c6d7ee35d6cee1c7bd88e13f889496210f9c7944b53ff120a68491b7f95b84ae37784c79e229daee3e1c40933f7ce4050b82d37f09e77b380d09cfdc6f47d7cce1f0f997a6b2d4557a812a9be22bd3be0e3775e8dd1837a16d126a1366af64e9a43846a027f8240f9db57fd5910b36a399358dee6dd19729ee1771c1a3e754441fae7a07b388178f8c4591af25f24bcb0e18183ba7d367df8eb5ef451b72533f3b801e31bbc2696fb33fffdb3fe5650f1af90970dc8c90f2179206022f14042a0bc6a4c95a8ea11a70871898a04d436cc7c96afa5163a9d7d2810372e01f90d5fb542b5534048bad5c86030245a40e3692ce549cf1b88157cab88974aaf1c5b556408b443d10a0094fe800618680b70fcc2048d87992d3b49b2c86c98ac5df9b7ec5210387124725efab45349fa31f43636492443cbef9df26171ad0a06409e9de75258edc66b0bfa107f91508aac14a933af6ce8d09f6313e49655e94407f6855a1166f59ad82a0d3a369436d4c42e8516deec9a66eb6bdb75eef03769408723651c3f2a9973124e96f4c8e7098fcc39b110a4a137466e8bf4a75ecbb560edbe8e2d660ec0ffe15e393c5dd49aef5bc79d6513e17091fc2755bb34c35fffa3f4dbbd84a6bdd10924","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
