<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22e1cd0e1f45d8bae97ad370b6094f28d8a6c5936a07455a9cb12188b6513aa670cf233edea311f08645cb40edc300a402c62ba376e0754a308d9b391a4991129844185d8a45599c85f6acc569094c255976a0b6493dd3f15b02d71d2beb94857513846d1966ceb3ce52a6e2674989f6524a219c35cb3b49ed68bb102276fc605f281af4efbc458462adf07c07bd38fcc6fe4496d2ab5a759ecd25952dc3560db59863b3f421e987c13e79b74bd91f2f9e815cb22cbc1f2c92800dd44144eba47d2814e85bad45dca3370768bde8fcfc53066994a99ccbeabe1b3353c7f98d98a76b64f0d9eb7f5ef938b8300fc7d5eb2cc90728a375363bd864d5a9d8bf9fa3c653dbc6ff864705be68e29b7dd9b5d9daff89c6ce02a4e8cb3e55dc7423d0178d00bbf906aa694865aecc1540df17944c02426d922e8b74585a8b8ede44076cc842c8866ac34c6a9b0d96eb2a0a188640e7ea1a07d491018bc16d261a7c84f1dca07999e237a19337d481a6c8291f67b655c2edddb67e3adf100f1c4f3725b3842163e3c7ed2e147d7305b41e3998b77a8cb7fdb1afcdf91f768bb72d99f7a9a3ccc20b0f33d34625b76467e6bcb90d84e0ead459806f6c1b7d1e772adfa3abadd6a7068e7985fa672b2153d34838dafce0714d3e54ec352038067826558fe9e7fb930c00619eb8782919b81d324d5dde60006b3bab9ffcf3a1f90071456e26a4a026f8fcbbca1905a59bf5c9952d66a8e7188c5d2ed4896a1248dcd02852f46e5b369e9a1bb8fc250a2b6d50f401b272b82af0f221fea7a78a14c2710a27b52ada3b804b7d7e71dd5715e1f89337ca59360770648a025b726ce3a6afae10f67f7369e88fccb824ea6d0b565eb60a03fc30b94f1d049e599932bb6d0d87a73ca294317283038f5e46aebafb78a82970c7facace4d7b8d88a3d1215243e5648a2dc1a83ac0b477065ac3a167986f26fab457aa659a0378c357d02fd33f926f72ec78e4e73043b13d7ef8de059f175f6351f7a61cae7ed5e86785b64ad4c347229deaaea92caa79c8b10c3316bca30587faa600601b0eabb737091da67a509f1a70ee85e23d889a6ed76052c61effed186476517c587901e3cac515969525a0f629a3e0363a5650e55c5c1193c66c9cd841a5da19b2ec4f76031f31a55d5146048427e267b739dbbe5a438a94825d3da99a741f3aed8be2b8f8852140741f3b4bd0567fb0f3101301fcec1129ac3930a41bea4a095f59158b55e9fa439226e6aa42a5e3bec8680acc6d5c353deed3b7b7c5d2d902fdeffeea1f3f63b956c318159bd311792eb53dce415026fea4b91dd3ce34fb5c3b64a584b5cde68a5a71d8476b7f6cc976d48377a48a99c03e701811be4a18f0f7116d9a40215c3f4f8081163c443c5fe63031aa565cc7da88fb4ff00f5f7ac8cfe976d583ae34be772b7dad639e86fc5c0ff8899a0e65b16ff7606139a97483c62864a46718fa5862d0266f347e590abb830a1dada6343367b162af942ee0efdcf53d08febb1cb49ca9d91661daa9179fef4b9b842558e6ca2430ac1d19dbd1076eecbd6630220a891b63dc064a9f66450a552809cd5e0e57df66998160a5333a02af56fc58c5c951b5010dd53911fa615ba2171fbf2eb3f41af5fa5407931e7ba7952dce098d2425bd21c613c734a170447a8996a15fdd51c4ed4ff7d6a4e338f1795ab1266c6f892fa186a739a229f90e88c036764caac2786f92a8d8d964004cd2ab6a49e83eb75b0a2fb4a5b90bac3f6168192b1b3442074a1124481cd9982f9d0d7124d3af2ddf5e641ab4158a9f733f9cce0e25640c832e73bae5b67768d99588cd34e03e674f17f1a1a97abf7d608411cef9ec9c5daa5796b57932800cb063b2dbc2ff57b753f9b49daac8f698bb1bdb3f6b0e53f8ea65881dde8199b265ee574f18b0f8d6738eebdbd20e9e7bd7aa6590e1ce7692ebe265de395158f2969b0c37aabd1a2e4a294d05b682b798ec6d04e1bd5f50cf19b4f6f578006a62ef3c12b4e04ebb340dadb11be110619d164cd80e8599185083c9c7ededba1ae5eabb0d5f744e5c49541483d49cead1172e38ab99ed4d79b6f9f9d58da4d816a7811e8e942265eeda2486ebf6eaf9513177534429154d7df6df75838be0b4557f91b8ccb2a6fda2f2225d73a04c3e4c2845985035a22f7c23accd3ed87a8973ad6bcde942026b4b6384ab98c60885033abd456afe00544dfecbdfd13736b958c90c646c843bd668843a403c2d4c4f76b49d62a296a276f6f85697bf6c81acbcc86835ff2aefe1fed76b54aac6eb31c76dece663428bbe50c1de84d9382afb3c83e689454408b55e8da091f5e2f349c5420d32d69c37a2b59a94dd302538cc72f9372a8285d6ff7d3f53aa3f227e607b330557af2f2189453b4bc2a4f00e0b841a4205a7d9645c28ac2ca01e539f37e5e57379b7dca74e2f47dddc3499370490c977826757078cbefb1cf81adfbe1eb95357e0e8449bbe843f77c09c63917ee932a62a8673a5d89d7da34b5de9189e48b972af349a056aca2a207e6087ff5a335ed441c385f7788fc9ae51d141872f44f7e433264404a4fb71bdac6a53347b459cb1d8fd93a7a223295a247e659596d9e8828b382c154de0a84d4ffc4f9997c746e2977dbe9ee0c1366907d9808954ad2dd102764e7d0eb4f4c5d6eef33cbf05847f7d62ef75ba293b955360304199a4ee03ba5114976a5fd21ed894529e1a6a51bd88d43a8208394cbf6bb84ff39410f6006967e30a3e50f38e9370975489691ba8825f936dbc0185ae38af8d60b01483c396adafd60034222570c729e960fc0f8f220dcbea0d6735af79b593717d83a25ca33d3ff21ffe8a8ba0aac39f2f5d4777b57fae8e8e8f94f6a7078ebd69c3ceee68d2a224af27d8602ce6723328d1d81796233068028a4dccf0924e7f03a758bdebdfc24e8d799ddcb50e18695e16fa46495c350ab67d00bac534694cec006cea3fd95b3b287b836c612ac7e455800722307b8558cad5c987acc76af34eb16b40bc4004a831659e42569d3dfd20f69df08797b1fd55e04cb3d6a3e37e73cbbb88a0e47ec1a738c36412041793d9e8e2ee97607979941d33ddabaae2332ccb7322dd0524ef8c88933ec9ef56579f10fb4e0b58d2954731f009b3c2752157ce76cc0a77645aecc3dd1a2305d32f1712397ce33d0adf547f1034729b27b695ff950b700d030f0642379f127dcc010dc21b9d2d917eece338755951d77da0c2f78b880261a7f31a8006b8e065b60d499c6660078b2fb2ef75e2383400a01e12b8c4bc5487383779f80e2a59e808d8c085cf374db1c1372ed97f68363d24caca16b2e40bc0d39fa6d86de9ac35f66a7ccd28d9ee221cd7c4a8f3af5a67a2b19c5aacea0a2ee18e21a006533b0920349f2c1d56150b2338aa676a39aa261808cbb37ddd8c3e6d655b7b5ad76d52b313fa7c04c7261f1d05fc55c0dbcaeca0230f680578b7101409e47d3be9afa0d8ad001e60345a292eb440289aad224a9c9d25bdf7265caeff5979a836dc7ad64f4f6395b2f890470dbac252b37adb85122cc5a8eb61f1716fb4a20124781ba3fa7f9a0cb05dd51d47ae8e34464cb2731cad3e7a5700a2ecdfc2ef0cabecf00856d7bcf5217e465ca0f092ecf85fa53e87f73b8d0ecd3bd9e88cb4549d0f6f1241187a6824e642f2501e2dd90e2d1c93b2e10bc47898c8e8bb14ef88b7d6b6d360306de6e47bcc150c747580f1bbf800f384626f18dc3a94e41ea15f1b7b00c6b9a133a21952ea062ff7e12b41cc918072214b41ab5c068240297b1bce67dbc24164680b3564d81e337bf8a51cec3c09f39e40ed94147c438ee40b6662f9713aafa5cca044ba363239f6165e221ac10c9bc6fd4921ff78354231ffc068b68ca66d04288aade82b5abb89f249c23d81ec6d516bd925d8e3b8ef309f8f4ed8335f55e9a628f9ed8680bc32a1314a724427ecbbcc9ebe58260b5d4bdd9ceb148454b9a4eceaa71dbb8ad71bc17d3486aa849523d17c5f279c396f9b3b439fca894581651b15124486533a1be772262560b9a1bd8f5ae7b443ee4a861f7b6a64a79d4f05637c929240ad2b8fcad3cc01a9a58036a0031368d275fa4f9296f5f6c110c17859d288fcbccc1dba0c5c66bd0e8f8e107c84c9091f5f71078a3813d599a2b8a4709470e3977abd6692418b31aa1365a883f6f556ba37884130b703dac3ee9863e3c066ada0eb0c241a3ac681f49c14f04579eabac2686749e58d47675301d9d7b429883e18fd9966a565676f5661020d90d7e2a8e965cc51873affbdaa31d0efe862aff8e757348978fe3a42b492397665dfdb956fbac4f415447c735bcc922b220bd35a416dd6b37f26f1228ffba40c5f1e91c4b09c4fe52100dd76114009c1f75cae5ece3b906052114bc024ad605fde34b4a1b0bcc7fb0ad9e0467dad23c2678b6c2bb209842f797d4e6f1cb7868eb20f9dc96a06f0aa7ed7a6c3f251ed819ed6b57245765c6c0b7075f04564564caf8ba91aed0a903ba9dc071a5fcf67a19cf7780e81d4bc88d7504fe2ed4f0d7172bc1451e4100c209561a5b94afe0d1392faf4db940208d08979e45f70953aad1e16f25a134044feba11231afac0e7e0b404d5474b51374a5c3045357d3f14a99e63d45a210cf6b014391d69b8dbe10dc760a2b284e4563baec94c781181d5283e34c87699321a14f2d7ed7144b227b28efe0dbb3d2be4efa5aa564e655cfbbc42436cf1b9ff7a7f57acd663a5a48c1eb721841412d65a6da4eb1b6f151b6531e074647c6c9ee8242548b05a7928ad2e705e39315302e6583d65245b8ee0f4973cd5a533ebf533aa30225eed135fa79b5255f87e0ac339e2b5b91b06f4d0e7059a71875f1d948dacf7861136e5f3614c9515e2aed82574d63edafc713e1fe236db51c8262e06b6d060ec6590d704b0d83e963f0f774f1edf132bbea27a09b8bf19a05498f743593d5e024686e04c3c5cfa3dd58c2b372eca896157243d493e54b60f44bc1151eb8ab6922dde95105360572a974bea14f0a5b14eb8a106cd5040fd6fb2d56621148620a740a37ed891557997e506a236a6634566189dacefe291f784aeff6bd14853dd8ed4d03a50fb6a902c29f1d954c07c02d5dc18aa0769c43779dc8297d35760ec00f8c386d7ff40adcdf081ac7c743b94d20080258ab4779b4aaaac6c7075765fd5f13343c4280f22fbaa74b6d11b5d643ff0eb9202f8f30219ba933c7e923618856fdd54c610eecc184f5210e886b2428542dd93c8991f20eba30760e892c2f17a9c41d3f8e4b43281680e0779cd2109bf8d785abec7e100384aa90d3b0dc3d4581dee7cb1011fe8359bf5d5a0caafc69837c740e6606562918316b28ee5d72d77a7f6f50bdef45b93d974d5479276c15040c892a33cc26a0d32a6a848b57b46c832ff00ec8588a888f6d9a49def2e16e121eb311611d6cca8678de17b78775ee0d3e5ddc2890dd03888cbbd200566bab7f1f6a720326902cfe728137fc380ce08f8930b5d342fa42e348996e8c4a12af5828cbb592f4cd7e2fa03dfed03b489d6f9c91249c289431c3ba3a7387dd2c369f3aeb1d62b22d148636cb84cdd24b09d4c175746d8beface8c9f2cd801c3ae8df4012bf9b78d972fba2a3faa1dd9744e03ca247625214c76203521f5b19799180f8ae5f94c8850ac20907af65ed446f6ac82f7e967cee4d83f05602782fc253a72fc321a9f5cd2815f57dceb54ed4573a40ba655605d58bf06b644de06b5116e2825c67d8f9ef34cfcfd790649e2a399ce3909cd0effc400ffc7a0e5797c7b0a3d1e6acae620426b1d1f80770b5ca43bb548e7409c9ee40043585cfbc1e2758661fa6cdb8f97e4e1080526dbb5533161927af3898516875fb43dc0eee828bd36d1b44aa97b07aafea378d86dab9c6e9338ccbf90945b524b3680a80445a5744bed54e0e8cf35ae484dc7aa0b00cbd2272929cb23a785aa5f2dae9fd781f122f2cc6c0dbb2faba52b1738929b4c44f01a1ae4a6511884155a11f5bd9c6e73cafd9341fa254a05bb20be1df9e45ef86e62de13d290a303d3b8c3e2b705897a2cdab931a3b6cbcb0312accbaac1d694bdc6bd586f7778f34fc558c35384eadbcbb991cea03ac60d251656a3d4f80ec70a4f23e931db5844dd78d8fbfa07559394f0995fa5758a6f84aead04f5ebe8da3ab01e299e246217d851f86d5ceb209550f1197494837af20397e45555ff66d3861d940d5e2a7c8d7e72e2386bfa1fe691734742fb054379a5e2a5892e201d34e329037105a4c47cfbf07dd00df1fc8c769c2f67a5a2e53e6bb995a2432499efdc860a6153699afb175df31fecf98c34a09d2cff90d5adba669dfbf0b5741a6c66ffaf306e03da64566bf0aeced5c356f164d8621b03858d6aa712d27907322fdedc365c928d3fe5fe5d745126f67f9cb855afc2604e2fe04f1677b3f72de294add5563a6bf656f6b041ec9632a3ef269f0f244f65e4afbf80b36d07292fbfe1a51ee23f3108a40bb5b7911cf7fb1a8dd1e0a711c36ab52fd10d874e674b0c1c3b2cc598efa36a2a6deef3667c8e1eeb0516dec47c4cb222d15db931793be9637df33d77a9958e996395b642da746ed702fa4a44bf98962bb737580152df16b431b8ee8d0399f3304bfde78328d5d4d063250604e0abcf776f9cda978d16cbbf84335619aadc6361d28837349926cda364fa43ce8cf49f7f5359ba7fcba9b85a5d8694238b70567118d000c46e01f6bdce6aab238361a46e58986d31b5aba9549b1a938bff3122dec823d3ade5d30e352b3fa02dbf6abda1f2db03b91afe732712678fbec7f6b7f6d06f06b49e41046de4ce02bea5b8daa5fec6292a244f500ac73edaf20102fa3d366de0b4154a2c09c30247b0f674f42c9ed2b08155c5b992c912e619a8cf7cc62d2c0398af25977e06f9c0ea1be38304c6f2c77b5041a184732c971922b37e668164ffd89773b77c62025603d2a40433d7dfb290056adebbb6a5e3398096afc5cc1d23ad64c1cdc428dab2a33728329a351ee31833dea2da6946262ab88550f9fa4a085c43e7294c143d66902e17ccc0da0537a61de321795921fca77e37d3aaf10db2262fd2995fc569c2d916d4c320f4d5c9a7cdfa9896467ceb0e01be94d4af64890f2644ba2309defa54dea7c86b937f26d11dccaeb20c3a60c922b3b5aeb12f4f32e112771466ba7ce2093af6bfc5b493fc5978eda8b7e41dc369009338134046c56814a43cedacefa84909611bddc24f4472c6858c5e7999955d7ae8b48ba45522ef5f1fb654a1379932c23ba068acae027b0b8d13c9e6e3b3a4c49d53974f85169d4aba24dcd73c090306908398e6de51bd32943efe1d54245a37973385d2fa183c1ed27a4353047d70fdd719e4c1ec51b304e772bcb3077192d47a2fb2ab2d7ca1d1444aab69d2c1aa1fdf043c7656141d70c66af9890fa4a97922b03b2abdc17a1d34f5ab3776ed2108ae4e968cf1e601def3d8f09cbfe624499fd8a06a5c24c312fa02d43e98394944bb4c47515c9a370773a97ae8a3044e2995420bba8b48c58449852c8efd92a25f16642b766baed7d0f9fb7017fb7fc0748db0636b1c43eabc48053b35ba24f313bf78bb8f24e7e663ea4363ba5ddf5439e79e69eeec652620651ec76e1b27ce0c8faf0048ddad265e37faa4718a7210efa1b8315ee6bf3547cfd53cb08450cb238b6773ada4a94ebd6d85981150d72deaae4fdbe5307d91e080b03a5b7c3cc4e9b38ce0b6a699dff9f638a6a88120224f47379435fff5f9b9bbaca0ca264fe32672f55e91dd9e7b4a23c4127814b260a44df0b24bb55117c28ea10d2c7cc1c963bf3b5dacf9692c3452e19bcaa08509bb39ba454e66de92fa7276e5ba43dd34119bb0a21d9485e747493521aa07b218f2a719b70cb16c207d0d697f1ee9bc6ef2e390ef34688466a42f1faad6039f85329fd61579a8d71227dc9047582098bdf414094f8bda6ac83215b1259117d377b4c5a959263af0ca44c50459c82d89ed5bbe7e218131b262d567cb82c94bec21d7b642fd5305ff9c248a2266b16041c368231393f778b54965ba80ef62a2ee2937ecca991075f042bb30139e92a0f310b5b94a9ac1e9f89c4843cdb772c81c5aa6516aaebb71d8993906cffe4cca86625ad93036c6eb01041fb7635c45e43a7b27c5b8b7381d03f465c0959168043cab0a04e7b20c626d043bacffb56eea20a46f50eca9edcd1ef74c3fc6d067dbb89ee9c75a00d3df8927d2dd6ce5484c39b751d7e535d85ca35231c928e70a392417da0e24249d099059c7e6bf6e7c69581f78f77d279105cf9f2865065a87840b00f0e74d524be5d0c40dcd50f69d98124eee13ce99cce11fd93cf0a86939b29334432f7186b547f68c88fbb19619bf04d2908dfa8139ae63eae61550e829d0c51e3fabc6a3eeebf0463d2562adc2e961ff982433dfe978e545817e86f3e25a730345a32f75d371c293f611378476afc3a278e2aa076ba851b138b6e14c0971d7c8b341ffd9b0301ea51592c95f6de6c71df45274d68090ebfe12a29dfff779f2c8086ee812c3f3da0508fddef32b884980e99d8f4edaf086f50151b7403c1fa4b8d1e5dded82e02e6b89375a394a9bcb313b602510619b1eab71fe57b6646406ec548f3f6b4d61b6e76ca2f08483e772cdf654c7004b8d561c7cbb55a4e5e900ccce92c25270b3cf52b18fad9f83503b639101a2fbb8ba203179540ec5034e3823a46cdf3c5cc0017d7a3f536552dfe8121a663ea41b164314e901b9237e09f3e7725ed6841db71e4ff9cf9fbab659c2baeaf715287c4bda4436286fe0b56a1c01de2d639c15cc5e114a749c2142e0b501cbcde89bd07e356bc4ab238a59561205b5629d80c1a90b24b362feae370cf4ec196be61d698f0f7c34e69810e02a3940f134baddf79084488e93fb2e9e52da11b27fbc57bb40fbfa6c40ac285158b68cfe65316031f06c09670245153bafe85de1baf27a2b4b1fd2a57ade40cece4d69bac84ad50fa5ddd9573b1ed0a658e15ce7b5d304a6010cfb8d292116afd174a833b7ca1f9070239dfb39b9f8e577f84d0ff80271209b77e8edcc297308b3244b385cd1c9a6b578f565cb65cd445394407d7879963434b68e3acfa4b3b1ca95eac09a4081dc2c529a66d436650dfbe84ddfeead15645ed50768aedb589b6eeb10d053db76ae521d73cc4f43ac7b942e1c1692446a36ec44b4c0df116e5c5985bc4310bfdd9b8fb4b489ae8c07f1a7c4b47f5860c673f051447015e92d1dd27e7feffd46d623d53c1f2153057f8478ff38b23c8ab87f916ee342c84e9505e049c3be560a3ee8a92438fd8c73f4f3b7265e4b5388ccf8687a8d10625640615c7b4aed206a0dbfea52805d9b3cec84ad619dd510e209c163e0e124f9b693b78a01c03f4da302fe8af09dde1cc2c53d192a40558f44f8877bce86f511e1ade81fa808e1afaab3a7e0b76335ec5973ee39ce708f6a9f4ca3b92c3f55543b816426e16f2fa85ca9926ddbd8ca36ac4721d21d4e39251ab0d3e706f65e0fa9c72ad91db5792c0cb4592b29ac96aa3afc6d5601470326151490baa0833a119009ba98922d63e9f239bc517790b192b5a56297410d42186d2c380910c718c5e3be247f6bf2c31f29627fb15835cb3be243758b3a58d63cb93cba3512a01d0a16675a158cf80742f95118a1806c30f99e207e76062580babdb5eab0f7edcf6176748463817b8afc30641237c8d99375572098137cf32b2d703bff0a3e2ec962a94ccf5e92bc1023233351347f45cd24b42435dab6c8735a24392d4585410492f57daa81b8b35fcff8bee7371b9e29b3950be1ccd299de806a040f88efd3324f5c09a8673026ecaa1d3327a7daf0963bc10772fa29d6aeff577558d0c89be0deed780d0e4f5ce536e7cf946b9392b3147c38f07376c337f6d7a7843d39693d49f2481ebf2f50b69dbb69b4ae230c9a8071a308e1e4352b3d6c55ccda883b3b938c5924aaf4f9a8a232e0fe84dca594cd211f6fee1ac15ffefd4e578fd6665f1bf70292434cda2d3a26c5f98b75461d75a4d3493b89df9507d08f42e98e3a4875bf25f1eecf427529828148e2dd1aa73dbdb94e55aed28508459961f4af218218ca7c091b9f7e50ba7e2fa753e6882afaab0e87ed56cc4ffaa04b5a1f78ff402248b2bc1f1cf548713644defe855f7545e4e54fe1d6d93b2ea7edd2b6dd83a0173af436c6b910e8bbfec117a5dfae24a06b4d89622ab53c2c811e1e0134bf08ab12d7e3c84cd701eb61e7b3562af9e4f35e1f5db4f9ab2d76adec66b41050d45f6481f0a549f37fb76b7944a8ea63949b8b884d9c751cc5f4103428575601d07737ae70c6df0fd68592c394d26b183134740dfe1952d724cae73aba97c7274bc16ab5c5e9df243e84bbc60190f85464f60bc1a449f3ec0b1120ba505fefcd6d74cfd36e4e4ddfe6029f0e24807dc4f851182a712f027418f7941113b7d8f6cf902dc5fc51cdc3a9ea5fe84bee513dbff2680c690dcb42e726fe79f2fe1dfb2a827e71f607a055f32d280dbf6b1607d2a9371ff650fe9c69ca0cb85c6c514d62e041e4a330b75887aec190067fa37eb7c4566d2a145abe346689ed15705720added73313e4e7f759fedb957ccff107ef961b270c29674aa3b2dfe55843f787d7ec573297f00539259bc60a4fcf95740305c89fc8156c82a927f702d017d0e59725260c41a6b3211238847f47dbd9e791d573e92419495d78e0eef7e7dbc8b6a9651e3a7e55ac271efbf44ac1344c5c758557a0f24e7f398963c5fef95f2c33ad95ccc93f8ee0eb6986c47d801d0c4769b5c6da406161ebe6b9b18d27caa430424d4976362afd48efe04653b6fdf5fb06cb48da8375186fcdd449cf7a8d43ba8db317b81e9901e4640fcc9fc9e3c366debfea335f54fc7afa6f0e779e1a43f6dce71d3089a16877f5247742fe3dee5164ca650932f3ca398597036e8fbdf00bf0de77e23c75a408e7439702f8d921b64b3c521758c41990aa9bfafc7aea61a152faabf2e1dffadad9774bd4367499515f5b73ed8523d0787ee73652c12067c6a7dd40e4631b19effdfcf77ecb63b9c65e976b5ce02b9e127a9a5911232a8fed45e9c39e847eea91604e8afc2da5a506e836328a2331d56a0613fef0c5db99ebbf56e63cea026290c6eb03225feeba2a0b15bd2e5186a7bf88f7b35cfb5af758b1b0e376279a082f5c5429bece8efa24905e6e5ffe8a719df465603a37eb3665f00ebeb11682d768edd4c44e498c1b1d3fca3226a98e689803d1af4391caaaf85e37d69f7cad7677cbca289518f31a12642d18f19fea1e4d7320f2c87f7702ed02a92c4b1fbac38d99793b3746a651b03493f5d8fec0353c39e5e9bf54281acba4273c26235d281cfa0261545936d60f2615c4baad3bf4cd98340a999f5fec8325cf3133283c55157e33e7274a76749fc866651f2dc4ad6acbab9ff73eda964c9d981c7ec9275db1796858925bb922fd4796da47eec51b55e3efb00898ff3e5e496b31d8efef9ad9dfa3d23c758bdb4d0faac685e85d18400d6fa50bc99ae6b24d6d7a8a84575f2b1c2826fb72bfb91943272d8ebf943ba46f9e2849f4e8024db36d4b1a8c6be1b47d259cc77dd8952212ff420523700d74961191b317111b19ceefd2474a5497d0d22956673461a759b4076754cb27dfbcdf5049c8c9f4e2224ffc66ce9770dea49808ec9c994d339709df0fb70d29819a2d95f842ba71ca3f88e07ba0557386d3df6043459ab71ddb4915195ec949f2c71affdb5192bc151344f78db1c5560e8ba44041eaf330b051d8deb6ca8fce6dfc29426a0822c18178d45f671880fef41f50014a97772f398248d23dc1c95d150f5d410d2ac7ef428e63a1274a21381581e850f5f05fd100b4661a24453fdb7e5d3a9f96dd20005580a43a026023aa48b8361a7d98edd323aa9a0d95f5b26227b40b0e126d3fe8c090867a33989fef34d1929e74176fc194b843586d76f13fa18495677c1c324ccb57fa8ab34c43f0b65c4d982154ab53c6775e5109079d10b3243ed78bb951a007875677f44566cbdb32bd41a3962f5d409de8d060ca810877970691833330c2d7c00241b7298e071db4ceb1a62de2315ad18b66a44f9541a68c8c2f326eddd8bf8285d9faeebcda878811a1419635fd7837371b4a7888949a2ef320c07cdbb6689022e522759cc79192aed6b1071442a4f2602b90e284d8e8eb89fe45cabeab2892121177eaa9040ed80ee4895518007df0e54b3661e98a17effcb94ed8cf72e9507c627ad09230c003a23038b544a6e5ea2ddd6413ee79b4e9de639bb213fb2ee5fc707005259917901ce2f49ee9535c34f70b5a9c31477bdffa2d94329a7587f7d077e4b62dcb62972854f193a08a5510330ea4082f947e0bc46fb151ab0ff23bde72ad297c1f23c89c12c0a301840ae1b75d1b6dcff2898a0929b9a2e957f4c976a5466bed9c08a54e3e21789b948d7cdfde4e43ae26db4582a724eb3eb8699475e91238de83864e34178313689afc0e44a785d2f385c536ef15ac1bebaa668f06e7a320b1e6b6819cf9778264ccca50df0691b8d8659ffd1c0b0638d3b3a4bc1c3e9ec1a2282becfd6ee26de974a0c4def6e6ae40f09b7b0846618f2815f9dc0eeb2dc480f6db6f34266612e0dd88dabce5c1181952b6dbea73a9b7f171006ecdd10b797ba6b077a691794c0c886222c89185f9c676258b5aa2082f2cd9787235fc76d7b6c3e4faca578881b5deed45971267fc951a70d85df6e13df91b10c51257211fb99b662cc3a1bea3a1c6581af17f43b7f0d3ff5a943cb186edab8d5761ab6bf11653ed632a3e949e9e62aee74d5bbc552a472a713a3a456dd4384891c651cdb860d1102b162c1110c145b6125c39c8f59302ffca40dd92d33fc27e69d87fa4f1b3329cec71bf680e785eafed9e3bc049fe393d2b3786601e1ccdd6b0c24c73ee5ad8cbf508440feffb519668f8609ec9b7f2e2850684adc87b5ee9f6c0de99018817a71d0bfc67c262c3146c5f224a34371a5224019138e4aea926749732fee437af8006fa5e11fe40dc3223d3d254ba00f65a18a0a47922a6818c7d83bd45d203d8299ff3b98a07f9df06744d1bf01c1efea8a73778979724abe5db798a48016ae1b74d00310e89515d50798ad784621a1b799d41ba3239bb985cf1b7355a764f9fd17a8178cd545be15bfb40f2634e73d2cc5fe631e28531e59bf7ccbb0903d463824eab2fc028a02a159145c13783df924e5f88c78cf4b74daff64fbd0fb6762c2ea78df23d6e5fd45dc18f00d493439f3b25e4a8ccde82fd9af886451af03051a92d41c93321d2763785a8362e197bbb209a18149f94900097ddf29ce5c8ed1e0edde226fd415fd1a8714f71469077ec289aac78e5c3649fbd8f8a34bda62252f96065cac479ee141cdab24974b0cb0fd1352168b0da625c42f2ef304bf66932d195b2020050e5eead274e58ca749eaeeac68872f74a9fc6e690cd8b075154ed85618b5867a19db3471494f18314f593061ae18b3360a798d131c90d5a7274e31952c97346a9d12618453fd04f160a3136fd92e64da93e2ebb85ec2d585722988ecf3040cb4111439f75fd6e86b0b665062a66b4955864945525bfe6cf04a480e875da904207fa2481a2479162045e2fcd9f908edfb8db9cc7389cd51f4fd8e2810d976bf2affb9ae56343e56635caba16cf09e92ceaea31dfe6f3f1962beadfa1ab2cb7d0bf73506ed0295ce06ab24c7837a89f922d9ead100b74b230498c7671f5f0181d1e290dea60a66e1315c8c3f3725af35423e04549a105cf6f8f121d20df485daa99c1a50f37bf794ef942e67c648a02dbf2d095641da4e81e5aece77d96247ed73d92503de5811942fa759d87aa14644619fd627d64746a62fee5683422da9ff7704819f5b8dff0bf1da60eb85e815ff7176e65ac0bf91a38484fb625fa45efe32c948cee39ac4fa2eca23719087b426555a57004c2e65445219497e3275c5e16e5ae57bef8b347451d9601988eab9e11ad89c61c9d3df37729c1af460199195f584e1b51801983cc89f426af0c6a0c24b7ab2b289735a03361940edb29ce529e59912a4013b01055ff0afafa6fc79db6cdba8e2cae9f1fc92cb51e39f326f932667ae39a9fdcc476904d87bb423f99abcc4d5608ae1284fe6a0f251d4dae59aa7a3ac5797080c2c81516051ecaf7a9f6bd1abb81c6fcc8a56fbb047db79c5ab074146a3470006cf92234d968f091dcff6ce4de28d2f4ad61fac13611187a5838e16fc3c43f195f5edebfe9b30bbc896b06e6f4080f0f985a0b0d407a4b75823bf1df2df9ff2ed0df7cec4ef864dd1096df6cd816d6d5371555106976833af7f546326c0ce90799d87e94ce02cb2151324644442bb0d016a91680c727ff810021a4b9fbad1eb35b5ac22707f01a9b892d143c69d3367f2cb86dc577331baa71426c09a1c4d5f616e171b9c6b9d59b1d6bfe68a3fc692aabb873a58d0a8f7cb72eafc3a1790ea01c55d9253bed823609e2c02fc3ca76829dfa630856a2f633144a4fe21e3418a2a35169322b3bc823e8db31c56bfc5a982bda078fc0cdf400dd7452edbda9d815c1b0bca902d37b548c92e9a0b70fbaff18b491e58beb427e2ce655033b412bddb26d35a610d7458951e21451f62f101cd72359d38434bedfa3c72cfa1a13d3ae60febaaeaeb67de18d1f439e1fb7983bf0fd8421ed8c3bce11b332163a21d6634046d72477820abf6b0f943d6884d3d455598acbc477d46f55c9c8107bbb0f1cb333c1c406ff5ca4767a56353b4ef7622727ee517c754cbe1df045a835351096c875b48443781178ef85964458475688c593bb911c3449b66cba4c560c2dfb437972b3b40ec4b088acb5cc5c795e35a4258f797b875f825dcfd0a4d99e6ba18b9c1cc79e2607021840a11647222feb404c323c7148ff5cfb637ef826213618cb60b1804326b992c518c67f51a101e5c9edf3367b8f6e41baf70d82922ff7e6160aafeeb6a23870cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
