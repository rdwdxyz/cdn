<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54e3b6c5b5fce27ae613fbc8a13799dd6f67154b215cafdda2a611b5f32ca0822fc9a25d3eeddae98c411fcab62f322a77e14b539263c664fb6e2bac31654163c75cb2940f170cb8768b0bfde6c4881951445b25d976263f5311b2545668742306ddd3f58f709702639f11daa3a325885ff458f3d51b87e787645499e63e32453adbc76c2873bc90dd7eeb6daed8f84de547e24309171c594b9754af82ffc987e32b1e7e4aedc86418a870e0902000b4a2985b79df0551a99da8060890899bd448647ac57e650f67a8860401fdfdbc535c48933ccbca19dc73726e58da0b44358a08a336e3879d3a592a233e5051ba503e76a80e1e0d1cea18e28d88aa2925aef12ac190082b1a0e8901d14df9db1040f373da2e27bbda957eaea95d8c41c0e5cfda7178cead1309cba209439b9b08a11d1e8398db4529967af01afdc082b5bc4da547d744a346c85b5d0c5f02ce374e7db2a6c8fa0ec36b857d3dd4466166fe789812eda12bab3111c22ff4ce616537fda4d562faa109d9c01656cff514b0f39164d5732abad2d23e6d5fcacb6bb555f68a02b79b1c8f38febcd6f162630da3ff12d5f8ff44717b3b62092a8eb83ceacf98fa7a1d999166714d404987d51901302d25eafedeaf4fedddd6570cea8d96e2233352e325c70727b2a167ce51514491916d8d94fb96ba9f64fbb5df91363cf2dba0bcca982551a866ed316bfd8b32e1553871015045b6204aba1a9b2a25c5e013dfb635d1ba9968c5f7a49bebd05c18b212366d87915a82bab643563f99d33d790cfacf8807a5ced499daeb15cb1fe4807024f38741bdfb9f59d795ebd0e389af2d16263e35994803e6d94a22ffa955addbed5663ab22f08917bf6cd20614ee302a74670f05b2cafb7bd9e3d4473f2e5bc90b1ebbd1ad82f1a00c105d5682c5a1dbdd88bd4a429c4147e19af4ea0232c392e9e36beddbf3de321800546fcd9d9b6c75cf880d454cbc6854376be854ecdd180bb0d727627a5f295d0a0c28a52e9593071b11a0f92ccc0bf63480712389fe58d75f7c1367a26915f8cd495daf21a193d56b9820253a25af8bb0c817261b42e00721dc5d01deacd717fb39f5b552abec5052cb9809db01bef8fa2f6c8128ac3a883ab8542f067f7a3feb49c3778f3d8707476826d942566ce32e326e51031dc5c0e516dbaaf98c72c57090cb98f126caca870e01c856fa70c71fd16401aa9de4014ed20169c858f6767a1b0a5d58ab99b2df250d7027d88191342c13b545a2cc0451f4e5e0cf4c7c0ec76f81096d945334dee72274d77bd08d69f6f331d005893e178c197b89bb43945dd7b412921288227b300cc4de82bd97c0d6ea14ee35230f8c1dcfcfc95b3c5d365dc1c5ea69f59d42e6911063e7be651590e768e4de40781ee2a66e9762adf64303e554fbe6e2be99abc779884d0a1b9c6f261677c03753f607a520d3ded0e8fe5a4b093015f636e8c253a1b6c92fded408b80d0dcf623dda9202874e5a20c6c4b7a8c2652114a38d819cfeb14376658511c4d33c1d826412e659ee9633afff6c4f720a85c8f6af3f864ebe0201769ac559d2353a4cc9072162efa924292a6cf86a047b90c3635dc28c4f8366c81ba16085e9ec33ae8e9b2095bb219c29a36f82bacbc181e4fbb65f486a2c3073027001075c4f897fad23db2a8e8a27fb1deea051d36f947827214e43899bff5a92ae8ec29b7e0de4724bffc723381ea2825c5b7a4e3e6a5439a44059bddb2e8b0302676a909efb3ad67dc0b2b2616b43e72535334f72f0860099ca2dcdd5f901f217a17083c9281ef95e37af20da18c2fc9d5b1bdf7fc02c92cf7ab79f9db3f8b89baf0527cbdf1a2e86184e14dc25c625a7d5a218672d408d87105fa1f487e5696fdad933b78a8e7f7fa3eae1cc439f595c2735358b2a0d3f27a7705bfba24586cb109fbc0c9099876120305bb41c26e89716f4daf6b2ae40329955ed37683bd2e0fdb47f72bfba5dfd6d4e2a5c07c69cedb988e4e9fa176e745d8cb9df3c7bf9d1cdb3ffefbbeff4653475ee676af3b5dba5166eaac03331464cbbbf1dc916fa606ac24192211abcf14c52a77628bf8b52c6a39612cd4368f5d95d8da8af0acea4ecf15a21facdb9a83c03b9808f51cc07ad1f34b62d91ca183771d3231409d67c2b3b0f4387871de603206877c169f5586160ea4ebf71dcd8ef8b389f9af03ec3714a0c6ecf088f97d1cf70e8a1a74109133a6523d48189de560f4b7002c7b0aec6f8e2fa19dca12959621619cc40ca1bc9ad9481d8f0bf35aaba256fb297dd9369b3e0555d4ff883821390996d2a81ba178828be8548de40e1f7546134516c0f76c314965428512d831cfc012633d2e81930eb75fdff114ac9dc43992a18703e3afde62478d7a1bc03bb6e255d5074e988782eae1cad4fb48b8ae49e8293f154b085edaaa1760a148f3361069c3a345dd71c275b92e90efb54b7a1ab5ae133447f6375c7112ee57b3d1dd7769edfacc381d9882b73f74a2254a7e36194bb0ee0c12fc7e984eb0eb44490d1161e056fe86e1ac98145cefa4833fc112832867b871b47e17672b9a71ec2a76626d1a9d3018d52fd37e63ce4b1b85c9330a0b67b03c1f75468e1e9afbd405bc953927c9352e61b0625dad1c32d9ff1480529b5389941627be408d275cfb88610d6b6aa87c00ed3ed6a7da917303f0e3038ed71f23eaf606c0e22bce5be33d698efc5b6fafe237bfbead1c3aa6bcfd2817f051d203a3c449b44b6780703f6aadf73508e1881ddb0ca1d58bc8e4f4d9564b5cc029d240c788f3eaae37fac03a9e7de4ec030d123733ef9462007eeac2f3a8bfb687d0e569683660fceebbe80d7b388fe3e9a078810a5c2d51199121f03129073d1b69a197f2c080fe583351cc0bd6c43fd9dcb6b312f5822271667a199272cf390828ff7de6a6f3d9fd662b35ad331f327ee322ca19f913656bc642056b27d005d9906fc02d3b4b5258957763755b78607edc46581c2b7d87a2a7fca300a2e7e8fc17f2487609c9b1ffabea35d50be0bb60457a09f108070104160cee555e3e6980b06942ef2a4c4fef752dd1e7e0a5dadefa6e6a3836b3110f03beb74f5c543969ee85073c2410988943ce37912cd7884ecef79e8a7911fd53fd6d8f7e11dbd7ec40751699ec1f03eaaef9dce0b3a7181314cbe54cc806cb83351de787ffd3a9fc97a3883b4ee7b90176ed90a73e26a383826ed4dad4edeff9b44837441c001d4f021638bb63b4fcc0f400b4af9e4790079712f8ab47a348027dedfcecd8f2de29e11e9d3ab65c8a950a611720a4d727a5f2fb32a8d2249060174c728ce5270697a8ed031ea2fe069a310585534bddcbc04c7edfd803cbcbd862e4ff7779c6e02ba40f5ed8acd7d800416bfef98b50164b9acbb87844f8befa0346d116e4cb4f120983bbfe1ce346adcca32d22f4cb71e4be568b6a9932ebe5c64363b9fe08effe6d4c55d31e82bd743039466dd99a428cbdf764319205bb54695b5da252d1198c9222947499c36ecee0e20f21313f8ddd278f00cb3e17bdc70d645caf829aa2e0db789b15bef4bf4341a6efdc06ba60e349213931e97d95def8e7189788934a3595e7fb197cf0c09a4203ce7b9b34a37729b964f55084b6ec1c88f05e5b8e38034b3e673444859e2997a19c9b4a0140ee1fd8b168cd06daa15c2f952df21781c1f9f6406c74a38995f17bf988bb0b6df31a770b40c4dd1456532a27c6aa8c43dd993610e529ec2a6ccee463ad7686709a911bba933b74cde51835b253f093d9f944ae12c65e7b840e3e6fe8278534c32cb36b7eb2313a5f2905283bd2afb94fcd6fdc1c0bdff6c410e0edce220a098f4cefa4dcb45d2445bb0a821087576befda7857e7793b1d7e9fb51231b23061807f3354a6ac2b183f6f903ee251d2e32286deeb73638f814e1584b6001e4023dc86bb8292efecf80ffe61b506cb0a20e59266e07daa7525fb24da25535058575884e641237c41f75a5d597a33524a39332e895d8644f6b2c4d80d29dd893348d78cd6701303f88c9ea7878a78b37f3d3f98a16d261e8b9ebb63bfaacb793c4c020eae695cef2fb46fbd8ee56d2a326b12bd072f7f737949e5c597b521516eee0b6254c24030a4c0a187935c30d208deb095ac09a80f2ed10707d145b26a8161b55243533de4309a62a3451208e28c7cfc0d79484f0921de711449b0a9023214e91fc048d3f6a6f3702af63252cd50215a53fbfec453c471b27c658dcdf5b4668c8e903a5021183abc638cc332387933c276ac96cd2120c2035a08f1fa3df55af1085778d4a6b4a16422b79eab45d70095038573f1c704c3565b35fc706460620231aee7cd72cf03914ab5977482eaee6261f587407b7fd506dbe68b62689e2fa69da683beb5eb8627215bc4d4f874f687d9155ad8580ae6584d7b74c13efc64e995482b10a22e96fd562233eeb88b293486f1ec20444fa3724f61158bc3c192b096fe7cbd46c2d76b9e8270a49aa1f154211418469098e8a83e962ce111021acf8a28e4fbca8ef98d2baca749d880f8349633a601baf2cb70e08d96e49b2c6b4192c66b1cd41843e500941db2bdbc064216c4f468dd757d9700dae1b325b2003e72a64a8f0d3d279b79062fdce42345dc163b18109f948524f43a95f073c0b19e99fc3c9135e5721a5978f4ca55835201f789e9070aa263114d9f06f1d12298f9f156fa65b990e69a6fc95a16a4301821a217cb829aff92dd5772d490b63c0db12e7618fb960d61c2656fd819c92a9cc92705a2aa8dc5d40f3600c9482b7b8cd30f12810f443f326a15506fcdab0c894ac3b40c2ecae236ae0aac73c119d259dfeffb41bc77d668f86a283159c0d4c40c477779745bc6169b742ce68819cb2b14157b344e8b85fc912d7f0adb0ddbcc1b304b9b4d5a03976fbf0c37d890655f4d92d36d837aa5149efd99d78321ea7d18db798328bb488248b5a9914a01cf5d67d89137041f4fafe466a5c160bcb0c98f92c00d352854f569f586eb49e51b66d4c22149ec3c061693d4ec061b1f6e07eac880382d06fa95606db9fd8276b431bfbe8ab2e32fba3ed8c22d301e6d7c95b10239b0a762d42a6619e39bf3e8c6aaa653291edfe348875cbdd8f718e7e1d283600c73ccb6532891202dd887053af4411c3ed3f35de48cc6c989a96b170d1e563afe95e337c886ee017c2edaae0833016513115625456910c499d4f9bdc4f0f89851681fefcad4dc37fc4582969f0912080c2fa7427cf6926ba69caad7ee4dd8e6de932b3fe053dfbaf4cc8ac5e8785405d1299529f5afe1bc5de4707be708e39962e3afcbbde6e102a373388966caa047ad178d772d4405507d4080605d609cff2ae05a44f6a94de7f61f3359355a46070e238c7981edc247580144ae5b4554692bb7772827ef82e66b037b9f3aa3fac657708b301816a081ff7451713beab41e2f54af083d02008fd67c272bf3fdd0a8ebf0e1ebd4f210233170d1e4b43c6eb5d07d34cede2f0e998c5728e670ff66f10387cb6a8280eef5203e5294e995069f3a3dbd88213a19f7cac6f1a8b79c36345fb2f7a543cdd8dc1fe6a600c84d261db6739af667e43e50a36a47fee1dbe437e0fc6ee50af5ba9e2d14b40bef68a7e406d618175377fa43f61f58322a65ec564ec50fd95cc24ececc51f1e35cd7247f6c68206603c82eeb5e79773df2e60dd981eceed83e6ff5d22c1441f7c03b8db0473de4d5fa9edb7211f05ce8b427a9cbac0d4612fdf2609b5b42502a7b6e27e951129de396fa686c58454fd9588bf7911b0bad3424a1d9baedbee0143f26554af170a5dee0567a6ab2c6fbc30208d47b09c1269837c73d3482c33113b3f81b47f7d21d3225b0a85e6d322253898ca40157c949441333699e922d67c94d998c231735d1574d3533b222489bdef377d8857fd5b7e258352c18b6a168979dbf22f675d62a934e8aabad907f0867cc30023b3877d87f3bb29f0cb952c8591121aac8a939ba7dd93ffce9273d4f9311425349df72f4d1d4f492b8ffb50ead9ab11c8d75ace7b1c49d309a3d7ae58d51022b1cf57570829ab23b38a3883ce80a8bacf9deb9eeb02670c9a14e55329502094fa41cd2e30c94b9797e6dabf5468e35527e852014a71889bcfa34ad02f45e755b02fb3ae4c3ac80e61a1316415673820ef0ba591ad9ca05bfd45d6a27e9a8abbc2e35a3e57ec4aafae5f3fe224accd894ef88e7c50f151b7067338a1825aec1959d67db13ad6f0e7c56c4563947c7fb7cb9439e65fc8bcccf9068ea6d6be9701bcdc763fb8121fb66ebc766fd385b7b13a607e7831b2efa773fe2e1609e9a75932d3525e19a678b0ccd286b1cc48eb5f21607d3af0f6c7b52971657a05c5364687f58b9caefb1ed17788159a32a8413a509841ec02849fadbb14793775a5b7bec8b56c398fd4eda753081ca4be77ddeff5b7cd1f1c9914aaa6fe02c1f8e710b075bc2927d07b3d0e1ec3ac90469ff679b006ce0af8d80fcb9a876ebe7a17bb5a60a4aeee147bc0f3a5add5932c40d62e882d38b064cb3f0c68b67b9eb07a2745d36566e341a1e9fd9b777c68eea1ab56858213ced282958980afb2fc350ebab820fb32d4ee1e4f1db14ea3af2842405e0e61e8e1de0800d50429c27cca5bf4a10842900c850449f7301303594d9cc975a110b8d75880ebf0fdf8873eaa496585bbf99653106220b03a3347916c1c3457f329aff1f63a712eb224d5cdf13e894980de6b10adb82b76da3c359c88cf77b53ff149b489cc8a892be593b418d70365a74182abf45ce2a6e8f62d196a3f831882de4d051827a983695883b61d4ed46a5eb2b50b4d5d5d4a0fc9d25193dad645861f044ac5d2d515ecc2ebfb28e07c5b59e4c774c449a44572a9b997015c604311ede015cf266d48482262a4e8062b7a905e707b35f154d6ba6f54ee37f0871f2a142672d39d918a99ee3ab1b7c54c089bd082001ced9e61f3537abff008498dee96745e4752873d20d017bac1ff4b3acebc84bee27fe720eb84f343826c17e3fefeeb47973b357b1e6366f32193e0422fa3fca1111be5e12f44f0c1fe6ef38a2ef27ab6f67189d0720b9382dc08b5670f8172e34eac965d508706dd2b8fae815f254b94d39c7e0e270d768c25d21702869025e43225f5c0e0bf1b9bbdc00b9dbf07d8dea47d5211718d9dff0a12bf3349495386c2dd215154a339fa43106da1a4ef261ff4045b5463dee3932f82bd5a0178167840b4423ece9c76153b720cd12c94f82c9555e76d1e83009c4ad2f4c0a7f7ae2932e77a710fafbe06229adaab6ad831ba0d99619169217a5bdef65365824a3b41c667b2d4feaeca2ab0ca0d05be61fcff7fa5408924b649b6ddf665844afd31a74fe79fe52babcd67ee3ddbccd5fae2c2489ec20093b6d9f345a39f85a207b2caa1c6a2bba3a1ffb5758a57bf58fac9bab6f34ae6d11ccc4f52c163726f0aa55c5276a7a76df25297b83c54bf516ede34948129e8e013e564f45514cc4ade3727081ddc4df811b85c679091c1a4ba8b76bbc8c1f8c2c11eb622f16f8054943f2dd80b20620935bfcbe3633e52d3f52782679ba49ab118018d847846eb25eadadbdbcb2800a0ed4d12324615fc9e2fb6243966e665e40c4a6a6a5f5964bb5c714105095f0d0ace9fe07fda301f4ba9def002f9894c42dabb3f0e94cd57a8f62d37301377facf9b7e9b22a10bf61f3e101e1acde7ef856bb34591c8746d6fff7fcf847ffe9e03df52075cefa33549bea188c99a3d70c43b388a43ab9d26e09873cb067706d5d63cd3e269008c3ba9bbce55a9a4267c01faaa7cbb3adfcf64c7a89e04d6b58aae0f145c67a2315c9d94d27513e0cdb449e80f5136fb45be884520e741559ed6e3a49c27de079e6b653e65e70711be858300494b9b3970d54ea0093a9ca21d2ca6c14a99139c459308c52e3d4cc6ab7a90b44a17091493cc53f485affe43c661e09af659c41230b2cc9015e47918d4a1d0399ee532d060a00b6cc7ca4e54da6861c90af93bcdb9668fefb0522245d23e408712e07cd22de804ceb7c6a10dd4a9066d8df92f5359cd5fee036afebf73f7013ac693e7e992569fc7730d154209f012c0b2e109e490ddd5968634eb6a764769ad4f37846d99861982099fe484a66a00579151588a329c51cf33020fd947220da8604a7f63fb79022aadb0ff7a1689898e14274a69e927910e6f4877da8906e6e54cde2fee3450b096d1649a5f0b9879cee8b023ab7d85ee632edb6838b1ec2976486b3de04e67db86db64b2a164d20911625bbe384d9d046f3500c4309bcc897e472a2a84509979d6d85c66ac18ed041a8ccbca1a9a66e49e02f8620ee2a582710bff6347046f6338ab2e469b8e8e046db03c52f0d8a879c6d683623042d463ba4c56e23138c31d83b306a1eff836dda5ba576fb803c8ae9f951b82165d297cbe6d82c7674c7f670aa4e9e188b142b5188c086e0ea728bcf54b2fb1d20ba6356e700f0de7a3ce0401e09865ba7dcc9fa748dab41fde229b82ae6ab808a5b614048502833b2a9dd44bbeebe6506634ca016c3e49dc0d6e778386e2df83998257b05ac5f7a903fd1127fef509d46acc332c1c0daf937631bdb78d012e6b3dc5e6bc2e4b48e6ca866cfa2a18520654556fd53be972dabd64deaa2d35ade7a7402aa4a345c7db747c85126bb956f334bc192cafe16516497cc44e08fd3ed38fd066c2edfed783a4646c32d274afefca5e831eb5e901df2184f8044b8037c402aa78fda5266310cf6bded146af65fe71269185b52383b9c29b0f26068c6f08984aa900b7991c6c41d665d9c9c685fea34d0d1c41908ffd19581e30c6a6a09f26690c449572c9f915e254e87439641f07843e97b5e8e4b3bb7d8e91a12850d12db7f97b455f52c12db72ab7f1a1d559b5e216870a58d7cab5d1d71d4430c83d3721338a1acb831efff0a6b8103a5f19e46575eb807d0cd7af66dd93fd731d2421d2bac8fa8f5403d659b48b5246741fd5b009aaf690e7d2eaf3d56e3452fa2fc7673147d1e15ade2e13210537927e51695feeff3e27f3f2e99d41621268e33fb676398ba88643cc9aeccde72618793f5723ecb731a539664735ae9cd8d8773e1b519b6c0c8f594bc9d2c0cf7dc41f57b2440fca7afd9a522ab43f90f3147c2f9e1c75e924d789dba88e1c23025718c7a6b9dbc42a85d60fcc8d18093048caeee6fccd278306a65a46f8468625805bace7eff21542c711b0ff0cc77b8fc6c62afcd6040148bf84e849f95be8920c8994f24a627bafb2540efd954f9939bab2d36cf5f0e6e6debd9b063eccbd1d3774e1353396818cf31cd7bf405fa9ad5f1fa809fe69d2613db4f97bfe8a7c297e8448d894fb3065362bfab73b5fa4c71e54aee34a8e80c0a14f9063381c0bb798865822012edd6617445c02bbf78576e98a4a164fe23a1abf87dc5b84c0e1aade786293e739adcb43e179a3f356f32aa9a1afb164bbcadc4ae53e766b56a24dbf2bd3061dae53a83008d5559c65b5e41bf7b944d8c15426702689164abb092d40b515c80e50c5e370f0aa76fa5adc4487f922dec9f6539cd41ede70bc2084da1902d7c06ecf5b51a91a9184d6931b7a06bab42cb5210087ca31dd813d825bf425ccaa5b8f0ec7072227e39f1921a4e00c53fa2cc1f215bcf667b053b284fce437ff3d2060d2845f291660a46c9184f1f7875e2445f40239a002f8aff9b0a2608d9267edb20747e3b6428ec180c0e30f4b6d1f499523a6a47c701c4e3a55866f965596c92f63229c9cf7cf7ec1cdfa6eca0b502ae09b720f79fd33da7153904a9dc6f342aaa2c731a1d71f6665d9b0893df19a6da28b413be654276bdd3f7b6f28e2e712f09384d86269e0db8352c5fdf4cdb75303851fde18f26dde3e8dbade9936c5ccda32af4561dbfa72d5f630599ae9ee32878203793ff66d2b6f2c13889c61ee2ec4a3db4c01cfc2b171178e017d974f7f18c8b5b7c48d98bb06a6c62d90cdeacd3cc95b4db2a62e60401228969eed83ea2d873f95fb3cdeaa7d9075fe3e26527464d62f8c695ec69e20fea2ac3f726f369db2d09fa460a650fa777cf505a2e490057d2ab0a939472010a3e6f0c4920b0baf2b45d98d55dfa953e70038f71ead7d602ea9399d534c2afc3f79f3f47b57d68a68aa4b376d7d51d62802baba22e12322183174227faf53af10675d57564edcf3c605ac3cd80435e13c2eeb685b6a80b168d65a8e4cd22a2808d6c20534071336926e7817c1b2c4ae04ecf2f1fd4a4c03648b9fddd73c15d6da1cfb3ba008d78dab8d9c6f95564c6bccd0553465af2c6dcbb59b9b803c9d7d3f63ba5772d78cd22aaafb033ef2996f85818a68bd05331aba5f281567163b42c5bfe28c74d4702fe52d3dd047a0b24d2e7fb64f4aa208220acf625fd5253f17c43afb274cc7ef699d84f1644fdfd4c2c24e258800c44ac800444f38854444d880cb123d5cf8a36e2b24758a1cef1f6f40b7eda116d807763c498ef4fb22c0698bae71a922711dffa1400f15fe42c8ae9e069c0a8e31cf6ea5c446d144c5ccbdc86e8cea9e951d794460bce586ab73d2475506d6224cc0035d8043f876a11bff8160b8c000db543de38bf3912cfafc886901ddbf4892770df93c06b07044f296d87df16c4fa6a42df66e6b1f150aa254128c8c501ac66116605bc47c6d76e8d3279bf537ec50f008bf763b038c892ea61df60928cc3b33bfc615cbdbb9dafc09521094a3d93b49b95f29da04ac113456dbff5d34724c2bff4668b6ea964da20c918cae27ad87fdbaecece2864a2b417fb958b71c361ee3f10ee37443416d1eb56eaca0854fe3fa61f76fca5508c32bf6cffecb1d1f3dd35cd8b4621f9786dff0828732a4095c53211977c513b47b3ab3ddbeb33f6c6c5a87d565b07652cbf2ba51cfd4312632331e5fa1ce161cdc27ea25160c13824e2dd54d33fb5b30374f971e6dc2109b17220f25e5ae64d04ad2c491cfe039517281438d77993bcb6a0dd70dd7254fa67b11a86542f53b788ba7567422f83f009b1d6ed68d0a9b56e9829c9a28d6ee8bd0a7b057ff22b7ea677c5173140a591f4648b8639ccfcfd072c137fc4454431f293eebb6af8a07527cdb2b999086dbea95cfdaf93a1df39a2c4d8091be1434c3f2d5869553465983b13dcd899d2e071563042d29007bc0de4c0e78f0ddfb83645f2740d2dee6045a322f3680b698bf7da073bfe141b2d1e87a63447287acb07d0d5dbef82e539dcc0904324973dbeb7d4a954fa73d13ba35179a747130ffea4e642c6d255977f1ac41e095915613f05e52af9646cbb5ff694e7d5055a03ca2590ed814070f73894e71725a8d100a8a54b67e4c99aeef252bb1c4c5e3fd297a08cf110e8196a3b7f8fa8c9ab63e7beba59d7cde90dcbb280a4346968b9ca7f365983d0463e0901699ec3a70b23052e9ff22c1274874bea10b585fb4a1617a59ead9873a2f778766992e2031eece1b25344d767e96442f8f5270367712e21eb89ff1e6605e3ecc24da19b32d0e2d305007ceecc3c7c12777c5ad394c9e34b17319aa7d683d173e8741e3352d5f9720cceb12def25a15e6a88e176a7df09a67fb3e659111d7b899207dd3f84e6c8b9e24769fd27741054dd455c0321e3ebcff415f71a2c0decd1c88a54b4b415a0e965c716779a0074b714a8c7bff53f8acfb393c9fd5f058c45f83e6aaca6544cddb3460c3880c57c25603b81d90b84f86773a133a6f1ecf8161265212dcaab55c3962cb79b8be35d804b55313c5484fa9074b458dc6c2fa25019a756ae5d31d3b40774f0e4adde88e08c238429cdc63d5425ebed506077c9378625c605005fafacfb39101383dc975a7a2c3842af82a42388149d137d8652ec6670ed92ffe3fc65be9eab00f5c5a164ed684177e24c4539829b6570c8a38a73083da21e4bdf155ec98a2437b97aee195eab323054458e276d5408bc31d912a42a30e19da5ec4a4c217b88073c78d7d28a87762168a5d8ba30b8bd50583758640ccfbf559f19cb076cea3e49708496f5d42af0147235e68e7594c5971ed1284a1b18e00ea839237d475fdd3defaf23f98777042a5d9c4db7db0a63594712e23912b4556b0f5843c7b1dac3749bde06aa498afc60599f80c64f074923c134c8e6c542f0b7bc2d5df6f6834ff54bf30ce34db0b86fceabb5628ab1a9974a8af2a04643d6f3c862920bd1c159802ff775b27faf3c2227e6f9c6e2ab1ace22039dc214b7ba8f9c37bea8e56887aa08e35ef7d14a06b8c9ab03dcd780c58914ae87abb9eec1e31c4e0d67186c21c9bc8631549c5049e45d9a968d69411a701e44bc6aa0ba7a159a2e82b33cee323cc99020e8d21b5aad5e18206ee676d4d0b592b4334bb10062b93bec938a32cecc5a3eab6625a4b2f8b56cf058763a0a3a1f16257ea57709a537d9252555f7d5367a4876dec0914a5b6fb48a9dea36e70ed662b48ff2c85a8d2519761975b0e917da4f0d404c950398e51934263ccdbefbd2f7a719b4b2109010ff2406bd93cf98eae48f4f6ef6a32daf8bc7d4d55c938c397ff45cc87d598cad4e35569f4f95af398ad65d3533b6ff495debe64054ae73d17ee4ba43bc1d547a22f00371d28784c216359ebcb99fd34e712190222846ac59cf7aa5bc10e5c191da96058715913cdf564ea618c46775973aac651a657ebe412de778ffb3b7af82da93ca589a95aaa5ad3b20394242e6b028ed306cb5c5a382ebcdf3d38e57de0e619d67722948dd51e0f462e11e69d0b663f3b0956641459b3ed213e9653a41f272c9be105640aed4441b27d5d5f1512c0e3d0bb59a4b03264d5f66271fbbc4e2abf46b403b2c62f21c01d8ec5dd923e222757ebe07163480f8add7a949b7ef01e209f777d53c8da987a137d73c6aa8f77e1f5918c1af1b1f6ccd2744f7e823693b6fe849ae7fa53d07c0ab44b67e807b30c329a81c0aac02a79b08f28d3a763fe5246c3da7c7e175fd51aece1a82f7424f7cd09f52c4e7b2b19c1b3fc6f998f8cf99bf1dbeb212c0266fd953c1b55528b391fcb7339201fb708af76946989b3dae5c4b9f7444f2fa91cdf91a04235e1c5fefedbeb340c85b3746a920a151940d3a321bfd08b57b2cdc3e76cf956cf9f45e96e90d0d45e261c0d674bb5f5aa1a903ca375b4149d825ddf6910dfd181009995be03cfc50ee66728cbff3fce2c3390b09ac880d056ca65502d9c6adcde56f90abe22ce0b7bf1e409a6e4bf8e6d4f465a65857cc6a0a36d808c815edc5307ed85d194a091eeab655a74bf4b1e28d49657a6444747d26e3c178f4b3584257de5fdfa6d0c8d253cb76f89fcc76a991f0dc64455758928685d26e5988c6354218509386e27125c416f202c5d965c604b29751ada36eac4d112de84efe838a967ee1bc09fd1986214a1597fbec1d458d77a33a1faca70df68ebb879ec8186d164b69a9c0b80c5a19f709f722e3836b5708cb78c3cad51b5ef5853681ad70d83d082de0c23f4898fa3425cdc21a5d8f4a76044662b93047f9100c05be65953a1225db1bb46943bec92c27f1b59625d0a18a4a7e97fb62e6b9ab7bdd96e94c14c710b555cf1fb4e0064d2c8a442ec9ee874d7437e70e2793c3a1ed90fc988abc8c623b619c8056bc70da2f2329b381feabdafa7497ea9eba85b9fdbbbdf1fd09a383070a55a68ccee80c02d5982aab34d48b975757b0217be3643770b22a972130af76df635d4ad24d4b84eb0f0e26886e59ea61cbd9a71bafceb034a8dacc331d2b14530467321665a902684e04a4633b7c270c4e9fe56d6d22a4b6fe6ecffe161af96d22dcaa10b4cd40e0c960a7dfee1d3e6649aa5cadf979bfbe69ad157b4769136eb86a5e675b8f193a1046f174e5fe703c367ce9b3b1148a1b72e1db7f97fb5ba3274cfab07e23707b0eb4bbaeb5f152bde5c7560f5affc4dff548a6270725a96961aebabd9a0060cce4f8b468970db16f2022591a135267e70dde71f109f748015211fbc1070c34c0221e44fb0b2d9ef166d244c51e6824cb0360dfd8587302ac31637fc1bd41e790de37b31287d4db875140cf34c6e0b66957b5323d912ece9343861db9b4f292cf53d5cdbf154965700716c5bf515a793ceb236469df79c20dbfd0d2bfffbe363667e1f661018c221b4ee6634bb2b893b350940af1791a9aa0aa98e806ac565bf05aeaf7b066d8613452dcede6717e8a03189192913aba1157d1615ef23425808b619de52dc13d0c672431812054cdcded0bfc3fdceba401ecf3549a33177fc694a93d96e1a5fd5b2d22641d332ffa64694d21c9001e11a19964ed7cc5eb216db5ec550ee44d2e1e89e5cb0e15517b7f484a5a4ebc6223e11da760563fd1a065a39e51c4da6d018cae5c1073e97530e69f5242df808a87c312d4a442e33f0795effd2bd02081bd4b6a36222b383425648e5abfc6dd5388e2c3165aab1ce8f3306208d34b5c5ac4b6c1b791d7c4f73840174c8c8438575bf4ba67a95eb4516e45468443d403900b25fa1169501b5069bc25bfe1789a9ed9775f04f4a0aac7af90ce2b3520f8ac624d3b4c0da3057fed81caaa81be7a9f2f8c5ce9472b4e7126afb008bea841b7c704a2f4711ff39271bd7b437ce1c8985dbac40cfdb45f6ed3b3ab7001fdb16722b595aa3f946363118fab755400ce9281966909ccf94b7e613ca02347d7d2ae2185041d5aa7b45dbcf0e16c181d4011c30bdeb2e090506911c3d5d8633e227e6623ab0c29d108063dea43db0376783bd8eb06381b9fc5c56afc9d5c654664bffb22b804b58ceec7efe654d15e503eb52c0b0055b57334bf31d24663c4340b3acf160a10eebb180468a06e3b542cdc8d2423c1286a837e7e9de91a6bbea6b6b9a474a002a2f418a798b243797d0527c1d82755cc0ca5e89f5d500c89d4971f3d5e074f05291d01e0ee1b7dc12a486fdae37cd3a72f73e78fd57d3563cd0398572edbcec67d96c78f875641b649692437fe4f785521f70ce09700b11f73cf34c2b46183bfaf6a60d37b56acd0a2a3680c3cefc571f72de135428ac61517317b500430954cb859d6c3d74354df943e18696a68bc4136695e2e2fc56d8c9cf861ef5cdd113e4fa74cc9e56a6db070fab145fb4e8072abe09eb537a41fe34ea42892f0f5239565fd53f98869d7dcc4a64740bc4e5dd855c8cfba6c70c6d4ae0f0622427b91a208466e3e425613949ca2113f6f49e4d061e4d88e839a5a7e6b0ee77fb8f2c0360549261658e18ced86ee4f67203c4aa8ec88299c3b19b0e68999727e74b820071f348412c72c0b790006c43207f369d858147ac6b9c439dc738c9500566d0078facb00f03b8a0a8c20c3401ef3ee61729ee79a1d0ecd346ab5dd1a138d21691083253a634bb942b73514afe43c466dc78d1737aca9b8bc047c1d5524db0611d053899d77587d0dba51e093ce7d1f7d3b8e729aaf59178ed79ade701f1972ec4af6556cf549ef7c288849b3d52d3e7aa4eb41ca8722ec1358220ebd274622d8b71ab444311bfd0d73ea680ce9f744eab22a6aac46dc64b7c6da8560a469e94359c8af7e7dba5dbb4e32d53c3f49b155d1fa529fad91ae5d4deed5edaed90f2f55161e73f46d1bf60b918cfbd78fdee75deee401931d03c5bcc1355fd05e8f52e9fc6b338014c592293ff672deb8fa453aebfe910153c78b2e715715bff424a3bba09506aee775e86c3432768b1788cc8fdb842bf0cd82a89aec1fe3050da836c866f49ce975b5293355568fde0f4a12a5fb688e552b0f92697420d477a03878e3fb6c963602b123187245d7151d6f8084493b9bb28dc22e29b1de31bf1e6f9f43930bab5908cfa4a864e2d8647bb36e63b455deb78a71c864be8b9967af22a2547782c216b9de1388d9bcd5e46b08d0cfca441d6f83023765c201b8604d90e1c07db9aac9ce939a15fca9470a83871636c74cb65175f9adbc741c8d62574f38e9c584bccc0c26d11b8b8b3133f07ca441fb4894b4ef061912e7c19530e5ca773173dfbb50c96a901b5bf63a007ed4ffaf0b2db60b44b630235030ef3332387170e7b3ab90641f4acd6243e66c85bcd1ef3436d7d678f5b508b19d63dc31d19b7c904c6959a78a9aabee40892a4239f14fd8d5a0d06f10a0498a9bf1a30932792fc28aa4c7c3dd11bce51119a30554eab855d134363a98c72b046a73e7ee642416276331eac68b5cd554fd5b8f040ab54064f498743f532dd2be927a2e88b32e3be387cc1c8935f275b48ab0941a821fd221ed1dfa98afa6495240039557e3e85f1fb0823c14cd377a82354ca499d4e964a278ce271265477e7324d8c0a990f1cdc7fa3365df340d66d359ff48e661d246166aaa7e25f3bb516056fe383528a4da5dc0f4b5b306d035ee1ec978689315b102b4c38140a6e9106335b7c7043f7881e4da42b598506e39a32a42496663cbd34d6ac96a00e734e600a8ee878f26fd8fec5481b9b833524aeff91864ab32479ebe933b2fa1b4610d6c7e8588c2667b8d6c692539b44641687adad9321a3b59bed7b538b3a5d97ec56af7856ca94c531e40caf020d67772a49b4014520eaefa34f7479386a673fb1f91023c8e2edcf9c5bdfbd974bf6b501c0609046081410e004897bf485351bc1c1f6b57a08deb20dd1079e7d2a77afe3858ce5fb31c35545c01bcd32371c66079dc65b675ce31e406ffdb606b649176dab5b7f9a83a99346d9d7d38eb23d9b19e3118cd857060903a5cbfd8493834be34619bdefa41795a2735c3c149ddecedb984ab7f6ed53677729ffba1b9bbb24e67c95fb5efcca39fc2e51d09c5a508fb4939e4da2cfdf0dbb1fa461a0369cd873988e21956b9cfba7fcfd79d721699a4c14b5e2a4e59a9575f8faed2cde5a5daacefb3292edf186ce90fc9335398748d8fa7b3d81634c9d2b30077ecebffe0a92b4198f5f54ef77bc708263c0677201e9fb874ac8ea869f498c64f090d74132f0300e22a386d4b3dc6ec7122dbfe560c7e8f6fb94b78adfdb9b8a977dd3fdc3145e025004eadccff1d69bfdee055fcab500c0514f9a5de27bda70905fe083838580d0bbefdad799c321f62feb6c52c48529669c57f87e93c44d38bd559f8c60179de11586e216f4ab1e73328e8e7a2bbeda5c9032d264ecea98188489327ec56d8dcc691eaa1849acd86d73c943a4f0ef3e68c1bb12770c1a8c9630f515aa8a867b6404756fab6f0ecae38e2bb19605ff457672c475554e3a794f36eeb28c6f593bb13cbff8389332518a1f60867fa034cec79737ffcdafc6866d23c62317e89ef1840735ae4fd7593ea1b5f7db01a7bcef9284d090dee143fe25ad2622647122a3dfcdfbb8576c8fb61c7ab79d2013259d26bc4c93460d7503bdf22cef03912b964d7e6c495a4a57d2a2a5b3d08f000f0cfdede0f702ccfd8247060dc2bf67a8410a7de182daef179b61d79fedb5e79729da3ef04fa333f82a0e19007fe9c52bae9634db1c41fbc8e96b8777115328e452cb96f0aac51dc955091cb68b04a13ae69949dec5233e1f58a13df254c629cc4bf18094d6425a8b36125d6edb50df65e8d2d268c6c81da39d4c0ae99e6ad94c2db21a04e23a19e83f27f8b0a9ce8127e58de7211378d7efc7df6e5a1171e35860839578b73553fd85202ac96309885b7dfd54976088837855d0e34055d2581971a607c2360c7b0f34dcc2a512e18e2af863b2aaf92e4fc835c974627561ca8afff494ab290e56ab9e48e7d62606230d230b180338597f1c10f832c54b4505916eeae002d5abc51a366b3a7d349e76b6be3a7d2d9a854ffcb21682448d7672c2164524b651a76054aa20885ccb79c33f094babc4a6ea8ee73d35d8518de212373949a4ff80b6ad2a6fe8f79ff353a893bde39df0910b5d4fc866b75a8f1d3d67695c84936f657451278013b35da36bae134f0b88abd100d90b436dbb9bec9948ebacb3090b7d64fbb364c1e0b72bdce960d7b980c0f03d8b768adc7572","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
