<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae4591293fffa44ef692038e896069ccdbf727d446cd4301a01b57a591112b703a3805ef29cbdd59e79248b7d4f764e2ed1fdca3c11cb8b3db953d9f768e92141f9e9b6e2b8c5e0830fbd2a3f2f5c4a43a96b0742200c64b78138390cc6d84eb49b2224d906b7c93c489d4784a25fbe418deb69a5f2ca4003cfb17fbb48f23e08f4ff6b91624e39ebed4a713c3462168604761d6473b1fc5ceb86d11dd05a421a99033780f4cc0143e773187ce7501674ab78397b17f5b21428b257365853c55b8fbdad85c528905db67a1583738c10896d2ba18c7d513c646122cfc7cd87641cd227e85ee64e8ee8f9567047b1d417f2ac62ad3a763342c3029f57d267694457f478174e9aa9c2b55390d03b9d5215792ba0e4e2c527dfde2bcef04d95840c8a0bd50b5b6f422c9c09e47cbee4e51bd1ebed6f6ff571e49f78ea71c7d293351038f5a70a2e573d5a6ae746fe79b990a2dba142f95bfce8db5c2b3eed8c33baab79fe62afe617d5c0e3cad37c93c3ca3aaa9086c41a7decb599c66d958306900caedc22cc9a2ffd545fdf36a5b13e6443b8f31c8bde1320f5b4c352ff87bac52e52d9229957fb712e4f965cb87957e6caec0f51bb83948c75cf79570d151292d03c390de2cd148708f00644140a4d5cb610732fd35ae897e3a7bfbc701d15606e833f352f9c538a50311e14fc1553597a9e45b58b8d6688bd3485e09cb0c1b93f43562a63098107659c094388a4a752148cdd34c799195adbf86a4f7dbac5f83f5b140e548e90b078579f747829e48e0c4f8c5ece7216404ea53f97e3441525c282c05fdd387f6c94494b1c5a99861bd7e9cf37b9241cc2e1f67708ac3e8ac7f6afb8f154d66ac4c5a4474c23a50f3ef9d393ef9525b606d3480a6ebb2d4ff69f37522a29e513155b134dd5fbc597f4c0d341544122ae4f328bec3e9af21ff63327f1d4b8dc2d9663e736b14a00a06ab81549ff1913e4646b17d151c12bd891eaa5e72f22f0eebffb32798636748453958137eb880e6b75bced7107e8a9dfcaa6a046202e16402af4345e540277877b2bde95413b543b9502ad2655b4da31025ed9d5fe77c7d95afc6ed337e1fc5fc1a31215ac534e351ddba66e8be59e826888af6ee6f3e9a17a30c1d458efde7abf3d4a6ff0cb9133095ac91141ea06c9cb1242dc8c3a4c08d0f62f76c77f37e5d1822c6d6148e4a66e95996ddef9905d7c1f41d6e0b34e49ea2bab10d1e9e6fc8dc5ee363b3eda58f12e6c973f07644712b718f49c63efdfc5f4e1cd8aef2c0f5ae00260fd12cd076af5a3f988be88a587a1458da0851b3339e250d36f2088af624f60ec11aad5bf166980b36c49d7d1a73c98cbf3cea30d9eb9343b69593a369294fe11e83537b236269c154f044c43737a5a682429cd8444f2552eb5d4594b841c024b42e65595837207d173d0006c5d2d28edcfc8abe1a76384b9dda27587412fa30a2ccf1590f234e98ee4d57886dd4976b32e4e3bfe8d4e488965a394e0f8073bd439a9937a6636373a40695b3957805244bae35316ea45cb2e01343b0f9fdf7f45ae84e55ac37d3711b581099f18557c848a7b91bbcac89f3b3845f8279459167fb540922c7c44303e82129ee79d2d40ca72161213a285aff7a7fbee128f35686fe740fc5567cbc675fe85437ff1d08cf9d30c97b005ea6b34efafc28494d2ed2a6d15569b9b6bf45fdc8e5c2e9a0a1b7dff94214739f4e969fad98e9af3f2777ebea8f9f62072c69e1230af9c6ce1f9c5d204948323fc6e4aea2e5c180c4b4d09d05185d85363c3a8bbe00c788237895d5a41a33b353ccd392fe4fbd5edb616339449805fe62d3f8a895ba25122866f7d1b0177bf8dfb4e1a5e5559cf6b957b3e7a6190ac0e5f3ab351d21a14037952e7f2f1a57904cb3df32bd00f13c375893447e4f323bf2295595c4207141e0c16548db36903640df167a988351272c7353684e798b78dc9017efa3994417faa7bfec19079cb03050e22967a145be0ed985263561f4648537c03df66505bd276d9b6ab49a98da8ebc1d61006e1ae4c2201eb759302442899150f9053a98173dc29079832ffb3da0230c54f321fb9258218b9d882be1ebeebae45dd6d3c394c32b8f1e2c90d233ca18dc487fae99d0f1ce9016314e6b35283a1768c08b2da33a8d7d0971db36717493262d51101b7e6f77f419c47bef9ffbcbf0e6ee63de09b60540988e3f1e443dd0168cb62c0e321c90845a07c5e5fec1a251cca3202672f5261699e433e113f77167a887581277f7707433ca0364870f8e2ac268c258402d5506d0faccae8df5b5524b8caa3e94abf6e101c55fbe68fb7563131bf01e81867d036b085334c4684842a8b623bb80a087b7d0e942671eb44377ef75522bb13d7dd3d5c6125c4a10ef848cab2398cb8daaf737226ed54873c4902a7ef6f86c36d6a0a071b5330cc721a653f27bcfcff00da817359448b9ee072e7911eb9135d8a06cc00020538af0040d802ada318ecd04eab94a4fd64ec956ad7ec5beb93bbca5f52341b033149be0f4fd788a8e36e58fe7adfd2da1c23b745daf40befb3fb89ff3d4f05082f8140f05cd3d6704868a17f132ed2b96170d6a15b80a60e1df11c1702db9798c94aee2e1dda161c08b7f3be91a171e89b6bea145e7fcdcb88a6224f385c5b730ad1499edf2204992d32ff4eb5790246b30108e63acb3b1c57347ff62b7e1531f6fef0f98a3117e540f4ddf3b9aa17cf8e0396df4fc7a3c74bac11cb5d1531c80d5938bd2a35864420da265b604c0f677209e517393ebfe66afc3e1bfb0eea8d8fd9fbdd33b734c86f9d2c9812373414cc82806bf2dda617df5a9cc012ead354339a451ba1585eacf7d731214fd6045b26c50bfde66adfdec2368e70fb59bf950bbf86a269fb5fb57c7d7c5cd68d21ed345dc577b9dfcabc032682161c0d10647ce87b4284409c16e0d0de5e8a1a482c76f47c824b0a612dc330d0b0170a040b4cad6068be78888571fff2152c3b921949edc2b385846f08afde840cb87135d401b015e5d9a4dffdde70fa0e2f570678b19f5197070d64c93335f7a989828dd6a0fb746eed962e296d945018e6857d933f709cb8389335fb176f18f34a9508a1a7e9451fcabed206211d001242d37f550a901f3d9220777ad0fec61de4287f893627af985b79d88f4f3ad3b19bea8f659f75456ddff263d8aaf3a4b84d05378bbecba4a491243fbed5dc1c64b64f444bc169b447bf5d2b9782ad95ef62978ed26911847a176987edae2053893b1efe78d6b487ad8b0759f95cc3a7cbf1d1381c8a63067174a6877a3a8d73df2731bb19c9aaa41fbe88291ae6ff33c281ab1dda0f2e2ff70b62c519d36d91176991e39f6b57f509277d154fbd73f13ad4823453a649c8e9be92f8deda231fbe4e0117927ea3508103adf4a743356bad5d04a7f05c7644b3b9ac113689aa16b8bb8cd02df4dbf4b1c58c264b330f9940cb477e60285106bda26c6ab01d8912e25d15d869503ba13e30f317f6bc10aa18eeb696da385fd93b34df0dff5876fdf67c6a5208468111c2f92542120ac8767c983e32883133a03f4f30b604f56324cffb8aa5fe0ea4b4f0c04fa8b6f063d15edd51e8e3681c8071aabae76fe0496ee8bdd2d456eb1ea6cbf732f9e033d846f4a77486e1112026d533c9502f92399fdf40e308b95736a0340ede92154cef1b0d8d53c2b9eada24a78caa019967d13b1a465665c692cc37cf773a9ca985f1f81572a5bcef68ab37e2cc05b41fe7b37feb61af5be8b552036a886c86044d492f9284438a46a5e93f52f00c8c9f65bbf2594459cf4a7098187f80f1001c6f81b8443cd1df514aa37ff463292fc16d47390807108b17e2384be6afef1c5bc04655caed3f32cbe2aa90f3d6d19ca1a45a457f5c865d939d5ed6a28185c78524955f32546957021896952fd8967e9ed0d4430d9d48650bf03cc9b1ed3cac5488b920225e2000ee23243c4de1db2fe631b46377bf916c36928e5963eb75602aacbe0753cd360f51b53a6405aaa56c2b5a61603fe99a1a4ae7444f79a9d8501687f2808976d6103c2a12588b9c596c8124239aac4ab69a0a8506bccc3ccfcc4c8abbb535d3ae59dd23ff7261d13a0bd42b2d98bb6c5016c47468d30fce23f38f9a7e1874f0708c26d88fbef25ddbacd84ba5fba08b70111e571eeeb07727280143be323a4fc4671219bbe0f89314cc38028e45961b7463c7784b2cb62d351914a8f8242aa820a205ab2f97ca90d07e77dc5ad91e177b72991ca70f0eeab3cce21b52cdd6a16e5c7cd748899c8d10c518938f50e344cc8e483538acf4cd54dd8b8faa8f8bae011fb605a0ae7728a57d47a28c9bc5796b391cffb3f285b2300fec2a21f8c0e9e8ae9aac9537288ea8d1bb179d16a93b477405da8cbd95eb9b06417ff3fff92c611908a603dc517116f34b70c5110bb3ba69fcf210c15dfe74fc4b58ab03a1c880e25c53d14fb5a73cc82b1691e24f6c56a9c7644e6a53b4ce3bb1ea208e5abe40490d14dab4b2627bd092445f2b22232dcec45919a594de09a9329b0dd0c6d3ec80459f916fc86ec054d163a505bf63b88104c0752ca83aad93b461593072379bf465f6d203356dad1827ea0b09cdb7d01516f383fedbfa171732b688d8e507f78444598826d05e8a6224b3cd9fea7efd58a86fd88e24bcb8d2db3381408c6fa8e8f92ba8d1a0f9d498a995552e9f189bd06362f4e462449316b6748e82ac02d912585649ab5114c676a53f2487ec66d1d54f18c68ccf69fdade4b8a0b5003a6a7dd2ea842b7f3f06b40a6daf01cacf219dae4df0e09b15f0918fc0cebe823a1100e90d76c99c379ae5dcce584d543c0dfbf829e19e7554ec34cf255238084ceb0b3fcb67b0c55d08f704c4c674695fa4cf265fef323fbda5cb15ed4b4d94eb409e2f63304f651401311e180678b18c013b4cd326b656da8328627bcaf029d4bc3a77d3d032f0c0d9cf4e8606a6b5e169cefce873a420f9f8a8085ac7967ac758a98bfa3e6ea68ac97d8d24affb8e2f63ee80a3b8a39e7f77f928d97d706d9321386280cb283abc682c78eb412fdccd6256d5e1924086f7c7608852ebe56bd8c4e543d19538f732b4160ccb7c0abfa3192e7e19a65bff8337d73c905d3cfaf919485e9c2e6c6a905415c4069c51c757b988a25440f8e437ea158c0a6a3c8dfeaa3ba50f3be57d9ea671ebded07f0cf026e647a7fef0fb174a09fa4b90c1f232a7f113084b7f86e1060689e5d0a4536bc239c3b8ae4ada13fe581821a682f63e05bffce8d7c94c53a56cefa02591c551ebe38aaf56c0150cd64a126bec367cbcc63cb4b86b0e41f13829fac14ba0d6a40bf2d88e5aa307bfdfc111ea465e267e2b5a9c611b1e5bc1117744b9acef1cef8b745ebbffd432c885d4a20ed3aad5813d1119d0a707dbc798df10fd276160efebb0f239ed61ee396db440897f472fbe19784615614618be5960fa187aaa94955d352b4db6f6e3cd99a5fb071b157340681d453d43f186f1c5c58d9061aa5aa12dc591be8959e861f323c980c418ec1da3663c9db0ee2371b5fe910b3d094c049e29ccbe8615ae3e941273c1651dc035e0c7472e129be90d49e33d14c6b54af6b4a45d26038914847eb547e73fb8d5ac127bc31dd2bd410370e8c09be2b430e51348a3e05012f79debeaf25a5b5f851aa5abe0c4203a5d8c3f6f5016448892f90ee2108640861896c2438de87506d5000fcc7ca2a38fdd46fd8271aef5fd0bc94b24e2eab01e7726e4585a904a270c574d04f9386d2c82a23f35f43bb2494bc2cffd5fee13ee8bb234cc210ff16e937fc4a51695b683b69e25e87f4b0b2c91091d7bc704de33b1cc7a83adb975068c82374f93acf80b03cd818208a1d12e93e95e167afa3daaf26fe44ace557457459d096192f81842030ab11db908c5f82643d886f28a87aa9f57b1b49947165021bbccc3e334189adc048a4f78cea90e9b311f2d5788017469aed0f19fd2cebf8a58144473eb911355528109ce5e041299b156c29476af051c445a560aac374c73e52ec8ed3fb7604c60b68d932821f10f2230112ff491b547b9d3a47bf2f4ca568bf747f5cd5c7fd52fab9798e27c590f1cd3699ac70b0f06ee674765af25390291fd3ae1210fc9dc9d20b4571abc08d54c3519267a4d2120e92375f6bfe9c36d5b5f4c8b7e7da9f3738b8565349e8238f49648c08b7d2052c2f548e0037222a725628ecb2413c8183612be8c2b02aa6070833c7d4d55071b4157d41c040b4e94cd73e8481ecc268da1b86d3b002339633a7dd339889d7bece40637d0f386b83ec33660257bff22a47b41a29f7e8ce7ef34c7973cf54c5aac1fbf14d83d101c59bd063aa4be61b7713ab5a679c505524aab8c8cd48eee06cd4a1358173e5ca812426232962c9d07d47abf00bae313ef755bab109cdd96a5fed0dc0453ea19665841089262be27cdb388b4c9f667dbb29c1ec36da2ec8738d11b0ea83ffd8c5923e7e20621d6c7bf02b4b17d7d0c50f73aaccae4662740dd44439b878764528fa787dabd15c8117cb290333ef73a52a3b48e5d415592c2e308d6f6dfd4fa7e6a101454688463dbeb000b0fcf336979077693105f069ce1ba0ec631c31cace3a652ac7128f8e1e6289baf5e7a5546537e6534dc29cee60f32ab9e6d5e8d4c4a9c5a231550fcefca28fa6a1454276af9ebbf3e204fab91ffcb3a4f275275450f1110c63cf507e695b6dc8f8200b98f18d956f9519861afbe0cb94591a790c5cf73d0d17e3ec945ca8d074245574f28d9a034bbef09410822947c1b624ea5812c1687273f966a08dba50b42e0bf52c541ad47c337675b235e44859fc9071eb019ed7a0958ec73d2f65e2e70c9753751f406108cba5cd62e6eb49a0aa836094cb945494efa23ae3c2a4d30a8bdf54bdbe40fed0ff26f4d6d2f7a4cbe0c3d389cbd8eea7cb9b31810a009c7abf86e9e8e1cffab6ccdc73ee81b7838dcb3d6f2cbde139ffb686b2fda3c3641f439004d6ac3f0805798e1bf07e8616aff97ab41b8e710f3e7bb6d591472f7cfe0ae13e46c7ded7cb04246d4c9ca57dd3a67343dd132994785f1426d921637461e7c3073360628f26a796be4e4d2d6fe811cb4d21af4dbf241ae5f8e61f14673f5bee8138ba8d9e1fefcca94468ac9ef1a3f08634e72a6efb4040d1a3a1ee4c9cef9466a7aa20dcc1c1d5480a65929469e3188a2d4e1e35c2eb4571d137956698fae43cace223d614f356fd1a4576cc6fcc693fcf30dd7b39125bdfc820d074f19ebb07a1497e4d78cac0edb9cd95df17304acc61dfead05f0908b042ab79be6822cca5e405ba5b4c07d92aa60fc8f5d2ecb60ee5d3e0222a2db8d8a325fa6c8e82a0afb8cc04282770b35597a1bb66bb3204d4360bff503274109632f0c9c1f0d1fa36ae493c1d93b772b42972b5f815796e5032f26eee57dfbd0ff7545b829b702ec62268218938ee6cde898981aa8fb85c07d0ceda95b981e3d40ea5ac7334299f8ea3db2be55b7e51e4401b8e39124bb1f88a1d31c1512df16eb3c2e6c192dd819ee31359ec3b77eea6838d66e87f18570ffd93c21f99eaecca92e098dce054f4393b837517b7e8e1a811f055a19881fe5f28701ffa50c2d0774d00c336c1b2166ee4d8131498e4c17dd125711ff57508d43d99a34e81c2d7ef8731a372ee73308536bd6afef9de8b95a90f8530f8e2f24c4f7e327e8b5bc14ec86a0a19bbc0467f7ba54cdbe05e4dddb1c3e18d59ba171108cd7243af9240d6f84333b1e6e4612df3c7c1361b912290baf5b3507b829ce41a8b1d1ab71009186a577f072bf99934ebf8fbcbbf52bf2b3b59ddebf83915157603635a28ef169f1d847793fd028980dc0029eeef94f1e32077b43c88b8bd4c9c5991c51ffae91dc34225d1e6018d7abc5950e809368ae7974dc0558cdf4569681963abe08c3ab3e7412d019c7bbad3dcdce699338ccb27973b446987925c69d399017fe763336876a6f8688d2b39f207d9d7ef52b64aff84588287982230cb259b5fcc8565a64bc1b4e5c9c4a2dbfcccac11620d6fae6fc9aa5b433cb869471b276ed8c9513aa88664a07a27cff24ef8244a8c54f8805c74e265c777b14abdaef3aa807d0d1ed04c5316b0fcc52eb1af907adeb13c8e559cb64a8ffc92f2397fed45fd7dfad072d048707e4cbfa0f6fc2787749c2e13da9ba843bdc84ac9d931e3bbc41183ac0ae19fce4b763754a9f0171fbe5a4e88eb1d13869a32fbe8eb1865dc5ee7aadba3fb9f366819a5e8ee1f3870eaecc10d151e129cc532eab6d723719add621d77a07e403ddc95248031e12c03b60b3e79a10676b15b26405dbea66e646a398807ac7ef5635338dcd7be19e815982ac104db567b2e9709e70eced80b98c8e9663b0c79646beb4db981d80a90f543ddeb653aac8d34cc5607a0e02fe22f125102a4ce9699a7888740bcf7ac42fb88701855b8f52981bfb306e62d128154817aef0ad28a8b0f09199d0cc8294446b5405ba3f2281aea3de92a4b633f915ce9a31723bf620d12091b05bb4e95733d8ecb6341ce35054d15a79e8e1f57fcacb073b8a595475860c88c705c167642b6e4c90b90f0206ce2f9941b76b7554b38f0d908e4dfc430bc3757e67959c6596b4d42b558b618ca276e1851254b04d16c61c1e0ac08977aa239f6ee7045a2931a5a6f810c47c70bd528cdef257655d1fe4d817815f3940f4bbdf821e30e6fe7be0f96f9e384edac62c882c4b4fb1a4fd0098f32edf97551a0dda63aa3fcaa4809ebf48e3e15e204503b0bfb8dbf215ee00c29c6e78f8a3311613532105a219247813b7fceedf6cd66b37717422f851099880e216ad5fe72cb16dc4fd104d99eccc00e4ff6705590c6c966446d268bfb426b3c7a229da8893422869c55bacfa422ed108d260951a1c0eeca5700fcfe51db746263d10fe8e1c5e7d507a15f9d51fcc872a4ca6e7bdc4b0f45a9d3d2531eeb4a7f97b94c1a887401667cf3022661b4e74ebb3ba384f57d01cdaa273cf938128628e5b8f19c536e1a7307e33afec3474d6bcc0c74b54195b519ad241c63112faac409dce53ce997be74b038cc0cdbca58cca0de0d42a8372571508c855e565fc064d2ba69c9b560db3560de23158289ee4ac30efa7dfcf0a9cb48a682251118207a99c7b4239bf58ff8dcc6d72e17d9508833656850ef49ee0bbda36b33d7f9aa04dc076d780f8688f5c0ae106f813b48c1907d77d28dd5ed737f1bf3b561ca1b82ade0dab67ef90b63a92d21025e294149fb2053ac1b28885d0375479f027181ead96b9494335431934d4a39d8fec824b2532a1625e60ce4e8d9867ff153550ea6fdd1d76647064fd095a3b6b653db9ae2e988142cf8d8cf54eb65af5f19da06d2be2360db18c4d80636ff3001179042f925c423a006cdebd772e49c982e19fc61fcd77a95254b65d6a9e287ffabd7f3d61b11250991196728e4c0c9c183d3dbb20a1f2f0263af826845a26f594d6f4ee3cdc15952404ff84ccf725ee8e625b9b3b66ea614fa658927e78b2d81aaab3091ca4ca535f414afe75d1da5a4218ea0289f2a1b1841de44be55aebf5eba694ffbe255ef74772429a122abcea95e998967851909d7bc0353c55ca764ed106dd08c53f04da9fe70123dd28ce6e4f909de04b5c6b32917a6f191bf8cfae7e5825bf4ef3563de58b51c403921c0465a5c4e75287a720851f3ad307ff19901493c9d5b3ba6136c7cbb27e29ae235b65db6b3b207d96261b06123dc40c65ddccd3fa1a08b37b76463d38e2d4ccf87cef15dc52f1c8feccb5e7d789fcad1f1677672efd1f47e6162b57823a1f7f2e4a7670d472ed49a444fd8b667f996c46fbcfdeded5796385eca8a3419c44b8eb3df3525d6fda2a69e1813385b456ad8f94233bf12f91218219d10f732f5bcae0df01f672b41a57fa66b03958ef869cb1176b0d21bfae43c4c759d47bbddf7d6fb6c4480d1040afa7f225370f11e1f58d395d6c2785e7f30edd5fc619c358a2fdc3c0db236093244c0aa72c5d469283c04fd12e906b9b6f3a75f7298485a36d1a0d4657344963c4d9118c5a4944cec8f5830d78f9bfa53a753e09d20339989a846d850cc3af54691565922b6043ab47513758ce5cbd65f340df193a78763c0c8d733ee49388a3ba80900f0f3ad3bc50d6665a3b0ddd0a95bff319e1523aa70f49f358f5b6ee19fb376b05f1618ffbd2fff0fc78f1697aa12a6ce904ac1c90789cad294774e1ce5560db1f4b1dada9cec915ac3cdc75cfcc7d191a35b780504cb123a7ebb3f2ed5177ec1c3a3879c5025a939e53f2e3a92523d18afe7f2c385d31b71d6c6ea20122db7968e55b8b445b418b589c9c8f82fff775037cd7697522997b5e8102ff9c9eb7836499b1c9b4250cd180e64cff4015ee4653bd71575393efa730b1e6ff52490f8e2351ce3414a611e16fd994b5d077186c272f62cfe1061ec3c7f4db33601196085f8e4a6a1a8ca6e172a80391888f451b3827112ee2884a499be946a0322d2d60b46909608668e2c67dc1058387d6ef6794011b4bb50eef7487558d0d29bb4e8ca1d469fe264b32dbee6448c230184b44436f7133daae9157d0745bd14bc587afcf4534438164f1500bdcc99113ed85a8a503e62c3cf70a22fd8dba86cd7b567e02c1c2ffb791a636b8500a57612df183b2971b8878172ac5b406577f7ff2e9c2409503719bfa4ef155b56caa20f14d30cf0f1e7e44d75645e9de62603ec795cb824a13941b36f8b4bc1a4df6a47e38c8db838c795a3da4829e90ff4d6eee4f08bf4af80cd5282e16166e219d1191622d089380349bd233284cddcbf81e993aeb50d18da82bed8c0c794d0f125d6033c5fd5989cb78e6d985b224cdef002dd45c786d87a2524bb15f23e7e267783b55ce1176e631cd5677c2c20e8cbf55d3fa0f5b7c7cd31cd11aef5ad3ea020f270e50db0b50ef5e3560ae0bae280531120694ad20bf80703b7959526c7ed08b4a205de9d1f647ac1e85a26d67f2cbbbc754e94b10517588c2b2f88fa7910e288e2878500247b7144667742669e080c6370501abbf971490ae7ba66f9ae931f48767124191f1ef1d670cfcaeef2482b8b498a5475f6b9375bfef1c1f4fee966c5532b9d7c473a1ee5c964f154059009d2b937621d456d0d902bce7e322b7a7203354b0e25a89df051f909a9837a018018fb2650258b7799e870f4d1b80fa22681bd00b6cbb3ae2214bf5e05e2b5f4417732499f73853daa70a78a6a90464ddb4fd7f7d28c3602f36b3d1d38682f9d3c9ed371b67c96a27853ab8995daa819111eb02d2d30062beac1650bff3cdec991c0361ed91c23ca5840905a1e974c12a7650ba95d65f108a2c8085938335b5bda3bf04ac5085fc9d28cc1a193428c6b1015bdea3deb3c6a7595600c7249ac1d88c253bcd4eccadedd9633d502daa18180eebb5f8664923169b48e0f2ee67f0d96142459f976b5b27089a1f69c1c25237c7340628203da64e85cc91b586c78a8d368b57b11fcb4101e105f3e3999298dd2b099ec09186cb95b715739d77ce9ac9dc55b7e380615dff328259e774bd7d2c72d5b2a337fe0e4c0da4ee9afa2474f3f8aad81e807130d21d509285c0159b01a097ffa101ec80218e98cf1a9f8596c4dc0e2ad406f59a8d1fa1ff001ff4fbd6c33a8dbf69530255ac575d9f97d541ee9c5ce4d0a7f890a411b1a628c0ae2bc0e7296b094df54787ea60114410208bff34167d208f7da106de296c41e3e8e3f85967b0841ba8c68f945f412a6d6122791f75f206cb77fde19dc9ea6fd8a7d049a6bea82c323bc64a1e4bfce035d289c7065a1b5d1c1fe41a0fa07138a4270f18a6d7bfb769f1b0f203f408e6bc530b61ecdd42ceb7f1cfe44dfca16af10f9e439e317b42f265b16eb3282f2091f2f4d396f40ed1d6dbe6ca38eb884b5d148146575abfa7ad8e5de55ce841fa77fe6726cbfab57d23163603758d96ce4365294c9e4b2a83e1e46c8b7ef7fb49eb8b7fffc50d0b793f4d1ec8176958afb5cf552b2f2b0671d71b70cd27342b46733b903b2899210d371a427015d1b782c55f031bc1acd0204248064dfa751a30c78f459e0178e9345c299680c9dbd513ff5883ad28831c7e1a5d647bbfec9ed253f6187a30b7e297bb572b1c6b27210918ff59ea5f7184f23cab8e6cda59afb4764df7625b05525ddf6c22ca521e459e79b4befe2b8a9215b3e789a9b2f10ad9fc7a25c49ba30743a50d597e3b9be8942ca4eb2e47d80dea78eff068ed25869566465d5aba9f9d16c0ed62d184c9467952bff90feb37599ab80d1698e1f1302605febe150d54a6f7e22722fbe5575fa98ac532e00721488cd2a90cd64911a5cb17374840518a42fcec590c30af5ac10de6feec4d22875eade841a7df12b9e479c65db6f749989823964cdd0b273eaac6c2369ffa652a913e79e8bafe7747887f78dc0f1ff285b3203f24370e90c5b5f3fd56a894869c6e77c23b50dc87995c5ca16e2974daf68d0100c7d9dd2caca5fd3639df9fba63bd6adfc25409f0d1b10ce8a37a323712be1287e43181dbeb782bf9137e5b2eff847ed1d0b53d6dcae085c82136fb3874935f54910d7262eef478084ab7de077a104f5b8477c7724baa55a86d319274a63fb80cb2a7b39f1cc189bbf4b2b0a1706421c0c18fe12ab860236a1aa6d2252a7ab86ce67525458332774a7c237b021717c8c5aec637fddb32fc33af4660b1c9d79ab9f3c452693a239bd34786142432320c943b2732b822ec6cd9d31c8709f4dbd821d3ee04c2540037a715c0537ba7c27a44a664c7721b40b563c82bd11bd8ce667319a86b4f5c917017bd4c5a5bbaebed2624de50a8eb8eb35a17db8b2d92dff2ed99c61230e91c2df48db114dbe4de1e0028b531ef233e7fd5aaeeab9fe08b02e1e818d2700530b72c788319b77011e5060d0eea134c737c630b87670ca97811dbab6554a35cada9fb094e11e9c3511c795fa1d102c46fe1250efb06ec0266a740a76fdbc5e2fba5cd7ee2910f7c8e5867b1db6c8f0a8e9fddf399fc81575cd6106722f277eb69ac9a0c30cbdb3360e7b0c9998bc488f0796dc1abae2240b225f73e2404c3a618f1f208e77fe00e3b07b765808ffaa518771221f926590c7ce012eef0ba58ce1e499582ac2e15c298292eacb051147535e7e51f09b000d909a295d97579a07c62cbda5c180adfdde239ed250c1fa9328ce82be9a890d2b5c6389ed926869b2032c8c155b5c61c76f47eff627de599adf52abdb402c8dac79f45f011f7d68bdc1ee6e097c24a2b0210ffecf55fda62e473495364217ca556bcbad78e1ac9bb9ebb9720655c8f693a370bfedaba7422e496626447116f0d7cf1c9e5f0b90eb8adc1ff0269011d4924613906cf4da61542386249c1264585f0b30946f289ca3bf1386bd2df86295b2cf582e90861d74f71974cb6414f381d45458d879a059b701098b661f53a084a35a0db1b8a00a0af149dda6d467c92423cfaeb063ab0bde303adae637843439fa8ee2231414ca6cf995c9e491d4104ab4d4e311297b124c906da39d00413fed82511c3243aaceb18b9f13cc72c46c83af0545e66c7e064d59994c1341e3d62ff9ce847cdca6c936a98f507257a9cea4c08d24ed9364176f38f8d53e0d05a7fce85e0d0691bb6a9bd0779a23adeb6a1eb6f4a72752cca538b70fb477950d653f3c706f8e9a339399b0d21962017842e1f6e98ac84b41f1e647f5f7dd2d4ced0bdbc1c44dc71163ca901e0e326f646c13d56cce1e3c66f9574b2a1159cd75f18b74e083fe3f2a83431a66eacdf2cc69243b15695eada3d22522cf853ff216e194e453637ddd6ef8307ad7563dd55b21d8fb5b888a22e4e78182371fb18037579e2edd1b405c315aeac98e692f7dda68e1136d82c17b70ac0067f41474926d9527a94d111f4a48896e725103db3415dcc734d3f1fde82749c8f41fe230c7a9f7f148619aa3a35c97b9f93c9aa2e80c2b12eb4aaa3b614c42b13c07e32e2a65c42206e7f626da631923c3f207d512a3d4b557fce805567f52d48a62f699f5e05ef789c9845f55c9e971a57bc07f59b6f98b34606186533ac330ce9f2ac915eb161e01819548a000db99500e4ef5465da6264fb3af3311b7d3e781c2262d46de53e3ce78e7a3119d0c9b870f36e272a6ba97e3f7ce258a0745aa9a2d648f019ecb9f79be1e9763449bf12f8ca23a4380ccbabb66419ff71d6c9ef82d906a92a4b5401f1709e8750bfccb369c62c71941819e2b531af2959ab209614def7419b50e6c8537c3b7e91eb5ef48d1bb4a3413259aee31eaa14d50dadea12e9f36c122c9027fdf76c19f5628d9b796e518ef1ec5154ed989f756cb69277de4af487bd010a842fbcb9d62d6d9f63907a15bac680d6ac0dec622cb382800b85c328915f8878c8874d5878b499a7b9e32bee121726c73c9410e3ef4d6ce42c53075e1467dd56b7134aa5cf953e09bd24e4de63d27839613a064b0a2a6062fdb929bfef73244f5b374dde698505becb1a574870a42a28b0718fd0668ec76b7213d3294520ef7742d442eef887ac48abb97521daf6f7716ba064dfce9516119fb917333fd45da1e0dca62ab383ae32bd6b6d7ba1b501c04ce32cf3c51178beba4844332d62c7f41cebf1991e7baf49e578b40c72e3d002a8c888c9f4f5931ce624871bfd3529c745316e405d392591cc831f5b8645d584ef359fd8d355f7a4e722cbf712f28734dc6f2b56cf98edb2386bf64aab2709795424bca1850383c48f09a86b391c78045fa058a6d847b57fd6dc7a6c1f1e2b3e7b9074e6f72983e79c51dc603b133b3148724bb1c27f196aef7699dd5e398d0d8545ffb76502816101b07ebeea150e0a48b2aeed71a09feedb9e98fc025633826c32325874b1e6febb5b49ca7c597f011b4601949c48d49891061fdfd110c6bfbda75dfd3959b83783d347e95cf9efd6a59602281fdb7b59d7ee68bb5076256be0228aa18ca54e4369e5df9d46d0de3bff4e008034d47c51af24251a5adc947929c8a4853580f6386cc55a3cd5e5b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
