<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6949ab6f4686f121c1cd5ec6e557616a71b11583a92ca0dc0c6359828ba3712d34b41745d1851ef1af53ab08eb5470d6f623e96bc1f553b60fdfcb82558e8cb7c6ace194135d0121c57916fedf1df3efad57a1b96152d32f575be3ef42006d4eb76d469089edb33f183f7c1139cfeeb560b844979bb81bf609cbe5ada23ce59d041d0abe72ba6dae975cf3fae0e09273ac42fd6972e7bcc669330a9f64826805121ecb792f6104670c687a15d2c36d177f08edd5200f921df02a2c3aa6b7beb5dfe0e24d4132df84bab57698c205e57104131cbfe708fc9391067cc665c3f1496c0078ce66ad0488f71f1bc3cdf46f0c1e4738dd9d78ba12e66bf67870183b349a9dcda5c49156873d50910a88c61ace2bdfd61a84b6acaf07ef25440a2b8cbb4b444c793102fff19a19ddc817522a6e70b70d3da968d83055b772425b2cdaa818cc49b065eb8ae03068a8881b69520618e9f26bdaa17101afb5c81593165fbc862ee9011fa6108fe1c6106154ff4248d6fef817a783e9f761fe7217f1effcc6b9672287367c73851007fdbd5071bd507c3ad1b66348d958cf33467d81390bd8efbe2025f1b0aaa7f8cc963d0618c9992cd960f6fffe54d01f67c9888c60b5c1cc27cd0f746a79d63f24f2d896c475dc8f85c4235e235cd3ebf0f68115983a1e9271884dbefc12de58517f8e76c36200ff8459d958f3642e4535cee58968de50f1e02347e425078c213d59400b8742a5e1f3532e5b81b681c33e3a6e21d913a86ad9bae4e3682064ecc0913e8527458e553523c73f1670e362df692645d06bcf6234b5da141ae91603f2f126ae7fef01ed86150b83b5b9e7465e2d3220f354ffc7012f022882e29d238d6aba3edf7d08b505e8b787cc052948011c303ddc18be866afdc1f43815e260f25cce0aa0cb9b34cf4218b09fc11acf72e5592b9fbf2f29ddb477bfa59163de1b825e11f66e5b398fab48f6eb5f3febb1c9a11c42dba50b0e438c9151cbbcc47faddadfd9793853273b513fa8c8517b93a04ce5b3b6c2df22027d2f048026f616d8d45c444dd18cb28a95c1996cbf6463765989173d43674309c5d4cdd465b07453e49137dc3c0e53d15ccd5bcc5ef7c6e8f0eb512c5314ac3bfc16d1ee02d95799588d2fec00d2b32f3b1e4787fc9d16e0f61932e75062c08b59987460c82c9b2e5fb21294ab3296606cf36c31135f02c28023742cd355d86abb2e353c48331578cb65acada98b3f666f1a1c6c0e081d9f04521794d32e92f263a2f97fce58340f03f3412920bd99b78ceb90da5dda7724341ffc2815aa0be6bbbba190262efe49839c564640f751e4f87ffcbc07ef2b4be0d325e33c6a1308a170514d5bee540171aedf088f6e674a5b7368c0a2ce0321e1d7537e351ee713c1ac2a1faa53f78bfaf05d2dd5432437965ae94587f42b4b8cd465a02e685447c8a3460c3e27589a83eadc9ad2b7038315cca214e290bb3de62c00a47bff1eb12d05eff8cb034e554c1fed300edf802b1a870c760cdd12a4ae7fcc8b71bcffa70f37b05c0b4864cd57f8834ad1c1dfa7167edb4030f3f88fcdb6059220291ee1b4b4d61b7b1c94d7137e38fe1c1be19b9e829f6e7ee7730d62eb65fe31a4c5fbf7c0b324e96f78a03f74c8bcd9743eab43596d65e1f812900533743ddfc617b6e3dd46e34c37d65946976b61d002ccc79413e7fa350253c66828c3a6fdde65dc37b6de3951a6ae5c80c4ac98a94f8dbcca5a223b070253f02a02f9603964e379104f23e04d679a62190840f30bae7692fb376d8804bf68a446baca6c46cc11d09ba5b153b94cd5b96596f0fb9c6d4910564abb5709ba9af93e1dc3b6bf972959e4835886fcc72430f38c9bdf4bffab7246cc7a4d4992507f3613c547877d0d73aaa341103a972da94c19ba016dad279d2ea619c2ab1a9e1acd0d6841f66ee5f799e65cbc834a4a9ed713040ba2402470a421a25476da7ca950fc7f008626c8fea86ba4fa9031ec5ae839fb9002437d966794428d27ee9fb31b245691abd22570aba1e9d2d1110403fb3d660fd2546b13d0825679fe6625cd676f769ca2ac98c4a2b12be8a4c9cb0939439c48719b09a791fc6ef41eb9e27dc4b001a8217c47f0b16b6c3bd78f7afe9ed8d848d19f6e7da3642c10fce29a10922426812532ff3c751c6a80bee81ca651094b78f8500764ef0d689c383f0cb540d9d2d58e7fae8baa62552fe882e1de0a09b4c86751cdaf390f0d491e2ef10a9a4e7d5d8d1edf147efa596b70bc8f54065a646394c5babb3eeff7942753931320110dc53de47fda4463e9502ccf99cd6d7f0fa50e29f2b72131f147b3f02f51a24e2c4e8cea94d4c4408839ec01401a5c732160b5c2f32850d0723d6c07a1cb36f0ddc25d34e1f56bd825b9a0edd55d1439def1144d91f40504187afce15889ab81030cd00aa5e8147cb2b745d5ebea387a74c38c92822192c2a45f1b62fb1399cdb7f238c5b589e3973843a2bde9799144b78dbc463b8d795b9f729235bae4a947c1eca34c11d0d8e111f7587b712da89567898b7a08c68ddde8c1c3c984874385b14b2482bad591acc6a4a94fc1bc34b0d7f56bf823b46a19ec6f1e13a4d6667be04340a6fbd05599ce71319f0b05f949cb425a0de9122d694f6ad97cb093c1aef1181f1aceba69676b5fe3b6a67e7a02631978459d9695919cf41a72e260328d572cbbf293279df9bfd7022a3fbd13fc0b5b6b1a33845c27d99dd40b98aa51681f4eca695ade489c3850dd69bc4e597fa60bdfc778386e1632f2c1a09cb28c1acb0d477b09f96f60752d049c42af1abae4121779ff8a5d9b059958d46ebde2d3a034c81a52d81e63057e792673425a16ea49db9b4e25133424d0d0d80beac37c37a69a717fe2f98255ac94d97902e36eaefc05dbbea1c48007abb342e01f50233d9ea51169b1e8b71de298196bf12169d385d3011c03b31829ee18e9a3171a69e46cdd6ca38b8bd2c99f18a5fcb0c3641253f47d1783f2becb828ce29052eae136f309dd2eb678f2bb1df88546e845c63b46b60ae094f3fdf3b464a3dea29668c0ed26264fb7e4e097124b07481b036c25a5f9c4ef9753cc7fd9e3030f1aec27c5d46933031176d8a51bbacc6a5a6129a7f1d0c577feab57e3245f2ca9443572e6cdc0878e8dd45c98c23091628b0b7e26101b165f7d5310e987eb14cc36b18273e8a377c6c6c9d139c91a5f5d0461968d9e36e231658878ec370661f8ea5472873c3fe70a69d578e84e11398caabec944e972a485926454277995f8197137ccc9d3219fe6f7c5b1c3005bbe0485f0c215ee2c1e7f7d7b081e45c3d1c8b523ec07762bb9718b41d7bf399706dc98682810908055f95263379f12607ff278bc62bf71ba5edd52e2f20f37ed63cb2d584832e33f4f52b15388f6b64ba3ab45cce27de3f43d5e473a9684a74a07f79d3b03c2a119bd80ae7f10803adaae0057669da1c259cfef95c9cf351429fbcb8e9a359c098e0f14152ce26e67abc20cc0025a187f524d1c6d3ce44c706cc0b7ad73bcb9c00cab35cfaad15b11e3f90bb319c989d22cdf53c26949f3d4d921d12f593a1981f2a25211fd9dd64d682fef0e61f2ae6561fc649061450734d57915c7c837970a72ea0fb79eb866d4a1983b8b43f59f818f89d5a126371aa35c570cb6a0dcc8bab97235e6f9f74e43c22ee71c363d3cd4ea2f811811b3d0b6fa06e71701efaea47e2bf68f975b788556e656540b55bc45dfd278710f3fa674bb91887ad4a5f8a153626e4df7466c725ed230739ad4fa66152ae0a0591e416824c973b962f2889a27b44c8e96940a4ae72bf1fd4617a2bbdac6dd12f52891063bea18f2b480e706862c509587d0e75194db7eb8e2155bb75f88eecb2f924b140d58aa56948ff045fc01a4d586889783f1eefc12fe83fb1a57ba113d4526cfb6a6d0504ceb301240ab1380b713bd3446240111cc2d794cd96764e7fd06a4d9d1113949e739421c831a355f80fd2a6465c5fc493be8bf15e0eada951e4c2ddc3f4846dc5c601d8f0fc947802e01084dc4a8faf71e6c3b7e2d508ad18838890738380323540ac5bf4dbc3c2d85577bbaefb374150af47ec4b144a1d2ae12d6042b6509527e6b2c622960132eef6ae892e1a43062712a95bdb34e8e880cef1d5a0729d43fdd2f1b0b39b2224fc6781c5f73d500e5681582e27f915d1a726a31a41849e30a8622ba5463913d0f14f033207b3050061b5bbf20f3dc32106acd8784bd46578996faecb5cdad271724a7268d387a5846039469935472cf75cda29d947d5d87bed24216e4c5a0db153b8cc3780a86c8ba83c5e17c334e6a9eed7e761c09b9a25dff9c71daf1f1e247a25a007fd987bd6557c9303f3e772660ac0051970783675b1033489f3e0984162ec1a601d676f3f8044915ea386958305f1f9f06c730e6e0b59ce9462ec793d4db965c43b07a9e36be0172b73dcdd49c9afc4222857b9bc5fda545c104c6be749beec3e7c341e6c918e8926b331a88b6bffbb200b4f81eab9c2889844d4e1431ded4fb179d689ef3080b04a18870b180c914db2c13aa85e86a6b74fd8e3f4dce1d482218861e3a2765f7c4e9f6013f93fdaa8175e4f42f199609fb9cf44899187628b86e0009cdc68105fab07ae2e0de832df98628e414c50b48a99858209a7e2f3040eac5c7e48afd166f0dfceaaf4cf2090170f9ec30458f529802263b0d6d462a7ebf0ccbd5e45ed9a46ef70129cb61ff92cfe48caa2f06dced60327e5227e2f774791d54ecd4dab85c67db190fd711dfa12c1fdf0953e096bfc354c2a6dca9c2b5ef140b774a89f461cbf6930b39982a736ba34f41d3be6d4a0c343977d4409f4587cf386ed7ca64ee6ad1fb716327596f685a5c979e78c46799fdee5db451b21559a3bfee44d37b88944536d7e5292c7d68d492366741a55abb09d62608922c45aef8a8db699c8c074d7b06b37dc31bd1bb98d6a5d1129820dcb5df7fdadbf46e0cf95f2b0081f056e56c49e94dfb8164de530f1318a824aaf1d237f4ff37d8e3ac0a90199e369c995a8270b662508f1c73294cb3460efac208e08e804dd9c8552fdabf2bea9dbb20cc27be2690af3df9af0b794a24351bb3f08de0010fa20579e623a0b1de9e24d363f919399f20a83ba8e929b4d5158f8f62e53990d40568f459470787f94c12c580a7d993802afef1a2f63e0d840be409c44ff29a30af13e62571639052b0c759a8a973904193dc4617e7bd13e7b084c12396526157f9392d22860e619eca6c9d98bf1bdf84622ba4fcb39e274237d2e657f9ed2cbeae5c929eaa6578b56e8199df91db488e779dbe71a8075dad5e59c2bdf324caa432e8015f2021a09c0d61be2363a129b8135e5d0aae809bfc71238ba6d1bf8f2f5b1b9fdb31346ae978b4f5699c66dcc6b0228c5b54e07411da0429d7a0df04f4a14f2bbf88e6b5016170160dbabb56736b86554f1197c435a30124c6ecad551ca319f88da5f8fc0e9610f5cbadaf566d2eb28a34e1662cded4997c4f5ef5d66e22813700f2968c27711e6f4664bb30eca43f4ff4a82fcbb50a00b583f3eb259a9b83000de3f25012f327e81b61d6d91eca3324519015c717d04ae330260ef59fe911fb802ac069e1094d9ef2a03c09570248f4c3a2df90923a4555671482f2a6932b0b0926fd7200cbbd658dceed4ff33b3c9f1009aaf14f8108a702251eafe56a712c91d6c63ebe18d6cf97e76f1a38a36c1aa690244b16c7c2f8a24abea6b9069562f8895a7fbc4fe7a7181e500dd2127bb9c87303117947a0876ab1043b644360fb31dc115f1779c40c32540d075e4f3652514a4fa4562328366f5334d71b6f0323f53fe762ad79b3c87416674083722bd16a53cb343c5093eeb65079f95c087d40117c26d9c2894ddc8fa136ed1dad024dac96007ddb674bf1e0dc17bf3b9fa8713cb5d7b086c2f5f0d8efeba86941e5a27f10d7a911d350228bf66f3046120601f606ae665c08f54225196e27642a10da10b99d43b85b6c625241d0c119c177b418208c50dbde550532a2e7f7029854db32e5ec8d33257b07f2916ee6ccf7f23547ed80fb30beec74f4967f4d4d33b0572ecf6c3a9dcaa39321979d1b1a27a7c91f99c5956b76056a30d19d4e488d4a0b8f667e6a5eb5198f3d853e26f2d2bb969d3ec4b2dd320ce38960dc2eb5e50a03908e73f94e4994983a0244c7669546fb1e9913965dc16054606469de9ecc3c17a3193a4149635a3e7c78b50ba7c8661081f7905d363176ea30242b31bf782f55bd77b2be27f96b74f6a838480b5fe122de2549f605b0bc88eb0514721854ddbd8da2635dc8a3a5f00a259f91ff329929d5015296fb89aa6fde198fe207ebd1a7782f94800972a272d294f77559eab8ba11850249c8d96cda891d3161a5890c76c6b4a7fae1d4f01c5de23e532dcdcc523fa98cd0b0c5d654d882d9ed98a4a2916a60e2c5f94d1ea972913f7ccc79a933e48f142962d2cf1e64a6cec330c84a54277ab9925ff1eb0a3ec0def412863d448e387b6bfab0ff87e986ae1decf14da444a926fe0733959f852298a28df50b284d32ce2e90b20146829e5cbaec2a4a57de033d22bdfbfb3720dc0c94811ca3abb4e29f7a056eb665ff0ca4d150b54c38a5a8e50f52a0405db8d1cec2d52b038c9c28c827aae05e7e1235eecfbe9ab5499569e855b4667e97edbd2ad59389cad0bc24c4029dbd66370f155c6bdebcbbea842253a503103f07d456c30c216e1aaba348dd5b0a3f7e348bf211ff11fce4e6062d0b9a94ce81af81b31151a58618015f33a3b459abddb0f027e91c6cebaf1618e94fa9a8e982873d08ffc6bf551f5fdaa43b92a1b0a0ac7e60c7247c79a6ecde9a129bd7e1285bc5b2e61645a378c285705a730e8f1b354c988789eefddfee8abee5cabb9b46ea2d596ecaaf343f17c1bf25480a29e79638487069601adf76f0789f41ec085792ae1d45f972bc04aa6c897d4bdd2461ee096c90acc3903623c28f2240bc08689e512f2aaf2a577abedfaf4da49df8e3cca1a13b235a45e905a129382e4ab935d83b1328e3a344b33432d5665f1a1195013211eb3eed0e114b3fa8ee48853908c8bc63c14536d18ed7b7a8d32b6f32f24768cbf8148aab4f9069496ceb0bb31f745829c94e856bedb99c168ca25fd634160f5bc12e7ba3b47080d61784c22bc298fdb0b2acc5557ed843dacd93658453a9e0dcaafeda56e9b9e738983f249bf66c44e561dab38114c76eb997ef4869d8e646bdb3b9cf4f43f31dbd608e65e249eb508a6b8df115ee740ccab30e6a1868dd7d0bc3d78a2aaa10eb8ceb5781b1ccb29305b8f431b2e2622ded07cef2ec9f4726a6a6b0c3b803284d5b59acd06c0da0ec65cd25f78f0f9eabdf90325564504c327fd84397fee6044bda2f4a753e2267c192c665f8a3470ff3fe0b32694181d11a758b6d2a95c1233ff5233f90879e66676901652064cca3e31a084a801e9d1e1299577ec1e878a1e6d20e5946f288c230d65997672a749e96925612255a72222d319a89544448e45e6f95151394205ec681ec732b79e2a6c5138a00a623f950f95c752206a1986581d6ce0bfcbc8768ed86732fb77bc05f6c48fe7eadd4322470a0cc2a878f1668e322d4b1336c0148816278a47d66a93d465b30f8da82bf1b2f27ae19aea939f0a3fbafcf4792fa1b7272f47aa6496cda53e9179a59257f6d945930f6efbca67cd16c7aa6937966217b82de9995ad4f0d253d33d3fcb0a72dd2f13a027bb41fcf73aa089c707cb51507253516760a45a71adb30bea8ff989694043b8507c151028b1f3971e4f9eb9597c3ad1224379dd682fa51bc09f1d0e278d25df4b3ad2b2718dd729f0f8591c9a0cd49af4f637e4d6ecf58188f6929f0bda89f92a99d5ec74b20a197a5469e218a7573985f3cc9c05152b8a686d6b8dfb55e9151a79ade84f68d3ef330470baab3fc0e750cc69d6ac142016bc270b189096dd9f3ee4aa884b74fb6679583cc058184a4e3d066fc6a8ef5af454041b8fd48b86b7ec9ecfb6a343700ac3e2177ea1b8b14c0132cafe0f091fd1d6c0e5ce5ef0bd7b9ed85261719519d9d8f83545b33501c433ae0d1c8f217aae7e350f4ca5aa383052474db491ce1eae73862f1f5c4be41865517c8033523a253aa9cb8a0b2452d7b3defe620ac78f89edb8da6e456aa0978502d0dd6e6b8d0b9118b2bf2ba7a14ad016132794261625d0b139f20fc1315dfddfaaf1803004ae4f3e95b9e1daf363a5bc227b2fb19417ec220838c0a5c968ce3f3bcba9f17a53bc78086cca99a386c03126c26286e4fbc3f90c516368cd891f9104cb6782d58a9164aaa1774ff18fd1ee6d640d67138fe75cf05ce5666f68076b37b59cbc2458afe50ed454437b32146f3b2660ac35c3142d363668517209bca1b148d353105ceceb094f789d4988b38c33a90aa839ffba95a23928e593d91f642ef866e608588e9cbf26f9fecd63acfd1ffec2e2bedc466fd644a5e55bd02be1ea04e585e8c5e26f0dfab40376e7b4d21d66c9cfa39bcbe9a13672f200287822575bc4c9568faa7531911c501abb037c5b0c0d18690b96f333fddeee247df6d6468d10ef2a3f48ec3ec9a8c260eaf498d4126d456e1326d224b037c78cfee77d7e417fa3a10ad568fe85e6ff4ffa48db49c16f46249c4b69200b1b9d8573257c4ae1cf26156a7068cfb1a2e056e2c4f30e5b3723eab07d20abef83e9bac01bdc0512670166e1d8e660e4516cbf66d777453717e490ebd9fb172b4281a83161b4b35684c2673673244e3876c4202a3941d302dd8405a57ef153662b2f3a2d154b380cd45a3a79070e4909afb62c3afb8750cf9305debb9a714901cad9387149f84ee2108f99f3d9e11699f52856efb7f616f539343c226fd2eb515527cbc749bdff2c6034aa1947423e8f3484451a1aa0b937ae1b4bd8eac3a03375d088a4f29fbdb73cdfd4cd5a0843675a99499714877c36727558eaf114382b098457efb141f9be31bb26da7bea26fb4bd389d883f5edc419b0e1f66cb288a7e2cd7388573993dd30b7ca39b61c294d6299810eced4688dacd64de5d98dc565149687381b1459a32b1ffdac211d0c266b4e2e407e498b8eeb112478707e8188315bd7e285d1d743f62059e07595cea8555e2d8e800998e9cae196091fecf0f3c0abded36bcd6c0e114859326989ae768478e498659bf7c940e051eaecb6e23b2e2dc8533e304b4efdf5851a50f3daa9f22da2e6f7edc3fb79d212303ac231b433912bf0c79c67ecaa9a13263293d9b4de536388afca6b87f151643e2fdd8ac9c18b950f3ed0ba385b5625186bb6704ae55da905d00cf366db9f39132a690c9cd5c65772322d637d6111dfd6e5dd8acb8c8c9026a7904c13282ffe9ea5eb34a67a4138c5ed9a1311d7d96175cd4510f9d803d35ee928c55a92c23b2114c36ec07495d685013a25411886c25e92a128e77084698dde1e5a3f145c4cd55b17b75818adc002131d526fb3947fbb94a364edd40a5142f315cbb9af2da3da6e70647f6ab010c23ac690b32cd3e3758f39dae8b45ed50213666b4794e2711737d2aad0e1e4789b42fdb2e668f7d8dcb8274b2e0472e677c6132fff383b6f8be3b1c5add41ee7b22cbf749940b019d82264647c494f2405806713a2c24bd2b40320c2a42c60350d188075fd0d59d5fa0875777a4a9ae447f3923541612f88f0433cef0b521cd99da8b579ce09159a87466e5d9cc1a6fbed6b350040374b6d162a8db73f4a1fda22ad5b5ddd5446afa1fcc2c2f281c1946b7d600a2280353c2eea7d86220ab3a9dc0359988fc3d695e6ba5858f2b95bae32d19dd60e84b316b5fc41a598ab1bccf157368187f1323e819d2da628215dd759503cd712e863bd88f0418dec2d38a68a68b6b6c76a41338d8aaa802d59b755437180d577986857c3fc59b5c0343c0110f0539975bf5c830f9d1c82efb39aea3fc164e4ee48a30e3e05a9f831ba84a3eb0db39f1591b225f6485efd1b39eccc3eb9dd48d6ca38c172053d3106c2e1d767594c6c9f776659bc36286c6634f9105fcdad3389ca7b233a49b2ea62939e51692b5727c5dbc106501478e6bdbb955dd9481d2e9f02e5d0147d1b6e457794a9065d828bc973e37b83da7ad67183ee23de8aa0684a0c4978213a9910747a3377e881c8756fdffc6b648f6575e732127235df9942dd3ea8c45800ebdf685a535c6cf2955cbb14786d483e60f10c6c7a6d7a0f498b8e81aa9d9b24a4f2e1d0e74affaee70af7c3b2ca082054f7d1fedf5b1521350b21458e80c21deb2be26a4b74507edaa4e9de3102d00d7d3120f8a8d17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
