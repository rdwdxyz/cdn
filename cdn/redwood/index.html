<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a5f7b6f3e6230024235b837908ebc70f2afe0e6d3237be5b8cfbe5563ca0c314d0fbd0fea1e8d65a0ddfee16c9cf77871e6b61ee1154b27816bd0b994c33a6c0385690f8f1a4fc9e6f4c114c9361f8bf0383ae9515487173602673cc4e816b173d722edaabe34dda54c39d47311e47e41d07c9cb6cd75265fc888ad90e56ac3d2dfa3fe9db7a39ee53ed9eb453077b15018b411c43df5c049a515d7919069832d5f2b37f8268f559b6b7dff70481f8066f81510810830c957295be49e463ad525bf206c6152dedf8204cc28f0198dc6003baa462fb71f9db18afc4ad33342b6df1fbc7f57a327ce0463c047019b0937f0ccf0a9fdf7d7ed5055b811965e5c50e38d4a6c1c70d098134ff425ad80df272886d82d8430e912bd2090d6a114d6eca0d9813cb0794875cb586c6628fe85547ef085d096e9f2427ba3ace953d589c923fe18f7314b90112ad5e3cd5911d049f78ce665acdc6cf7036095420532c9402525f16f43392348472c772aeddf7d36419933ac216869b5792721ca5c28256e2ed36cf50269a5a2c817332382a80e7d547abd89010272c1977d44896a8d2a96ca82f0e930b72ab26eb86f45796009aa05b626496da784c2f0294b69b1210f16d50a2b3b23957bf2fe51ba7911fee8769a798843af51bc9d54f86bb74c674936977bf188be4753383d523a5a235da50e5866dcfc71bdb232be56217446d39528a30e6d21425dd20622c5a8718328baab682f65b53ae61223da65406dccda47b7a9a8502403aef8a61a8927da8910f47d5df39f4c5a4f82f13a5a37f463a35431d0fabe4ccd6d604a3619664433e503051268f31810b0c580c765370cbd2c281db28fa45acc5de566950a0c43c0768a7b01e48b16b29e60fac646b8ac9f4f571b70619e99d2df254d3ee11823303012b1fb9a541cb9337f588aaf02b3f3376562d4dcab9f3a12f07c83133c14d494367192c0fb855c463e75a0e4dafb4d49bf333c4245952c56b36e5bbd5d14cbe8ce6c650cf0f08dd9bf249f8012f7d0f4fce126dfc07fbd3e151235985b039f130167f99ffafd2ca7963abbdafa67bf307c8e23bc5dc5ff1696ee0f74798cafc7662a4580d6d099294422c0cef77bc9035a2a391445776d64365d5b53a53caa951b93b8f890ccb7c919d3b4bece167deb9bb8f006b316a8056baa2444990ed8dcf1b2f9f209bfa82cd65386a445561f6b6784305ffe00c59466df5af5c7daa4627c80e5774e81cd2feec1e397c5e04944bc382c90d9307f3764af987ad5efead9d3bdea58bf607c7e1aacdac59fcae679c670f01ad65c33a54ff5d1abcc0096f8ff6cea57967614897079f52aae3638de0292163b1e11eba9b73ede6fd502100fbb2b842e3f252c39911cad5d13aac74d63c76a86dea4c96fdc6504ddcac242d268c6a20a11f7fa08f5a6dae4192cfb9c5e2b00479af27fc7a8660c0ab781ea7812a3c4ad8d35f53a329769932665ca3ac696727223a9aca2b4fda58876c1b653cfc9a8bdb363aadc08ce98ff5cc461005c3c6e15a3e5c089a4c365f1748615d46a4f9f99d5da1d781bf86fe56b3ddd1670dc795d5c85755aad5250615ff6f327d3a14fac54873cce326cef8d002c905645ce77321e20cba7be11bcf0ef9fa1ac901c5f1e0e49115fab39dbf103373efc9b8c8a850a6ff4a49dec46b6ad989f0128b27b5b411a7f64ddecebd3b19ef93d2367e07c517cd62914859816314705c9774f4681de42a0eb3a94875aa0167889ca9dbd8d3ebe1e6158695722d1654fdb0fe25fd4b047e913662c810208238297eeeee2d9ef88fc965415f33a8ff94f2f478d4cce0599ba026c75fffa64d18b1a7d8dd0b654cb7f895d9e0afac271c0381400cc53d5a7d41a6fb0b467405ee62d88247d4124de2cdf6f1e3cda607050648877d2a9f861b655b47d6b26158ecbb7f60879631315aae0ef1ae980652896ed3369e134266063f25b571278e8c864bff7adc732990be30e8ef0d1c52303cc1cb0f3a04a9411c5c0c89214722e1ba59d85b5e7cbb25f169d67aef965e52c913ecc1aa158f50c75b46e8aadd0af27181c5cb58f7bb42024ab6a2c62f82487d34dfea688d65cd6b2573890c5de76a2ae2844312efc0a9e0b7ba9e73ab8cb9ae19d3f5def1670d2a8f127f42c9b4e04cecefb00438c95b215b3d413c1eebf90d593644d7f90b33b98bcb0f11346b8231e9b566cea7f5d8bdd2aa8466534f13b5fd764b0e9d73ab0c70eb06bf53e13b28d9c3b8ad88aae4a0b165d5b6507bc3f2c7ce8583e06a7ca102af77ca5dc99ac4dab4e34b2ba282c66409a88ce362738954050ba0f46f0f088dfa882abf08dace0102fc15adffbd187fec3ab9ab3a99005b6a1a95a456e0c2b456dcd7a97cd4d89cec026d827e5c3db41a5bf245dfb008bd0816d73ee407179e3b9b52c7a0f37d8e284cefe8e4cc0a10e0628ea2ba9ad36b20d35336c037a65b51bde81b7e0271b181cc7b26f9cdc0daf432b7ee9f07f662087979df4e2761a6f3d9bd8717bb3aa2e8fe3086853e4d579a2b1f1b9df9b5b21b1f7d8f2672b3521a3451caf6bf46f849322ec5c99c24d443c20d37665aa28b03bfae178afb451d091c4d537d57146d760ffae12b4dbe5bfc9970aaa5738cf02f42e2a0b4de5fb6252700b9b6dc097bb3dd2cc910f838173b72aa9d777e042273a276208a8d4db07e26604e6ff667ccd4efb268019e95847a529511a4bcaff35b69e449a2ff17ad354337734df404661a9f46db169264262b984e2a63ba75e49873b6e76166a0fc8d4740d90d0a5878543fdeb3fefae17169124cc8d4ad9fd00e4f2e07427d8698baeac394e6bfcfa40fe531b566667a2d0e2a09a2386d68c23bb1ce57b896af0ab0a21136551cf4843fbbcb724de3a8f41f04d7ac6135025194dc6eeda90b87ce864cae4b7211b5bdd6d4dcb7aba13cb8d417afc9ee70a77d22c7900132d1bd2ddbc13b38e953dce2edfe764df4adaab3e2ed6555d3fa8cb2fabeb1dda74b37292f163cb5c0833fedd71f1afc0d730f909bc211cde23cdc7e786af54b31f02d07016dffaa4c686faf5a4e48d3e4f0642e064a8ac120556682c06fd0d5c83d1cd9ec585ceeb89e4f57ce7effcc8945cfac6f87a286de027c81ebdacfb35418093ca8b747df56e6cdfe2c266fee9cfc7a08ab99162ebfeacfe34a7f681683fe2c0241a6f6e8d7798d15a2396b075d38b375c1ec67393c94565d421aaecfb7061151ab6bcebd48d259e36a8e5afae1996e6356f53da4aecd7f8f69c61def91dd7d4bce04508ba05f11e816158a6c93450fac04e07e902c0224623e161cc548784fa33f8256ddafed87a6c06357991f28dc12c7caba251f234498390bccb1885383e7bcb45f2235ac59507603d99fb6dae484c4a4400c4481e32efe3ea56aba42c3ebb7affdd647daa837f91363cf7b3a06108572dcd27413560daffb95e07527920329a0d8136e1b86c2a0e21b4e1e20e6e3f82f02b3aa10109e6908792682ff5659ec02463a3f805e95bde97b831858cd601a2640130c614fc1a54f1509284cb4f511da02ae32ef93eed283ef05b5bba1cc1517c9e27f262ea337672213855b1997aec2117277e7e50bd9e6af0c1adb7302d8efb2d58a6dd313a1e3ee776c32f70b69d02c3dedd9c912139153cd9c34f2cb4cb4d952eb0b79bd25592baca0c56f6fed79584ad0c58e3baa597c2e57571a1d151d9c58d06dd257ee67242b2253d698a0e707da6838fb30c88e981e873101e3b4383956a5a9b1b2436607f0bdc164ae36ecae99b21f7fc030582784494727f2fb5f7659d8124fde48c77902724f0759fe7e474855e3049b57cffbdd1deeb3c53cd15bc8ff2d9a346270194bed700b4112883c25d5802de7fb6e0def149ae46610b79f9dff28f98de42e88bcbcd6fd9679895bfa9ba8f89863e3700985257d0195b3b5b42046c905ca5b06c8aa2ff002f258d4e763f50a71f21e7a34bb12f6baad96c3dae3fafb7093178950e5b16a31271ec530b156dfd5447d295ccdbc2571cb3c9c4c072d4a64b61ce60300c217eef0fce1012f70ae70d0ac7a9805093439ddf589ddf2d39ac031ef03d5d098c56cdcf20abd5dd6ba45d4290c5bf7fef102d83e8d4dc30815719de229f7f1b5deb29dc7f6b32aef8008061e6d02213b902d0d0c2a33e8477676ebbf27d3d43b56583f035e2308b3dcc71d5d8465759d1091cf2402447024da60140e1648a0b96b33f16e7eb5f49e99fffe56b5deb1ed01f2f847cb08aa367e2f6089363aa322e3f496e3c01219d5b0379bd95bbe7ede921ec408da946b5df11fe61c80b7f9cb1c9fafd447cd5e38945cb1d20ac48ee7b8e9e80663426f3f81f6d7877f21ec45365d4ceec9675dbcf55d377fc3f4e7bf1cacb8dc1e7682549865ebe29f5ccf49c9f6150fcdae08bbdfb52665ebabaa519eecee76f31b0d30297ddff64fca15e7cf145738e74005989683452d83ff4ffa8522ce68c500555d852d213eb1faf84b4d5de14f3fbd5d1fcd6cb04cb6270a1babff4adf78dc29df1eabfb287a5d96ba45f393a5d31fcb8d575e076f3cc04cc43111c41b6e32aa5ced77e0c79f984749ccbea640f06d58a921257dacbc18d786796635014ff7986fb194f1fb5c1516b0f1d1c5f390187926bb4b5be9bb71a4cba8651c38d620e62231c71c50e4651c512fd9cd9e3393d10fd97e3966a490e3c64add00e3156154980d44cc0764fc2ea80234207db49fe21e9c6a9d734869e971414fb4eac56baee87b24bc23fb7b0c0015e430e5367cf50573da9674ab57147305794beecdbd3ec55caa5aacb3b309afc15718c988cb1673075e67aabcb0150b060aa222e245ea982e1a5f337d3808a51d4732fbdcb8cd655b69155578e12d73d00a38eb0f58bc5dbeeb4f5c208af6c02856644339ad9f3dacd281ab0c1af484490e12bbc0c92fa05e2a04b3538150cb70dca02846b7ed8428de4b41a3de82621072a60a7f0acbbf2e0882c048898d7858a9f78b4f7af52332f9ea7a01c6c9c3c6a0c1d136ba480a85205f7bb8b891f4cd9eb4071c0fdd3aa55eb73f306bb38605a31a9a2c4c742135fea92c1272ff5db46d58cedf434d0e41f064ec3822a30aa698b672229493737d3402257545fc762a03bb191c9d196fceb14a9d8f4c70fa83e588f1d21083e3658cd996d711a30bc4cecf50f9b2f9adce4a292138a5e88fcfe139821fdb46c39425170862448099589061828725fc0376bb9f565261eb28e5c1507441812ee9b35c1ac9e63ef07d98724a9150b6922e35e4578a5f64f7b44e86893d5b378726d82656850435be29480d76bcc6e3e7453cd39f0db9178ab251c389b806d67a4dba579f97583f20389b81b8e6e8510ad3428ac719410c638a8b3d05e5e0c24154be7daa1a8702c1d7c05254732a267f785e05303d5e15ed039e6996e536e20a4940a6bb8ce87b985db4005fa32c36f0c0757f4aa017f1bdb3e98c44352d03f50ed1802c01b244020d7e8a374a640922d670c7d9d5ed69a6bc50cc2bc6e75e5478eed98288665b4efa8be96c28d51470c4f411da952eb97b3a4d652dee1a7b5b732d98542e9623dffb05d11b49169001d378ff49367e289963d021d30581b030ea9b13ce62327fcc60c9d31090071b044c910954c4422dd61afdfdf55655ce510d661c8787c44dc9fbab4cbb452bc9bf96833b318e169a2a21cd63e06be1f207da32d6c5ce847e905b7f0d35ab12af5a57755341edf2fb479a4dde20e8d808a90e2b7165bcd194a8a53987906f8ebe53ce8cef64683a822732bb10d5ab9500e4425e1a039fc99d1150960d9d7068756e773428121af19d1d74eff3597bf46a5bf3c5497704feb535e5feb5513f2a86a5bcbd36af63b0cc073568a4a17dad8b6637faccf74a54be3c33855bd75db11f81e1ac9727e00b982a7e2c3588ab5fc0c79b90482c874991a57ec0470c7b1620bf6024d0abb1e2d42cfa23490c441df12a499d69f0428a84d19f87a3fd39a167102fba1f0fc8845f5cb6a4431a635d76c452eff9e1f0388dc6bdf31fe6b013aef856d8a8c933a9cf613bcc873cbe95fa8757ea5f9d320cd8fdaca31f459526c02810d27c4bbc2f4c084a383f23c31b3926bffbc3e53978ea0a8fd1cc06c82954ca9773157fe3e447e55a412e6f424943be7a5653d263dc03833c0ffea3e4546a3362896685273f2ef04832409266539ca86bbe35365be998ba7be89ad4beaf7074cd501a8bb7c1962643029566775ed844b65d038f853f31b3ad2ba70b0fb786afa8b414dde9fd692bfed9322be9fb0859ba0da10d8cec3f38363680a2160795672549940646bfeba855444ede3058cc3dec12a84da8add63b94266de523b64fa821a0908e893cffd9eeb7103e3ed31675a517f2692d21d18d9fc777d2da2de82f30caabddd6e685e0c859475f60e5d46cca5179a7fabfc60cd4eaca75b0d235dd85dd3315cbb1c2a8fdd0c4b71a3fde100b379444ff09a9368c6a4f35c2cb716fbeeafccc83d96456af4b0dd75cdc909557afb95144787f8089f2ac882afab4c8bc7502e18108a7e96a5b158e1188ff74b23a1ccee3e978bdd0bf6e0741d597467935988238bb72459c1301d5f39c2ec3c87f3978a7388311df2ecc4500f7b2dcb320db8318574b73351d40e6ce881615fed09ce418f594d9f04f78ab3fe5d4eff5d8b8e4a325cd837294fb36c1fd658240d4370cd25ec59ced556da1f10ba0f0a167f0a516344768c49157ce3ce1870a7385075b3ff8d574983a7d46cf47a252eadf371e0cffee15b125bc83bdcc5073796e15d7454a27b253b907ec3f78a82edaa21d1a1259611b715289fa9561e06089a9bb0d0c25dfb80c7c86a039a6b5f05698639e453ec3f0eb1c46af08c084cfbbc3ff597478b0f3b1b4e51c9927769cd3f087e463d50c116c03ca463f6b5401d8454d306cc6e477e05acc1374905698274b8fc0e660c0214447ceec92b8cc15a1165ea219ac155ee2941cc338ef7919afb29c66ce14962396bffd7179d1a8764b7c0625df3f4045fa7134cfc713e6c74c4b51a6fa29243c3522c7ec00cdbbc94990a7afa4049b5607769c51e1502e774c30f845d4db76adb5f2984f32b9adf8f4fcd7ee791087d6862b33a94c11b511306318865aac4da6dde41f5ccfce68377e6924b90e2b78a500e61e605ee43cb2d2fade7aa67b7117978f4c20a98c9fcb6f7a324b9106cee577d7e53221ff2e8fba8e140aac8b1b52a920076ef42e437c0710785a3dd9c765b3a9c07538bdaf51ffe2f7cff5d2c8ea88004abb4aeb7aa1dec17f73d99621f4bc221027f8a37fb1c3abba9c123f85c38abcf67fa5d1d0bc18d94f57efa7103404f2416c9811290bf26eefa32f3f2f428e5465e0f694ac8536a93a025b76d441036d3ae38272c1f6c83246b516dd5ada32fc4bfe5ed57df8e8f69af48227419f16262c9f7e44cb3c435a578fdef32dae039ce9328a9b38367682776569ea12b787ed7a7031eca6c1216f98bd79f921a7654cb87d60f4b3205d77e3345672831034bc3a81b02eb150ec8a2bc2259bbcc0f5e42887ec9167f1726f88b204f1f7fb7da565584a8989e2845422e4840e93e01c410660868874cb07455fe225ec3b67869016b25e41f775cfb583d2af957e981b9fb7d3aa24e1967560672211ef089c39a7ab97dd27e28a59c886c8568b34dd7dce3ce184a95982855781c4c9c0376eb4d22d5beea04e712ea3343ebbabb697b9c2f43917e18f1b11ca05e9f005df41bc4a3d4d99d80b37488aae75f09dca439744f7e0104dbfa5ba582f4a7995171299b4901778d727e5453f86c8d0ff575988077d465dc584298139b10b526e86a661d0788819bff35a65bd0f2666797605b1b564c40277025f7e5385b6ff69bdac9209993ab5855b68b4cd9fdc8a123629cc1c4b2d7507b490ab72c15e26151e6043aca907aef889891bf1184f8f04409c6c5105498a1070d8ad20e2627b1fc447b0db229648964c7cb3728f1b84575c0fec65f35cce2a8414bcf5989de9dc33c59ce1d09267e1ecde85b67ce15a98d1bf9c39d4210e71a0d3fd673c04f106db0aa7cee660b1dc415b263f71069238385a6e85db748bc8a8e8dfe0adb2d4876d8ec71abf9c867b021d67291fc832870cbb2930e4183f8ce90bfe04597f398dfe104a14b0a044770ad6123718b4328ac3f0648e07cdb77114813ef510179d3c15a05cf4e599beea7e7f6786198547b47e97d85519f3a631d14a009b5ac324afec19651f44d3a7ed81e7f68a081685e5b888709bfb441abf8fa8177a8515c1bd6aba97f8bcb79198a482d5f5d409299fc55a79ef730f18b350314281068beb6e76c7fcddf776b17f3c6c8a31548f0457ac0dbba520a8c3e4c5e3d2c7d9ffe5af88bb5c578e0398164faf30325cfff12926267960bc0fc183dd5314bc364f827b6f3789d70ad2aac3657fdfebc5438805e43a7b72cfaa5f1502f1fb77cc50082e4f82d9157a31c79f4fd6ab6af7d6082f71fc30f174f2cc290e8618263c1088d360c9bf7314cd9cf1eb8bb4b837594813e379afe0ce44a1df7389b2529c5300a8baad4fa0c56a0400376d31f8d85b86df4fbc6773e892090cb1ecdc5d96784ae0aced391a26f2d88eb6ffbeb9466c5b6677b13fe04c5a5c4951ba906e7b1d0cdba1226ca000013f14aa323546ee431cc01a2cfe5acc301fede6e659ba95984ea24e8b0b6af2e8d1d0145ad95b7b76b64269de0b063389bda3dfaa557dbf5f7292da974db26738b668b0620a6e22c165ca7ec058707169b90dd10442b046b2ea20b4ef7f3851f9697834ee804d66aa67440d62e34d9619db610cb4c6c3fda22cfedeafb5e3136d288aeb89398773edbb6aabd1c79188f18931d23ca399856b1144800b26b447dc277e7fd67ddf8915c85b19bbc0431eeb2c50167b14e69f8f99b5e210595882e97e49f0cc0e4070982b95b747afcbc23c196f1803834c79ef2a4f264ccdff7617a190fa8225fa51a288b1b3edd339d1abf7b7623a13bd41d896abf4067f505c1b7669f0be3c33602f8f6b15aee326c323076e08f53924d0183a12fcc67739734b283c9dbb83fc2110104b46eff455f1871726e525dabd19a2025943e365511a6e37bb20e127f337d1478d95ed96672f21ed1e7980a6e6d637d1334c65d05df35f2c07009e9a1e58785b8831a016fcd5f276653c9a6f07dab3daf5dd59c6cbb62cd99fff1d64c5e98112301dd77d8ea32996bf0be28f6c1f8f528d1a5fc4c274425d9b63cf3714e5f533480a10655ba1c52ce3a5cb4cf3b36ae5b81e57aefc68b65c7049d747bceeade2efbbdf71510703bc3eba9774b44c3ed2520a0f97a2441e71761ef4621dd9b667955fcddeaf2d39de3215e4f4dc23d47f160fd78a15a59fffb34d4c674dbdce2f41ea5e9ae5470a0866572ab8e4a0400c3c6c131bcfc260207b2b9b2b9cc574249f27e6c5302261460d4501476c92d7d286316d2d74117d6c176a2340a95241529956b1a92de9bcf3ae1455aa67dd10819e7b7e1295a096758a4f82b97c65efec5f01031f817376de01f5d6d0a006fa05bbac4285a903490457cf0a3af34bda58496c464a70bc86ac19ea6d47fc69f82ab33f6f45d11bac8caad53de090e2e9c7de487517c4aaf6e9f7c37071cc1e08ed0c68064095af3a5140eec6005299da97eacc1489e25f8a66285a006f62d7abe0fea39e057c05f3ee6f7d9e346e4165608d3986d7752318b71e7750f04e1672b285f50a37667f2b6e65ca4c1ba3890a998ff9eb9e552dbccea96ced1fa3b3f795713d3f005f74a7aef24ff5a9ae80db800ee75a019438b732317083b3c72e07ea736a0d575a541ee48bdb4f42dc1677da94447b57a774e4e0572518d4a317a18734e14f720bef06e634524852ee6f6684b83da3c7b7081a343eb2d484ec58bc782dcbbf385da44c3ccfccc7c55a10c84918cb4ffd9647ae3b47e44cb603d480bf854caebc8d96cf07b6de668665fe3d6e358eb2ee8c6787bd879692158f1f8656fdaca8c573d87d52db83d40a0d08afc10685777ca9ad5ff95996a6b3ae56e99ef7848ae92398101bbcbea2ed0013ff2eaa769922f948392ea7d296192f4907685fa6461524f7f6d35cbf5ccb71afe707339fe1b5e71f0a9079f2e31eb61e18c33afa583436560b6398d2e4a69fa174fe02edb7c805c5d30367b34b2fdf2854c9dbd683751b592d53834147a1d6a3d30482c1500176b12bb4eab0a6da0978a5691a7e7da5fe39cb2dc4ab431e4e306d6384f8cf1284b26e2793b2860cb88c6a06ea719b660f060fa4a18891bc2a2fabc4c4762fb2b0ee186a3acb81cf90cff87354b843abd63aa08b3a9cea1120f595b45e45eef61798c03c90f17c8fd6b559bce1747a6731e5f366e71222276e5cb9b79be139c11a849fb852f862b20e4f791b604a5690b9f5994f16b4b163864e740921fea6e37572e7e9abe33fce8aea76b13dab3aa9edad7ddb44dc470f63814d75a9a2751aaf2f4108987e51a083e7a1c0bf8d51c63fcf3782305bc6398a9d58b0a2d3c7e87d5f0f4c4ffa9e862afe220dcf0abddee7dd28a297d6e0f7eaa9e88f402a7bb581552e4e8d2edfc94ebbbfd99894994d4629b992032c99cd25c3ef94b0a8a529090b46166f33ff5b53163f389ce2d5eac297d769c2fd3ba0e71a90a27e243297e8fa89eccc521c52a123a6b9e33be805fe9722431e9efa3ddc9a896ffc062b1ca41e516fb1dc49db472a93169f1df98e7319228dd8252abe053d0fac26d290ba38d2c3d0986e46ced13902106aef3e65b2643594e7c74d803a7a967b921ea18b6a7cc2ec6e25fe4cb999d18aa86027bedd82c2a9f4c2515a0788dc0f42105107c965d1d9a6b7193e89437a70402f11679cfae1a773d6a2379866a8cccbc325be94b3c1b5b2ae1d94ca06a0fa6863198ebdf1683177ad69f1b4db10e3e3e76491a9bfd27d2a6eab52c6c8198b2380d8924b284d1456cc442357cb8895939b251add6bd551d9f10f77425dd4f6bc2962aed414a7d27f23b184953974c82a754513c8d55d3ccadf2e6babc4decaafaab031296a81b147864a421ea79c4748a420f30cbfb35c1527ee74d4ee82cacdb3243f0e9c0d4ad0e7e290a15d07e681d25daf7c0358301ecd36d9331236db38b1b9a1972125f346e0e22a2f53b41b8406c060196019105a96b5ea5db7f0a86212bb8a7c8bef1fdd2d6caa6be21c51b8180cdd07fcc398559aca292767d4c4df3e77962da8c7f6127a72378960510d0c13ede567a3ae5661f67f9f497472c4b6b871ba78296695f7162662fcbbbb709373c52300e6c29c9c3eadaec5e00a9c9db39e8af6b8fb365c137db47e6378dd69a075d63ff63acf1d528f07bf467d4fd521ad623055424fb8f891ba5d98be65f3713572ec3d5364faf7f0fc4bda19b93186fb73e9c0f8bee6a0cac93e6ccd2bcca04e128d52fd9bad0fa108a76385386578527f54b18041030205e25a50831a41ae210060e8e54a9efa223fca7ff4f13490b20d9381459691d9b325d55515a51b9d170fcd509b430e2ac882846e93eca1887192a42359eeb7d60249b506fdaa6a18c7e3b356a6f38a6545db052189683d1933e03043847e8117f006983001f3bad15be9fe791f0a6e4ac762214a6edf933aa4c7b5e8a00bfbaaaf8bd728b0da4f234f0d37a502f088c78969502a83825ffa41c1091ee59861f27db64136beec7ca12fd765f1cb4548c830cc597e575b8c89b2c2b9c2673c827a236f8eb8295e2191a1f6f9dddbf33ce2aae9730906280ff27663229a9539298bc94b346202e8c3a93d83c4fa0e405080a9f47be50914899f62554495fc60fd9a099069edf7c52cb09bee2c3259b53306f7c0ba06f07d22568c3e5fde4b38238f04ff8b05371271a1d944f2a14fdd0c8af6107d568a05523788c204a32e18d97b34fee903feab6063018da81bab47025c4957e6a4347cdea0eef37cc2a00a3994464580d906563ad6699b3254eaa2e308d1ba54ec296a64b73c96fb88df0bd76a67d863d053ec7907c5646b36435beee03a51a042cac62332d5bac14ef29986a51208ed18e6925d8e375a6b234ac7b941f6948bb75583372677d88f9b714147608005301434796942445679811811ad8c58a65eab968e562aecd0904ef05527fb69b3f1d0eb1165c1ea9fd17a0b28c9e5b2c562fedd62c1d8663aea3f4765a54dfd837e2673a9074edcd83b57bed5907d7f388f93e2e6c40823f0ba2e8a2f2e38b529a26ac412328ab48282fb2a6703aea94d91f19970b0e4f74e3c893dd42e4f67b9c7eb1ee698bf6d627ae59ccd1b2113c64205f61316d318ffbd6a10ff9535f375b46de18e4596f0d6fd4debd92c5ed7fd08b95f7220b9aa29da530f8d6baff1195ca12206aaba6939c0a0768c34c7b8a0ce22780e645ba670378784884b40f28b186458edafdc5104245873916b5237056c0cc618a18031d1e01c25a50a2c0b274e0251223495c96872de847facccd12a1758872e311dd9f1fc895bc6802a7f0a9fcb0cbea909f5905bab64f0c5b24e2cb223e74c555e3c8c99d4798efe5e33a9b869a8c60a5949b080df6dc1faa119b317772ed110ace18f745e5ba48ad29aeeb8111c12f1ccf826e5c7323d422ac3cbaecfab9cfb73e3f3b6f920212f29700ff210960928868384e5c109f2e56f104c3df7f523d6fe70c4aa6b4fab1efe5addee4238b67ffb6491c63259549626cfd74935f531fdadd264b9ed9f62dc284b1dab6f12c6953176dea29f40b7ed780d6b05a34cd1f8d89e2609bf6ae18fe790c117965104b11b7270c8125fbe5115e5d1a4d5c9523af597e81eb0ea9d4af921e20d1185ac03e9b6dce0db2180f1c4557410768f6b5ab2b282b5bc341c6a84420392fbfca6f5e7cdb25cb5ac2d6e966a39e42223b5bf7b9f094efed5136bd8724e5c865355f462a69485c795e5d4ba23b07926b62d5510938cadcba312af2f617aeeaa809f9c3962c6fdf6f88af5d4faddc106af30358cabec84cfdddeb6ad1cde28a1b2f1be3e6acd4b2f92ab075b4fed78d15b0d3c4dd681a0fdafaa4a39f59f5f482eb777ea787c47f9238bc979575cb3f4780be11ab12ead8aa378f3dcba570c24872038e9684c41d8d116682ecab0cd2f9b594c71a4ab36e6ebdb0af9dca5e2cb0383028ca6b258da444bbb66978a7c568c960d9b050a7a4e8be347505fb78052c5835ebdc93ce442bdf5e842b7f48bdc2f873d94db15a4555ef9e8ef54dcaa6815e82cefdb6c1586179c1dddd805c24f06ef93ad25eb18f2b2071ba23e5e8f15f2b678301eb9f752eed5945aed6b8037ead810381fee856d3a083d39a56ac64b54f9a03891ddb528698fbdfb0a8a2c9b0520f90cf60e1bd27779a3c51ad1e2456c47500c9157947c3f4719fe0cc485e2bc754001ba52e456a140b5bee3c5d4915a8b7fec0ce7c8fbd2a8a324b0ecae29e9762c7e55c336365453c523d876b224c7c32a3177cfef8207f3aac476a35ff42a65d806b277e94007bdd7bd57601bc418f622c67291a413909637b27b4debf771846d8adb75ed5b6cc7ee066cffdf9fdaee46d407e2f6f9d2f0889ee2fecd5b4bf1eeb074b36b0e1ee23813328513797b1f631dfb0c0d94d074ba4f9388823bd3da244811f5d02c0baec9157b361fa62e644e002687eb4dd985477bb520664bc02995c856e4ffce3a15dafb97bb6057fe2a007f4db008bfc096032d3af05054a5f77a1d080c4c078a0308c8ff0622da61c0ef2186ccf19fe8b85b850cede3308dc6175e7725a968b50f88273c63fb6cd5c09cabcddff32c3e0046e1aeb32cc98c1df525128a41f0b7153ee4f0997d003dfde63d92cf09d48e01e7bff0000b2da15c13b404068fa70e10bb3aa10d8fb21e094e154a952624cecda3f0bdc23c94a4499f10ecfeeab8f47819c90cd6f337c664943f21416fa0af0da84585c7e49c46e85f531d2e370ba24ed30ed3db140cee6f206e0fcb0a5d29cbe9296c5a53ca86ccdee39f707ee6a32e0e59cc5619d34a4a463256723fdde25dd7b8867402e4b052b502ff7535bc23cab7cf4f8551f2741fafb3c94de3a2ef391b8e5ec8f25e0fd39ed73646bfa98cef02b25f1b465d10f60ee12b04e01aa7e7b76a5cae2957784dc272b2de75d9e42fa5d9c7541b82c6bbb36e50c40a1aac5174c3d0cd4ff3764c88cf2993d0fb82bcb95e9674d35e400fb4c013662cc3a2b80088bfe86565c4ab447ca9ced982dc85593a072b270c1c8ae3faef143b3b7785a91be5350805339f6028534f90356689d4de2b1a9411aadc1f9951e89fde10ac5098d48e756de4b9c1d489e510222a0760d737c5da842ea8e3274c89949a724fe60802d63bc079ad70442e78ea6db46a0f79442554bd69e0d2c8275ad48201fe12438165f846f79d781d693cfe2110e21e2e92e13b2da72c64e00975c4b03cdc66e6ab402e6fb0526a9152ebe3065bb11be81b6a96ae24aa117fa2ee23e3c7e1d1fd16ece016ac8b3a94fef821f14a5df3e371ec1ee464908fbe39d4ca1592cc540769342a43e4cdfa233aad7dde667f22508384273966be73c746389154156d55960686f1b0a7eba4cbcb4e21b7fce054d9ba61b9fd2d11683bf6c44e3aceb2410f2b2b447e05800ae176a5fcc0fc070abb33dc7c73c3aa9e1b5d2799baefe30a6ddcade6a8fae3ea2f72688df82ad981d1d4ae3df39186fde7021939bdf9e4140e21d325de499b20916581906fad6a9475a7e15f849a6a8add96aa47b06c06013faa41d163357c31447792d6a09285dc200b0df18baa58279862f156d9b570ed22adbef8ce086b7a692fb6d472724c3f0486601b1f3a1fb0afab34429de5bf062bfa66e76d019e682f416c495af47e7b573720af674da149ab91c50f7f271465bd039ebbfd8e634bde93193bf5c5719ca02ff62f1032b4a5676ddc7663f6be410d5a0018dd6727b768a2cab3e4c0bf128fb469813c8c3a37bce7d3014950a8f6c56bc9799e069a21cbc3813b3a7fe867dceb98e9b64f4b3fc6929ed0fd4f4ca85f1e77bf7a0ccb5a1264171a42fa040fa1ea3782eecbd25a1fc2e6d40763cf9afb44a8c54a4ab0cb7bbd85c7a5eaf42eeb1a48f7d597e00ca6fca356c18ea1c287b7b8a8cd972365c4a86a8df96641a7a1841963187b877fafc74ee440655ba2a576920d73390ada20e7cf2bdfad296f501308f76eacc49d78dd58f152edb92cf97bb3a5c013692c0bd9eae2d514bf566bde4c0aa921d3102d1a6a41b09797512b6af01ebda2a95d908ce8dd70ae8a9323884aa69b3d0e5b8bede454cdd12c3dc5eeff71e68c1b5fd460227c83c3429b4a3467517c787a6b9f03e2e51abb66d27c81c68af7248d525406238771aacf278b450d154dcfb4ec23ce85dbb66bdc0c65f5b6c19edfeb80f9d9d1f7ef897b385dece5a5633f2651380561382e585e9abc42979e3d01b5908351c3ec91caeaaa97877f414454e927c727f1569d8325378b212d7c13c3491d125b293d8692b37b241b71b7f8af61dc82814f5d6d6a1e95b55cb1def76e7a42ec16949aa8ee7453e6744c7f3fc21dcfc42a3b2842911dc48ff2107a3952ea25e920504b30c509071a934807dbdac9431d4b8b3dc65f02aef863fe2563f2d1c5d3017a4ac1bcbec4e68fcb29da9b54e9665b31796bc5efcc21611a8ea8b129298ebc2b1507b95f434cef4e8a70eb21fb7828f149a2c35dd142cb51252de765a6f5f06f7382e2f068af8b8090c83d1b57c0ee47b6053944856a5ee3411126587c6d8a1217a2dc04701db3de40e5ecf6a077b371352be36e45c7dab15d6436a7874c8c7a269d2b4afbb24079d3abca899ae7b9ac15a7743f03a115febe728029a0bc372ef56fb8519bc2ad5dd1da5285dbbbc3ef315648b2388c8253e83bc4b4cbb0f0a2d95c7c636ff8d306a38947705828cefeff2bbbcc589d3c58a1d19c19b8ebda6e7dfcaef4d93ce44b6ae9349d36d7c4e5e59cfa87539f747da1ff77e2944501ecef3641b8e238bab61c8f4d5a5b270b1fb590b4e884ce26e50aebce3f9b4f52d2ec7ded9ea60a953b0c93b32ffe7f1369779f5285d8241a6e642678e4fa582d53f799e0c63ae2d6b537aaa80e6e8f05d6adfd97d56d958c8305eb5d42f79bae2e7edfa7ec64d713af0a34f04d9523db5b99f1587f5dd9431c78c2c4e55d30aeb5c93ef347f0dcfd49d381faf4ad896b980ccaa34f1ac6f3a981793ebb615392477282b6c4d7362417c498e4985d386754bb245cd12134a6b27f9489cd31bc8cb09989318284e241d0baf9f831bbbf877e47ec4e38a96857d9d57f7f57902eb82305bd96e8935a7dc708631ac3c0870addf407706d9619ce9af7f4e83079a1282872e255c72869213a0cf35182dccb2bcc441451c2d00bff729fe9495d53d7e9d36bc4d230bb9ff7ca3ed58b75789d16612ff2ce1063b7c85e26e5495341be57fb1ebc740bd4580d8ff6c29e2b337cb2796a1f79896126f534703269d8eeb646039f3234915279dea9cf85e749ab1937af012843cb05b5f53a130a568402ffc7ac8fa3ab5d545670ad3fd358863d207146fe4700bd83c59b484bfff85514dd4b816e9b909248f254e6e327ab7d5a31f9a2a0dfeb7a2f5606f8896daf006cef7e4e17a37d6014f5527c0a140c5da21703b52ec47de602e3e1599c09f22eac9c8bb091764bb8c6dad953d981dab832f5590e422206310af69a91dcb0bfbf754cf2da3c76ae3eee9be49f9a0e102af0fa0d265608f20c7291e0e2c6a6c953ce319a6906b91e5b1bc6bce07fd4f1455f4d7dd0dbda87c8aee55a0dce5202cf46c3d928d5a332a5732e33449bde0a97d7a0ab8c1a40ad73dd5f8659ab2317e577a7541c907cbed8fecdccf41cacdf9ce2ca9c810a2e46022b6e262d1a9c449e2b7c2abe681d3c4fbe4ee9cf72fd39bb99618bf09d92ebdb669f02975ab0b6c1f87caef59a440244905a72156c97ec340261734d5dfe1ab28f3cd1b5359de390ef560d13e7b425d393ec831c67d1d0ffd5bb8e2fe2677a6210bf600253a8a6bb2dfcb17e179ddc6397f914870021f43d7c270489e0f2a29f26e5c2b1c34d81e7c28f3ec736741c600529e5f52d65c3b38a7a35470157133eab38d5ee741e0ae7cc3b70776e1bfd516a903cb43ea2e2388c5406d4e799af04e5e6740f29427a78ba0311e21b4d532a7b391afbc4fb6a81b3d7e899c99ab55a1d974850fa9344e62ccab4be8a17cf4857c86fbfb268761b90d8965e81fd4d2658a77ae66ed6b320b6e02b5076e2299442ce558dc7b9ff7de4b858fedec226ce6ffa88a09b8ee363c8d1e2d8b79339ce11813bb626ce9c05c21c42abc4829d4263581774b2e2287d13f0188281174c86ad18661143ccbce027789ab60de3fbf168979557c2c33e72d36689ce46da3af82bb172e1ad43a16e01ba038f19ceac3c2549a8fab15d00c199f3d3aaf3219e973d057931e1379a148956565eb8e4383f572b8e6b631b3d50296f9bd820ae5a82be427f3079a592ac33e22a335101463a0a80b308c0b2f2bd77475ec1a80a6242cc7e6445149c8ed853b388dad6fc87641ae9ffa33183300b1b4eab88d7f032d00bb161c5f08923d3388c648daccb7783f5d0846c47e3f0bb2639b29f9c8e3b88fa768920c7cfd05bfac6acbb3f7a66411c455336cc44e70979dbdd9f7f4a9bcdfc39cedc24dfd738057f519e312b198f7f825b6610509135c343b4ef0568bb3ba42dea9a8b895b8c04a827ee84d938af24f7b731f2de50863a677232fcdc9968910ea2d1742a6a288592005c7ee40d1b1e46d4c93e7e8db1b0f858417851f462a3a49c9b0cee311b31a47400315f2230efb1baf4cde1f534e087c907bdb306c0f70643870715b7105b316f8a2bf981778d97d6b052ecf4ef7cdf05d40dead49a77358b58ba7baa177a5000f7e2a026f89eb4531bbd8d2e363d58c068fe04c329f39e179fafc47771e458bd88df936f7bafe9e44417250de8c8c970444ea30c599f257e18821b5abb45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
