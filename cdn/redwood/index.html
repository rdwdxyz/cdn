<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f5d45aaff3cb235ed8d41392e9e8ca408f55ff35caefa2092106e20729a213d0b493677d1807bd044f25fbacb67fb091871b4aa8476377750ed47514ff70aecd6d8620e41a5a658247f20027cbb6722fc1fc1b3e3d30343223432a5d2470a0259620cd9ba36e2354a8a22207810726273d789f70df19ca66598059a1c5fda73326656e0280e16c7d7a3bb61237b0d5a2ba699ac8b61837f0badcfde17773adbba306cc74a9fa85761ef97fa36cf9ec82487221cbfaee213ec0e70f10cc5bbfca63972074c287539d89bc7bc62eadae6e2227944cff860c117427febeaf008f1282e8617c7205d0ae069cc61c74ad5b868189eaea5595c6bc5ccd557e0f5a6f3812d3cb5d5987a5e71e794dc5dd2653e011f0067874818ea4695223a028242cb2bf29d99731f16c92a259719dee0a489dd7e80d0614510eae98e1a60c87811861f29ca1e4001af2177a41e09fe4c925642e5e22503a70bad050d8dbef7bfa1ca0e5df2c1ddf0b203e5e25e9044250818d53e72c0ff071ea4a6cca4a5558a21838ecc5e75fcea1fb76b27d830e6966defaa3668c85d9a4b7886c44b87ba8158d5d85e42190dd71821141e919131c4e0b862ddc729728dc4861cbd739e2c7cbdccd797bae8a20ab4937f4d7717606313701a599ce9224440d8582ca216a57f84b8677492880daf7e618848c07305dae1a11aff2f8ec445c68e4af72e5f2adc50e9c5e0d909a9d85af5be6513e69366687e293b0bfee6bf015aa52301d3b3d5d7e65a0fef508c03bd1bbdf9d6e8d635c30713e475312d122d8832ebe0e3daa21f49bec5acd53656a82c2dc8dc7d1c7f1f4effd9ee1866cf0dadc318232ff38bd5d7efeb90b42c3d01e6a076d660da7243da0b8a38d125d4f0a524724ad6c6a323fb3d89637c30acdd45483f738c879d594be03f40985c26672f600ac926c07b292350b57a23b5776d4dce9985f465cbc2bbbe7723c038dbb721700485b1c5f0fb82796fe7bbbd3fc73d7b3ae2379682b73b1b38fdecba6bd01bfafbf3f1b49e88b64d0dcc00f78e0e76fa479a7deb5554af775c00dd3c071f8b8d0a5bd27e16569e321da1e2a97a18b957be989c1cda9eac1372d76982ad5f9f3b32c6e862705341dcc51393e52668b8c54c629bb2723c39940dcaf0a52eced3f4e22aad2a13c79a825d9046e7675bb11d71b54dc1f7f20a01a90e7170456e829c7e23835de9539cc767edf6e0827eed9f443a300b24e1aec526c9cc94ac35330df991b57f2266f564fbd719b68d8ee8265f555cc060bf451b4ac4218615081f277c836a2434b1bb0ee015d5e29eb85f7f7561c0cd8bcf658dd2df655660de70f8c5af822d4d1cb93ed27b057f78a65947f3dac94168643656a6417defc9fe63c4e3ba7ed1d8225b42a8fb46b08420b3017f3349ae93cb0e6d6da7a311c7a5c0c3a42538e6957b41460972d0bc8652576e943a6641f3e77023fb1b100b12d1204b73c3e8d4a2166139dd22b48bf92862b6ef299972e3b0402c485af2706a6f9a74705992fcb4042cd9352f47b90fa92d17ac780176e0739514f36d3213a3cc3a560cbea3f662e9420cc57f6b49fafeb13a689cd64ad73b404ee764c07a36ab95cef5d6f14a146b95f47f249161673a8c718314ddfd6652ba255bc45e9cb68265e21b45487bb7da6c5805c04ce9b7ca3a169cbcf04eb3d4a0b10b2c5c3f35f801287f3464cc5c9baf2aa4c11d7da9ed5a6ca4fdfc348bfa72a578b6fab9eb0157653554a6c6a6c7ba4761c7d5717df2267e467316ac348e3c119527b82a573c5f0fb5314d67844539bd907fb2a1d597dc2ebf982637732ba71664356e4cfda0a05ef2df92d67ab04a930e7012d1525d1d780eaf553e1e97ecb43893f95c115d50a16122147acc8b41559293977c19611b4ff620b347636c637eae6beaecd4b31c5467e6405eb3ae7e71df5ae9b97325f0dbb3c8a9795e9d71942d4192fe6cba44700f5abd113efe6f058ca422194bfa7c5a40739a51b8143da6d951a679bea6fa883121af48807342139548955bb517b8cefc791227df80433d516e15e833f1e170a7c8fdc5105989d536855841505539e3ce6ffa35e8979084113b70811dd40025060d1bb0df7600984658d10840b50e1f307393af6983284cb7efdde61cc3fbe91556c8adcd00c5278e84c3597412eedfda75c67f2ea7c779bc2ecc14be619ebe1d06fbabb22312727a283f8194701197ea907bcdb347555201da444a9fc03a77f190732b214d0e2cc772744d5eb3b258c83f66a62f1d9d4488783a939359e3b601ecc518864a0ca32c8975d3c72bc6da3d560bcf2874631ad235a1eb29170ccbc3bbbc513a4a87107f9c40b06aa8d315ba60d9b576eaface59b92159e01b182beca3c11ac25ff838326852588678f22ff008a71c7c28f26132df733a2d1a31de6883a3d1cbf8ec65f51aa244a6136740c641433f0cb6f0d8958896c4db737e2931f996e65b19e96f9953e7ff426ddf90a6f483127dde0805aea9c117c7ae76239011d77dd41f9328dde797ec2362c039bbd62ee5e53607c8e31bf498bc4ab424b1a01f1fab26347657120c6765ff31a8ee74d2044e3d9653456df2bb880476c358c7a196665be8e65ac10f6d44f467ea4d9f218e85bebb5f7d716d1e2085f3f553473f5085a489f291c23457836bca58998550c6c0a43024799ff8515be1558165a3234eb32a1523fdb4eb7b227a0840ea5a19987afd9a5d5ebd195f457612d7fe7404d188528fffe1a1837fbcf06f4c8ce149a579b5faef64ebc0c46d53aab001a27812894676e91f03e909cc78c54de0b8798a5a5f154360becb9711bdb74941656fd2befc6e1f7630661ebceaac428c9aee918c0b172d4aa4d8e3aa425868dbc92a11c3fa2303557d74b5ee30a97418fb05b8de8d47cdaf0199704b1dbae9c2081483f4d78a8d807a91bf1cb9e76dce64a2b08a801a8fb5267f8e899f6ae90189fc5dd57251311ff57ed9a23d20efb082e60c4e14543dede05c1cc8dafde55ecc511e6b8ad6a77158d114e23a6820cca2a31d0a0f4d57473130bb2e30f43f9271cf5f700cb5172942dcb472940b6baca1a5ebada7960f15945c5688a02988200a3a55c3b64207ce5b559d9c029b235e871dfb0359e6a8f86c6266484d1bbd43fb2150de88b8993d59e85b44cb6ab2aac3626329d1f8c91c90cc46c89c2a9a010f4c584bc378bd83f15c3cfdb2a343c1410dc7ee7c408469a96b9b0d13cb55ed29afe3e5a4222fc863249deb4af4cc87aa6cab1f09165fc0804596d07015c2c9c0a09f8e2b5df17dc22ead87063e751115f2beb9735b9e89a16766b03278a2ebf72991e43afb2a57b1971d74d49ad192df277c48d80736051512966b4f7613fd44fb6e9cf2c3541364012e05b23c528853cdf172f819afc66f209ea851c20ac0aaccc7192499ca4d48ac43b418615226049dc8cf32a095aaf0eb1f7862d01dfe499aa04c336a930135c0da7bbf9d0ccbe15b4b32201794e09e768e35506cc88826a4c23c0677a3eb7aaa5b0aa805381e44c6246497f2a42c08dc873da17c46c97c3ea55a486c022dfae1dacda28eb80abce274ac5971bae2c4b35d79525a1ab2f2c72f74f726a4902eb068e4256b86d090593d71212e34ff88a89db3f787039241045b04343325286a8db9f9e5f9cea5a97773c2369fe3b0898440e6b8cc89b12ea2f2a0501a304c89012ee02a527f025376e9a0c4e2b2923277b62c1163d2d36948a6820e8230dfa58efe4a59af91b8b450b585cceaaebfbaa269b4c0532a06568d101470f30054f1be7859892b2cdd5cc14dbb24791894b3d509df89a0b7346c03723b12ac769946c3f35bdfb85acedb86ef474755a41dd895f3b2686cbe6bbb0c9d787e1e4eb1552a11f11159757ef9558633b554da15ed4e207188784885231c15bf5c3db173665a0c652604ab413e22eb58541bfcb3fa76c45b2b55204ecb8274ed5ad57b6fbeb8b77cd3ebc2e2a4a05cbf1ef4a794660a19c6a30bc247d74e50fcc6565365632501044f94dd1367e7804c0778f41d645b15b5b3af7dc91bf9b470151843e423dc9a3cc53fc14d62d595c9e8c265546893f92f4ac7190db6eaa517a119e6f1ade7596337c1947be7f3a96caf78da6ef4ab8bdeca1ecb99374034f0eb90d07aef66b7c9eb193242a908e5f0a5ac6f33d3ffe18620ea0b73538dd2445b6f86fb25ea4729f91cdce92771fe06b123b1a8d827a8b0ef429ae715f446da501ff0260caef44302f4c78de72647b89ceea5b11da533e89a2677043158f91fef2cb04415852e2c1941f65e1b99424620b8216290ae3e4a21a135ba6ab3cad026dfd462e5f1fbcd15b84a103f47b8304e78be910b8476f052b043d666435d548e0ca9f05e4a45d67c8b82996eb88cc49a5c51a4ab214a2cecb468db1bad20151712a18bf8728b244468fc2a26a1daa1984084c7c4a574573a1131a342f3f9b0c6932820ed6101093b30d8674072465524ca13197893ef3575554b69e6ea56e4c3aeba652d9975776fed52ec1988cb3362e7047724bbd2c313f4fab6e40dc31c3fc69011cee94fc4aa6ab0be7978db4d35e91b3e58ff2e85aa855e2b75af137e48ea2e7466e53f3138214a7e1c1657380562efc64a39ee8cd9e89fd130dc0913cf01ecfb78bad194646943f1e390754381491b2afc2655f812f18c56d45d18095fdd0a93e72fa429ffc8eb090bb8a9783569e859deeea2d9b0c40c87019b57d0f6b9d6e4f9c2d25259d7ad23f0821626759217cd55c508b0aeef7939e851fa43376d78664c52d04e34f4509d1b9a302af89874ddcbe0cc6afa70fcbf6263d736fbe23d886d64c67843362d11c7f4c762ab5c12c33be47f2a1d4658bbc61bd55c411522de43efa77d983e98d648508e0ce1bcf050da38d33619ea6f7105e27cb6020f0011c8388e2338cd89c011daeb74c943e3cd3a66f1ef6fa82757a55c04edc7ec7fd38c151cab814170b57ad5b366b5d2620a391098a2e4345167195d289f463abd2f9f16fd6062737309e87d9727fff1059eaa509556950f051037cf68d22fc150930fc34cdc4ee7d83cbb8390a144eac609a2c0e2082d452255cb7c5b52e3caded282652bb66ab0eed660d5e3364650b2bec18c3cb855e11ee817dcb9f2585a2760c14383890b42cfa4ebbbea78b2cdb6744d95183aff8ab58d36a6108c29ea01379b53dd5d9d69fcae57f6d206e6ead97a3631dc98628836fe95c4b22cfda259fe005ae9f12bd161c261d2c9598eb682c5ccf357b193aa161dd280447047e3148880539111457683045a2307979b40574f7f1447c0be60245fd8233bda1ff52f3b9aaefa3df90c177bd07b7a35692d55de9dd36d34cca23b8cf7adfe97f98c1bec209740bdcd41a46dcd7dd66f70a5ce05d36687d9c3a6948ac1220305a8214e7b3e3061a68d6544e63016fd965cc37b6967590c388cdac9e59f6ca812f3cfd6a508871271240cecca26d73c02df92835e5379713287d52a3a7b8d28d04944b98a498ed0d47ebd1de89046fbf072881b6bd9ee00d6e097a493139f34d8926b8f537e85dcfcce464dc13b7766e904644c1e72a15fd6d37f2343f821f2d7014b655441e550b955be572024e2bead7dcc7cee09e0e9bf635d3b333848dba97dc9d370df84a4f673a774f3751e64c1695d8d5ea5a311f961145c0308686a7e26210006a96c3de3e71481a1762198a6dfb2b344a9a0fe015793e0402ccaaba6ee437452eb2c8d22c8486b17550baf6943393063c746a447396307ac2c7fa43729f319ff01c339a0ed97d920bccca5c894fcb3bcd21e0e4c40c0762779e3fe79fc0b16d74ead3fb8e2554415a589d1105c24237f10f0a16c0e86b37205d7321d0962c61a39fab727b12571d6c97c44d9a21574562e2c2d1f8759c5ec00ca049a3ea52427f99d6260e1b2033bff32ece166fcdaaa6e2dbb624b2b9b97ef13e1e4972b2df14008e68455753548d0dbcfbcff88a73b1974918113c0645cc7f305bea7acf0ceb7862845eec20a76cf6bafe82fe34625a6582496d12d125455f9dbdfbdc3933d35bf77e17999dc56bc4c41df5e740bc3c4f774667265e4ab8345f4a58e8a4e450ef56801f4aceb20aa11ff7b2d8b43a14e1e94f58eeaf4baa54ac972ee5efc083513ab4f2e4bf3ee66c0fa8eec0d0feb8c3908cab0626b2e68bfd0fdf7e1820a1d330745d4866f3605eae6b4c1481060e2dccab255fdb9b3c8179c307c7facfb3b81bf1ae4e422631be00baf52aaf905f688b4695feadce4799ef88199f5b96b3b4d025ac4790600dfcf23a23d4f5751c095472cc25e9dcfac3aa9568eb5bd5c292e38e948ad9ea8f7e5cbabc4b3e479593ac98e34d86cf906a2018603b2cd6a44d04e1d4df516727a7d770ea487b6e886ae006d70ac6dc6e3ae13e84501703f0d56e0d4660a926c63c2b70450820cc1d2bbac355a5ab4582ae6b8f7d2daf1dc85d0f584bba6ca6f706c86897f6af05a3e996188ac7b7ae04e04158bfaaa3ac8db4748861e2d6fcbafdf2206da48c8cf0a6301ba1c9460d1a469f2c560713679356611ccf9fb943c06fafcd2a6507b12c7fe53c2f66fef07a70ead1e9c64e25c63dd8e22ccd3dc1e7b26cf79af5cbde798bb93dc9b5b2bd0019763d96b88421d9c8406d5a09ae57df9029845bbc5f0f90874316b4e6e09df6a31808f08f5454fd75a78cf0e3dbe70fa267749be93e39cb0c84c983bbfcdcfdc4f7d504d7fcb95e218d94a13bc04512847b30ad23015838186637b93e49305b785b1bcb772cf02dcc3a57f4bbb24faf1e2b8fec2f8db85687f9491d7f7e4e45f4cb2f042fa6978b8179dce0fbfb49a44e7ebf93c4363444071608c447cc32cf939380d684130d1d656fb56cb1c7eb29edbd19f7aab5c681d4ecba180e8c6cb0cf4d044e6b118aad06cda1fd872b62f5f4da3ca6ed994a4c2198dcfaef15c3d88b3eb9822118e6a1527e32e18ef28837ed4d629d8fd1c22ebd6d8e7ac97a14f6e68ed914394128b033611d3a660bdaee2e576cdadcd9d110b66c3c1bbd212c8f68ed86f97a0dc3102d47c483597c3266d9386d3963143b6f7afa60cbadc5852dc138f767ac6e52d5c28c9c6bcc896f4fcea7a783676bb8897d0a31181268479535b0ff88fa6bcc673f2f3defbe50007b71376dac7cce6fdb3635abeb3c916b3f976ad15cc4182be793d0ba9df2e428b6af125225b5eefa3af77e9fef7742b19a38482d553cd991577bd94a2cf444ac37f7fc577911998875e588cde8572b4e15bae1168562d17025e1fc77f1070ff413f73b37fb6c606418184958b58d8a4989a2d70d79c16790fcc789d9f06636fd204b853e7f0a24f4fbc48f218c2da88b785abd3b984a8c939937f670a3e3103512981253f814a00f8502fa9c7e52c70ad74df2c974c9b694a4f4841fc7e7877aabce5fc6a0cdc25dc85bdf51de02893c79016071aea8907113b56ccda66df3447e067753c24b54a0b0812d42f7991d2f2f009eb27e441bc45933b9c967a21ffb8996753246600a7ceb3a12a28f1b9d411e54f3f9fcd7af158c775757555393362725b549e756b850e0076b709476b4b562d9a2fa1e3144dcec7be0f2cdf4bfbe9bfa6cd1b8d259192ec896f4c5f4a8a8edf76ced6650fd6a214b119d4700911a33ee8a46b3d1d6da2a882d4fc535ad682208041ee6a1db20929a41469e097bd6802a8e81688f1d2fb69f049d3fb0a8dfa19d69a45ce76a046de440d97c37f7916dc935b30efb32fe6b32194ae02b66392a1698dd60cc27cd1e8ff5d5aef8f88a3e88bcb1117fd12f49aa069a7f634fd9865baad08272966d185eac9e363404d8758a8f2765a0a781c11dc651ff6b2f452df6ab4101e46218e1f3cdeb1007a8fd469179421aa377165787ae19bea045f1cd79cab9202f4b3cf5539512e8b7b03fe0ff83e2a6a3069ce7398ae0281deb0a916ce186e59a01514bdc03ffb0e1bb900f26cfbfb1d2c3c815b07b0ede3c105dcb8c6e3f2ef109b603f44578a54f4b34c7f5bb18215573e612cb2b39c71d3d9b7bb3522cb846cec9e42b5b1e660871767a59aedca6621a6f1d020d08457494e24de355860252e54057c55e88a2eb990bd2d57210a6a1d00803513f5f9bce2ce486f689dd4968cf12a6f822a518fb50c023a716a6c51a9cd14f1e8fe09952d8d865a56289e46dbb4a702906749ba3e3a237c4186a8b7a7d53f8589006bd25019c07e10eaf9df0d2ed023f4cc5a09933e44274d166a16f13f825374ba362b5670caa6e66f00e825a158aef50c33c5bae1a16cb4392456f2d0d1a174c12498824e6d70c1fba4cae4875ccd2ffd52c7d6b2e35e5da30a8da45bee7cbacf7194649cf80ad2e31b02ccf0171dc7da095b343bb165bbe3275aef8f94a0b86cbc439da494303e7123ffc49ca89f85d0934acc504464a23d3eef766d86c685c3b55f2e9234db0524134d0b4a250585587dfd1709ce0f52b882e8d5dabe79c58a268e378ebe02e98abd70d4e1c1eb8f5defeda99d11334ac7bf33d968e05669692f6ff890f0890d6ba64c755d88f43da0117535460a33913fe482fa099764a613504e040f5c53e00c0bec0a39fa3d0863b5304f7a326ab6ababdf78453a6c2babd8b434ff1caa1377e4f1e1b582a10c2c6dc20ef102f6fea958e28bbc762f47152e5a1b02f65b6ac1a1d7654d52167a9e7aa755607b0688620516997bce64df388a7dca542c7cef77497049bfcc2ae387571b858402b519de0913ec8d8de86f920515f2a994512f2c32cf4da413648d57d5bc4d649905682c198f1b3ab38c3a39f1ed49a11c3e16be93471a08a3458e137e3d6c89f30a9c9184d748300570d55d890033a8da5d5c6fdb1e8398caa1643d2e1b73ec67589e77aba12c0bfa2e0c18861a7b8fb9d6cb376ac656daffedef8df50ff9b07230fe1fc44844130143849ac0ecbe0b4d715883e88ea3cdca79a75f93912c210d383c077cd32b3098e2379110e39054c1e4e60aab46de290afad3ef931db2464131455a720a9f4eea2c43c4364436b01a42ed62ddba608282d5ad9a2973c48af2b67aa2b9f3c12cdb8301262299e5ea5ee762badcfdaea5f8294b084b8059d23a6915516e3f3dfbecb9b877f8776fc501285afb70ee92b5725d0f91635626ffb0fad2326b02c05e07e22f9fbf911fc4e2add5019d8674929b879834cafbfb5a7054d8db0c0fc979ffa04d0566b1d4074bc88d98acad883fa1b68501cd00fd0c227fca349dec26c511ad853995e58f88fc4829381d472308e37273eeecd2588e75868a72fb47264f3f6915db13bf92e29dfc3c1e5fd07e7dafedcbd53bde42aa42bec84c366a7e7dfcb779cbdcd31411033250a2323993215f28fb26b49057d7aac79e0c06bcf07bb497baa862001343b301f3d01636bc1f5ff880d18642ab1ed3257f47aba0e7de2a327ebb6716951e81e05250053847bbc40ac4c85ffd0a8e6f99a04a1c026670bece39b357b8d0b742c773c838f906f1510197541ef5bedb2909b2bc5919c3b6c4a2c06844d794056694fd502679a4d4f12eaa68fe0c43b609e5f4bb3204592d46ea18599bf2637c833001a77ef228b0d186def9c0e2acf76020cfd847e03111e596cc291c904642dcbfec7f7e46033b66b5a9224ffdc77b46485f7bc5f7b16e1c6c4641403cfa67430552c5c4ff9e9399986427e2ab9e69d1457480353885a92377a62d814cebdea76f8a2bc94a3e0ab27f54e4d58e05e695b00fbef9583b1412e9e1cf25ac46d2e0ceb144bc4d0c3e86c410dda60f1d904fc5da4364fba2862199d36ba33da60d212c16ca50b56aca99d45221e1c823eb8eea6e1ca87e19b4e13df44573267d36003bfef5afccf101b909303cba411e42bc91127c04755f579f6e5e4d32d1c8f8a10bb945abd861caf8fd300fc77438251c88c242fa10152a918519c5dd1c8b8c3ee0bbd6dcf248b040145552bcbe8352e391d75cef1f285772098dfca6d75aa93f18015c05a5061e5d695da1d294e35d84948df36f5e41048043fa6be36dcc5948aeafdbf1f14d1ffb7e2fa2956ef44a46b0409c287308b6f5d66dda6e26845517b878069a0632c07e312a03a0b5db928fcdfe3d84eb65ef3353205ed169c304e94c1f483711110ee25a57dda44399e040a20a793bea6c120f300ac574937b83a1ac33e48356a50eb331e7e6590d4a1191a4f9938adb6a89ab342ea0056d54dfe2258543198950b2d3a08bc9b74c9c000b51de78349b4ae0339faff5dd43686f0895c9917cc3c6272cc2aa74586a3f0615dec93c0f0b611ab9f08b75b8004b2128bf566b2479b782867933904db84ced65e7727df3e14d94ab5e23239826704991685dc7fecf798f4675ddbc0d6576740f763755860a983647f91c2a552399e4850a7407628789f08f87e141fb3f763b2f3d600233402f5f0d42515c1d99c701ba90b39e20a682406b1a0134e39c21eef7f7de3b1b3a13b20f308a6bcef531342e7ef537d2274e154b973c04d61f90951f1c2019375253ee86dd9a880c467e099c2353900c78da127bff272bc5fd22a5cb36555fd9338a11e3e79c95a12cc8d3aa16f9b29610092be439b54887135cec1eab6b815b62954aa2950660225b6da77fe0558bd9bc9a8c31760b06bc18c276e9490938a2e43e96727d0124467e72bd2b853ee0e08e20e8213621d03c9e344a6b2878172567a8b465f64f865c64cd9087f99f3b7c94bf51334cebd871b42224e08d66ab37c3efbe32be40d99447649ce04066ea56173ed79895ce121be0940543a8d18409cb5b24e308e7a1c1efcc77b4a132b96484840113dbdeee8e11e570825671201bb92c0a2e304fd25f5ab42a5b152f1c6e87eea70fb2eca1c1f531e5b219b45341c02dc02fbd0dafff1268c565acdd544a7de1ddf16714793c79d40b67feae6d476bf0884c9ff3d5a6d88ed523e22a7c1d1b9c04f8429a865260c1b51e5a84e3b288ca59572dcbc68ea03fcb7bba09ed333d7993ff3c76ad985f42b8cbfa618a05b8b1b653d854e6115ff487d3ed4ed13fba75cd0c5713a82090330af09cbd6a0fdaf669896cdebe8ebff78ffa10bde5d00a5754a40dbb8e018c1c712c9be561a7e1b8e4e22c9b6590ffb5305e33f64602001922b0dbcd978656cf8a0b5a0d5bc273c298d4d0d2836d31a362ab5383cb5812f469f0cccddcd6a5f7e11b80a016a4faae30cda495819dc6f3347a43c885881b48c77f6320cdda0a9210bc926d08a85cff638f84966bc1b72f8e4333dadac60d87cf41f626e1447e22281d76a3e91bf9db4c9cfac4f9dc49c7b6e9f0a2bac2984dcf964b12959435515d5dc31f4bafd20efe029525b0ab35244bfb95bcc1417749a0ddd88d16404d6de3c70389b394dfc3d4c3e79e32c3bc816420e34dde36c85a4b658f2726837f2768653ac2d840ec97afb38970ef963af7fa540b155aa15633b672b32c8fe22060254e49318954b5c03f9099e8b5da539582c598a332ec3447365d8350d4d37a16eaf539b019b8258cd6201bca55185743aa3e3d49716d7073b940f692cc32f5218447ab04fa9db56087f834764aa22000cf861e84270cb078c7f8251b9c2ecdc28e235a629281cb81d7736593b44d3af57ee8ecb712af036da028e3d61ab5df8407c441bf0c17cedcad37c4fd3dfe1f05d0baceaef68c441b67b9e030d017fbfdfc09d9274db52371856c7951d6cbd08345e396377572f7c22bdfe8cb9dfd2cb3646d21bac0ef49f3fc59a950f0396dfe1aba9de664a3688a4a37b29dee724c1454063984056807b346baed1611372f2df2e5a4ec3e6fda66905e6db0544eb945a8bcc6a9421d7c85a5a620768d5c051d9990ea41171935fbc9235c1efab131a94d911ed7818f3af1b917360390e51bc1175d681393250b9e430c2c9c62df47b723b1d2b670487f69ccf2486ff520b7578cf89dcbe1624826c219fde7be1778e2afc31d835ccb4b2b3196eb649d0fce4e5247471bacba8a48609f078a6fabddc9a1b4969b48eb8d9c49e76f41aca8f728087a366fd15b9f40b1965bdc8038a9bba92b7d390a2c89eecbd979d10e0bc5d0001350ee5bfffd43043156680544a5d55b9661e0306d92026155f64e17892bf44e1ae34e6d70a880eac0d86ac7e78db57439d39de55077ffc2583b295c20d300dab2038d9c838104ab69939f6e429c7a1eddcc83c13af308ee24f608b5bc19e21ffd9e8b0bca611316398071ddd7256f5193f4447792fc781de198f0de13dbbc232a854435fb11a85e5b880813a75d3db300fbe99672353ea5dfca9a75a228662350e272d1d5788fef173df1e2a150888a03c73917f28b9c2b3775f3beea96ae6df5eae069850bb1d2925e710f6f5afb4740cb4d1bf639fcd9153071e4e8e4d0d4b672a28bb5412890b74f7543706b06b9fabb7ae9ba3e5ccf55d18ab080abef3b347390e22fd3c72dc98de88da0c9d2d67f109d77e6e32641c6b1fb52f6761f1b5686934774d18fc6f7d9b0b5e3e49e310b76041be3d222e7bb27caa6314dcd158d1d31b472acb3343321959e6d8534dc2c7c0b5cda5de50028c9da8de4a85b2eca7df5a72a70d6a9662740b5b97b6944d2c063e9a0a4949b3f4ef7110fcbf084d265a7a5fb5282ed7fe5fb53381eb8140779a1eb5e4bdf6a3b4935998dbe96b1770b88030f3c8be4cd8b00e667abd1a15ef5aaacda9aaa17da298993d745b5917c3508a996390dd2cd23efba85d4bd6da9dd01d135d25b7cebc073a16752495420b6052911736756c268aabce0dca682f94bfdcedafe03223b97ecc7a0c3727a9e4e1145766e1893e6d3453e51e2c09731ab1ba8779649c86a78cfaa956afc99f693f6ef8bc0f3ae7b98ff9f59a207150aaa2ad87fca9366d4edb5f80de2cc96eee473650b420355fddd1cacfe460d68509858d9dc931cf053947097727d16b57d4cfe0bc1a182dac45454793ccdb42fb83df5955c22b6a35656adde304a52fc7cb0c3020f21f4b6b7e8f39966095849adeb40f7c0077ffa8e423aadac4462c760d0c8a6eb11a2d021a926d4da428606d32a5532731316cc62041999a6d2481bea6006b3027ee28f89c6f268a768975def1fae00856363059fe82af89243d31dab8342efa78c7e0d6d50877ccbb1d1d2d413603b011c3b1947303e42b667fdc3fae5c34320880421e42380bb9a2eca85d75a3c30ec766145495452e9bd20f0e99be4c9daa8c4d141ad920420ccf979331597a66d3e2834448404442a9399a6298eed38a2a6ffa2bd9747312e0b058f64a6ce7b3b4129e735421d190912e5cc2df3031dd2215c767df77b6213ec00675489873ae7667a753627c4261c8cca90a88505f70143f7245d1c32297d35a69d304b5ddcac444e526ba43096ae1c77fdb34af21a49b79459bf7bb03d9fd5695633c0ce0e47200366d2f18cbed1e13dd2c774231b87067c3167d15112ec16eba118114c2f347963932479e6ec32a758665a73a1a7142cd3617eca6631e6e9d6ff10f5fa630e2d6c4c175a7443d2bece202b45677fd46fe90e2510fc62d88d46b4f33b7dc84695450fb03c0f75391fcbdec8cc2cf4cd1f3c8e750bef1edd3f6d33d8765a27141e210af3f1e287d85b89220c9cd2cfb3c5f5574384bc6b720fcb33f7ba5d78f9bb45c1bad2db07b930819b9d2f1a2ae34d1abf9e63fbe02e8b6a4a28d30cba91a4e9c6759fae1e50454759602a3e358c175a91cf63246458047f2ae6a4a7e6c384a1fdab7742d5df4bea984ad616371786e3ce80e22925f933ba9f414d334b73975b88109776a9b491185ecb4088fb1c4a6b08e2a5477c9f3adb5a4b6d586a5aa1e94f9474be2700826f78e3fe2c9eaf62de927778729860e911bfa21149af9270abb2ebbe32651f5fbe8da5a68395260c19f7078629781fbda6c12068ebf733dedd979f92c6a7604e2a8a8ef279af1cebcb4fad1b1d792ca1a3221a978c16b152bb2aa9d1834cb1c51d699e1031369f178e06902981890791d8b92fd85656efc558d1d85f163a165e14ec4d1db15bf9ec31180eb54b1811370a662b5e026972224f104717956fef908eba7585ea4dc11a2ef6256cd979504f3c5f1015d5edfc41021a1e9980a7e941328693cdd07332d9a340fc1d20b5813a8e3d594bfab1936818f488896ab83599ea0797b0d4625d160bf9f777b542a20037ae86131640a7cf056278dbe5256236a806d82927de3e26dfa50bfa513ab1cb24e2be1dab427a8e323b6d5abb52963f62799a592d86451c29f182309aed83f06b202d5e138f26772c1d7333f69fb83f46a666c9f36b4301a8cd8cee9ca53d6e8d9c40b1ff587ba15be87dc878db825423125588608b1c32aea0e618d2abd29835ec07f537208fb249170150b176c2fc24cac5457bb4e99bb3d5798a4fb375a74025087f5773daa870a5b663d55ad0667ca6aa5dd1ac4393e48e8d98b4200b995895a49136877310096a4f7b21730a8a4c5c08a29d61164fe8025440e5fd6a1b233c0fbead9f8e5fb280dc6e999561880f4dfb5ff53fd0dce9386acaa282560acddf68876696e7698210e2f436a1d5cc919be42ff492a4d644a8a9a960f87108bb1e561ce7ea4023b56f5656306211e80a3b2cf0b4a18b6131de7be56aae6f5fd11c6f30bfe462b5955bb4b713c50c6e7fe02aa1518477e23244d00cd5875ca2087707b0f9cdc34430c2e12d13bc99445081341e3fc5fb0f4371529a14095909613db68f003e58adfa57c4e76a4c2474861448228c233c182233037adb48aadd9f90f8d5f61fc8965b74001b40c802793c7138ff36e8ac580e92e95ef241483a96784e223a31ae8b17e1fef40f76be9d824fd87e8b5a4d325711c610411a90a4e640a0bac25d562755c2129581c04c3ee73d59babe305c51f30bb92c59d8e6cfaf7cf5de008f59b0036e2ab6beef3348b41143c236d67e17fdcc07afce86cdc61ad62cda1f3829dedfc2328e166da1cb48134100d52142f4862b7fad1b5989f34cb0209bb7106a5846f41b784044c7031178f4c9fc4c6a922fe1c076ed2dc6ef38cd0fea9b089f1ecf05abb6b9248fe31748f1ece65abe3bf3f2c8edc60540ce50ce617385912f2a7a87987876f44589880f965b81db4e87a2ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
