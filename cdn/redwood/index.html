<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd84658d90f7caaeb44b25953f89a95311e8e6d5d49072e5e829a80e616027e696949d490020411763fd53cbbb7e3914e18d3c83853dec839ce9e599c47f3deb3c2c5d4f9e585cdf720386c1b3916505942d49ca85663ed6cf3376112c4280b773db219e01ea14df04db45df5cdb4a2f6c199a5d301fc9e55f0f709c82488731139c0de8784e478a8a0bd972643d5bf574cfbdaace0f288004fe67286d148bd255dd4bc6605c8f1e9111adfd854bb9076176e447abd5304c3224cfeb97107546ec9906bec9bc1d7e931b02a55a75070dcf539b16453a496d3ca3d51cfc16a327db1f00b6e40da7150c1f3d197a1506ba295a8c3957b64361903c3bbfa4ca6561bd26f34573cc879c6c78b84d6ee71264f487f01cfc388c57f04971d77b58140f55d29458b7d3575ab6644e24cca19e88c6d6e86b3c06c7af753d9c7d7905b2c94ba3c68bafd77467c9fef856f87fd68ba18f060e73a8cd6f33cc096a948a3f9cec77f738f298b0139ffbe42dbbe385b3a32306792244093f3c77fead7ae7a3dee8c9c7f80287f0387dc25a3d69efac6234684f60562f2278ef1041855eeb419f82b1c363a597c72f7f17145104c3eca025c51f0826474489273a54774c2657eb4bc090f78fea4803b07b84ab313d73a872c14c6f9e3a443ac52e33b646e1544b2cc24c1df82acc9c60139d4ccc3701d4a87566d7f8ca4535aa61502808ba6821cfb4450f772df7a44bddc1a012e27fe6f8796f3bc95c98a72963d2f5b7353ad7cdc7ba9fd39f1255cbb0a52aa58d5ab1d6e406b57197a71217fd11049f9c16b64463e6247f0597eb0bd5723313cb0804909ba679f989bdb861e4c76e56761c8785643c915892f955979bacb084a9acfc13f16f2782a37a7884f5201db158f399a12253da8c027b9f3b7f01d13d1d9c2b0009089ee9305bccd8195f676da84ccd68a5b49850ed3bdc30fe9038687e980b6a730628d27c969a30e06baa933e1d5b6f671c8edacad7837a7edaac6a32c42bdeab77d09e325a066b845a5d0dad38522294918fea1a184ccc6010a1ed228d120dfc2968a638da6bf0c3c9039336371b5c4cc45ddf30226d6a550eec48700c42f61799d51d6d1e834aa47b0537cb06304d95b2a8812e4346a50941bc934e44249e13807c9c28e502d855c6cdde8cfef11b5fc9374ef9e695673fb0bae7a802b9cd5bb1c6b97feaf05e143ebb61806bee5bf22bd512a5a30bc4877b05101a03f6e7deee177595936f9420e28a0dd47f0c6c63f7e0198685d92744ae7ceac61f3077847e1dcefc473335b5f804785e46f0a34238d5d76292f8f77868012f5e43dae017636941046f91de9dd3f32a05146a4bdf08a7922af6fe16255a43f7a840aa2a27139cbce67599c663cf1ff5921d1eb621b5dc88d6fd520758023c76df70687fb408931ef1faec98c0bd39b586c363b30491081e8aedfe047a1dd4afbd4225953442fbaac1b1bcb0026821221e2170ef532e48de3fd80374a8837fbb9b51a44bcd67926ac282585823c2333bf5843b79674258d76953128c41e7f43b4c5005750514678068bcd4ad48f172b7074daa2a37f82d4d43b83ed021bdd5a2125ece2584180353a20ee083258bba4d2c9bc86c043a1bd4288511189e8e20c42fc6cd461185f4c1909ed8f3c1854b85f72fb46c9fd82ebebfd525eaef1de4618dd688def32f9bf415a167295d611e19d77006b622bda75476f3fc67fa3824e006a63cb79be59e11a61fa318f48200a8494b9ce36fbe9540b958e453565293760e1f0f799da3d7da71f626ca05e130c210053aa182ce5e05c06da2a5c976d47eb3d70582e961bd96bff1817a43af5be22ee80dcb5551d76d4eceaef8f701bf330e386d8a92021b6ac6a8cac87f7bee7546065ce002627691ae5425f6210a8d48324dde4c56c3f4e9f42694cdeb179c546925c34797b2b6c642738434cc3ca07b866228a5997d27c2883c04c65b25786d62843c5d627d663079ac5d168a566efe20dce8c4e6b842e44f4d1301ef91c88304b2228280ea60c266bca841fe7756edc38954721d7af96b5bdf4d681e0a6fb790757dfe1a325f32de86b81a6bcee6f471a4857f9c24436825431b6cc3db9f39401cf2da6189e14acb362c400fedca3721dce288e08015f2c815edb84904c0ffff0b07e3a36ab55dc0d0a7a7ae67d150a58e2a22bd15288d8b1b10d3bab4048ed0e7afbbc297cf65608b498543eb95c8bb640f81ed286e656610a5c3e0f1000f144dfb1e4b087cd3f238cbd598daaa2b2c68ee0c7081f3f62d43c83ca47354e0b4f0741a86152505c17e037c5370535babe37efae53ae77dd4ff25166aa10c486c539ddd26620e118e06a8ef41514bf627945e7259c850e2d3f27c8ca28e42765619f7dd6e5068125f1e918a55125cef2fa47dc2772df7ca7b3086a91da12f02f515f3994482f9daf18f94d562ae28a4fbc3d68f2e5b20c5982dc5184f32871e64c77c81ad49b2d6bd7a84cb3c6cfc7c123014622a8e1a9422eeeb758a249562efc806a881dee5dab06e7b9ee31585cb9e2fde84a41755c2c0bf88b1673c7d3725ceccccbce906e0aabf3863f042e401f380a5fc7431a893b0cb05b94dbbd14726edd920bad2a654da76b02c0515493d2622c4fb6968e0021f2efb3164c3921f4c940bbc6ee285d4a5a676e6212d24f615caed3c4a95ac733e20fe3b25db6f0a16c987f9130c3bf1bb993b50f23652040c39beb5b20ef1a11b633f92c7108e8b57056722c93d2f5fa3ccb00b6d6c84f042ede40e2a93c0ea04e1b5ad8f0ac5955a94c9824936207778a60d348814658af983406cbc165092fa6b8ca32e6a30440244ac265ed0ae4497457737c42a5ef64d11cc23b9fcf7143278a279f97342050a4bd92529a5a1bae0ae12b30eee3081df7e64868a34523a7935b7670c69edbccb9a51532888346a6a988c46cda35298e6333be64c77c9358cd75047d405d33fe0d94977019222dd6d262d7737f2f09f022a6b7d8bcc837bf19ababe74d801d0233f0e3c3776a9f3e9ee95b6f57d498f400eaf3109b7ddc4eb5455cd75e29cddbb76a52e42e053412caeae61261ac7f9edb9df1e116b05b8b1c4417c38e78cf8b528eed321db7e0c0f3037d849703950f3e0a98c7eadcde9fd6b49c5bc77b26120a46157b58a973e8075223df535f0d1021c3190c2f8efcc7ac1f3a0107aab6a02781887239d8e65a2281c79309092d76abc2d128c7f518041e01ea0e5c8ef6b8755f0b9429e458cbcfb5ddc0c8987057a9b94220240ff6afefb5e0e1fa5ed024bad6421d3847e568fcf4059c57aac52d941d5137c2dc825904d60d457cc1d859c2559520b69cf0673b33a27e16aeaa85c30de583f14eb751f14f75b5bf6c301c5f8075da92e1b2096145551ee578ce36a8e6aefcbc15aa3a816c5ca63584e7ccc78c3f801748c4aa361cb4c59239ecb3b837417f1ec68700136e0b43c09e01e37d31d9da31f7090706946572a6eacbb54b448d5dae76558946d646a5ca4bdd9ac82942b017fcb2d1f4f8b8164608a6e6430c6a56880ba4d046d07daec31bb8b8e70feac9a29e04baa7cb61ceac05b93eae13b0ec1dba78e525c942710acfdb2073651183129ce96426b27af87964b70525cc041649488a158314b19aa40c6c9753a4d8f83b798c645193c629a5502af919ba76cfd82570e4a4851741bbe4f78377858c6ba3e5e31524a00dc683411363ed587813c8f610176f94f7ab008b77d867b4c92ceb841ba282ba38453aa72db4b6175093c6bd456fdf43fb4ab35883a82c9563629150bff9d930ebc5b3af017d7b0a027c66985f4db71d2467205c808f861aeea1ad5d1970d50840420791e862ead1b1bcd5b5e75de1b87640c181214a689e398ef792979af4e432f6ae583f7d3a236cc8a21a358813db04a6c0b0413f637d7f592557d2248ac072608fd06ab60b01d44118eae47aee1deb6ff5f820bb3e3ab0b0da79b5727a53253e2cdd7e8c136f326665cd59019ede1272d8d3b7a1df9cd7c5113f3b2d7037d7014fde7e96d900e2c5dec0f76253ff59e5ae2df449ead9b70fc40d9513d76891f1966775733b280389005c520f75f952c54c420837f594577469fe88199399c68ef40d2e0f0846348599f7201f31ac21eef2be9837fca6124369500e001934947e30fcf03fea9e2bbb54d14c3bc198b3eb357b29f85617a6bcfef39f7e8d868e3d16ab807ea7bddc64591b577c7aa457a1da91e4cfa7cc346a6915fecea0a37255ee650274a271c6f3c27fe30bc987c4ea311cdaf1ae967c96286d97f0931f8042e67f86f7d086955f3d22d81da5ba12ad6f4b1fc5ed8df01d4edcd120d898342136a25729323331ee233fe077dce195c8126f0968b622aecab8ccde03ddd28a63ab6d9ce0d9b2813cdd0f00852fe9cc821cc81f219f5c7d99cbda88737e8aaf8a2ecc8907a08c2bb352fc57a76a3fd74dc2a2de10799a2974f77037226b682b1003c1d86d3a2f77e470e5ae929f26e13dc6421ccc576fb766f1ab800da607949e68a42fe9fed8250581d5bf8176e0879e7af0452f6016f4ad58eba3d00bc800b85a08320d837ac8591e08c79c77282183b23ac2982781dc2a4cde06cc17677c641bf42fdef83a8574f95d8349def637706e0e06a3fd0d30a99aa468e2474f3cdb350d1b54bc54371758f05845380eebf2842e57fc7e67b94712be34c04da68ab7d2219959eec3f45db924986715065c66904c7011363cfba7a8749172744d098926b08d48f18905a03a445d56036e95019d89f823c010981ef86a04424a8741d375481a89e9e8a650ad50271b2dd1230dda2919ae3c9db1cf797952f16d14ffb791f207fb88c9491d146bb8d0240cf8f3c837ba1dda9e580493bc0c48c14dd4c84eeca7aedca0ca076d4771744980e008e5fdad50ab106f4f65f536a1618729c39c1bf4e31a6aa56af8fb83c1839de949e4f7481217902ff3619ab0a5bd04158ce01cda8722b02e5c7b3b4889322fc55a362d2f41c17633c9bfe3a080c5b6ef98bf9be20008e651d7ea5c6448981579aae2d9e0483c76ce8db625fd00f0e1d8902d0b0fbbef1d36dd5a0fb233b192962978418fc0ccd30fa0110a7dd345192ad2b258c02165382c73b4635db6d4a0b0665c7caddb52f1fca9d502888fb8dc8fd4a6f21207a48d1e8e372adbfc1e6a28e5aa40c04719b02285dc3a8516335083ea194380e6fd4d372121203cd31056d99a857125d79df25fecbc8b861a72d38b9d9bab676b196d950fbdab340aa27982a6aaf13aea118e630896d0e9054a15d2e690a75bf32ad8938abfdac8b5103e43fd8436e56cb8077709545666de6035e674c3b23b75adf054d2d94c05842fcd9c1c4d1e7df039fce43b1faaa4f4e1c0962d38749512ca028ea95c89eceb628da17abd92d4b94273954d864dc3adc4f7847d9e39ce5332e740d268c66fecd674729861c46208fc5b392d07699107bef9300a7378375e1be8cc14a92d09d14441ba8803c99370a3e525fa07f6da1fbaa98db72ef2b5bd31e6791bd9c53ed749d3fdb27173c7e36507951f8ecea9123e480b52525ee42ff44cdccd4a08099b475af2135f07bc0b3706976d5f180f44f78e41e1822a998e7a3512d191b68720164838581ea2432ca28106ef09d2d86c74d4b8c19d291db9e8451b25ff63215ffd85ccb7f297194de5ace6d665a965a1b2f04becc9ef38393c4c05e103101698b47ed184f8d998771ff6f582c334c6ef80a4cf56bc0f7716a25f14c6c4e6f3ffddf786bfd2b79d8d40239a036d4fc7276978def214a1cbbff7bb79e4655a674a9c0ef1f86f7020ab2df9cdefe58b7f84a261d2bd067a757abcb814ce5a454bb39e1008924cf47b6df97a6467cd514431b75dd733cfbfc9c7ac541a5ea6ce92fc514dd270039b5db8a31280001a7394592422da5033989a965c7480d81c4c42aa91c892328dfb0c9a9426980c19c2fa8013dd2c594c616a0e627ec011e5e2e9e75ef8e5c55ce325b21e76a0b48aaeba18b93ec942205b7c14ccaf7c819620fec5e599202cd71696a2f4c3d5560a67a899980ea5ca854346f58c81def045a1444813f0e9600fbc1b710c780a562f2b6a3da7bdbd7d5300428f8b3eaf81bd75d93526200de8d24c3afa6a4916de552c25a6b76100adde62cd2b8ff24e04160363c713a91e08c6a147acb3d90ac56116f447c48f893864ee619574fd86326b1db859a653eca5ff328fc9641e0b525daa9009ff67eb3a071c54ccf6a4db2800b00eb044d2557dc899125259f5545ed418a6441b7ebfddee851ba1c3f69e24cffbf0606bc5178b80c7773afefd3ccd582a98e1136cf8b4ecf1fd6b32e40670086164769680d5b78de0f589710a711f538c63f70187458393553b6f82176848275e55b8b63f024ce31cd4400e3e36237081bc39d9caff00133e917fea817390a1365bd89d1b7052dda8c988cc3da90168844a347b446d034a8040e47cb0d37881f0135246b68ef87b3cad7c6915a665a4cd82637c6411bb5ac1a50341bf6b60f1e56ddfba54fd9d0b7e17216059a3c9ae47d7336087b27ad1b11bf0d93c0b130017d7e9d7209495d688a9df1c17ecb37ae73c4c8e62164296b97e699ba36bf3325205b7b2669a826fe61261bb2f9787b7cbdb03b02ff446dcecae6a791905225d9b8470c2eb61c4fdd66e9445075c036967eab9500ff24938c0dddbb4eab0ed58e9befb035f6a9797a3a43b1bdc60345bc6f4b7c8cd1c9aa8b5ccb74700dc231780d18bb7b217a80324f1d5e627d3f5eb97f563e6550f63c0e72ec2b9426782ecf01c3b989f5c89d05091dc433d9d121ff8d2c8bc5011d34591a66b374922a7f0d401eff7885cfa75dee53b3c53cdf6ed3ffc519e7f5118c179f033ba81ae689bbb1c1622c8c903d6a0458512d3c4d1ffe61db2a7df2a51df1595ee252a35173c75d387a32c0677dc2765db2f2ad5ab6a72261ee78c4c1e51d3cda803f9176ef08f62a545c2fde5735bb9832324ac3685ba828356ca1c1fc86ec81d1cf564bb63007d7d0cd65077fabec4d2020836330cdd51ba9f99c8ab583034d15d8641292818297cf637c32a1c6753c8dac79fd5bd2ad823cca367e3408ff8c737028971a942f31829b28cd14e7cbc93da3bb1e9aef4805ce0e4bbf108ce80bba7e843c66b83c07d6b4db873052c510dfdbb4325401b53ec02daf042f4eb75cf2fdbb4f235636a95c58263b1410bde84fa7c2ac4f455678ec0ddcfdd65523b165e43eab643309b7cca321e20dd42b7765e2bff58d148705d854f5fe17c85b65c63660b481aec397bc440a6fada5ccacb292625574c7522ae645502e93c77f33e382b9d0463888b4ff8a5f0b13c225fa8b67f7a71636d9b12b456cb60a2b92d19b23bedefcb699f11d8ed6e9c1d1207c952580a00c1a6c385177400aef03c79aca0e8e14c4198dcd0495f26ed617abe0a5863f56e1130fa18068ae256c00b84f3edec0ed1ad2d16020955560e8492449a88d99f21bdb18a711cbeb43b84a7dc8f166dac6f54993e768d3dd8b59e11d7c978896062878e8b71f1b8aa3a6cc5d60f4200178c1df9549529069d8526f05231f68c60bd2c8ed5ac17eaa698f39a89b92bce25e82afee43dd5a2868281af1919ca7002b11acc576d135cd3a41525f324b350094742edd0f92b28a094466cff6c4bb818b2c3f344a6843e10bfb3b8688c6ede6c3d3ba256101de086be8fa3025b8598b81282348da357df1ff6800e4d2059b233e415039f076146443d7ec3105d2114e549a8de90cf45cb06b02ff7d987ebfe5ad29f6fa79ea2aba8c82811d02abe8daeca0d8a4cc05ad3c3294270d2bb119694b578edbe0debfeb581c6c0ce8f66085cd0ca636b498e9c83e55367147f2f46d4c4e2ce8a0542caf5677b390ec9823b779965b38e391c1f0d9a11d76622d7a284bedd58c66ac296026e895e424b69dc2893c9fb59ea1fdc1257f474677e353274cb71da6522ed98a6c8ccecf8a7777ca3da494eb064263e6a06607ef56bef035af3413c0fff2d746daa4525978426b58238fd416cce96e6f66ceef3da62febe8319795403fa3fa51840b26b262e005af0a587368f957548413ded9aa2280bae7be43f1a4d8eb13bbac54176945bf1f629f9b6934da31fdc5d30683daae76b3eadc12cb5b214976773352d82d5f98e023c0215fb17251ac1b0ac50ad9aa2837111add54b587f16f4e50befb13794213da8d2ee96fbc5310f11d6509504602ba702367c7ed1fad4bf347588534c8b1efc3c926248cc2512ee9a19fe94c8fa4ba9fb83463cbd5360574b20dfe3012b919559d0a1e3578f4254d8505dfd90a0a3d8540ad27c2148cd330875f09dc7c7ed1bee2e50d3de914df952a539b09ea681389daafcaec24dd02de85fd1ac6e0466b7ea072a860947a32416581ff3d10a21cfe5b924868e6ee7a6a23ae14bb63ba43da929ab6090448eca0d29ad0c38ded10be44759133e05414e4b712b51c4f744c01584cc5ffa63a0a408928ce4f7c012a8b47fc1e77bb309a4109669f22f56f830e9df5c9dd42821a21810dc60527e0e5a828feb1b9f0c62f66fed7ee5eab35b938e5c4fa7966850db72a1c450e8629c546fd82017be63567fd5a0bdbe7685d7929c236aa9ceb2bd1f040853e59650e67633c001164ceb901570a5f7d7c6b6eeab638369ca777e8bcdec479ee1f85365e3ed37d4d4d9a729c53e49bd40ee83b4c3325b829cf48c00794a0102ff6df6e6ab074ee9bf9c231f4fb8db13d11b5c60a9272d24eb1b4781187a182b3ca601f745fa37929d84d517a779b83ae5c3d476ca18177a0417342833d19844dc8aab9add0267f6effc4782a5a9d2276c595ab7cb8a7c2f3c5c511a5d21444f2b33ca14a005da0da119eef3e9cb02f8a259479e04609f5bb1c049f50e63a8d52131df1322d1a593247c766cb1a7d2a4407f799c3e08d771273bca5a5727f1de414612cf321eb5634fd913efe56d5847e5bad303280d06a977fe623a5f09bdd3a11a2a2d949dbb90aaecef67a9fca77cc0808f7b66b1533c65df9ed9e2172c5104e6b2d0fcd1452a15f14e992a4fdc9d8dd41657c4df2eb18d1b47fe848178d8d31b40ff2ae881cbf2ff81c827ac7348b3f330a643d7f6fae67d3e6aff0766517eb21e7773e30178cd33ca69efc0b25229c6a0c2ce1efab038406756aa31b59af202a7c9fab866aa2e78107ead6d2a973ab6684f04172562d810b8234e70d6d67644fcb90e9fa23236366c2b15afc1a900c88e1c8127990746e7bf819ec09f81a6e8fbc0da533441645625a4f8e02f1e422f0b97922f6724bc5a8c13cdb8ea43154e2c6277680c4485ba7381a491d48f87bbac36f1d53a40100fa5a444cd79e62d319f92b9147dc7c43067853ccd6e053de3cd1569657665b13ee4acdb7d0092e57eb84f8b885983289237e458e9955763385771f64528d5a58023038ce1010a1ba10b52b3699c638359f175b9227d5b4751161a571d836fd73e64d52ee731da3c9a917b557e1c952979683b31ab1daa841073c141cf22a18e0ad89aa73de7982c5ea5db92baea167fafb83c4028e42e549fd5aa3cc8e1f993284b5fa145d8a389d720395022e7f3ae2d210e58ee90d3c211afc69189c75e71cd6f27d6b383acc634d193ae73e5bf303bcee012e411f24e751364e96e544fe0c5f625a98641d9b10a7c5112670ddd08bcc8bc4d3e1b33fb934eebe901f509262ed36ae51a1456bfa2c7fa0986fc2ac10ee95d6d777991294d9c34a09bf9572796421c4a9886bdee6f4ae1e5893892674329f92925273e22877745b49945477b262384eee260491865a7abc7850f08caf5897fc98edea0bb58bf53dc0840c3947e5dd237c79303fff3cdca85741741f3278c90d94a9f67231ae8b78c8c1c6eed4cd0a98dc6308585795c946c87fd34c7e69d63d7252fb5934e83f3cfe0d5922614a91a553570a58b75087ba402d2bf5f00ebb0f3195c0a5b1a2029fc80fe11dc23924bb113b17c8479bf4b9115d67f7f5932079ea355a21abee1ca6559f92c86611b962fd1a2d3b8bf702dc223f24141dee0b3538ae6d3a70ede76387c0e2c557560feed0333f1e9ba1ed73b0647374b4a69078c42e427c297d341eaf23743bdcd5f63fd6366665bb4f804c3ce546d39a133bb406fba444320228856a38d17896af0232e99e9daf38506bb6ee275d99a06e3dbbd3bca57f9cb5a7a373c0cea2fb4d65290f85cdaeb29777119dd245a5cc325c67c7f4e55511ad26bb85dd0c76d8e69f14c9e5c1cf1e9cadb4bcb9e29170522c9a166956dc94b2e92e1b1eb0a70cff21852eac155313c0be01e2ac20b23f65662af2e3386b333d36de53b569b5b975462cc7774aa9545bdbec54c860dc11109ef2fab3b9700c28115313f79db4a9907ae52908a96de945b56c24cdc3d267fe5cbc1ed92fada1ae0d2dd7b55bbb325eac2869b87e402bf80a9c1888445c17174a7138a53f50cf272340721024c4c9fe1905478198081f8ec7ed09ef5a3cecf79a2e6cebb1f087a6bfd33f444f51c5a8714a3eabcf469fc231d3b458884c9754a8160161b60479a6b4e75429a862cbbc29b0acc20adcfa544e147ac9a27bcc88a62d5aa91d67b47579f3c819cb9a96a068a916a7496f72cc9d8dd9e073db4132e5643f2b902fa503436692b824aa039003fbd4e1dc19524b70ba312ef30de130a7ae6351aaec38d721b516626464363844841d234dc7b13b5c1fad92b180515291582ec4720160def18ff50eadebd7e575554f2222eda358a0bea16e5abe1e7e879c1eb49efd1a59a157a5b7c6f024d90a25787cbe4543d2d6ed1fac21563143985d497ac4967010d6a17a63e87d899025f0ebf42d546f151cd7faafec6723e1620594ab65f726b6e0f530acf7496ef4ebb6fa5487559865e9324aeb6aa6ec6728893dc49b6cde475af3b7f021a66d4d699839d1f988bbe439b005f5c17df6e1cf703b1e7f7cd529b94ae10d0b58d9e9bb4591961c4e0492fbb5f7cd3a0c55efee0301bc56ec5a4d3507bd853f639d5b1475048102515c3d2b3f3a49c41cfced5daa56232d494c86514d88cd2be49868489568022e27819c1804d2649d20b6cd18ae407e57cc906e0892654ec55d474ce9d380baf02859a38515724e87a7723ab1cf3be28ab6ed0f435ec3deb2c0c0e70a030841208d51698eafe3387169e545d377e646a6bc19017569959ad0398e79b754ab21b5adf7790f8c0acf2392854f41b093cdc64d66a30d43cfe05665fb985361ddf5eea1b3d48d4e5792300d12cb8399cd4c8d258c9def9d442e2b4b13e3de5234e896cde146a95f5fa50be65a40466a332a291df8984168a1ec65f409a298ecdb2c7893b3541eb580583c127c53397a3f6b41901be3ea2d4562427b0947fbf65a01cf5dee32be0bf8cbf5c50ea93083a1457bf4245235f729ea7d2c1423698e533a81173950ead250e1bcfa87846c5cbb21eb4d68a78e4cf99b36e126e9db2662a0929a58cf1b55d1fb9c0cb2880eeb728261cd39ef8d73e868971e30e3be527e4ca53a65e7f4cb29a96a0eca7887efd5980d25919a56beaa475f2a8be58bbbdf1e8963034d43ff18aefd5aa408011e3dd045e72c7a5b3e0aeda310ede148e908714008a0e771c52f4dab1435a005cbfb39e95a61646db46306c33ab05dcd1a2b26f92a7ba595d812f9f63fb3e28c64eb465f8bb9e95aad39d71e5c7bc2ca63e63e45275b8efe61a58360dbb1f39dad0b598528d1e608c419238ca4362029664b6b4f5b861172a15fd30a1c90c68b5937a9ddc9c6087aa5414f1a3a44b617dc34280178f9b06565621f5eb126eeb9492a44f4594f85b33a07f6ffa8d9861745af9afa6e4a464d474a30c0f757bdf86ddfee2fce18d0d003dbe594c910ad1d5ecdac5bbf9eb5d2e47ace2020bf5c1fb28115e615303e5b1862ccb4d5993c65cf16aa9534ac56997fb5c124596d5742dbef0275e43e10a2c30efdd3d273354215dfef693b36a5fd9d51acbca676ab6c3350f6978526abe443edfafb217ceeb3f09b3379de7f45235a2a8e19464577bd94b4d3d6613c0bfcef92d6d9d3b1203f48a4ec8901c5c4098f7a2384405e7882fa8ca1ce40e4afdabe64bf46dc10d1eb7b33a51d854148b5d0473bcb04b28d0a7a8f15312aa52e1bb587ad1bce47f823da990b8de19317f05419e5916e4e3cdd452e802c1afaf9f5dab8ae3b63e9a2befa75269caee31780943db836b20bb5e715a6da4f50f8332ae20ee8b7d81de60d7a80e3d3a2c91d5da6b3764faaad983379c4f81a84d9b86b6eefb70d4081b0004c93ddf3c7f1e1f96654221deccd33e6f04ece59877dceba26509920e8743092e098f70e32f0941f19930a815c7981e32a4d717a662e1ae294d57b6489b20f3dab2c057bc8c254c8886f44c0ed8aae344c14ab8d09e3353238d59ea456a8252e3126670aa053ca21169f620b8e3529863a4a8540b0987e9302585490cf6797aa939fba4936a196c633778e643d544468775b5e4453e551dc967b68fe2fa31d0877ae67d1dd4606704c66fb360484cac941fa1aa7c2d23354fd7e83a03e027edabeb922731af781668a782b8f5cd561404e49cd45db874fa3580b878b3136a61fc2204b04adad96b2f3feb4441d341bfd8afa747ed87203b7f32daf87140ae92cdcaea2e787bc2a09e30046f90864836018b615793e70bff68e6f86d0808f779cb8ad2ccaf9a1fabce723bfdfc6e6edefcfe1c56d67cd97ef9999675ba4030f9e4e1e9394fdb6ca20826e007e27dda752655e2fa03450b82120b0c48fca486054ea37b2b9c7e8854fa0f5390702da60a9b0a4042fbd1a34bcebd8bc90d41e30302ec60a3789d7abbdc8409c2afcbc99fad19fb853e5326f0f35cb67a15d3e8606a35f32dd39764f50bc544030cc47f6032ebca0329b782803770bd20b35962a59ba05f0794840d9f00f21f6f2163c452e34e8a855b3bae044b09b1089ab107d6f31f75fbaf570f6e03b5f5f12be95872408e3e0187a2ddc3286290065a5fb8339d6f1122f0f279e966d702a40f2a93155ea8b282e6eb87f3145cdf16e4e1eb18103cb83dbde70bbea77edb6dba09c58e4ca187864d38d53de106dc17718bf25e0f3eb4db75cf32171dbb2c87d428834afee53db99b168b5c7642f68eaa5b0d31b64f470f55829eef78a2e20a4d644768338058d0fe0e839557424efc87b881e5bf8cf4512fff4274048e297a315c2307b4c9da86a39a7798b81a1518d27c6e645065acf4a6c5acd82346392bfd923d474e1803f1df963351a506a00e3cc0b5dd30a73019ef2c9e2545d7f9d9064dba85a7338c85b04ced66fdae5e3ad0b84f88dcf165e88c88de24182898b5871854c61b513d65b3f49345b250d451c2ebb5dc3a52fd77c5f22708c5d4da5cfc2b3c3c2b1462c5817a23de03f78deff6e08838cc8672f70a523594d1372766e7c0868b875638d0c8df0462ef164e347898ce08a392788c77d6cf94957e1c397238a015a15d45eabdd5d72e45d4a424397946fb0522560f315e28551a4671714c0114f80b2ef5753692ccd0b817721b6598513fcba6593709d21df488764e37b5dc77699ec31eee63d96f3c3d4d4225446671f93cfc1d435572de54e3830b7b5e0abfd0667dc332db88bf91fd4f976cc422699cbf932e640c355894abffa451872199de025e32489c67e0362b6e83f4c346537ff686d33ffbc6e376f10e5a8c2a5203859e30bc420330589bede348d303f6535c223ff41fd04b9381aaf067874a590afa1302849b70f2cc172c484388f1ed3e589db810b166ae911ef358e3cddc2d0758f156a85e1d585ecce475e941d0cf321fb54ac0e73b65df0d363293ae3221755aec30c6c941c34c2a51b8c83553ed6c308128f9f9cb8d6b2f93c5556d2bfca0ee22c028dcf71d4ba83c3316d1a9bb0650b913e1b3fbe1eecd84e511688c3585770dc558fa6c9dc9393c30a5d116367ea4dcc3aed35de5c5590d51d47f92ab07e423ef01a1d8eb45be0827a2300aaf1e62bb864e48c82ef548d86d36fe83742c36037be07ae2230444c7b3c9963ad56b996722cf8c5e3606abfc07fb5ac7d508335384a8ab0405810dd0cf6c0ca2213bb9653f39f64490689e830e9c336c5880c26c6652efa1a1db40d78e3dd2966f3a544331387a9e5c76f62bb212f027f8bec5d1fcabaa567a38d5817311d0ea531b80f322200d62135630c28098c700a65aaa3e88a90bb5d8597ab365d6c1a7ed81ad2ca84f40afad982b1168672d79950cdad05ab658987b3469fa51e2d349fb90a0a7ef551756e211ded77b897a4bee5b1685ff3f7b4f3d20832eca1d7aca9c8862229ea93188e3f3fe5dde6ebcaa41628330ac19786c4bf0c4d4ee81f1f4379d2230b9bdc006459be2a33225e0151073996072f6ee84a61e70023481616d2f844dad252f9cce896a4b8701622e8156d56a0c103dde121188a57fc4df37dc7c6ed1f43ba07d098c128216c7c7d2585dc96758b7b12fa5d02f208122442541c7e4ce5befe1148e9ee1cc9d9b00fdbea50dde0e928145a4919740613cd11a507c1635cfc744bc646d7d3bbeda9141175b901f361757359a145b85b8f7cc901a65534be12c8143f083e0ea59943ae143b324888434954ec3bc1136ce356f13860ad8d39f77e36b20378bf151fbb112b1df9aba72cd6e6a61b58bbc3c4f25b01a46d5e2b8cc95026f1175a07114733bc50ff7caacab074ceb8f760e453d08fe55539c51625156c660edd095843930b1de12abb4003a8b92edac741d8237c7e24a4e495c60cd06b9a0ceb80f124540fcee0d5927d468ddc3202acb8a7805bc95a2a163277524c7f887aa4ef608b7bf1eec2ffff37b61f9b53b2fa204d1de805e49ffbad55d2a13a0d281e7ca7dd61c56a0a7f05e12c2101053b647b26b59a39bdf5c0002dff47f89e55a9a6feddf1bfa6a420ddd5fb1e50c0771c93e1c42e225307bad989f35ad88c5f703f9cdef781e9f2993430a02c3800399a5d85cdd86c7c8e027ea11f5caefce5ab195614b243dc15b2f00f5fdcc9de1614666ec49fc780d80b15fa170f0551fd6175d1f64d924e1780b9f6fb9e05cc917223f139256b3ea6f5d01d89db7b3322232e90c662ce3b6d048e0d3662619289ee651080300d72df0c30dcca1ff1bbac488f6221dedbb74fd5817f039f25ba7404af85e8de20d78233db689785ef97b0ee6831d4d07d31bfd95d846fee8c95bd2ddb9c69dc5b4181e301c5e665ac932a028878daeb6ea381d0eaad7c83838e6cd8a86a78d5e063ff514bb54be674faa2188dbe55f01ee2237958e58c6b90aa61b8749da4dd3835cbfeefaf2bc62fcd872f4b651e9a57d66e9dc3851c7a0d3b660d8eeaffbb9a7ddd46ede3a737d4b3313712932a153fd80e23ffec30d130f1984a1e2a531ffa9bd25a037689de346d7b704bcf24baaf40f5b6ff23101666340e305072e11bf9b7f6d79f3a7e3cb3e061a55b401920f1720aeb033c8a49f3699e05152973fe7b93e01741a08eb07b08707d089ecc997dcb2788457376804aac942acdea81affbf3793cbfb6d586054010f0055f8294e29c6a65c90b4f28d51df2f4e761d1a056dd33d374c5676e77ad86ccbf53ccaa2d0c776d3c749cefe92e58c35a2494f5f1ff221def0142114bec66bf8a7f5a80041abb50b070a75b845f7f5d5b2518ee7ee4009fab4bbc00c50a0c75f0e36bb7b9af59a49f4044e9a9d738f70df358bc4d453b94bed8da3657fffddf384f10c85ceef86dccdf6fe17b356a32d3c729d97704ff51f150976ca3a639917dff53132ae213e8d225ad3ef507a56f4372487138591514634e6cdd87112f0bde4303b2a0ae2f0a02ae19896c9e28e6450d0a27c3385e1cda184381517c25b3a403927d60a5ea18539b68e3f0d11c9240e91ec7e26d2cbe061c95aa40cc15b62bcda5dfa0be14694fb828cc17452ef0bbbf5debdb65e3eaf51ebac92d56e062472bbf9781836a6e8ad4e1c879e409d0fc2142dc10c61091c62b40a34ed9a75568929e12ace65372e3ae78eacd16b6e89474565089174484593659f4ce69c7b887f00d739a59979320bb16320785cc95d184d743fee4fcb6dedfb4b922f982dce270bc433f5022e22f9006f1544a4173727ac30b469c89840b87d24bb977ff0a81c495f988198ca5ae547e633c1a0d252ebeaecb88612f2343c9bdf0b6b020d3c68ab02677600709f9dd646de3ff22bc952650aebb4d260182aed8e0df6bed4e61c2605ffa201aaa804021a29d27b8f7c545cfb1070b6d6e466632c4f7abcebd3b18eae8665babcf40e88b9bcd2d180190e7ba3c91195288e093dd4db953e61d99f4c3465f7d6f86fec29e3bc377fa43fdb58732f6e16e9731be07a6189353211d8eb7fc89959585d47a3e0a7e983856487dd46561ec747117454ffebef9abc21537e83b69eab41544eafd648fc89bb22c358b6417f69643b2d5ef8d4c46a59bba7a84034565e375fa15c612dc8cd4c145be058afca28075bb431439fccb8d7f15993fb5662b92cf40833f14689eb9933f6430d9d7efcb10d3e1d590e93a55e6f68a661418b85a78ff49b6954f50f740ef339742b9be0bd0fde2d6adbca04b90783d12b5ae00a7b3797b8fd0cb3e2fa19acca9c3cf7f595e73ea6a5ea95a27bf19a31388aa16565d8e8a06b720a00cd7d15938a71ef11cfcf73065bc77ee580cdcfc425e63e6ef2b18d35c2ede9908ee452f14a1ad535426dde2e94507297e9b7242da0ebcc34ca5f5c15d86ce804ce6e5fae4079b89525a19f3f4d9e4507bd01413994f677e6724c1627e139a58db95c8d85816d9709a14f6cd19bb43e499f6e39c86672e8eff878f31aed1dae6b3c127e463d0c013171574c47febc8e7c5d47323767b107a2d04cb5760e73938fcce580a33e966eb249be73a54920d7d03c461038abc5ec3b3b31c41fd65973941538340b0a3063e06744561f3d0897416283778baa799657ca18b56b8f42cbd8ad28ff115f58d3ac481ccc364039ada2ed64a361eb574f13798fd1e01d1eb1c8d2b6437f7e950c6bca75bd347273420f9a298a06b610e54b61b4ad16a15a9988ef2e0512d692910e75ba9f8865babde250529193eded441ec46417ffb51a202d3da493f02c06f49296ffbf20b81475c10ed749b589c7cfd860b6a99c85ef026ad2b2be72f92d83de019479fe18440171999ffca54af3484f9ce9404227dcb67f18f80219e4f8c79c7cdda539595dfc81989f0873ed4374847e5684140ff93e848045f295bf9ee203b4e532898d97d86e63a5cc5d6f369fc0a940ebbe8a415de580433b0ba941d342db41700c353805d589860b4f65c2416fad61cff151d603ce0aaf79626f4c9652a771cc96b539ba26f35bb43d725b172819a8511b0924681b95228fe5e26f26eef07fb7d6452aef0a1a204fe78eb16189b1a4f4753791c41ae231ed3bb0816e4f6de0ccffb18e7a02217df76c1df604ad314fe1b4206016dac3f5535c91218fe416f1cb6680fbe0d2eb1a74455a39757c3ec228275f8b55afde219188225d125a9f2abfc2f9687529761da8d0d2c6c8fd6c0e8eaf832584eac221da74d3c5b2f1ee4f164b3fbf2ea213048c943ea10d8341a14c612a9dec30ae7c305fa596adbe6fded7ee8c8e0a043b335a8de6d7ccda81a433a3c1846ff74f7f0835b13bc6eb2d10c607eae7db1e779bf23ba421db56994e142283cdb279ca2c6344a7e45c9462cd3542e9840bdcb46887eb873d0d33262c655723c191df3470e5d6cc3f1f30e45a49ab509160efab29d2d9c30713024de7f1e520957fd0d78fd5bd36ff91ac63637da586e8d336daa10b03c0c989e790f1311b7548d8477b0812207f297d82d803f09eae387e42f896bc866263ba550ceba428645b56ea5fa1ab89d80ec818b93a6a91b779dabc74223dbfa6513c1554ffb2d5b30da93b7d37693d6431d2abbc9a1aefe7c5be7d782c26beb1ac6b1dc6269ab9ea02d5f5025f7efd1ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
