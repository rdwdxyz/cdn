<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13219bcf1319fc7f09a293bc06595e573474642bc43e5528f212017597c1c6f7aa1be5a83838856804268e05810c6a157a31d290524d4a6ab1434c1ca692b273af677b615e48237314a4dbf9644235dd198c5b9f4ba5f84d2066a21214d73c7bacb5bc98f0d65e372eebeeca9c38d0c43873441c7a730b521dc74681ec23e7904a642f638df5ff80b441d4ae289177a4f246b987d24a3f5c422afd03d0eb1b5d8015cc3624bf1517a212f9afa5c5d723382933c8523b9508eb380bf2007080f3c44717fbd34834aee449c2751abc8c5b9b3cb30bdaadf77fc75998fc8eaab9c93fd25b5fa1823e501177a450dce73651f7358702704bd597267e874cad76fd51b223861eb66d941512d95be0efc9dbfe31e17e5b8216b3dde422b630eb230bec3d4c6ef2a2e930af13f2a107cde2bd9103bb145b337bb998fc075707f221a13483befa316d514d10893bf2f8a357ca1eb744901bbd9e3a89393cf71c9049453622a1a35f7cb93230b3a00515535b1d9280f51f28de10718f98d3b599ca9988e5f0bf31b2edd71a6594aa4765df63188d27c5edbf4e6b035447ed128c4e5792f0ff2c4273742a799aa564969ec6b482a687d30701250571d0b90d9f529a2db251979e32454c50ba9c1310af7f1a4172730368912875499a898b4b76fbdc84f57602d1d787ff68444da52e836e2b7ea18d0e3163b4b08167f5a200a6d9e526b19ebcb646f878f2ee9d159193a0f63f76eb30c045c6fc7cb7f1375227d36b116f7178c2096ed58ed20345db9b70572d95df6335522bdc238fd880049d0c495d9a42633e1b9032cd680d746ce894e3030aa68828aa12210f112ef01ea76a29b9198790b265324c6a470f8ddcf370cef5fd609ede77422284492edc1e3a59ad246e9ce9ee41650876ca4e425d0c7a68033dcddf9d687c010e13feb8b546d29d16b033553865ed3130d450e7316dfadb4505906dd1cfe77d77defe2c6b87947babe87d8f569a80a2de1039a62fbc449afc8e4aa3d41decfe9f9696a5f8b21a663e7d0784ab74ef647be0c6c0631477bdde7ae3efb8bc688987e77ac17b7de255f98fbb75656cd999064b9fb89419e25439b851ed3ee6f2d00c7b6e81e20c7d0bf894e112e1a63732908a7fcb20aa18cebc72bfb82f43d22402ca4c5c6b7b5c417b8ed67da0c4e1e8b885eb8dbb4797e5c5e08c91288c8e9bd058e2ac7d0d56972d28f9ecea21d667dfed594208280daa24eb988f98d6321b67b50671210cdbed67ad8818c239d961d3681e5be10ae4a4e9e6bf9630194bd75771bf6e010416eb51fe718dcd48ff798c2d33892a8994f4f8c360f24d1e8415d784534003cd935505ba19e1bc2bd95eb49986f645357fff3f14d5542a72f88d43ef32efcc86963036108532e602c4320fc4e745cddf8b34a0786efb5bd0f9385b8e3575de82489059dc5afa46552cc4f15c7f370ba4dbe4af68db56e0de644bde71327179be0eb35db060c3565c459f3a8adc543623faab31cdd1e9bf5caea7636d8043c6f714a240ea95587ddda0ad9104be4db47fa624fdb90a45df60d641cb4058b2127af01bfd412565aaafc07cc399bee7785fd4d7621245dd6b65cead1008886efe4ca6db12c636b7c48748c17190cffdf5d711c09e79472e2a9c3f32167a811651756def2ae7cfa8af449d918a64cd05692164de29ad787a3c06492c8ed7b0994979b8ad7f7e95c40f5526ac9bf144cc44947b6afecfef6b14daeaee434ea7e8d3ddc922a162c4d2aea18cd842f007db4e51046057d572e900f037e2a8b85192d147032aa33ab97ab915c3d556058cd43b5cd1729c8c347a1246f6be348d16593810aa5b5ca57b6af1fc6b345a96ca42892132c27dc080b4fef9a995a1f7b44ebc4051dc848b75c7a88822887e0d0963756d2d0dce675889eaf7f74454214f95dde0ec01c6463efbc2da6e3e889fd87c473e31ae1e0bff88ec41a007dcd94bd8d076bdabcfe3090e380420e5bab9f4a79aabce79511fa8b3ad5248a50b90a99d17923b8fb82b22eddd096cda216ee8cd7839d45bce9e942907b04320a368d6022eba11f65b0bac497992ee0dae19ff4e8c8341072b6aa24cfafa55b682f28b90094ee8b789c6885dcb5ef39109b12acd969e66ecdc7b39410033c7e3caa3f01d49d53738734711600ff547bffcaed9e95b5eecf6162c0a8286d1c0e9d851b6d0db4a2231e1a9359e8c36de12b1409054d740e95909122ef7b4de0335359151b358410f55a5754352dcd19b10889b2a31ac3eb5c022687002d283f64b0e48f941cc05eb704f0d37d19e84c2d913bf46bbe379287d4ce0f941cd2a9120742d4f7f0eaa2735cc24d26973ec61e34fda869dd9dc65de06f458fb1b6592360a44b0909017ff5518f489763a112bb180547b432396bd194b8800e7c05814b52c3736d70e7173cacf8de65f580b7d06357e69350e94b110936e446dad816e659ecacff9d5c6c562623a60f49f4ed30e3b6caf2f94fb70cc15d8ddc6fcedba1c094e6b393b0d8b17386514793e28cf69d28b04e01478cb1faf52af300c4bcab6b0978147c4c576bb4e0a25cc0651b4579cceeb9439f4b364d9fc7ccd229ddab5faf7d7cfce4c069732deac86ad09bb3320423df28158f2833b265a3c17c6bb34a5502aa6e9813c711898077a50100949deff4eb6612888e803290710adcdada5ce830b123e3d4443c4b4453bf116fbb5d1e7c208930384330be02895a72f7b0c58323e2e80f4337c8c7ac8f7a433e9243be950e8f169a368083b8b46795c6695b69ebc5aea091a77303e91e2eaa90ea0a5eafb1b8665382aaa268d64392bd2ac29311d9ca337803413123988808d49e2a6a4f1486081aa7df76305d33f171888a96e1f9ee5f7c04315130bb9827394033b68060eaaf1867fa68c664dd6fbcf22f1c74c4158ead42fcb74c63d1f5f233a2cb5328691d73edeca5b4f19268e834b6ba43feef6a29429c1642c3d290770c4d3c8c58fec1b066299b1eb216981cb293db000081f252c8c87f7a78e3ef0d37c4ad6867418a14805252e1356298a133b4746cf647d7404043e063761cb12013822f155eb012f4842e6b3ff61564945c920453dab4db2a5ffd12e4a826ca901c0894b973e55067cc746841b5d4e7087cb775ad2b0dec2d90f9b79503cd93413a8749ab48556270f3b8804f1cee619971936e9acab06f3bb53ac9e4b54e6be52dabaad60c5347995ed98ad2e157d257c39fbb6f06a884486e900ad1512eae62bc53577c40011d3ecda53b961857230d52ef6b094a89c376d109fcced5b842ec46006617dc218863aaa390a2beb79e88e9c901254a70a2e32f62a17dab55f9db6eba29b46be0825bc3bbea06a11558a361d39ac4bd01833757c5c163310b074105a6f9914e73dcb00d51efac33c4c96e0311f0594521485d49bf56ae07fcb5d27d7bceb6c4187801d6078a15361d8a17ed6d41a216594a161c1bcb48abb87dc97a350390203c4fbe371848d9c92745968ed61cc2c121ddd5021f68606f394b8efae6758f644aae1a6884f6fea96ba1b215ca0cbcf893778ab2bd15c7e3de13adc68d19b19a7765d8fd008f3f4a145fd2b7e95affcdd101472ff97390987da308847e2a968b39531af4f2b5e508da6ebf454c63acccd96af57142d34909b3e565c9958695a6303899bf1d4b7bb127e2e0456d0a3a478569db6f7414d971c66b5b62543e799d28d335dd959159b7146e8598255bbbf34a719515c1436a4f1e0e724d9166f5965224520ae838f9042ebd30318625c4b271658dd2cd89b75e02e4c5c0c8f4e1e53610397872346082ec05cc63c50bb1dee296fa4e42cc34fdec5ff276a108a38ed17574dda798f495b564ba84b3cc78d4bda02ef18cb6902d6a4196aaf6c2c53129f0c803926510098b0d1ce81b326a1fd43e05f48ca78fef9cc877fb570a87346bf296ebbee69202e4cef460280ba34bf036ee4667ad8a615adb26a3b1a6e7b0aa2c83405db03573515ceeceaf76d4a278997c478a6ef8b13964450a2972003596e049c9b9bbf64b4b92e637efae9f2d2d33e651426df2bad3c5ba7eeea510a37b944ebed05382557caf5d8aa9b87d55a240614e1dffade7d10e8651672732164af03e76c72975fb4fefd3062b2428c04ebf669ae5ec41ecd680f167491f79a4e5cd7f640a256942142a5066ef388aeaf3f4add4db161c9b70c0c3b9616fec83ad122b55614d3f44ce40df9df39629294d06bdf0575eb35e63db875cd4459f4aeaace42a18cb0799920c412e84cb673f24c0ede03de0c57d7cecbca90de99cf959f3311afaa1d129c97981ceb148e0570b4823c0819855ce0d9315ca1f4fbaaa8598012ed678ec522e3e3edbe0f1eee7d6217a28d38697fc6dba9112d3bd8414d61dbe88cafdc627898f16bb146a1c8197d9bbf2fd7970e2c7418d5d625c45d6de6aef13f294dbabb4e340a6da3c30f6faed6edf4caaf6d11b4c32b52d9220ab18a30c095f9ca713f0937f3a5d280c39343b828c5a145957629e6d032d07bd71c5de956f38fb469002a8a1a20e384e1d2af52e60668d157b000f562c5262f06ac85a7d341c10db874e4da5c2fed81fa1af3f80116b3ff723136c705ce696f464eb830b160b956844e6f092fe04697fc6cd9f828a7cc0dfe5507c66bbd184d6aab8a75ab3129431674a9916e5c097a263e70093b0843a9cf010832a1d0997936d2fa388b8ecb38d4aeb4ca53a1140f216ad050d2f2217112bc2962e141c01752861d4eaf20c48968fe54c4a6d930f16680a150e42860cb622e963c640be29cad0b6c4095d96a9e67b7cf00fff5e13c71a3f0bbb5dc60ac8153fb2abc6bf2aab424d2b0db04b6e09b896617731953e2937a2d83769d95b5448776e529fd0f223a79ef8bd7b4cfa0d32e2155d16bf39cc1b34e9a4cc3a36476b01112a138199dc1979fb0e5ff527da0c293f3302a39c17ed205261eff907db72a6bf31d31d7d4828a815e8e2f0732dcf9dfcb13dc3879d81dde57bb0e0a129b56aeae8167eb7a7f6f891d81f5ee16f1df528818be4d17051b75e85a09eaca56a5709f6eee46d29992c14c21800129cd1c5cf15c4dd7f539f2182a928a2b788464e19f71ebf831847c76a2b1bf4faa42568ba1bd5d205ac760ba3ef1d3087b988f757c05217103d54aa34c817422f0903c5c7345446de63d94dc18e4fa5ce4508f60d8a355d94b2d873003ced681b896aa7a287c25a124e733f730d809a503fe11583b8760069193c78259c4d42cfd016880587c155fc072f34b4fe1e6d18af07e950dd1d118fdb60cc27caa113719897557bfe83757ef74f5196c3aa3275d4c75928e08c60a733875c6523bba46af0c6ad78ab162a9cea49a575d276100afe50902c4b88df3b2a009105d3885f30c20f810c3661061ecfa155771337464ae8f2ed637bc7c7c3dc4d7febc2e91e586b11734702926a770f21207162747cf20e689730c402b927045ddd9cc046af7b37a38767002294389019903258809582fdba3960774deda7a74f9792b5f0c9495ea4c9338a503510bdb13f085fda9af48b64bdd6c52a6ec91f5c52a27424a2e83522cd24310b906ee4faf77003d958985d09368b32fa3ea3b55ff0f5a4f918d4729d88de6d6bdaecdd53d776c530b8defa47e62fee04d79c996fb801b50768673f315a95175c26391f3fbe277b59cc2566ef3cad9600d9d7f8f3b1eee9be8873967cd33afd2f76854b973f6090c5aabd862669774d510a4769439135159548b1ba416410691b823ffdd1fd30324fc54c2ee30e9e4307bd3379e39936b4b2da242efa7123e408ab025e33131d77b9ba8d3de8c91bc1660779e5e723ddaf4c1c8c4c4e50992eb2cfaa9f203ceaf993c2b6d12183a06a8a440e23df123cecfdf540296dd6e390ce04cfec11856a8dbc035497e181f203f0a5ce1ee8bd5f4feeddae67f7085994fed203d37ee2dcbc5ac26d03121dab595d744a057493095e92ed9384ebbeaa8e4ffca0d8b9057df8791ec3b5c394e9cab7b84f1fbca8826cdf940e1d3c8b220c422466aaf5c61ee006f16dd4d740b4f12b3186cc14efd12f87eada45c4bb4504d3926777eefe4de1007c8fff082cac8478d58b3bac64dd1fb5dfc1cc899bfe882347832be319dd12ed062185162d10d1ed75d7492d3fb0638b6923b5767d40a4ec4c540ba8cc0934e141c077977cb1a91a8b950c74c37e88fc8046352b385753a0a347a41737f3a3f183c9faac82aa8d6088ff23e3084463569bccb49dca486e32f7b7a73d041b7ea163c5291749180db0b38a2371f86c3c71e7094c5cc0a7b56d7098c258c9bfffd9e0850af878d28f1930d8800ea18ac9e08fb193f58b8ac91b997c2ca3fd6e3f1f13e0d278253d94030c37f3162b0c870812875d1e988c365f048c2c37a451f963cc817be0021d7cd0a99a1a1fabca4a13207dbd08ec348a0664af12d08d99c047f03589907e7fcbd5c55ae55fb274a1cb1affa0bbfce50614ac88a151a6b4162a145bac5c787b8b3f2a86a31824f6c8f428d659efb3e22e6025a5e777e1926c06ed63bfcf703ba869f13ac8acc673e67b4997a7a8559df2960286a3cfaa3cb90be87af48aa6239eac49844a13ecb9bd5cee72b4e51c507a1c1b7c7235b187af15c62fe6a55041768f7dc0f340e262f50da46c6309bc1b77cb44c307bf9383b25b35e19cf820fd77bdf5e618bab03dbcaa497f204e80ff205fa6afb79e7cea9fab999c1c62b7765befcbb739c6b15819ce8a0788417251264c3fbf6aad76387e645af5911c73d24d93fd728693ed8c2aa8caa302a4a7872699d7707284d7977228e110a9d6b741ac3c994e198b211f5bb17b6c94aa422f6b4a1ff34a0d208a914fd9d8a8b5ecbc3c3343399e0319f0405a0a978891a29a82f972d6fe979cc759bea63f8e01268d5ce91e9dbbe0a43fb4b087c26520b351d59bcc85005f1dbbd2e93c9dc54e58c2272e1e7a99cfbf4e238d52a07c378e0c17e58848d2c5773ff3b06a916e7ec44898ddab793c5da01e532ae9364d08ae700aa5b210cdfd683832194bedae8d6b52e768b7e9af09e029fdff043dafd266677c0c7ecf667e61e97875903867dbace0196f07bf8344df2d06cf3f9c1f65762b3c6df149e2c3f86626653d71cdca87d60601bf246ea6db6c4f541943f1afd0af9cec59413cf6fc3817e120cb481ed8efc90c870b8f00dfb6acd37011ecc4e6ce83845f24588d3b6aa28df0cc0477c3aa7c4d7b133187a8d3ac56fd6b04a446d10d30c93d58f4bbe6154b2ee041a09308d8ad5fa5771180b3188caad0397dc8a8e8c99003b199b8fa2d5ce7528491e064351a038ddb16cce90bcb7e784579fff946a9d17589ae89c2ff9f69c062b3cb5271ed3755004b15481dc6f9c421e2c8e3138b84d762e0be7d6bdcc293737326c361ebb76450c58628782808e62cac08f3c243d6904ccd0427887b4293a88158fb4d9c4ffc40b5813095c5d8c233cfa08f5fa909cd0e079b3a60141bfa81883e69f261896a854ac79463b90612553fabbd7bc526d470526bba36521e078f6376453a507e8733099469ddaa04d540d3d7cbc2984e4e9c8d39f474e4e4580ee599a9eae55a5a0a9775717901ce9ce1d2094b8b38c34016e37d457669a80d176d7d156436be35673faa439b46674cc2f66e8d421c74b8122c2d8b43d6e6ce41d1be880414592bbe191e4d8f898df7ffd60361ba5c0960937e025c98dd11b49863d738b034b5612a6cc455f369f673259f3e5b681ce43291890a234d73f3ff173cd1fb8ad5dd69c020aea5ca6a2c3f1dc6f0f5fffe8fcb4ccde83fa346cfd1f38cddc23f5bb934af21334133ad37537a2ea3dd6772672e70a5490070b53325aa1f67c9fc173699746324b8bd173ca5bcc50d7a4487de28e06c4dcb2b4144d68897b47c2f8e9053316c4a56e9875b802dc7ba813a40d6cffa9f7707788a84eadf361bd329349c47e5820cc78a262740baab46688f223ff6292f0570c46a7bad6b95ff242d84de6062d6c31069026fd163f4ac2aae273db69f7ff9ab9bfa2e9980edd5166bc9ff8c813486903c8a8c2a3c1a84f342e4a4d2dc97977bbb1872bfff9827ef7c8df7a49ac3ac5df8bc2d1ba35b0d6d69d705c1b3bb5304403dfbedbb9e4d442d8f8092b90af77868623c7c85b393d367cbd713aeed79a13378f794d6f05d707a345d4cdf5d48cf6eec648885eab8feed9ffa62b2d14133b8462caa734a5aa5133fde80435e11ab4839d034322a7f4386d18e07dc43e4cf731bd2b97ddc32d817dbdf595c3b689f5741eedbdb53729056e4022aa2bb3ab75ce4df687cca4bc7861d45e51543f9d575148b735256c10f62ac6b317dd78ba2acc51ff78b9ce42a1b47afbc70de77d4fc0b71437a650205b49700d4c0a13d784a9b695a0999f033afcbe5c16cb45ff7476005849508ebd0333cc10da265e3f9c36949dc113d4f9978fd2be086f7fcd555a1f70bc5933f175076b5eb04140c662797e99f28a60d9a6fde81155ecdb53ab7201013fef6cff72e4e2e8df30956859d84e9d8416daa084072f737c6839dbb8f379d26fe77a0cb03505f8c1549c33cd25c25ab3c3a821b911a2b4b755af44a9fad5912fbf891b48c74169b4d535bd748721ac2128f0daa65ba8bd201489b0ee4a9111bc949aefb27e690155c768861b38ae16f9bad29d319849c1470b6efdc3c44bc9ea5d58b9bd38ed6b04ee4c7ea21a8883885394d38827a916d7827a86ed71e1e25405352f702a2c28f56bf6897c88a3a1e806cd959da8e439cd76a06b17ff7c5164a3ac01ef6adea4df0a6da266c1c199ddff50b9830679c94fcd114575f2029b4d4be3a0d2524a64e4b39dcc7b4339b34390b63a4b6fcc81eddeb84d861f9bc7458de2a9210b5b4710760020b2a043647ad03b9c052e06a2b1124dacea1911c5c8a4c2e64317b69d6c64f2e3d24de293cf6e3e2986937a78182171f88c49143705b2cc40816f9ee634597e67868b39264f5afc2d5b3f5dcbdcaaa027fa53f113af488b827c26854b3f5c2cbaab6430136a58e4fe9f5ff3efddbc435f1e7c2342cbc14db467484063c7c6fa05668b4aed2e31caebb74a1707afdcf539b3e452ef7c25e212e3dc82c18875e875e550fe35e1b167794c1d574908e541f59a1491018a6ef93f962d9dc6b373a38b73cb62efa3e069b797ce7e3bd8389c1d13593ffaa2569987d38dcfc6ec4ed043b62dda3c0a1e22bd378ce1f7ffe6348f438d434321a7a5d12f059727e8f97a0acb0081676f5a9c1429dbb3f108e0b6f3a44f7906d1558cdc77357d65602664a269be3fd5fd85cdbea11fce30f826e1cd4d122b64d62b6d16159d1ffe1cf3a18db8721e8df661af262e6e6ff91baaf404199418f63ad409eed827fa7f0b6fa8cfb194b747457a39d5e1211efb137dc3a4eca2cc3f08ec1b85afcbbb6e963cb95eb36a3c99bf016562f3d1786c9349dbf9e635cb6492290b43c2d583bf944ffdada7045acafff675af25d6f60f8330197b42332b46b6000a6d55cc2b8399c6c744f1e69ecb621b15041cd9b832eeae133af13efcd1cf090661d41309224d8b889a550d2225407165b0f52ab60f9d027f5292e59cdecd1463b0d6632490ac2c96495a0d7586eee1f7b42128cc82a853fcb226c6dcc0ac09d84858e0324ddbeb6922e67b6fff66dcc7ea9baf41f593613d59ffb192b387c04f7e5c7420a01eeb8d3b52072fc8452e8e7dafe769021782cd38d1108ecc16cce8a80c9990f5dba9bd93e68943e5b83652ee9e01c003c625bacac0df297049dd9a05d838bdc7d9b5d936a070405ede1ca66bd8745642c33d341d97ff036e137dda440c65efe38180f15b53a4ada6ca75355203624d4103a56e373da261d977b2a0170ca9fcbc5a5f794d896a79632d57698b4606d098c957f658965a0a66b1c96a44264bafd20fcdd7732222f6f111a968e0a26b3ebc4bac4b55068735a1d6427556ee0d37bc51249f99f42bfd2b6c19fbb36893615a52c2b304f8535a7cf108414e1a22c2554a23e0ab6d1063b93aed4f350c14e80766350af6c691c6bccd02d831286da0729dea7a1cdf16c8f964c35b4c7189935d91c2b5b080c115058257d1435fe3ab5c4da954857f5f05c9e6dc8b62b0657d54defce25b8f651f361e68f5aca349c9a98bbd0482fe70f5f6497bf5e5b3528cc8e19ae1e81cf5886f8ac270953bd7e6afa7906f18d6a8f1f6d4e1548dc05d10b764e0637fd67a09a8c225f74baf9bd5ce9479f37fad27f84bfc27c9ec5eb5ef4f17260b6e2a6d03ca917f82df8ce2e0e50092daf26505444cb7138c281d6c7ece345251347ac86dc461df4bcac273056517164dd065da2db34d8dc52a653d96e51cf1ef016e2c13110ba207c9db26ce707b543c154016800dc59f2d88270fd93ecfaf175b6683ef902dc0275183fe59d2fb4014fab3e71df64fa0e85c2d953e64bb97383d525d580fb9445f2a6cd671eeb3ee1ec68477b1f26be1026ee6645c658622f795a656b130280c5edfde8c075a5e07e6e27c281f3990661284ff0803364f58fd69ad1f20f20b067bac2b780905de49cf97f98ededd2ce26b1267844c77f2f2e727a2c67340a9b542b09d56f72266b4af0dde84ec6fd69392afbae96c984f22c9d55c1141bc811b8173d04eec9876d6f5994bf7f6dcb195866e44c8acb3c4773c8036ef81fb5cc297768f4683410bbd5be5a6de3a7022e67fbbf0717414870dfb3d5aaaaa60604bbc2919f13a468250153997c2c16aadd838dfbfe68bce1301ca3e2f445aca1148ccf56ac117a50197e7680fcacbce263d9bc12e8109739e40b3586d14223afbba5fd0bb087ab036169f398502617255eafd4e79673316908b218758c4fb9eb2f811cee75e3a7e76e3e06859235047952c8a911e02925c5add3d45d22f5b44a89ce496786e6704e797c58aaee295bd4ea9744b3d5767fae0da1a3d8b208d7f5d791e0c341e3d1f0c654838f143b538cc47ea3c0614c944a4474ae92405af1d1a69efd1b2eb2fab6731b09696c38055b90c281784a358f0877c212d94973d109451511cdf96b2df521e54c0dc2d1fd77c84e858dfe71847eff585121af9af93e5effad1ef4e29ab585c31b141a2204895c124b027b48290bc6d2327c102a240101e33237d83187944e0fca79e463e766a6ca374fe380bbeb5201722c6c223df4e1de8758172ae28aa35ca3ccb8c53c8f845dd1e37f3e8ff8529c889fc39ef62a3918e07642fe321b212e4ee65b354b8d0bd5da4e541a27c11b902fdbe6a086ad528922760217dfb1ba7d658a7b2cfed23b1849620649fa26df3fd72099bc3195034c0d3ae0b03f41e5c51d7c132ff5d72424cec50ebd2c35ce4c084f20a04fe9f5946666f9ccf7e91202f36579fd06c0b2b109ba6fe9476cae4c9c7d4ab940fd11203ca73e93ee8d59a19f8e52cd79f03a78bbef80d14dc118c3dfbf7ec31bbfba681a1a4969a26ec3d4745d837e4dec94b49c5f50bd59fd2882b20ce666ccaa37e149221638c9b054a77967532fe9e167fbae2a120bd81c91900195d1086862c0b6c928b3eb84e29281332a299ade3da248823e95a2e83db85ba359f16397c5ef369123d39b9e6a4de18d538cb3fb93c9b0f0af15c8445e2731eb400f58d9532ec5c354eefce2ad9c1bbc07eede8d1e3a4934cd2164ce71944b88fc601dcc05eace79fb2078347866d372e89e6b2bf56ee4deb9758e26115c82ac660972aeefa8e47ad0b4a40f57adce37204b822997f2a9ef556d5d264309c38e8415afdeb627724da4a9e3f0e0dadded294532b48e625fc6e6247a33c64dc14074337f855749d7737558dd2d10324c5cc2936e9d4a80487541c2a3c8009e0721af65f6eae995ff8e9e87800114876d109c87ae999d50ee7fe6780cea10466e8b25c5104b2a7ff19a0c4b330fd669634ce6e75572179fc9e49adb964595d9d0a6de7af4236b302c8fc7b2c7cebb49be9b91642113fde467222ed1df578e61dc5d62e36cddbd9b0852142419fea4e143bb020610cb9d332ed4622b1089c03518d4bac7e3d1b94624e776c86b833824a9e79a57197dd678616f3f29b0f339796c9bdf5f80ba513e17b28f17441fc9827fb02954e7a01eda30675ca787fca30219eaeb4989a76bd237cc3458b302e37c09b33e00e5842c4546679563c67e292d3752b559db9b127364c0e7030e50f472e168faef5cd362b12c89bf194839db60dd10eb75a9fad5645703e9728608103bfb09b34cb4903d9697bc5236eccfa0a54c53ae789d9f8fe7188d32cdc39056b8fcfb82a52956c951c4d02036d60cc5fde407a4209e9640e215ea021478247ce498d45f19a7b4fba85a8d7254551b9c8664341c91182dbaabcdfea3f3c21840a0eab12fd5ccba898f18d14420c29224245bcbf59141886e557ac20a7408223b5445f6a618d3f0b4f04fe58da06428a6d091b690a309a785ee75a9a9020164e9cb52c0b014d49d4f7cb09c375bb2fa313db6a5ae7e2bce4ca0ee2fb4db7fb956e58ffa30749885208b64e1e194d90009b9101d054849d6c5001c0f96880db9e6b256b466e9d449e0bb9e29be7e2b92d9d10ef9f8c6237ac72b9f1d7c17fc1274c1a46b358e1a5307dd1857227c905c410ee397c3954b34772fc60584065cbd2e5f7a33f01352109662c2208174068663d985432059f9294bec332ad78a7ba2f755a9e8df24ab2ab6d568665716a8aba06a336717be23572dfa79eac1eb543ffe835e8b67679726fee221b352c08972e5810daa05071765674de0210420d0465b1e7365f0a682aebdb558e601ccd4ea88f9098dcec909b3f9a9b88d71e3e1c94fd5b19caf338d8de80bdc7a23a03d1b61bec2d2dfa798d28ebdd68f03aa16e6f2b78d5e7b8d3e91480f8a00b7bd968c1f094f0dcf4d810ec108fb9e3d39bae7a46d962fbe616281fe079de228f37e9f4d8fe47c3306350a89ba448dc908d7fdc9b964e269530abd1f69a39e91c28bdf834acd3ca274ea2331cd7284732927c3cf58cef65fcb7b900e4a7e0c85d8c30285a8b3c9f98f02885b2e3e6df04223f00f42e2f59d5e5cc1e7c0daa750b8988f3d04f272c39ff7c63d539f6c4cec4d4d9a157bb97ef02dd243f5dbfdc508c93d5cf420246c781248fdee9c93041af4b68617259467044955ca586a4bde9417647322096f0988bb12bfcbc791e90f236ae5454eeab00e574a719925d50d4f4de937bad607a777788847ab6702fabcb03ebaaa05e7692373a809f4eabfdb77f13f0877acc0c6477666b73344c6559127037776442664e4ef76e3999005dad8214e03ccfd1d183672cf0f76ef04b4eb792251eb00d22bf60731323eaf953c58398b505d857b7f93b31c427dfed2c9e7f12dab795eeeb0c012f829144cf8e0f92ca80c14347552dc82ca326a22ac7f2ce36bb3d88fd781a5d026feed8703c440fad1e1f89059ad442dadbef43ebe58335d7fca78b5b152885e076edd7eb732c1f8024a25ccb78288c0be3323d9a180be59a5d1225b9520a61c71b7a476eede7fba348c07aac07e90bb3e957f5741a70f71f2de7c9af8e5e20feee99075240050b1b0f347dac8c0b239c556dec0483cd703bd7e87bd9ba4351e651abc9cc97ebd21e53cd8d24701167625ea368ef2d6286f33a26a5d7b5e0c18c70580e9f92b613d64a665dec8c925967659da0878859ba782b0be7082245308f94109c2f54fd339018bed160e5c3366a7cc611a2e35f30dfe3bbac43703baf63c02c5fd0b29e10a2e24821281743c205f9c24a1dad2f4fff74b7cc67cb2f9ecf98aa0ace407a47bc45bb9d8b4f4e34f21f349b953773d1d1fed38e5488d9d08c01c6298f42e6297dd0f5642afbf4212f9026e01e6f5c7ab09571ad45938002dd788a31e476696b2cea220e346bcac0774b93fe852707f886feb6d7eab4ec9af9739ce348cb08aee98da896b8b465b23d852479b3bdca20fa8bb5606479a1d01b5b3ce788c4148240c8f59cd1d5992223606905aa15ba787e47bbf0e5e09741080c9b5123210bca33d0e42a6bca71455546a049e62491e5aac570ebfa822ca76edb24497edce8517076d79a8c267b55c3921976442ebed7f07b352b61f55c90c63283e95a3cdc1a89c5837f97ed0c649446c05153a90b72a678cc83982c959fd89ee842d3aca78a4225948a686d5e3b092c9960bf544424e29ab9743bf09e43b7f053c1ea5001ec771caae3a2dc1fc29defd2e62bb5db14578cf39df3c2c95db96dc012390b68776daaf374f5514e3c4e11248e6d5ced4dc9f75c3563a2d80829ce37d81d7d26b38a73f8c54a76609a9e5b6afe97c8f47dc915fa1872bb053fe00b80dbf56892e03fdae0e3a6ebdf772d6bfa73842ed5368edd2cc1e996ad3bc58e993f5718e76459f2e2a5422ed4ac71e91c4d722d9afb53a3823b1fa8bc4a85a1daefe5c1b9f41cbb53aacec4a0a0d92481ae56adb45c4a66f9e3ffc1669a817736ee9dd5d72ce8687d9c0de01af074c7aa583b0104b6cff5458e7301e984d88dcafe029cfd81e5aaaec50a88e3e6cef7d512da8bc9fa5b80abd2e5409aefecda73c036fd7f07932f55ae6bfd3d4a1950a4590e8bc7b054f62c4a001a33602b3b06574f0ca914bf3c36037cdcc176e144afe6b894d97a5aee83b8d7024fcc5a10ef513939c6717d72d991792e859c3e483be670adeb7f2f0ea2d6ef4e3def46d81b1833af28feb04f572df5f081ca75669891461b588aacc1205fdf129d7a9179b114d27dfe21ad1366d0b27e6d43f33011bf41e70330b10fed71e4b59f99d7d4182d98c407dd9a46aa2bb7af3e821444770decd875c15384a78b37f300cf175a8ae2b43682752e76d0488aed9e3eade4bc573483f8ce9ff69fdced24186def1878cf98c250fab126e3a70a42ccbed965dd18722d5c3cbd019cf25e6db58b546e7d96a990e9518b6bf4f2e754ff9416879db28bda40626ea8ce1973ff47b8f58a4a335a36179e02592b236807276f78e2f727c853f4bbb856f5ad801bf7748a8f5468408b61062f5a0e111371057a4d3bf18991b25ff2b9f3f20c1f8c4cf44f072af3bc154f4d2f5fde47e6098ab52afb8e1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
