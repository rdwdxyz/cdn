<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15c5aadf4a1cd90de1cf70b39e81b3a9f1cb3b4df0b10c80280d4c84fa4ccfbc546fa69cd4949f916561fbd435ba90f8116a36b2dae0b6d626b7b3aab63ce4d316bd078b3ae808a1559dcef659fd48334c022723e61d3d3d89c12c4708881f7d8f71ea648c99376d9cf4334c6e4c38fc862c7edcd3921822a3592e43b8d70777079e0707d54fbfdb7d087a157305ee31e997c40f30f59d16c4180053e2bfbc7f16eec20a51dae652efdecc538662af6088466a7dda86b59e814f8766940f5b527743e46ae6aabe96a9d906e8ef1afd4f1f4be7597f6c64ec3a68159215d8a0b0cf57143b3df28acc287c1430970acfda14e7bc538434344989c199de5b1edc0e8ff0bb83ef7df9a3048d385fbb2a6f814ebb5fc6c213a0e187ababf2999db3b3c300a75e656b6b93e4a55f88b89fbf0f7eb5405c4dd50165a2b60f31cfc776a7c2d6d9124731dd914670f4d234e78b08eafe3f88e2efbfdb6c13682798a39b2c2f3f9304faaff1b94efbcc28af65be966fa06d9207ff384b93dea75f683f598fbada999ff7691bf45618756fd2f0076beca1f4e4ead46a1810ca1638babd040c2f792e808a5b816171498b92fa05c05e808a741a6a2a9dba669a086942ff650d32539a6f540c0c077a5e136a174c175bbaa061de3c08b85af1d6badc5aad4c5ece58d3b819987026771c0656265f01aa34f1ce70a921d9b8385e0df20ffb14297b50787eed27e53c8c866cc04aa51816933dda930d6c0f40a8db27e3c3339744cf161fddefae334192cba191ad24b7d9bc49b5139b2961b34f77dbfc2810abceecb28bfc42ef276619ad318b79d08ca5f0bcfa1611858ab5fc55eb85a1fa006a893d43cb8117bda12138fc998edbbbf9daecc9da39b2fa0a6cf044dfa97ef4d104430db6f60cd70f73dfb64a3f758ab8facd8bb9f8eb9b0df7c8ce375ca62f12736e812b301e2607d20ec3901e1e0601b3778a8cff49cbb75f2c6ae7b8011039a1fda5afc49336a6103e6aa955d60a7d55954e34b1f4457e161ac346d40faf69cfa91e25b059e5c7977b94c617381d260c0ed3adb6585217b12e77235b13a376fb8c3630336bd6781283e930f39e183f94282c4a4b9b99e55c1a2ca61fae5b7d77391d4b101625a65d6de3694a29585740cb48b58b1f5c80a169df68fbdbdb6a6623f635ed41ba788e7a91b46b0943e2b6218c6301a40d5f3fbc2b48245d02ee38716e81c1d359be481b3d16a2c183b4ffe46cd4a11fc1310a040b74e8075e66b0739e59cdee023b4ea2e840c24198805889410ba34ae379b252d10ed394489db4e7d16daec3294c3246e98c232a0fba553983da93055b2e6a643a45d1084fe75993d5654db857c5f348b4a282be87112f50b8e4a5eedad4dac6c356531bd3e15c0aa3139c7013ba869fc2d7062ccfc8e01d9c0b3769393608633095145257ec87af7a67bc3ab117caba28695f63addbbf98e66d58467cbae03f3af8a6fc9acc2c78fb7cfe23cff58011c457f916d30cb2488f3017a9088bbdb54baf0d4867af7d325989a2f56f8f454cc9e9b744a09cd5633c4738f600c7782656cc5e8904d71fece97d8bf9bffe532bd97d94e73256fd138fb8c253038af092a8a4db4b1863c131fa3ef3d10b18c123c515da2b89a2b02a35fbc2e6263e59672918c626ee218cd4d4aa81537af5019cd0d8677cd09fd5d0aece98f3f9a785647fc5f12c52491e3e96759f66e4209eeeab2801559300b13d5419d6723c2b62866a9f279b1713b845cdfb353057804e40e867763a71068db62726c071b641651404a5fc862afcfaf1a9610d9f7dc3caacf4e0c054f77f71d7ed6e5259d73d235dadb33067f5002aa2d0a5a6662e83005e289a48ca3ac131abc688c1c1e0ef07879bc181c43d106a2dc0b5cd8ea6588323557036729a6cd9066de62b39fedafd00c1fab82e3b320db48cbeb227f3ecf749b9fa6f403d7d41f1f772469ca923857d108467139fc970c8ccb6c45a45d6091e6644520d6cd793c153db1bd6609f4a2621e3acb2e1eed5db14f8c3dcff234c98b75257e606959951278c7bf0d93728c553bc70ddb8ac838b0e44dc23005e206f5e94e56cc31be44a6a2aac59cee9c7120b5ad0d7af6496cacfa837fb4056bcb94f8a172676b13d6cbc1d99e41b2222f0d9dae14eea5df66f19b00f97d8d8bc234c9782d8a022a0b27b8d5277b63841f3a180f5e49815d26984139f1780208d07ade536bb514acb249c504b263900f1db1b2b1f043d0f1087fd149e9315d7001b492fb690e0fd822d5ebe5e2b657ea7b24017640109c6721ff680b674f483688664419bea1df4871284762605645130a42d134779b95a36cf56b36f94404c950adaff53cce0dc6e4936b90a1c72ab894c98c2ae36065b944355bc83cb992c82daec008af38a36babd4c36db7170c4637f6fcfe8287dc50a40469acd7d15d3572070a9921533e428e61aa7165bb6f0899aea294d07590dc32e845cb9e336a3562b208a7a9cb8bea951da8f796d3d96fb574b49b526095a69d2d76fe6a3878fc266f78c5faf888676b082802b7936609bda13f36e90d9240c27b8891e54ac6548e922359d22b356a82fc5ca3a5100ff25311b2f20480bbc7477cc45ddd2500764ffda32ace11f4df8bd36b8833080a62288ec919e2e0a3beb46df44463d1dedfe564354d377ff600e46e765dfe54fef18c7a4025e8659ac4841aa51fb70c1e1059bc6ef0f7991104a17b5a1a2b421421d44705192e92711442ed4b8262666231eaecac6dd190b8a86b826f3d558025670f93d84075ff928a5ce9f8dca10e7abcef6a503289196fd2dd75aa193bcbee611a1e0c72360f56b4149ffde9b549b4feaaa6b1811a26343b3749d9c4c9769b0b85e289d7943d90358715123998d06a1cd664dca0423906382e628e93549a214472b8c487dbe85482dfdf74181f383f6de6aff14e4586527be0d64fa100f1bad6ceded2405810a0d6502ab28716a4d34d266e963cd416d855a6e682e4c304ac8d7cb6986e05cfbbaee9ebea65f04b5a08510ffe0ad079415582370d5cf1cd4ed2dd15d730b712e26d0afa2b2860e6d56dbd8a7bc81d8c29f225160098e32f6c4384a7249ea4b84e2ebb27d23c0e06282935f70559f1c3526868b66e500a7e0ca0b324ff8a4085e5a260ae2d7b1395e1483ddf2a3e3717afdf21f45946b2ffbb00c3c0967b7705f40f27bd22eae75e137c128c714636081aa97b6426e73ae8c42517c3b54c205c80420792d8eb0954e7a285b424cdc1c24c76c006cd1ff0ec092bbc89a83a8d04b05732e98cf9e388f28108caeab4b1e851f43337a6b81d34d4d783d700e9df792baae9b7697c8af3f0f9523af17aacb157233fb6b90d6be86febf1b9787f79575aadba8351f1584991b0a1b6da994eeba2bf9fc226e06895196f439d585df6fd4390ce9b7bf176ddbac055ed37a7652710dacd639c69cbd689be52397a91954d44923e043903dc733a4aabb5173df966bd41e1a64fb6d828a1e78bd2e7de18c883e9fbf64621182304cef21a0c572e4a90d7f215a97b6eadc26fe684cdbe6392e9f96e5607791491b84fc465b12f83456a36e3a47dad53b5ada43f81e2a0923fd1770c12a1b2db5ad4d18ecdc09fd7ab6785f26a7667b5fc16a8a03afea067f5e0901cdc35b6344676430af8b3d8303b841546af5b930d5544ec0d2bcd15e982c6c0b386d77ad85605d22d8f5eb03eebcb3866a50f0bc5eabcbe223bd3d3450d7668eb675892614cb4286197504636b2b48acc3ceb2e15f38e90b2814cb2ba42c4189f667784f16337ca46706f6eb87bb316d53792ca6cf7744d7ef0b27a39736fe2d5b5d7b40e1db60cfff3ad14db3fa7796099c167077947ea25cf867ac2216e178ca5fd7c51bdbe6b0692a51aab8efa898d94855a4bca3ef39d2252b35893286da6273a6f769a274cfd1a667c9a96464d8d90ee8eb77c52d9d3c0988e48e6201d6d344e3dc244e5d7af94a9442caad5290012e5ff219c8ca5be72541ce9aac81ad09e7cb7b02b45b9f1dcbb52dc073af920efb114cdd77c25d43e04539876b47f9b628f4fc9732acb79ba8b97bc2b39860ea4ae58c02804132c673c66bf4cc6c873b6e63f800f1b2d0f09c8c360858114c327579054908c330e563e31d5a648263a8736c19511dcfec36dee78cb5b8385345ad62adf5a3f46274d2c9a59f757a27d883b724ce8b486dbe9fa4d33d88fc130bd8ff938ad2b66b1fcf366d8116712734c1ff275827737a05674d8f6b36dd5f183a4ed85cd9c4bcb0d8bdc1e80a4a81979f0bf263b2ab27c6cea5104caed38fd718f356d046b106de3ede82a5463117b0eeae46597744b1721f4f9a90504967b6a7bc1c5cd90454bd683cef64fb8987274c5796adfa6ef65975854cfc618aab599419eb0c6577be5b06eae6b5b6a291909c0a369e50ced69d246d0f7cf3531ae4363b0e1447c78037bc50c50b3d2b93ac90061a4a1d6ecae99b09964b2eebbd9b5f8a048ba0ea2eb31baf14874a0c18a45b3139954d52a5410c9959b7948073d0ecf8cefa68ab167e5a0a78c8fe85f5c57c5a06f8ab6de0b1d7e4fe0bdcbea744923ad6350f2d77840d0a3d2fa8594f9551a18c0fa691f65c85805222cf81453544fd5a757651ef8b2f6db2497b5f1d1bfb91d3acfe90f2c91f46bac8e6ddbbc05ab2d0a40ba58126b9344d84dae95c5b0331dc3205cbc84aa2f96371abec518913cefc1d55c6e3b7342ee1f7a80321c91c5de804255b2bca57771c3dc32ed25b80a2843bb446dd69662bf0a472ad5434963c7ae6e2c51a68fdab1fb5cc69ac7d36136df7835620389f4d9597c9dab54438514df417af04a46c87f9292f73bb3e54a1d7240b8ffe3c1118ea8324746c2a865a72e582b5ed1eecc2e1cb4cc569e67d84ea535be1a3523ffd222b6e320e1ce662c168b7b957e9e8f5581b365768fd0de32cc3a81a237c8f938aaf53b6bbaafa4d5c425d3c6a05d2afdf6c647fdb4edc50c58036e0810ff9b671c93c729b455fc8245ec48ca4fabb66c477e5d66fcc030b3b4a08c7b6e35d601bf083afa261f1f18ad1ccc22a64448104dfb9dc9cea0c038787718b8192fcd0d406e0cd72f915d5eca84b435a6e5603288e45675c365aaf49b21e529a6c552d32b651084faa4eeab30e43007f41eb73fddf7043f253c197879a972f5b48d8b87443637b288f14167ca1311fee4555dbf130c040434ad53e452ea58c42263520eb9104abeae05a4765a85a6e424ad78bd55db883b1e8d0fbc39943641d81e15fa1e5a87c366d4c6c25c3c4c2902dcea2861dd21109c4929403fdca45564cc83616b188dd12da4898db264d826104f8215af9701f6f56aba854ac7c4a97c0f53ce4bb0b7f3a70c218b30b9696a9bc8a9bf14970f2d5a837e30368e2d084a81ece8dea261450c062373746810b653d782efbbf3be2db1089d38a18d1382b1e69f6022b207e7affbf615c2047b8b5c06a5636b0af119e6ad64c2eeabe225b7bdbd55f227a244a25aaae3137178b030bfb16c7ada66732db4c60d884d59cec85c21251e1335251e368799cb5b9b27783d95a10e9274f11c460ded7a626ece09dd8229665a3e817ab464e6886348740f64005d138b52af5176074c570bc6df9a74990fd55b7e118084cfc4c8719ca178367a3ae6b62e46eee3614e1663442ae65f34bb75188219ad265ada559cddeeb6102d9d973d3d34851aac44884630caedf5947600e6124e9b459cdebc8906657078465406814d31bb8fef1ba388d18bd967db18b99c7370814f4d32cfd534ab192174f2df2890110512817f163e83ed43627040e9ebc9e1e959dab89e24a44329029afe35d7d9aba4b00f7d7d38e5a1e1cdd8314617690ada6dff54668a5f1ba49590c28be79727905ceec3b81eba5d0e7853f8af7515263b95e71439b2d1c2e5e73b1b7bfe3345d82a1bcc87e0d8e7e4e64d21ec2ab6ad816bc91547a38c6777d796ecf245c1a6fee9634d81596dedf4a55bed5dba1bfb99f62c63bf6566f66022c00e06f98324e1a6e4cfb1d1e83cca75c784d32488cd485c9d2b3a269aeb25995e2a90eaeac48153f065d5a5a8cde6e9c4f926543721e0a242056384f20e679215b579157665bca66727b11250cb02b0ed1ed34e37686472b0bca4855b43837867ef4b25484d8a9a2ea167f31ea0bc9e2d3e49a8055eb5b1a24ecea150823a0cb7d5740b5c76d8f892da6f43653859cb92a78a704c6f328e738f7a53a2c6a7b2fe9077a3ada15bd509051c8ba908a1ec500404528e5b803adee7bcaeee18f9d699bc26abf17d76e085b3fb2e1c6cf58a73f339b5f88947fc9d797db4cccc746556ca66f34ff2373e0acd2d29165f2441a15c430e2b97fe2483c6413d1b42a74df7d78f9b9a5a7e52da745f6d2e5b7d35413cde35fcf54895c3dad233e6cf25076d8ef862448085bf124c260189668ef999268d4b6db2915a6064cb3d1119deb91d98c547233858340e646d798b89b6ad4c7b1927c8fd93301dd50a6531d1b4f1b723858c9ba378484f353cb3f7f9d792bb1fec1605b0b36203992fbfc8d68daa03f3dad0a939cddd38ec51091a1c646f70c8515e0252e60758dd10f13fd01ccec344a8fb354330043b86f4506354589923bba9432ec481882232aff3c03a575083425a68f74f2ea7240e6cb6d865ca7863e11cdcaeda5329f003ce74352a4b96f88867f1c7856b4dd1eae797b9bdb4d7f6a9954450d0dda183a08e7a53658ee13c0cdd0a57d73f57ca77c6ad55c4296877ed6227956fd29c5a1ad93650f3ddea2e40381cbd1dbf9136279087ba8cd97bafe8dd72d3eebeb7b40942a4d0126a3ac2026f6d59fe2e3c67f57b157746741bfc638cef4869aa5b80e54676a82b0f767feb7ae6535ae8014dd4f9b115342227cdb1b701e0e7f0c92b0a5c767da19d3817e849b07b2f0bf382e6552c14bc193bc4dfe17a0f3e0e82f748afeb6c99c0620f8c2de0e3bb6058a14d2ef3a97bdcf22ba2bcce127e1c60b3d6df4c9402d66c22649d4f25a152089ed63cbcb7ac302373d3bbd35540af0a2b0df8e248c1c41deaff87b44b0c636d4153927b0146669355ae09ec42d65dd496fc14f5e6255a2f13da1fa6453a4253dc6d9a56d0b2a4bde7cba89a50e43a008becb03cb0cb5aa983644057b1ecd7d22e80f8ae42b9148d54380b98fcb8b279431e5c5b2bf1867213776f17ef988b8375e7ee7f086c9c1610125e55d502be9e8726ac991cef3e5a8a4d390f08505c82ae25fea880dce1e260fb13778e170e299c7dad4f7290b7412598b9a9c6df9e5693bbffb003161cfbee2c0c034c77119bc3f6a83a7273e2b537c707aa56cd2659d2f71b7282a1f2bc52e8eba06d8a72aee2f3715af74c7a5afcbf8649195d410fe5b594e2b931e9300105d982f6ad9309ecacc6338deb8ee4077eaa261c84a3720cdf5c182b8e46cdc529018e6b48738d5492b12b9535aaf4270d2cefed03a5d1afef3cbd942145f2919d7bcf2fe4f85dd9ff6c18d81dba85fbee630c87ec97acf9e15b705c3cd66eb7c5582f0d54191d54c5c738d049f4a03e77d744d1dbf4ec92f2557a4f4859b381e4bdb458a4c14a441b82827e85ff76610c3f2f482cd7bae5c0c2d215b4ca3965329ab4c3e21c8c4ee2d92efc6c7f364d382400feaf441c3ba1f5968a5ee905ff59cb8b7255e890eedb6b4e11864866437d31b0dcaa26f7eaad6884461d3829b7d51d080754ebc3be9c9b5b83b72adb0146144ede71bca3405087f0b462e3f03f814b30d11a216eea03e100506e12133c4bc0c30f39a1b0a7237c60e0ba24158611d423959874ddbb7638a8ab0580ee217efaa67c2c6d0d48dc4f33423ff96d7d8ecc3225e4ba5a0a4c2bb791f6c07a5fd175c8fc0e6b446de352c416e7070341aac79ca6ba6f79ba985fb151c2b5b9b63acd099e98af27e9e23d0a04e0644675f9b4ea008194963bf8ad6d41760d836d0d407b490efa02282ae3f483d4761d227444d264b5e73f2f4bda66ae897c918ed134349bdb600e0a2882f8b5d6c346c8f93e10332ab0d98b5a978a3c9c409e7aae2bf71e35ab9ad825c0b007580c80297c16f07b4965bc51075607e515e7c572b90eba017c424c0974e06b4dcfb79469d80f430fc5e738df7d648a08ac1ab5b20fa207a4ccd6bed8ed44db0d663b621723b8967c0e81f7b08d6f05dec01fb03eef5de409f53e4d2f6ad1bbf7725a55472510107e4360fdb0b823e47dc1398260821391ed7f1925e1c84b4f728422571db6f9bb1c2f207ba6f68a9e4c442c44adcea1e6d30e2107df9f109c7d595ed2f10ce18bf8fcf2a0c7b87af6dd75d152f396f4ff62220b070cfa20a8d42a79a2edf6f5b58642e673556cb7478a6185a87d2516d094da9217f6ac0a03da292dabfc7fa136531b5d73542d51dc98a75917bdfbbebbbc3f37c6bacb396d3c6f0b74d720344d7aac835c498463af7328f44e4a7944c11e410daf99282ada87330f3c126f31e219fc1478a80d25785992f932c29f2ac9780d632d99dbc36429233b269791e5cd8df5a1814a3100d200b30954d5f3f9b25da055c3c4ce81b8d3600e0479aec081a0b7da2e987b8d3d3eecb4cef7ad66a5e561ee2d3d3f25ddca429cb9e8772a992f138d730cec75e7a523eedc718e41dafb1cadfc49692178789ef5156619c073f1b11ca677fd1c062e89da4d841680e68ead66271e79f600d91808cccc9006d06ee2de9f1f02c4afa612b638e196e698444866c6f8363da8f2fcea764f9a08401f19debd299581d5a6a574bf95339fc0d3e8a7ed04445df22f19778fd241f2c08b1ed4ee8fbf40d447592a941e910e83f10979da9fbc5de91038eb48ca3a6af92a703043ab9d8da7d0c2473f48a1642f6de65605fa97d47718c953181aff66a247153c192e10ae6dae60e1e8e27af88a3937a9c6573db0cd16e05c3d57cf10d116350f5dcdbc58663b0ee177efdaa79489299c4a2be750bcdc021ecf2e7fb500a1bbe13250a2d3bd9ce2f9c83456c2e51ea6a5816f69f17c0565b83772077fa54046459ff1479caa06ffb0657699965c4e72c5d9c43fdb3de9eb45343383909ae93629dc809d476c4814356db2ddb7c824a22844474e417c34b397f8450ee8bac6a52eca8b9437345dbdf858b74b3534d0fd8814aa4bb2b3d1e76b20bed347b1cda09edebf2f61542e508575028104a573f225514e18eeb900f02ea3b03c2bde20f37582e56e86e5d7b0e6aa70372cee90abf4d8a62d38b5ba9c0f49b8bc43342e9313a2bcd2ac773b88021535b3107f83b2eb2328f4f03b7b99d4f33eb887f816696606bca8fd932e2a98eabbac088335922773d19815d1d0e7852b1df6edab7ce8f9c0abf8a09521e82ff3bb59af0e4caed3718327106ea3549eb5bad66e24458c3ba1765ee6d59931240bb58dd680423e6b107b3edc62a42a655251dfe33d99ba83ccc09b3318389f3a42935118dd9c1fa82798f0606becf8d8b0842425e2caaa017bbb818441f23341b368f3933ebb7ff6437fd9cb0447635aa2b924dbcb788c0b2fbdeaae51ea5072ea9f252c18f8e34e80601e531609a562e393129bc96bc176711ae5b280115ea3b0f6493e44ec1d98b3b1f1120a65f53ea166a2c72eb18dd12e215e1f03dfbe0c38e157bf7dba47605b556973aba500d989ac1df1b1a39d592bcbcae977985f3140122cf78b4b8dc7f69b1ad97dfb91c0c4ae1fc35b2c8f3b75640ff6ad2cdf379dfd814dc31494678042c4c3f003a296602f260a85c23331d88a8615a1d884b6c5a6604b545f4870297443550a98524a8ad9475349fe2b0bff7b5d514cf839f0692d163b5576d7e03dcee23806e3b09f6909621822d1e64fe746e64eeafd427d77ef437a0fc80397c1fe1b11a909844417d0d3b8bbe0bda7e91e6df8f99057478a78c53de2df1e7356b1196506782159e446e8afae2c468c373044bc94b72e8aa1702d2b753bd7a51f1795267a125897a45c43fe7cb0d3a03c20759381e02a35dff6a219135d700d823869cafde74dca8cf134cf3f253479aa453e067cafa28ec985e19f15bcaacc8e0e9718aebdc00f3381cf9e8430a4a52f1363fef3af03e74a183c4a84540f12a87ebf0dcf3feecbd950d38bec659d5e526a81978a66a4d51537b473385bac59ab389c1a71a05a0c180c99546865248db5f30b5ff58a2d45097c1096303a9c7dbc9fa8f30ce4018ed383bc1dffb6ac192a421347d48769fd746f9cf66f72b1473d106056ecc277eb685a2d66c6eb5529b5346b48733ea3977ae79de120641d0ad1010215a97bc758750956b9972c076ca56cfd5a36477f9faae8efc682527c73a9551495f7f63b0dbd54da8f7fb9a5bc623415f06deb2830c9956c03b8f7681f7904f970fbe21607db061aa13fd2580603f655a665c66365e89c6eacda574305b77a488dd5a9cd95e1e6587d2a45644c381a0ebc2c2f1bd3f12b65391b03d4015101a2982de0dae818890dc7be8e8143012164e85e3ccc9ed8376428d5b172bc8d4a84aa2aebce852765276d66b1fb8bbb373ac5c5a7299bba8b362cdfc106ff1e1db732c83d0a2164332f21f7584a44db9eb14f3f7660c62a3bbcd128537b25ba8f32be155360d60a18fd7bad3c26d89661fcbb6f716942daf7732e2a8170fae42380223b881c4abb1f6cab9efca7c327b283d4c382c983135f59bf45b2616c6f7d8dd5cf45dd9d57ee7d38c8bfe5860487060475a5195557b72f9615bb15d84392b1a4fa5c3518eb9e5cb2e4fc75d442b379a9f4ae04331c102c0c17e332cfefe33f6fb5865907c87ff391242f3a530f5ca499e288829ba8ff07ad7902828294158b7b2f1ee9922226861187455006344129d8a7ad4d39270e7be961feaafdbe0c3ca293ee1ed504e8acac962e64877d4da6ac88c659c8acc739cf247bb41a1b17ed6b28d3eeb1f1413cf78eb5d8d121c3bb97db1b045da31809ca10b4187c591b8713e1d9529a0afa833d75bf445c30bc99a8d0f8a7eff123ad9d76de94a7f9f838d37c28e11802e4462c7059263d461f21bdef323802a92f2dbcd3f70f9fcbdf302dbf29e319b442b31f4c93962fa97d1c7c387ab60084fab5fb86eacce50e4eac981f831e19f6fb5a7a025cf931811b2804076f76baa99323aa091205bd8a8aa02feeea373f898df85baee0b93d232e00a5c67e16dc430f94d32a55f7543ba92db00665176824ef7aa2a48e9a495be8d7ac94f758affaec26fab33e55425591a24394c81c1d5903572f4abc1366e606faea43810efad67e26c6988b3bda01fc3e852aee4a5fbcdc2c5219d2eaee3d208665b9133dd17425ee1c102920be35a7c26234725b6c719bf034e2eda2aa0117eb7812e67029e0646a939b3c5f68268b33cf6d17e1ddf85e505d08f104d40a704f71cbf4c766306c180562a0165c84b7b5dc09a291868dac16d334659b27a6b1ed24672d4cf07774c18da1154fdf18fad975d14f6b75f33c480ba7ec03431991d6d0248c77c14c4c12efe09c830600fed053bd80d8ccb35a43cd50078d98240e2fbbeb1c0b7e661288582c7408fdd8dc6709eb040c83e8afbad5dbbb6572cfff54143e882b375f5b01e859f27f3b66467b3332b3f01766cf58a6fe063991958f88b571b2f3588215e940b2e9cfc7cd45c1bf66dbdc9f4fc7667ad10cdfbd94cab9dac14086bca26e3425112c291f845707914071c1e48c5c5766e9cd3b71a5ccbfc58f741fdf18661591db351b342d96f5cd3a99cae7ee4048dae31b1f71096f88ae810682879e552f309e4f93d8a893fb13412a302815cb040ff9568a361c1782b763fc1f7c303501930e903ac41e7df4982965ef4e077712b5ff64dc1de11519a6b73db3be0ade4364829966ab5689b6a3bafcb130e1ba6f3579a7aa1a2c9f94d9d54361141fc5dbc571dfea71e8d26b793bf9b218b0b34f96fbf4edade89cdababe435e9fffe86cf443fbc51bd582f487ad55b1a7959d058f7622c142eeeb192355e848ea49f3dcc340eea76115ed798e0c96925351c240783d5cd954b4afabec1c2ea37ed69c95863d307efb12319a9e9854e6719d9652555468410cd04de09d1d2362d01a56dcf585f9b6f472d8f9abb5a5472c81a493fdec70c44f6107ef51641641ff859f075ab0f79ae85713bfc0f11ce629fda75245c3a78c776e6b594f09363396e03fdaf181fa83e52b332c35a271f3f34f88d109c045c8fd5f87475fb5e35852d08db31d0b879a3c727d370cc218eef69d18c0fde2dd7d6840c559542d6bf380d825888885cda02dc7b1350fd6d7ac5a30a162a7e4a10ce292890f3a4bf0638099dce66221828c6477414f304bd779f36c70cdcb49f20119c22de03c3cad0627104303e12ed8ab7b0fc7c9ea37aa4cf438b6f64b0147624bec6ffa7573e96e34e041995c82855aaf277c688b91d8c289bfceb268061eaedee6dfbf94c213730e0405526bb076b4372344084e1f2718e31c52ca4d539f95f7e1f1ddfae63a4048217a408459c0a28ba0e44519bab6f54f5e3dd638a7523715a4c5b70ff5c110d8e14720bbb4891437f343783e49bfede816ee69038a81a47b5d642dddf57a0bd958ddccac635c283d5ed8a49c4ca8e2752800bdae713d36eaa31eb0fbd21184d0b9ccd06adb351e7d917fecf4d7c5b47f8cf57a43a9818af01f1d16422150b75cd13944a06208b100a3255af5e103d4647bacb3908f2f2a2967805e14cfb7df6ab314888e2daf5dde688becdf63200f771811d77f2e57996d4d0ffcffa805efc3236857bde1d1fce147599498123989e844f39d3a18e286994fa98c134f3388487fc24c261eb9a63bf3eefa95709288fb1750f7bb704b74f32988c6509a4ec7175b024b4057fe15ccb97b8413533b85eeee006d598b9d485efd22402dafa6cc73e50bf68b9b4cbe3c73a89e0431e6bdc5437c8584ffe82add7bac6aae20ae286bef9de30606178db498d0d91bece2541fed7bc7763687708fe808788076b4d1a20e2034d7793baddd0d7cd95d03a31286b35179350ed2d983d3a209848574a3e85fd2abb4f82656076238b47a84767ae0d2d33e741f6d983ce362f6a27adc5d1393a666cf8e5c9c968ef65d693fbd6a3ee573620dfd94890c895c02bb96fb8722e5453527f93e5cd4de7fbce4df1b321013e7839670fe092ed6400f5dacdbc5d11eb960654b09eefe0d0b028813008416a7690f8eb3fa045ecd556dc1aa52fa8d9aed2c3c6afad5f458a10ee45d3066edfbac1677fd9ba4e1bf2763ebe4b34e80a4efaa3a49e8a712f1768560b7eaf6ef360481f244e19a41fc3b2e3b7307850c1e9b15c491e3a332bb30069e7102cf5886136210a47edfd6a52ff1909194411217fa099956f7150681886d2a1904363479e27c770ece2db9c38ab9c34c9ac058a06f427ded7de8a892a53e82e786cee9784bb36fe5a4558b80f514ec165e55df59249111bec1be633ccd2883163a2f6d62416b2e51e031c349f84de71d5f1244c3e9d0b6a51fc11f52d87ee96f7fa2e4f718733f6f90ed2e0537026c046d67507fda2b3a2b45a520b1e1f74f81bf14db7d4b9ced8ceb054760e418eec9122f6ebb046b04afb3a8d25d51f9318b9dc6acade05777ee4b97b10181603972e22ee694906e818ef364519973a4d0aba46eed4ca0a4efc7b4299f332ef1fc675d9b7991a64d262874f8feba2ddb8ce2a18003600fa746325543108006dc60720a543876988a3bbe94c43e7d9c404d5be3a6d6707d2c02d47e41de40f2d00d2d966735e73a857a3e579cb77295b154eaf1cbac2251a36ff46d7543a73049812dcb6e8d9998ce5bfa267c2a165bed87c3a68acf57928bb93e72abbefb4dc1e93fc5af4d38f64d255f4ef6ad841498b215d50cfc079f91107f1396bf869c11adfb8721ae62632841b86d852499436ba89cdd7d7883cbcbc28f8a4f63a72aa8f97abfb18b524463b713f7e17296e600608e2bdea883eafac43404894249021877bb46127a199527801dc935b567031232ee6aefc2c8d11962619f5b3d9a5011ff6342b4655950ccb859bdd42331e59fec4ecb85448ce96080b6d2280d1ef4353ee22c548e7b7dd66f634645a04e0194d725689e584be402890d9dbf73f980bc7d56684f83f33c20103f1c0898cd78ced96e5e44652ae9142d1996ca4cd15897d6ea429f933a883988561639bc37b774e7fd0a41f046eecf480cb628d45e4d4dbc4cf92d344b3cb97dfdb3a8972bc73f08c2057803f9c7f6cbc1600c6657b3dd173cd6526f4a474ee9be0594900ac793f23a62b3986ca685341c85769781d0b4acd6eddc7329ef00b79bfc486b04fffee5320edfdfd75939fbafd58839415792c62345b3a7d254ded7074fafcae1bd8db1e0d847adaab7276f59f3ee57f8fc9a936e366eddbd6fddcb446e0ab0e8a3994bf0edc4822171fd81e048b41bd326b72e483ed41dcb04b22a0380b37061b72e53d7e16876226df97607454c138ae1249dc551d788a9796f38bacdbab373a097a617680e418d366389be91b8743f3cf22f3ba0689e9551aff62d1850b8a2b903c8397ff850dbd606a9af15057a4269638246a0bbdec5cccf19193a2d151eac0fbbe5535198c846403a9c3de7d2f3fcb422af3c44a7c58bd7261468d1767ab9a2db221f2ccdb302bc6e1720aa72106d7c5771d6e072f210c2bc0f0ce569d35e093a07d4a8dde3b75894f8e72f616aec646d3f557fddf8489eb9ee2f7d168d0795695382269b0a0a8f272172dfb42567b1a9cc66ed17d8c767dc26dcbcd9fda39ca6f5d561326e42d8019fd8c548f5513408ea4264a0aab553be377515640b542dc88458e4445f2e9c4f17bc2beb8d94173643c26312a2a194a9a6d079e35400351bad182fe01fe67987c61f3581acb35f9068f040f4427e4897b6051b03057056079bc3d5911294c03a50c76c560d2d764469f76e2e22cf8b7e7a8a8ba8c290180c2f03ba304ebefea8a34a13736af58e670d0914916ca1f6b99cacbf9d7550c3a88f28b43fe9ee346518be5734c4ea7e9385e87a6990266602f68d644cf97e413c68aaa0ca1674c6ba85558fc3b82fa8fd621ebf3ee6e3aa452c67867712bad3cfe37f111dfb87fdee6183e60eee20f48b89dc9e6ca7265fe27f84944272a9b8d31d1610476d75295208db9af6c72967af56e741691a6b10880f53e56e106de357e036963d5e6afe44c46c46794dae8b751e857e5ac674cb8fb27e0e2b3d3361168fb2f3b0f516c8565b347d1ba7e8e8941283906025dc369016338b267dab2d3f713e6bbc7e177b402435efcb892ea55c93b1110509466d3fe6b72f581da8a59dba2a6967e2297da4d24f2bb01878ae8bba862035517f1bb73dbef4c85bdbb36525a2f98474218cd4375dd9d16b4de1777b9afb5865d463267e5a9108816acdd357bee937b8f83de979b057a5db52a0e171a71f3c32725c45c12aa81a7fea55aac76cebf28d9d0a3664ce3665a8d95a984ccaf5015516cb0504348c4a1dcc70f893c6a6fb2ebdae8d3a00c0e0f7887568b5bc6f181f9dafe98258d7e85413294c92c00bd8165d3edd24e74061035b759403e7532d8c6716e77f88be17f817deccc13512d1c569a4e9a0c3df87ce5634d5c6cf93702c2405c08dc745e3e213081c292fd804fd317f1ff633f612344f0db6d6bd60226f12111f459e1f7772b6d655938aafde85c730e40b3c634b128b0b12091db91f55a628232c817071a9955f2ec84420585f77849d73e1872e971c9ddcfda0655061b4a4c035ec8fe0f2bff6f6bf40bcdc15ea6b9d18ff1bd74e1808aeabe03e83a4d0855223637c116515c8b8734f159c6ed4d18dca19fb274593e31dd2de33abe38d12f8a0e81ba9a7abc0b60f831aa36539198301cc7f75cf4e384bd62adbfc9d75f82f27a9b8a28cbbdc31ea9e022d21d7dbd1068616ca8b6195f275118856bdc55bec661ce9a3406d5891222f979d7d96f509dca175113fccfb391ccaf7c4a33d561e4a78f0a7e584fa9bf90f245d7f3651346d93f9ec42163db18c05acf7ef546f58bd6385510436d05219409b7013bdd612ccc2527723c2813b8fdfa935a93ce26f507a47d9ca2bf0ed339d5559eeb5c8ba554c7432225a9f2002bd9a82dae27602b098c92efd0cfb927aa59b762344ba931a2c3e336970880b6c5c49c3790705f3b7bc7d82c9d6c8fa7a4a06256e5cce6ad435dfbf547b4467eb2c826515895fa007fb6ee37610905b86b776aaf7dd88c5018ddcc4ae62116130ffa3b2a6947af911382f4cfc673731ee5f8ddaa4856d2ec5a7ef94bcd6173d575ad82e9a63218ef7b1da76f1d060779cc926ceb9b82222066381730ca9a9eaac37583da19251e8f6b27fedda6af129194cdb89fac9c20a6372cc2a71940f77f11eb71e4eb1f14c1d4dc0d8d3f6ae576701a7b548e149338359a522bbc3215a67c96d4ac6c6da5f6bcf1ab8a2c02e2e1b7db3469ba833ded72c25a1c411ccede7df7eeb24f17cab679059f24828f71fc6afaa15fc71c2c5c6240e0e91dfefcea968e3428205d5649a21cfcea730bb9a996d59409b71a2689e46dd8cdff6765551c27c0cdfbaade9d7e524366043e901ca0fdb33776abff4718ef419128c300ebba741271c1b1e3cb91555f629b0625dcac1363a928d8036ddfc01e2a4eb13fff6a1abf8fb161932456687d58b0384593bc7872ee6f4871d16892f1a336e5ac4cf0a08f6c05a0c6c6cf1f29b8da9c7804da4ebad8885a9a56587636659ebba5a7429ce674644f9f8e7c1dc81c5aafa7d8875149a10762eb4d132e3c1a2f6f2a615ebf88ba7e727147e8dbcae05f07decb33f0877556aef00cadb90e2b702ede681fda9f0b263caa3862e9988d37313505b2b0b1650475279d54dc95624d8c841cccff2ce5de532ea9be7e5faa79d7e0be2fde0937a4099e4c556aaaff238648e114119f3a30971006c9521f059123904ef3ff58e1ed9b76a275093a74a51dc30b657fea3dda352ef731147deef1695bbb8736de3332b432d6b430fa1d196fb9d7291b797ab23442d52772e412e4495824268262342a1eed7b08b7a463a654416fb0cadb2413276609491540f3d55e34eed164c428b1248b67b3a542307ec84eb222c3397b7dd50e875dbfc726dfd3120f30a28d51d64c88b93c941f9e802ceb3070e15515ce0b859eeff2ffdc95c2dc1775b8d58767aebe86382d5b03eb6d240bc27e3418cafd6fcfdb5dfc73b8350fcf07e274584ba3a2caf3b906e2eb6664c07796b598f3b82147738901d7cb9101d01bea263ff0dfd7c5edf48070240d7548d58e9f9ba62357419cd07ebf3c9ed1ba6efced75f56739fb181f0a9f567437e34f7d02e5a675fa8d80f5b0af65ae7502609befc29682c3b07ffcae603319db98514f8f1954e204b2ff27460d568118bb0b7d4f594931192538086615fbb33f133774b3a05273193e12d15abed647cd78b535b06a721d65d205cfbd235952dd8531bd3633a4ce9c72bb15301e903ee542d3fa2fa5185794bf64b181139718c185049f3b7f1e600cc6a3fd29c1b6dc9f13dac0969c43ff3614349cc8a252231bc91fdd1a7071446b93a02a58b0052a6443d58b438d78b06c6ada2a5b328fe614a5063fdc6cea476cfd2bba45d0c619c6d0a2361dd5ed1eff418e6eb99dda29ac4c2b55a60365ede8797bb31e5ebd5649ec7f16b98ca6fd98054e159ba8c28ab49bc5e00839f9300784a36024fcbe10147e08b23b6f9b3886ae955a472a258cb2232788491fdd11fc4668019bd72150ae7a4717bc389cdc9c6f51649b4fbf7921e053dd26dd69c5f16abf6096357758bc643a03d19ed6c0bc2efb5db6a35986bd3e0a70a2ed2c008210994eb09d072051c6240c16e0aee54d8a44ab80b36d487fbfe62f6b6c50458771a83f5c16ab49093758330642431bc9511401d9089f029418e02181aeef3d9ec1b2cc57892203c50d87a669f3954823411881b318758bbae3b42d789fb836d49ec7370e9669c6af59fae4c199f4132d7252ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
