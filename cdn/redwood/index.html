<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb8ddf1682427cf944171c3e65fa7471705a554566b0f6c9fa0b4691a2ede7e5dce72e6997176ff76ffa79d6941f2fc43e7f7d8df615553ceb63a5525817ea4d62bd254f429dde46def92d03033d41071a37189746419b44f8f8211fc55d143744cb6b76425d8a4cfcc51bbc9a7414e1224b46c4074491eef54e0894a17cc6d49da18f6e33d415a77311e066b5aaa32b227060d12289ab3570302a667b77ad5a874daf38f6f85a07b2e678b7cea2ea6f5bf96f732437af07b1483e901d59cdf4f545bfbfda7766c77dc47f89b53d9a8b34777492504cf393e5489d76d82c613efa9b79dcae869b190eeb3392560ee68e6989dae38b4cacba8da194938925a62357bc68b9c3cd448419d8eb6412439b730c1b7bbfc4e23f89bd0a160d49a94be2a6f9eceee19c8af971900b4fecb4888759f6e5348e79880ebda7a76896b500f464a59179f997513e646fefa7bbfb8103cd85728e62bb75330694d1bb940b62b123c02829a649a5db9ca6ca888f9905a5082e3a875e8ea4d4e9f398f77450711d54105b739b805d205a234e66320258a62259277d37331f843f93686231f615e89c1fea8a6c8a4398d94631f6c328ccb962021e0ebdeb429f97029ba55c90e7f7bc83079b521a2defe88e858f414b895fdee26371b302b4e2dccf23642e366c75eb11613bbc953704c7597600cdca5cb349cb6506124a25765be2a7d455321f39e298a585ba1686a984169659771d6ba0391797bea9235a37f6e47099a6a975fb3c1c4c3528f46386ff78c6d0e331a4432afb458be9ae8eba98d770df77016d6c5cf1f814a4b87407abd09079c997371c36e59451f2d3c89bdc0307a054a1f89648adc16f18c9742f1043b7855da0e7fe3d901d977ffa651d512b6bda5643a3377fdda2a5797e01cfe3e15aca8d17b99a08d5aaa22de48c9d17b634c7f00213a0b0beb11daa2f169946feb70e467ac18560ce731405e28082c4d5cc494dc64fd5f08d5f3c23f723a384abacc5f8132c96aa247502ae0248efa51d7c535f179ce04e2ce8079587ce2624e8c1ce99790c239ad64d09a3dbbfc209045b07023a2071548db913aa68fafd5ae64a520794350c2b8699adb9b867d1db7ce30c152f773fe89d1ef2835a1628e838b5aee848c30f5a54175dce862f3f168dd16b128db0a1ca214cfd6a03f259911f6e83ec42f92b897c47f9ce93c1326e7cf4fbb94342acd557781424d6992d1d27505ec70d21f5f392f69056ecd2d18d4db76c3c556983cfb0339024b19c3b3466d272e82b97096d6e35439a3da04aea736d66bd312975932170eef67529d4c1944511f6a6ab05312c5d07418daf8289eefb5ba7f1cf6d1d54f2012d1c32ae0cb0b7ec3cdd179556df84e389f82e478523cd811b1ffa137f786fbf95d4c338b52059877741d897b8c7d220c1587c661937ba0dae4db924c139673d65d19880676ded1d59be6ba7c4de62508f31338be1ae6621fa5a3e055b2d48ad32f20cc8ea030ed2502b1af1b1a6bf65a8c71bd1d90a4f01b6175a6245dd8f766589f67e431c0c48c7d2592469eb7ffc7f4bffc1feb40dfcf5fe725ec44f8e7cff60ae8d8fe0a20a545ae1792524305a55f9631a44ce3f2951a44d93eb5694ad42be4cfb4cc2b8223b8d25549c7a59619fa58a0b16396073e20550864f32dcfcf4650936259be42a3bc8af5bd2cb3def41cfb3c625b9bd3c78079dc911e491e8ddb3eaf7c9579a34ab1548b05f00e96260c67ad25df41ca2c98a6b3826c767e662479c4efa4c7d324ff733f6faf1ba5be82f48a95b8c53d805c628520beb26825251657389c0343bc0bbedf21e309f07f5ca375891152fd85e754bad0ff2ec2a2c54b544866469096e0fd6ce83c694276a37d0047fedc791bd937296c9dac0b3c791d5b80e25557a90f894587ca701798f4781a14869efd4e093f0e330f8706cf4c6997cb31ea36090e6f7a7d2ae1f8b3d40e325194a9e3dc484c37468ef0a017043f3f8294e36315f8da6ab413f5f47eea13aa1960c18649b36179b8a5fb6fe5d7aca8efd2edde279768d84bcfcda63fcedef2c2f391103453401fc9b98d2c1e9c7d734dabc43e1e45e260c82bd7514b4980d186b07a4d8fad233c17b72d500121118edb518c10287ba5e9ff6871235571de27dbacbc876fe108bba5accf9830cf16512ea3ba1c522c46218782a9869883c419e3cee8f5336e9a99ced52192b5a6f5e539e06d188443f6520869656111c3f100b57f0b1dd18d2cc560952b8ee00485484789b8e9e33a0d02fdfe6379042a7b8f8a5c77df26f46e1108f7a59316c2da2fe1e7d418cbc07b496d0dc1bc6752dce89231d323d80dcaafc04beb0e2a0e55f73d1c3107d11557a73301373e386d6d24150c1a2a8790cde61b51c4ef3b0211d4f3eede2ad9cb9348fd5c3d2b462c3ec9d6a8aee23891f4378254a7067ab561c0ccb01070c63a8ac9422f7e5fa346ae59133079af940e1a5303442c53e1235806742e2ce55a0f04252deaee698d45c8d3b7d3f1f3f3217bcd18e6ef88f11d3bf72ba35a7d5243f0d2f7ce1da27dace969180975281f8c15976e06afaae42909766a4bd1b15130ce992790b08af88e4feeed0cab626e577664fb88e6f6a213e7741323fc985346d91e1969f8257890400cb61883406d35a7963b3fffc2ad81f593afdd6cf1e14a1fe983571b5b35a7447411898ed0dede77f35e8b8769de22f7c9e4166995fda8d62ba0d53847940750907bcbd03cfb022813be50769ba4409c060a726a2d13ff1de03afd98e98485706af4e57e6bb4ca0ab7559339a2044780116c8df2f86576fb44baf5a444de53ee79cd6ebb658bed49ecc4d3b62c4eb846e64959c41ffe5a767da1205966ad24bfd76cdbed9d84fdc6575a3ac7907d9fa394d682c9abf267eeca7ef8d2436767ed3e0a92ca576f4445390e043e5d2e3c8004a90925048d09f078e4603a170ac3dfebf1fcd67606f5a46c62fa312966b3bd15bc1065b676d698ca7ecbea293df382908c5412300581e519fdfe7278dd55655c723ae65b9c3fd37e6800543e0197ab901820292da152e57676b83351a53217bd4b80292b4630ad5a2180860c4ac7cce0d6129f9d6da2f94137cb4ad2d3882750142a065650270b74f17aac499b624e219ba035df6e59e9b3dbbb5dd3582a629f975730cf6a3a6d67beb3d1c1c81cbfdd946dfd67b501bcdc6c794dfc3c18286429f8f8828be4720b82796d69fe6c46cb8c38d9b9ce4e0c2e9fd35c94f8b5465da3c61bb60eab27e97966581e1f4817eda9474af8789bed2107617ddd120489b522dded4d25f22da01a2a1be965695c2095e53c90b00c148f6a8b016098ad9fdb0a9355f7d09f59b512ae32f666695152f1613c4373ac5292f87d35baf74a05a556b97b0ba0b7c92ae10aaba4d1911aeb7d0b40b1ca0d290d52d02b01a18f3347e51dfc79266195a7ac39f1d6ad29e97313b530dd7a07482752d17d26583a30386767887ef78fabea84db0e338eb335100c5b7c20a232ff547565bc3e6528ea10f29ec867d909fe9ba98bb49d66cb4ed324ffe65dff63dac72b2d594124774619aaaa79470d6a40630767f934c315bbae4b234ec696a164289e544628e5b8438ad1acf6be455fbac49b0826cf3d696e3766f99bb783ae7dcb7dc9cbec0a5702eb90424e276a7b7faaa9f63e78a7e4ba359ab7c088586f2bff300bc9555024ec19d27d350a898b0c6322602d4a6f6ae23abafa910c054b796e67f81625fa0cc1ddbc533b5eb6c2d207ea15fbf101fa5634d79279ef46494a96f1767026fd7c7fe9b07f1bbfad4bfbb6565fdf415178bfc86235449f9fd9f878acfc9f72f7e6b9887850d95cd13438c23730e92edbecfff57003ff241f6c920fd7c62d164caed2ef72a8d919a975073e2eba329f1530f887d3718a7afb34f76e8d04e9ac2bd8e6c070f5c67947c0b10c054ab9a79fd0e86ac1809e6d6e72331212ef6918ebbc77ec5033ef9b801545b7c21612ea671d5769a68d71b9ef2c01ba6402d6cd5339e646bc52c09ba5045c33e547ca2c91f24c2a7cce375ccbf32fcff10d5effb0a01b1e1982e982168d244eeb63fed76d72a66076327cad6178934037651763519d6260d9eafef0215fe86f2b9fe0bc30f5958b1876bc7d42b1e61db7c16b7b339656fdb4f99802e33bc97ffdda9707fb6fa5ae5980cd555e748fa03e2f7e20f6315fc3db3e13f9815081ee60765a1d207abe8bec812daaab7f043caf777cf6f3ba2be5406bff72e11a7265f05fff711f3298a0b03a66f810aed1d4ee43346e71327b137f2e72157930dc31a60162b473858424c5c9f182b323bb9144e3deab75bb31d9590ea701b472e91b4c54cbbdfc0b55d4d7bf845d5941e2af1c611a3c97a7128f8a56de016963095fcbb136e046e3e58bf401e72df1e9313d9705365b07bf2c3c8fe01cd10e9009d20b8196256a90d130c20943513a51ad39961f95ce8bea4f7aeea307b75f8ca291e16fba6c69dbca24cab48e7549d11ab8979c3e03aa75f1a22bcbf9d0bc4bbb10ded8197b10519c9e1f01976c8504f0aa7ed7de0ae4e85cfbb13e1afaf80ca867796412eb060f5972155ac2b1d99264ddebb2c9369a9e49dd5bbd72e7fb8f86d2926900f346a8aea3212b4a0412d8db4de98185597ed2e10ea69a152ba98f5c89daefe438a548782b67832ec5bd66cd3d1d91c3b54f10cf7cd307b37292b83b0c185ae4431d9861cc33326269b6db148ae5011e8dc13a34d69828f01a82aa51274c88d50e37977683b6b11667355d68c78bcc770706fbef95b15524315e0bc0b177cbdc83d6a6cdfd3c16c1d0d9ff1a74dbc7c597df5855741153d59e79fc287782be2545d3b8d53408fa16e505848f0767a8476e5b237797e74bac03315ceb36d84e2abf88a708fd2bda18cbb9403fa011130312032f18127149c86e14ff651b0d37599e5b1eafb749b6ec61608836a24cebd485a9b25ddc5ca9c0109aaf7733846c26fedb7dc62948fb18c4807f0a49edacb48706ecb85deb07ee1d19252c66c7c15cfdb7994173a1e551ee2c20459bd56d5ba70788b9bc13f74013403e173b92f1ded16d3b4a9ecbd20cd5c2d21c52365d59b7867941a4beb91f223f8630c0993bbc174fb56394ec58ec0db1e7ec4794c3065d3cd928b667a27ef2808ccf3fde085652f578db6c2d893efd0814cdff5012f1ca63a49d0c6a1255f8ded583eba51cbd64743da4bac35e4180021863cb7845b65619fbc3dc041530852afc36cf797b091dd93379b056c98a5c0fd650efd5fa568a2839ccb35ffd10c40ff4c3d8b5350292597599c1a0dc19b9e4bb0892fe8f3d93c7e177af97ac28f81d173a7c5ad7cf0fd36268ca3a62362453e740b294d73bd5c45f8c9e99f08569266872488c477f45e22f246726515e7379032efccdc46e42ddd308d80bb98cf126d1c894102d05ceddcc99745565b195e1e636269d69e17aa761c53fcee52e34a381a4aa88961322836cb212fb669def05543cab5afd35c622c4cc7ee0c6ac6a2a1c49b01395c46158740af96280a07930ec720d454de8dfc618f4af2475069e67f636175635e657f190d737ba560a0715296a2782e0743165e7842abf7a51503df943355c2fdd012a8c28a90b37f5bbf675460cfdd63ac4a4f767a81133338d43e7af404fe4b8210f312535e333bb3aaa1bb12298f63e87adc20121b583dafd36524345ba67abfde77d53239cbd25b03e57ae67bbfd4d29903593d38135ad87120cf9a3dbe0df890d079959f48653acbbc8fef5e6ede97d545fe4901994e2e7bf4dadb767503cf143173ff5dbd7aa07d7a71cee672d49246c4dbebaf77b7059347bbfffe15db5346fbd8560f34102166bdc9cb283640a4995683507bbf5c6d4f3c3e5e40153eb4ba35cdf5c0a37ad40d65bf66f934eb9f7d8a858768e1335917d183f020cb3f37f808c1b40762e970524885840155b1448cfcc546a089aaa89a07a079903d179025381d4a8bf1fe17eecff616cc7916da24491a4dc680ca308b005fd135a56274899d9c96319c50025f81f7ca67b282f90482e4f0554552c88628dfb35ffb4c4586ebdfd72ab56db9aaa0d767bea16627a2bb02e1b46b2df01921c4c9b2c4c01b6a1c4a90c54a907834a6a6976c49517b3df431d22a86c46a073f1028594ed5832cc3b8ce90ef0e57ab11f886d6aad3c54c333a9840eaadda3b04dfe02d69ca3f4bc5ed9215ae99ccb5fbd3f542019cfed629144411970d3646c25620275a788b13bed8758a30164787e9c090648aaa3cbd402a755016f9e5a03d7606d689622b8d419cabf9c4b6a2a674a4c3451b907d7e55dc88f2ad38bb9e8599c0b86db790bd6811253e0166d8f76cbc1fcce0766c449c63dcf51e3cc7c9cbc4503efb9e7f131153bfbaedf73b3ec4b0f158f7408c9ac8f624ed0e48e04d7606e310c0cff1c1fe84f37b037149c8493445c0d604581cc3da6781496c80ec58bafe7dd5e62177f672ee34936a7254fdeee77bb97c8e150f258de3009b6b6a8784ab1f168b254fedd1a91d2321c5ecc9cc25b366fd3e7c2400368a52200dc5b39657f5766c134f06aea805a80afe374c4a923be3d12cf3bd0a7bf1ed66802477807a770731166f10bcb410a8d30a717180bce9cae40a789776a2430e3d3ca93336527cfb0e44a08b70e48268d71c5baf686ca2824d376d331769c29be1a5d40f1ddc57e5e87a14004ba73cd53942774a7d4a6bdc29c47aa84cf2d1204f128817a27b53deff3eb9a255e1c33fee9ebc0b7c6ccbbfa092d83430e772c3845fcb62b80a6787545d26fee6aa10deec0ff5e1862624400037e70734d6ca7138e2566a3337badf6f5454146d1847cc16440b9b2aeab2be86f4d96dc22c1fecf0715c2ac133dbb530fbab0f6f7c38c10ad2750fbd7185c545ead099c3d05794ba7d9bebf368781131ad226d41dec9682dd44d6ff7ba0dd9350f775f380c94cb657d74837d5c3b0a313bef7fdafb91bd9527389b444776ea66a76d03a659d59dd74867347c02fbc9a9f56542d94d2923810b159fbb4897561c12fb46a23000e92ee4ef539a4e4b9f92ca83514c87ed6f71227e257ed1df8ab2c3b2f5f21fcbbc0280814de90a6ab127631b9b5b8e1779d45e3763fa7143a8ae767d0eeb0e9a14953cfd73099923f1b389f751fb487b4e0817a6927c99980547051eef165101d153f15e474ad6c08bd6958d6fdce0f19adb4585f8fa8e2eae844bf70675ed3893d46adba414ec8134c48e67c995d8985fc2bca63fff8fae8094a8f8848d6c8e635c4617c84c9fc8191d2bf192d737e795f1ccc033f02e6baa3e5ebecef22679432576339479ed00cfff5c21cc19ebeb4fb6bb6de295227b0d0fa59088b8f42367ba9767d37c36807366f02c8011efb5ed66860f2af265c34c36cf0d41d3d46bd6200b8ba80dd65495b652f9e0fffc9ab8e5ee26b370bbe6fd62a65cc3ab0c0cfc1287d75cabde8ecb3803a36265b17fa3b8b9504dea1b5874a01140e61baf4cb176e6b2c72c63028ad48cab5f58bded18e796aca1f99bc8a0a0b189dc5737b152cbc7bfa08167241c33a7e44dd657b0f3e23f3af2b42055f820f173d07f36da86d108c501b6191e2a7568b52330c431a7fcf2c899112096374787916ae55a010a8e50cea0e2a2e150657c4942c14354a5a25db1941a4c16440f86fc6817e0424f388456755bc32706e84f1ecd6759bf98dd4ca9dc916e7d83c51d4dce3ed4c9e2a032d4e247b39e60c3f1f917eb28e8ba36333f29c62d98d02fad22661a87335d0b79b4fc0d324f9b7ba22253ce2311eea1a6dd6c887d83a03c88bc114faf4444a390065785055643c7a04d5c1eb6e2f98096cfa54af047334e56ac57615de6c8f5617c995814e64891954cb3eee0b4bbfeba72708749b34650061fc909df76f151266436ad9850dbc2cab484fc748d1524562bdbdb1d74d8721b0fecc52c21aa790b534bcce96ba1301e91dc9666c750cdfc8490329191d5d18a22c2a32b3b8bc5a8b3902773ef0105e91ac71e7798af0bc2d40801a6035b0d9308b658e71c9a28e3fb54207ba045f66e4e8588bec223fcf11b73aa29b4be2b29f8d9fa13417f1c7020c86718cd69aa8581b872030df432bb9d5d4998f54aad3def89c2e08bd1b6377d0b7d980b67d7c420b97db5f1cb794ee1fe394107862d62cef5af597bb7a590d9382ae22478dfc4c81fa150fa2a5ad7b3127959f700110d97bc4ab7ac322da8959960143a7dd9cac11b7f0f1917fa3317862b9ab4246a71efa7e8a5480a581350faefedcdefa5da064c67b00f018fb29fd62174b846cae186be5989ad47b71e3688996f7a45680c98bc54dfa27f6921ffc5a24f577e6f9edecb827577c84064a1ed71538e82227fea512aa4a20e0dd56430a32368b671252474b0716b566271fc5894ec89d5b2ef30772c7a87f1550d147642f22c7584a50c6cc48a05bd241a82904dd80b293f734f9f6023b327ccb55bf0e3dcb1e5a87fe8853853d3d5b28ee48fd20b9c99ada9e7ac8cef7182d151b26f671bf28b8286cc8324b5055f7c76c7b5bda295b7b344853ca70f6a9d8ebfab8a75ae6be5a85c9d51db6aeea98dd6dd335695be02ba234fa149a0e946b284b622621a2aae8426c472987eef2ccd9a085cadb0485f7e344df56abccc094c02d54587773a21c687cbdeeda7179fa6c2bcafa3ad10317c3f6b717fc2b7068674e530a5fe3aab82d2e51e369247de4e1bcfece070363cbefffc477c5912f16dd1c23d12036318975a49861fd5319c6a3799874ce79c0ccc8312f3d306e26d48aafae2bba69dec7af695248c77d3198c9a10b19489cec2a09ea86b5da0f7d06371cb9c3d59e7fccffa8b3ab824e1e678fc909b0655cce87dafcc1699aeab3d4230f2ccf784c3832d9905348151701d2990f5f5a01dad63f406eaec2d14850e5679a539128b4494d9541ec3cbae74af4d21c2382f60defc16ddca798df22f6c943a3cca0b39430f493df3f2211f87e84f4c552aae3bc46767ae1d5b1e36199e5039a6af555bdf6a678c94271e1b5f72ede0daf638a4a6aec570c2470e83be719954c62e2f6d724f1c76cb3767b090f21ddfa915ca3f81b57b84c4192be78ccf6d1b20c498b0863dd3a8324b75c53aa3e9ced02466a96f2e5ff5797655fa8b1c6657d8232b771ad998f9a0da9fdca9405e5ae0e7df1385ea1341c34a8455888b5d2358fce7583f956070c5d31b67bbaf0f0cac1381f31d654a57172c0ea52cd7d0c281206ea58d26584e6f83d529aaa22657484051138e693da592a80948a585193bb8b4c623323fc5255ca640be52584446ced1eb3d51fa6973aafe2e5f99c3d8d345bbf4d243a5acb65798cbe50f8b8775d14c327e96b8005c20eb1335184e46d0ac8a63d067deb9d0bd60208069c6c9c787dbe96b2a6147a467de4da2eaa0923a1edcfeb756921d13772abdf03715975bda17e474ca459cd7ef96dba4898a1d87438e7c54cb4cb06354772278ddb14ad5c5a5b20fd545eb9deebffed58cbd2570eb4f03377f85d1a4da10f28b6b3be54c0eadfa8375f8cc418d71b934a73eb394f870cf66b904cb0ebc04f7efb89ed0a598c5bc2deea2cee05e36e732cfbda25fba02522244001728c203e2440483107bb03ef2e05660debd7303625272e61927dd244e04688334686794da48b8c9d3f64346d13777b5dc2b0861ec18e5445aae957906e7bc66a7dfbcce07ff8f7b95f4657dcec64b50d0bf469c1c72d73e05a8e37a34e898a2760934a172667a3dedc680b5294aec091f118344c9b66df20f00ad3866cbb2a51c02b95757c2c7801dfd9c76172038c99fe74cf0c96f4cb5aa96b6b6a282293eea1909fad2a5b5497a00f322d8758bebfa1b62eaec80e25e3f97b74f4dc114c4dc2afab485106b7db211d47da015f03a9f11e761c1aefd3f9889549c802ceb079eb26581c57484cbc9cd8682681791d1187cbf47460fce0afecd2e0f58ee816249b7178eb7a545a874a75cf7bec4ab9d6af1d45418e64e557691cce269d5093ae99d50bd77e4160311a10f15f8cc2853c578d05a61cc5d056a6ea19cf6c195022485e37339710c4be0a8565ef98934d9e371f009da8335c26f3410023965fb1ef62a7db50e24f52d5aee388f08587a7e9bf9561f437c07e45759f577bc40ca4fb0686cb5c3ded806f8e65e833148a0b20b9feb3df4fec4d56d05a99537cf3c327ef2301a2d31572c2a7cd1ca37de56811371c3ff348671e06c102d3ae8e82c65febdd2e9c3e450667cf356f9a64ca7f5239b4cb114812d1cb2e19b5717d19ee23ec88c896d72e75ecc6609072dd6744048bc56c3c956dba831af3a5dfdd2a2d36eb2b4ceb517b0f7f3ea1a6765b9fffec886c6d42228f8931f27405893d657a8c1a1001b0611fa8fd205fc1c7f67b4f4a06005ad7f38dca7baee00ccb352929a7d9959831e1b8e3becbb12a85ac918aab75b63e421be2858ec3fbd61e0665b0cc7360535e432a64b36881de4a85a9be97ec85e9e7f02e170220bce7705e95042056ae2b0c2928f0a61d27be86bd02f464205a95470d5cbaabfbdc7e21a1f5bb464e4e41b04baa87a12dd05f5e05ebb00a54cf19c31ebb5e8712e423d8ce6595da6320855ec9e06b054992a22a131fe732f7cecec9690598866e6d0cba41edaaf4b2b97f2972d3997b54df68974c25c12eebf8b2e3337c96841b0a1cc988fbe8066b99faac06f34ad5c2353265c83751d8701d8eebfc45ce2e3fed10f25cd538fd8f3e4ee96262c41d5f400b571b42a02b12810c407039aa901cfaab989614e24815a0b682bc0373cf7e9366d42ee7ccf83aa72b980cf35b358a62ed1d14968debaa23681db5f9cbbb8829f8109c9d30b9adf14fce29a7ed2bd39183844778cac58e9118bcb8630974341e09a966346e488a72c3c5ab810ae32115469e1585d4279081473c31fe09c46a9893522ca2f7a4a6beca34d14b76ee27ff149c2989aaf06d75e31aa8f64d1a7d93a703ea74f0d512ed0343dd4508870e5dcbec3d4e9547d4e5a1a26944a9211988cb9139db5076aac60b1dc37d45617763aa768bb4e85e62da731ae4f88c3db8c73f80bc85fc1abf99a2305dbda27a185a04de280d445f389afbd62173be4816c3a28d9b83d72bc4e0641b28de210163825740cfdfa8cb8673b286696c570e9495ac835b467ff810d91c909934ac6aa93f60434b65b0222fb2b7aa51bc4cb089dc490593efb3118b20880be7e551fe43d233b779d5e4c758372fee6835ee49b55325921337ced03c825a0a801c023b5373b56d10aa330be2648baa890b1060672de4ec79960f25141ac263cd1e64923cb92d83398611a9c258d58db2ef6fd75bea988d3902edf541b19fb4dde5a04186fc2a0ec32a3122f98f3ddf05a1c011d96d3f1b672a10f2c221ba2d9640b2a9315823a16472937613e855b7ade650c67ce3afad460c27f46b4930fdb68de5bb3a5dd6872b268c5dbc1f735d11d64a844e22afa0e1574e6d58eaa9c59e1c1e7ae79d326698ab6a5f20ef73a5ff42785c9db6c5886eaca8e63c4b18e69023aab5c28ff2f6bb8fb4d2c34bf36eca57447f9a8e055424d7f49083017c60519ddf1bf744713d1b9f5a06bb58d720062792985cf1dae30929f2f4782aea779d0990df19c945727fe4827a93c1c9ca1880544dcbf338751836f110d6d2ecd8a3be8669f89be889f60619b3e76d700e9cc8e52e4d581187b644b2009ade8339d2388579d327fd3d379a8f6e468287c5f25b87cdc80768552a045a45c0b292f315da736db86fc415d09fe6c8cfbb05c713f9d966fa413dc4fba8fd80590d1f49aa07a036cb56ea172533eb7a935a1cedf7262d2de7740951f32066252b4f108b5b1b05ca8324b1722486858a232f13057354eac384ac4a1da04d029b99894898373ac63b463faa8057aab97d3b07408d98475a4740e7ecd333e1636a4c7e5c2085788af1a680186965a84c86344e5641444ea7bfc29d6f1a66e5f28f87cf01cc5b35d454548987211a7b2d30eab5e7956ae61bc4d2b05d5b4c1f225a89216b3c5f606c4f92a6b4cf1a7a8e4073a53bbbcfac54c3b34d6f084cfa3dc55db866e7029f9e8382bd4b2ca047850b05fac53d18d3ff7fec69d3e7d350710072104e135b55cea2c044acf6e0e606556e60afeb7bc689407fef83e89f88ef1d5a5980331e611296b93797d265159835523ef46f506a0a07f9f811d5946df79aa99e19da19aaa6521e5b6dc268b4cad95b4e716fb7b03ad644d810422748dd98ffa246d4cacfbd74e7504b642ba334e859ca61490681e4d322df245e90cd82c1126ee84f00192dd6535d76036b2944544f615e97ac037f1a956e18ac5fdc936a2e18a53ba216de7a5bd20746379902afa0669020239ce09a94165c2b50d54e9b62bc9ff489afc4f82b1509f5bbb745d8c504251e66621cceab326cc65565c5a8d8da82529523acb605ea016393fd0c19a9944d477d78aef1b371b36c74576dc2da6a9c2cf61b5ab7fc2dd1f0770193b745af615fbfb24ae7f6a361fae92ae3969be0d516030b4f56b1b471b19dfb37d6de93f08407e3688ad2cd49f0fd7cee7bad3d8b5628887e298213976615664e0cadafbc18d4e2e5f63d3e6d7259c36110568fc530219634629b457eb106a434b9d8a57b27768135dff377f9660d04b0bdd122793a9b01eefb5a4659cb1d1369a271708bc74f3feaca9750bab38de1956a099aa0f18e5236375d89c9a7b433b0ed0a16dbf955fde466f1a4f6ede26c2765cc64bc70b193d0fe15dbc52d7c6662cafe4f626d819fe2a6fad4a7db9a242f1e96772da331419fcedd506ec9533fb0b952e49c5595fd502b44b8c7b4555f4c3382250c14fa04b4e8edf92b4d6e5a068ce74967128373e3e295c29124ed39a50ba42d513871c770fc0d884143ad610124716dda42a499de44ee07bddbe6190a184c169dbb14efe0cd0342cb7ffe52e8044240b6294662f6630c00e28bee61c1ab97f143b6fce1c4b162843536edc35d88ced83817dcd8a802b871ac9c97702a44ed77eaf4c7664d5b7f5f9894bd04bb930bc8ae9d36b5aacd256464d759f420273d5a8232d592285be2fa852a8a8fb759b6ba248759399560d8398cbfbf37f6c906f74d00dc04a87e7c05861b09897e46a3325a5bc677ec1546d922a3b17042eeb30493fe5d6a648ad7ea14db2a5e25926660294bc3a7be14d2ea50af0d7ce8edf5662cb0bdc7ae382e3850b6ae109bc5a03a31697bdaea79b924a0a189859155de540c9ec049da45dd3eec6e76f3996808f9dbaa94d4cbe02502319f16f02eb66afa9dcd989b2714fa9cd08d348006c504647aff59ad2567d4bbdc4f1c86cffcfbb8e16f2b9945c9b53d7ab16d4a54c64edcb3dab5bc5f4aec2a80baa88c6a17378f4629b2aaa2011c09a17082cecba362152b3f82587322a5a56eeb48a44e9b783a283569386f439065ba428f2c5f10a499660cb3c9a26229b7c4f5b3330d003ecd967bce4e6cd5f0615d5909e9c26ca3e1e49f777b6dac9be42b058b5d53ffa6c45ee79e39ece896c027d9b9bd8e20e0d36c9e3ecdee3aed1b477899b5bb36d23fb86afe437b67de77119e018898b0e954dc4f1956c7f84a233b1b2cf1bc5d071fcca0b99b82eda629be48ed12ea8cbf7a6d20a9378ccd6204162ca499b97c3782e3b9627452f460d039ddcc1212a8f21192eb90d8a107443614241c1d51a96c8b931853b1f4b637e1c41f682d19e63be33b974a44be672c905d7219f25c26d79f38d4d340bcd683e5f920eb9f131f93137696ddb27cf44e896036e247b652bfd27535a1b4c4a2f7662321ff8f8475dd3d01310c3546a6a3ad61431decbdfc5eb41b0bd3caa31e57592c563acf3b0b0fe326d802df9259a458765557e7d7afa09d501c630299fadb41ce18adae378654d979bb092233a8e2b6fb231a2b97e85575299de50e776ebca000ddeedd670b9e611f4727c71e0b6be4737d633b9dc1375d61b4d606fbe62a6c8f23e63e7031eeb8da916438165c8bb6d7677e3f3dc92f6f61da2526efe7ce7475ab3d87a42a4f02666da9ecd72366e3cdf073765cc86f5d95fe3f14ec8c957514f66f1c2d96273223bb53362b1df2600a7d9e0d5084270a9c1d3e206fb1fe76779b72a0f6f09b3c132948d6dcead916b477fe99b1d4720e5594a8d19ccbff27c9cba7b7774c71d0082af14642641ea853c02cb6aaf02e32ffef7a97428189f3b781602b1c77a35a8b2b83e6f71e9aef9d3dddda3f740f722ac5ff33ef254aab81d99ea8fe4cda0f973659f9d1603ef7970d95f54f0bb9037879f995916632676570c2ed4cc875c86b6313bf822483d8b86cad911a8fef4dd77056a9750b4e6a080c9e9846c1aa10753380120edbc3aeb9a0ae45cd58f6a4571458b0702c01ee2d20e114a20d8397e31a5adcae1d0578d737e9ced2ceb9224ac5e0fe3c8b6db5dd9d917288f06a41a889498613c0ed97ed6a13da677580b30c0aac4596a17021d3e4526f6b5ffa59a35cd07f0395774e28d2777f42f9b1700b1405ddaac71730972dc311ab9e9d8e94ac3e77f517dd2d75c0dbad9f821da96bac920cab5b81321ebbd94a523f2abd64b93156bd318e441ccd35191d4482942557def6291ae906c40d2c9ed81547b4922ed1971bad26a49d3a4e6547e1f4dd23c8ea39c046f095952f0504bc51e97a26209567ec3c8cb3012753ab94ff568ca040de8d80c29b45b79d28c3d7b542b460f0bbf327521e63ebadeab5cc7d51e6934a4a37c7c0d84607c65ccdabb9aeddce9640c15da86bc6c2b9c857870c0487106ffd9572e1d5cb707d4eed5459b233ef95054c58136d257f186fa04ba4b5cb80e15ad0c14799f64b51f8ed6abdb58e6098e8a76d6154a8d3e5c31949fa3e8b787c418a869d3414dd3fa668b88fb061ac2055a26b74ce15ee8cbc8016fdeb82a580b6d4485c6ab80ab61e8f3c9e8a22f9cc2732f99f4c9654ec84434545ec5f896c8f7158297c31cb198dc359ec3b7de513fdd02f9e27af8a6b7a66ce81eafc9efc2abd08bca41bd3d82f4e73ac6e5a088f2fd0e2bedbfb288f63c629d31fbf40457331aadde488e8f636e2b2bf5ea9f7d6988b234cffc96181e733e3f527ab96ee50ff3c91421060c8ff63c4c6d93ceb4d7508083e43a163b9765dc34313687027c370f0f7a5c4c2e4f89226d54b6c4ce05a9f4cb8d55d17580ff89819fb83d993a87c70f1bc02d2cfc9eec4a0e196b6677c33c5f97059fe3ba6654ae3c7902a53d9a9688b83c5d4b590c7636e2bcd7c5f276f2a06c54b812da74a4bfa8c32704159e49b48fbfe6233aecac553d026800c9649e0a8b2a1e02693bb1dcd987f13c4caaa2e1551e52d9c503c521b737f8055d7eb1ee624520aec583cae96fb0ce6559138b611e32345158a56cdaa1f514b0f2a310954934203e6303e79214d11d7469eeb65ce95ee6b957ca9c7c8b2ed0dab2e0fb59a51bc7dd2c347c83a19856cb327dc5404915a477675233e0ad5980803f4d8f260f2e87fb420752dab262c496c4a00ce2b9c624c66494b238a39bcd98bc000caf3b6b7fcbfb46f55d9c361a53e38ee612c0ff832f8d00095433828862eb8d6c24ef999103ce0c27d9023eeebbe5cf1d00c1b56722cac2cfccbf18573ca8d4a55bb521763e259759bf1c12b1943c98c0a037d5e2d1e8a880c555c7d36fd02b1506fad09ffc7209a8be2e7dc6bdd36668712ff54233552aaca6c9840dc1be08ff3619522b9c1fc289041ed537f34ac49b2de05f751bfd2d6608b9d1bb3175d8d26c023c25e5a1cb54c851b0e3d63ced0c08e4d6a5097fbb3155d3a14239b35c66e830e16c47505b7688e88648ee277dbafca29996694b3adff7e1f03901f952be93c4dd293f89f09c1c648131bae32a269dfd63f464fd83daa9be434a4fe134e64bd180dfc276bfbd9e34a2c0b1d060de6d01e2c65074161b14e7a90a5c57d96b6cb69038aa3b9b85929c604cad25cb97a5d97633dbbb2a62520f0eaeb08b35d0bfd93e4d4348d9f3630afb711320ce1573b2f62fc1d996da601eda16144325394efc637438fa44ae3bac14aaf64f627aedb3d2d04110db5654bd59204b6d4408aafcec79a73c0d16fb59d543a5c18369064d6a434587525711763ae811891dd7c6814116d5ad5f36b3aef01fe2b77b0d79474ad7e88f61bee3bff6112b37f17643020b5c122ef8dd89b995c50a54c3f8b8504b2a4b570bea1452d3623692cb1eb71619915d01cfcd8b370bb2d76b0dab338640a58510f62aa10e5e8cfd5c4550931c6073611ad9d0491298d3830e6a858de760527f8dff51321f4b3348ad1cdcdc2e5ad9e9bcf470a4ee1ad06618fa9d3900f28a65953a6141aae53fcf271dec3a64836a81314c2d3ae574a53f98e7f6990eeb309fd270206d4b6f7880dd80ddcc3a13dcf8b8b62827613ed360a8937f40ef94473a42383840001f923e5d2699c8776add82ea1dc06402f1ff8b3f2b1b3c5c665a98eece55a4981402487949fbc44b10f16566120d48395e3e1afcf777e3a0396e46ee1a3998e2432ea31ae9930d6c02e371a251d4e86ad132713090c47406077d105b876c845afcb4fce2db0bda606038aa3a02d15420c0f8aa5a443ae59ec87ab7ba789adbfbd1675024564851144d1a2d345a1bdc270abcfd06bcd7c6c920067f2742690386ca93403941402f988b9543cbcc1d93c96f4b75a06ab4ca35ca06f35e680046831b71b8e566317b79be34bb757f509e6af7378e2d9d307de4cf8c27285f423cecc9656cb83a473ca575c8c092734399c64fc2f561b958a134fa5cab7fa42bc4cafb3f4d41f9c076d31af94044858c8942f70e9e771a7898c0f0799af4205fd32f60b3c52d35106ed032a7b9a3edd5dde5103ed371fda2188033058d31a30f2b2985a994d0533796e693192ee40a818368d75caa5aee10bef57d870c43a23ac17be690c403b5482a8f9b603219dfc0c6509a6a85168a057f3a6fd9ec0da2902a8bd13a92919535c479230dda5febce7eacb38b41ac07a3fd5885820a0b58d88ce35fdd1043428401646ea0d98a6da304b913dae400fd66724523b3049bfcb3e458b66d9a85de941f55db1fae02b0f0e72a782266b2b1a1c56eaef366b74efbac2dd12b3fdc71844647389aa9f2e618e63b47d2695a0dd77502a3342b57ce6863d340d4369cee33af1de40723b4837537f1d4715bc3d5fe016fb408197ea806966f421f853768d0ea1de3ce46bbbbfb12f24858f361f79659adb84d48ddfddca6a222c6f264fa777ee106c866182a38116574d415ff9465dfb6dbe4a811185833da20727e09e3c45f16d6b33133c1b9c98b5641c2935f6f6f3b8b791cd1c2d41d5ddee627ac1c518d2cacb3ca7d544140b2cf775beb56db4606e7e9ff33b177c363ab60a5266e8d3a792a929722140328b5b3a08cc4370de3a76c4484421130f7c5ce23af838551008967c07896578fb2653f03640d143047b624e048ee11dd361af5c35f6c057cff80a633e11c8710fe2cec21179e782f1daa0b1c4724ebd2a8862c7f11a23ef84b0f2cc931a926fc533eeba6448b1c154c7f0e4c37b357872b6e944b5921735c7883deedd7991aaf9baf96c6475576c5ff94e9fdfae19bf5332026af38a566e6df61d7788910c33dac74622a830ecbd198c737668a2b383e5f959dcc3e5524db3d031f18d77468ea174eea49719ab201e8ee5a6febb1496825d629c24dc16c0a8c32e9613945c6f2ef73a027ebe0185cb44ca49b70d63479f3e011d495490b77fba0f56f0e6fdbc651028bba937b13d58225c3d167b405978c14307089be76a85724a83980fa482dc72cbd398d764348afa9f9f1e8f2699fbd8c1b2ab67061a9103c1874ff819cc0e0ed16652258ddc4fe77eb64a32ca36eb4817f49adf594fb00cee4b3c8183472a996e676f4d3ac087f105d20902867922fd8bec81d7397acd4f078ef720d06c109386f9550c500dae450f10341b6cc1c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
