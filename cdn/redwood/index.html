<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2467ce6fc2216d8bdd892e7a40ff84283aabc6801a56eb599179a89451ce11f7f725f44bf8555264143f11b6dc487dcb6e743fb40d1d029feb52ae73d46e6083e8bc1b5c785fc7462694488adcfcc67cf8b295c0062ac98176893974ea194655810f8d6a9833ffe1f537cd701a9268f94fcdea73de943b6c3853230b4901c0a501829d434a780d5be4c70574571bb9a254f93c2b7298063a7c5312436717465a9bf080c05ac165448f3ba58cd668fa064bc583fcfcd716871586290540b12c21ecdc3326b17df2fa01bbdf3237152cc4cddf5c62f996dbfa2b10e9e44d596ef5441bab0c006cdc1fa7083119bfc5e6c84a42a59a4760bf0051358c395de00fc783ecd77dd0b79ea9b63a4f7de21963a23e068e5bbfbe3864be4dc4a4be6878503d8357cb222561ddb3397b838dffa160167d9d5020b2a515be3d271ec6f58f96546916eecc16af1b5bbbcafc3646c31ba6016422b6d40cfeed38a54b9ea4cf1f400f86bf57a67163a475eed206254bcc57adcc002dbe16568ba57d705e90c115abb8219b34db6fa91de80158f5fc6b837f55d10eb72760d8a0b389f9b9761e4ca0bcd6eb5e7c6fd93dca18d5ebe614183e334df7284712ba7e83b889222a0b875e41639b5fd4a8dae528f02d9fc7d3b7e88896947ff8ed958b915fbd4f4d7990c6b630c1760dd80dbf522f1a94877002d2494bc856cee5d0f4629a699e3237b2e00db0bc8b533d8a53693f327527aded183528ce58b950f1c7bec4608a93b04dc2158d0c32388d32271fd6b2a04fea82e9a3b67bae5e715c0abe6533952a4ae8a9b17995ed57bc1b0be4b8c9fe1f236a7fa62c2c18e4672f1c67f594aadc534c16723fcb9cbc51d32c72a85726bf65e5150cfc5299884145d4ab780affd0567d507906f8b3ae21e5f988e256ae75ec855179e54633ee08aacafddccf2f1ec684866fa935664ffe67da1d6a53a1ec43de7a4549f72055787b2974d9563cc32b67f68133a57e61459b61f6ef8037222fe06c673cbf194f54763838b340aa8c4d6dd5661cc484c8f71d864036f2be44fab132a7c69cbc0aa403403f049af578ebe51c4928b37d44f93714656961764259db722a7f03a6be2df724c6989d7fce2112b47f9a7eb8b2251e28c5c5cb02c4c847c9b4ce81bc1b983aaa7cc76838f00293b395d8421dba705d4b4fd92e401f2c3561449cba227bfe5f8c39e65c7b8bebf85d44434b48adab23117b46d57611ab081f8b71e379e3629511a2f8665266c1b2cf2acd3ffb14e74355d03ec7a1735905485b726cd917cdcfe97a29000744035b4b62af1a5373acece5890980f95570a01270cb7198f40298ff36e62f7cdeb359a3945d246e1631ba6fc150296c82c5cfe9809bd1686ea0ce57bf1c690c58bed9e0d35a9c9b322bac26367bfd6c344f26bce6a014c0026bf1509ea51710e92c59b85832181d3026fc2cfa8bff6d284c3909e9a08d4bef178849ba4b5d71efcc279ca1fb750de33b866b5daf4a5735aee8eaf9a4ef6cefe54a6ffd2064d6ea72dbb7e4498ed0f6779c676cdd82d5a2adfe6fc10e8281f86f37e146d824f65d172d13f80949a14e69b83e566523f2f2307528646508e3d8ba9a2483c0de133f49795b8faa72523e44b0db63511f089947258af6dcef855db741d3d5b00c13595cf24347a2eb1842952488e2a43ae9ee40713df8f470c891dcc5d881e5a4571aaa74ddcef94d47139bf1eb956be7a34c39d0f5aa70aa73221cb196dd5f22a9adbc0d74b8c1a57a61951bf4eaae6c3315d80771bf515e2d146a08c0fb5f36a7ea81a36efd6cf94b6984da81c2fbc92c4e6d6e3f44799b56dbda9ffb76af09c50165f1c23803ea5de92bb3c6324ee899dcdefdfb25c90ec45134019a6b42d251d0dcbec8b05dd90d42943a3b815676013153656328b910b195a62013601d3adfae6549321c8c5e6adfab98f82d19007442b7d3e5510492a04c2d12f379a9c79b8a893f9b45b97a9d553e0540ce1d0546ff3fee3af30a3ce4f572f622a14e3fd2d633fc07e37eac44f1a515558f2deb1e9eab4aff22d599f7bdb9f192756934b45a72dd4864ea45b74a371cdc74d022ddb65be70d410e0f18fc887725f07a017a09aa8a957b34a516f057e490e786212af5c9e0221a49c9d2a7f621f45d9110dff9c8bbbe1e208a092c026ce6665f48b2ff931e90ae3223da6486d78f4500258473acce5d5d1ba3c7967dccda0fbc0a9304876a2a42d1310682d12712ab0684514805fab17598ada06f1f8ed436d3e914b895d7c130c36dc4f41203d972610cfedf7f97ed4a4c11b712ddcc9bad64a7ed4860948e74bde72ce091ba539139da2b1a756d2f0ba2bac5ab0b5cb915e414ef2a8f7b41baa10269605bb3b62aaf1fc23d971cfd86b6d22c2466c585424325785c7f21fdd10cf419155abd1a4ff4114f697cdf69571a0469023cdcf3f16acc5afe79541de07339493889223a18bc2b8313caf597ea60d0a72f48c7be4edab64bc553edb6e51556f770bbc4db2290c9624ce87f7fcc0ff20d772b5b108571a243974d08435203ade3aadf83c7efc3fbbc750df9393b5a84c2303ac8830c10076c1d2713b106ef6f2a3170d20f6d8b34201478d0e1eff52b77b4d5d9e343752ad4a76a6f9253e2baa05f5b001073ee5b567659dab6d548303b7d7ab915fb3ccabc857bee6ed83c67194095cdcbf52f8ae5fbb3998848fc0f007513ac9be46a822a90a9e54892b43c1033dbc8425e9cc022015604f9f02fcf4acc9f2be5d6418b6ee4f492bc28de14f213cfbe15fb1f495159ea0edaf7d8d0bf8cf43580ca976931a4825c6991db044843c851eaa6b9831c41676339cdd0881a9896b7c74bb2dea7cd3f26e4cd2960ed24dbad826f2d34ee3ff92300d964e07f5393f286776d1658af44c19d570a87d560d3d36a999941e475fd1b36813e4ec3a0ed12772be6c881c8724d8907b971e9531ae970656aa92d5dd86f67dc89f69e93de12a93481e17c7f1c56d82c1f9a37e0e8e1a31e1332f9bce1debe47ba843eaaf8dbb79bf0c4c367bfbd94a122f96ba6990fbb08fd65d97ef7406e2bf409f13d6749116216c1486f569d0b8c1640643a815cf07daebe0ec8873eae6784b21ad81c6d94e8b10403ce1b4104063d811f4440fe4787634f8f491bb0daa2fbfad0759f3dc5abeb3e5dd6981cb9de225b41bc672e2035678f1eec39557b26da0009b72c97116ab1c3c13287869b1e55bc2cac1ab1d0e079c3490736fa0c8492bd2134222e3b3346559e541039c91afe30a4cb23bcd5ec984921fd9acefb0063b7667367f34b3b5010234d85ef007c9b461ff565a95e7a7d3f8e5bf297c23ffa0ece8f805a72ead8267aa01f4e7efa46eac8557e430f5e970f1c8c7385d3e9b748617be434168aa10b3b3e29ec4de0b18915440a3f3ebbbb482b0597758cefa230550a856ce5ce01d17d085e9d8f38fd557654762eaf87a2a2aaa7e341a2c871172fcdb52e4358dcdbe6b1135a17309be434284e33be92ab66356316ed36d2827d700e0d18b73f2b5fce493c9887b57246f6303686c84cb5708e2523ee06709d42b0127a8bbd02aa37d813ebbb1758778fd54d039b90e22f19d4b2bd737482411300f48dc67009aa8c8198b83955ac1871792671a8fe57791dddf95f6216b33f62cff35c6933b77e9c86e0acd4b51612a516d570654d076fbb2db3d28fee69956746131dbacf3ab1ce25d48f0a6e5bba760c31e08fe021f8dfc5a8437e688411e81cf26adb32ade05f71d1f431a6879017b08847f00c8dc1e4c07aa3d82ffdde1482898b76a386e6aa414bec78cb35667e73241bc4babb2d9719664f5f912e781f8414644f7d8f2a15d0032f791d60374e2ab44c6fcac2ab1a72b8229d9dd516e4d3ccd6a55f676cd7409ad8c60a0c10e05ef89536f2f28603b458f29004c7e36f989ee36baf7a12d83393e0dd2330a664327401c609fc10eb1473bb749e40e104244c3e71540bfc3173b9996c4ff41f98e0a90f56fba4da3a7840954ce817804016343b0f7433c61976f6d1958e0c548c5cfaddda616096b2c3f6b50f26d78d255598120584edfb40552abf8164ae9faa9a11ae9c3ecb76bf2d3e17ab1343d4d0c1fa7b5f216fdf1da6c5657d998c13d4680130521ead303a784cd91e0ec1c8c8b5c049e531977e3ff0b1a47ac68d9298ce3df29a4ace6b1ae4cbddab96f20a7d3d4c4126ee538a7716be27bc5b55e4622a81a40e6a21d65dd84f0eaae5c89704f446e0a4ecb97d017f5d851bb4a91f5169158dcf2bb68676e338d35eaceee8cdd6144f93147119bada82283c7b9247f8517f80bd241468db8cfa31f9e6722b479360dc17c78611d8cb4e9bd20f01d4f1f754a06a4e030d5a03cba1cc2a37c72287cf3e8468b39d3b5f3480a9a8355c18d460522d4a8a0d07d2284e1eca3be669d26112c83b07c6feffb7cba898e71cdfeaa06441314f60aa0092c097919ebe450acca33a268c45cc55c82f6831b0324359e471507e53fe56ff82eb7b1fe17863187ce7c58bd4b73add2f048d7b297fddd8bc91556376a5e73b3fd5ab516235ae2dcb2fd5edc1f14b718fa7e3592e0a1a9bd8bfd4669bc645d7855a0d94ce3e78207552acd1c06d0a507d903605da250d0327c68114d8b837737d629c8f88a81359cd7dae40afbb068ff3aef1b2a2325a4e1871a9a3c85f822b22a9d6af734714971939795e092d123a03c120e8439b1a620e4b69e517dfe149cfaf764d0056ed18448ffd8912d162c0703c8a6364630ea3a5e3b9e3a2e718872852060b01e6942a50cd209e12e93aa912efd5613078b7a84c93af8a180542403569f73b282bef00e7757e6f614f669503a2bdcc68322910ef626753840a624083d6ed4733317c003c01ed91816e0129cf5fdb58f2b7a4d219a1470da2aad0729261855680bbe8e3891cfefe5efa203a6739f424dbdbe9d7d3036febac3b4bcd48380295072ecf760c842f059808df35f9b56b34ffd5ff3b92a5f07dcc0f80c41fc64e4f3cf9ac8a4b10ddc0415c83e77a369b6cadab3de4b4f984ddea1a1313e7005c08a9f710db4ae73f7a27ab9c16f9b2f6f762984ca5d91b3bb2cc85cd5ba5d228e37287220dea9b42c553459f7be96ba7aa035e25a57f8c20211b2476fd7b324af9825fbb1d86e33cd396a15f1299a52976fa1f6196d5b9b5905f1dd35a47da9d61a238abbcca5b461a9d6541176fec99c60fee6e2659f4e0896c6415c950d2afdedc77d642fcccdacfbde745852339562761f75679c8635651ca9ed8d997077dff2a61c79ca6d383fbf14e2bb6b71867ae66464830557063e124a4b0f872da9dd143ad2240d354304be2e7dff8b7411f48c37ff02a7d271a8e2eecccc84cd72ef5bbab1ea40f600a2a4917db56e5c66f5c260d4c6a8381ba8977a8cbc5a63c47a02a58ac99d5369abf4b5ecf887c1f4b3f47fb5d1c88bf4d44191ef9a4bcceb9e6f309147b363a88740d63793b6f03916c4b2d70a8af1d5ace44ea871bbaafab95763282f9a31ee206d397bcfece270560c1921fd174e059d40f1d01dc470a6cec4570caa200574d0feb9205d01efe16985ef6285a88d06d63d1035067efcb96fbe8e49f149d8d015e79fa3a91d7f2ba0a996e957bcb53965813930fa3f0e6cdffb264cf5d2fc8f3b511aa21dcf1ec182486b28549c73e4f76b5f32dedf2eaa058c0ac0632faf5430b3b57d4a97f6b1462bd13ee9d98701db0cdb480ece8d6a348f19c1c1d39acb4cf0e01fe09d3b3aeb99e47f74d74188c6c38eb98b05ab0402619b33a7d7c77e752e6327530bf01720fba3b719029a261856e87c08d4e71dcdfb01e74efaad983321dea5fb0f4df910bc4486d70b300821f4cf2c88f27fdbf3a4c92a0c61d5cc2ba6dd90fb94a411fdbdf544f2624e9bfb0d92d3135bd50d9af2817f598ddef5900b806451923e9673ceed19da9239c8a510e957841bcbddfa6f128e844df8acc7ee0d9ae559be65cb557f9644d72229c7617df9d2d26267557aaafae6d5c1c4754b4c86bd880409d553d09004c91d64310decd2187c992d14e773f4f4720e40859c8e55d4df6240dbe522e40986ab1c1f187cf1299ded765c85d7d922a90cd9cd1534c21ef4b1484f65ebaf602d10f50d39c53e63a60f50f11e37f1c62361139ae1c03277156d5f9d7d11d7428e49c12f74e3ebda02c418f173653ff2d2163c573f418c90c7d1b210d813a14ad66a88af4be4316c48db3dd3f60c4ab67384d31fcdc13dc48fad34205692ef4efc30915b457357edd258b7b1a79ecee5ddb5873ccfb8122d47df497d89faa245193923b97ab6b84600c24c6d253ab2cee3f78b867201b3f14262ad17ade6d3c16c5e07c07cf1cc88dc1832da18c9c1ac4dd112b6c5249b947dc24703b3a6a4d15f77d491a26254b4ad37c708d72f625f2347a84d8d128ba8a591dfc02c38a90ed7a1868e511a7148733fc8091e2434791ce0c98a0bd7b8e605da63b1fe150f8b5991f63312262478171d52e2cf3c224c1bc0f1553e6b4b0ac33e17cc6218fa59dce8220ee81d3d9d24cbfffddfebcd97eca79a5afd7313b37e8d36c6621353567c2b968b85f5b515f648031fc95d982994af263e219a480b1bf40f36b0fa93cf3ad18820b786b9afc2155b0f599c5ecca9fcfb17c2d68596fae72ea14e7107c5465a7b58277e1d2419c0a7d49375afbb23c76fa237d6c02f89925f76616d63da7ed1280f0f711f80d14caf94cff64f568b00c1272aec73c20e66473858d5415b90f6969490d3c500243d5f65e8664e7d12eabb630613c1fa8b07411e5701e6b186223ccac5b0b4cc2af3759c4104b19c02e20330703581e5d6eab6b31684c84587d68c5da36192d24b509ecf0ac00f7f2651418d756789444aa70d828c4d0de908aab1760587c8475a312c74c0f356fc6a561cc1223ca065c009c3db5d0b2aa5d28ebb1392500ff72299228753a4148cac4a8da12a04c8d3bab9e4cd9b1ac48d5806c7ec9386a2c6458b6e1920c563d4a92e86879b5c184d83a142d401fb49af205a8b965920c76ce7b7dbf32d43e94f3208eb98e13683d493449f4275d857d5659934e2d94b652aab731cf1ccc0cc13794663d1ad3886220a7988dbb6522f801325a73f7446c78a572155da31b037589d0d1a751a324bd46d85d50ab5dec3bb3501f01909857e70df0414c75972feebb47544100ce53f4e8855353727a0a5e56cc06080ba9c08bb6a1daae38bb51356c37f513bc00ea501ac46ee31356ad58e4d6358e32c9f69d9456759b191f12614d324eb9ac4c8703a0eb113a56782b1e0cc4136fb1c07433d3303d09e49d3b4a5a0294f01854e03194f1eaf5e6780992968a6c8ad261fb2972ae0fa6b57c21974869c0c10115d78adc3ab70f82c8e13bac32b66aabf9437c16b596f5bb0120378d258c1fa339f850aed30be40b2a72310cecfcac19896acf9313fdb4440c93105d97f419add82c6f9cad8db8978ff24fa64fc6cc4b9c1d429d6062e8965cdf3845ebea3aacc232d45fad2cb707e124dee3bbf8a4ba8fefc82d6ebaaa5ff363ba86aad62159b8e024c6e4a3782d8d65d7624ca86e0cf607bb89a59930a48d732078c91f44606592f4fd9d24330ac057ce57a1f7f7425bad9df2878d34aec496e6fc5b4074fd3d8993eddabeccf6c81a20b03ea499cbee720a2a5f15fa85714cd9974aa2a763f70582d06c1723cbad4b48d9541cee53a32c31ca0b10bc1374b6b397a0d3fea9ec94e62e1041ec9ce0be0031bfc097bea81ee4ac8a36fa9dfce9a36ee490aed09ccd4f894e551603e7541fa01ee36dbdab452ee1db54a9c59ddbcd324070855276ae1556a8065abdd53904dec30972ce6b0db9f9d079d78d2783abbed3484f10f5e46152305040b32d371092d38a23320c9caa5382302f321f6d8093a8b568c6cfec3a1282bab9d0891c23ed1eb127c3e43faffb1a8f09664ab8ad13b928732aa5a8a5860fe0de73ee7bbdf7e90b7f1554ef248f9dce76532963e1011c7a1ef5eb06642990b77aadef25d6f65e26236888fce8f51c329df2923c74d42d4c20be33a563c9a9bd9b5af04a649dbe4a2045563ec85d867fabb6de0ae9a85f45170680173a1c881f24987ceadca3a09b29509094ad5b19283258fa5448cd0a7b1d5c682fe0415df436c942d378aa8a967b54aa59af7db64bd71c1c20a4323a04f9c656d0ea13f680e7cd67f6529c87d79033ba0ef05886390b3ebb92054481824d6e1d642b4199b134c1efd075c9d87cb19e0bd158bcdbcc582320efc7cfd5384da41b7407d586927dea2d1e121b733e8569be65a804300f9af40490569a58c9944f9c9014d89347f8809b232a8231d08223bf82b3c50d512eb82c1e0bba778dc1e21cbb7c0066dd68a98e45e05e31d0bc5f4e4a4d48c513c1c9e55d1eda0dff7fcf390045e056df89d8b491b95c5af56e4bf53263d612f8f32441288328885b4faf50b3dab743ff16a1eae8ddbfe969b9867fe1d401068f7221ffc504a0cd1dd62f72637c849d1cf74af4fd9f69e3ada33db1d4e03be268a02fc08ffbbd22d0781e884bcd4862078b8d02eec44e9ba942106c8d8b19602e2c623b4c7523447579b00ad51ca58bf52367118677b1924514dcb704348cf1e5637fed6974c4c2c7b65b1f5a11340c7c309dabe642d09884f094499b3cf985f40dcebb05d579bc8ab9a908836c4ddea174f914f55d42938975d1374ffdac3f0f24fef8be05382f63924b3f5bc8f16f6f48856dd288ffc370fc998daea15364d0a7408ea6b8ed54510c5a388d643643117aaf92627074f00f2ffcfe43829bae541bbba669253887475e033a73a24b7560ad897630fd90f1578af6d17e52b1e5eadca61621c446ecbc1c5711dc315f8f6ca1232952cb720d056a24ae4c4225ba6b69117da8d8f9c1bc15022b69a581bdec0f3bcb885a42bb1b046bc37a40c5f92c5e5511ab989319f4289d9562de5d67ec798659f3e4d8413c7c84888d662abe68df1492004ecc8b8e5d44c4d3a55fcdc9445b9a03d7f02d6c3dac78fd8dfe7ce80b8ed61153a88391badf48acb78d1286b2a7cfe53fac54638a9665fa7e71b38627aee867bfe1fa2ca30ddedc1cad644de4c1fa4f28fbcedfeacef10f7d7f479c7a5ba2160db31a8ba5193caa5fa6a960f3cbebfeeb9b15436647c38714512aa837a98666786e0a0f749b16fa9d5adae6011bc6e93c83db4616842978f70b09f77fb1500edcbf4fbf45ae28181f08b6085cb1a6fbfb7766b11d66d9448b6176f97781ec05bcadd9743016adac1a83bf782dcf3bbb9b75a0c29f31a2f64ff33188446791f5a9be77f6c1dd73409c5abe2e0bb89231f02dba7935291136d218e75260e9acace6d748b9bde650a2a49286c66c95942a3914ba455a8d235eee5e84f19f28d86555c6d5fe2bebd5192038e22aaf35182e6f74a94c868432ac22f0d13a080d30b5a4fd7aa5c3df527640668cbb0e7f58aae168fd9257d531e6792a1ba373f3062377ab1c0d5893e801e093d463b77d4ac1f1f5e3e4fc85cdaa5a09bcf5dae133ca7cb10707472ba91e77102a7beb749326cf983a15d830ad3f72ce6ddf2be924d1f51438c25a897ef179779d27441d6ba2b9c529950c1eae1b82b7eaa02e2592b1dec40d84e0a63ceeb59c94b1fdd62df0a0f0b464b0d2fefab263f659e485ed281b982fb16d8ee9a6586c2b8ab962908d3a1e087af098b2282c8d3a8b57b83580447c346d1049557ceb203c4fcb5781d8f5de6df145590c112e0695c00247cb084a6b0ddcd645ec2fa3c7f8f05b28f2c21a4fcfcb51e40dddd9719a034e28fc06263477fb0d849f3f30abc2e422445cf2a267805169ac1acbe91189c2d66b87fff1970f9b9d3c1ab913cb8e64e80a62ca4cd01c1c4ecee5a4287a5e90b5839a955bad2af16ce0b65a9603eee8aae5615d2a844deab48b3f5e57ceaf68f1c44ad84b8eae4067eb99337bda18d9fa4e059ba438d7236a097f1edc76a991d5a5602b615e1171c96b90204df666dfae8953821382965f5af9d49e156d1d38424d040454985a9cd5095aebd970f5c8fe48dd0059ec6fb872d94e042cb60140356f7bae358b9ed9e58010354239953fa3747063c84a627cbc03470c78a05157b0818328a7a8c975f250b3059d558f6625b74d00f1c7cec20aaf1010941031aabed9c1828490732789b7b38f58d8097ced4f7cea7bfe6ff86247195e9e5bb36bae5b309e8ff3165e0738114b4220b95ac41a05bf8cb093e7b020827160696971c7bb20533208d70c75aa70bbacc70cb5fe9df71aadb30242e653f5efc7fecf7dd46d9be8a174d9f3027f0e4043abe56035c8d8df3250f92163ec911c6b76aea3b445e6bd6f2ad3f25cc980c4f698b0a0de9963ff5bca4f3a97fa337bc1500ba6d1429953bddf36ab5271db722013d1867ee79aefede9fb580cb1fe5f7b9dd62a3284a3e5297bb887503d65876f540eeea54c186611557ae6fabee49e238abd22fccd6a18e4f5ba38b1b9c1588f270a8335d2b93f521b8d9e3be152ff6112c8cb20dfebfbf20c66005da32a2a570f4cbf194a0c92a82588ba39c1c1e002ae8d267c22a56215b50f6c976a11d8a0e9e22e8c026e11685d4ee4afad425af387d98f5a5450aa99c9c6fa7478e38282441522db24dd0a322ad9fec034ac231df4b6128857d80f3439ff654eea032bf862285e9439a6dfaf3a34af1adc4c5aa309194ec47c7ad5abcc3fe062658b54a4529208aaf43385180cdd5fb5a4c98f709dfca829c79219071a998755f956b80b99066b63920ecc0ff4dddc1785bff278ba1a0aabd126d24fee9583520aa3923627f783e4f9728ae39a657d084d965dd2a9d16a2358f6a960c7a926b8160867aa3367a2ad05fbce49f0efa4497879e8a0a12c498464c8f93d794382c3b2e9092cd70927031dfa546a0333bb0143b94f55cb3ab31297180018e348469995cc46609b6af4e76b7aefbc25000bcaa1b16d774d434c52d1c68bae55517e9d9ac812e1266c396972d07b893708fa5f965af2c6404d122dfa9ca8ee6b08d818f16a82a4f9f450d7bd35992e43af8f5c5688d6606216993d6076ece1e24ca1880e13d9bcb11ce42d83843679d4ab201a37905bb86ddf992001e986cc17aea6f926a88fe74b38e28ced3054482a791be2a0dbbad002f9d8687d4347843c91d1085543188a269937abcd084ea37cf91fe486d07bfdba0e2acf64ff4467e18b3b46b7a0ce45cd6b917b15b40fbe2e07a80ff8792c6ca434d68603833767f652df259f281a9dcc9c4e97bda98ffa60f5ebb0a4b1e182b506e58b32f734dadbe66a4b6c79a2ad7fb0cb9813332b93a16afc63ded6fa04a9559e31b9380e0ada5e37364460b6413bdf63189bd5b6467bcc6dff646ed4e6743d623fa33c4af46f11a00dcfaaa814638eb6d0a1c970c9b735f0335dbc7a8bc17100220c71e902e582d50ba5dc4045fa02e0af456c691196adbfb75ca48df0d11235a34703662efead20689742a0bf9940ae90211007fdb3876749814272392690981c4aafab0ec33cbbdbcab914ae10a2b72eb012cb9c57bab0fa0d14a36b5beeb3b0cbdd56782c8fabb5f63f0e673a9ebcd6ffb0941808aeefe07e6ded99de80497951e48c3a6ff0dd1a00bc63222a3a810e1f07e44582025e61474d3b9c255abcab36f5eb0f6256d27d46de30eecb99f94c15e129c0a9ec7b2be2cdf7244611cced9a5a73ec1a532ede85f530b124e1f92051b48c7bbaa07b28c655436d0340ed86d8feacbb2411646887b6d5e417c00cad317c9500bc691ef5d5f0f6044566fc182c72c7daa9956d1f3a0aa4bc339f73456b6a6824d18939a413af394e04f2e174e554c0128683560892abeecf3815bd4dbb6d73d4a6dd558f78d0fb48d07b186fedf62e183ca65bd5ee5569451be31914cff84694906c0cdfa7c3bedf14e277cb81bdbcb8259293c9c9320bd6a77319e5d9a7e932c3ceb2aba6a613d84aceccee69faa3b5f8c61344dba7b46f9c3842aa1595bd966e0cfdf714324087537459d03641a4c8e3fe2dceac7cbc860b900b60df3a630722e6035624c4511bd1c83f6388c2c1b834d613c6ed6ce1418451c58479d9b1cff8431e8a86a06ebe10c767d4651635f59d9e074ec97da911522e3d07f8e10edf948bdc6c35df074c6ca78713debaaab60620d8ff7e722f1dbb4da9c090e5f25badc36a1dc93eef5d16685d3944b697cd719fa49ad5965a2c2ef014b57655160a07151fcd97ecfbd980d76a95c0adaff370af3beb870adf78d2c9a70fb61b144bfd920e48ce2e1c671b9c20c05b9ac72f50eccb4a6b249cc47ab203c4c4d7d7035122ae2ff960d6d6b602701a97b1ca20ba1285228213514fa82b64ea865c7364cf2e51e61b2a9fce689fd3ccc7d37e4fc2f551243dfa09618a02e9be0c4f9bd2204ad8b52f2bd55545d476e1b3b926ce6ce8c6dbb793eda0321660e398024237d1225271e5146acfa539b44fc6d695c2c6c9e41e4a30933266f1dc5b113c0c5d848db5a436a8c7abe08b529ac1ea85520f79752bd74892306a52d637dcd1954a747d5c3b7624fbd5e7461a9c43ef21ff63a253e38e603088f92b5db1774fb54a57bba3e46e6d2610727b968b8f71d4f9bfc8579037d9da0e94214b18566f88bd2bf0938e62046c0a95004352fe5009fda9a4baaee1046bc24931d799ea3d4049680db6a888a85ad608619c6ac6cbffdedadfc68b4392bf6bdf608374ce60ff346889c55278081e14b394d6c0bab89772226140de395db130399a940c11c1a0b853e80fc9dd6ba5ab08f30cf8da250aee0ce26d86c58d41e99f60def9f2d2f1913b84a4de7b0da7952c3eae6049a59139469ee7687a40355a91b49b70628e68deee5eee41ba8494123b1f8cf41400a8af3f706f19c1d349930f6fa7a25d6d20f8608f46607428e7c99573bd3d2684f5caecc5e8d2d22d97a7657d65c16c7386eedeecfaff681df13077ca7263446fffffceb4fdb7b4b7f482ec57d3063b65468dc313c9b92894a2b551dff15697da0ff39889ef4254c412a5fe9d633f4c3f32104bcfb22328c135bbb69b4fb90a5e6110b00d607aff63c8831bf2e3a38269f2f247143ef63d6362eb267b5d64a979f238830c46be6d4c38805d27a30f5abd46f8b61107c12bf179a22f2c00fc8e8a96acfc1bb3aaf8a60ac33fdaae234e7fd8229e3ec45fcb3c7b8fa6fc7ad1a9deca6194dc18b66d78722a2e44020e8da14686b914ada35823c049d1684bc69de5abc27734a1cf106bd58e470887179a31b068a958e12adba82218ddf4cf0f3dc0d3cd625217612d907346923c97647ec26e009a0e9255e1dcc3658db071087c3f0205b980282bc1ac70efd65da567e02609ea61cef138be08288fc1b9a04c4cf0fe2c28f56476ff0cfbfd0cbb933519457b3ab4da9185de096d52b2ed51ffc7fa57758a68cd52f86c438935784d6294fee31f4fbf6256fc07da7ea8ccf1a21853a5263409df72872619deada77e6c192e64a6d041d9b77043bcff1a861ec37be40d2e2dc7935c702a85bc050430ef18ca282814232b63b6d51c4a276039609d17e394eb1e49541bd1fa885f3034c6c221800872c2bb7bdc500e51efc590d4749c5f086a9445d4b6ef3260452b1cf5d528ca8b8956cc6948ceced5951b142ac15166e9ef6a61c3ee9096bd761dfd16ca867443d48a2a3ada25b44b22bb31c1a1b89b768f00bbe5623012a7002db14b9b781aa6abcc2cfc5c3f364da107222f360750611546f2d496f5ff92168b86ca2d36fbe4c46764e4ff6dadfd4d8f575b6cc8355be3e2a9be0d0c73bbf28f07d95b4e2311ffe9883c1bcd13740851dba7fbddfd8406cd9b2fcd082ffc67abe208abd86f800fd94e196eb47ab926c24428473a713ec8f3dfd071c403b3321e0b3f54575088db189b96c7037ab2cb05c110ceb72e9557ddcf02c72dfd73c85b1a6094ffd08f19283ad728354f96b27527362b70ca4f8afbb7dec7152d848fe0055c30295a35aa2787e96959881b9e72b3ac3269918105c89f26bff1c276967eb19a68212f88f59efd7dc387ae7599e6d695a1ba8991013385e1af1438c36290031311d116ab6893e3b0f00de63fef20d3735872ae24ef69a3655beaef25600a79d064a3002d818277c20ef29a438642191f1091a724bcd4e810db314cddc11938cb8416c6e44fffef399dc5726125227e67f3e6fe4d5447fbee64774d1028f45dfe6abcd6423bbf3c96eb82bc44c6cefa092d5261b5489b17c6df660a0c26aef58bd939ca40c1a162faa99ce59c99eca5cceb6e6099d3da3f922933e2c2e6e99a27b55c640c27541852bf396e21b34000e18137993619387d6c1f712699a6bcefe296d6990094eccc52918449a842d4bc5a475c29b35d343afd6ca2f73905f96d067b2d5e492b2cec188baac0a0a54764d4b51635a172984e3740e30a7e0380579d989e8db9ccce040d15cf40c3ab91af59509e5324de74ac859fe696d28c601e6503c2250994160df73a6085e0e88ba19386caf433fa457d60dba1f5c8b7a7b64d8d9da0106aac7a229a4a02728ba7b6918424e02e29ee2c59a282059861e9628b92f322542cbf06f715d7c957ab75bbf74bde63665993448917ea0f4eb576e937d917d1edb3f43614e3ada50a13ae978a454a2f69db49ec57445dad6051ebe81f57975eddfe405fe750ade1f10afa398eb56aa95de67e825f778f222d40bd470ca3a8f1b3754c606705f97099b099d11dfe6ba0cd483597fb5b61b7698225b8efcb83120b8da0a86e532a1b061d8efe2bcfdb1f4157c3c5a2176561ea0fe58a14a4d301ab597383516f58f585395b063726ac16f9b47ff75cd18e9a88591440acdd23d670fce368c70622690c5f90079347c6a4ef274463e291a135485a0b36c11e91c5c1c4bf295a36ff5cf2685ee5dd28e1178c3f4612fabbd5f10ab43727d4703e7ca84e7f88d1d772f347df530be5036cb713df8a35f0b9948e1cea1f1f9d89bf77949522cd65f1b4f789aec9beb72565ff340c078a3f8589bb68112117d92588422a621165c8a80896f6fa487367f56216be6c2e2466ab9da293f11a168","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
