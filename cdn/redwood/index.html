<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc91bcfada9457806834c52f27553d6ce24f34f4acfaa8e4cdb64db93cc931944e657e85b3d01433ccbef8189b42d28f4c1f3d59f4fe1bbf66dfde0da8b346ef2d53069ab21d3fa5b5da6d264dc8f625ba0a6948964eddac3c610abc851b114ad9e153ba5ad173da2a8e81f551f4b487455ccb73d51f5e2387f34571cbc92ef8e449821f7e31fcbfac8a4c7cb3763e94fda32d4a10856fa6c0fa929bfd5c69a2a24c54621df0e10b82eda008883453140b7cf696200abe1dbb384b469a6b68b5142467ff1e263711bdb362810f123c904423112be8518f9b08387ef1c6322c3398e1949848b512a667cb405781139012a57a479ac05f9e356d1981846b08b7aa9e7469c8fb0a67e31002cf1dbd07b9d69391af054d09abb813d7323cc47d64bf99cf4214650da08e2138add2355eff5060b345f07c5a7153aeb3e22b16b630ec467432621eaad8f2cb538667387f02288933e6913b82812d8337ff7dc4f08fcb213ffa5b2943fea22677e6383961966777972c6830418af390a99b26e283ce1426f0e71cd45d4896da7f05934e551ded1e328792b78c2c25c106c4863fa72827acf456a0e2061c825d99c20368caf2af7c2b5ddd4a9e648f57a5e7bddfe2b907698654dbaba0de7cd089f33fc2c0df0ffc875e3736b9a9d73237680707ed6717d3403751091affb8317b3a4dea2262228e66b9030d3680b6dbc2ff5497766ded9feac0f887e16cd3af6594dbd80e4f1c4869961202299c1f479a91f90bbb8dff184e3867a842be13115488a0dd9ee3ac4054979155b500dd705dd4acafbf458c86b0d02ab9d929574dbad8d2486658bf3c599c5e62db1ff91713b05962e06de469be1ed99beea3bf734481d99ba2c3827efc644a9aa847c0bf6c7e40cd55ff4701c691181ea0a9b5b388b02bb5322663aaa623c68e8cc09768cfa6a4588fdf952972628aadee51d602c7591a010a8ce6b059a9d944e1d31906baa9e7472c0d9449c9c268024927b57b4c3d082857aded32cd61b5966ed7c19fb4054ece468387f78932592a082a6f46017654183659b052144f041f104afa60b3237fbb9f4615021cd54d27f97432615e589ed6d3ddf29185f8ff9f0168c4d13190980fc734ed2eee121c628e73d5b9c212d6dd8306f5401bd0bce92549c08cdd17ce67a558437229fe75da0faaaacc11f6c9f9df98a1a52c1b850b4bf482472d0f20997f678adfd9b2fdc00e24a68021d51b705e99b8af6bce685a8ea1d60f71c0e8a02f397d8fdf24f2114214dafda9f58b3f3dbac67c6bac1f326d6f0e4e7f3674c6abb9076f45a9dbb213bef4701d5cce155f8d876e890c6524443a0c4a1462683133160a6c01780d25b0a1e30474296c8a8de63eb4ba32ced18b2c3efa85fc8efbe7551e1625a767792833a6b228f8404bb43036f2d0f344cab6861213e063f8fea5d09d03e6a361a8322c7871234490d6b0164edb361e1fa4fd024ce54042c09c4f016ad3e5202fc42d76a22cc4226ad9d2acc59290d85e6c6e798b715623ef438a41bb2c2f73297bf0e8caed40d697f10adbd331086ed58db33b32981c9be6146930a976dd60363e74e0ae021fa659875d0581e41eac51792b1b63a28e967d8a73e958b977d6a9bf08ee115d23a251280285d0989f9acfe4fb9372ebbcec0423160ee411417979bf26e5097d4143033d275a41f3f396dd3aa7fe534d2d6c3ca5e1397a6f60ac50eb50eabbc9e575186d874e2c9eb58a083e374877dbd579d9d5af03a90ebe926112c6c7698a7fee0e4869aed5b426c820db46813d9f4659b23d97b44949425bb65eb90611fb8a8546f7b6c7995e61964675d34dc80c15ba80836f5bbdf701ac829c3d5311795956a52ea7b28af23a3f20a655ba603d82c5d7ffb90afabb9d0c13d3e85f8023df81f9c1f8679462e944375278e873f9ed2d08b58001b7e048d32eee2aa5349db3b389502d184e6fce08414767c36464e2c40de03012f323e7d83473794fe6a486a1e85190fae3afa21c3120486a596115fdf7570a2b062e5080480a7b6495b137ef6b4c461ff6c2ccb2a3006c2727e8df8a8d51433c494fd55360e8671fb1849428238f23fb1fef3de3cf4590c06cd03a200ac754dfe78791486571a05b20a9023817b9bbbe7af17a17fafcba63208f39bb1bf927c2941779c9ba14609b13c71f560346b80d75b7fff1ddcd9e70e2118574c7b6b4ab4be092208f01e6d292f0cdc7bd7004ed41afacf99753cda6604970b8373bd4cf22b5f870001e152e3b9e444b154bc4124d84b94844516a8f15f53ebe78c682cb070322ca95c65c1b052a0616f0813582c797c06fac13c7d4a630a6a4bf3093a7e3855363aac248da50da0095357580d000edbe92d25b74470a7fd151db2f31fa2cdccc774d73ea562b68a120e5c0fca8dcff9f66a43fee5ef277ddcffbb1d664c212edfff42fe5e859070516452110916fe5b07a0365ebefa27cdfd99996758e98020ff12623bc89d42d67216b4743113265e843a5b588f13652bbcdcb6bb3e7ccfdc07e8dffc389b264ec50fcbc538044225abc2fe6464d9a7751814a8490f1461e2dfcbbafa9b6fd40d70c6212ef9cfd00f58b84ddeaceb4eb1968e950b1a5c677a7c1e2205c86228453ff648c825dcc134cf81dbbc286bd015f3c348470d01a27ac0a99e1ca7b29bb29846c0f927d6aa550b4ede33f4a6c8fd9b50c7b50dc6c30fd7e5fab52a9ed720e65e48802e4f303122a4a3863e168bd72777f19bdae7804c03bc3e76db1568b7331036241bd3ca1e487d3d02bce1a0d63cb693ab0fd66b3f0c27889a33dcd659418b3aa889ee4aa22956adc80887f088c47e1251a3b1dd1637d74bf136a469ac946944b8464f5db1a16f8bf2a2f0238c695b58b3878b3cf88683c991ee2562b3f3b7a74e7d2b0f8f36d956e6daf7452f8cc8d862f3322d16f87d26ce7d5cbc6f4c1e28de640ebbbd3307acdfaf6fb151f9254e01ea9bac2b0bfd3ee9e64ef0d1a744ce7b21050f1f61ba6aabfb588c373ab69e9f58c784129867a25867bee338e76f585413b3e06999cd0ad45adb8d71cc06da13e34ddc0bf53ca47623492e19934b19ce145269d8eac7e0d7c9941954891abd7a65ebf1594c96c193dc1f860f277d9bd1c8a57289032801adb0a90d33b3b674a5c64f932ec06ae0310adb98f062667e87f3dd0d075e7c21c5869fa2c1fad0bf13b5267b3240dd58f1ccfa12cfb0b453008366e7d64d015819f296497f6d04de3f3de65429f4827d9ed2062a77c7603593bd4e8a54c6797addafc19daf1dacff728aebe2f54b7d0b1cc40c83aee549bdc45b3e9606f0c0b47febedbaba37d6eff109e547b1193ec96c739bbeeaf391200a679638ccca4dd113921dd1d3fc51d5cb6717923d5bedbf0c1b2bed45cda0016d475cf277c9633fe09ed784733ecf8426add474b023c1244206d8622aba069fccc65097e5c3c44ef142009e66734c34c1c3fcd4a05a44f2b814032f12fb601651569ba273d6bfe8a5f7be367a7d8df957adca8675c94f5b51709c6830c7d8f2c894224d79c192e8b26eb14dc9d8413a0e941ddab62f449a4306f98b7ba22a236a02a041a12fb37049696b332108471e4951610cb513be8fd42d0f8f604d6773ab9b5bcd8b1152b9498d5dd4dfd5386b25c6278fa59607a09139019ce71d178f2d57f8722d26bf6440518028e2c9b74d700241ca9a1a70a5fc104dbb854def895b25d70f4ad2a97388d28167e88647d37641edd52e2f3ca274167e9a3cf6d032411d201c58801f0e8b39ca9513790e83f3e8e7e279b77e90ca9acc8ac78ee15ab5fca4b27d8e177ef82baa5ba95588e5d153ecf4ac6231a6d213a2ad5b68278eaf2107b0a1d1b103a75d351fd37b7474e9d3e8cdbb632a6f1095e5ab9689d6912393cb50cab889894f752f2f450fd75d1636dc1db2ee1e396de93a21ed441d8f3ba596893196cf98da23b601ad73f774eb38c62cf49f6ee129c4021a956a82867dbf85466e7e2a35bf79d3744d5e729ba4a35aae97f5246331c97222bd80a1bf08adbc0364a164051ec2dc615b29f1bc0aa1ff1df304f6e5f34b6ee9a9719883722e7fd95f0860c4d48bda76accf376eb67cbc64b0d81843e918febc62b46e203910276f6d0f840cb6ed11b71a1c1f14b9cfd447c7027d900260b6b352b8ea4d6f41194e9d892b09c46a11ba6a2706a63855b37cbdc7976accf41b9e4de4334496e36d19ba5d013f5964ceaf7ff4db7ed8e8579ced531f7a86496a44ab1740ddbceb0647d15b90ac2ec1e691a41d320304322c3c9d42e52f2bde22050c4ce77020fb614e3be009fd5b0c16bb4ba7b49ab1bdca7e6c6d8a6504a07f95795f257e13644a1fad7e2566312883a0b8ba77ab140b853a21b3cc2df9b8d2017a68f8db025a9cd90c465e78e82912e622531217c06a1e998599b34d92a47e8e379e48ff3c301e8b25038244d8b2aed25f7df0ca210b9e856690f00157e1c67bdbd36fed3bd625cec952f9cf116603c699f1314f590335f4d071429de15586a9336826ab5cc2633e806bf66651856dd692b7b9967f748e8bf57b1aa209906f2646dceaa50fde3454cf886fe3bd19d9a70f9df6d802fcd278f869afc424ab7f9336a2b4096e47e9930ad9d33b0908c2e18f5df88f8814bb67ba1a4110a253d535913bc5833dbdddc1c1f9f99600d1ac6c861b8445d0c9d2bc1d00395a4b6a154f5c5c6cd1a9e6aaf6b2a435092ff9c58afe85b3205da269a2a16a3c12fdbcdbe2c4a9d2cec4b5dbb0243a328d85f67b762e7a84f3c0aed0fe3b7b5c50bec0f8464ac3080c5d13904b08532423abc76ba7edc89505ed56a51eba9d60e939babfd3d209623064ba9d41a31a22b9490cb0e2352d1b4472d6c6dc2c91c2c25535a7a391181ecb19939c40158253fc5974eba74f07de7e53198823f78584c6a2600b6544c4992cd939b5682bddc4cec1761a21d79cd484d68d82d4d7cb633e6911f456b027891fe60734d2a6d2b9d017d3cd68fea8893d9ae2246bf3f0eb1de7d52112b836cdf22a4bee2ac81025bc320b046ee46de3ddefe09928bba0cf3e61e83f2c5074eb1d6476a3895d17d61688048c5e787f7749c3e4c1e51e0a048cd33299c5aaecae7994fdb05ca551990512b4d4dadc32da098e1a6387e8b95da4176da60389c7e7823cdf5ac6b76f769dc02c49d392acb9af3ae02bda720f4ba14b252453ddad6730fdbef650770604f8c521e72f7a6e8157be0b985337bc1f5ba6a444a99b0539de90c09649d879407b5910823a7e81db448ddec6d98196109416861c7c0427852a9e651f2ae4e22a8f2abb5b5b9d75e5ea5b672bbcd459ae4166ae72d7a697d4e5ae75133236c294ec9b1741424fb9584e23299915f1d0362f3f49fa938bc8d5eebd742aa044e3c98a4a64147f90ae7f1fe8173bf34fde6464e43c450b1a40a5462e1c79cb9a0bba4c923c70a99cc85dd1eb2e364429e61f71a2b200a7f61b00e0dfc504181159af6b3ecae7ddfbc69ec4dd2f89fb9c8aa76dd0e1fd0fce7bb0918157b8b6f5fee96ee7339c629efaeaa534dcb1e948c1cc9ef1477da5ea0063aa1a691dce3e29dec2f3710ef3dc4fc88b1d26e57590f534f807cd340eadd91f3084da9a90f1759c10f0c12cf9d49f18c07e0e584af4686014174cc7447a8cfd0101c28cca4a9fd45b607e6cc9b26c229ed01a9dc46a61af8eaee3af26232ccc3dfa412a156f2904e6e58e124578ef2ca62f471fb01d292ed17d83562bdc81547651f967c29ce0ffb30ac1a9f72a559f28d6a669282e87a9510d23a9a11b24aecde0a9c1bd9247498600d9b7377ef6e488b79533431080a102d8ac8a0487202096a5a04f2ea3ee73f3704248de4bacc3572d1bf441bd5251c3617b1161eaab7ede0e08839220f913da44b23f29bce003c25675b84536a3cd482188fb98d19bf6995a68bfd92afdf33f2ad8412c6b849df7ab581d9134597c4b47c3d4c15108f3f3207217d102c757ea5bba7f458ab5a58d6e6f922cee7cc9c8aaa41e99bb11863e226f662ae30fc70d8e6efba767284d649aba8e1535d2be35e54a7af873a1211ea5fd236b7f4a6b75dcaea7cecd0535b45248e19dc2d5a9cf668651432805c36ef609b1a45e9b3867ca5005e9b3c2d049571d67c33c8519bd4f999833ecc746f37e471757a51eb8652b179ce0fcc5628e84651889078abd8a2558a046cd892cee2e33c59dce208f212d6c333a782ce8a789cfc3ab283e01867ba983ac85d3173888e2bddd8fc78b88ebade6ffdc0bbca8a938d064d9015caf1cd9e1565dbf1d66d6d15d035a94e3966cc41f3d6197052f517a7780dcd94e4fdb8fb87386129e5fdcbcdd48bd17465fa95eb0ee9cf0d7cfba311691592f23cb51c6281e187c9fd23a0a87a718a6435dd64f9fee75a740767404111e34b533a92c609443c9afed67249fe1359a97607440f5c257eb48b3a504100411e719c5d43be8b99bdd94ec39e1bd65f2ca7a05bfa08153d20f0d70aa3fb0778b2c3d691566a4007cbc03b10f04686d8c990d224396655fd0bfb41dbc02293f1086e1e7877bfb1489c61d5657e6a296ec2f14e08c9a3149a5ccb2c998984e2831aee4430b59c6a072026d098e56fefc9a5a58c0416e2c93091e1ecfe44e532839461e0840f6ed040dfcebb1d5b661b597aa4618e68b7b0a17271f37b2fd4fa7b32202be9cc6f3cb21e2f0c76fe8804c8ef19f458c239e48ac8c6d334ba0b01966e8af618bea9851c09f24ac35b3327100aeec3a72a66af2f932d898094b63b7320d344cd8d77af8b0bace040cf966835e9074207ae24202722fa80ed8c0244f8ab49f7b87992d8b0768b1289cdd421f23c007955d3ad0f2e9d4b7013487b2d6ad745ffd7b66cf74c7af4da5be15595ada019c4cf98ae1a96fa331254934b5cd921a923073dd2fbf2ed765d7a30300a7e23af747eb480e7c82b176bce669b6a1f8338d49d24bc72c3c2275a86d92cbbca82cde9647ab200e8377bfc98990c828bae115c9edef3be9a03a387dfd84ed5781c1d5edcb9f199c0b27bc96ae4b6039796f5d78efbd45dce752158153c45dd1a0b24ec12b8ecbb46d81c67e81eefab2ace4a8de9f501ff8bcc9ba094441c596eb7df4f9c8e719f6616364b905d03007b1efe3f232d9fc35a5e7a073dbe455ae74558b826fef734ff8a7337b1e06e918c9a94d48ef4a3161c1b9f68033765b36bc91322a3b14610e7a0a3cd3a2b051a7c57111e84c9e159f21713f7a37a623e90c2d7d9a604e1798706ba94259bc1d89acc13a8b79be8cdc24a6559da766f9ad19dff388d7b2f12214b59a91b5e5f2ffb99a43226006d9895aac8a2db74aa1b5a09f03e7faee675470a28b5e36c5c1f88608b464da7ea546c694799da0a5f570580d2d15ddd10f1b964622d1d5c4429d8b0ea67987afb6854a6c4d9b417d7d68c4b39a8af6e4a76e04a06dd0dd12490a667ae64a65dd0721af8c93693217dbc607155e0e9b2adc85ac94df6a49e8bd79eb7d499d2d07087b7e77a7fe7dcbcfb18703533d26b26e2f8550b6f3ffa99c44001c0c784be48df10fabed7b2dcce30399ba05675fef8d9286d0fbbad2f1545ec88bbe570000efa91d085924883afcf5244155273bfdc4e7017b9daebc51e2119b66c0ca86475e5a813f0d48e8fac34274f5a640eff7d1b9b0b697f36ffebc69c5179f5eec294f573dbba8aa470bebc1d5226ae2bcd2a69a52d05d073f0621dd46059286f3bb8e27763f765ec652ca76d898308d972554ff77efab5733ace15354710ce1c4e708f5de853e408e09f531021da4f548c8d1ce56b788a77777d40155b4737c6f5f13253752b2f45b5940b37f65f4028c6babdd85948d76c9cb38b61b5b3fe3824dfac4024cc714bb46750ce447f234221b3742d913e2e81633e1e5865b7c5033d2d8a1d0f30140442c04ba6de343b46219d0515e36f56c548849a03a0ed374b641312a2bda7ccd3c36ec3d2baa941446b92078b23fb05dda0f6d8b3a1c4570bf8f1330e7851859603ce49a093b4f3575f8cad2310af9eb9ef6ede67c18bf116fc87a1ca6953882ddc73970097f7d711bc6a17078f274f398e28189485dade1a1ad32e909627a760a8af71c79986894b74175fb71ff68a23a8399ce77e6052253f4df240b25acfcb3b4928cce44a04bc8f47236d2b47f0355f0e25f2916af29fa1a9667753d2290b72809d0674906a7d8678837f98a5eb7217daef046785a544cd2ee330d87532252b9fba4f51cc2505c534f262f629beee5dffc18d74b8a4f7d71e41ac328c45935eda8ca031f319b9f743be04d9f14b4a6cac72e7fc6150aad8c54b72de01bf33809b1bb4149274c6602e8c4d3e7e71bc07414870bbb061eb20e487a0adff9b4e72bda0b1feab99a43678c7ba208a41bb11c697c661e599bed7456494687cee88d56a344de2c1bf430653799ae5df2d2aa06b9e53706f78b0b715111c9682e26149deab2e425f5a179286402ee4a5329a4b216083394bd0e7c48fd89add4af8434db8f621058e93511dd18fd248c91365d8c00f902e957d02f19ce45e554c1594a0b358bbeaa97f3abd958b4810eeab32ada7458b998b2b82b7dd5306ca924a4a836300be66f09867a01a1cafa8d1f4320d78ec442544a1b77d237cce1e88499d67bb137120b2ee95ea8ff18ac20f0f2511fffaf2db00b4449f5dbfb8ae3725a5e012509f53c81beb8b559ee584ca64509e8fa872d3ea58da2fe741de60569ba576b03e35b5d842901aae40b9333c39633a4e568cd356bebe854b56d7c4e1e2b1728a167cbf4892130267b8ca0c7b77d5ea0debb66bb720fd1d207a1253590e9c4c77994d4449420349537a68d33796a819e442e5842ad0854927e5e26aa6cf2175d716634d59f9d14661d7b461ed8e08c51a8255a756e566a740437593a4f216821f8ecdaedaa9f81f2a6533703d5c1ec9b0d43f551b9e9215fe0290703bf8797a5a4b8b16d1237a0c79725e437cde56dec082c7249cd590d9469f61029de7430ad10d9831515b1ad403ce3d981208e5541649106e792e0508d22678ce1da9d7a482332912e62dfe1289b66a261bbc975c80531d2cc29fce2bb09ff8f938decffb2b44abc7c4ec7046c7301a845f52f7e4a0a485212b9cec0bb552b7d85ccfd1fb0eae291cb6f74fd9579bc581f2bb7e2b9913cf56480b2882fb9574cd8df33ec8eafb87d1c9f3e0f256a6793b55937baaf2717c9e7c1f92b64c4a95d22d6b52a6ced457fc41bebc13eeb35dc86eb28202daee681b8ee5724e223354463922c72f835bb002e8461c9a8f1a51824496c28ae9c59df1b72d08084af2de6fcfa05654eb354e9f7b5de3c6b1eab4546934cc54ed6d1f94c1bf3549c91c40e3610b57abdf3e2ecf0ffcfacffa7d3b2a98ab40fc8b52cdcfb03fed91ea45139d786583861888a748cf73c444acc66c3e10bd599f03e80f3cf7cc9132f8fbc874c2d311c3e15ce3477b5459459a2861a30a7bb412a20e9ca1b396182ec5054e98d30e5783b04b2e62ce0edc719a46f41f7395a1d017dc35938ea3d5448a183d6b24fd6a97b36a8fdf1e4011ad1cbb743f45b0edb9bb1d43e1613cc42577954c04b43240a4081c5cefc16eb3e28449ebef7d115ee246254a71d7a72aeaab6c64847b928965b02899f83dc4e1f619996e0782db1df50e6724c630eaf89584b2f71c161b0ccc01b08af653d65e20773c1b8ae814350dd4022ed71ab50f39d7f2c22ceead4a4048a134753c6542bd60258181e1c02102b0aafc3ff55cb39328d636cf66b45018fc4dd55af63a83e754f9e6a28309248b3fb3927ded8a18f47c3d58c31612560f8807931142fe165b5c981812df96bc1d26edecda6820e398eb01aaf012dfd2f7c69089c015dd9d38f5f087c3a182aeb2cdef37351d2d525e758a87358190859febc7977f0e4a06e60fcfca58abb01ecd867a9f23adf11449b8b674bb0cbb6d16cba7559d7359d673b791ed0ef5b31124e0e3fe752eabf9fb2ba57003a27f66030cbc28d5b6f1ed13806d8c244074a9151f7c616f68e853c82c83bac2183d7dc052d0befd241b3c60e7a805b93196236cc36a6f8f7d229bbb9180a5d8fb091d6feaac12b40515f303458c31b4a083e9c832810f617cdabb32e0c0ab1b3ff552e2ab547249701982c46e609c3bdfd32ed5673602efbb844403de58bd346e59b43552af9266f1a358d29daf77f97672d4372c62abceff8b48cb5c132da874e92c5380da7a4b9a4ef1dd81085a74a0e6e0534b37950fbba3680943a4c0c3516a3bcab0e3c2a2aa29d48f9f8ffd1f04faee2ba3027f18c233e6d2dc32f165136c9a0862d626a5f5e1c4cb800882d24fcc7524f714c488506b12941f55e8d02b841bcb619dda3e093ea7ff76d3fc7156258e3e37036becdd30e717ab884b692b6975a4d870530c790fbd5a35016892e8faabc3f91d06d04e73cda211ed8676e56d31e06f72d682ca37e92aa0ba51118fe32979beeb5719986652d683241d528e7f0e1c523523dafeb5737c080eec0d6c7a6f72a66ddc9371d8d111250fa553b6e473d355389484cf5e48ff246e9dbba8bd1ca74da77c635f4bb734dde3d7a04c1e29d03c4839fd088aa0854131578ad04abcc56924960c09e157fd886ee1c00ff088926bff3f203bd2992b1baae78a66edf8110d21e80506f8bc433d34902a216260e6d86e0717992acfc36ffd6acb2e3465ef129fb96fc5e952bc6d21b02d8ba29338ad28e3abb95da12a37751698f1980707a7659e0ae5cd2e488448978c787b147d2661ed5a9c5acc0dbd3f3dd24a7cf7a64e06753b2b722e9509a2afff14cdf375bd440503887398326ad7eaea561ae3245814fe890d2f6ec8a11bd1d5b2abfaa5d0131a56f5cc2401bb0501173b70cbc8d7cd88d5a0a8a67cef56d95d193d1bc236fd71b738773e538ca578e072f971be45320fe7e4178c6a4dd2914a91c3aa06743774122e8d3fabd42d7df6f877d75670d7a34a90f2bfe35c9c07ab6f3c677d98cebd1f943daec021760c28e44e7fbbdd6dee7d87cd67cea0ec5a2b1c9192ba55ee68a7798590aed2c4be227f66b39180add935586bc5f324acb65efcc97b9c73b4c268bbb7e4a7165d33c2ed9d0a37907b9a4b6e19d46d2c01e6f76075b40b412c74d2bbe19147bc897c4017a2333f9b81c09502e20604b8e75df2acc9752c774cfda93ecbd1d577314aeb419ca9d01c36371706312f3679d43b16419d30007f5a0c69a58b92dde78a1f9d400306187db144c3eecc47e354ec4c56766494efdf2186df68e3a729d5a87e29d5fdf6a9e39200a88dad707b8cd198b347db433de248beaccea6f28da2526191dcef7ac91464a7579a6ecd0123fc668a88df4af4fd1b7f2b0e1e3a41499d7330f9ed95020cee133452c78596855650fddf34575ce74f2ad7ffb49b20baefd82b4da968c79aaaaca38a067d1183828546828cf04d8bb233cecf320f150ef474ee78aed0161d218b3dbc4ccee9dee042a590343fad2b8523c366bb4f189266b254866b6b2cdf5fd859ebbc447797f9d9652a9ca16c9657a3bc5aace102d93e8053d672564ceece7c1f23546ec18643720e31170d3ad7779d477e2b7635dd4db16435cc34ce9e66644f3da1964cd1e31f746d850f261ff8ed0cdcb55907d8be5d63b8692f410685c1e4a7548c2c7dcd326e7aceeb7d18af714e4ed20be5dae2c913abce39d3cb40f2d51b94a5f0f4ce81a877a607209cfeb2603b47f13b744ccdd4073d29114a08e57cbd747f1d486b6a19be8b53b167ad211cc11588e06b5e51d58ef5d6a0d8111922042530baac94a2ba47baedb276e3ddc39b6b6d40f0623872c4ed67ad1eac031ce2dcb21ff2c8fbceeb106f4bfe555a0defc64e9f8b897438a70f5d0d23a75083251619cf756a4aa4fd231f87312b0e93a450eb6c97375834663871cf595517fd9b7ada4bb07e094720e400f45cfe302f057ef2ac4640da1ba5cd726ecd76bde1b75963e94b5364ee1c6d31ec048ed1fca2f277d286413db17c7d9bd55efcd757dca21d5d4225469ff3db6ad243c959acb16e7ae150630c722bea0703c2bf244fc77c23c1d555067d511a82e167f5e109fdacbc80ab79c1d2651a4f0bb035e6844c010002e5fd44a355bfafa2c380090bce0288338a4dd893a7b638350bca178de02e3393cc906a129f3f5ddabda30a47f3874421fc8fdaa25cf30b7fa0732ae71c276983bbee85af52b54643dad815e062933f667640ddc899ae33c6c32ead482a481e0c717e5ba16cd4cc27b8ff01347259960fb88f89b672da32e954948ff9ce9ff5b8674f4351f8d10f40c4dca44b6205e4885a7dce59b13a5a720bbd224cc95b3bc8976a60f36cef2637bed6b7b7ec32a5cbe56a288fa09ac67da7b607cd4f88cb3810a61691b8a0f83766314a8d5bf06e05879ded14013ac45fdbf33ae3ed8b23a80f2121e3502b3281ea605572180b5813819e4bc970407c90ad656f6b5bbc46cac95e72af9555886ae36866a754544775ee6d0182fd41e80b72a9f21dbc11ea28fd43307077d98e4a3c5f7fe47e96fa021f08561dd1d808bcc7123fb5899cf27044f288581e4b123920515141295df5cdf64024bfec829dae2acdf1be03f8cb197491fccb5ba5be614782f78184d1cf81f4fd9023d8b12aeb81725fd5aa53d08af7fd7f711944fc53b4c552fad06c46fc8ae30da7fc2f510d510219ba22b4cb59cb1951b9fce2a190a0b0655c38e652ed011734fb8457521efb0b6032afaefd83338c026ff82d23f775e8e3b0903f1cb3c32b715f3e16bc9b4f52368b4a82ec77738c1227ca4759ccfd92fa2e9f21c9c473cbc45bb421111675f44ce64f249b2ab799cbca3b2887a1cc95e9c2d5071df2e005591439ad8edda2429d44c59e7f74f70ebda30bbd83433c0704e35b5f1f38add9f0710c513f8cedb2aa000c497f341fbe2963c01213fbfc9cce27859238fa624339617376143c4715db39d09b9ad7ef060149311896f464c899b9d91bcf8c50e02d50cacd3e0812eb78ca5ea244054e1ee28a6e38f42b70b861860daa91d07207429de6d9ff15c5594ba86b85c12f15e9afdd6e8138cd9e462764655ed841267b52b3130ac180f8ef281586b079d187bc0057dd3c1da7dcb152ea80b80bcabdc2263f4e2a0438fa81f2c87d4097344d6dd3429158aca3d52ec7ce6bd5622dd0694bec488cc22824331febd2297056e854b1a3d0ab1925242e5cb645b8a40fa53755944d034a5379a3c86836a752d1f259b95f37b27b79ac08de5320951b3e2a3052afb40283c18c00094d2625997c40c66abeda427a9c4f08aae530a712bb99510557eb35abf124e8f67a980d3ccaf90c2c1c3d2bda620c538d8844fe0f305a766d082f5272d6bb5d3be75b8459ded55279a0da663d3702221117da1ecc7a1e7ee5aec5ceeb3b8c9a3b19e9b9c26e5c3e8a8a8b1bdcab8ea76623f860079b317a1e9d1a561e6c64f04670368185217cb3ab717a917199faa5522c49c6b3d4eff275cb0719583f57053bd044c0ef60c3e3c6ddef362a77640c6a07b253f7c4a222c51ffd95f8b7d5f5a0474cb8ddc5ccb690535b993b51c2028a9f4bf118bc3255b9f4efea002d8999495019b259b3da18fc28d03605074a4eca235ef5339ab7ac70301d865dcff2e5ca68c90f09b6cb1e04cc6cb893856dd1993901ee2acc59914e2a819c1ba05beb6b8e1fd800e63063ecb58f925437ebdc18360bf93dfd53370f854de433fb5e04374144c8e87f2640fc8b11076ff18ad6c0f9a7784ff473abd122f4000c9e11dc6de4172cb1a879e33879cd49d893cecb305d2a8c5ef21473643c431092c29086aeecc2be9026bceeb2fad4e6c9a302ebc62b646a65527af12dacd4b47c94c5d563fa9a49328f186ea1f174f87c57d60e852ab905be6ed95a8fde9bc6bb8fed15bdb6ec1cac06ac495abf6a4a5c058ece334edfbdcab567ff214e88d9dc0b98c0011fa102a18cfda63b20c7f0d87a5943c3aab31ae67577d824e0b12ec6de55c420246e2dd376b15d210020c83d3e3051ea812bec503165dc42c6eaa3eb21d4bafea519cc734a00b1ee5560ec0fa9134267ac9ca5fb2d412d43e4c6cb492455f3cf997b024b0498a10753ca1a37c422778eea655565e2cad625c832865d99d9046f30989ecfe4aed9bdde3ebce7609304a9a52db1f4930e07a219f73448335f793955fbc1578804f527f6c188140e44c85e7b61d54b2862bebb1126ec3206e0cce95d6390f8df9465253620325786c9b5c8851584ccca9019017c799d73c5b50d68133c339ac7b0515c9cd11dc5996d81b5010db47fb69f3bdd3624a08cd2546aecfbd9839743ebb9d9e8158871417d929e6692624781e15efdf50b829d188d955b02e3955995ad8dcdc37afb77a26714ddd85ecc38ecbb1c7e835b97e21e28e4fd8ff7388b135a696bf1f5fa08fcf9c9ab6f0ca6c96ca0010484c3ac05bb2cffb29b10a8e8a4689d1df36668c8a0f5bee23204a7cf9d230639e1827850b66bbb40c73bb8ee0f51d39e44cca1fa181625d333dd169fc97953f1f3860250b301557f4668f052cb229ab9ca51f0ea8939bc2c57c4414513b32978fea70805805e3022d389f7757e68d62946148004d06c5ccd2cbf6bb85c08e25c86cf733ff0e5f1bd46c6f15d7a9e047ea3a305440a23759e1b27b9f533d4b6c5ecb8aa7b10099b7ab4c6395b4feb5b3a56c81c9cc96daa8338b69c6b4afa87db2acd7cc6c2cee28450cb682e6ec8d083c2986deb6a31330e024868b2e02d5c5312e8de39366b451edd0a11c37b7e68736ec1b58b70860e2612c10b721bdbc37c0372932c1edeefb8f8411fefd2b00bbdcf14212ee6304616a26ee2d0594d72ff35e396332c22d8d120294c91055ace91a29b69b85c89afbfbdb15e7ad124f48722be73bd51b6580e012808324da7486f0ba48b275f0b94c3da60c35a74efdfd770fe4e0fe53678fb4c7491452dff45c3ace7b969443c5bd8429a785b869e2b617a3497edae3c27c49b5de4b2cb55514372a3e11adb6b412d53fe8e7434ed24cbd82c4bf9458dc9ae2420c15318913505cc1c4935c35cb1cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
