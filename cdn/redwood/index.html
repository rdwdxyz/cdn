<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4643746bf5c78b37effa171060518c7a54b41c7ebb3cafc0204195cc15a215b2c4e1116e94f6f1bb35d2ece2e08ad91f4163036d85bd88b3db85629d50cd28a13a9a1e1999301218e215a17d784249e6b063187d2a20c6b64511a9834d1da60f3247396973b4ff28243859c7b568997770039bead84bfc2eb1fbd4ede79bcdd10630122029535ec396a468a84045c5ec62ba356df74cc2ac1bac73fd6875a002adf3e592018354ef35e1d401187055c18ef234a2f2b5340a24bb8b1aedb4b764a9ed322e9c2e1cd2c3fa577644e648c69176c4a4e70bf9b31aa76c491f050055172341a396fa01825c20f1b6f3edfa484fe74ec740cadea833004d30ac3409ab27f077bb26e6d67475e2020f52b3f0ce636b975be842e0e86be5bd3795a6d2dd0a63a5db57e42a5f7ac319924392da52138aafa43d67b829668a6859b7fd329b934696ef5317e9d72d792af4d7f2be7dcc4f5f8e1ac6a343116e993ed8be265888228bf1844b9219609939e9483c1f74c289bda77caa5df94885ffa8a3fe7422160000ba610050b82f0c7eacd912c1a3627933dd61e8cf7b41f11f4d2cf271696b4d92bda4ddb665ba92c30f939bebc0014b8281e6a1593704b3f3b95440747c709483d247337448921ab0bfada5abcd128bddee433d450c9263e2878e1693d2ce89f523409c7963a71616d695e77231b683e582d243af377a862f207b4b37e790b40e4ad09c2223e3348702f4606891c36fcd3fd3024831b4e3cb1d903a7da5f224f676db375bf3551ec53cc78fae939d7f701f556aaa64df2e93b0192eca2b5760786e9b06eb8ffae2398e4c69883946a51241a7ba1e0b101add5502551684f6f261df8c5b949bd1b082a615f490ff5024a92e2f1b20682074453e6d663bc02e3b151709af8337ce41addffb87d4959caeb451e70cdbab902cf102fa687c5796c6c59ba911d284681ef486049d7fd08339b749dc5e67f055ec8bbd44027581408a42e978af355f2e4cfa9f70d29d385131c6c0d378835d5e6a72b3af63925b20b136198955569e372d190e38295956007d193aacacac03faaf3a31f1dad656142c2f059368ab7a9dc3cc7510c4a5324ea21633859b370737b220da884789c78b420916979ac52509575ac0a4cdd8816293ebc1eb501405f6923756cd6454f8a7f604c552d311f26aa20f9fa5928d724adc89486b569743e3bb122f7eafa2c3fc368140383cb7e374e53a5a67c97212c375b6c15f78c226953a940c715a238b0287c1b790ef8795aa32ed9362b7b4bdf2db18c3143d231794d2e7c96c2a425e976e1593436238d78189163138f0a99c78f0608427edb28da7afc3fb246e7b1e4560f7c2034b1fa052dcd7094a5d956ee3e42af285495571ce599fa1d4607bb509480b2cea6bbdb1d436bd4e70b0100239b8e9013fec36aae8bf6ff2102e525e3d311c6f4c96da05ad2ec88a4564adcd1c52ec1a638b62a398d1ec2407916a250d54c91ed0abdbb4c9c919c40e6c3fd638cf2d5f41e702f00825474157ea4728683ebfa4b9e9025855cec7f43f6a131fcf0680498c13f0b3e8f9e0a8c51bff7ae9535a6c8b902f62b7cbf5a79d5417face8b5059a8dc461e7633cd21277bed188ba98b4de8b6eb7c80cc375ae52f7fa2001f161441d78a88f2ad5887821700483f71d2a1d37de71d07fc0c859c4018efc14b4c09a55a25ecaa58f8c9805d95da4341dfe2dfad4bb6ccaf599f057325458e7bf66863b66c03410cfb3f0c4a49f8d6021cda722df0114a192fcbb475ebe8bedd15c00193d23e76a475eb5f457623a6d9b71cf3c646c7c686e3f097ed25c7f515158ad6ee096e10efdb2b11b73a60dbd6c6476a1999bd138ec0623f9bdc59da22c72cab7bb198e051aa570571c364ccc36e00ab699406099eac6166c6aebc82091283331b80d528a1b2b4e47d362e487aa219002016ce47dccbcb08ca1e14e58eeb4df68228184f7f73c8d267e50abfa4fb05832fd2f15ecafe6a1b0089580073d77a36235f42e019fd5310e4aff75f13ab91fc5a8de112a06d70557a34d24da452eba0c3920e9131f02ce2e6e098a9246866f87cd17257ec3a9e05ef2a892bbc1105f32159854ca345556e53a25938d4ad0bc8a6e3ff4d3320d00aa11c4452d62251ebf4d269e83f2f566b21fba29a6634c96690c104a918e0f6151e64f1d520ec66cc541eb488a12c297a48e9550d7a9b40a1398ebb893e11ae6c5811d7f2ae9e9d4fe09f986d77553c2642d36d3562eff6c94c1d023d78c34d9073677a0e4eab64427ed760adff720bd3ff9a17e5d7fa0b9cf53473d95db137a5ea766b70ec748881ad9e7e12f0a55706890e25f190d61e61d05e27018283e1321110d09a5d807b3ffeea2e7ad4e6a4deb5cc09ffbdc29fae2ee2a1ab2c31e808ab0d01a15a5c4dbfe7dbaa82e922d0738e50f63ef1052d6e10e38777fdbc8e909d1f8ee2bc3d081a4983c7c1196880c8450b8e25f23efda84835ed478cea7f97f541aa46ecd10a7297daa10f239672a165d9767937b114577ea5edf3af7f9980ac8caf584b46b64ba881ae79e374a0698b2b2f0d984f3068bf74f990c7370c3dc189b9261fc6beb2a87b8dc4419b699c487ba606000bda4083d21ebe8a827271966943f2e0477e98160588777d93e1e711a277b7baa6f052152b4030db49b255f2dfe18677fc97e4167b48cb33f9cd901c65aea211177c9cbde4102e55271c1b825676372eb1e6810c8837d3a736ff85a61b1b9833dfb8998594b1210a025b63b325f96006bf86f3e2608ed7a7f6f55c53f15ff5f4430fca31bfa4b006795c8eea745270a12bf4de58655e30006cdebc40805f194104c7a77109246fa3a94676374b940c8724d7b78d17ad5af9d971216c2f23b98d86cddb12d079c11b5b1cae9ff730a0d3ce67c606365b226ca0525f3ff2e2f5d161e3bd18b1319bfdcfe71a97542af8b8aceaea7d0730e7e105ea1997b372026fd270676c5d63cf9042dc565868ecbd0e9e205e0cc8bd1d91617264c316f46258c44ce1222730bb9cd1ee53b1297e7fb6e5ced34b4d45b6cb839a5a52a130051b2d0793198170c29e6e8dd971eed9e583b216dca4fcf3821689c39c78215876638e617c37409692132c7ff0824f585568b50cfc100b6814fd55d6d7db27f81a04efb1c0c1cbe11eef94be28a51f1b72173bdc19d869ad1c531cbf494028ab2097a25d43d2636f9fde7d9ad8c59d5419d0afcaec4bf0d146010cca90accb81f1ed1e2a2f32752f7bb73518b79a6f2033bd3cacbcb36efc96f49468721addbe1a140191733ca58a0e9a5ad23ed83caedd60a14c008147c18589b1a8310d91785313ad9090d85e6b8e55a3e0fa44623d6784c7976a1553dee348475f6df7e09300563d89410467ba1ff7a9c6e1c797b6cf4b4e671af638849b60bbcbb68d4b45bed069dd406702cbe6e17af56f40c4200cad7b60b2a03c81c2bb008c3e7609622221488892b1bdd6df1af53a703b204859756e8ce8176b22ee7af1b388a0b5aa7c055e3d82d06b9ba9d4fd229fa45ac1a0c617833e47b6950fdca94138bda7b0bbfab109b229b681ef458a76baf3de6f44bbf008187c7ab4065b6f217d639b8440ae32779e6ce75c0c782cbca236c555b35ca31424a4b6de3fab1953eb2aac993bb5aee990ac1c1e6190e8b183b062c6587b0bad989564e09752ef9b740730261842c8496af83b4551c3beccdb3cbe596b04587da10b6b6fea6cf4639cc4ebd2cad73bb7bf93c44203f0f79a3fc076799f94676066562e746bffb275bbfe05966c93a61fd7fae16cb5228f0c52e5e51dba4876ad1bf1f1b74d86470fab9314a8311fb352bcbf726631afe364d533278a218a033fd564cb6ac4e8f8b73b25666db6a29628b5a75c8c20cfb98fdec1562e52c7cae56b6f9e1d3dcc7ea44f3e10fbbdb8183a5dfa0fafe5b5f1b3407ee5c68cb160c79e960fe1e52753d8f01bf05e95d841bcbb89ff29ef4db8e4a3ec332f8173590093cfe8e5d256f2bce0fe6d9a7931b651639c93a874b39694b7e695e2b1997ac104f98a0950c16d789e21ad1bc716862397b1c72fc2488b92ffea5cae2f9c66beb902d5bd24026e4e956a6151c28cf959d042a36f99f7a954781d6f2a9cd15314b49a4a931c3c4dca9349e2c744261c5314cabc4f869f9c6ae25a1eac4d09376a8886cd5be2c48f8dc962d23bddb2c46ffc50a2e5487c44de987b2f19c20a1ccebce1f46ddc527f3c7398ba6bb7c091c043e1fa30d375af593a92619067127a1caec7ed085b7ecaef3bc8e2902a4ffa42ed0a080675ba82c0cbc3208ea9e98bd5003885fc0e8e4a0214cc29e63c73626b8d81ebba0b1c37e1f7c11f56b7f62289be581e17a9351a3d7d3bb0540760274cba60e9eb4386291f166e7c4bf73aae4f6e9b091e7bbea7cac4d5ea2e30090f00140211ac629a3cf29a7b9afdea924e9313a5b89c3c56a1055ce50d6d96b10de3d7fd13bba4fb16e601352f7b70ca7993d0bc9921af9df77691a96920b99606b3a0e29bb8b47a1f086a648299781668a29e9b6b0eeba073320c9d4cf0140023142a55b49f4ed2f113b90566f530d71695ac84453d1ba95e7a62603522cdf18c3ae43b7cdf99de0ab6869db8b179fbb1c2cd7a10935e17a86be1f59013199f7048f371583a58aca84c2d62e8ad4abb49639ff262d48a1e78b245bf68ce8e4149248a7e87090898f92a05aa20a3f803ef9067315d8ea41c3f6ff4dd28c9aa7f5e159e9a98d4dca07f3c832a05de2d368e1329dda83ac22cc7bd462fa5298d616cb9a729585ab75680749633fde922ecaa6d170cdee2200611d896b1e89ea8d2db1d3afc9a94c39ac7d6da51fe5366989689209c5bb3809088996d20b7593e4e204009f2a5915d423504890f798c680c717ccfcb07e70a1e15476a2ccacd25696f955e40eacb149f14f0bec4bc2797ac7eea67706ba73b4f3284cc3b0e34cb8492c8c77849124be7305538680b4d0cfc2b397a99fcd2bd3560914ed2c67cb1e559a595cae3a6173b003ce000d41e4a47352160b64499f8f0c775bc99a26e9625daf490357f1a6c9c8f511de144a42d7cb8a77fbb3668141a8e086aa54e8cc13efac77694b29a0bae877475ac4645462b3af76038eeb81bb64703e98c014e6f18f2e549f11a7e8135c0559ece83eca1ee1454d680d557de9249e3f231b430e91abd97829850f448e833cea309ec5f47b2b53bfa5764cec0d2e9e4fad5ba9142f5e36785912d4743d9288eab42fbfb145966918fb6e782ed6c65c2dd6319f940b67ed0f7b74597a3b7d5c1af6db72d4b10597f658099eae6ff216ba0a5ddd2d10a3f8a39167139167b2853534eaa803e55ef6ae05eb0a2a73eaa3a7f810ddc4386a3b34427088352b3bf1d09d5f10a2edfecc95aa35d1d0e9d9f7a4a129869ba77440a6d5948222f1d3406439c633e8abde6fa19172539415a20029f9280887dd40b677f51b919da2795810c62f3709c619024bd96ff040b500035d86dc15ee73a8c0bdb4fe4ba18be6d0bc6e1061614678e6bf767c593a0415a0ade5f0379e3cb9b45d6a992e663eb4e5984529564166e3f16241ae3e28fdce0690ed6b21ad38a35730a0db4930e615067ba51082eb017169379336af3fead534cbe44a9f9dcb8f911cdc6667d1be362221447398f8eacc61648544f72be07b70c35e41968ce23a7740b28e7eb37cf1adfd3a284834f595846ebf6028338206bf9a8688baf1c6092e2252fa94917ac58944286f2433deac0efc13e792cea3f7c5821750819b3fac38181b59ef033cfea1c3f5214cb056f0d98696e4ff5b24eb32da3991d72481e2fc60f150c355f08ca9a94f8aef5edefa6e856505636f604bfc0182f6d25e0fb65e59523397a260fa7c5f754215c0f503295c26f6708c1ec9a6b010c8522150791132d3e6f04948e0178645144b2e8c74e7d8ce5e531eeaa76df6b401dd8d7ee1f601de369428b2d551d28fbb6b8774f40885c07d72bd5112233e726454dbf3e26dd8bed79f008bb690f410d9640391298c3e3ec3df39ef6f5d7428dbcb4b6c8164ab3af41831d36ccff0db6bae6d09aef2146b9408311abea3f91ee10996d431fbf9758baf108cc09a245ed344aad0103a4fc65a8ec0f0dcd9021eb03d26150cb0855a43de632045927195d0baf2d86f2b00d479e199de9348258eccf0db43e8b806731fe69d74504d73dcd2c2725512e5d432fbdab53c25eb24d492d56365c27b425c57d422db2a7453ec2677acd02ac40f7ff66172495ebe7bc6854360f6f0c9a469098b4faf9997c0471145a299d12f35abfb9908542648ac99e4d7d05a953a026ba52a1930689eba3220297ca8acf05a630e8b35775a48395305f60693c765f2fa11e5de927b750b2f959ff7b51f84e0b629f6351817ea7234314b680e0bc0aa03b2a1c40031a5be591b8b020ede6a9238f80b666f95f3af488285686cf63bf28f57c9f9138bea8ab91f74fd503da46989a79f20afad391b07479f4e0fc8b1ce0bafbb1208174ade58de98283554b642146e646bdb5fb94f906ecdcc049694510999667c943d9cb6d84c0be56441ea27625945adaecce880afd7bef1623f68a2e9ff52ccae26f6c24796c34295148ff713e32904979bacfbd983eeeba9d37877b85f81fa5d05249349230e566084a769d173f4f91aca4514aa724bf785ffe2ad7b3b02098b153f8d8b42113f21ce11c792f783a2b5f59bff050fa977dd03de99a93651b1bd66b35cccf0f7ac22963f1dc6400944eff48e3a5f9172c94ceac9dcf0c80f528978a832fc4773c2c40796e2115b7cfd63b7dedac6ba33078b2c1f17b9a1967fc6d987e36fd9f981e17f65bb3451a254f9e1d828084cb9463680f9f6537fc82269dad1f7d34dcd47b80659371488d1f4f06a490867c138ac4ff58531d385379549d357b01583fd4db05a9be9ccbe025f983b92fc2f998ae2e2c2ecbb19b9cd8ddbee6366dc03245469a8cafd05ccf860b723cd6f13df68e164a63ccb5ac88f20d1b7835c33a7b838fa82f06b8a85428f741069015a868021d7c775f27d17f1e4685e03726bebcadb04f08681dc4e9206ffe6f195729abf6d90edd837526e6d1121671ec2a473bce5897bb013bd33101af5b0bd4be99dcb45fa71448ee2362fbcff93b9e0467972bf389f9d439ce2218513d1fb6ad84d3bc547b59735694434a1a4c7b7d6a30899773c58e11937febd45552c95caea2c91b2a21420e1dafaab4f6789925ed69abaacf0ef38a557482b091146a6e6039ee6acd1375fd3f11b81e406539fca1b4c0b7a77bb7d8a87631d36a8d9c685961e29bafddb416adb8bed86cd8cb280cd14939dc867f3905a0046ee81748c4e75236f4a7198858e75724e34659daf297f32b4cac47cb46f6d2b21448c4230f481f3b600a6bc821dda81c91f945481816fff9b5872dc8daafcd1411c96e911b4ae9e2c56704bd73cefe45f1e37644a4873f2a28cd0a445a2d39ae07327190fbf6c253b4886eb54838ee4139f1b32b7bbd6dd453930c5276db47c1757854277d41649e45fcb3e9da55745c4a5e256fc282698dc37a41ee715ceb44f869952718c18d77b5fc9bf57a5a24ce5fa375054d8150cadcaf2c02edf7297d0c81490803e4432b9e79e2425b6267540dc710450b0308e6662e7a94fc324abcc133f064669d055caab4c4c6209990688dec23722ee358addec16308fdf6b5bb472ff4dcbe2326bae2318ee4dd1bf4963f26f5a10838957e7bb3fdc642ddd94868a2becb604f9618b5b87d40a4893a5893fa4a17b18466e6be7c07c3ffa1616aeaf77bff032e1903c14b48b3c5fc3aec5820a147d27c529b2f398ab6a1fbb16d905d6a937c2fc957e28105712ea5eb1919c170dd035cb36cc3c0d7745e2e3a4b36d55d58b6dffd0a7bad30a3cca6caa211acd21275649cbc80f857031bf00940fee85d45fb1f967bd637f9615f1c644fed7b230d5ae14e801003d573473101d3cf6c299400cee7b2c0258a27e17a54894dcae2e71b5371c116ba89ace151771070449c42a7968a7584d2239908aed9ff4847dbe2795e5e47f2367316a868726f6baf2de11dcf64d99138e82420e2f7fd670ccd8db6969f9746b18471968d530ffa5cd58155cc9a8a92b3bc61d91acdad94484435fa1908b934f3eae03a808579a84d451cbc3dabfc8fb4c2be593367eea0aa901023584ba0464b19d795d4a082bf9671ceb1df7fd41d5f5fdff3e77fee8616fa6ba2d0acfae524a699070bb09992398f9b4c82ec04ee2d8dcf62b885e9142c2e11b15c2386b51adb4022345b2c3201be5054ad3fb8ee69a0a09ab01b22e6dcce337f5373976f14dcc4117dc1421ba1dfe67a8a3cab2eace9acb5c597f80ab7be913d3fee61620341a6c708e28647f523ebdceeb6f4a8b282b5c9effd29a4a9dc7bdf2642c67e4e90ca04ae7f726ddc007844386b45795cbfd532e358e74a054fb3ffae4046ecee8c634ce519e1a1597c8f2bdc3b9bf6925aefd44ea7cf20bdc49a1faf0378479e47556ef2ad8886d94615308be24d07ec1925e00f5f73c936c542c21bad3e0880965d38d28ab85d1214bae766d6f6f6547beab0a14b727ea3a298c1c24428c438b45bf11ed56c1d1f8121967e3f7ca4a360154ce8dc977f5ceaa01357817dbeeec46a7e2a632c0537adfb839cd6ff5d6341e5e91485d8b0af8fb0dc162a0188ae73cebffb711578d3219dc4b17aef18ed87d0b845c26d8c25223e061f5ba80368154727c05f906ee5595d84f64c4811f9ada2f17f80d62688acaad44b476a9c0a44a8db74a0e07696d853f3d94b7c524398dd4f1109c0070d6e44cfe967526a300daa4672e56703374087da8b58da5d07c86d8c8b5020a6185881f21beeef074b1ffec0df763d7853e1af0105f8b1f590a15d9102cf5ede42e75f024278db49f05d74350e23af8309d1bff5b7e1021784e9f79f302dc64d1ba35610acb6584344bf6e9df922b0e4207bb99c9f10805d866fc2aed6e4ca1fa2c9d8054bf9efd069af701f7cf97e8baf70ae781252a3197bde0f277559d70b589b736c18e957ae0168963a3d2f569cb3395ccc08cfb018e333bae3f1611586f1da17e3c226189153adf2d96b0070c3621f9add6237b666921d3d1f56be603a6940c7623c85863b8f03aecef6b444fb1095fe6bb15d00571772a60a3ce3bbf7f890e4032ec554957bb1e4452013024abf82181dd5963a45d3b547b6d008d454c8ca70bf277af1ee99f11401908118d9c2837d50a5985342889deb34f3a76959a7a52b4b01b2c14d2401303c4a1a428c23f9a1c6b57efa739f8b70817b4a8baa04ae4d38c7db58295ba33437e57cf693250bdfb5d4181f882d5ac7fa791da3662226b2be8f5004b5da610175c8fd17f96353b5452f836844b72dc52b793f6f90f1fec9aac9df5e5120ad9dd4e599d119c9598b049dad81c14eabe98987fbe1a6acd6624c48f8d5321e904f92342081e592f9c458ab68b4007e97639124421fb5632fd1792641f767d0d32aafa0b2146a8c9bc3662903e1b701f2743832ef98124dc12cd0554b3360d23cc33e5b5408618c683fcf0407aa29c58bac9d2c5f19d46ac51356cf1af7e83636b53bc610e544c207fafd4a256f46c1b5aa219907398b5bb1cf6ac5fc33a5694e194cb103c0c57263db3c738d8105b5e82a5da0e690417e7c682b217f0ebe0ef1a3e82a34f27ca0c208888426cfe5947450a974739fde1c4bc9ce092fb32f1bf727679d69a4142b294559cd86d4939ccc45c882f986350cbd36e5f770b24f8942d5810d6dcb4d914aac894c50b0de84dbe14bff01baec38b4a027146db4bca0ff365ea82a3d82ff6c703c57797ca3096072c70fcf836acb1a84e21accfa71864f10c8877dc8e22f40ecc5cfc486b85c1f5eb2fcb652950a1ea74820de06938ed1e2cacaf4dff7eda9b0e713b819a43a7282fc44e6004dbac1241e1e3cb012f69c7e38084b926a2c22663ff90ee6780176e14f8b9f915bdbe88c5826d1ef571b72406e7b0d67465c9f114c227b8d4e550d7b3c2218b22dbf31149acf5e2768b9a772b12152a2e96f9cb6a2ca4e7fda06ae0421714192a6ff75beefc0995a11685ec0404365d9294cfb58f813ebbc60fc71db5ca4b0ae7c14a82ad7396e080ae0e2b26abc3d68a110489e29c1002c2f8dd274119e046bac4f370434d2b80044858781d5b1117986144baefd36031d02c8db6f91abefd1be5ad0c90cce84840cf34d5111347f4b685f1eb980e9381b082a9f3fb9e5cef0fb5e96fe476c6b84bdef45b7ba6fee23f490e58aae9c9903695511c835c7e74c6a97f202173629dcc86c8e4aa11f9ffb60945f4bebfd928dd965c91dc123995e1298df7dc265dd1b648fb06918ee2dbaa20d4d9f56788e4f5acc045431e3d7ea244111adb09bba8046efd78d3df9882ccd90676ec21bc4208c11a66c3e70e71182b35c219fdd6e349d2af6afdbe58a5a371883690f269d429faa5bc52ee3dff5cb038ce3789b02a16703e071e43e10bf04393056183d4ee0c81766802ae0ea5398117fa303a23837e995ed88dcd7756b33e25fae71011ba2e7edc97091f8188dee202a0c432ab340ce31c31ea5785df53bfdadfbb3944964539f3b045b5c162d5abc9ad791e928cecc75b37b79e289976e7c38d4f68ee00097bc09795dd407a2b27461fb43a60b6545fff5660477e6058c84d8ff415d2850d22d8d48eaf9e2c9a7bbb800d525bcf46bf19ad9ac779b15d5a9c6a56a31d5a50b346ae5b00460244606210ede454976927d87b01fbc2ed30f78c5f8dd18f990cd6d22a62a228f3111cb8718b6e8599b47245cd28fa24ae62187bb9bc3a982b837832461f285a3153733cf96af5bda6e7016bbc3cab7fbf1322c040ae51c1511ecbfd9b8ffe97230abf531432e4a414929241f6c54c2218bd71fc34d0fae5265952fb47eb71b70783ac5d288961c42eb251b420c85ffb52358264e06dea450e6fd0ebc6273f1c49959bbd40fb6e26c3bcb8be6e0500181f9aef1d39fb43c19325ae5930bbfd4d18a451cb99ec401da4a21e9704978cf3f247b24a7ceb06af28a15d0bb8eada400a380684994a57d0c83dd2d9389dd3f12342dfc0674831e7fd54ca7088162180f30e8e4f239ed67e6934fa63a3acc9fca556793b103e36989595df7256785c4b01a7ef4bff7383aebda2353681a420d666796d6afe9b9496fc2159223971b2d79689ecb2a7e6d076ea46682af017d7c796f28e53c2336d4a1b234cd1f8301ec14ed4b39f38b91f65705639421503f708e2fe5e161076742dc2ceae1ed1f2f7d46a424e1176714935c715630bfc3cf41f308cbf8400ccbca318b2a47ff72dbefc27f799ed6e2f1b594f10e401f4112da91ca7a379fdca056f558273a0582d549fd058fbffe11df700a75315f6724386db45bc4ecce3e3072b274a1d3a61e7e4940e1022dfc72a236749b0cf5cd0106fc5c00db87db28501e50a0db7429603cc85a4b3fc97697d7931fa73e7faea3ccc0e153c790563bd50531d7bb42871b5a09fd37d92e3869db6e7595bee4f1231b1bf444baaa6a195d7b31712050e835b5669f63f129f2d3c51edacc2f6166358ddfe00fd17f43a44dff04e38ac1dfcccb2259f162acbc98e72cd09532760a66bbf65f2fc76e37f32013fc575077e8b9638e3df2b5a71b8ab145cf94ae09d7c7a3ec0f178cc6590158b33669063ea7dffc210e018fd19ce49a7c6aec0156513d7d56dd24251b86e37b59a1957beec365b4a0108d77fd8976515bda164ef4445963ba80050002be567091bff657853791d49a42f1e9e97b900341d59c91b83fd20e4ebb920984a4f782b93ea76634f3b4e8f0d394094a742a240a190de3045c1541e80a4d76db634150448a33008282bccaa5a094e48c34a62c814d59a20a88e66b6c94a6b44c76f914683df5e4fe1969ea1b812cf43665d58462bffd4410fd7f8629513d52f6717c5f5eccd05d75742b2a4e4a6cc0c372f462f32ba0b6c03693c621dc7aeef90b2179e0808ce825fabf163be2e4f0a51358558f5737cb6d9e524b60509359201bab1f0059a03befbf14016d966a436cec43303d2968f95c10162181ff14486c8a9347358d718e9ca6357b4d7ab17b4829db46315ad3c20a4eb1f484c2f736d73a04aeca48e92f5a83d3a635bf601d8a42a1a8b8db0882ac9af6476b7123f14749bd279b45a569e966103f23ecec47547af3652dbc01a5a469ca1d710cf520ffd07d7569e31c78fce1fd31f9f9f0412fb0342c0e968bce5fbac2419363f430c64669ab7651c0cd4a6be33907b705c517fc3049faf66cc8b3e5865ea7aa9c91c7357c5428a4c29557168518492834d149886246b4f91adf2e38bc8316c9398b4b83564ea39590e8b1da6f6430b1592a5126f5c4710c97e73a0cf6ffcf35f6e4d525efd1a50c9917270a5705504d9d3e3d21d5be112bae83a08778ac7d8888e6400904e08d37cfd063fdb020e547d6d0945da709026f87b056d01b68b364b52a1af8504f447207d889bff9a4e3ddd1a539b8250320ed0fdef138898d87560ea69d012f179a0ae6cf8420574e31b4a4725b9b47d5c01d24817eacc034b5c0fd11303ffa261bfccbcfbc9af89fb585cc53295be0537c205b96be4c51a6510e45cccb20857add95392b89367fe9274bfe9495162608741655757199bc99d5ef891d7f066d3fadd2ae8df06ad26c9b452a4f1cc6593f3dd8cdec731193c8c0893abff1398c4203984ce9d02995d1b899474973df27f7211e16a558bb043beeceb43ce828b6c612b39422e4b69a5267a2eedd7392c337de9baa050d9d77dab42b7a816a57f69ff26cc7728e5f4c7fb207fdc0eaf09f701472349b4074807e5d92b89e6777c9bac55d4b506c582bc4bf3127bfaf15cfc043855d050f8794e57b55d819665a8525ef2ea0cdfa61b4f57cba0d7e5c0ec6ab3454acd61e291205e927b9a9d160aaa8e0a417c43ccd46278165e4f2edb2cce28be09c563d45b7e7b9c6962c47508ca807dd0b0dbc70cfb1cfc3bbd568be02711d9601d563ad0b700a98f85df705b84c2cd82b369d7ec87c27d445765f36324869eac1b6f1688554c96687f9661c0fe758cd4cac246c9eff1ddb1e894895e36bd83a8592ab3864f8486f416bb9df4716f3b739ec571f1fbcc562d7bb806894d6353641b1006b5de645792db2b025fd8a4275a44baf30b26f183e71a9ac480be762fcea27fb15bb320e1fa9af4ba77c7dafe881e8445bbd5c4fe27bb6c21a126e8e4c6c6e0a6582693fbce9fe70a96cc65def7b1cee9637ffb7a4fed456b4b2f725b3c124ec0ff2ed116aa92a304d41a82cc4af5ba1d7e7326cbebffa986e105cff50daa1a0131b6ef8c13328512774051c9feedc8f7e94f756eb6f0b257e332d878c9c2701dbc54997f0d76d7174c140df5cd2e36c0a9374b5d1546f2603f4d7dc63d98b0f8a2d067563414f35584928ab85c3700ca74798fd57fb0e747e1340e7922690023ab594254510cfd4d69a6777875be8fd0b9ba7acb9fc1541dc850d9813b5bc7ace524227b32f41ca30dceb7fd619b4cbe3954904acd6ebde60fdb64564aa62bfd1e22e2eafe0ba33db3dc169d5e9dbf559b205fe63deda6564b748692fb78fff77ceac77dd84f5db72dd2e75ecd673d5af137abed01573feefa968c47b20e85c9f99bdf3592542a029c8232ab3a8b040ad553d8cc6bf57a55a5b4beee77ac9efe878d1e4935332db2209b7915cf424409af65cd66f5f77da37e177bb54b7fd2e3cc43c6b12cd1863e2a35146ef046f9512d96bb8c4ca8db155d6c92907cb3748c4f6bf83a2e7617f7e8e2100ab1faeba7be100339bdb68757a63344f0489628983e8b01eb4d41433e44290a9d9412ef8119dafde5561d20190f50d9fab1424c667f1db6eed9046177b063bf620dd648e7c9ce986049505724e8d86ac7702411a75b40a2904c8a0856794107fc80a4d26030e52acccfe1bce40d2ba1e748ea372662bf44db6554e28c0b2788a6f141ad0443137c73ed489e39d488b35c235a610fde4443f7384c5b4fd531235974b57584342aa4a73fa8eb05a18222e8d6343bfa0b4d96eec7890547b58d91bcb2b9e39024d06d46ca675e5583af6e70cd8c0674015490dc152141c0fbcb513aae1176a349714dfc9750467378028bdcee1091b9052ad2b725c6a1b8c995af0767e05102116163a04fbcf572b8125bce23a34513a9a79521b1ceea764277acd94f76a9c79c0a6409bf2d8869991b72725fc5dcbce8badd93cab86e7e24b161e3602bf5dff745ebac94342641febe8828e7819740f9d267b19879b0ec81352884774c6124530024c7483d46cef76a537862499c8f5dfd1d32d86110db44a86265a0798f6c1c7b77a82cd80020c47a97a84d3019076c51595dcd96c3baf9673cffa3ed7608f13ef3f9870628158a135c4e4e78d0309084c73a4cf98dae064ff48fea548ac59e1237b751fd63e7cf636e0904eb1c1b4e6f06650511e256953518b57ae9d65aa7cda0616c4da94d1071e1914db4aab98cc3c0e8ebe3590b068da3d567d754d24b453d76d4d4e555ab01e4174e4bd0608f243f077c2a3dd818144006b1e59a3fc7e3d16815f909171c47a1697fc904a9cc78efd75240cbe5478ce8c6e6f0d195c8387fac97cc6129b38846c4279d4c8d7a8b9eb8b871098aebc830cb8f133e50a26171c47f47a5ef90b680cbd3059ef088ffddae6e56decffd564257c275a771cdea7a1590b078f93fca155ef175951a534722d57781c654c81e8b91c916e5c0ec4e41273f925b6580b03fb04cbce8d864a19be31004abfe28876299fa893c3cbc5444e17743776dc9da38cb1f6d6ac15076c663c8e28e0594eac876fe53b566d229b148e44fde710cdab27b9dc374f241e11bb44611515af0986d2f6173a4c50dbf7380b03b5f25b847d067a86bfaa323e9dd48d167fc1da3496443299b67901664d09cfa97ba7a98e2a34b973702f697d806e98bf00e17af7cf304ef09fa3cd212aeef13fca386626108edcef9efe665d281843ba4d9baaaaed8d493b12726a434648ad0b08114a866912e54e405d7ee056de1193bf88d0655d1e8ab550c3fa4546fb8c981320d183dd133588686c953d929fb11bf21a2d07d86ebe492b40c0ba906a8b32f886f5d1c1a4007fb216787febf8146ce2eca7a7a21602761f036fc2879b5cbf2bfce505f76f044f484cf741417d1d7e2306bcd44624c6b7358c8326db1c193f38b66186f571ec8f95392e8c503ec79a2746d0d1382673b06b6cf174ad35b76ac23e06789b7abbd05011a68111f13c1df000aadd80ac55748cce8f87d14b89e6e8d8f5e7952f7d0331eb88005cc1a2f62974052e5115c73a95c01b8250c10cc33f4f03d9626a2b3973069ad87c494bfa9348f8495519bb8de92eb0becf9d1f458e24dace4e6ee750a27ce96f525b119e6c348410f299fe60aa396d5bd225beb07df1830e30c3ea99a5b4485446b47e92f642d2030b568b495037eca93752294e028d78187588d9c91382f5ed6e3f4607558c53110c1ff0cb8786604e331b69d195a53a2e4a63a9a86ca6d548171d361330b8b2b3d30ca5c474fde6ed04034c63a3afca5ebac7fca02b96dc1f8959638b52d5382d6bbd3e011696ff46125b0177c68e30498be907fc39df8f0503b9cdf4ff1396ecc733f6b240716f735228622f0c43375101868c3115824b92171eea1f1ca1fcc92fd883e33fe1e72efd18cb0de785221ebc3e1bc83342d07f95d3566a5e2c89c2c070e4f8de477b9ba3926626175f3e11479d0d463269ffc55a6bb1914422f4ccd79b7609288874ee2b972c7cba4bfb9deb25b46b7e9384ade5e95a10ab303a94fdec6b8790565b56d76cf9998f04eaee70af6189cba9bfd96338b014cd1f296a97f93ad5b31afdde258b6bd2e84b60c4d1d2a2e2176e436e87cfb481755245654c8eb3ceee9290c30c9e5faf2c6613f97c4d24b3f637a45373a8c13b5f3c9fcffa6f1ba4f8d562888284eda235310a65227ed867bc141d3feb0e7f0b79df8c82b677219681468f22409ac87eeb8090cb0217633e2c27875591e935a8077e29d621f7b0d6e7ded2ffdf4b8699f8428144408055678f288b620e430afbc8f32617ade8a1f05b76a871f9ca3dbfe646b18fd88841266999e91fb945f317f13f3d8ada5159228199317fcbaab545b2c2a00adde52de383f271748e9972334b1a3ddcd5c6ef97e292147d326eb688fad2ddbfe1371d6cc9effe20f9e1b9cc6be46e85011b4c08649aeed26ba68c7210a72e3b38783f881c74495568bd146ccea70fb6e2b4df43b9cbe2d1561321cd1369b8fc5fdcecd6073362c8a6faf8e92dec73a12dcf59ee5ecdad32f73ecb83b2ebfb6e40f5172efb283bc5eb3b64a8d00c1935b71080e401d5d2463df9c659c543abb144fde3513590bf4e7ca28196294ae8f9f64c3555225c80059c699315e41971c9d209f945a9abe6d60d39976575ef730aa7363d07a1c0e95eabc0d658eb751d399fab60992d5688e97271d9e198bc8e45edcad7a9bb535a00685f71546ed17455a58a8ccb556aac160d9b9cf197b4cf83d30f9a38d17d05aa06925c6fdf11b96d008bbb051529ac1638a5060ecd0a6a1e9beb9ba4cc148e5911853372db075d31875f405f2f8442d624e03a0a7dad2282418e445c38c03ac3da3974ce54c526d300d7b780baa8c7c4e7e41efe994487c6af9d11438743b9ffb8c4dcb007e90e1bc9f9af8a39dad462f398db53b63e36d6ed8df0a433c8e7b633102ce42a922596e8586bb65bb43a8fd0e2b3ea9e4e763ff17461ba3d69168f6ecdbccfb275eab5dce84e93c4b83548ef7bd9cf63b007262adc9e8a47f25a73092d4469286d63f0747904b207a677d7f70a067bff27306d26604650f7afc9350254c255b79894405d12e62bf1a2a0d262e702129ce4fa4315151f620df55d98d8b6b8b4c1e214abf42b920384364280d6a1e34ec6995f4b57f35261f787075b00b1636d82c15e2512cebddfb40ee275a1800ac8d1db7565c38d0dbb40adb6181bb2d06147e8563a4544151e7af8e573652f0e24d9336edac0523823eb178c4ba93a297c04e4820c86f5458c77b43cefa46164550cae021fead8b06a5b437ee7b9a58be0aaa173b7bda568ed88452b9f83e73d1097f867630042e00746d5ccb8b288811aa25969b672aac514abf4e71feb867fc88b43a35cc11e3e1fe2c27fa19dd628424dc48352ab4895740cb2ef75e02e7d1c70f81674dfa85cb4f4a23101d2f938f34f5ccc42f0ecc93ce2e1f373afe75f1adfeeb7120d9559152ba2fbbf4cc1d479028ba27da5c21c4a26e5d967a35026bb7c60f17e912e337603e5d3a2c5a2dc7540926695e0227b822a60d3f950ee141d0e9fccc542a521cf59c05cc27f568df324f28f4f4f7c782eac8488df7eb54c5f817212e083f7bbc19916667dd5aa14afebcda2ba122ecee3554d6ab94d39470942acf2b6d10d95861c49a60fc4abb4e29fedd10d7a941c477ef16db19d46a95d8a2c3439f70a0eb3337e196c2ff488f5f7b02b272d08e2c42ed862807f7551f444b373eb05bf142ce5c332a9595fecc376ede8de0f7bb5e78a4c9a414a574a729b3e056326b855f993aa77aa9f3db29c8b2384f63600d808ac3450d0c5671deaf4377ad03393545b859159a788e4269883ee926d093ea90d72a4873015dc031e0a83a826342947f36d7f0a9c61c72bbf0476e732486d55273c8bb5b72b975366867a1ad9e1a95c596f7081dd27171ad4ac0fb3dc8b51941b8cdd2edfa254eb669b056519bbb55651f9a6ad4eb9086d338b1bf9c05d883b6192524ade87509123f5b256067208ec28281a4bc664d670e49c16870c232e9300f4c14d128457f84ec1c41980b2c789573fbe86fd8542f4369b99c6b1b6932ea2296ec3e2230963d06f14089cd524c8cfde78fad63e61a6fd6ddbbb2991d434c69e234c8ce351e85e51d330399a7ca86c59","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
