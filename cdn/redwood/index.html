<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02dfb60292b66e92601cabd99d4e4449914b16c3a53d225efc90ff43efb94e1728f44d143dd41dd895e30206c72c145e99ef5200d8b3db609e8fd5a5108da12cce51a270f9ab962b81fc9efd8cc688fe1656b45d2e6eec5821e3d9d9bd234acf892bfa4e3aa194279f3cecb48295a948cf55d671ea76ea096c315db7f5cace82d622cee8239ce48ac778296ef5c4020a25a23a0f9e1ca33f439a3eb07a5185bc7a81b7cf434bfc3eb6e83617b925613306f4fe8584b8fde924dc564f23193e5a3ee1f103a8582b9e22ba7c768f2ea7c7cac003e91eb6490bf0fb56dd9eab34f213f08a5a2bf7691822f625ec6ad7a7a1043c0512090fae7a0855f0d89b324c58ff181a8ff97aaa624f5bf2a29f45331473b151780856db4a748d415bdfc8b8fc3154f954f89134522c47f44d3d44fe47922748654326012861193eea4549a1e880f731e960d8a3f1d2fe285d323f0060b97569bbe87b72dff7b1f6e8c43219efa526c87d112401925401f8ab477529fa80eeb1b6b203eaef65b7c932b0ced60ebc351baec5c2704a5120eca7a4a670c1296ad7210dff0f502e9a9189a4940a382ffed2bd2471e420a636011ace1ecf98efba78e8ab3aa28bb78f884073ccbf58cf99956956b3f67c225e5148e3874a2d36e0226a40a6a46f66ccb6eed401d13397a3202d80cd97194b60a9f94bb6578e988b97e8449bbd4829bf906db11c5ae885ab962b08b84ea5ab461a4efca47a8850fed180a8625fffb162b58e88d26d54dac21981185ea99c3fdc92caca0e7ea82d172434aaba0b2f295d4dc707c9b1c19df04de68d49cd8da71fff2146d0ec46e19dbcafd3fdc35bd62bffaffc4576d2771b1b3eaf8043ea9e2c206b590b6e1234c37737d415c3f5522678d69796e147812625e59c4ff50fe0c47f5eebd7f8b310d793884a690b19454c4f1bde9260c0a76de75f446bfe87eb8ffd01a30bdbec55520708834bab2f986dde4fc7a35edfe1f1a1f6359d4265f2e601628b002bc74bc7a4b9fba3d24a660caaad70c3f55f4f148ab96b6205cb704373f41ff408bd65f6b687d07441231ac457dd357bf9a00a1afe1d207459979bb48d9199b0b239b3cee6f0223d34c71da13dd0bacf308a2951be529228f5c4136367175bc21c3cc32ff90c1b77b00098d04621cde518aa4818462401b4a653708250c5b1ffdc57fab246b0b479adeaaebec85224e1ef35c7cff57d49bac5d9aec146189bce25f3c2185e010d2b3069d11c27d95fde3355ba3d87f36cf271f72a43dd8bc4de2e492fc02cc51d62a069412a995a993221772b86a78de5324036ba2abf827214f5b2ba9564b8ebc398b47d3c8acc67144b0c2f8ef4491568b4c29d87df1733a8582ee1f9914db40be4243a49b9e741df6cfadf2f545551ba9e92f34fb56f4939326c6209fc198b0867052f41cec1933c91881cc2cb8439943f192e66c494e33e9e44b54f9cc26b67a1df9739176fc0de7b6924de5e15c314d8c61033af47c3bb401d122aedf7c75133b1ac8e6b0d669ba1b19a1afd57c4e82157983298078bee94555d26f6b62668eee97a3acd6ed9c008b7f25c9c3cc4b19d2fc50e3823467ea4d7d45af14448d4517ba1ee6db18ca614c5841e34129d34897ef7033a972f902b08909c93e939d962a70163d8515cc986f83fce7397d04472ba457c60d782cde09a79dd091f948104e1e4cb63e8e52d6bc8078368d74f3507b2effe2c67b042f8a1c23fa6b018beef2e40f2589b380de9f2fd93eb303de56fc0b20632294416310338f6e9f92af98c34c2ecdb039920df5da9f6fc18bc912f539e092e6525bac7da302d5d8e19f2a3c0100aa27172bbc5c45d96d7eb015ffbf5ac0b300cfac40e942b887563abf5bf595b94a9bb0925e2962999709d2b42f0e478b3cec0b702d489be1ad826df14174914ef4ad18ea6089b0c39386930ee59e91e12747dec971cb4df8bd294f2fea8a74a7975615092295a50cec5487c2987b7657b809e595af0493c50c14c3b6d982ae70d285d60e18cef4c9ecde81ac929d427889101ab045855006293e72d9f2ef5da5ab9157be4bdb54a65ce78fa094710526f73f33d08f879782033c83ae46f8833b9148fdaf2c152e560b159484455c80261efccf4f28d1d9e8486d46d95bb5ecc78ea4c3865dd46f904cc8798427cac867692a8a65292a8bbcfcd8ae07c8f03f06f93b64e463686cec72f8f64c14a7f4208c3f7e222e737fdefca248b139c63a37ee5e96f5f25c2648cc8d6db9e3bceb377e0da328b8836e19d294d41be9a19f332c24980f68ccef7968d14e39d0bbaf7bdaa982cdb9cf650e205d7dbe552f679e9513009c22d444b3d3b84d6b12615ab464c08f34ac150ac9d317f63718e70953149e5f38baf1f6edd1bb163324a5ae592a9e9e3feedf745ca8afa1b7b09643d5fe61819b3e3604fb1bc8fab57b5562b9eea3b00773aeac2820af8a701ce4385e42e89e4bfb6fda9a1e78079099d7cc47b807d9cc26d0fe6f0d2025906627fac85f18d13ba116b284cefb5828a14584aea0be4a2c2e794539287a1a5a39a3517ce1d6baeafd943bb139c2bf207f730ec4a641d88b9400bb6a2b239adf0185c131910603ab2edbfd17228da65aad6e11b5e2285d68e81bf8ffdae72d9828be9668b0ba1ff59e3192cd9c242f2ce82822da0804b437bee262a65ea18d5c8fcce943adb09db64d6286bdf0be5c31409aa8c3f8d35985ad8b34746830f95ad2a6d9ab2fd1c83e3b28a95d450b14737593a99647458ab41acddb1fc28614f574ebf165f81998f8bb8f57beab4e65dc3c41088bf314a3755ba4d191f60f1626aa5dddd571a9f2bd923ec0c3f02a64d7258335dd6e083378e34d1350c5fcd5781ff9cf1a6384d092831aff8d133d0b9d1d526c11206229c3286cda8aa5d56b54f31d7519f67e0918d6252a387a70551f30f1eef8b34751b0c87ffe9781eba35d012ebf78554fc3608d0cdbbfb1c1715e9ae37228d925e1bf4f9c2da09999f10332d8c5a51ad16166c04f6c9df6819181d822412d34dd658262de3d7d9354918cd183af6f6099b2bde42a90a0eb3b875f164cb654fbc6d2ee0141c24bd064ad011318528ff6ce9406aec5d0dd1a831bfd8859e7939d91bf323ef0179aa738075532cfc968a66c4e7ae140c9bdbb6792fbe972ac20babdd121f856e8bae599af8cd0421338a26c1c83e48ef24581c51ee43dc31da6631dfdfc2058b99abe716b091eb181d9fc57748507c2ff7e8fd90607cab0e09889d9a62978009e72882a7527ee07493777536f178ef7f6efbf0e8fc00b2ea787c638a8aaafd86959e3d40a0ac862a4f55c793185582a381342e6f7e04d7e6065977ee64c61cc01fd47654a5fd92ecd15657453981099890c887153dd709bb92a222c0af4f93517e33ac0015d3955a2c5f33c06e226b575c0e6142b29675939e8e97cce34f5e2cd6ad341784195f0a5d65f92e7ce2b5adc8e0a647f9ad42524f768f480e3fe705b45e922b02614d46e9b92277fc375b990e67ea60d8ef7570e42860dcdb620750bc7962b7f5c0dc12efd183371df0f5e88765c953148b83c301ab998e90392c14ee54e880748b05fef5c8f5210d87c04174387a393ab99eaaf8fed55af23f79e65b3545ed837b72fe602d3aaf770bd645d3e17dcef1523e59a217e78d41134d4bbd428159525cadd73c7eb4acdf7058019941f39c62349aaa8d4ebc9c2b7778a3feda6bdf3cf97afa603dd8cd47b94ef4bf052e5091f37474fa993ec906d1106fba81054c86df62744bab80fa9ce734bbe9c973e77e17b6f544ae527681caff06d68f663a1dbff3fbf223fab9dfb34ea5417cfda0bd3294fe04911c6ec2829004354f967f0f1d6190b3a8eaef30ea644fd2b7b5c195f73e147672bc641a218ccd6f10ddacb70bd0eabc30d30207b4cdd47cb7046c315be3aa1b122fa12c7d629e2efe1c9d9bf236060dcaa2968692b54de3365371390ed133d831ecfbb413fa340fd71558637817e1bdc35006d12220461b81fa1ce8dd4d595a92124b756b002cf78b41ac710b86766536d94cb2bbc746ae1b6ac518e3ab5c9a1e6bdd845d79dac2070a3267b9b63d4acddbc73c0facb41cdb1d290084a1f24bda0d12ee33af53eca849ccffa32cbf1c6c533fc3645b164b0ebf8242ce80b7cac4e16e59065f5b05c016abb56218009055f790b8d6021b5e94df0b981ce44fdc787fe04efa5bdd0e794a25398d2d5d4a319566ed5e164f49a63d7b183f09f0b5590e1a408cdd0ca22fee6d2931872ecfa10fc517ef25c1eb59f63df8fd9eb03b768366d4452bfd6b71e5e4db28b91c455c26c8b0a67fd5385669fd8765e2b44da0793c0bc310c78c69f643c426663daa76df3e6e8e4f1c1c873f7d12cad39e4b98c9a1e2752add65aa02ebdb115aeddb6ccd7248b1dd5a5c4db803b9aee7d890e8d908fe044bdda1ca853507747b57450fff64de23d04cb9121e2af892ba0e61b6e1d0f7ed04565ced5b18dc27b3f3ff8e7a7dcff92b62fa20ee5cfce0efbd11b1efe26cb5ad2e8edeb625068482033aa2ed84ed714447fc18cfd31b25edceaa55053b5a8e8f297f46f52778b14f43330e09e9f919c26fb9c7795e632669a6d8e170bb72d762616a3725006cd2fb2c7d78f78d6565b5d23f80222aa1ac4a2014beffe1d0de836a8a5494dc21c9cbd22a513ceafcf54438dd2f40a5b16591424209e54831c7e00caa84d47c936329e0995edfb2201d4d08fc2766407e6edd6ce14acbf21bc49adc5085f0e25c0177e272c733e0ada1d6ac74559e6cf1bea5aa960071fba03b1e9ed2e4025b9966d32bd346951c173e2f38dda7cb97f0e5676d228a9fdd4486abd8312b2aba8448066344bbdd6094eaf9f11c8736e17871dcf521153bf336bfdb5346e9a64554dbdc24e14243a68828ffb86f8bdd5dd5ba6c0115a4561d98b9267741960269c0b24e761844613bf034ccc9954cfcdc7a0299fd3f6759c8e3ee5a4b37f8ac77cd76b21b5e45f6025602940df40b9fca06ec72f42dcc62485c0dc0066ce0b5d9db030403fafb5ae724395b1f046119e90afc84943ccf70e120d5ced88b781c74c9947f71bebc84b3ac1d1b2b2c810127cb47d42374a43d8371c39345728b64b0502793f69ac7f2c3d5e4d56fbd5b9729e6297dbb5a8f325d8f44f84ee1b6d2af6495e6183d8066d8e6146dce59195f577901048941429ecbf2e368facb50eb7612c11556ad0e73d607cd54f76755ad4391ea410234d59aa8f36c3ccec804c3365ca7134a3e925ee4a73af4e28484941e829b4619252aa837aa85c094130f1573f9e416ffb93cfe3c7e3c88ec0344b902c13af9e0617354d1c4c4c6bcb5885ae768a502e249a0ce82451c77ecdf34419031cecb076cb4e520812dd931c7b91ba133d2524864dfc6f20c1c33595715c7485260b957a4790ce54f83e4487a3c10c4cfee9f287789f082466cd17240da168a1dde1acca424477742c5911b1538ce685750db4527845851dd794af658af15fe02548f7d0a8e5532665571e953609710216e6206deb7d146f46e811c3c38e5fbe436a6e217bf27af7166bfba989ef1690518900d9cc9aa09f0e76f61ffe51b8508485cd36be4ed5e022e7783ea0a9f82cd6c3e7aea0d94b934262db8e5c334faae1a427724644352d08a44328e93c9edc8d2204bed9040b1893e1a2eb8988c4cfeb4b6800673dfaf7720bcdd6ee58d93e8b270bce59d3838c11fc5ece892eeee717b1614a834611da07d9ff864839a5946bc9ed596da774a7f77f118526dd83053620b717c45ed99fdb92a1d56d5e9ab11b0d671c451fd4424482a2642de6e6857954031436f0c933a7e84a7ec54b2f1300a3bdbbac5f95811034c7cfdd39f56f34148dfa285640c352ed5bc82dbfc0a0493caa2f18f668ae983004b583b3bb61595b3be8826c3e1565c975a70b9e030d151eff9e1a44d94613ac88f7f86ca01652b2b2086baeff9ff330e6ccc1433ab35cbeaee2947b0e246391f011c9654b0ee044eafa092cabbf23945a1f0566b32193a14d1f5365681a39f053e290518c715cb4997ac523949c2fa026a59cd0a284d29f2a99e8c96360f06d258a6883517ca6c0837db042bfa2360680a4bf1b4be5f77a5e032fb054294a7d0cd6843eb4b64a6d95908271bc31831be6084af68e05b1be06e397ee4b36850734ca44bc3a5da6ec4a6d7bca3022f68eabb2b6e10c1b942111f6b308959618110af848eca06e4adab9ec4746f52debe6ebf08cc88323ef8aec417de03ba0f9be6e2b66678e41ad9857d8c3ce51c119a0756729882fade094fd0dccb6cb49d3a03b851c74ea9db5aee1649d9a642c5e43c92f7f56b3f0f3cd522bd48b7776d277c43e18d4adc834395f0ce344749f698c718ff05336597da8920ef5921a3aa8fd5c8540fabdd0c468f8746c87f1b658b50e792783e273136e22c8ed47d30f9ad2b4dd2fe80c375a8643bd01ce5c53a465c8b6e0aa3428d6e7b920fae32364bfb7516832c043e6a2c6bc3178c8bab6405bf3ab9411d570c852dde74bce1879136ac135afd48651c949e6cba47a334e3279152a1e990dca6211e87552ba4267bf77178d6bdea19c5507be789f7399d87ef2a7db3d73a0dea7c5db5dc19ea494d09166b3cfba1f42cc691f2c8203d9fef01ee45284c38c70b6a5c00c9f4511484ee578250b7467df8d721b396adb6ba074add80ccb10896c51aa09f0a8145a59a33661024d55ecb259853ef8ac43ed5068b1a56467291a2f1bf5b0d4cd3b8504835a8c2e816abe445175834f112d879ca4a84321ec56df89eca199769921783f25e50ffeb001c39d020579c7b120cddc86b20a7288cf35d3aae888d52087e182442aaed8a7b6a72e1f5ed58eda3aa0877cdbaa4f093f1c15784f02c0402e1600504f054260d5fda2d1e2508a8a42529578cdd2ff22871f0b6dba895c6c2864b2de79f208a61a49101df1f3cab6ba8411513415f5816a8287f4a00f01f9b3072b4de18882af7117d5fd780ac467617872e8653f88dce00c0e2b1cdc2b950ef5a81605e3a5c3e2e5b63b760600160403369b211fc3151336e80b83af25b3c8eb4d5f9e86fad08db4670c06cb3386fd0112c46f5bbedf79d6d957446915e1895aa1111eef64c86df1a9cb51478da4b0c17ffc9912b8fbbf34f3e8209f9879dfd37fb37b19033dc497041a034293548f014f54b5b251db5930961033e7b5c0e3d3c975ae7418667cc4c119022c4a8ff0756a39228015187249849804c3f5189556a1912196971bc5e93270d1193b42321120b65611d416e627ce723753ae0cb1ece0e3ca73aeac612395c0f05caa7d236b2d1fe6b39dc5ce05d8d34271c041d68aaab9ea217fccf9796deae4ddd685dc44f09a30328fc064a93f138783bf026d8746055bf23ede2a4eeb02c500df8ec5fc409c64696036df29fab811ff529a4383ff76c9f0f568753a9bc0c685f63d5d4a164f5dbb543f97465cac8c9668b2c1fec43b542c561905d847216d4944e3d20c3b6486a5b06b6e76e0f909ce563c7c2fa1b8b96da7fdea833fb2fb53db24f8ff3f6fb6cfe277148317f8c532d04992ca4841382f0920bb0c5e3142a7e876fa77484ef76a2ecd8a90a9b753e8a41296df37f76b2c3d7994bd926ed53ff495613bfa3324bec5a3c3b62af7d0ee2d99feecc6f928b2f09b5fb116facf79e041a83bf738b0fbca5475e60ce074d771ac85ead471833da283ea266a1a45333a4cb549f74243b5c68d57486c7a4efe78e5c4f01a37aa4a8337cae08c383177eb65501bf1588473c91ae1b58c791ad99e78d01025a8e1f4733a8c36f0a223ff0e750e36c24865146a1572ccdcec45a12a8bb487b96733ed42c649459bff7ec17de7223271b22957d3882265f2873d44f33114720973aa3efa1c46fc3e36c942b3cdf50d34daf675a44c4f954d598bda07c714b126d23fbf72f799079ba76b06d00426c17c141cd75fe9e550a9502ac924f5b327876daed4e204ecaeb4c7d5ec3fd6fd0c98efcc8979b7c2f27b4fbdb16ac399062f487e6c2c712a993a7a2c798844c576831462ca13e122b8f0212c5f214e4dc825fff2ddadb1188413081a350ab700cc24e2a4efcdeb4c5561a845784b2da777b9e7287d5aa09adbd94dba35d498f217ef3227326c53505c5a3735e759228b92f8491fe96deb3670ceedcd5c0b8b6e90ce1a96d6aa80fe54cbcc414697884c329047d9d0633cd905541fbc5c5cd7971f962169b654bcdcaac2b175d2276d0ffa485de374484670eb0d7a4941361f10e61ecde124a31d829c7b605a2adb36ee7facbb06e6ef4a799b9291c8859b3ca1c4fe1f14dff177e05435b1df0fc7323ae365276a57e6c834ad0921cc88a13b542ed828ae9b1a6f3cfc11e93ad2b43c6e63844a506f255ed6278f162799460ce466ced3f9c81b1ee5d250b4053ac940e1819ce775e7aa5a9cfe1a927d2bf071917472c9733cc06900bb604dc402974bc70eaacd714000106dac0b724bd326bcac2c1dabd686a0c81acc023efd3af3b1b378b8d244b21a52a6699b83d82886751ef6e132ccd3590882d6df9e8f42e305b2f846fece93ec744a037f5f5aaf2ff8277dd49c52a811d3dcab91e8136dfb058e47f2fc9c56d74808c1c2a4381110e87815d1f590d5f7d785985941c693f828950257ae0b4d1645e708701f3e2ecb6c8db15c12ef730ec5bf46d6f75a5289d9b2987baff0739cc1e5a551eb7f0368b721f3f7e3caa260ff078bdb28be720117b6343ad4ea8d055f80c3a895c645a40e756ef66359c721b765201f682b34ac9dd161dc7e9e07c1d004daec5e35b55e45dc6c6a85dbdb8737de6fe5bb2edc43b1c4d1d1390d9e7093212a9d1459850ccc7c45c05e79617a6745de3b5221251067705671d391aa9dd382ad1c642c1830a64003066fb839f445d37e1fd4f44b5439ba24f7bbbd434c053733e9d41503c24af9bdd83f1cbb73cb86c513036c5cd253ce312cf5713271d5c2727be40904dd8eb2f3e31dbde8ba70fa92fba39dd699ba731c200f9bae6065b215a1f28cec0d1b4753aee30de1ef56f575c06010a578a02f3b0578042d5274860a1900a82b8ad613f06bcbd864d59cbe7ae4cf3c10b6e36cfe10c48a80da5d3283214a5422082c0bc309e4b8d5d952f1275c84b67897e78e7cd852284e5d0d1fd8546d0295914ba92d119a8f94062708f18830e000caa5c2e466344f828138effe328f7724c00698319fbd17d796f28f2aef540e7d0dfa638828abaf9211d1d7ad9ac2369a877443426fb436b9f21abd081ddcaa43eb6aa8cd3a043d510e10ed8954d91fd0abeed957b3197d69f483ea1aea111f41b00ca8754ecbb5ccfce853e363b6e328da44041ddf410d0bcf5733d59fb4fac9dcebfa957b85ec8ffe8a6c44b28183ec7a2ef4492a52b2c2a9b13b94c32941d75ce5c23ae9cc37ca104ca0eb23cebd30fc6494f9997e83418df8f7aa239589e263033bd9e9e786498c9c6a24dfa602a45df135f3106e202bb70070a88f85e0f3f0f2d6b50d0b7ee06c370ef993e11fd20d22a16ff0ffd250347e6c8bc5dd1785076f731f185a6b5c8aba4c75e201ffdee036b2d52dd4cd5a74bf8c9b94b9655865218a6ce65ee5cda51a42809389e5e61881277c12d652326287b641eea16e5db9ea106f57ff4baf4126db18541fc48858ab62dbec92bf76fba873e96e1f36d1391edfbd5939c9866e8894c8670b1efca22d61644b2f04f19da3f71c573dc3a97425d0fa692d07d06f4d9026b1671059a335cc21c1b7a100817b66921cd4b6c6698a5d41653192191811d14c2a41039aa4757c03674a132cbdf1e1145d77fd0fe5656d36b46cb0b890c0658d90ca969bee46dfe6337a176e49b898530e35d0633872180d070f643ad64834d4dbda2b9eb0440ecd1262170b8430ee62e3e704544fd2fe100d81e28bcde7aa8d10bef3e97ca465a0d5ef9994cbfbe0cee504a31771c6471a5a7be717d4f190817b4016cd60ba52591c30f131993a67b216e24f44a44709be952153f6ff3eef6e3016e2f6cc373915820d16d2f751ee75b4282e88f82e14d0eeb62c591ccf6be82df15b7586f23f6485c140131d429377c7e725e0c89d34317dbb20db0834432ee199fc430d9c0a71ea77d5c6425339a0e520250dc46810ce9f52936944480dd8111ef10c2d10e70c1a78dcdb7fe1c37b580929deaef38f0200e73e4efd43f233522b6c6132bea2f859e5519fbda6c890286656f83057c2afe1e59030f812c20d4718e1e101c835da7c035552fe16a9e111b4b9afa93f9fcec2f64e00687b48f50e4a72786339537e8cfd059ad32da48eb88b0d85e5771e031038b453e67b53c3cd0058685024b2c99b0cd5570c4a52d20be70ca889d54737c77050044e1351f0188778c266c6d4e5f4fbd91cacd2adde0a2b724c5e617776f3aeef2bdb613417c2c1ec39bfeed8f290a31a0e35ff83b4d58cc7fc9ab514b45b4f84a395ed7955930025d44698651a06b6380630a8dbb27e89dbed5ba567b46633947817da795f9b1a85ea9d10dc7dcd69f06a7a72b85fd3cff06875e03583ed7fd1fb4898c0306bcc54f6236076b7e0f66ba886d12c1b8d429443c473376c774b80483d2b512e5af34a337c372ec8fabbf788f3e669e39b5cbc8aeeac920dc18acebf11ea29d53ca8012204ba700fc9344d98863726004898a14831c4dab2a42fa4670b134a36c474bc2d03926ed5308c0b767845474ae241af3919695ce25f523c7d181ce56e3d93efbaea8e127779c5df3804deedf7f71fe31a18ddb0d9cf7b6509d84d23e3506f810d5ac9319d38b21f084af670a454d4d6a3da9500de9f44d255b9c316817294e57c733cf931f74273d302a966f0ea1cd0ec7ef447d5d1f0dd26efab85edd8d21a6c1b6dc1f28aa026e93758359c66745b5b0bcd9a1f6b33ca10b52274aaa76687400ab1724d1cca26b6a1eb2e089fdbb2a9c745388f23fecb41ce1992988c07fb49c6b39bdc5d200f020251558905dbc2886bef9486a5b4eb5884596ace94a48e52252baf0eab4f349c54f3a6cbdff7fe341dc686b40602cbb78f994c7551e5e75325dda39335596072c20d3f31c657cb7d94d94c34030a5f2a0a897f292809551c7d4b6cede9856a20765702403a728be4c5bf5cbd5d6c3ffb751305d9a5fa69ade3206ce516eda67d3bb3bf74f88d7e4d9fec8acfa7d6432ee2237039f7bb8aecdd584f473cb1eff820d448ac7f2558c44cfc970343bb21cd21f1de42f416f0fa23822b7c06336dfe0a3488c2ede15eb5a0bd99bb92facbd868f0dcab43e350008b2aa316487faf23474375b47f7287566cffaabd6c7cb9d9f5f3a4ed92c3242245e93e34997987c5f18a9de2fe2da76076bca535e3115758436f5d0994ecfc52b6f7f4c488c7ef8495e18757d5518849373a6d3c4e3c2b7a86ad973f1561f47763b59fde37a429e26b8da3b6fbd381ed5e4918e53fcfb0f43af50cf91cbba12fdf00bf3049e498629a189efdf51231c66a47f2899e881758023888790853eaa3f98e8c24b8d876f7a28edf460408bea5b372c73f26679ac183b0af8886a45c39e7bcf053eac7c1d303be95c0d32a0a36f56b9a1dffb5e1fe8301b2774579516ffa041da75406970ba5150c719c3ffb4691d871c4d30d87e6bce347f8a14a11963a0a8ea60dc11214d318a8db49788c807964f325e37e6c63d96f553e16c930aa5d726136ebe10a3ad184c8af02fca512fc76badc0d953e1d5a4f5bd5bf9d3f52bf450c62ff33e48aea7d6c1d504f8512e5308233331a90912e8d90f8601da56e4a69eb1d7cd2fbcf083af595f7e7158b4d294ea7f96818181d20a48ad0925e3b946f32a9b8c1132758449def39d0a9cd109eb4b01aef6abd67379953aaeda4ac77a8b1011f8be3f90be964fdb499767de7f75588227d1a227e4ff35509f39427a4bc1c1633e1e29f8aefbb2cabb815e7c1ca374fef90b68ded47ec08297f9455ed3f3fbf44c344eb47253be096531120f1b471953b89282d2c10e1ef7296c44f79f721eafec6c076e0eac59b943dc9b168398b504d8574355b35b849229eecb88f029bb054ea832bf0c5d371ebdad610df0cca36250a21619874b63529fc33bdd25036b9f29b656f67b039f8dff1e2a601eb7ce263570534963401c19946e38e58e592fccf4afe6a04eb1f60e00b94f2bf688efc8d475841f75db3a2d7d3dd5e54c968716b886ce7c6e8f75d074d73b55fae16dafb22a702ac8b4e9132c6d458a40051fb99c1870bb0cd14bb54eb92e9d05f752da12afaedeef588de0b1757e23f0e8dd37b4066e9f5f72524e09a3aef5ccc47b52f1a46b332ff5b3d6fe9b19c8f9d682cdbca67c2ccaf5e5055d5556d45c5b85d38f660a3e38fe792d198ed1c4489b29afd138ada15b9dd3c27e226bb887f8c9d4a9db0b2f1013fe5cda159b99a3d60fb85793fbeef93650bd792463e30e467e13044ae217092457d994a627e0984b609ac97f674a26c63c54a0948941e6cd9f0877de090cd35398ba9dcc833dce6968891316c9104cd40456e3723e8849799631e7d152c643175d81390b749a4babedd29a606b3bfd275df2689abf3ff0bc85a394f102791ed7fe8fae0f11b405daf30a97fc6237073210930cba32d39ebd56bdaea452b6445e69f29a24993fe1fd2e48ea9a2257eea18338315c39ad47831e8f26c5df81fd32a133a045490e8321906d9e757a492a77be759d674cb860e16599572e4a0fdc50c5b67330f935a9c0cee7a696eb35793ff3a0b37e25398e29421fdf3989a630ece67011b4ea41bda8a7d7defec599d6afa1b288cb2965aaf99476658f753eab908e918da474c97836d45eef315c99b36fb2402f8cd2a72003e1e7c7d9df7cf347c3f91225532f044e6d0e832706a7e95d4e78444ea802817d25eb31004d9aac2db9fd6bfa34567c36a8c826415baa6db8df944bc9406395f2ac84ea8e3e19afa9e170fcd0d5282406cd016947a80780ab5286d564d41a95f58727e5f620e5ec4abfd6c1e9825e79f49c5e447bd9fcee3e879178d46d3ac5344f942fdca554426f3a7431d592c1d2708760dfed13d4e35305cd4bc6388f89bf90b61246af936e1c5162d389032970fddc82eec26af9c3e8721de757601d93d47e3e3a4b449f1a8e3d5262cc5f1948680f75c6260831dd056957dcda5d464bc2d6fa7ba617f53902749ec3219b44b726fe4facba1d779a10ae0db16f862f1ff75b261b38fcf72513e7bdd107f966d792b07db35c818ddf7e9f8e18910fbc77142143b95b1dacbeeea82227389ba3cdcaf58fe3a19151b5f8833b23a51238fcaff2dbfe6bf19ca12396bfe96b5b63f5b4fa1760a94a7d10149ec76a3f012a6bd0c4558c4312356705ace800d4c09a42a7d40d31caf45146eb311ffba0dc91326f895cf19a2478fb8fea0de35782cb769658da4e8d2eb6f1046367b4ee5b03b54d1321690d75bb96e938daf79afa38ea2a47432b5a1506860eb65ee313ba46d136057d8f0d6513065846f54fcf1c29e9672338dafa8c9fa2678a23a3f3bcd5a3c10dd7e522370c00e098652dd809ec3dbde39e5ea0cbe12223741b97e7e8d503ad31fdf510c8b5f1665fa5ec90fa7a754a697c92ca4afc4b97ecc33b11fa89d68951eca52496fcfaff219be9349ad8228e2bf22134365cb0f25cc0bbf04c7d20d5f1f3966f46d19d0d84d60a4a7da36c0f6da5d2b8c49aba7a6b51d282d2946a1fdd5d23e13fea5b4d8f608e5b948be1bc2b5a3f8b5bba8f50fa4eef431155bed7b9875406f73892a7b21372cdc4a3764561bd66488ec431e37cdceffcdfd52bad7f1054640ea860f83ef3b8a9a01e2ae0d654ca1e0b8e225b44208af7cf463421a600178511535312f953e97cb52b72f1282c6e35877320d23cda699453bf99fa7327456adbce5b672ebd969564a428a2517427319b06272f222a21bdaf9d090ac30801087cd24a13f310976f06da67143c05d58d15a86cd61031aa375d67c529dab455ac98a264953ec5786cede491f3a1a1e0908ae940433fe127e789a6a039d54948b10c4a6571c78d3b37d55e60c8407a91b3a5dacbb93e144903f388a235b38c602bd19ef89f26fb5cf166d44b263f2bcb04171e3bc22d3ca09b86e305f7ee0db4c9bc106fc71e309f7287f6a800e945576303f95db27facb68715902737793aa16f7905ecd7e21d13076f133a7da008db79fea75e397f36282908a20faac1920d569969fbffc3fc72f1f1e3aafe4e2256d59d4fa4369b436bdf3b3b48f15e705f5f96724f5712eaf78a0c072f523ca415c0c53ce055533199278e661a9697ed803220dd90f90fe57b4f1c5c0a1a0ee195859949833f3929b193c173289225c64192f2e8f06c4ff1a39c0a465f331cb44ab2d8d00195845d44bc42f71ba19ad2abff5bf75f1c50d024edeaa1fd788213c1bb6f1008722163ee8b8560cd88e056435816784c36ef35dba2b4b8ba05a3a81cfbf29c86c0a7598bc0aa9e50a808d61cb3b538e9365e8152aec6f21ef1e7dbadaa3ff44a21bafc82f60ac904ffa66aca88f32d3466d253c7ea97d9d283b6f27e3592baaf7bf6cf5dd44d152e1330fac838992f62557d91f4a552c49148c4ceb20967a6847619f1d380b63294ca850ca94c8bbab867e6e7c8a3aee9bbe5c60b623672b6a8e12482045063b42c5978c9540b8cf2dbecacea798ea7f73eebbae8fc7022d401bbcb1e6f8e5c26e0123695929d4a4df998944f8642fcc936f563900f5a497efbdd263764a5b4e0008148a877cc5395bb773ad2cc958090d72684cd2fb6e99de2fdaa4c7d52c341f05a6d67868ffd7d9ba61364a1327b37efc32511ac5ef44f3fb8a08356d51112424ddcb2b9a1b97ee140ce695ddc0bdfa71efdb830ec2a3440a9aa31752c1d9f6a2d6375069ef75dbecb00092e12b5d186517c0154c366a4698746dea0c2049fb83128b14a1462410fc7e6fa8c41f49e36e4d32469abdc64ec0c50507310c43642d876b5bf44870cee18c5634f84f4b9cdc9f6302c756034841bcebea841f281abb51da78fd3487b90188b03671fc4ebb31997d5e00701c2a6dca3e3f8edefe095f486289bf02016b6146a331c010a3239b82571544ca6ceba824fa71ecc43de11860ae18b9151425dc1308ae63ced07a57e750b6b42b7f276cd64cc72f55562290b7b42262acb9584461fe78780f8acea6c7e65bac7def323d436f49bd56c323a16951b273777f0a76a8a2b794d008ba6df22d0732fd41b450f0ab4d2ee0b816cf5db349fe5c59acf8503ba7e52ca41ca10924229a3c94189c8b5a0c5812a70c2d813888b4949bfea157ded625b10f4b3f1bdf5b2b2f19442e4b073a5909cc07709cc3b91c605d6f55d2b0065a0adaf7a604bea879e455f6d9a255ff88f8d3d5b50d1f17fd68edb260eedf54b337ee4c10c75f8045ddb55b3972ca8bde947b79ca1a99beb9ace63da69c9d8d6b2e266eb477ba55524707773f16a4d6bc11208a8b62a3f81465e9bba4c1193304b6477fe00c9060241d337dc40d781fca55a94f51882b5ebf3f90502f20e231359703a330084109b2298438d1ea0d84780bf2b5d80b2704b7e5c2610346103dd86aaccd556f52ab7e5a89427c827a76a414e0d9fd989c6d03706bee4366424ad18e855040c84353e501b3f7df7b8cd49b1ecc72ba5d14230a0a042d5721b5891809dc7f96ce8c119e437b483734dbdf4abbd13f95f30687f930ecc16dbd32dbe66e76c8ded2d2d2c276b005070f0dadef95c0e91ee945162b50090205d7c3b98046fe9d486170a501629a260d4d4a7eacb6595d4b4d01ebd87e5664fc53d0f3bdced94e7669f9adaaf97d09927a92431c7144b32cd789a251e7a6f8211245aa198a9b5dc400b8b5d7ba971f1f4ab2817c8ac1cc3f194c149579a50dd92a834de0041a44db249c63c63c3831e801b9cbea858a512de046499ad641984d1839e5d2ac917854cefaed586b75ce0dc7d6f27788a1109a30c6127dc5b92a3833ed63c008b883430fb1102ca29dbd4e08c87f237fb4ac3e13184b6f9534697f793db173916701ed544d6a88dd4e150e19ae2d849347a9dad7a7c8928fbe77b86267bfd021643778ba3d8812bfd7bb05fbe80a2fa0c16c9498a97b3057a066b61b93a9cfb3cfac2600612fa21c17a7772a72f155ce14053e236340dc6be8316c68cfbeb8466a18b4f272f3a49520effb6691e1a4b20bb00d5a8608f1dc35ffe534db6cd3341073022c0262202369ec83f5c28c23215bd2908d6997ff12ae20f38a33e80287cf863bebbee802938b4bf8d1ec89438d28c26c71f7c99eb951e237fe292bb7a52301e159088dca6dc1ff960438d7592de9be72e0c275940e5eab7b0e7d0883e509aee48a541223f846fd1b48f88ea7a159d62c5841ca24d0a8db3cdd56d882e94b34d2407fbc1eecee3e5a269f5b1f7eda32508841ba5bb7593dc2a90d7604741f609bfa7e091ed3f4c76672e578836a53ccc8704dc44cd6b4ab781603e5292b786026c5297c811548034afdbe43be6164cceba7fb0bf23c84dc458b0b28f51434152c49425d6f67b024a67c58ddb3bc2182fd9409ea2c2356868ccfc7951f6e2a24160bccfd91f5a1de7e06ef16a5819e83d4f7a97fa0340a8953854df3e03d75072573792110eab4be937482dfa031865b531d3b03facc08b67e06d121c020623983bc02ac0c0e4b53fa6a1a6e583f822c094b8ddfdd3a2ee9d079c39549e42fc018e1a36a1882293500ab72cb1d3c0cbf9237d31ac47e1a0b380f90695bd685101fc19fa01aae6fa3e6478e076605308257ef7b53e1c4329c6e904e2f875a8af73dd1bff3a5247752a99a0fb307beb129eb7c4ae00ca178173624c14664b16a8ca2981cd184d328b6c5941e29415acf77cd22078d7ff17376d3f5eab380b87d6c40d5ac4a2d2ca16d37633dd5995f75c68a0d4af41b9b7a25f6d321740d89a9c3dcbb3b8fc99ffebbe9386bb1cf56df856d99ba9c7b219b99766276051ad4d7bcb8a4682196b4f58ba1ba178a5a8606e1a0ba84c0f315c8d473279a0884f4c8f3909cc9001dfcdfec0b348fea063d42c70568f0b19592019b87a3fcdc418d5335f9cd41d5aee1b727866ae2b1dae37f0a98fab33f2d4dcda7970eb6ec7801638ab82ddd52b4c60ef4814351d1cc24c26142bac0d8f9005ab56d752590e3c534c02bf4ce9cbd0855659349cb219c85858106990f65716ce35678f2562cc832f161732dd1a9dc0ecac8c210d9a6ff84432142e9eb2d9b6db5bfdbb56a767d2532b9e2dc7ff1606e7616387be119bf7d45ce7afca56b90366ce3e980bb91722dfc5894e1bb1aa45405abf53362b838e159928eb1bccc559a2819948d563cb715852cb79514fe40eccc5ff417e71b9d33a0a86a2aba8e389ed4b163723c6ac45a6fe9da05188513ee8f3a3a386c0576b4ad1cec22e6c689956191f0cea38f4426a8ffd178dde84ee0bf25de13f6057487ae69cf50f652e88cb4bf393f322b6533d739ccbd98801a3f4fbe168c40353ce57c5fb65191865326eba9d5f7af29e4f04060433a41cfe72274d294acf65eb26ba7728bd6e8ed616671ebb2f7696a6ab7ee1b65b6e9d5c690acc32dbdd5feecc8dce8c2fc34fd748c76e74193cc53ca1e737282d4242ac1f683a6bcbcabacc05f3e78b0be59b6254fd9a44854d292b2052e93ebf5d4d06c45a6da163ca2bc2d4e3ba6a939506649ded2f35542298ccb98fc02001e9fb53a13308d019cc24a130c6267939da9be1969d612b2fe8338bdee5b42af2bd471fbc8ab0f0ad12f0971f4608d2c1e68a81a4c414347043fa60db879a873c33f1effe3c876864e70cc37c209fac419210d2f300a391a194294ba82695ea4ed84b669048722dd3b753c78c3ae585293d8598a694bb2e8bea9e4755da8bb39c2be1ae1b2f7aa44724c6aaac93004d9fff29ccbce3b794b87c0f2177c81f946d0e06991058fb7100074a27f43ff81c7241ce93d170fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
