<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b56ba53dafa058fd44e8d88bb1cc4739200ce4046e3d83de18d4cbd241033da89cf9c5827cc90875d4d5714bf178ec2375f7dc1ed0ea8f500521a8890eccb0aebe2d450509718ad1b145385f764fc765740f188b4293095bb8bc6a83dd31edf69837c2ef5ba9b5fd8608c9fd9a9889c4bf8e872f29c6de66bd9790107eccbb2ccb701f6cfec02ed9071805e29057c2a6701a1336ee4f357044e8b40905ced501c9740fb4af5ecbbe4e1fdab47f8de443cb7bb295ad9ba9587a0b5c5686fda5a77dc8ccf7ca0ff3808f145c448c8692a7d67436e13174e582100c10cd6004c24cc4c155b0c458225a35f0891976b6a06b163a9e295ef3b8fc62a23854c2a6b5438dce26127f72d876d37d8cf87f68cdd281e2f6ff6919399e30bd394fa0d6ec6923f89fbd9f0f1419772b6d33a673d7a20066eec471993d8ee36418865eb9613d08a45e50eaf62c5353594b78b401cfeed6e03e0f36776b97f75cacf26915d41f5ede1906d44722c913d08c0d15adb0ed6d1ba584975488759168d169daa91ff4a609c1765ed0fb4106e81edab949c8e245165c88c18faa58753d84bc78fde7e56c1a68bc7e411784b69f5166734876a17308c8855a226aa2adae27dbb3d9272ece7d62f664b04dbaf4b40670ab029e51ea8b65c381a89a9d83bfbb6a7feafeb8b40e382989dbf8e0d08435d2255758db0eabf7d19c6eb0dd8c310ba7ab47c870612fb31dc935bf470fa4566822bef97ffa9736b666d3aeed4c873273d7b67133980a53d8021d836dc99aae1bc5a011ccf52fb0abf12c635495638f8b3490e6d3bab419e08217b209f0c71f99d8220eae9266e26bfe59bcd5a3fb84f0b62ee700a7c28b6b7aab4b28cfb61be87334ccb108806acabb584e5d6e870bc0cf32212e03927d8f2f03d23716197368104aa8fb7aa3a8b7e3a1d80f72300f7a2dd2b273b6de3b4c2c885a5afab05ab1d40b51c3b520bae5b273582c7656730ef25d2e681e7d38ac08d2e77eae6fb6a8bcc68a9dad42c1f1ed49679edb69b6ac343acf7fd09b845fb9a2427fee9c6a650867b886ec3f50fa6f7a0a7b3160b20425b77d57d2bb2d0aae75c3e9e6eef6249e72e5bae05cea3d35490c83c9263de353bf7efa77aff5deef6e44b18e3dcbc597e93eb81626a535a48f13abcef7a62f9bc26a03ad52b5235595132d8dba327f7e34f4ab092d162758f2609fca26920c5e49200f891a20dbe6316d9ea57684056704954955ef783672b535bd38790e26982a305cfff0fb7032b58134c482fd50c124165a4dcb6f795bdeac093813763bd56d0d41aa3a821a20899b1c63aea9e1dc4f78ba706c71617d3de4ffe357f8e486be0556af668ca44332f2970f45d551c779323036277cb678b9d3616d9f7201b5a390a5a8687a104addf49b3422e440dcb2e3c4b007f8539491a02f92cf922f93d408ce7a00dc79c1beaf4c7dde930112a3c73db3830bb65658d32921a3a8629c39639cc44506c95cad77cf805cdaae6ae0794cf9da479bbed1c9cbd6180b37307eab3e1de3fa71dc450ad084a5d70e47949b13df34b487964c3d2192eb2740cba6adad984ef21bd871208c3c3dfd5804f964270e4de60d50c97b4e62c5d8bd90689b5d878da99424eca0f40950dca4369cdd8c47bd918c94a211c3e0f961b5df2759618053ebf9f683a90555859d23522e41c2fe315f07efd5878d57055aa2090c568b6b0ffb91ae293ab0f12372557881300980a1bd0ec52ea58a0f38a7a21478dafbce74b2595f1c1e04b9653ef9fc17f015ae63051b538cc9cefef660410dbe7240b60469b0d17c9337f4ffb50615776901a92be8676388a5ffa1a362a50860bbfb3b7d4fa0b77cc939b34ebbea9f6eb00bd815c7b6bb6a0e6bce2262ec4e514a8c75b0c900e83d618e1d3d9bc0f89ec705d69de962d90b410535265cae6d90603d69eedf47dc16a62d5dd3f8db3c6a8592c9608fc1d52a9956849f7b4bcf64bd841daf55dad782f9e64657739be9c99517e68285267d0b2c1f1536ac44faed62f06edefb3e22248f11b1e42b73278ce454a8c7181bfe1118a41cb4146d6088bd987b18dadb7642922879b23e0b8df5121e036296ca373e1fe17966597052251a1cd7a51887e2582873794af4c6c9a264d18e0ee9a532d45bb3800dd9fd334d3f9c48385f5e356c9ec3ac3ba319396dcc7277c6b5ec4b7bde34585654cbe718d8710f7a5df9711e94c020b3605cff5e9e9cf18d72cc8baf37f391121eaa5685400c66626275e41b9f403e7514702159ae877d18eaff7ba2d4ea830132b55172639b45ee30231b3aea08337f761aef6cb6a2d12fd5016433bfb21ca89e3cb71d7335d313c886d1695e44307137f70ae5703c48f2ac310039b25694e3f752c25cc5f202178ea0c21009ff078a1a4e99e8b561846be638601c39f2739b7fbe4b5430b61fc76992e6c640eeb69e4be2e3bcdd3e833be56d27f0e5433a0314375b62b2214fe590c9f47d86f126469395ce64d02b1a182e54b2585a1657de51524d18fc6ee214b3fec1894cfc3bb0ee993e3c7747a73bfe1902032bc7efc499db34dbc36b2eee9353c160e8d387f0930f0bfb936a6c3456866ac0d41369de47edf96d74fc0b9e7bcea164f1a4d7640e8c4ad03f69063002a06c98d9d764712cdc6612c87d6ac23115a571101a35c0f84b894f6b71b29d2a419812533d632c4738b4170212625f93ab00d09bc5ecc1445828848beeae8e84f4a3445155a485859fff751c561a6049371079af89af86c3bc57bab2edf54bbb31a345afb60fa562a18baeb69c25c6292ec28b5b94f30e50bed430f6b1e50f4a368f2321087dbb4e610b81a06489b6764e763bfad5966ec17a60b7da94899f0994c8c5b652ab66c6fce5098af0d1533fbf76f6f77158d8387fc126ae9cd4aa4db14bf77279ac71ea8bfef7fbe8e2508c3c3c313f0fbe116ef166614c2b017485a03cdcf9bd67aa2d434be35258b9baee79b6fda0d035d4f716e33af482f62b31d9f65c6a2a8f0a8b039bf9d74f663ea9052d3832477f852864d4be63be3815f0eb5edba5cc0d743931a428985fde395bcf1a9f980ace17c6ee9bd5800e8c8041ca07871ec77ea46afcbb3a27f3a5cb98c587ee61c4ddf74a6e7de6e5af4ed9013c894142fbad5adb2577f6a8fac299535da99efa5e8c58e2bfc313ae2b4e91f58a74779cca58b6e100e73046a2bfb17ca0ffa04392717b540b6a4b5f09fb4ff553add307a0588e84bf4d8db54ea07b30b24565463eb46553d7717a31dea03fb874c180ed2f25fc32cfa2a2c21390b71fb80fd4579c3171b62928b12da4da2b0ae0a05e5abf465828a8da5decec2d8ee5a105890492f1e1ec243ec94cf28d8e47c0a71444ecd2e554d21d58894296c53c92800badbaff05da56c6e731152654fb9392048cf0f33354cbf028e0af754286b02af36adcdd8e9cc37b717a77c5764f9bee86e8c3e9193cbfa8be6f6d13a2c136a1f59570354115eecbdc66378c1959a4ef853537f9a1df54ccb6a9b23950058d8b7d31e309a1010415c4a83e1d0ad74e19759e4e8ed160c4a893916270a208c81449b76fe815ae21af018a32fe8c8602c0d0c798b7b57f72b470c70f9fa1bf8edc085396bbf230ffaad22559951be425af6b715c4328f57887651d492d8df3e5313f90e228e1d6678c4e3df1ab4939ccbe7e46a07519c1a530136d020fadd80b725f688da6e01fe9eafa26a1cbc38a62a1733a210dd57fd161984a6901f43f2dd51916470f7409294ab498e86dd2de16deeeab37a05f745732263f09e5d5cdc5450db9b4b3c9c94ad132b8ee642bcb66305aa98b5b09a472656cc7c18296ebac3a9cdda60aab4644145f41b1a1419f48652fa3cb6aee40bc113a0cda5cca17e5dbfa4a6688453bdb0001bcc7a5573b29487e3d43cfc770d22a292c41ce34b60339aeef709c5a1ab9c65ebf844934ae0381a3aeccbd4f264a1b13291cb1b5e02abdefdcd09ab2f32eb6b6987ce0cbb69f2bfb01c4bb87e1857b00b037071fe4a01587a004fbeaffdb26fe2736872e0110ca3664a05de6f9f9d9a1c7c140fb2d7f1373adf223c87b8e00886e577301ecc0698df601b6ab4690ce5400d678fe8c13e16972a9e52dcc341a00e370bb3b692e2655f4df9c4adce385babeb83a48a86af6e14c8bf74effe1eb2f502297f8137ec11087e8cb08f77a9f5929dfeea75921ae9f8ac1cf020d037bf996e9f89ef16668e7d0f829ab4a3263b13a48dcefec4736dfc6250c962ab67553826788bcdc07037a0bf291cf6d7707492ddc68ae5a7e595136f8bbb741df0bc50658c9ced80b90617f82ebb37c0296a9ee05b2ca3992732e9ea73eb9c8de0deecbb2198c1828cae4863bbf829be1632b017183ce4bb76303e4b77dc60da97e1070be8ed73e128f31c81d515d191f8d83720f5e12577302e424fb51fa7167728960ce5387453d1558bef8b5d4d0fea4f979485de7abeb9885335e00c797447eee98c43dae50a9b44194188644081e806a6fd5fe424bf179506d8c6fae524ecb945219022dfa4aa5bef5b0787ffdd02ff053fd995fc2c773717d1fd152aaa652babfcefc7e75a0388c0762f866de0eb24004571a0d3e2413e9f56ca57b64e9e1891840f82bbf326ec922a6a30e5d24768708b409dbde7e99858ce0c66d3a3f0caf44654e6d586bd2e44e063453858f4aa761ec02c7007bd1b08c3da15634a5a04c5dc23c6605aad030049887a97be79a0b85d2aaecd1609552e3fd8d2dcdb293f56f9032096f3bf823225e54b5cc598e86503aee6ec06b4659299d01999f405cb3f8a2d10fe296b630fd277994b5463a4d68f90eced1c0fb01363d9f6294be629ea86321f21028569b5cd06942184d08e3ca364244f1ad4bb97e9a781cbcbf78ea37815ab9607865b11122b6a5670b1caf93e0cc2ebf6ce137430ad884e6cebd67ce1cf06baf472b002a6609384b4ac8a1954fa71c2244ecd7d6d5160f76c56b0e7afba705e920484f25e8fe872580c2bb98eeeedcb1601b9fc4d4030d70b4f6b914fea0a3c5f7b79073f2e44dac481f6169e71dd0168f570dfbc6eb526122cf63706f5987f145538ae6067e38ff3a458de0fc6db862cdad7c614f9837429b0e4f3cb103df5f6c16e6cc9a0fcb2f1e7b13601e0034f3b00e344d3cf5aa179d37cbae213887d134bc81efe5ab101b51e31e269b91bc0ace4c8ed04c5f2387cff34616dd3ba9e3d4d9abe56f27295644d2b28ec3c1c02cd8654a591e7f604f725c4694f466f98f53ccd9b3e6df571a4b1e7e87a21633be4baa0ada3982685a052483a11a52c1c8c426751e4097217497a376c49e2dce933f103e53aebdfe50fa475ec9e35762f85c67064e43908f64f0d3d47a8dc7cc19eefddd7b8e27f21de2ec0f8335927b049966e8a5945e71ee6e4c2ac00bd41cd0c9c2a17d460d106ae2176137ed7cae8a19701d1aafbb5136b384b4bd6bdcf3e262b90dd9f935207e0608853d3938165b7ce49c261e8de449e675c3b9c49e1d544fe2152bc6a2c237a4d06b3e7283fdd50b763b3bf797cdf04b0c2409971d0def47e120f996aa343a75ec0bdb92c3e93e05cad003478f130f24fd0df28e39345c2ff57439b9c5a72e93b41ebd31fc4e6b390c99d764724a420f6483866b599f56d8f60ca125c6821577ccdc55e7363205b9259fe3dde2ea6347161fd4bf2fc18b7b53267a4e86f8dbafc2657b062475ba6e3f53bd66cc8db55f04fb65779ac75723665d439fe71c7d19ecc34a2b1561c6a5959d46262d8f9fcd4df0eb57f9ce5dca6d136be4fdcf98b12c783e7031e34f09abfbd994c856002e888cd7e27ee22164d08fc58e88ad8b7de6f5118c760d52dc5666ade4f724afa714715448d96be0fd5f3aec6f41d2a29111ed53d25361f316043ab0eb7cf9c86258674a446950382ab9d9a8b451559192f8dea4abaf5960d4f8f962b52217c9e655e9465dcc89bb5180572758a49c6a30bea69dbe8efac776e6438051c160a87c6bb1437d4b9ef1da963878e5384ecbbcfaf2fd0eb9fa463e16ef87b9de6d25684dbbec5afce9225bf5789ce147ad2ec47467f1d82a33a715c9a56a545204ff9e7478b5448ce3a7f23bb749c8b737150dce3d4615281beefa8a4bacd789e8bc16845db21b3de716948fb174bf9786c998a4525a9a9d71f307a3ceec446a1ab6054a83e78091236c724c5f558c72cee873dd00bcb832a2be23d3c82731a776ab0b0ffb0859651ad0a46cb1c9c0c5a702fb85089eb2fcc60e27f366babb6b42a1aa1ed801e79731025932ed19c988fe6b88b25a97e9a099d6e565c24f5546a5ce51ff40b54a4cbf991c408dc4abf1b5deedf226e881955670a6a9a2fa2313bb8cc3f414ff68706404d4f3a25e2127397aa5deb16482849325d17535fc30ad9d1efde3d2dd2d00c392794ef6c20d01f0cd4f7117820db020a1601c3b8e746994e881c3025088a0775601d362af4eb18a426763644f91299ec902c8da5d6b945b6b9113cebf20eee6fcc5b0bf26cb38ac1b5eaf26745a1c036c1e36630ae4b7e85b15640031347b5407bdfe1b8dc08c4d5ee4932188179bab1340ea13168a56d560ef033e035cd2177bec29a54665e25202c754865245e4a9f252b4bc264f64f5bb8d6fdc2a19ee2177c52157fb9369d659c5a04349df1c1c0a06bc18793150010da3abc7b8c69c82a245a7f330cede1f2d792461015988066b26a11ecbfb151ea7a1a8ccfd44d0ff9354fa27276b52ea2001ab17ae4fd566ced92384f2b5cc1390ee254d24bbe314b575b26d9863d09cb0ff465493bbd5056484cbc4b2ad581c088a502cc903e20d28edd7c398f10e8c539f4dffe65e4258705041c2922e1f350f26fa33b4d3781d20e6812dea2f5452a1fe13aca3bec2875b5e5b5c95950da8ff38d00aa84505c3e649728a450022e57bbf4296a5f1079b35bb19e8829a24b726f3d4cb8689ee2fa61bb6b9643724d384ba52f7605e469e27b2f0b356119824038453c4c07b552be4b06295e71517bc9c9802120b3c12f378af44e88dcd7ad7929edf887e744f60e90d49a69adc58971caac4dff5b0fc780b1c7d7cb0f1aaf01fd7be2769b653e3edf2244449d4483e846e08702a28a3cafebf0d5683f40a81b0274b52e8270b8df159be1494c37d60e117be421b5ae81abb53fb21609c708ee3d0ab133ae811a67f97e0225167140b42dad9c74896a80f0b1884dc40ffe44249759cdda0afc07b682baf774f777f09eeb6fb4bae8157b9921929f55f79d73c9acb921e97030ce53f278e8b9456e151c64545f0c45f79168876124451ac4b5be13ea2b182df7daa622520e3c85bb7ac83e65b01199c366eccbab2d622463dea68bb8afd766c0984af62033a3ba2ebf0b01b42c0297d420a98dcc50bd1654eb956d09bfc2493373337d3ccb10c3ab32fe9e3f8aa3daf6fb080e2808ed014603996623545997d4f5f5631f95e4c39284e16fed455b3df09ad9a82be30cdb7f2a57d280111dd387967d9cde0c44bbb2e990c95cbd87bc0a8c85e5e57481c451e5b6926c18af64678316c344c04e75e67de57f499943ee1043ea36971c075195f8fcac417985cb4ba0cbf96f170c3bcd307d2c10b16adaf7ef3db963f5339a0e3ed688fff95c2530b4d829308f9a0c2967f6ac54ac3bf227cfaa95b5ee742ec063e90641ac9aa48e05759d7ee683bae4f1ea3be6356b1c98c53b8fbbb45bc4666398b92f0b24e9514f2979d34a7644c97740231bc3f175258f0d2092692083850ede04f5db8a9003d0c44fdc64f9432fb98fe8b06afe1e1efa926ee86a3796c5a968d8a9e192176151ad939787b4404dfbb7418f3f27fe592a18ba2004b03c0695bad76a0f2d3e67e10d2cb3d73f5dc8ed093b7985e27ce9986d4662aa017bc943e4aab770e26c0ea6ee6c1461713aee1e0a44c73b573d12928786e26f16ebef655699622acf555cca446a1f8a69d936e275054df5b1d30f0f894976fef085d9e1986ecaa5a6fe3bb21324d6a35bc51b3678d0334185d2156f540ee69e79b018686b726128051cb0e69b74c663be7d8d9dc5bfefd8fc5aaf27f7ef6a42695139e5afddeff887ed30eedbd1233a3632b62b094d9f4f8957a83419b78e5288be505192b861de766de414b111d2611e08e2a4bd954b1d664d86cf45718232d2c9ea11786f1ed4dcd0c4015525d476effb96fce0950337b7a7b9346dcf6481a25cbb0a5f1a496429ac07d497eea016409a8158a971a68936b38a550f48a555487406ced9c235bb61e21d5c79f856723acf122bbae1208a6cca72de048d81fdbb22e59ff80ee2047a718c9a7eb1f4f0449cb0de3a0d2b21d0df816ea8cccc973f3bd1678277705de104844aab4dee145e80a83a36b7e65dc8145d4eca6951d3e0add8155d042ecebbc1bad2c65c79e88e4b434e91f05c5fe94c4b70eba82678f40dc001f8dbc09041e9f8fb3c01fe0d057437db376c1c6effa9effb411ddc4ff070f6a66fdd4c828bab9f94668dff7fa737afbbb1877abfe6c1622916ef26094cb924e3fec5085cfb60a748502222dd5ab0678f815dbc93e6a8502b6b7069a1c6cd2375111ff5c9a32a4e53f4c5281ca08550658a4ac13a75bca7f267b8ae9148b47221d82f7286c811d533dfae2718452cfbf40b1548701d64641ac0988378f44d00745a8b13a3847b83c95b2f401b77b9ece4d22ab59c1e8f62a4910570657fdc40c39ddc4c0ea2e6aaf45587ade72fe88cc0185d8000a1a9f9cdee57b17729f9b88a3a66b70fef08f1f68c9c83d994fb32430707a8c6913cbd4d17d4a3408ca96092b5989b9c861c0e1a108be985cb9b1b3c1fddbb05684424a121618f9709499056f910546b872c95a8cde065cce78f3491d5bb18338d33960395b1cb4c1a35f402474b9c233bacd7cd4b2dfb02555adfc77689c98c5cfcc1dafd4314b75edfa57ecb40e82337645c7350f10629a52ee5257569ee47aa9b783cc7c266a8a92fe7fa28060a89247e91bff85df6bda2d7c61856e1ff115e8ff3182748a615150e553fda314aecd52f9d2af6b2842cadfbaae3806141cfc77724d735d1e0097473284ec75a557c0c7fb81ab200e7cd3c8e94297d1f315f0b6125514e0d78d7314600f087ab532daa08ce3cb54dd3f1584d5d2a401d962bef1ab89c67eb08ea47714635695e4cdd1ae571cace4faf0502c796b1db723244541d00e4384f3a60e3ca3ce18c5b821ada6227c303ea38aaf5fad9c5131f05f9e0884e202e2ecabbd30dc7803c3fe5d2f62d557dbff33ed127bba5fc65e6b60c5b6f108b5620be4f69468c82348ab203c192012ed92a70bbf50cbed19ebe68edc81f9d41a428b6159feeb61da4082906fa01cf1f78a514da69476e6a0dca2d8155055b85698d6daacb6a34eb060458edc1407f45a5e9d777cc08f1451df97e84d756662a9fc83271bbbe60dd5f7e4fb8fb65da01366313b79c68f919aca38b29100e09b786f29831abe8511cde8fc543059068d7cd2b483b4cb0bb1527261f1cff04186c3704d88ad82a53d79e3061290b25f6ff2c84ff32636dc6f9391890ae2cfe991629f8897902bcbf3af428bdafbb246997568111156047885dc21449e9046d4c1e418cecce99f858a5880e1b3ae40032b232b67fdbbe5133fa3a7dcf4988419589b96e50a0cfc4572e78069380b58fd1bb69004cd8cc86883aad23a968d809e7aefc815e7b1791dabd77e30e528ce8b62c1c5114b0378c4a5ce497933dea0a345cfd45210879d012015f0c269e3e533be4dbdb18945c8b858fd16ae9c47017cd10f55a65f848eabc02b029e0d0c589c3a31a986fa698479fb9920c0a75a75eb1678e1eca56b9e75eb25e2e9a2925c9e5f4fe35fc3f9076f816da78ad972aa33690c3fe44de2f3eac985fd035aa2b58975e1f688c714ffb5070a7f8e9571c672bc4ace422209def81b72e551688c6e5b8120225abdc4111a4b2085616e61a7ae96c41ac1531bb6eac60589c13b92a3eb2b469fde9f8d70080a5eadbe34168cfab4431bf1135e7ea6d77ff9c122ebdfaad901bafc8026d25403c876fae2b123a15117befe67d569835c7df2a9b907d7da4391eed09b3971bf62baab2238bbd3859f5e92416e3e2bf8318f89f239891e7d3ee819ef921e83af24937883f8f01adfca1aba911057626078bc74f07d5409e6fe7beaadf36cc0cf37d0c4aa6d3fdb1a9f88bd7f07b0844334140364c84e4753eb7aa3a1e53ae201b3fb669ab850ab7b41a8f81c44d287d38e43980d613b010a805b139791866e2767c8f4660b672e555984b11ee646eb87f76ca786d99234d91e219fb6295015af0da544cb10c331cab0877ee49282fbe8a3eb09d9260278f6903241dfb16049cdb78c9a79af122fa16ccd247721c00b70a1fa91a1701b38296670b63e233047623a4acff041661f9c65899a4e8331e73b9b4b4d2dfbde9bdf6b8765cfabfbd7e77fd7be67710ff393e448455deda395d1298b9ce3e31e32b4bfd003c31da3ae9b686aacf6dd68693161a24e2e82698927c140fb0b2ff7e2746d7e5049d0c3a57f28d65e4226b0f14ec6ef7ebf5c17b86975845d54a7861de70e541635c920992d6b9f614d5350e128b550e2a8d9fe904aefbb80d8c7ed90c740f6cfb59d7f42d062799ac635ce4cae81ec92b7e39576f417155ff8796a25fd6586e2785b7b9a1a3d04896127652c4900ba3a32df3f203c38c76d8e354d7d7137a2644b43fb3f1353f5af071fdae8015c7d378eafde8e9d782b26816684f7a87ae4f04a91e49a818e2343e1faa4fde2d66273d8c1cf1c581842e42ed5634c48677eee109340e94a0554989d7e9582a5b01eb19414280738a4c603cd0717fbb005c3da77e677e3662fbd7e759243dff4a72a2f6e706524b82ab649361e760ce41e7378198d5bec002b5cd19be7fa8bfd5577f1173649de2909ce4b9190b910753c20d4a0a91be0e0bc54620173c27e5a4aef55bebb73b6ed7cfbdf2488c133e9da91b2f010a455758269c69391ff0ea6be646d1ae4dad961a2e1eec60251584075b60e72c81b58b41cfbff56381ab73bffe1353991e85307f719aba9da22f3fd9e319726c661dfa870fdd467cabf4584d5d3f1f0107251d28526e07e5a59f4375f40ed100e4646f53ef9de88bc89b1f0f9c7bd03aebd1922787d2cb78d94814de9f4b0c342ce6c7b65f796cc2646642cb5ab0772d748f85fe136675e321ba287de511c4b79ab065f44a3fff70128bd646a09c4ac1efa2590dc0de9a9c2933c3d1c456cce967b19958879842cea6170b5487c94a82c33ad3d9ef8aa1b281628f693f7ff5a78c6d6c8e4a05bcbca37d742a2afa3ad0e22a30f6b828665be4cf69f4353ee745ff499f515b837f1ff59f40fa62c4492533fef4dae38d8772f1900ab8a85668581d1f3978a11edb9caa60b59733aaa1dc0a34733c6bc94e4c692506196cb579e9c5f8aff87db70192d458d3db3ad1c92c184d9658d559cb567e441cc8ea241084287484433fb51df90f954a76626780671df44feac1a92526981cea1b9d585a46f35ac1d2d91686ad6551f7de2322dd71f8859789e642988255bf4ac2b6dc29a9692b4b084d8cdb198718036d7e2eb29069f406fb1bbc9afb9b625204416b1b7ec5d8fe9655e32ec2a1f84fdcc4301809092a082f71986020a8b921081be216de7e5419ee31064cd36cb9f1eef06108988e133af8fb01eaf96e9980373a4b39ef5f2c3a9a8fced3ed6bc5aa58e386c532133aaafa8ad60b97e65bf73e2f1f64331303cb36123b798e41be17e38b3e32eca7394f16d1285360c95b78e81e0664e058cbb1a93ea68cc03d7f19ffa0d892704a88b755f5717911ae286815c01195a740c2c1952609dbd428bb9fe7dd7ccb4147a26b90dd453ff5dd913e7bc985f460be70a0798b76b9635cff5af59fd0ce49f9020eb64ca28b1c2c076d601f820244f1267a86c0133fa3818e26ba9a5d97cbd935d9617175c6d40c024de67255170bd90a1c8b90d63fb2ff38ff6dc1efdd91d74b319883023cc8b4ac91964bd18e9633ac980d906846e84ed20bb651689fb658ab697274bae00d0eb37560c39fc432692b126878fb023780097e241d5ca0ec3ccb070ac6c1208f810be499a293b88e4447d865fa4d009a66b753421469b5b6636824b384b51ee07c7928e61c68aff98154148763591e13da03c89c423d4089316c52c75ad55da0cdf8a5999dd936ac55db862e0bda9538449ebdad8fd94eb290f13372e46c1758d8600599d14bb2439b6ce1d3fa602a6a2a790d2d8a0d8f03e0e1bb811490e1015646a4c8fd717e797fdd57721897d45dff9d3cdcb08c6050c7c6674e4b23bf3b26a09e71a36e40d313becc30de0fde8a75cba53fb7582b966f98a99cda6bafc8224ed4971412fd25663b8ebc3ae1b3e6ae4d216d61f2764c597e9fafea6cd6d972a4f9fc60d48ffb0ee3e923bc77e0b3277356f1ad54edcd00e8237f6b3d418b111ea5e55bc230bc38e4e8ff3a8496927243bd39ecd486fd7b0c045594c584cc98eb2e2fadb6e9d4f02cd32a7e0394c3502fd1770c6ded0bd81b394dad089dbcb4e3534bf0e00a483a01cae31daf21c740f5e77c8cf3a946c533bebbf48f5fc84f1c0d49d3d7d1be8bcf31b2ce23b8909d983a8bc713c89a3f2508e4d04e38a10533af660beb4e9f9ba0d0318fd0dead4a7867c29310c18b5b218a92f3ae0b7cb0b91cf2674919da80e106824fa80cc939a52e22b17d4a871f21f07de704c16917da84eb9753e2ac064573c55f08c71eb36fc842c347ceff6ea0f00d110452782270df59111fd00c3694ab4f53c2cce7c801a0aa919681ccc196df0a13558c762b2fa51902d9922aec533375c96be2829d68337446e296349e29c04560c94cbf9ba4095094aa961c42135de3c04f7b097e7942f87e67ba67aa91fdcff90a0beec77247524141f29a53c7e51158f1818780693af29905d8d41f7fddf76109d7fae8025088909d85f2b8318b0ae067a0572502fe834376a012d718b624633affd10143fd82ce667d0472334bb987784e1019a3ed64e31e10c6126a2f810d0af05f80094fcdbe68c9d44a70310ac1657b3beed11aeb7eb56c147017f8850eb6b1a63b7cc6c84a83008366090a51efb54c6ee1f371eb720aa724d1493b754224634d09a899d781ae7293b5e8b007fb5f8d00ee3734cd92ad4892e60faed67c26a546d2f8e438013522f95f621c79f40ea9c689f2f83092e778fa01233c346aa9d37c4b8a787dbb6bf8a6664547ebb4a08f217236f08bb3e53268d4aa548d577edf4b10702421ecdf3e9ad0e7c96a9dcc983a56a29fd2f4248b88c75be6f948487fd608585a2984e04ea8d18dce7e7ebe1b5dbe5267787251e4eb781713258f9c8b3561d3ebf864479dad8bb63afa582578d090e00dfd07a2483d62345eab8f86d08ee14978a29f63248fbb2c45b043d86507547cf8a2e5b2eaf6c102a840b843cda7239ba6e004937f28a524c94bebf1c7981425f1c56dad050a0d9cbe84b3822f23cd920d5493f372618dd1f8df58067b2896f636d222e9f3028b75ed29dbe08e030600a567736b385c1ab0d8a12eabcb33a2f08879020cedaa01d5e4d15e2b71a0acd3e232fb563ade32441492dfa6df9112172cce067d2e9ec1d79542e28440bdfb0887e484c763591e669df63738e608d8d6fe82f0174f56ee450e93577076c637da4e846ac0f0c8fd31db383656bfa485c44e34bc09cbe95d6085ea71eba244db3e76443ca4705f6eeca717314344de53b01464acb281f5a63ade18bd26930eea5d1a2fa1c548427788c912cdd9f0e09357fe5f57fd5b16ae68bcb29e50f97a834929a135ec06f5f75ee28d8451d24061356bf26d9f1ec0e11cd99aa5cc728743b75429537a2f80d9294a7eea0044606e108f662f4c30bb2bbb64da0291e2a84118614c962d4f644959585aad43e0098a8a3e7fab7212cf76eccfe007307b7d80455a04dd6b45e46f812ffa047d408b334dff15e84bf068f1e7deb28e7478aef98620d6b4c8ead82680f788a18752bb551625586c449d69e96bf15e48e84cbb27bfca527d8c08d032974a602520ce2cddf12b82456e2ada5014b0cc83494bf3a6420eb6285f9abe64023f6d292f308db31090bd7b66bc4f9c08bf0a7ac1f3969cb41446c657c769f8658e543b934cfb175701f32c08ea6d362fc8f94d09fa600808e6cc1be609a815ceb1dfd0db6f265941c826ebe8eadd39f71d04e79807b821ad47012da72b78c108d9a909dd9b52a40eef8e084118e30d5d4c728ad58aa08287b5a574554f2d6475182118d42c43b76798dfd5871b04532c483dce21b3feba978207f824e85cc4326206c445bed460b2fa912754f80ac93f987f503768b5831c393e03c5480aa31a0fdecbbd62ef61f844f9b213175f37df585d6bb12b71395af507b85512a957f9194d1439699694c0b0d5ef5caac139924f6f71f927948407f9d92614911b900f16f55ba958c74ef7530cb4c194b4c091c107a9dbf25b7d5ac9b302a80146617d8871a9ef1b97cdf2c46529592639da97fc6d5646b100153aedfb15912089fbcd4a8a0f8cddaf9546bc66cefcf76dfa7012743c566d0b5c3d91a8b73ef4d79cdc578c324bb9630aba1d80d6f59a2dfd6ee4998affc048c1452a3e2237ffe6a9a7b6a72b234b53be9b56bacb3236d2353b86f559c6cae0dcbdbf229aba27c9006e7c5ea54b7b76e81a8a68ece65e07df59177d6e87ddb963e42bfaeb6968dc8e2e5e17fa528ac23805f9dcd81c00d79e3c5a18adf9700ca313f800b1d7caa25d483850ac36822c1b218b56b5f2e4b4d2a658bb94db21f973438663f0cce2ab5224965e2bd97b9b3d9307ddf073224c0b89ef24071ce7d2a0e2b89b7127957d3be463822838214079e345662fe6d3b7ec07d1d461288867a959f7e7d039dda4ecb1f84fe39012d68524d96675913f973a655ab4c6464dff49ad1e96cf3de0c9473614c50d549800bc7f54c980936ae9df6d8ee2a6c62b116b469853b5c9a18963ba2c1bee8d47ed2bc1abb94161bf38d5982c9a422328d80e63a9203da2e2b3fc16fb31c4408cdf15e01ce8d05df77637c73311e94b80e833df0dfe04d2eeacbbeec0acbc2ad7b0d87b154f5d18333435c894ab8fcb10bc03d172b6bce73f2e3825ea1585961a079fdb42530be495f74f3ea454c6567ff5bb547324c83169d3849b7b28c76862a3dc15989fdf7ce059fb163e0163b4bc28d160ecd3ef5ec1227a0a7e281682d0d44a174629719c7ea17559607b4245094204cd13b1b84b1643c87254d9ce85fa13be94519b947cdb41082b28228c6ab150d325a925ed1540b1d9bfc3e5ac60aaaea27a69f6f4d7125b74b0548749f0bfa06d654e16d29bea46548842df99404bb44611e201f7d1ac90b53e95de7159ded9e8b876ecb46a1db52aaf401d15900feef979228a0e5742aa2f11543483b0c447a90f668f1736517ea2eda44d9b4c2ce042e1d7520b95d02b8df961c4210be3af0a5ee1cc570a2fdd5a402557c7d9739a6d9c447c892eb7339e82985f001849e3d7770aa108bf3bc673692660497d9e20b38fc1ce10f2be2ab9d126a9b12ede572622a42912b15e9c864fae7eb5f52f6b3a838fbbfe280a773daf486cacefcc68a146634186a255e3e6dd67b74c3b7ffb1ca8c9018c9728e6d49bad1f3ab6421e4d33afce18adf2f0145cd44925f7a4f63e247d3f1f215de047703f7746c8d593efc9f3ab8a14de5946d3f5df047798e6d5ac006dd4b35c688401436d7612a64806587fed8830b050b38a6e7b3de15093349f4341ff34131d18c7abf198584e54565c3e54723056fdfd3205f1df514e477e4b0a87afdb73afb423e50500f4a506de35f4620493d5a33d303e67213896ad61b62643dfa0b2c684a60768170db27e9d6b36ba58c150fdb90f0bb284938ccd9e20d6dcf9b5577188288ffca88eaef21a5a4032f85851ba3a5374d5ba6023c36db6e73803f192ec5f2602b6265ec38c74120da087c8ed67392305c9f35402414baf670ce206393160ed110f29fc1c26a8e0c78a5ae5cdfc7c470263a178889d7762b8ebd8fefa11924c2f9f9ece743bcece0c0d6959ac69278fe8f3a986aa9c16dec6c5bdf90667305b942b458a1a9dbbfe7bb2e844bf84504517e865f0238d647c05862d9c8852c2a86ebce02fb4d1b4237f028b60762dc4545e6bd72691364b469e8be71c16661a2170bbc6caa705161790580ac2c7279dd1269c0d7abfce88ae295dfbf17f93b2384c79541d5aa88ada00ee49278cda01edb66ab6d7c6586a92124641c64c05e14a2b59a2642aa988be793ee0a5e5c535ff0c70b45a6dd788bc6331f1e583a92e023c30ecc4eb0b55e3afcdc6dd81467ee90ea43cdf8dd3b147414aa681197ab9793e14d04ca1a55d19ecbb439bc6952bf661a5b07d1caf534d062bb9657e5806ab98c27a3c8e44e6d07d5c79e49a036d62b3c420c1a2f5cffff556750e0e96b16787350020ac46aca8065175b562f1a6fbce1d929e02ad96ad895ae066aae1e65f43f154c4b2f914547cdb6d7256df2a88d7b5c63d6944bda67d7ee997f6b12eb7e05db210e412bf8272480ce18bc9f23fcc660ec0660c66e8cc6f757cf001c33a4898199c9be139ee40a83987ba1cac9cb8830cbf36934942094e07a7af0e506ab084b46febb8da607d394c44359afa60aca9d61c9a91434b7802004dabd1757c1bbb7f65a334746417dd5223862fb256baad47441e59643f62fade8830ffbc0dbf092d83af8f71c7760f574ca9d472f131a0ab6efbb1ed9b62454ad75744a6e15f2255277e7637b6e2a5b00225a0d3af7f3b64c40b466df21d128ded2a6df2847044b3390a4bb3c0dc591597e696a2b300cd75b32b12b590483981e8539e35a1c88aed8758bb755eff318d24db1423796fc6841ffe615e8628c25356bd7d9d412f890ade826d21f724d9e471db3855049829321fe207e79374eca0309dd59181ee7a714d5dd8c97ad6277e614fef53280bab7ec996fac6b67dabe779fbe77733f9e5257229d9d76eccec4e922beb2016b1aaab88e068ed222e2d0f4195078b93f8db920312a91c2d4cd57cd9f914c170b766a5617a87fef6760925f72aac1286ff7acc0d08fa78072ad5e8f77ade2998c0c109c571f9a3a6e0729316262bd36eafebc093d1702553d1461103d6c0c0b52b42e3d7332818f6816963e701d84370d1970ec0647550214d16271cd5ae25b40a5f035cea7587831855a963dc0d05aad12379beb5e55eee2ab3c8fab5108689608cb0a91837282b0db3f5ead59096e1ff43115994f6ae71a95f92be6598951db4245355e8893fa5760206c23397ec51c98175d58df9dda3358fb183959d43f440bb278b364c3dcd7e72ef8da33f833daa6d162acfa4afb6f4258f72ec6041860a187b8134910abf1c7d4d6f92c27363a900b5e0a68e0a7ed046db756bb82cd399bc1d8ea1b38e376f302f12b9baba9d634ff959e447563443757709952aebcb22380253c975722333516d8a4cfc4d9fa0dbb9a9d81128090cae0d08fd5a7e4bf90aab56959ababbd442176502ab9a38c26bb0f87edf04f43449f82cf681d6d778065a6e262f300be43c46c1b0cf99415d7f12746ca0cd3b44120b98406f70ae63ce0ac04da11c4bf46aeeef7ad7b1fcb52383e11c1bc69873a66273b4a00ba2856b93c982504f591ed984a79db0e2089fcc65baf8b2df8c79041560714aabd8327c3b0364b2ed6b35b36d91d890b526ed9ed719e9263747a645491043a62408bfbc17534bca92d25c6cd0b6a398fce0c35f39837addecd4fb8a1e9970d15e80bb848ec7afaf28c99bdea51dcf4d779fd45932a4435c525d278e1b2e7756d3b05b5de9f0e508f5d3357fdbed06177363c096b0629b090044170dca373c208114b8c035919655f9a7fd1cc4e1168a775484cc4a6371e4715bafb873c3826c3fe571676afd87b18d22f36e3c3d058fe67594e4401038ea1f516d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
