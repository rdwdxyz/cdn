<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4abb40bc13928f0f10304ec571189c6ec59cf9683010f20c0fbf4d76b5288c816dc9c837bd09c465567e6d3c4eca8f6db74648dbc3a81b0d41abeda319163999cef2a0dbefd539344fd584128c24dc858a4a57addbaf8f8c7e752cb4d9de0cb6fd7e80d7a352970983b7b9838ff726da7898ad7377bd2f381f43eae1178be3f3586113ac7792ce3a3a2bc177928f17f111529e721cdfb34ed43fe4601f324d530c5b1887e518ee30b7ea1bd0c9af020abfd77be23da403e1f1846606d597d289adc054abb2fa885b6acbeef9dc6ccac210d8a772c206b56a88b32f34aa07eabb4cdf260c286dac63673707fbe7ecc3fc7bd5a78fa69870ebd6a3b19eaa6ff6ca494c981e48210b1006b8d881d56f20b9cc363582b43f83d949712a69a4524c175eb3e0a0122b07c2ef76fd86b4ac0c644599d75827848f95e1d48511e935468bcfd1b4875b256b97116a81ea7c4d5a55a5527f7e79fde19ea92bef1d9cd31ff65be2f5b73dd37ab129f754157a97fe7ebe752e8a3d0d71b806451710eb104570051471264a3ef71e3707fb15bce1a2a6d273d0ecb4d25d7c6734ec8294175fbd0e6d29912726bae9e66365ac345732d59bb637239645ed870c1834e78af6ddd39b41ee3f9716d257194ce3783722c6e73c2ca39e1a74fdcd3a4cf486ab7ce63042af49661b529cb051f311774df5f9f92a62a061969007e78b7abcc526e1656e0e9590607f6abf534e1ea33aa2e2a097b9ac54bc9c9df87330890b4fce987b14a181bdba6bb9615e9b9bd95b84cb2d7f9de91462c05425fd8f6173a305ce0e0f99ea24e725200b6374262784732ed03c5ee7cd060212da148eb7882b2fd54335f881898d38f6a9503eda1f0f5667abd975ead702a0b2944d50945099405a2cc1c89b78657f1600481d6706cf7a01f2d6ed664bf48eed8dc1019de8e9c2d40067a94f233169b21fb289f70d45dac870cd698f9bc581799dfd1ac6248edebe1b787ea201305d80ad274590acddfeb7786c27f6d90f5d4e9a0985c5dd31dda77d642887f4f0ef39c9783cb2f4efc461736970c2af178e1820d557105d2088835376c968ee175c94280f3d21d70712979fda1e8d09794f7e4193789738cdc0dbff56436f683106e754485e0f675e678bcee67cc6e4459a95fe4cb3a5026d7764131b7edb03abd214ecd01755dcd6b722d675d8d70084d77f82984ac8f8f8b34b5df97b004bc10bd407187564609c2128bf6a211aad5d7c17b4d2f2753f7e35a66bb1544b1ee3bbb5be8f004299b8e4244957e73f917c9488cbe560e64382226249cbfb0efc17f95bba2c9fbb9920b01de0c0c890a9b791345f18141be8a4b0bd10304a6e3f7bb1d7ed2f1b11f5d234b3bf29e77c16cc9ccc90a368c567acc6267b5d1f4e61e722f44187ad8885c154586e58656bb29c7fe8f4648416ea95f7ab92012be8eccaf18bdb72ff67509af7e486913ee650c58a522ef996d2da8d3857eb02604fb0f5d22dd82a474d40b00f31b0d5ebaa3fd31dfe1bfe8fe817e6ce8d60d41f133e4f3782d8079fac8c896c023094edbe301643e129f51cd3bc2849689a0a6578863f6973f327a36412a7e37a3c5f6edbceea34db83a733c078c793957e58af29c2e00d8863985e46836a49c7500561ff5542a0b024dfcc402cc0e1f06df5737f5018f42c53031f2c71e4de25918ec5e816c0022895ba034f0c4c0e5c3b866c137b0a45e2d200e6e4e945f319cb598e25dd05bd129454214a1602200bdc2e7e1df77910ea84705673b2a9c30237d2234e9762d4b37300e00a9aa08aed009e7d3c63240a7c7ca84a2f4b32962b958a910d1221dbc57ebb66597f813f23e13d3e06b0cd975b4a4d07bc97f18f8b9d8d7da4edb7a2693874813d1094fa197cd1e62b60445299627b0e0b2f232d4114841f9a14b5f46f9b00de3cca9e8ab049e8408344cfeda7d047589b1499a1582235badaea72cf9e9dd2fc1c4fd42ccd4ee077ac505447581179869b59b7e62181fc7aaff244573f54702b5b4efebd0ba9a12273d8c22b4e1e9889ced6624d8cfeb9fdb4784bff1400ce7681d78ce5e5ae5e3fa1b7148f6ffcbc398b493ba2a38591c956c97756abcb62db451d9b045f695be0acb2b654a854c5c395ea18fd349dec506dc06038b40f90a2a1f93dd43b938422c39b61886f9da7e5dc394c62f89eac56a718a9f42986ddbbad67118d8ce1b4a3fc8b688371b9a4b45fe8515bf5e63c77df099e1d33ed4feff5fc5979506e8bed635eab53ebfa78d1b3f83ccf9a34957ccce724dd8c0d0be26db579b31b42c1a8e6febf0fe782966b9424e33f230f8b2f3469aa7ba16e560f243d96611a8c4cb9d4ac362f0e77bc14832d9f66815880dd1b6998db679c91f16d403734030c32da44aff788282f56e3149d6c8067c1ab034b630f57b9bc6037d450370352dfed2fad774d1871d2c8be11993e0356f6e5f3fd6e2e9662432749f663aa773c32b359989c4c692c2aa6a72456a6415ed5a6d37f53f1a3daca290e64946a4d1f11a2b6b8f0246d518608edbaed66c0edd128954205ce2f6fa534006ee988b331de61dd1dcfdc55309b5623f770da61be24e1ee1f0f27c21a77e6381f287f175595511374a6c20903ece1a160af0f00a2c70bea73fbfee0a332acb708d0a1d239d230005466889e70456c3ba4eec82f6ddabfce26df625888ab785f65cb8c0c9b643c276c2986479b45d8b48d09e7c9027b7dd582b9e73fc436018b1cb29ba9bfae245fb88c08c19fd283084758874bcb56287f05b0ee4192edb0dad02187a35896acd678e68253f5f4c932252de6302bda67cca9691c9c600d4d58005d657c49bb2585b9693b9b4cf25e6327665d75452f0b588e99ab50b2aebaacd427150e1b91927473d6228e00a62f78055a3473fe660984a76725a6755b47316839642d836c3eedff7a9d80e75d1831f3ac62fc803c058f030d4bfb8fed0499c950fe4361451c2ce529f7398a24ce72e1141fd605a7669d6bfbdb8c675b0798b6ee37140f537ed734e0dfd38f0c0175bd237eec125e13b49e8100b0dac08f513fb119f700f705b10fa0af605c1b4ae4470d97b57654080f0aa6f481b4f159e93b40f0892caa38dbe316d27dae9bbeb4cd731260d6591935a812a29f2a5e7fdb0b952ce7601fbef3faeb7fcb39ecffccf5bfe2a0fad569ff5c5b62fae9e467191b2de5a9e3d13e4637d5874726fbe764190fba9dc5f9555be5ee846a52b4722453006c03b6ffc6e59fc49739dc797a82c69e15a88f84dd5bf4afd4d9f9c8e1d56620f8c186cfc66a8cf2d734f67d25361d99ddbf433e7b06920287ce1bd0927be60a435be35d542f9e73fa66e34c6bae470b600caa979d74f7b096ba3692ee5889d410e8ee8615e535a7c7aad9db1f4381d2b4b856b83074f50421489a54167ce11f66d3a60e00853986b168a8d7d73f57aa85e3f4746941039aedaa48ca16885458834ce0ac7214e0c9d4a62d0022e83da46448e40b1cc3ffa11ca0460835e93f1e1e9c5a9c9c4d57cf57905bd980e60d933f5b7698aedb028d2bc2880392907975584b7ee8c1fac731aae5ee15532c94a69b1ffbdfc35e9dd8fc88f663534af4a1e39e9b89d623409d032b5c88bb0a0906e017c2dee79d0938190efca164083712991c87a1773fd4f5bab83215a87f0541bab2d4911b455160b36c66b77bf3375bd3668bfe28cfcc2176f006baa47bcccbd5a32163b357241c676c8f2c239799f2e679e0a0c24b5bb808c763bcb1bae02eb1b439801adcbc63d211b312a3a03e9deb7022f4fd4f8c3d07e7c67418ef0dbc9b20d7785f3ddc269871aeb0bf03777d091af7b14749e611af0d2b0e783985689e86c60da4ed2fe21492323265039af96077939d31a1bfcaacf55b3e634ee405e063456c307bf5ca3cad22cd8d2fe244cd0c512e41b0a43000c428593c8d062897673a9512de3d32c3caf846eaed230ca3763fcbc19755473407b6ad5fb18d11fddd8286e8e567268188fa5d8b6c0fc4c19879a6c1ff3c513957e5479f0d722dfc4e7f1f66ad73758d7ee5d591f66e7a9622ace77ba32237b4389497d0850fc71995194cc233819311534c273084c3ab5ef0de836e9e6e3f1a571c698b9e9a25b49de292d7bd83d40abe10482b55b09c849df4b165933fbf73fc64b4247f7cf8ca0d8e3644c8d6399bfe57f037a3454a9c18adf5cbdfeb0b818a09cac36d5eadec9cced31a84a9275471623efefdbd0c6a91da05f5983f39adbc2218b285abba1fbf5f2f0e470fae09b6a29b0e0aa1887886971d1e57c1cddab5ea14ac5fbe77f11dc47b9f4c622204512328ae4f31e02a6f08729728a0880a1c9e28777754e225f4e79351ed3e89e9da03f873058b9d463658e6e28b9beae01ae63b96ef65c2874cb3055fca69cfabbc8295fa81c078194d18cc36599a3d16e754735088324c2b4c8d956c3d4ff3ba25c41f3805452bc3e92c9dcea14165ad7efaa6fbf600e10703f4400d74ee51a3128a8567edbe0e3490d98b5c54e9034f71649443bcc6fa4a0c515f4e393359545002187276c032fbc1e396c6612f38c26cf41ae8eff8d9588d1b205b5ea00a5827c57ab144bc31fc4e64b7fd2934f0d35a9acf5695bc2f20668bc1a2d0bdec8fd1ffd94dd5daa3bc909ef5e3dc25520f767b15b6d7f4f6de49b251cde41b025b810211081201a5fbb36d589ace898a8253a24a4e3cc095156cd95c40dd750a9aac6eb1a2617796719bede6719a0984baf7f8e5b29a83ac1488df51e385ae685721b506f201eb78bb0493acda2adb25721e6e10831ab9fb07dfc0d650372bea41cd28a5194fb5f4a8c5aeac1f1da61465d7dffff2bc8131fcfd805114f8818603d93a5906105633e599ed04f36dc21853717e5d5687f9d7586aea6613ab57c28c63c42325bcd9207d63cc0901c9476715aafac3d9595539e9f772b8d4d02ff4df7edf4480abda4851ff3c805eb50ff39ec2732cb70076f44d19ab385c760efc8aabe8e6683f9509e0156b27f6b793831e8ad32217063e109e0988be69f5e73c5bd05a9ac7e081822547456940fd6d1838c23fd2e7308b5f41faba8fa051716d29b374f93ad6ef7f9780d8b960cf92041b39385046dcf960fe6f812a1b36cd03363cca1547921f96dba95e02de994a8daad44d4ff35fca3f2bc25d0f1b03a1459964341dda84e3a879375ff050a9f8739002b16970f619c79d60096352aca90cb852e535ebbe873d4e6ea954b7b2d0f1cb930c3bba61656974be9d1b6f30f537da6355e6aebc5520b97f2dbcc61a64a3ca60f6042077e53c28996c4ee79b10e940c5736ad35690a6e2def29f285d577a1621518b3c20a10381bfad7de52a09fc77c8dfe5c062de533954e2ff8d44a9fb3532f6b965e4879d414fd4375fceaf9ae949ae92d33194e1a4d69db01e6a5152a2dcca4c864218a70a1931abdeb93c5dfd1aa904dc53872c4959572b2cc69ba1132c55f5a62b48994f96b0aa7125b5d9dbbd44348114fd04897ca902da23f9d8032f8b7ce05a6b01abfad6cb95037818a8102fcf072101bdf3da3936f4718c509a675da21337bba03a3578c485d8bbe5f886731a042370b176789bbcc1735c5940d3cd0d3842e47630bab89ef3c8caa5e2ca6fd87ab9bf1fc02143f09a6de9d725cad1d86e0d9cebf550d2e5428abc4c5d8b94b5b7152f62db48b30efceb3bd64c05079d96505001ba6e9acb6188cd524e388c8b3461a4b6e0db0d3b0fc6ae72025c8ebfd51506db19aba5793f89de37a43379bf14b6e6fa65b39dfd36aa4b9eaff081145414f6e4c8cffec499a0cbd4d79ac3efb4bf5ad3df649c6e07d38203ee165ed81982d7a967c3a6acd26f32fba9ca362b97a79277cedd0d7c9cad526123a3b33b283f49e2e5f1f8a111e511b61d0616bd1c0e24f0298216e44deed0be98fca0ecff31266123bcab5f93f2de5473d803e1773d89a936d0d63e2a57f3f3b81baf81bff5ce951c01b75cd56924d87fb622184d96f36aa841597e1fd40221a21f3d56be9d74019fc17fb062ae5c92099f7d5c2ad34ab4e90d3334e24b45896225cb3cdea04b46c396a77c62946679d9c654fec97d0829584c86546b2d42c041529b1162edd4ab215eb39321c5a407b70af4c09096f4dc6532f700618ba3c41b9e876bde611fd69dc8387c3046dd3613e13784fba36f76c1b173b10a10f121a3b86cddb9d9506f8ee6eb916305087e80f3b78822229a691c6922960a8fa55d430ecc8bd671cd7b1b3377abf6e7dfeac0f326ccfb24872159032e8a8c385cf03b8fc2a636a752ce4d8a4e342d8be1ac33d31aaedf0dab680a42546f5711bfce9abfd19e34aa45ce626e9b26bbc41cde26c4e43b7aceb0bd95579bc00d6f4fd6a0b45784f9b484fbd436bea281e25dc9929b87f2de910054e9eaa2e757f3268549aecbe1c9085a11fa0ef62905f388ca48b93ded9bde0bd33f17b413f13536b517c9f4b990b17f7187f7592d7361bbee8751e5d66c78f146b484a4500a6004be8dbbb813a4dd47bcb791cd95b9434ed5ee0574b21d9307a46530b07beecdb7fdc1bc95dbcf7a44151ef741a54517ad813d8d110715d568652522b2a9fc3dbc83c27c09ce2ed2b29634ef0155e20fe708ee46a145c49e9be303f8f6ae8d000c32f9c9526b629d613a67d1fa5ebe9398a6155fca2ab048c2eb1f23c15e1f8cab100f26d6ef519450240cefbaa5c7ae019c2bb359cfee353861df2aefed25bf2384b5fb648f0dc944418ba268705bc107e6e567250d1f2fe35c990d719c5eaadd1c620d0f31e51a17f0ff4bbb7ce9694adc48933cd796fd22ff1c6e87c3d75b9ffb113d8f3d25b1358782dfa51ae9410cf26383b24c66740d5bb4f0549f379f298e8d0cac0bebf4798ff17a7dbe01a3875a5e000083f5022960e1f8512ed5a5bfd005d8a8814f0641d13bcd9bee082df836624f4ebc051a1b986e926b711144f3bd60ba14d50b402ce3713274fc5a06f954858d2aa48cfdbdaa6f61a7ba69f218456347ac3d0ee9d7d3e0419a1576d3345fa9c3e14d98a3f8efa4a2180908d110d4b0cbad9ad3b62d38427bdb1602fd5bc65d34a2009b7ee92cfea158225eed13d3db579616869c8e48b5162cab1ddcb75e2b728ab09cf8fba2b2dd3e909e1214cb2d0af6bb06d6f94712e7144d1c44f10e1f17fb3b7615524f8f84bc2fccbf7db9f40e59b0e400a693a21a972a132bdd8039834389828deb7a4b802eb181eba39f1436acb7c47e6281f3287d62f0152c369355f4977e49e035242538d0a1585573af0edd8e17103da524d3cb83195327c2ef2230010b8c988886a470c0bb37cd36180aa81a2b43a9444a25a8b01e34261f0ede4619bfb9ff98cc2f2e4e16c5080bcc3823839a7f31cdc9ec12e02ef811aff9c79e4d511e079b608cedba5f3f9fa2c2458a2d9216bd554f09f61dc1961376f701dcad23fdb9cd61f01dc5ab16ae5f9aec92dce6a0860ae613dd09d4c562287f257f85484cf7b4f9d87c1940e38b6f05017b88be7a341cd3c05b845cc085cda5b35b99cc672e5c2133626f8a4ba613a7958b5b61757ff02b2f1d548777e060672f96aabf909e1f75fdff1b212673a2bea05773c8c84492ce30899725c50ce2e10522f90bf716e4bcc8a195924af426b71b7582bedbec6a723ba6dfbc41b86de425b08d6bea1213f64f72377eb36d18c1eb4dc47e9947d4ce5376ae8118d8ace15ed4cf560f4b456d67139e35078e9538153142d39cfe676361a5d85e09fc027afa76cbeda9404cc5ba0e24fd788b3a6b288ae5c23763fb383bfafb7c933fd7ad65f93d8a620d2cb65b0c016dbb013fb2cf989ee0ecfbbc6ecc3ea015061a71a96462de11366af8bafa1b0b1d2fd3a98fe930e4e8c7f42d153ee319154382010336aa9912fa18d28e50b4b8e3e4e4b2af4a9b086bb365462217b242c5849a0770a5a8e0c2c87584a7c2f67991301e8ae4dee41bd73b3e0ad15b39a24931283ecbea9ebc6c8a0b8aa5b3131ae0f0c59381e9117dd1b541cab436066167d7e2aac925f0c2b780897da2fbcd99864214ba8fd228857529491ee9e85d68a65daef8eeee61ad2717e207fa84c79b5ba3c5188ee9876bbf0aadd8bfbf13e00e005aac69cc8f2b2ae331f778a570e54ad87c09921e241a5dcc2e0df270106602b1b9ee9e601b7100986fc67acadb44b6340b8ed9fcdbf8ad07a41e710283194444ffa220d8578675657a4cadba2cd8d7e1496da2f29c78fb18ecc11499ba47518d37a25ecb5037bccb605972075559e9a0c3f1e025ebdc37e960fda296fbdc304399a8dfe7825928577ea0dae80722f28e41aa7117257d8325b6ea51cf1e7ea761c9426134d80a48a290614866e9d49dc5ff89bb52da1837e07a21c674a708121b242570545cad384157d8ba3031c972f5b418acedcd1fe93f8d2b60e0c86243bbe86ab8db69578551bad17f51f97f87feeb2f8e4c6bf009cb75fe06b4e0675415e68681ff195797515745a25b0d82a6607f2c1e694fd0534be207225319f8502b328ce5dab4938d83cb2fc6f03a63079042c6f4d03be70d3caf21af65fd08156cafe5ef86f5af435d773043f58fecf1a02ec8fb775a962e29f68ea1314e06006d404ac935431e8777d3f6db55d47e5367a8626689bd7432321a734b7d5e9600c298ece20e0c5853ce3a40d899e54ebcde7dd9cc28fe435d9af63911ae22407e10ff42c1d9cce43c923af2a0d4a78de07b750cc53bad8541fa0e1a1edd52a91844ce1553d9f1f1f1a1b7bb2d4aefaea983e9fcff57fb99e1b1db48876c533cfaabfd741b2b90fec1631f0068d21e14b2ffbee2d740851b5c4fece91d7ed34894357bb41f34f90931582862be1cf822997b61c4c1e18c91f18be01b8a058854eac2ed9435075fe81b18a3324a745739b89d2e094970f42727050180e9aef4939b483849ac357836a4b60c0583f7fb94c281d320e149d1547dba6879ee06745576e1a429818baf8acd44fa0644b340daf0cbce06857dcc2e474fbe9df1b5ea1a5f7941408c3a023bcf65d7b601a32429ca1b197148246e0bf563e24d1abebc65aa5d06fb9af3a8f5e3c1e7f81e35f0bc729403788f6829af5c81b06ada27ccf9d0160617deff467c7326cb93ae745b974111d0f44c7897a6a4bc29e0439888d267737b7f076b77c31ace2bf4488761a401478a4ef4b34f728c1763bba7d74d71573b2c4c6aefca0f2ff448e42120966b67eb28610e4b805b0047d297afbf162f8df80432b123f7ca82863998863832c7b4a4c2e78749b0c34486441db320529a1049d910e82bde436cf5a8711b934a925309fdd9acf72e808267d06d2239b5ddbb5180d93e2348343d6acfb855a1955bfc325f212f3e70ce6212e2c98d3914bca4792165fd6b9894f046230e4c5920a2a4412448d00076a0e423ad58f8c80f289a3db7095724afcd2ef876b9e0591d8ea65c3df2ea763d831a13713ec8f7a104f78bf0c40a8400cba684ab0aef440e6255ef89b456927bcd3b7f123d5d24dbe732187183665ac94f1f5c179c2eaad5c13278176c4bd552fe2616072361173cddd6c03bbedc693e28cdd45ffcff62457f8c350673afede843a6cebe0f148d89f457316d8453f322e5ef6df0f56e75251919b4e0183ddfe18f484aa1757bb00f6b6d9c544a5121fac300cb7e49121d49d7422cb2869f3114560355908e0adc4c920e19f0b84e9e9f575ea507b0e0edba782c698d7b7f1b591f14dd64d3553890f0ecc964597754a727d2d323011ee2461ea0972d5105d24f876c656547a364f886f7bd4af66e0aaedd50716bf32648dc5e056535b91c53c50f1a403428238aba042bcacc49eb505948944c9136acfafbffbb33e619acd9eaf5fde912b7ff8bd4b2d8ccfb16283420d5b33d25153a5831771acd5ee9805d22ba776c1b5a0c13e50eeb7f2376d9030b160baaad53e678bcc15582d69d48e2366975924f9fc7020d328db429d92ce62cfa56db0badf631ddc78ccd05b9d9321a88b8c5ea4ff62e3b932ea9e47470c825d1cecd5087d466bec456d0f1ea8dd42f77c39c26f8d76e78455a5bad9f29581bcb7765e6f888b1561b9bdb2893c704d8e9f682b8d86ed2b3080d8f035d9d1c5443141eb840562887ae45c254fc9d4da1716e11a236756ef983f4858c5ce73c0c1820466db41ab1042f3972188e57f44bb8fed095224961a573ae372736db9762e1cfe42774f3226b925fea64ca14c2ef5d31046700c3f7ff4b13d724622a738b377df64b6623dad7a6d5538d83e979bed0975ccf827ec971ceed2308cc7f67480afc6ef8c978085eca83590828efb15c156f8fc60c3d8d829ceb04e76d4ad04b83793efce68779f1a87cf343e03a49e628a70404cb81f4e69ec014b6fdc634d6347b2c21fe113f3fcdc528e08b0e504a6cee981421fcc2f8d05758d83e7a569190db8d6f1092f635dcd0bb923c34860e9acb60fa5b02c153acad7ab7a0adc07cd303616f1148451605cc324262ca2e4b291ba725fd6eeb49b18ce4d977fcf000200a4c65a40ee13568d8985696d1d9ddda2d9b17eead8ea602c363768e8d5ba339b6bef0ef1c90202b914f4fc91ac1230e106cccdfd84f5997491a8f59a90869914ab28c60b93e0ef61a273ec9de929845fa75da0e5f7502ee28f5f498587b5d8933ef7240f61d566ae794efcb1a8583e15629997fc9c55a36c94e5968fdada3e7cbae1727f86e204b2846f60a41aa8f9db2981f8e4f30fd87172699148fa62c75a6c41730f0338230b4bc3e90d3cdd463e7fef2cb607a582475302ca403bfc41b1a4bf7747829eb5907983bd6a03501fad8c075d9b0d6d2d3e014cfb2ac211c386469aed09c63402c636b04dddcf67bab360d1af8cbb0302a3ba8ef8de1c311179dc24047bcfddd43021cac37bb00f2c263b2f15ba7449ee6e32d782b36512f85db3d364201ffaa9fa7afd34da9ca58d40ac69ad25239de2320f1337f6f5045b069e7515252823dd8bef27d042261047c0113a0b091fbb4198d4b29eafcb0fd04d38d9949833742b6a4465cc7d5b476d320df4966aa445cfcfde0242aedca0c6613c87dca8b0ee9c7ee456976d41267286e1b96c9cd7b3878ede6e52e27bb74d4e3e920b9a496c8bfece7e25739ba7abe0fda9555a87b53e96333a4e0a0873b7f83445926cacab035080d33617ab11bc6423d90413d927e4d610e3421439ca722b36d8ab05a41e95e3297ee4ef326c47d848feaa081ee145af14d4b86f03e3262184aabf017035c5f2ce8e0715e9e55db99c59ca00893f320bbd36028f7d50b6a3782f0cd4bf886639c9856faf3f1f7e73086b01bf67e52405a664f2f3eb9ab30e4c9feb3b9aa97bde1599ad0e66b59a1080380b357dce9a83555ef22344cc30f3c22ffefa96f2ffe8e842be570df39d6acf559f9dc88c5d531a217795557e6c9dfc38353af43e2095dff79897e02968a9a5ed09d2e39b8cf231a1acacd81586f349ea7c0b74fefbd2242d3d59f09a83683bf0841e8464fb7a534ba1ce8b2ba68f9e6045e77a9ef6a3e4f49d677f0beed2e4e44d8787c30a5edc67577e43fd2c2566af4724b556e4f7cec27fa8b6613bfac84339293c86c3d59dae90a2b8024e81da9e6850f4f0bd56f1fcd0e7c303fe24fdf6ddee35b412c7980e9f2488d345723144da0853fdb14a73d9fb46d20dc300fd7dfc19535c5c486f52310fcbcf26fe1ea4532d8b46cfd3441ea561f1fbae72b8fa2631891c1f05b5a56ff19eb949b35f3e34752b14499c69867f8a4f4753dedc9633f08a6db0a7942ad7adba707bf83d1f789231379fd7022ecb35d6b40ecfe3abf781a80002b7a89679aad6906a02715e4ddd5affa868ebef01485ac9b8bb307a405ecf2c1f577da908e5c4cc69bdc310d29ee1193a3cc854794a5375c261340c3bea6aa73daeae0f9a7b8d73271edb011c380a7c111f7c5c53e93d8dc6e2c0cc34cfa75a7bc904fc2424e92dc85e565d32fa2463aa0af90f99a461e1e422f777660e5bc9b6001e59a966f00c62c4dc8f365c1bfbca3c34fa0bed1b173db3fefda764ee73e1f665ba3e571af0c1a3d21c72b9fde75e8a715e10ac72ae8a73b8d735c2fdee0647806e4d61331731cdcb4a823a7c725a626685c3dce3607b16d21d134ad59ad8e1df44ed0b9955cbf398ffe0a2d9b8ef42304254ab6e05baded38c411350b8c620d928382f74aff3064dc97f7824155494caa18d77e355f8ddd1467ec1d03635ee9ef99cd93ce4145be1301a5c10f5a676bae84d2bc488156d6d9a642c130ddf803713d57539686f47ed36425221c032a2ba157194752aff0776e6825ecee45a627c1b192186d7e922378439f527bddb5a2af4c2e5e7f46da93eab845c72b37e5abb9abac662e2fbd981df7fe09ef3c6e8c56ce95392cd943f3cbf45940578fbdcd3d58ee813a675d07a3e1f0b300726a2cc2995638da6bcba318c7486bb3dd36e2b9cc6ce99a519c987cc74df673f07fa2447d33a1df68234d53ab336021c85f2892545f56a48541243e6d7739e946f9586dfdf63bd9c3baa74c8211caba1547eb3e8a0f4afb1b09fe5e20563521def3215795cda03d21c0549ad50dff5ba5d405879bbb22bf690c2e7195d7e79d0a731a5561365969a2279664553e47d61b15810f82a11b876e91f9beb9acfdb72e36c83df6f9ee400c2dda6106b70473ede0a40600bca57ce98281d818741daeb45d066a8a44da399963080401e65c47aaf9a5d6531f2e09056b43364a10baafe2dca193a42d3f220b4324ca45d6d6c450fc96b8b94c62f5c2a6249b5c868b1365e5e22b7dbc370e2ec8d3f71b8788cddf09737f75b3b1a04ed2ee6f9fdb40e511ac32da4a7e5800ec29d8b4fd10b812d14a0dac58709bba40ffe29e1e146da94fb62bdde7bb351f46990d98e66178083674d353ec0acaff8b610a918ebe31fb4942b590a2425eb9f2bc9b7f585a13017ac8e678cddce0d3c759ad4715d02f881a2a40758e34f21e7497d9f2ad83ed635c75c4570884bb9b95ad654c5a18be17731661dca2ff2bd19191067253521e7354e1595563265942601e5396ece43c3622c49d9176cd8e369e5477ef5e757e057a4c8f157d47d7dde680748d6b3e44d0ec8838bbbece84844fe055ab8d8d3a877724c5b614bc9ec32b85daa587fa1d99cb9e503ac6f4d7fc259409801adc0c70578ecc9b56d9593d18071f25efccdd0cc7055c72d5af04fc7c149de067275ae3dd8f7734c77bd768a399ec89d0ed4318b7736acfc2f84d3af2fee876c3e1f3e50a6d230bacd92273ae11918d2979b75b4246ce5d300c342dff1fd9cbed1b112be99c5afec126165d4e793f1bdb8a9d4c3ec061b9a611969c8476c4167ed58a3cc6ee9aec1de2a521066ca694ffc6fb024c3d5bcabf308a90933b9d91011d096d47a28d776dc6eacbfdfe84b57c7030fa4baf23da9797b59b9aa25d5ec656fadbacb8170b7da06c200fbb7c8c015e34a5a241b2093ec019d9c51b83dd72b403a07113ca3db7ad25d5c74ac77dd143c0ed41b1ab74db916c4acad9105db8d79eba635d99ce4890769640042c5c892124eb461da4c7fb08fd4ee29aad9b68073dd5c49a39d9931a3b68545bf8ed5d387664a62366ca24e4e07d13626cc53d12112b38d4e7de9748adfc056ad230cdae07b62ad6284adcafb211033d1b97dbc02641d301cecd0d28ce443dd9fc1b6d9248137001d8aba89bd8c88264d430e26e359b13869caf360691049c7af4d5ecd961331de6b94a7260543653cf089ff5572dae3fd9e356e3e4426959f0fe1d2acddff19d0b437d01aa00c90edf4e8cbda3cd7d91f4abba7bb0e06316ae1347fccca41d88d9893e7c42f2b3d7eb0f651da9e4b57bffe62b83f4f6773fa9985aa9fa54f62946a0ce5d73b43e6f1853f361e7b53616ab19931fa2ba3ae80a4468ea7481c76cbf0049db8aa28906c967e7cefea784dcd980b15d0ca0f737303ad8f45faee32349ba1c346fb2be532f71b65e1b3e96a54beae34a98ade6bfe29ce2a81585d5752f89419435fb3efe9749b1eb67ed1328d173099fe94ec9ce5fd72cd1ce84fb006ed603478ad837fa9aab116fbd55d20946dd2563f7211cfb769e8225d94d09601ba6248dcc9c6051a0ac01edf3299595fa7380b60f7fded221fb9546a22bf613015318cb8436d809c34e4b638e046214259eb77f1cdac0a9744aefdea7caf111fed94cdebc3b9acdf5a8002e5a8909b82e0ffa18fb213474117d40fa56325ca851a4e3915e90309556ed197c86dded26c4f8ef92b99da5f1a05fbe78485fb0a234f049785aa0584a49673027a1def60dd080f1a8b4fca4519cc141c55ec115ca32a9227e831ce9624688d8fa17ddf4224bf510b8eb7c99339daf9b166c40162e343fe54d1e0cf8bcf6b8d4e732eaf9ba4a11ec92e71e2d1d7395f92ad74ee2f5ce68ca63980bb4b15021b4f4c0cb107524a13591272e9dbd0fa341ceacf37140dd58005fb384131682b39c01339a16c96e2271144a3d667a34c1f633aa3a2de4f337dacd1ad4ee09b67d7ce1dd7900f00f56d79a5a6f95854e48184a5e2e25573c03ac18ddf68dd02482c37ab481788cb68eb2259e26c2e0fd22e13f0908cec2b10f1690611fea2f95df31fa2697ca847d0ac1b3d9e32c3f32f68de063fa12adee8f96216297f5009a4cd8560949bae649811a1230a05c240ec0c2434cca0727e8923d1da14aae1c76e83502330e321e49c7107d4eae8bb2ed51834681c1c795d55ad047737a60bd4a2587f3dade90de254f3bcad16b8804dceb2f3bec691d0d3944f9647eeb23cd875e10eff81f107dccb934f1091f91b4e58ec705416606a7f059f56af94a8c862a9f0b97019b35afbf922f1c57f5d6ce679087cd0617169d3597ccef2af77db73c283eed66564843cdc7ac15627ee884bd5db0de78634cb6f03583c19e116c07b84f86e094e24c870aaa44be1271a702164564d2b0260641f4df6bfb1262502d9fbfcae0e626c698e0e22471d38ccb9b33c4f2f9b1affecc6c59c47300b10d7ff6a35e3c1b249f0f28b7e0700de8e664f12fe7c479ee11866f9a6f7758ce2822aceccd6d56fbbeafad56ae38f3b97c998bda62566f9dc4da82a427d3b85e849b8fc73dd88e1baaef8bc9c8eb950e9049ef8787c9b5335a4883e7daf7baf838861146ad9b38e07ee57bb839007cb5d2129832e383c80ebcccf95ea201d55621fc3abc6dbd8f2de7f96e1cd1c878a4333d0a59e80cc156aef742d03f5b5cf0ce76be0bbb43574cedb180c2402b079638f98a488d1ee2bd889d28e9224ae8637365453139d44ff42ff90c876c18479349112e4b2844f2126f4eb63f64e636eaa7e91725ae7076536739aad4626f9e7b51c8e1fbca0c6a77f7db83a8476ffb346ea9de3cc5851d5762fe71355d566bc2e0ed4ba415f4f4827a8165c444260c874759d3061fd3c528b4e59cac6b167e75bb2fd70a24ec478df55718d07e330a09470eda8649cfaa4e863c4e80e19fe84015576ec15e208aa0014f9892bb857f27f28935dab01dcdd590c041eca711a5df7e705c7f82308cce3c31c2cf07cbbf10046c268ff504e1b2c3316233e1089c557fa42cae7bd55ce7b6d9fe4262794c11280e27fe2127fd8fc6da9d8bd02e63958b913181ecc4e4cb0df50773d3855e50732370f597b38f3d5a75c21f142644b9c100f6200012fcbd40b716f22e62cdf99ffa223db59183cb4c2b38590b65f5387e04ad6b472b2a6c117476849b62ab70951a523361e8fd79717f5293a93e109795a5b24cee2e26d9db5125f2635da98e0f91ab0ac40bfe19de54b9edaf2568d02f02913146a34ae64c36292cd2b057795b4fd23a149ad179dc1c9a59369d919846f4140e0e490994ef21bc21e971dc871ef229a8f56f1ffbe660173877fda0938a99469b981395ca398b79662f865908e04db1b7ed362d9fa2489e780e6f032983a1bf273353c2784eff6e65a499e6afa06a09f44771cab48e89b3052ffdee1e30735bbc71bfb9aac61879789e633017bdf9c723ecd23e09c43a0018e6d6c82e38b99949ae1918908a36838b3e79e72e51f39451ab3f599dec1f3e7566c38a64e2500be518811f9f142ae3827b56e6c27c37a9ae54ca0955b1c434ce31637e46c05a5f45da81b5905a113e35989cf3c1ab7e7a783c26782edefc6cbe8d334a514ab2bdfc9d4707d8bf2975559a94c1373eec129e152e770d164d6dd02df6efd4cc8fdf60d1dfe64140332b3c8874abb143d59b42702ce40736a9f9bdaa0449d91ce6ad87fb1a42b726500589d1429ff28cf92a759b01ab1a8d515f9a79d106145bd460faf06a1f7167f6f34b468d069d319c75e149a1a7b56fe8e61248d7cadc1d740851a53166682f0499959ea5f168d4ee3c3c59434f22ac1e762f2e3830c7cac100513ce0c1afd31a3e654bbf119667ce71e2add6cd560f00eec7cd5a406671f19f07547b14ea70648abf3ffcf832abf64699ae6fd708abee77836b73571396b8a9eb9525a9b69ca6071e74c5dfe876dae82c47e8b8153cba87831a7eebaa70110df62d63e4d219fb001a5a0d143fe2eb774f2b65baf6ba9ee14f3fe5a378a007155eb08dad4997fe256e92de30cd188b0e067002f804f68303e47befc32f70d5d7d5e6ca568fb81be539274caea17d3543a5fdc24039022fcddde29f507f5de88667551ed162adb503648af67beb0d6c360d43037f88ee3ebe39bbfcb726814a68bed9d12d65fd1d9ca64cf3417f53cabe6e7dc637eaea1ae54b84a21a35c2dba847df34b0f51d5fac3f384fa077fd98358bf0d6ead565f5a2703db3bb465a3669152c6a8e8ae7ae52fb2d502f5ad53d0cda427773b92fc2790ab07f3f52f47aac4c6fb5aa586556019d9a7957c651e6ed2d8c36013947347d7a1b551631ea191c7606283ad7f5af1c1ea570905240f2a544dacc9ccd7ad2a2914a8e253af2115518e9a65a9a171dea472142b9c48b4b27326f2c0ed99262f02a89da27fdd7cc9a2e92a839a202d5875089236b0a16cca8ed899c88f3b456b5a47e6db3b2cbb5b054984932c3242e59032872e8116e5a7df32c01d2e139e10e7925eb64806f6977d716351d7a5b6998509b5a0c35e4e57939e908f8404decb63cfb153698b8911d19644e8f5a443a6f0f2e0ff4d61649cf57b04bac87b9c7994d7299483c112cd6b115bba086f93115e38d976217990462ca07bd173d5017bbb5faad836d88024165fa9c61e18f424d02c0baec7ee94bb956732d97e7e7728ea93e339305c203b86d8bf1f5f2b80877e96ac03d05ac7c542ccc08093ed97c7cfc1169aec071c35d8a3789c8356aee8ae8fe028d1edf2a33ba579909855db215409afaeba16c11871fc8717950b5d4476a70b420a5b17858c71e9bbf9397a78c3c8d52c18e1b8f719aecfb0090498b5d61f5f5203af7384087be3db8f2730e09bc3d238c58e882c1992abd78fd973564fc8162ecb84455f565d0e8a939198a61ae61dce0f1470a238fe6ee26271a98ead2db526c8c3c52ba8eb35a2693c9e4464b1efb60ff0fd43fd5e3724b5fee542088e257f47091a46d1b97f10161108fd6b6df2781eccc725e06194590a939ac3ef790fa6ab48833b94743e945e07a18bfb3763764b6bd820b4aff2f00328a367c718ab74e272117e7ec05c0a3479b16f509b80cb94f67bc1423a4d2717a134c52d72ebff171772b022348a8020d578499a7e56c990922c0e37312b6a46418473f4904f6b29e6d478c3981136073c19f5c5b19c1de692067890d076310ffa2d11fdeb58765c293cee1af5ceefeba6de9e2f23ee50bb5c39b874f6d20921895812f9f733523b07f09061725311fa9ba763a29f87d6794978f8c9ffd42205b0b5150a6d53e5f36b7c550dcdcd2506c9e468223926862495bddee316a422fe98d2814b049e577e9ba97e58aa9a3bd6a7ce9daa434f6651c775595ce24184e730492070293607e451280d8a14ad27c3c17ac7198631e997aa92b3eafe62a8d13f84b6d83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
