<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c781ac0029878788de8f05b9fa0b90d86fe078191901bd98119c0c28379e4ca84c623705ed782df566654ee2062593b73a2e60ac7ceb07852da259d9183483358b98aab0996e786b89394fbc11f5b897d8697c881e1b5badcccda1b71d23b114666e073d39cd8b43849ec9d1c96666ce6fa672d3fce655aa48680e82129954cc0cd2252e6093d23d13b69be6ce287295d5e146b574bccff124baf847a9323dc523a2fd3c3da24465b45fabbde8d0256d94e9acd8eaf159f30ef01fdfeb8d5ea3ce23551f55d3bcd0625d9ebb583b6c15e8ae9810dc6c34c59841ee8f155d60bfb8a7f676dd248aeafb83ea806190ce486311a264a53ff8c0083808b05ff1dc8efb48d9670576342b02b9164f0180377e27144896139f6a695858b49c3d25e390d8b3bd2c584e4a665084811b892dc8c1d1e5d960735a241a4d1a9992dd982634cc4311c44904e16afcc1f3204d5c73f7f62ee473cfe326539a4d2b590798a6959624af7ed864aae643f538a599fdb48006de613df61e0367c651d2fe412efe5ebb67e5f01aca9beb9074d4bb8a133d9a07d66a06ae39e047fb87573c22490cc4cc420801cc7c7c39049ceb18d178ed698f0fc51f1d9032990f9f45f88e5166021db874e7eaed58ac47ef363d2945509e688051269ad8d1630499dfd58a9ddda35f5e984ab2a333fa85ae728d42e234a28178877bfe6f915c0d7cfc5c0cd9a49df4bf2ea4946642bf4dadfeb9d0f334392abf6eadee8a56210417752ad977241d63eca9e348cdc8ae4f073e4c4a09396fa39e2d4048d21a744e258ce1130ce5ed16417475b5f516ea789449a29079fd8d0bd5632802682500b1bc9f8629aa2dbda545792441a719a8f0729e9d0b50ef32995aac2c1bed5a90e7125d63b5ef3bb519eedbabc948b134bea972ed9863e03deea38e18b55f71995a6ab824eb452625624b7ea7b19e8652765cacb92eb4afaa8248a5563362da08057bf797fe041fefb5ca9b4b00ffc38ee492401c494f9da12efc208b5be86e6f3eb7f59d40c0d556a93d97e56660f605ea99aa956c414addfb81dadad0b1a9c992875fec720f2247130864102a6bf413f37cd86815548752e76909d78c52c20844506c320ca70cb0ddd68373718ed7ec696103988ac390a62af0460edd6a61da9d84884ebaabd097b4e4df8e8ed5145d67e05caad03f562349fac3edc125e579c1316be97829133729485e95b280c3441d416406eef4007d47a7ea439d9354ab6730814dc6dbc7ce952d4267dedaa80e0137185b1327960452dab8dddb2e861b684d6089b185df4e36d9ba6245bf5d4b5fdbd0f402c3d31eaf32e17379bdd18d3245c9aada2f056b854f5f1ce6b4768ebad62fc59493aa1910fa8475a176c96d369f44c698b8eafdf85cd5c142a89d45dbad2e6ff4c779a8bb1ca11ed6fc3dc5156e2955772677ec146cfdbef9ab7048862f71b9512c1d7c0397b9881eb085339e2ec535f95e7f9725ddc1889f29b20d6b6d54551b29438cc7de339a91ae973661e60a87afcb58f9a76a419145e0b423b4403686e98c3857f3e6460333b3d73ac34bee2571e167f2d32ef802e4f18bb490abf2292e773db1aa39592f2b1f8e35dbca71bfbefdd9f4196eb131facf3c88ab1da64fdf1ff9157fa5512521af14bac5a3ed199a669fd1482ca45c71b96a9ac03a93231ebd3cb7e5cd0a00d7a3a69f6e420dcc1c8fd06709144d6796b7eecab745189272fdff18da8ed1efcd74804f756179b4bc2c39a6c3ae8c10afbdbe06455ef91ffb8f488efd69a70e0b8e835720d4f9f433faf887be7c726e72356f0c8a1003f739ecb21e369272dfb85e8f7fb18fd943bca366c085e6f2cacbed4dcea215a285bdc12989860bf87c46bfc4405fd1b861e4a0f587fc0e3d64c0e4519ff2fff940fa5e3ccbfa32a25e53a418755bfee58181abba41520f3b49c8642b9e5003a054df7783a78453fbe5b2027ac77212b20f5c99d2b1bd0fb0624194f5c68cd42e60c1a22e683f0ed1c36964e9083e034b1e6ab067ad87e0c078659e470f3422b2ed0baca3d63d20ba2e5322aa238f735d55189fd850739283664c8251387d3be6ca518ce617f23d118fc855e081cc9b88597eb98c96caa042af50965e0ad61ee20cce38f37d21b27a50a0dc203cd4e74d9c922848c7ad68612f6eb9574e73e7cd97f55b8a17993a0a64d5ec4fb54cd139944fdca3f8fdfc77104a9a81283c2321bde0bdd42de4c0d991cf49582f31baf0c4e8f07b8590e1ac292f08dc6ff5ee1d183d3492ef6f325ff06d900daf8a0f93c67fb8b85d30cfb241b880ac53d237f21547b8e35d46b13e6c71e89de48908b28d5aa13dfdce0b4df40aa2158cbb86407c15b7d03caac22f2a368e778748d98b13c181a85692686da1aabcbc03bf27357c7f3fe29960391793988222f9a8473257fe62ce7901ec4f3adb64433798f178cc23c6481c467e3a112a4a573b4b1d48111247eadae67d7f448aa74664941f2ff7dc9a9984a66427c91d62594ce1b86f9937b3aeca682cc409a6278b81d2e7bd7ab75af3a7009ec0971671df98d6dc61f8b3ff4d26f8cb26e00578a2a9e3dde82928cf2c2ede8c8d29aeb0f510c5cb96367a77fa3d379016e450c4013d8b08a7bc00e32ce0453b145bdf2deecf45f686fe79d5ef5489ba555ccadae74caef4f60da5b148d4efa23f8f6a282678b65c3bcd2f208f53d06a02cc34b4ade423294b51d62dec4b45319d2a302600cb66370bf3c103c311b0c25414f23aeb1d6fb6ea9dcdfb178f3d33b14a4295e2241060ef220237b652102dfb4ba1456d643a26c9b7c12c4ea13563ed4621e1b418b9f283cd96e4721ae45fd2dbecd38db812946c7c8d0f1a638703969f85e92f0cd34551c701f2dbd9134324373919e560b3601bbee73e2279a48f043b10ce89c4378cf432b7608551f99d4569ec280fa72dc83ea8195d5e15a799aa58b1d180672d3b15b35843e95badb94312c983b3cbc7b5783e7e6f4e16d8c9360e7f1f76fb2e4f345a62b4ccd898a49320b8ab099bd7c424328037ca2366d9e4e88b188b29d782d2126dd25ac59f7df4b8cec1aad0136935145549ebde8342e3f74eff80945f07ff4c5b1a302ea3ab456acd7833550276b1803888eaf6eb39f6256514c4eebcece08517ef6d8c8ebe4957736655d292264274543bf1e85d66d427b8090df41c1fa575e7389b4c72e4f64cb4b6fd8e8e33660c3187ae819b8ef8029b58fda0ae301725e791c8ce20baf5bc804a00e6b1601fd4d8688ad06ddcdf2c091b904b802817114d05189af3f2f275a1269f7315ec0c2a3566954f048f27069912b97be154bac08648a6d557b90b91e6a7c724541e222c3c5fde1f0d2667d3f6330f22ecf20d3f1b58c4baeea7dec76e7a0d9700cb7ad0ebacb3aa6e8398f633f396157887ffea6c991775fcf41e18392b2278f2a1a3439d942f9c74b6397cdad14085aab51a4ec6d1b1a8a01e74b5e1508fbac8204dd69280535cd9ae3e8d3511ea32f6205e86fba678efa17e22a2a6e4362773fa026adcbf8e5e1a4c25de2034457721596af52324849385ffb14dee8697efafdd1f281c5df38656e0386f36d956efc467e42a9c375a72dab447ea46a6b6cbcf97688997dfa80526e63cf8bdba3047a33754340aac00b70f480c0dd55d7968741a85b4035a3466a4fdf839018edcbf10793f8dc8599c8b413c253fd6cc59aa7b6755f97634d10cf0d9ae96af57a76bcdaa3011376a517ad5ed5e547071c1d3090b4a8a64e846a4a6acd89cd69d4ff4e32de582084a51b53e9587bfe0743e638a2a2c32655635fb0ca4c13bcbff50842bffe00aada3d9e40e04fd45236cffad2173ce6b1f836ce89b311f9e7931895d6295c34f10b9ef3971537349dd3bda9018ce8e51dd7ff43ee03d0724a582776f9bac126c819a26449fda1c68bbc321700b30e68e5be3e42eae6969c17ca9e796bd64187536546b0c7d21951837ef8301f003b32fd84008182933b86c8d8150a70b483435fed744519875602d9d562273a3b4b00a82f628e3ffb8d7857cb03593a946421ce0c2da46e994d25e3b32f57636bf0c1f12f5fc9186acb888aeacd594882e09c8e1ab44f9c109c8d2f27ed074e2482c96ea43c9135f0d1c27b220c0402d88e4abc61fe568c740cc37744e358abd13b0bcb6c084fc3528dc529900a31f32af84eaf0c21d7bcf0c842ff5a446b77278ab9d71b2f1e9d58125a09d99d51e8f433ecb9e0f9ef87fc5d12f746aa860bb593a7e1a80f8eb8e2d299914b513a51bfa4efa796cef1f5708878cc9bc8682571e4f10eeee51410cf45c40c7237b17d6c63da384cdb7f93f655ac7462401a795b30ca3efdce8d6180d32d80aef681f170ace0654a7f4f2034f452b249227e72ba52756907ab3936eba7c28874ada03642e9904c4708ff2c224084d0fc9301a7ba94a0f32e40901222d6176c54fba65358f4fa34ff5ff564bbd3218828aec11a77820f9e53e1c28a106b0375a47c36c67feb1bb64b83fbf5a510e4c53b835d96a372a8163517acd4974fb5fcc1a57c47d7d9adbd332d25a20962427a98e1fac7a23ef5407c9746f2b717398856d4a2a33c9b3db801de747a94149cb4ea5b68b7d9eb612c1db668f5417e4f97e105b51c26023457eedb7ea1e487efffde700bea928f9e577a3fe5a01de869d81a4bafc0f49e64026b96655d06b2b39b6a27c2e0e4efc55382d5321e742cb593e9ce0587ab0c73d013899dfda336068b80ee1c65b08dec7cb1650fbbb367d3710579bc20e62ffd2bbdd4b036d070087d2da626bb491a71cf44c13ed79104c3dd9486a166ccd1aec444c5997d003d862aea62ddfd371dc6b418dcc46b53e52f4a2216862e5072480c6cfd9ebb774bb37616a0319547277884228ce31b5f5cf317b2818fa1e787325bbdbcc359dfb8e0d67389ec124fb001e72458c6509cc0e3a9b4242311518c43f9e2f615ac17c632e9ac3c4116fc612d72fd37b54899a0641537e5833653e656ed5c4a8c50d7cea0cbb2f7ea8ccac93949dc82fb720e8b418bb50e98b6daf97bbe9a0a1088fa735bd189a13b79de3adffbc78456ab4fee6f4b32fb95c7ed1c86ac2e4b2cd0e2a34a36e8a1d0547ccba97928f31464037ac13d99ea7728108ba133802ad8c9849730daebf86ef5fc78dfb2dd7528e0105e3ea907b1905886ed06e31925e85dd375153d7d1de32558fe30f2a3d8551c9428e6f9db113d2949a5f6bd1fa36d82b1a0a32c00f719dc72ded2a415f60531416606bca93aa0f4960558a80d3b3c8cf3d27228b4d68369d0ecdd96d93bc8da31183f184827fea6f505334e0c393d31b03f865b47db48d4306e5afd53bffefcbb76bcc6437a53b11b6162e6f23e68d643798ec718fc37dbde1c88c83f89e2102e5a3f3c24ddedb5c10fdc812e4633eddafca2776102b65dbc5041fefc021aa3be7759ac4d7b2f2c8e6609ca1aabb876400e38925b941e362dcd905c3c5d8fa063aac3b96b3c7a98b6c844f2ada01700d1d495418d3e0f0e75f6c4b6de072307f5726f18e4937a3304654c59548a9010be17aeb0dd8593916f3f0785a443fbe58208d3c3045142dc3d1e2f044d5d73409b0832865158403665d76c49d8743749a099269f1f94b41e4d8a54357b0cc9edbd4668ceaa455a73dd77abcc07c7793734a835bca3f98c4283383337ac154fb1159ad5f7f9107d28dd0a6564002c6a28897b3a23e1ff7c0a6242e53efd357855d7644bf3af18aff22eb98318555a74eb0d213e11795abf37ea6f8a52242ad362f9e6186064d146d789425cd414f1cdfe2ac737c8b27acd8766bc320be73da9ca68a63632692cee0e5333694f5df831974f0270ff3df5d7ba4012d5995b63f6ea6d308c1b809bcafc586fb7ab9fb543c189935470fc8c13acc92b1c4d060ae61db59ab7f007b45f5f9312dd938ae6a6232cea3f023a1cbe031ab2da0c5474fff17682ccf858ba4c87b3521abc050d8e210866fa5627f25c26097d8e23f501bfc62258222b343885c50c218843c9137766b3f179ffe9f77cc4d4d1d83eeeb73a24c7cdf862ad001d8bfecc47f38efe5316dc628fe65d26b92f424464f4e8c816d379959695ad25a4a4218c6e408234b021fb994603962a4f4a83ba8e509a213e563dcc61a47911403c56bc17ab32acb33c8b42b85c1808f42c361899fe4ea8cfd4ca9cff9bf30169b04bcba7dc7b02d4c7b9deb8e89a91009f2210d54a4bf0b6fe435fc52c8c62c2322338ab6ef917cb7765874d84a10d5b37aeec535991cf0d6e9dac2742cd572d37f462ebf375a9debc823255bb4da5aaf3b795cfc8d09145ad07f0806c583052bdb9991c9f03f895c3fc4e5b2dfaec88fff46c402c9f4a71b1946891be75c58f78710bbe153f3008b8b2f5b63180f8b265075d5360ec56a66ad233155afa1aeb20e3ec8b6660f372f78c93c8f5df322c4764367b3c34eacb0d8d6dbd57ede1d6bdb8d0c455c70007833c0f9ca0385b773574ca74f0c0f971c4e2f727e657a568352ba144dbd7cbd4346ef1f779ba71e158abe87c9cb4cadacf2b2d5c26302c6bcacb31d0a2fa4c3c67991207798c05fa143b7cca96bc07afaad78f5be376b1746b7a2a5690312f918e98377119af5d63a73f80f37da957e1394426596c41a26c0b1b34df6c60aeacae1730bc141d69cffb4a8fa4506827156b943138100ebe8d126e4e26fa68b7f28c22146749b6360ab10b61887a62733a6d0806222acc8b6747af9be598e4faa11c4cffa0fe7a9e1b100255a1d77ae77b384ca4ebe0facbc079df56862b86b29ae471978ba4daeaa2ee9f987bc5b274094e4abce4fe99c2c8cc16e7d700885a2065cfda39dbb0a9e990e67863a7f914407b80dbef2b22a6acc81e773f6543db35db5a2c2ca592dcce2c03716be11eedee82af46f5ce0d1311effa41c0c0ac0784ae9c2f74c8681bf4bfde2a0fafc4776cf892b190cf1c8a5330110459ccb8c07d7f36d74bf91719ccdb3a6576999bb9df5462984b79effd6bff97892d58aa072fcd6f79b9d9612c1e32719b694cbcf0b8fe95e157577abd86c5482eb58f10993802ae5bfe6512712c14533a41c17eff84464e9c1361d6ce23d283eb0dfa2b02aca04c89a5aab1929586372dd9504f6f91ff44854e12f74259835a1641db6ef4ff96cc78ba8f475e4bde0e0a6c6db770b4e41b7b1c2d561955d3b53f4ce1cde959e4501cd95b42b3d2b459d18a3bf44ecbc997583742e69f80ddc612a3d5ff89edfc485abd072ff64c0673c07b9f094a8c59555a16f254b79532287077c9459b82c6a2e6b2732b3857f7f752affe529fd2ca82d8a500730f481c3bd2598fdea1f60c3eec1dad7c5569d1affeae00399b361142b6a3278f9df8a56349a9b19e6f1366db73f1e90450c98381e7a48e7117c72a3a10567ee457451437f8de34d065aafa5d44b9abec732c262e3de895707b45ee4356d476e43d1fa73985506fd8387a439c160aa236fda5edaff0f316335773a5ddbc48e84d0a0f7291bd0ca0ab607f79a7893a1b6f1da7f877d943eacbbfc49dda787ba1cbaec72686725b656dd433bbf65b3403f148bd953846014a30ca7129a7cf8f58451956efda74dcfb49bf2ab7bf0527832fdb2c2926b26c6407f725fdaab9f1d66a22c8f7ffdb838baf1d2a0aa8fef72873823d0d1ec84f8e3ca1d6aee9a63b0d7202872e7186ba116994330ac8309d1014a10b8fe5aafcd5a6817c593dc3e87fa499a5625e46238547eaa6fe48b41649632848c612f9a4c9faf7fed531419b9ed3811f08515ace564c1c7dca993830805abb7de1759bb74bf60780da14fe1a2e3f56659a35fd4df27483ae6ff087647cc68f8972f8c94a874de6278dd16eac85187a8018132548cbaaf75b23d849643687ad3d76399f683f4c3280d8f4f570811ae880aa5cb8d544f2acfc1d0048baa7d6f872940f0b678ee5e37c9f1fa9241cab3663309eb00dc4a0af73262764da1d51151253b62c38b7ddf8aa7a2d95d1342f7abc8964b38bebf2c0868f273224bc3452216d77b21faf7e2760951e84720965b22d4e632d55adc5ab987b098bab8d6cce0e8a7614556e1397c2136c55caa98cff36db891cc89bc9065ebcef92df6691f522c096321129e83044434c83fac62b03ed786cb3f07a4a16289ca020142cdc6496f5164ba0f33116e5f83b3d1d71a0148628af4b06f7f0a1ce10633b1ecd65c8c278c26934a60f9b80384c2ef9b42468ab4a47a838b5ce04fc53277061be5bc6193b8481a115a3c2185be453e1716ab091f2b3e257983160e69d15a5281fa149952272fef5e64b7557a6dbc92c580674a6ad73784b4de41aee11dee90ce601f5f90d4f1e5eab62c0a4370ebf1fa5f03ecfd2a8f50990266ed9345c168fe2d36b4efa4b77a057ee02d4fb7c4b47f60cdf996f47d0f640b4bbb0e76bc21b1b3a450de27c3aab2335bd4e0d4077ebf5058c7218db2273aa6b364ef318f2239ee3f1fa545e7af096c8e4cd69bdef5a8fd8bca00a57ce8f0afe4c8c2164eb9a6a747393f733ac4796218c0323d66817a47d52af8e3b3d31b6582537e218b316b03a80eca712885dcaea49e7f50c8dc67371016cd46f3ef013732309a2c6bc13ef6af96fea6b8643a339ce3b197c325f6b905b9c18c4382a9410347bd00d45ca8156d5713cca0fdce46c8d396e8087563dbd160f00a66ad4fc1726e7c4bb80a7bd3debb8b950223d57595d0ae538c363495e32d53652aafc0bf35bf4c6e6557f658757e320a3e79b189adff8aa7870b9d2a9e8fc7c07132b4b50f2e83c8f4c6ae59b6b30951f73374911044ba7efa50ad77f4921765f1c43723503c8c4e5700e109d8fbf81861c53d518d49410e7b99d6e97afd4819779a5ba4355e5e58e24b9695918f9f34bdd772875a3dff46f3f1fad901451844a3aa1b473837ffe13600676fd7bb1fed97012ec02c10c385974a72485a01cddf5f0f18ce359746d4c914b337f68be93666c85f5c086567a86855ecd605bda931dee08c689cbf40cc48525ed84337b8d5ed984509a90da2eceaf2fbb72e02e9b7ccc89dfce17d82ea9d871b325a21b7211faaa332e6aefd45ec15787c9f3e7388d60f664f984b4d2e37a615203154fb3d13ce59b721bcefe0d2dc758a075631feea5d9ccbb7f9d2d3267f69328e088db7e209b79f917fd3efe993b362c7c3b3be3ee8acd701309e664fdbf094763fcd81aa6ed8849d2f6b73eaf5d91e16f09b69fe392ddf1a349b5bd33d2a2c12cdc3bf0a31061c8f288f85102ba7a588c8bb21a3838003f1d50f782d91819e87891f7d450ef311eb3f0ea50787eedcb686d09038fd4359232072047e6696c20356a4529b9ed6340dc826d04fcc60f2076d31421a34b8d28894f47f545c9a0994ef5241a684cbd291b71907afdecc4da68548fc9c20a1de4bf9e4f7cacac8003c109975804682671f0b1f1577c88d3752d1596ea35b1a1372691851c344d4b91901366141fc87183a06915c8b94f72fe59dbe6229d1f6fc680e08a78d34bd91247a6850c2c5d88c52aac9d2a1ec89e797191caf1034d6040f10e45d3a060249906de5b0fcbb7224357b051eafa194355560099cbb4f37fd0ed6d67f76b8b1c678320e709aa34871086afc418b3417ddebdb3723eed6e5962bb595b8189c6ef9faf71d18adae94e36be81d70a94c02188b310c2b0b87d40a3700934c9a5f35ab729967187636d68a595955f68d7e111ebbae6880e09e0458f2d695eca500e212da1eb6f25aa74cea8a97da18b7022b2e5ca33d1445c5f0611cf71414403e766b97cb7c54514cd94009ad18879e0f24ea26f44af8c2c580a89b921848c86c0fa55d54907411b1d88c8750eab7cb52161103152bca83c12d145b75072b3fee732cc28931bf59c69ff40cc5a619349c7e2b2bc340723344473f46b65377366c4bcc2c38212457ba4cb88ada5b56bf59e81fe80b1e026ba964d21fb3ac2d356a8f553467b8600b2af354325f65589dedb30d081ff5cae380a6ee12ef37187c517327fec5920ee447f4fac353fa30376d0b66b195801143d398eb28ccf58de06b59e1986730917708d15e7773006edd97a625233067fefc31e16fa1f8eb83e2c6e1474f1ffe2764a3d21da5653d7f6b11b55a72eacbbe259d1ace093e1a25d13042e079f1fcbba3d8c45ea080a5ee00df573b21f52466a325a7a68b5b057cf8dbbca5cdc172b10b9e79e92c758607f6a71964b640ca68a16f64c11d4327fa890e317322e25b369c668900614dbcf2f822417faaa181b8a7dbcf69b6617851db79ab6de112375626d58cebd2311420f455be3f8e1130b3996b92a414d94d13f36d4993629a4621a6a41fe5fcdcc13406e0576fb831286e1465ff4a817ef177c97082fd23e40717eaf71168228a1eb521a7f11d27425de41a7ef6646aa14e9f169a53c4d11e92a6b43760419ef39de96be655b60306f88065ac91d644edd867a302c8055f87299b9bebf3e7231cd50acecae2fff1ccfcb3df9d7a86850a18566a273094028f0a18fead187e96a61421b0b351d513010d7398a4a5abca474004cd908e31d8e6c7178185f3d7277a252628cc429aff85f3299e9219c54f63f9132a60e0f3945a1e80a33eb67ea0abfc9d8547a09b25e0b80122558ead78fde01019c250f2eaed8bf145f86a8f873ef97a77e57bd8b56fe134874f56b5ffb68617cb894ff8a47641599fc831623afcd6aee6e9d2fbf20798ef44fa89224daa91c86386796135a379b0107b9ebf309315bae70ea11faa2298e7a77cb9d62d7f628f2484a1e20186efc307407293611651272989bb737404dba1318de6f975550f62c9d4c8a15d1c2dbbfaeda95b42ef4e91e71ac845a193030789a3610a008ea44084b186a09795bb0e6180b16516e1025d5682124d938fdf417c4c64201bf911a1c4586ef454883e5fa21f91e730088add509811af671c9b18d8107d22f7eb0dafb9815531d7b96661e27898c4221a968eac92bde3b6e527dc6b025331fba065056683ea58f3294eb64f0364ab63edc11d111a32e585035793c8ed26d04f82a42b551a0f36d1ded2c5bfda303199aa2a3ca7f42da0cd1e36f05ba843019e5f77f47d39be6b0dd8a9e5622d1194d18eaf6f45d61f6168cf1e4fc85337ba31be199b7ae7b9e8c1f46e4c61a2fa29a4204bf7ae01efe18de7a950c5b645617691fe08e3dc8029d463b8b8b7f1eb23429bd762c238d86e6896679dcd21013afa87dbe7208bb0eaef141a361908f8c01b635b8fb7a5c34b4a8868bcf38113fa803192cb682de1d3e1e041b89a452e1e00d3290c55bcf353913bf5297a1864d91c9dbf7ab586ee5fea826f226be45f1444713862a8970816ef191f4111efd3d24a3362959d15b4e1d99ecfdc414e0d8b4ac99918acc3d87519cf05424a5abe0ac7176a52e0b9c952f737a91a33d610bb57c8530ced3970ffd355d5cefb939fd8efb3564a8bb7d28e8d328341e82a654a0fc324c92ce17931344c41b4e8c5d8f726d8bca3d4d47f0f8ce851a2ef5751226543baae6d09cf8db73e10812220e2229463508269efbda00a4c09789aafcc557677442d25552c2468a59e0031b3915d1c8385b6ef0f6c2fc0bbe42501c35593a6aebc3587e1ef2b39912c1a4f0f2e5d33ce4f5a8207a1b882ae82b1b8030cf2205fcc7339e5b6d57350dbbc632f53d6220ea5af445faa7c18e4c13084c9e07c3c70ca0980c3e9a2284ec878b74d694657e2466670048031b902dfac58d3a58621deb962849a92fd72b04586842ab297f4d5b18491a4fbbcd7b5044b3c680afe9ab6caab7f40eee7abacfbc330695ad3aa1678de641ceb37874c1b10f761d481863216e576a5c598c2ff00cd9dd4ebfb52c2cfc2d0965fe3c5dc3f44708031d7dd1f6da09847c98a7a672c9d5a21e814f85c2850b6b1592b110331f6e96edf0f53768fa846d91e045c99a0ef98fe0bb85141f4bdfe8566f9e4d20b51bead0236f12c2052e79dfb2e484d07565f65abd7c2c8fe71b3f7725728c7aa64e5c75109407726901d1076e87eb2c77a537755e3e70fef9c11459819534cf8bf4c7bafbc79ead802879664063a501b40e7847bf6b574100388e0375b9cbb26825018c09c8934a2dc8e56be8c5bfa4f3215ac820441b67dab3338e35f0534912621eee80ef76bc80afed047949c3122fbda0ef7c42d9e5d3ed7aaf5d8c4162425f990925ebb0ddb4cfbb637e2ab726d2d1763665ee94f2114417f193d390f2c5abf2ebecf106df4e2153f441702e20481e3cce743f4313e14596d4a42ceb6625265747a9bf6c4af10911a8dca15605a7dfe56b60a804f05ee209151e88d17780dbe6a2b957bdda3435dccd854fb43dd5582e7a1542b18ddc622d2adf73c5e846ea89f89725cbbaba1bf31981ee0011023d3291012afe2743ca119a29df00792641bdb73f1857a6448ef7a7c3d7a8488e2777763370153f3607068bd65b0d5fedf826c9581dc5711a3e6533352114356d375143782c632e1753bd5792c7ad7095d50299e53f535474ba69abdf97e935fbec5885253585282564ad58b1b8f42efd3013fb991c0920a48d28604f091dad46f7c6e8e7e3f0d0ba367c2378f428dd1c2207e53e866746a5643a263c33a3729e4f96a8b69a8eed8ae1248f0f16618d49f714669274c93667aeee267396cd180b8348ed3f2e0c56d90fde9b4e56f8861cb4d7781665c2901a03905dac33eb76e6f802ab7972643729e1b6327afb813ef7880c87ab319d7895101ef5d0f60a2abb28a41bb646f43d99efe7a85ae61701bbacc2b05651a238ba602cff293d26a1174ecb6df840c7a35bddff3a904892a831fbf1e3b363545f15e01ebe141a6475d114b262ca57b3b149504449060260602bd9829e939bf1178f404724ac394124117ac178f6241b169e1802983ca2d68c863c8bee8aeb780b124fa08ccf7b6461bf5da3309023922f0bed80baf2d74c865b4ca9c1da787c1e43fea722f290ee4246fdf66ff298fb08631e8e049616d90459ae51ef0b244c1d8e4ddfc8d7a4681777643a3474c4ee450ac02fd2bd2cab8ac482643bb6a987775d5f41694760f5fe6b028d8cf9b4a2ec196367d45630d84bf4a2684d92a289d5bbc6c4b3c28871cb500b40d4185cc85713c42df74191f68b906a3b5d2e6b5eb0d1fb6b44ebef7cf10d84538073b19576d430989a0dc5a50fda8ba68b11d8b9af76f841982eeb4b708da0e2348d200eb34675087a2752215a627975946a529ce1002eaf69c96191745a2820bcd3cd81ed3bf40bdf0afd8aaaebebe2363e9ee7dd17a990794ee89ad577222bd0c15c0b78a91a0d00ce61966b62569550fa14512f5422831b01aa1bbfda30520f4daa3573c6f78d7fc235ac75fbd565f0d664f9c93749980a53f597ebd10488af7b08b58621557206c41e8437127bbe4e8986d14c98eecc6e1bed48f1eaf7c77532e02c09e3aedddb23996dba1011e89da6d0bb64d87dc82f2383e7e6ec05463ae457a56087e88d68a7b0e0b3b8a0c60fae8e962a97015ff5527f1923e0ed046ff54f6f287b88d94887f11b8d551389d9a3c65ffde5374bcdcbd7b444ee177d3846832c730a2abdb699895997087878a57ea9bfdf39638937f4cd5e973e88d118740705a9892cc8c9ab77fbee36f3aac3d3f5e134a0d94fdc8ad816e6929279e2c5f0477c2099535d78495bf67a0a3bfd391e41645bf3c56a455d4d9c61a25118b826197aadf7993686e8769b4a8e2a1b11a8b272453719c7f9f192bc554dc526f6f28627cac59b1cfb56d4fcd0320d1fd9a03abce9d2526f8d676752d7bc285084720dc9d862845594a746c319cd14ec24edc8c86827164fde25ff99f01b984e40fac6c57250bf36416fd59a92d713cc7ece718ea941385f77476b2c0b26439560b8ef0d566d21b53f06667ee7ee1937133c90a7506ceaff7f69e7cf32cee502d5926080153818d3e2280de25ec612731a3d5204efe5b0565da3d0fde326273346ae2c3f54c3b4bf155f6e183f6433b93fa7ee061de3ed6239dda215cfa182335dfec9e50fcbefd02c8618e6a94534007daf954c2ec93178e50bc3cea4b620768b9601c3e552994baae93b235646cda319a7106fa120cb66d2b767572b0b1d5a038e636440807e6b3e3eb53dd823fce7ad2a289a67dc794e88d3efced70b62cc8bc04a82197cbb3fd40ed58b8d227cc1a483535a5e5a58d038ea76b90a9b4d22dd655b420114d30d1e5d22d75502a632248928246b1a54d6c4dd4691d1a72620e61650750fb1bb42414d9adbd550a350490f935c409d018d3068c3ab40d49667914c6b77b7fe6603840ad48f5fe15ec5e1273f037f2153388769ca4d85ab4548b9429f0e8497bb842f7fff710c4bda07ed9c3bc943c20bb2b12ec60882acb1a61d43431feb6beb305ce4e5f82fa9dfb458d6bf26258d8c6e49a667ea5f245e743ee27f0e4860bc1fbed82037e8e927700c79ec407731b245255a07b3af150de842eb275cfe86d633bc3d4bba4167a4eaf9c747b5519f4bbc8c7c410bec3ebef67e7b8f29cfa10954080595c53525e52f20fe6453f44181bf2f8443271d3662315c1260ae9e8f2a1324fbddbac9a164712d0d876608d9133bcacf414a467bbace06bf5e80f4474c62e08ccdda0ba597aa600a3cffb84a50ef73ce5a25f76357dcb2431617fbf15fe26836d1eb06f9ef94bd48bf5ba3e1561fae74c1cf57e39b9bcc19212b00809148e4514c5bfd10dac85b6ffd547f0ad5e047bf2401f9d56bc6d692643cbdfcf929a5afbfc9675f3869895b0b7230bfcb88a61f19c8fea5cc36c99fe8a6acc22cb3248f94b6c0922ad0ecd6cc8f16c4b17c7f6657ab2ba9aa935adb0c13fe889a42d22a63219e6337cf60fe142236610fa0ae2974294d299aaa3f655116d0af61c76456725e73c987c88b3a02760803e7f4ba102191c8c6c953c393e77357d29916ddb9fb0e81f3b4da39914946dbac0ffdfd06fbdc569f031fdc48be6be17638b4f5f5dd5ea730caef36f10224380b6ef2b5a911283ed846720e330422d4bd50ee6f78d3f9ca95b63dbe225e214582704713b09801fae5cc65ab2af27512041c05c0f6ace5851e7e04d9f1039c321523ddbdf6b2dd553d6bb6e303cea71200dd24350844477f5474a9689c9ae1339dba06f8cb04bf778393ba513338e655472df37e7d871eaafb5e91eafe1227ec70f237a102d505f2020aa14acc419d549070b7c435b4561d02ad64097b4739a381262ea2caa46c1dc96742825e4da2059ac539eae094834e7f179420823d3311136d55efbe41973ac1bb42efabc0480bcda5f56d07512c1ba65d578cb6996bfa098ed9c2433f54942ef11e3f0e5d79f68ef66215d88ddc3a8bbcaf9f7dd84206b1d0f51c6cb1f4b31549250ae83c198db403c6f4d2907e3004be03a59cdd2d027da74d9fe494e7b5067033ab74822ff8a34d1693d4c087cf9a9ab83e5abf6233ae0c32ab33d5d5f79df3ed6d4a13f0bffac42596fe5fbb20575087adb99ed80e0d88328f9cccd619080927a149f6c958b901c851ccb5ef7d9d9ef6b9fb625a0023af0fae052b2d9947df3d88cd25f976feff94b30c4cf651451367a81aa366171f56f091171b8606669321bb8741e5045d24dbe2307b8599561708fd3d7f0fc3aaed98a6a6d182e5a27980d3080f352dab48615115d217aa9d4eb1b98c956237d37afcd6e3d2f9c4847edb39f8900e0a9ba87df0f5e76c0ee434df0489c22554ac2f77a796cb44f7e6fc0c235390e068828c4eeb50965c756dd9afd280c95ac1307088302cf17bc3130c686f0eb762b8dcda66d3eed9fd285ee06176b29a9ca2022145a5d1662fb298ff07e4e15260925052193a2528851c6183af34f0571610bdb7f003ade5d592e495f3d041c12fdaed2f3ec50e81b20b663dfc5c5d5e2f019bfb632993a873b67309a349961372e6f9331fcbc377260cc62a6ea73515db7d6862cadf5b12bf305e32603329f9929d0e1bf3c9018917edb02395516855f17131f46620cd457e9d3a0125c57ba18375432ae3f6d30bb5a9213814964ca626cdd1b0044fc016f351e24c1593eb3d952ec61c6c6e099b51c26279d2be87efda758a247b5aeac8c499c4fd33238799ce438d564d765bb85257d8ecc6609551b5b726135aad0401f507185f3d894f218f093499b5ff49d2a49d0ce49c9d9ee60799ca8d0c54311043ee7599078ef425e0fb60b288ff6b499f4d971342028201c08d05737d4b535b5cdc104c2f8e149971aaf395ac9e473b0ebc5c07708a734b38a579c77bdd59943fe4d6ec4eec7d6a61a2b34d5851969fe527b7267b26f04c69ca8bd9ecef4274e57a81f3f4cd66b5dd24458243d4578db86a148d95411a0f94cd9a6ffc6a7fb91b8021d36e1d36ea38b2fe4a40f3708976ce61db0161a02d9addeb6bfbc1ae1ddeb151fc0a892b4f22ca066faf48cbda52863ddb240bff0b2c8540f48f237bd713c98901f415211c5f09fd4b117685045b03d32f51d4a9c911a3988f615c9c13335384be6114a132f587384c6a181ff2d4262288564575f91ba6fcb7276213c2e76c2c5866554a47f358bfb2b406ae569ad7447ff63f24cf895d87d47e5b03b4b528036aa6ba2cf11afde863f16368ef68a5bc545c01557532b7291cb6b221cbcdcf2b131480bdfff51006a10eb62235000681d05c2a6f937392828791b43eed3eca24ace866c5d5749350681b769425aca3aeb0c69a6f38726d6d26867af51ea078d3bbaf551206313e0479ad1903b3db53aecfc7a5be9b9c66acd81cbc755a14e6e20cf76a261faa1fa09ce7be940ca53c75a32a074fc96b935d9ab69e58180aabaee5965403fa5b4693598804e9a2c7f6bd8eae076bbc92025cc9f5ea539f01d0c5b5e3b008ad47a7e61faf4b9561e517eb85ff406c75aaec0fd04ec43d9bc5e07f483cefe8be0ac0084baf45458e87e333f991a82ee026c714b277fdfb6f80ddf4c0a9d4c82287b43db9b894d0de47494e44a3b29381e540b0504754c4180299d2043bcbc223df77a9e67a81c750106ff2a281ec8d6d7883efd69bc51a539567a1738c101f6a27c73e800ab547dc78e0a36ceb25985eeadcd586dd060da7740140c2876ec89d7c7a59d88ef106526933f4e46bad467fa2bdc3ccc45d1731659edf03acf87d6d47ae7188e20def7513bcaab0c4f711c7db028c101e43f5d73b16c2ce1b78a450f7a4591cbb31bfccce8b480e54b98c537276c48db945fdc511267b9854a0feb66d14ed84869b53f465aa5b0c699056d230462de379dd69f0c6fe46762ffd40d549405c8638646d2cc00b878c579be8dccb39d60586dba88909afef29d55f74a42b456bbf9d33967534fee6ee7fbf9807049e044386183d23c705c6674cc9e8ac0c1eaf5db5c264e8cc74ccc0514c4fbdf077f93372f9a53ae761d669bf847224bb8f4f5d187819fc609f9d17aa681d56c67018aecc917d4270da63b5e1fc10739dfd3b7ee22fdaabdbb951e707e679afe22317865d86334cd5763e242e8d2c2318e8081add3b3bcada6a7346056ad8e4e3d6eb6e7c67246d754f48cdb69c35369ed34f93b8793cf6fa829739bc33274b85ff3be728072f63edee7e59cc0c7235717cf58adc57d55e58ffaa93c58d29038c5a72f9152ea4df71ca3164fd9ce8eb978aab624d72e831bbc346ee0b335a68af4a0f48aaa9ac86bce8588f429ba0a33f401be41596c95bd1b21dbf1ae741d36d1979d64750761cb7cc308987df382275ce8f94287b5572abef4a0d73463b4bb99c7c0dfb94e26107237c189b999cd80e6359d6b26cb2f741c1a9c62c9c2e5685037989a3f8068c89b63d8ae664d7fbb65f95af67b4435675286ba6df2e2b2b3caf7f660a87e460744bde2edbc2ed0722ebd691f278d77128f12fcdd9757eff6a97a6181c695c25096238f5e4dd7501f15fbcdfab2d49e2f8c0cd36a8c829ba874f786a74c7e63ea39f8f627cbe8430c90817c3acfd4b3e390b8828b940484a1a3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
