<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9a4a6785f2aff1c4005a6dfb8fe0c968554d6b47bb2c9451a8f91ec1c9dcb168c09c030fe631326eb2f88b8473e1a3331990aaae3c921c9e06c6998a25550af34009c6531d7b5ebec98ad2fc05eb8e50b7bc692d9ddfe887c5cd01c2d2980e0596cc270444ce41f3d68332983edb2ee38336029d2c710caafd00cfff7cd2e19530f1626c14eaa6e66e534607ca51c583db1fdadf4acc6b608498d606b0de1bcb6e101bcdc23d487b66f908bebd01eb2fe1469d3a1e57bb816bf941f0534b7c83cb6135541e5bff2a0cedd12a75d5c048f10366517619c0f02eba1bf0132cbbca598a482a37cf2b6c6898fe1813cef6bcd875969007cac8f98a078c7c1dd121eb3e7dde040d4a9a67ad2b5056e29b0120e4df527fc967837a391fae6c180c7f08fd8ad5dfd438952909c20ba0b0abf77094a5742bde6450530dee403d16779513b0d1cd9c91d6a720673aee7011dbd1e031c2b700cd33d22a940c6cfcc36ff1aefb08eea7bb9044351c1e3cf458b678ce283d2b0bc3200fb0b03c0b94d1ad1e414f4fa434f06dc79a01858050a55fe16192711a79bde5d50824534b0991560bbe6a73f2c0c76c3cef4c3ed8fab32ad806f54e1d6ee3abbb653ea000317f278e170f3fd045d3ed430b166006c1d68b7f1086f9616ede578e4e4c4cad2515ca76aaa67d304bb76ea390aadf95825218defe471135b24f1a05256c29d3abed98c4dc130b2efa4c29278afe9fa8d60e66c857e119d43fb7d3930fd3b70aa2dcbaa3add85891fd679876f99f97ce801a7bcdb766b8f1082eda56c2fee24691e25feb2e4c2fff955002eb2ce7d23ec0176715cb4ba75970d03a8a4d9daf7b5e5aea9047f17f53a2b45b85e64492fc5cabe12f5f15cb3df19e01ab2809a664777159d2a007c9493cbed75ca70064f140115ca4e21a8dd7ee8fd30101b4335ad578ab50316832ea1f6090c2a38a56e138a4bb6ea2c52c812531b661be0bd870bebed6c8bcb7d6d3bb96fcffb7d391390203180d7df88bcc0c79a3982a509448ba5cfe5ff4bd0b1e304132ae963f2e7785abf98e5c28b471e33992e902bc6d3ce99d14494a3f77cc3d7c9864cd8706bad2a5b491de0e8b86e61ed459aa2f7f79767e2c87d81a0009f26fb16f84a615ea43222b01d35519cfdf7f302113999975db0a52b7b64c05d374d20bdbe01f56de8a7393443710eb7dd746d3999024c114ded5c6a810e0b668c3aa29ab5b80c86633ec68b82e4c72f5b470878d7f3383066dbcf4ae78f89ac8aed1af8dab941e282d2f883770cf07a98b798527cf35b9d1c37c42a22aa77f716c9b2f7b585421c99143d5e43e285db378a3cbcb2f926c51ff603d1f04266ef1ec4e3f7f2d6762ec27bffec3e899270a06edd6c1248a7cdd133cb57c08243c1a48bf660ec57dcab1e8f4521d537304b278ae3def4b1cd4a1a0fdcc402fb418347ccd6e1182dbce41b6ed70230ca8ea44ad1091d969a6d9bcd912b386a6099451f20debd20a65c172f5f6b06f35af1c5eb0a20d4d2c5d4d8f6448b6fe66f6d4e5f48c3f27ec4aa36e82b29d846f7dd616277b1b9a2c92d347357274839d1f07a7eb1e69117aa8589b182e6d7ccdfbde4203f38a9e48773d2e166a0d83cbafa56f5fa0a11b427606487e600debbfa9874e933968b66b7025fb17a261a24207841b013619c3c099bd2156593a7547cbc6d8a7b0064b6d363f072c474758c1b7b780b600120fef0660c12a50ca0718f702bfc582954340c1fb755751783cddc26541fe832a2ab59824a091128d7c251428e2e3e661cbf119dd4736908d0b70a864d4038cc4e9e2534b16166484a0d8ce2726ea2762001affd1a9ed44bc91375048ed4c1c5e2f350f9a3c714ebff1d0c3ae0ba2974b20d9815e139f226105727c1b05a5b1661b918a57082cd6bd11eadbaea474b13b09fb84bdb2b9a2cc2865790199e77cc0329578c258642fdc0b26b2b89d49c6a3e00ccb6a4d893a9f953f1caccc8ab4a246fa819291b2fb463d9b5c93cde7ff5235fdcb953514c8ebb80d23753c0136735f0bb819ad1ff43372c8959f3ae9b7749704882850d1287735dc8d39ae18f430d73c238367566f71cf3d13b17dc90bf643d41b7f09c56899e9ab49eadb689779d4a107ef7c098173effd3ebb3bb3d5d93b7afcf0050198cb6c63a5898280bf9f08c218f60bbebf94e12c19d9b81ee4952e916b4018ef15f032d9147383ee5c16fb9738e7cc65c0d928b4382b072b32d88a86b2345d3a87d36b641555aa60dee654c86ab2f2aad408837c0364e92fef42a91b09342d9fb66d340b9a7db954ec4096e90d1703ff73c0ac6f309787a4bc067e6f3e355f2bd771632e0f420cbcf22824c61d8a8f56845bb342e47694fb2d20e57da667bf0ec7c61fb1bd8955e0766198778388115b3aef26d149f349df532b3b90f346e8ebbe360ac20855062fd62f25fb249a134cc8464f2fc9a5ba9b41f8cc9e6d6bf8cc63b0a4e579d3ceb189ceea607daf27361a61e40978455868cc2e92a645d2add38711f5a5875df47bbbda4846e4ffa8f9767ed67f4351a9fa6c3f17ccfa5d92afd9edcde978226e48addccb9769e9e4d25228a5ed4434aa1db298acc5007bceba40d192c5c386f18d6cbbb5e3cc62e6f7684117caa5e03b4dc7e47c6dd69f754b2ece8e77453d3e3d6cd879f7554c6b1c96ef86079577a9be84cefae01486113e28026f3a564a34fa29d28bfcdcd5278c58fbfb573af448cb326cbead54052426f346c20b7aed48140002b3110189e2146380cda1aeddbf77c1f71d36a51e091d242fb9ee63996ad540605b1cff04e47c57870915c1c797124507ef985bb557fbe76c8551cebeaabe562fe4014be70e8803263cbf1c42de45859f08a11cd8988c43245ff82924d1def112a7c9b402e33e97da428d1828af3caf068e585358a0257c1212b73f1c901bff9bea7ceb1e377e6106b838c07a5f1d52de68fb711284462cdd8d3fbf95807c6f84616c14e3bf7d2b0eec3d3c8581a3892f5d7b927140d152b6c78895e5f5601d6b5f5b99659619a4b6ddf119ff4a89f255652fbb08578b2ed2b7f1952527bd8583f45204f9a1060bd6b5f2dc934ff14d083c20fe87257c1f8bb0bf6285f4146f53d9a5fccb841e883bd067128f76c7bdda4c7e3c8d97619be9cf7bb46c09002e6ddb72e692a9be65d8d9a4575edbb5728ede822291e68fda0d27c98cdeed283a9d4f258d09d9de44a196494fc944cc39d86fe1b4022d343ae1ef078d76ef2abc8377e9e4fc2120c24593b3115f35db56c553a6a1d49c5d5a751177bbd5067d722de5235fa5267dc1f239629faaaacd3ec7113957221953aab616d4c6ea509f7da2a125ff6ef47ca42f5cc9dbee5d329a145f1cda6710b17704f80dc36175f68e612ce8deb0c617d3d903d28f53f9c121774415109cf8733232d5f8ced1ed933b7b5712a1672603ba6aee2704a454fc0fb6125210f9ed18be4833b2dbe74d4892422c44eb4d4de44f8814540097117b7ee02130e793ec70598ff332e2c804b93c477ca4dcb002c228209de88a0c4c73605b254d230952e7114b9a00e5770333fe27672af7bf0df536786a175e3a38edf8ac16d146d742e606e5522e69855b5b7ca47cefcb488fdec92a5ed21dc575d42241c52ed4b0cd8e69a0c997171ad99cdc3db2e7d49d348ea757fe76e9d0464bcbf15664bec14b0c28cd9f7660719cf4a133be378c483e23279f1332681b239a6d093c78665b027b1199c0c87fa33f9401031ffa217d04b2068ca2502aeaf24ffe173861e84305fe45e2a824c8938fa09bcba28418207ff8ed2895c1ad4a1e73a17f6a932b300990f81ce89e30acf13377dc79eba6f23a6387fa9d437e7dcd7cd8c3af88f91f0dd7c6269fc3bb089a7e56517e557414e823c0f1fbaa04844b49fc68650afe17a337dd0aaff59250208f3cd44766957e1ad79577c7b1119fc1bace628dde4d05db310c738343067cf7708a4ef7351382d8e0cbe218d9fd7039f6cd767304a88b1ded448fbb34be5d0af775a9bfafa5c4a989727cd7842e70f28f4b2c89e07b8f8bb34f22cab80a6aca2c43c80ad63746383dd0124e178e8b2fd4fbd3bbf51cddfa591658e707e2eb26283ae15aba321adc89b2a489a46da144dca8a4692d7a728e06761fbf6f2b56ca491ad3ea89eb5d66984152845e7469e4c7bfddae30811a8b5b7bf822a08049e1c940e253c5ce6dbfcc9b1f88c579d1427bc5ec7bb0e458183462e6359b6eb605fbd43a884df6c69df18cadcf25cfde8f052dfaf07eb94c3e98d8de61b880f0802b9f55004cde4de866e560b6e0abfb3136b87da4c0c8096b2f0fd5d5d90ea4ca67428752ed08d76dcbf0426d3a3039098fbf37a358cee1b344d1d6cd57380a76c3f333d0c07588f91a9930f63ea58ba86b663d894cc46f598e07f33d24cba7967647565df198df13c1513d04ad73a2516ea431f66bd430fab55a68264dc72bb2165966bd5967be43522380deb91b24df40527e38a3d6f3fc05854edd23bceb5d4db27f1628ba133d655eb070f5644042b1212d7dfab32f4c437528bcb28b20c3ab9b45060d1123e24eeab6c4d85cf434678227da78a37007fc6168195cfbbbb63edea18e71542041ce537e1279119068dfed67b8f56ce4b08e238d697ec78fce81221b1fecb13b736d5500ef5ea55d2dfd9ac3d278d4a4efc348f8a13fd9122519bd95c62e0c895a7d05d4e0b9b0d327429cf972ae203b292d19201947416219b849387d05e5b8da6b95b52ee008a10172a6e54a6e0fd5d891715db96e4dad9c18328ba11841ea57dfa8e67a5ea2cac9fd43e1ecdd87920f0da535bdd2ab43331172c4df8961468f50e5951c6ed5a4f76deccdb27ee0f0c1d6ad92c1755224a993a8d4659167842dc489887b403297be12c83c846a206b3b96b61f60b7fcda2ce0c84957e0237c30cf30693a181002d56be94580f4b38f1a9097f060205267d8014535ca9f321850586829688ddf02c3612cdd3dade7bd3ee71aae5b2afdc5479521b64549823b4038a8ae188b7ab8c85855f65eede9a91541e7984bdce111596c62e6976652a6d5ade81a1bd3cc51baa67178e7acaca3da6fba580e87a207c5c21d2cdc3c94811da135871184208938e869e7acce10e2d358a4ea89f14d80562a79bc65d133411cddc40fb5c00bbc7d53365f8f4fed6b4b349dbfa1c210d8c96d0d81c11dd5394177d4f4ec90d1f391d8650f3d7f0d285470a4c94004e63baaa4c8a055c6dbe14116490eb3c1fc85351a6f1a57ab67a91eb1402a1670b929169f8d7fe9bd7e3a16b146865e8be0b200619a774919a6640bad876b85e3b37b2d5fc3e80a328b4c8d67220bef5af968e7ea509be0ed6c123d4997b2473d29f337b7697d0df73ebc5a412094f02f2d207c08bde701d5b370467535aeb7ef8d51b87b68462a101de78e235a7a5cc86c5e3b7c6f5a40fee711eab24ddfbadcc302a3274f44f7da6412c03776d27e8afead5bf4ffa3afd05545220c5d191df7037f728c6f6d755f501affbabeeb16370d268bb6653cb925a9fd39367bcb15228508721099b50d5e0dac1ffb541e97d1266630a34a73c8286f8fe60e9998a0abb83921bde72f9bd270b6b9f42599ce8d11c2574c31a20e39c2bd2d45e20b410545da3f5d90e79f69fc4dfb5ead892a52d280bce06a638acfd98680527d14addbde7565b89a900f10ef497cf5465c7982c8d87455f624cc2da45e3a0118f52623c0ed3c8cd6ca4a5e4ea198c73e0492dc8d66fc7b4dba131c275b431d9603aa9b2a1b915fab1c72662befb761d6e505b02be61f04c63d9e1aa7091fcafff825a09e66b50e60a61b9c2f2e1d7d8d60f2bc12da3db1973c0e444e063dec1c7ff1d7dc6f5825e0e47174e48fe97fbc379176a1cb3c662f47346ae8b2ab0cb7b1c17226e162a62389b418da79f35605d76becd756d51d6272fcd00a8ff5fe13e1ca8554f3695f56c061cb4436dececd129c3c71e545d0bb64ce8c190ddab4b9b39bd237f8c3e930929b5aae65c95a00cee7c75f33dffef11bd7abfb5a1b6773fdd488a13e1df6106ddaa79da69028d05de3c466dab68e5c0a5fed6ee1e7c05a811f0248623b1cf84f45883d320d78e538e01bf8df7c92b6b1cac18eb35548ed14101710be51e5d56e21ceee4f097e56c9d4c802b5d914fe1394e99a3977bf541a0a7f4aad78067888b5c8fd18061bab176dc5c31d451f43f6c56cc8106b84e731e13fd152a133440760ccbb859ad487c4400968f29521f8d7105a6d668e65d5713239391af9ac7dd632eb120d88643e80f1136271a00de99b8ab827fdb5f40363f096736bf42bfdea0660a7cbc5694d50bd77ac1f759192690ce18a20a11b1237f0db50d1b1881fea7e8afca6bcb66cdc764179f6fba2636b122e9b66244b58a0256c7f5cc8a5099739e148bcf06d8c0e231eef2ed82adfa640cf793780c2a6ecf9580446497c8327fd94b946f5466bd639f15f9b809229c02d4162bb37665210164575a907c71241f8952ae2ac0edb4c9695ba80cc3aa023f01ab99d63aaa837ddbea7637b247444356a7c96dc86b302272b818f2ff8b5067af359ca71ca07c4bb3c11d294ff510db0ea8f63cc8c9d5f7758ebd3c7fb3f3eb0c6f8653e617dade6daf0046d363160cd2a9b29c9d512f3dc654bfcbc79c4346af5dcd5c706c2b1fa4d2ef414ee8de843341abedb287951c94359b05c7419e02f46e65bbb08ca86dae6fd696435a7c918b25ba4cb798c6a4fac5edfb49a4b460aac0e560ce4f2cec5c166cfb86f9e64b4b9d3885ac79d44d70b3bb528a396f94637afee62096be1e20bce615909513f18343c3ac614781c5a8560323c495b7fc43090d67f2ad51a7d8da69a7b617b0e810dcc93bea6d64ff95744d6ebc740a54521f7932bb0ff8585468500060453d530748f0fde85005e6ac47a6cb88aeaf4d6624543e087bf4464f981e9c86cb843862a073e399c1d8dc86a2fbe98ec169a532be1991027bd55f9eef5daac21689000f512e2e0e4e8ea611929287d4371062f18e9270189181470855b1dd57668e4f86d45bde164acd7b23b0b0e7f07af7b7f33f03bd9b8c5b12d24befb33a63d1c4ddc7dbf0b9d039df9e2321405f0f61fa868a97228b6b9ca5a788c4be0c5fdc4174d11190c05b1023a7d80ba3eebbfac6690b4bc6f61315be6980147c0dc8c592f5c7a205c3df221f7a8794a5d3877873c8de20c630b99519b5169dd3d1e65a290d9b59662e1cfa6a345a6fceafc1c066c6b525ddd2353e0a81f5e48ecf619745d7f9f383285f5a4402afc7874a127f074683a8278c036902c4b9098f8ff0b141e847d6baeabdb46ce34e583843a379129ed9bdd85ea90b1e34abeddedecb0aa92cd47a7adfdb1b72a6979f73567a9926823273ec130deb74c58b8af8d66b6e70cb91284ebb200019b8b68ef974366d199d8d8d28f18478da70c53d322151419e4e710cb79bbf6c92f7ee11cd1f4d3d92bf0e1ce1668ed692bd0097da6ebd1cc94bb468b770ad7a01094fdabe00bc2ef55e3af1b575a9357653100458fcc806244c4788a2c314c3f51d4646ec2fd12bdce0c140b91cd9cb39ed7b8999636aaff785759577086ebb096e9f3e413722dc69cf17413dbba874553b85bc63c67fbcdebb817c85517bb4cd1bd2319b64f89db556b13603c00fa1ee8816a366b2761428ee4d6189d4fdae8c33004afd2ae9737f531c9fc8f1c6f82a01d4265117fec98e64f384c0ec3390bf8dad739d74a6cfc81dfcc24b74bbb2ee28be39dfe49227f55951c8c32a0718dbaa91e1f111fb0620a28919e1a103f49a1835179b336b9bd42aaa7bd53e6b6b66d4d3fd562f637e4375591281910ce24af81bf372a0278771191de8e49adcd6f41ec8548dbd13b68612302a3abf0bf9f7ad004aa8f7b9aba9d57b38e1094057a3af6304b6825517f2659c129913755683f3bcd7bb93ff46c2142adb972e467c6e06e5c2fc766090e2250ff2a4d5dcd516b2e1a6e9b2e7638d3bff680dfa24bfd2df3711b5f3000b0c7a2f09d521d6dd6b042cd46797c204365c89a9f1d4058e48c028e8b0f468a5bb0659efc90b0fb192e180150d4077b9bf63d7975cb23b6c71f4f228a95e9d1ddf205048abf652eb86ec7f7c3958517f3fe2eb89eedebe14fadf53c09bbf5c8479e135ded73a53fb2d77f3ee89fd70afe3b03bc2b7181fdf86068ed92dd1c8b75f6fbe3eb377b38284b99d83a720c09975a3e8223eaa231a3c5d3a4bd98f7376942123330dc5da65ce49701c56f9104d6242219bc86feecbf16022c9a86eeb97ab8acc12e919082c41bccf488c0fc07f99ea79be147d0dd2317d4e4a7c0836f7a378bd4d23f469f3b044e445caa50f5f1cc3457c3a1e9dffc79811c640ebabba1c6754a449236eb24b1e4b1dc3bfa301955baa16f10903eac4988481a247e557c7c59ce2c111f26f05169ae43605bd1b421dc0162f785a46764c9042abab0345f12558ee786599309a550aebf64813107d210605c362d3824882084967097074aedd1a024153f4421d4119eea9ba42dc263cfd31145e216bc9b6b8343790120cfd729a41f5c8998d4c8bb12bd58e22dc1f2c8ca036cc786f7a37179379999880ba46d29b3814f5010e43a7dd9b0d62a5feeb55f33e9b2ebcd0a7b8d703ea2e1925837da57c8151bc88edcd0b46323605830643caa0bc84fc82d7d85fc71f31365cba57e2f60c0ad1d2daee5b3aa9dc9bb65c36cf3e84d94b6aad608a7ca5091a9d260cea1b7028b2621af4fa2bd0fb6e351768e64ed00a7ead286ad463c6c7d5adf8a20fc746f0f5eedbc5f78f9c09fb9f08102b90e1fa1c6465bd75f57e869bc7afe59a8bf849f86fbd1f4600e1bbb85173a1a02d9885bdfba89c724bfd325217697a37457394fc7518511c4e7c25f4a9dd313bcedab5b379f9ef424e6e01ee5019bf604d9fa6816df6ada841afa04e8a0073557b419a47aced26cbd81497fff6ad8e61da7bd87c87e0b93843c33fac2a559db50e6415a390165e5cff8f0a16f2578d8c06f177185de11d46b26c3267c501c69094c17e58d4157eb7fa526ef4303578bfe24509bfcb502153b4e4704f8110d6b0d7e3f0e803d872c56be9376e953b6ddaf03c733c8f1b4edbae7df1076640fcae8ba57420d6e7b8df0dca15acf72dfe0a5dc614392a9ac66a49c17ef3886ef3b0f5c6c33feb0510871d3837ffff567c703113af7638a32ac3dab6cd65b5361fe8bdd9290dcad28735d4a145398a3f5925d86e2a1e522adb304af2905a528f466bd2353d1ad573bb96f927209d1704cc44949f9aff546832214ffe836ea00a8f6a007f8b832a1a58c8756af6c1c8b0cd8cbdb9dd79948f1c7e4bf8e91a212cd96c151e992125bde2d4ec2bfd0f592c0bbf3c69d4708e181eb52319a6a2327eccefb78a9b21412f90c2fb52912e535fe1c2df0d6e6ae691b246ec6a13b5e707a6d636dd1c85ac6a3757c65389a67592bd88d88d03b870d7d513cb6b551ac8a11267358e4b28104b02ee30c44bdcf2342687d402065e2dc0c57eeb1e5bfe151a204ee92cd3eacfedd43b36304de2acce585b354502d1764d5bd9a21edd01f3e0b947c31acef691e985216924ba642610ba9a4cddc3ecd68d337a998260e332f1481cffc7b50e995e0175bce630f1fb69330683b3ca8b09940b3f514aba399604762be2b337c69d553646ca4b8714c5c50312348f4162005ac20a14571834bc4033a4372ddae984021637d1b5230d22eccddc0681aed3504243be7957b05efad805b9a9db31a963e80b8e5fe652c6f5fa7d569deb2f1f0ceddca2b482db3088a756a60c33c47e16fbc3d95936347f45569bb5cae00b006f4f53a1636a7973981eb010f8b10e9e728927cfa8144043f5e7c3f4971e514c3056db8a014f43e96559be43142e7ba4fd44bc3c90d4acb3dfbbf7cf239809f5a2c2b78bf86066692e88eb8cac68cf3bb8c6a6974ccf2e377e116585f8d2f141de436be0c4c97c6f204503efb9f526dc0e0e23bc94fb608a0e1d625b1e1bbd1aba57b042d58316f8f2b2623afa31b75f54acf8ed57efafbe081577d7a0617c547d3f8070be2e0d05ad2ddb53da3787d5c6eba0cd0ca156f89e3fd5de7b8428b9d99d57b1ddefa785ee7de090d1fa923bc121d6de48ed1bfe7b6366a16ef5522f765ee915e515b15123ce88ecc9c86bd726c1386419a1786ce51ecd11bba08159a3da21f1cf98f8c57fff5b2264361d2a41504e8c02871c45d8b1db564f2f9c80cdbf561b142ca978f11bdb7d21cf7143380933fcdef69fdb1edab048c991309e652c4ac7c9106ce4cc1e323a12948d2b60163feed4549775ae1f3f2a118f77279df258932b56eb9f1ff3fe51aeecd6242319c9406124dd0d012aa592152af796cf3d923cc6df338780660f82a7a748ea976b52b4ea791dbfb603df89990a7106c563007e295f6a02bf09fcb00031e1ed856beee01fe819b8abec1be990497a19b4404568c317e6cddd3962326dfb0607ad4cff3771fe67507990ef9bcb136c0bd759db5a409a3531bb440a5fd8a7d4ba65abb5cf9960e82e1318a1b5bd075d1b64db11802372a72e25c604a344c98f4757f4e6ebffd25eceff4fb8d8ab4ab0d33a9c4a0a022bb3bfecfa3089ebf77dcbfcfb53014c9dd8d95452ec581e0c9d91620221ed3c4626bd6ff02d12ef8919d125b43dbe9a52b6ada5faa4f5f42005aee7005c26a6a218cbe4ed782c66d255f59645ea1c47d4f963f069afcd451800be950d3f3fdf7b1db361115cdf5951f271eb47984808ce735b26e2161d0d3735a812dde5fa150bc658b8705aea938e7f738db41210cf12f9b2a9436656d8af173661c58eed62ebdb8468a3490bc50e7c7a04f57e21346fe2488daed8fb09c1f3a8ccf6bf573e180767690dc04f6684f302cce104a6d1f9c383e1c9de7bde119c267c4c78f282ab0e325063bed3ca424a3e54d1a841ed9bfbafa8ec80767a92e73697a6bf6a218e8c292d1a108ed357c7db9abf75f92c51a494b2c23c0079228cf6d8ac4f73447965b3ca5644578f02e31566c52d26700c8408f84a47dbd07d0e2451652ee1cd157cc0981db2320f75065759c1e1d1a7a4bed0efc25d8f21e88835df4fe190c207a55e3aa9522fc6f1ef2b8b7291732686cde66004d7f4fd836b2af81049206926e7dc7d7b29343087335f6f8dd4ea2e7aaadc7580a777c86257a8602c05dd429b9f63b4b2a8922e0b61cfbbc07fe2777f73d0b53440e833a377c44d97eef7d6f587adb01531124a5a29d8b82e2c09195ed2d449eada8960ce90a0e5005d2db55c5d40932ef6eab431ebe7d5822535d64649d654cf889a9fe00978d5a9293de7ce581df6f5ca8982fffef4268ad60ef9da845173c1626ebe5030e839c56a2293aeb77a4b6bd605327f14d2743d851a6ba4be0a1b0838797c74258b8331e26e309961bd3c4162e9e2984fef947f7f1e9463fd95b6692a6b9ffef36db876a4471a3f99f9e56583e4472ef31e2ca520eb46760757d240b10badb59fafb58e6fa757ac93a85ca5a314da000b6b409db3ec45c524eaedb8a6adc951fbd1a3c75128a84f733266c021edbfa3e74988f62cc2858c103551f29a2e54dfeace4f4af9b556c81da899ba0429fa837b54cb649531c6a7bf70756f3bce76043b588965f3bdba14ff0f049289281149b796fc04e0d0a361e4ddeb081db9e278f14135ed8e0d21bbfcfc5b372c1e76bffb2bb3a25926c09a7710ca464483a52aa26814c9235f2cab7547fcb56ca5ca4bcfa0f425e70c01e4ff30d1c8ab71386d5f6b25fe22151efc5c12a7784d81f35fe458dd577110ba528a82110ed8084e4deded8466f8bd33ff9bb45228788d510b8fe72200026fb943df6ea136e86787b4f5e3c813cb93e8968b33fd79b9135b64bb0556a2ccbb168e5297776f847f021b201e7425f9dd688178b00341ef19430ef882d4ff079a1acf20062300cf4fbcb82566bdfdc94cfb625df45a68ca9e5c625ebacabe81b6238cfc2a2903cea1f0e9343a05b6977c05b70502641c5359a0d9ed87f6a5acabe052dfcb1329eb7a2081755dae35df145330a277e523bbe2f0cc7ec19039a5ef718f087b15c1c7913e982c27d6a39c9ec36c7eae2e5629eb97b7aaf78341f8de23eb7b2df31b630558588a7fde869d47f6916c29b750df8017581578737d6e4a765c854ab5e563218fb8fb90a3346b4ca41e0fef047d7bea623b16757c2ea1684c75ee7f7113dfeebc2cbd5f04c1cac52c993bd5180ca4190b43a6b12bd591af08d36dce151456c1eb5f204ed2d12e7b1f3e6c34e8d3a25c1d3057189b76c46115b3349a4a82f51642c3a8ee63ca4ec8b4f97867692a6956ec4c2e860765cd2f22af777312c8eb21c35480084820e5d6d6bcd77ba2366749468c75c0a3fb6a909e51ebaf754773262c83803bba652d73e706502c039a1e881ed6bf430fe40a0ab28c0c98ec695c068f7e12dd079cd976c83924248b428792f9100e44fb2a21831ca4527f99d16c94eb8986b16d3147e121dee036d8c4f7693c03bae69724bfd6e922be615df70f56abc2d90b45b6c9b69cebde4937d5ff3efdc3e738f9e2c0496a0b5e3dc365898d9bfd217685ad66a58ddd3f3f02ad2980182df4c267db956464482525a1144b06400fe9929277a0b27dea1a57d4aa8372aac9e141f6e57a58555c987d3ca2b553d575fd315025d4d892d23bfc7fc1e1663170a6d31fda75350ad2ed32cfc854df988e9d7deb157147306a1aba2f72ab4295ce06c599cffdb334632131fe8a45ba6dc956c4d58e1a226460ad95678e59a070bba65b2ff5c7abbdacdac3b97fb17049dff5967c20154bed3ea54de049a5d197b88c335de710564cfd8b3815b228a7bb109f675a41ddd960802084b12bd40935bf3e9daba860d1d657883c4aefd117d07ad25589dfc72c3aacc0467dabf07990baaa630b1a73ff53b2b4c311c9e15476a63a14e4df23b251dedf87cbae0ab7045d5576e8c859370b991aaa22330a2f490b49f81f867ccfe454fa04f3cd5712abcc1512f15d4cf6b6dc93a340ba0d8026d3f322531249ae27866433ee0bb7336b6a61b18b37ecf0dd8c3cf755eed34a6055e854613242b7c19b430430c4f2ffd73df03ff183b9f9011ca4b5e0b928d7ddd8a8acf1b1a1d441f1507e7d73b8a00add460d4d0767cd03a6cc8625544b001ef7f145d37a2c15876a4583bd829fd81657f4df410dfa68a28db761044213a490f1ee88f7a8310e04b418ac9d64cf335f0608dd8b6d92a622053fb5cbd3f60ddb45d309d7637be9cd6221a4c5ca62504fdd2cb0e14a2e787b962532dc80c65c122f0343a4c21210d3b0ae3b4fd2192bfad20be32bebf56ce72ca98da162e7d710dc2f4055818f4eb9c80092cdbb6d9ff05dd381aef0918d7d7f75caac1db9c341dd3b5222654293d630436b439ab3aa87a1c1ca45ec161dd8f31943d0e8b6b19eade95d7cd91272376b30e74e9e2627e67dc6f8604eff0b2854779f2e7283b3a396a812f593c25e942675993a44165891051b1b931702df0fe2ec8c4f8e6583ae8d242061286da7eb0b60f4255f844ee4588df5194712e74a4f05684fe9d2319ac0f716adf1d24d498e6b430ee01edde69a09d5a6fbe8cefa014c22e29b351372ea102f06f022ba31a1edd3fc6b7f214f82a890d32b4a6850e1242149d756aed17026ca15e2d8e426d46296c7a7e7c0b2a42cf423ec496fe714a3322cbd103cbb88fdfa2320df3ef0ecf68c8102a8725b73f75217c4d082a6e8c9da54d12efb1c9a237eea77318fbd92a08fb00d5dfd16b9d10a30aae4349ee7909ece0249520f99374a46157182219fe595fd2c60816097b198d6e538a1596f20af79c5d3550de44ff095901dd704418c245f98b941fdc2ae28e482a1e0b55f33fbc371048873db25492da10cf8d8a15ccd3d7f6afb39545ead816e31e3c524fc75f48de3c366bfa84bfb90d496262bb28eac78e9737ccbc74df256c8bdb779fa2c473986a4b690623b543b2adbdeba12a8328fde63e1a6d7eddb1dae2cb669b1e79d42b4c28a60c38091f89e721501c0aa9a517c3ad89480a0c2ba135fec5d59fc8646b17d4aa7c59d2f72e5ba9c33cdb2bc83b9b4ed4278d8990ae90e1270d386dcca68fd7158c0e89346fd96d4a42713fa6c0d9396111723c554f336efb4e68801ae37cba615fb099faac936c5cb68a0a3a70d6be558911c56dd623125a249fa61715e14039ac06b74d2754de2d9ee206649c88f3cc2f8a1575289a986ca98a9563529e512f3870246a9874306f32d784040141be0841c777db6c02f53623eb47f892563bc101a4eb99f4693a5e5a16fb7fdeb779afe46eac49a3d9b61418df06125f6b71defcaf5494c5990055f7a57085895c8eee03edd6ed1d1b8dbc90937703a9fc9131b4f8cce3a6770bbb16f98d9794e7fb200854eadf4428bc7522355338c0fdec399d13e887a41c2ebafe5e58caf7c84e862b671f4e51a1a76ce27226fb105df9e5ec6d04ba503e8c0f03e899f4e5d3ed934ed1a9eaf60af1dcb0e4dd2702abb1fd0c89b38c20de923e20cc7a6ac239d29ac623eb67e4cb9adaab7c0a6c34a5aa9d64a24899477bccbc6118ababc2ff713de3af6f6a8fcdd4bd443c7559c247d40649c88a40f450ee0c9a9282fb540ae4c276ae396b697b02c92765cbf31fae7442b158ff12fd0165a3664d32cad17257253c696c828c476356aaacf676dbd61df8c8e9b799d6d4d4ee1d01a8230269b4c8b780ed94d1d001ce1daae19f7a6917d1e8106572bfa521f66a5aaed2161e9a8e33714e30f02125aceefaff073362c338390deadd18383382d67a07ec1fa5c4100d8c571ed4970537f9be96057db337f6ab9c4ea401a9e14ac91501cec7f419a741898c0e7cfc6be3616f6e820fc23cff0a1554bf05e70f1f013a8a54c66d68a944cdda9a317105e80019f79f91fd5ca0d38e619d8ea13ac6aa6c69e0c0d3823bc83a24ea6e11ec1d0254128ff9b505c88a868d2933b6f5b1ca694dbf530d7566f243cab6e578a8eb09642bd42199842ae0f8a1991df653d509f7e619ebd9565850ed72037ce99afaac9f4cefa58dade9adbeaa048c2ff48cd86218489bdf5cf0e973bec17f2d19894e44847ad06fc6a7f4e8d069e4428fb886dfb1e1f8beda4faa04bf06e330cdd29cd95292c8c3b476d6034183569e2a831f6b96dcd4d116b9ea9c56be8bc1f8b5414ffc3f4d81f60f0140c29dec47cc65f06190a2680177161b23d7b191fd1710c9a401f75286e42a7cb5aa5e79d434ae4ad1f666e99de9bc1b4be36d942cad2db656dd717c43579bb27087eb886dbd3b15a133628b62359eb4e6f1d383e03d3d00b87bd784b164e7562fc4b66cbbf725ac39a6789609d8f194381c36b6e6583ec060295977b8f2163010d3dab13ee23a75365ea858ae8b587983182220ec4381ebe87ebf958aa79aaa3810049765865ad70853da1f3b936b54b02597344c577eea9d79d84be91939a62736794cf050fd761c4771461fe3a07ac6477db482c59eaa6647467b5c15c4f4d7a921245be837ea4a72ca5406c85638d75d70e009e5246870d70f4b20a6372adc31edc21a9ee37ceeddde2da76fee20f756a3cf2cd347870736f3ccf0190679c2722ff0ea5b4bd4ad55c67035acffaae36ce8fd5d4fd6f1d6c1cea836008a2c1e98ef869377c2e25c92a82a8bb2f9ef1c733f804547e3fd84110efe89e47ac51ca20fcbc2897145c5a2dc3835eabd529333487dce77c9aa74481d39bd6d4bd1f223e322a023b8d63207aa99a4cb3cfc5ceefbf72575fc04cb3065dcc233ba9f89fe1514bd62653414376bf3d921cf321a4c15ecba74bf04446564e9a2ed03e2a9aad917fbabd6b681b371c7fa012c8395988e0a083cc750776d852107aef0f399764a654089c4b5ead9cf99b46beb84cf6ad355d6e0f023c91c3d63f6af7910cf1b278388e3c7c5a90c3e7320ccd3670351ae4a59ca1e6a37c5ec9165654ee79963f9f256493e08128d881d845b26b4ba55d80d753a824b46941b8c56fcbe7d34895ff0a4e2a1e41220c6f6d711344714ffb4d859041d682716d5137c158626156aa008ac2e8147344f6d9a781ea8336119e61cf790cb6347ce2a930d3a53bb5dc31ae3522efd0ebbd08c07b4a06580025ae2bf9c99d983a1ca3147c68360610a5939fe6fdfb41a79e7c6a35e596d5309480ae11d0ebea6a0a7d28f5e026bf77d93be8c6cd8fade2723ce94e7ed78c65b0212623043de069ef6d17753b70afb2f94c70b363ec2733141d1e5fd69fadd1eb3d9f2abb3f58b812e35d32bee85af0ef6d50acd14a573412523fdff833cb471ac3b823301be8e876b47e45c15c1eae7edc482fc111400845d9e9124dce34692d23d97d8a0da4fe7c6eafb80075cabfd030d63c93d0b79a2dc1789157fbe181480dcdccdfff9681a8bdc557ea7704f44b9314c84790b39cfa1692e73dabf729d8b6556a5677a699b0ca85eb6b41077580deed2dcb93f0fb7eda5a8f28104ccc7b4f7d420fe99555a4fa859c24776addd2e2e0606695b60c10495ad6de5f925f0dabe203713935eae4f840cc5c54c65689759ddd9d109b9252a747df75de0c18218e7670287c613d86e47424a8e10c4bed8659238d21a00f3749b110b1a36aca84bfd3a4f2c747b5ad82254039b5c37e5c0d2579f99ff2da25f22595fd73e1cdfe8533836ef04d53b14213bda82473e90da04731bbbc41fd7edd2187cb71a0f94da19ecaacd07bcf9be902fc62276acc05512cd799188020cf02ab0aac156649cbbeab5afef76a8d1dc3d5b19177bf29bdf097021f18cb97b2ced8310b2d0ce4e3c5e709a058853a33d91e900c881a52973c6a5ace87702f4ce1fe60eb1e5e29cd20b2088e80b4138d7b88e9a7a654b7250b2dcc2a1400627aab15b3d49e0493cad5ec98416f7c948a432e669ba051b48a3b1e74420cfc2b77dce7afbb9b8294e67e7e493f7540fb84e623e3cdc2050ee5ff84c9f865495d2fe3bc7813853bd0403ab493f784b55ab9621b1177fd4ff6b7ce1ddb2466aad19108f982273f01ddd634ec494b9e831b54f50f519665918da0ef19fef94646255268997754cbc2cd31934b8025d59a90f0d2ae6580e6a3c6d7dce6fb2ff3327f150391b1e77e61421cf21f29795bd2b06ca30509b02ef4e6843ace3f24da73461e5cece7a20d99aa079c1d5a12fcf4311f4f79c1796dc39003990692a5a9c9304ffe01369a5c840b449217909ad12763f7953c2922cb66c009b560987158d2feb91911036cf70c1bf2c61f8414aa5774fa21284bea124e9764cf22afc9175749ae005b01a8113bfa30b436501ece93fda24346c6ffc3449d2f33b4e10f37aeabaea07e7e927dfad735afbb4c0651ee2e413b36071c8e0b28084b5980ea4fb0955b747a8584b87cb2ad59c624a6799f18b0f9af37f159eae5cf1820888cb2146ce590778c8963aaa3b35f8ad013441ccd07b29a2b8ee44ae1c87bd8beb386daf133a3629e09e5040722f5a55572fe76274554eb2689824ccf8e4ab6b24a5bd41240ec60139e2d9616a1f52dd69b98d9afa9d0092d70b6c28d84a76cbb49f0b4a8e1808c0f31d00fa53837dfe39086e328e13428d24b347a6dc3844ed55d1e60c2a88ff7da6caba9c9541f608862d6bfd4c195de9c09f694e18bb87109b1cc9444c353c28a40a4c7ba6d46e46a6e6e19d9267194a397506de34d22fa7369afaadb169d5cd9dd4b6261e91b7fa1da6c16c35e351da59a0df56f8a667230a37634508273bcf8c32f2978e9f18a44d646245689a37ab241ef311d66a863636e107ee2037569a9d24d9f832c27c0fb95bf32060e692b313808f0ca87451217289f4e5bbb3577a40b703d7ec7f6f4a5a01327535446e551d98eaefff263ebea5b43edf800de2055abb9b619c050fab9611d494a672096d0834e0dc3d176d1356953b31c4314371dec5d2cffece32623860c60e4b6bc90e5d7b6e5deb4dcb04","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
