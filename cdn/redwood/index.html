<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68fa3d1d356413b12283a67961938ae6632b54a1858ba57c97950582df5ebeb0a931121298781fd355e505c80014145e8127e62723470ac5ba24120a393adbc50c539b09d73e247bcc8c8010f80a2fd6d11a1328d8c60ec28f61bbc7aca56323920af6f1962f37714767061ef614018c14dcefd646c57e76f0c51d06aa216dbc326a0f0de2e8849f938ac14842582f82153c638b70ac1b19841ed3be67682e8f45f1dde0ed08aa3d0f0b56ee4543e39004fe23c28b0565302d953d14ee76627b8dcec255d69889807a86c225052f691c7aa45768ab2087902df23bd16210be2c3ad3c8241daff5cd9960ba41c6be3d888654878a1782cab3df2873a11a9723b9677aa756f28b6369db941bcde55be715b2c9383ea7e5c38f659e73a90d4f1d1ffdb07194d0a5e32aca40b7a3722ff3c998b8d3ca96d876c79369ff33b89e7a866a4c8786d170616928f6962e1647e2a5952ae8818065577b60b7f04f5a22717154ffb777f29ab4d284a948341c26563afd87730c45ac5db9dd6eb5f6ac27b2264d80189b7fd824b3d19d684044545b7107e55c2f0c689df38aa865cb203878421c7e1e63295bbe9496c9815a087572a606edee8c92e106726d46e7f1d2083ae4a066cd6c77c7b8ef1bd1c7b5446522ff2999c05eb861d303a273229002319ebec82614ae456fd1220f914c9beaa3d570d9a41deb5facf0bfd0dc107630c305b0ff86e655b7dc85c7cc38835a4611fb66e99c38fdf36fd11f35b906d63b99b26ae8b90a8849ac8aebf58cbef5aeedb02ac72b2d57634fef3fc363e851e0280769528c970037751817b0e1656e5486b2fd475a3bbf15a86655586e28e70ae95af7832e9baee71d92fce2e7a4ebd08c115b7a06e903f119b6ba812dcfd769441b8979130186a78a782a14905feea4eef60b5c228303ed01c772ca2b265bac568b0172b77641aa6daa2b4e440002ce0d1e94cf1677e5c115cefc41298617bcbfca32d591458c4dd92e5c1dec35a50aed95057bcd34e488b59e2580e2855885d0e5b7c349dcf4c43caa36d823e67334e7fdab2673dfa09bd26e68aac0cdfd7c01d4fc21aad6bd2ff13c76e541f8eee1318f97a3d554cbc051e69e6db7104bb0af16b12fd1fbf62346d2f54c706a566e288b57f4ceff3e9c0e3bbd6b925a4d729f8a46c5cd82239a4a65ad9253198bc9d629b806750f368ffae4b6eca79e614b31b8a8a3ab421dd61881c1bd7d67108d0c343b9ade1de8d23ef5482a142e19e4ae527dd0c7221265ee411756c1e6e350f338acb1d7a0aa695091cdbcb06895d7b35ab72d243d286dea9dec9f9ef9fceeb06ce1c80d2a98d193e754a125e434d1e6532278985aa6a95ee43d69b42067788b984f4121d8f68bd0cb09ea431bd7958bbc47e7dbe319852e7c682f9b3e68548c122c27680e591cc48e493fdb3754159b1725dbcb99a5896b52bde496105a645ae0627d7c8f2b071b85af874955a95a9ba5a52be9069fa7de868e7b945445c59f0f7e9f576883ad48a7f5a5a80200cc77fa1f64b08571cf4aac96b18c8b477d354546e11b47bb48a6195e3a53d376fce13516cdc990bc3e52a1dbb26d64f16a2df0959a6d83073e0261b9a274990bab894c547b6a3d1a0d3bd41c5dd139c8bd528cab790b8e26a544f8fae0a45a994b8dc8ecf8d219eb3242958c93a7b42732b941d757fd62837be7670db6a88e9bdb8698c8ea1593742d0bfb07ba16b7e50e93e601bd81019ed4122907ff661098d7b0b51dbd24f4ff53b90936041a7dd79b4a855a6d8d1ec4a5ee59da174924044d49d52d989968c7b18523c7e109ef756e8da6bdc09b1d2bc27248981bf4aa20ddf37aea581c25b3f4dbdf3cf31bd356c81931625931cc5fe9ecfb769ae9e6279fee7df961085282f1832009245e95a8ee29c6c598a3d5c8b7c515344de0f0bf8f11553372db38f304f7c7682b907ea4fb739072be45ee023eba776649cd3f87e8b8e35d3944f6c5af6af0196a546b465a03c8f0014e460f9ed57e6bf9e55d7405f13ac1362a7156492f277a05aa83c5399af7e628ea2e13c0e3a9fe03474648580e77e9ae007401abd066a322bf47c3ec25a118dc03dcddfa5713e051e4637a2e324202fe1c701540c4b67c28bf92dd84d7240fdf67350302a76b6e4a8b9157ff7f0706fb31f58c68305388fe6bc8bbe664c1c13129c6b18d626d8f780b9a9c5c5e742b85b2ade4fdea033d3341380e9736cb5ed232220ae4c4392b4ca917b13ca1e9166f9d0e2660d18e0f5eb13d9e86faf28cf609d66a56be24b26fe9530a4964415a38ea4980446756cd4aa734efc9f2fc8b5f2eeec63ca86acdfd70151c8c2c3b640910e6eeeacb1ae5a2708a5e72bcae9a0807b94993d7d080152f39430b59a14d07eb8a242bfa1b2899e1cfea2bbdb39cc5cb7f9cbf4444845cc4a3693114b614eb2ed67081b69d607ff9a1d39b48170564b15ff79d486de5761e2999c1868aefb8bef105e87570209eda2c0c417239809794b39ead98ccd5bbe28eee5c0f54d4d94e39aef9bc806f9b26932df92de9dc20f19c35bc33df5295286c57bdb0595d48fe437a9f1265e8299f6396150855c4db47a2fa8785915352fbd4a4601499e7b360fdc110bb662fd44ff9b153727a2284c1dea2ed996d5e3ce778c431346bd2bf00da7e34e7151395c60bfe41fe24636247b8f0f1d72a52722ef59998321c396945ba18b514a3cf282265a9bb7a2777d227fad63af8132a61486ba7878c859fced65dda09cc5663fe5781e91b5bc383a99faa70fec8b01fb0b5b7080e83f6cd316077050c9ef7d0820400185f61c9f9806fe68eb8ac34cdcc8fe5953a023b4e87cc268e9cee3529a9836c426058149f19e62c6e444062dff972d08df296389ce0fd16b847506282e9d68467638117e79503f99663367255e5c568623cdfc91999c9a9f46c7ddb9682f805d90a958c821bc7675d4185b7cf59b0fb039cdecefdf2fa5dd5b6b2ee6584e45f53d37b38adc332c35ffeb7653bb46f343a9474bf52336e224c0072f56012d66058597692ae5633c610de706352002f63fc3e30794dbd692c0c6790eb1dedf7616b76331075463eaaa2b376b295c61253c7bc62cb4805edd27abf62e1d902562f61b01fb3d6306dff196c4f270c807fdddc0e4302af3f320fbf2f46ab7a9f691c653d613f5c42219af97825b2c006a9bdb566e574afea1f1fbce96bd342f7ba2a6b0e212fe2fecec892d7436346555bcc3a3e2ab924357fc9342df83a4b69db626fec10295e2348973e0d8a1a9ae13a1c0528149509796afdc07372b9289df564c0dced659f380c30363d16b4b96085bdd72a6b683643b38b17f2b680d0f447e82f589a407584ce89cdeccaa8b90cceddf28560c5a6a2611710a713a80d1ec1d7bbbaa3d0af1d7f5d7663f3b5da8339e3dc51921e98e54d406a8849af2b3d67df71fb6af66fe89c5a9798e9e9f12088f85bbcf726bfd3f94076781c86d2a3667ff91d320fa9be11f05546e8af83dec7096f06b45c737be7a88450316f29ff38d68ef51fd6fe735822648a8be1b0e5401d421b743f6859c50810e51c120c5baac7c5e58c856f554a528a3f02e08ff53e2464e004d4310a19437c9fb73ca52324bc2cb1de3031c56d25870b066182280642846c56135a13e72cbed8d7bbf73cf1c4aa5fa810355a4f3351a6b6d8b7ea101ef357b178c0699c05de88f8bd59daf758eced509ddbbe402c2f774a2d67b274d2d20816d7d1535f5f5359ae17ee5b7018df42e512f20c6ad1a417a95aa5ec30b69325e71961f46573da2122fac03c11519d92520240e667a67d6a9e15a72a8d2a2f15dc729b93cc9bb1d8330a1e0040c24f42501c4ea92be8b780af7a4d0c2e7dc6272cd201b84afa311fe6059a70a7eb526f7fb750e9b1b7ca789f9581e2c48eb393da9895b88d47af53110bfc8671ce5f7da5ada1b6a9adfbccb9fb78e18e15073642cbdacb6bddcd690a9ba21f75b76fdf870764a1ea818b5d7dd1b03c39b17603245af6a86181f75f948284f40ad51b9a78fbd7dfdcc6a5fac515c9f070bb82c1b206930fd36ba01d7c628dd6975941deb76c615df46a39ea9d08707c72a7871add00b4609a6ddb5a20fac25e0df8c035306554c1e4baf1e24045de11452232e1bf166f4b91f844cd24bafb7d6e132e2832b1e6867164b166467c7a9329a838ae104cc3b5f4c791185c1235110033091334c0e9d8881d87ab23e14012696d514ec85057b3a09e310ba90fffb00c3da11acafd0788361b04389f428135cee0cd3d077152f5ecfa1ea1b80c53d516348a21129aeafac2b142e6461f33005139781dce109fc35a10d761c05eaf2f5a8cdf7a2b21715afb9a714f80a347ed768b9849c8aa304dbdca2d59c6be1dfee952de2ae418331f088e76fa939af5d2aeaca8907935913cfc0fde7ad5f76c7e19a73cf5d215f55214417eb0aea76f94f076cf6b01fe4a24b5fd9fa0fff49e41123707b7ee83ea26d2ab18de18d8aedf8390fb17b9e28b2ac79a415b9a93e7aad806e210facf9d08cd1dfaf3cd78653bf0fedc4a993e34e4edb5832ae16ed0cd968adc61cfd0631b27492ffa50c4b7e2498cfb222871cb18a515fb0c58bd74583083c0c635f999ab0895dac9d14d2512f3e039cf10d3408d5ddf7ce6e7a7c13ba707c5136a6d7f69522e4e26f4dc32c8e779edbee2bdb57eeaef747c6e7a5bc567da8cde22d047abca572534f53950d130c13cf61b9f493f356f9a23913ebfbbe51a114eea18f679a0370286c35dc34c0946b09143507a4dc546667ac38a4663682d424cf3a8907f9dc13aa1606e561f9df4952182dd7a61830e9e572824fa19bb74c8c555d1c9fd26fc9bd0102630a1f51994da2bd15a9426023c1cb3d1ad321b90c78a2a5f585ecb9b5610693c91b4a5ab034d8b0e31a533d6d12c8e7f8889c163c6cb9fe640c931a2d75a255535b614bb174ef9cb5981885473a3ad6f976b9e2e95b911f0870f4405d8c2c6d3c263f1a046d3548bcefbe871b032a85cf120de511f2165ef85d5f5f14211571035e7ea61f995e78ac356a5065cb0e741e56d14c5d834a6c0197417c8b2e32a06c0576f79c24377dabd0aaec9292defa4c8453f2485dc050e9730c6de20a3638a56d18c19eeef797f0b2dfe71c34539a70f01766cb4e46cd48baf1ebfb43b5627ef44ddbaa5e53355f1ac1eb93317aeeb2b333c6a2542c2cab6e0a1b4b1b6ddf2fab75e476d48297e26588d0a081fa12541c68598a8871473f5bced4ae968ea24ab384b42870a72fd2cc859647bf8b5b30ed568fee89bc4b87247599c7629b6300ba9cc766792ba0c3d424ae2f62a625fd44af3bd83b6e8c8838d58de31f81e5018dee6b81d26e5e378bec5b73405f4d887d3d815d8dfb26ecdef2240280c559e7a9cf2ea56292080c721c8a88fb2288a10f54073ac1911d17e931804a3ddbda44177432e82cb2964578384c8cb985131551bff2df7bf7bc2b08141a205cbd5b59563c0e2dfd66a4c2be6e1ff1afdc424cf67af9ede4a74798c0e892141df4a5a37df9016f3f658e2d969b9d65d73fe5203cdc36fae84d445b90b3ea7d940bd7d0a5951ed2338e9392577510bd75823c2dfef92d1d39ea9dea97a972bf57ffe76dbd76879c43f3ccecb87295b86266b5587a8e9fa704d530e8f785256f33ee903e502b8ad4c8774f1440d0f448e2872e5fcaf7881173ccdd855ba1b504884c1e57b5cdd84433d062a811a7c8d22531218b7ade0f1f67bd61028f35d483b2b0da38671be5f6f128b32b8a10d90f8695073c27fe38af8610cbc4a4034d9daac30996d431b429e57a38c9025d46e0c968765c65e41f2280ae0ae7d688230bffbeb8ddf1f35bae01a74a274e66c843fbf8f9def54269f7a3f5d23d667ac7758893f9868058e609f87cf175d8c4eff2c8a9965a51164132d83d8ecda94ec4c5f272813e12369d921e36cdac54d887b3ba2fc7487c2c4d8ede94365aa932982bed43eec9faec2adb44085b287736d09a69b1a12531dfb21841ef6ebf4830ac9c9b174b1580bd93633bb26d15166e33700ab37d0ea143ae5afc0df7531b5f1376dac887f7b557a694453c2e976aa7938a019f4c31e73282d90665afd488f06d68adf22236da3b8b3e108de232a6fdbf63b26f0a931294bcc7f62b08f01175c0b598573d67c82ddc7fd3fa461bc07e3849c73f1dfb1736411cdc5a083082cef895657a2b978676187d276f4c5d0f07878ea8e840fabee089296cc3bebd3eda9ada2b07bb149db231a57dc197ed563a6a3c9751aaad43077cad95be8510b5961e38a94503020fc3b1f390c20d6f1ced518af1474c43499f247087f1374ae0ed1026bffd30a50f3be486bd09e1b452c6c7ef8252bdf82f04b3fbe4767ba75658143f0e074c585c4c50fdf45ea8d293972e3957ae9e7aab49f315ca767b5d4a98c021e1247a133a1466c2a646270651dac8f7be8fed688ac605b9ac301b4cc5519ce997ae80d1f75192eac072eebf28db9180c9feb422a9889f892ea8804f453fdf4d2afc1a627685036b219f851e59dda52bdf98d94321ea5f41279717489454adcd09f4209186393242084a5cbe9b2a2cec412fd9200e532a7157919fa2d903381329839769fee9bb0cda683c1f62d1864d456d0c1b2e9b14e9282bfca03516704639a1bfbcf560c7e9319c3c343c9cda9b7f74c97bd1fee2ecbdd81ec5e0667147d164848c6234ce0d20f5c2e7973f57388462822154dc2cfcdbd0ffcf377b106e3a2e4eaca47f1bbd5e3dd3af297717bc5b6d1a23285df9cad6f05825330f731f192087f9e95f2fbb5e50f22ff7397a6fc051707089d2a11ce5375eb0dd321b8fce9039b348e9146d9183042c4ed442d4f33e70ca4819947bdb542862a3925d2ca0121695d13c65c11d9f4e00593dbdfa0c3fe26ec68f8bc7b2d64f536d8ea344fb6c199406f63edd1683707d09f51d0018d716f4dfb99b6722ff46f90c8899cb93a8531e525776c77dc0ee78229274e3e2477b0f21df8b54376417711ae38810aaf13f9764dd3cff2c3c3c3b46774ccf596506c38f574ec8e702df8e0cbbcb68a70613bbf5ef8db9b4297b6b455747cd1b403c74338dd64a4fdb28e6fb2c7088564b25b382b7653dbbf6e9eae5713f22693396ab3e32d0b924aa000a4bdcc883ce4068e8adfe60b45c751207756fb8eccb96de7af5894fc304932efc9df75d238cc46e0f82d84d3d93079190fcf99f5a6a0510cb76de579bd9930f4d016fbdaf2486869dfe83cf669ceed51c3e114818bcc71edefc550ed338815ac920e2ef1849cc87a771296478069522d90e6923718f18d35db688e834634a3b05586e67bd5258075a02f36f04181431d056e3d543f73197880542294df6669846f0f14aafdb1f5c09ec2dfe968cfd0c0a8b30e2cde7fbf50fe3665125298aab65931f2fe22bbc3a3e0a0cc88448d73d65782be01d342e626e60746729f01e6a9bc71ca1ff28a51c1afb08f6b494a6ecaf628c2ddb003ce5854ee3545fb36f1ea7811f23931d1a9b1ad0fe9bbee377039ca3031b4750114246b08f2d6fdb1e6d8d44740ec9197f16ba06a01cb3bc8e68e4995aaf39d01c0283c31408c8b31b3131e8551966fe5e4865c3bd3b2fd4335a6c7c95f3f004989c9a21f25a08f13be3594745d2190599ecb52be9f7507cb7cb5ae7ecf45b44b7807d4a8f4b88fcd5466ba4e3b20e2e298491fc4bd30ed7348e5d6440852dea9b301e8222030a473a1e6ed9dc5852c0bc3b3b31fddca0b3d6b53f1d8aed27bfaf075e76df7bce278b345bc3b8708a47384bbf0f82f2b56dd50fb07aa570233ccecba87e1655a5268b36626a325b0b8afc797fb3696c98cca9616216601e9ed96201c6091945d87412906d934fe81be56aea33c22e99a951ed96da9f12614dbe7f4f6b94ea2a0107695bef7680af37d5624d1cc77616c14a1c2b8a647414c74dc69d6f200db19ffd983c8f1ae42ab3d92238bf6e71c628cfbbc23a9fc5ab0381f08b8ca2574d97a43e0825ed68c2fe82c99ce42a9328a5b9ebf0659fe7e619d9f23c3cc6c50188ff21e816b45c925916314c9bd9b39802510ab29bdac8ba6d70a536baac7c1eb82991d649ee76dffe4900f808dfcdb2daca9aa2263b9a05a191812bfc6516c7317e83d3bf7a9a744757a70918bda624a3b71424cf1132fd19f35e98b5962163ab59ccf0032566227618312eb87e92e5ef9842dc381410322b1b9e370769ce40715ca1d664f3a8815b329e8f741a7bc04645691c76923c676c559162440fb9319b07b0027d1023b252791a6723d982ff3ea49c96d8d360aafc300c082ae7e8e3a3cc83c55662bf7e64efcf16bd783ff8d7d711eaf56b7de40517101a115d994b0bf9f7585fbbe6a4d6b4c60517f7ad25052394317c12467c490ae06277ce7a63ea909e87a79a14b8df927eb21cd3b86f516db3952500e496c040232f334efe89ca02fc47ee6f922301a3482684ec6badfbe2252d111e30bd5a778b65344c05fa22ed943364ba18f8764bedb5da106df2e70f524756e3141eee680a97b98f32687eff2f7d650f577b2783e45fe3583f3cce44f019ef1b82b33a0fd197b52a9312600b302adfa825a4f2d7d28400f963fac22b9f1bcffffe5df2aa9b70682d21d8b45cc0c391d397b89fff604673527b4a14b13c9c3095e19b9e37c46704b560b4787fc73bcf013ad5f2f8507212d706063dfd6a502b4b7021718e707b3cb6e7669c9cda2da4ee72c135ae5ae98c880c1bffe4035275ee487785b2f23b23096f2401cd340206da02671150c9ea97aef07aaadf8d2f3dacdf6e0c19d9947782548053dd2011cb3e0aa916f343f5830f536eece8ff19b9db62fb022e6483ab22413a41d22fa78bf9e1f78047ddabb33991566af1e2883498617c3210d697e77df903a68a2808bfc60f2ef8face5c1c815fca00e54b8c122f4c7b95e5042a6a9aa39022cbac9ff9c0ff158cd9709c29d3f9be8a2cb5e746ec2c35b96348becbeddc8b3740bacf457a29ede61b594e1af1b1aebf022da8c4518fd6b5887b935f6bf2133cb6d42d7268cdb171e4815886ef8b4d980003adb7e3ce9317ed5dc7d6a5cd8eabc3abf6a3f6ed00ad59d9e6fec82741d802418fd360df6bd3cf03ad791629cf42b244f5c658d10a1259b4bd703944654ea060f44d522f3e8764b4c8e2feafc3d781348108b5bf25d3d7c1c240832144f85ee52e3c55a0384fa78a59ac133469c49d400b002ae3c9f49e7d10330428c07abee498980b806e1a5fa71f3f2423b0490bacf7c640cfa44eb3536048dab103879393afa6130d0a95d7f69e66172467772fe5fe43686682b36ca425a583e462fba6a177a6c291735d68be47b6b609ef6b0761d16dced2ba97ce6ac4dc5b2ddebaa942b5f6c19069169ceeb371ad952a94efc24681b88d82ae6b22d777cb49e2b57800a3dd5acb4d6b791087e98d09dbbc454e7600ddc4a7b27e272a5a6e55f6d320ede988fa57e0e20fe6c6beae359c9abcf9fde376d65d79e4eea3937e592aa8c40405f70b90d5519be23477bd0d2e93e535c329420bc7fb382f88ca600f6739ed1c2d7823f8073b58beded1c5e0f2bea78b73ac75ff68a12d32aee2ffcfc8e2bfc6a0d26c542dcc201be7900c6235ff2ae76a1600123d1907bea0f89260182c7a928adcff4deea944764a2e2ac0cf57f29c2e7934ec4c70cb264a850d005f89de5521936444c057a2a9e14120a80d964a854fe4a913f6247eff1956fd9dc2352df5a6a3a2444a4270b971b1a1c16ace91d05c137f9d420d0001d44b0f4445136ab07aaa852042ac6ccb958296634cf17786628b87c030217c13d0720a8fc6e608c19e289fccb9259d22448331c653a1b43590e099a88ea0ade45ef35194c9cd442183cf0375d0b6b8e40bafd2c5fb6404bbe4c18f18a2b75db3279b73609ea8698820c07834130a4f8b2150bf982fb867cf87df6d442fe915ba222f62141d778e367ec29366c412adffd4464c68204da0d07720431f5a2678bcd03dce85a708b92d5a130a72be79ecbeef2dd6ac825d714fd4094a9a3f81aa2b8ae35ad107b3a687b68087abc42809e143b565c0188e5339a541960bbbc27206d0f9ce3ad7037d2353f760de9ba9d0142a766ad1a74773b5939193d9a8c521658cba40ff019a256885975e0e61c4059d247578d8a80b774276ab90702cc1e869a6f7b03c9534eb742e3abad8adb8026d36d9edd5f59fdd416bfe6d54a757ff552dc4e5d406cb479327cd55144ec710b252abb535509e9bb2f7c7054af50bc2e71cca0a78b551e6c56da1d471bc61144226feb81113f260c4116ff35ffd36eb228e51cdfa6efd99c4b8dbfa2659289c3e050d58b22eafa13e831878534a6ed5548392ce75cece82be3a43d1bba2ed011499d86482cc565b9d07aa5e7e6d0b09eed53bf7ff56506c4fafecce34cb098d06b68f6a8d69c994ebee7d205a26b56f235eb4b1016908784d572476eabccf6b88139126d3b4940c1bb9626dbe6030652a3be027f811b61a9bd91f445fcfb4088f92abf6888a8de720eb89cccd0a3ef0b2a2d65c64619adb6337fadec07e3aea5aca9ba04ec83ca81c7d6303e3e1b745317b3c3374e5e7e0931c81867b563fe101594f92725f027eb245f3538a4bb2d3b614ca7b859171fea11b04413b2a4139a57b5b93696209b2329328f5fd1fe1d3702cc3cfd3fd571585bc23794a7e9cfca4613e3cc632c1d27cdd6061f739c3d604d29ecdef5dc771a46aa27f995512f20d94a77fa7dd0454a3c40f3214638050bac7b85cf1ff691723512e5bd63289936ac6efaf287d677ba3a302a911b528f46d0e742366c639b950824bb073ed0b0f017a3fc0a0d3870ec1bf98728066c61bb81e64a1c113f4fa0d1f4aa722e192b248ad911283c4e3a88b22a71430dbfa8b18668c2a7f74c46708c9ae2b9dfcc069187937bb8283926b45bf1bd24d8b509a9b4f95ca0cfb2b6433a12df625ca222ba6f86392199530e28270fa196bc3ec1c2c2741b0217cad44e4a82f055ec7d925e78445445356ecaa9b54108ba20299e6833021f3635ff3f2c8361d6f5c7e86df256601a3551d1c34a303327c2ba68bd214b1fd350b56d4f06a32ef8a021cdd06715e9a6b0156b49d3876ddb5e17091035edec21e1806794102ecb7e3e371194999884781f09c8bf4f1c9fe0287d7238ad285b802650fadd077ce6ef78b134ae831a92b297bb4a5081965ee2393996fbd261a49b93dccdab1630f3083f84a1ac8a60f4171139e0a5baee2ab1c4dd88af36231ccb4db6a2db965fb32cf11ffbb156b9e93b27a49df602806f39eb5cb9d375234058fb2c5778aa6565aa050f4c56b89a5cefe8216dd1fbc5868ac681000cba35210723585d937c977ddd1d96537381e2cd900239ef704907f09e89720082befa15874d24e03f5da293612df66edeb7760986bb8c00a6a888c5f4297c108d3b430e64bed652fe9b015082bacc7f960f35a5ba5ba565b49803501e82c477b0db80c3e42e60369e027a524b59f202a8cae290703e1bbbdc1a25adb7a885e96084a1f92d5fb88d37d1079fc8db8fca5428d4daeeee057d1f424a068aff101b0d8966b30f3ed26830bf298d02049e92ae6e7f65040fb04cb7747e65b24744999b46c851a4226a3b51c3f9010c46ffaf5b5c3bd9b593db569e802ddfad43b17a2ccf5cf7f811bea9bfd2b1cf20593d4d442d35253a8af29e01ef452cbd5c4fb356a8b5b184845cf219ef461f1119ea083901768b44f02ef19f17f6534fd702dbbd9ddfab199777ca4b884ad176bdfeaf63ea9c3f92149781cac48fec4a48f26ef571ea09a8cad18e1d05422452a38abb7f126985f5b19f77e1fb0807ccc54f179436b5385434451fb4780a2fedfa9229302e07b49f1dba0ce0e8f2a336ddbd6df3023a23d7e0946cee7d95c979eb7e5d5ea8940411f4fe45b01d71189fe23bf98581697fde41a264f97d3f0ae3b7a3f3e4e2b051eeb30bbeff45a0a4424bf4e962de7bbbcf69582a9e80fe4b6a527897451f662794cb4452e1426675151515a5cb7a8adc93548fb90b0e50697a12480d4d7cf684ee0f19e3f7654ea87ac081530cdce52361a6286d365e260a758dcb9d0b6e37cc738c03b8dc6d2204982611aa3c120d1931c7179834a1d8bb51b1c35250d3eae3579ead1d55af2d7e159c8b1af4e1508b882eab48556910207d4e17f34abadf15d3a86af65d54b118c26ea4130f3fb22215498da9b755d20c72d79401cce50cb07500c414929c07d1f75b319626a6dac46469c1ad3ce13c72da97cb69ff941635560120be01932035ce16a2a7e9e2067d917da0289a3b39ec31f724762ff313a0346c92d38f8543c037dfc7a0f3d18e9ef6746197b1cf1aed665873bbaee59c705c8ee544ecc6bd48723d8bd5da59d19cd33e7d96187d598db037ee2c653e42009915a8caca7ab2c5535095bae0b4faf1c0fb9943824308935d317062f2ed806ef7384412e910f9e457370e1f3cb550525cdb886e3364c3ca2c342e78c0f92a721ccc4e565125df86fb29b7d1e0a3cb5858e3df7e25285cb04899dd625e7c26d36e9ee28bfa7bd9832a312491a6e090468ba156aa72b717a7e12d4e2d81c19551b1dfe844a21dc455cc81ecf441195df557710efeffaa19bb50b0a6d05f030d5a09f8895ee0602c4485920b445a58407684094b322a4c11e04f449f517fded4f827fc1a540cc5f75ee24a25a589e51be82100bb6c242fbc855da563fe6503d61b60ec7bb330e5318f9c3afb168fcc621c3930c938b93992432f7825761c7894d2c2dc7c2832a0ce135b20e56d3449a5927999404542b8043a2216bdef75bd729c45566c1fb96a07a388febdac5ce55bad2d654db3c8dafb6bb5e8ec92abf025066fe269fd55daa868feea8b30617f3d2d607849c395c8826b23cba3092526db547b212b385dcf15fa280ac73c48573d99dc803d11245b57fd1954f0c786e44c99d6fb97a717675704b66d542f1a2946e11a81127f973c939fd8484b2f581883e990b676b63c7809674424b44d75662b982c35855641ebf76a884816eb27c2f3c074c75e8775f3e1f1a5abddb2c80b02cb78d5321c9a28c86a0ce780892f414d37704b36b743f48df26e2c3ded1d0109ae79d8ab6a1159f9661d0d4f797aba3e9201f48a3de8a0df3437511e7a4c36bdceb36fb648d498e63bfee8d1dd4d4142e9ade098fbf07e89ff07c95007ba640fcf05fbe9b33256128cba0ac634fbea74ee32c6350c5b64d57f9aa1b551b95ef6e642d38ed65367c8a2c03f3efd7d42e0e5afc53ab4bdf76d1884518eb1a873088379251044ef13d3caae8b508fb242c96d32d19509cd2179d8bdf624d0e4cfde5c8c538d9f6033cfaa8b719da2b105ec50ee4224d2c49760b994fc7ebfd7892dac10c482babf202d1618faaae26f1ef791b68ada94afa36e8f0e417d874575cb3177d69efc48b1f5e2e24e2e6c8695250716b707d462e915a2fce18e09b37c7bf6c3177bdcaa76c5449b4db34cdcc61ec823028cfcce08740baefba2cdd7d3b81312ce214e93eba2a4c4581b85224a5e1f4a5e5a739d0c67a720389cc44ceba9db71087d9bbb4718d0679502c8bbf3ce4c42fea3f6f87e844a5770d2fec3a43c0169a9ae4e787f7e5b54275705dcacd54431331c50ef5859c0b896ce6c3c72a201bcd11eabac6cdcee9d227751d5396cb195c163b46e13ae126248e00906609fb8c3a11e1fe1271588cf8bd25b734e3ca627b985848597908c508457835a2d73fc2de8b636d7c38ea05801032f73fb0174231789e1f0d1741a8f4dfca9e1dfddf83215c8adc84a742e9ecece468335bd3faba756891e41190390ec48854411da5257ff76a16c48e680745ab4145895fc148815407351cc2cb09fe32c00bb9aeba9a74fc5209feb04437e00145083fc5bdae1ee56e8df884a8af64d4af49312264052962ff17d7c111a211c625016c8718d066b497abcccc300e4bf53b192c4571fd539a0ec8ac8a8b6189fdf90b42c77e4e7f3257d860cfa27ced6d4fb32e1748535c894a6245deba09fc59af9546039c33f1eae4081dac03ad29e6528fcd2891455fefb1d05a92c43caed051cc1c343c3d48c34872d702ce098d7419715e9bd029d2ba165e3e103f1fa0f3080d8af9c9fa5e2c0e87f140a897f65a35af4aad6095644df008ec39459e80bd29480a549036ae37c8fdc667567e30a5859df7f256af96a5805e0b99da40f3f266438ae891024cdced9273b7356a1fcad88bae1e8d20d07a4df796e527092843d979cf3293304680d66738265de72c30f4a999f3455d8cd08c0e14657dc76dba1a8bfff549fa0aa944c0fe35d5d2ba0efabbac2a4b6a3b4cd303a805d6fa60340bfb8de983ff63aaf0283a6ad1ecdb02f1641f9b6d275514fc5540a21937856a2c30be8059dc958f07800a5d1f6284c47a6637237e474aee4ce8c526e9b67b1b53b40d602b3b8124a3b64951614b8596624c8b994051d5fadd129db277c6f11d0d012dbb56d82305c17d209177cd92c969d7f639ec037b439c7a27f5e695f28cd3dc3fc8e0a47fde0f46db5c62a7f383d7a2591b89145457c3686a26725141ba4c48e5f3ff30cf952a82b1dc0dab44a2083a70bf1a2ad01090853b375516b099b192ec472318bf6d6c194aedb0861e72c07a9afd9e6640f9a469faefad7c48caf2671d0f08a4ed31637faf65a0877da5aa43f7699575c117af6dff32a6990d65f5096ce39ef8619c5c50cf6e7ef463af3dce27558014eedbba516f28f051063944cbbd79a2b177d23610a17ef2343b59a5e938507b5d420f919c52e9b4d9bdae27ff0a768ee01f973dc97f5859a27ed17e34770cecb2ddd9e848cc2ecbb74670ef9b443adc81a0d011be276aaa5fa76aa033082a2ac33b445f4009ddbbd13eae7c98cbed1babc80aaf661ebd4f62ec5b94452dfa5eef3d5d9bb78fabc90e472fef4170cafe500c07bea4d3120669dd401f030dc5a6dd91267da5baaa39a3e4d42864b8ddd7238118233d10e465946496722ee0b082921ac9444f64e36739fe8460bcc9a763ee489168eec3d98ec600a325bf567c3e6fdf0ca2de0b169744aa06c564ae2c88ad80c395b9378086446eaf8dc273b1398bdb2843a749ca571b455403c2e9a9154bae9e1dd4be80e5ec2e2d1fc15fe334a68c419039c7ea5ce36738da8276ba2c4f2b2c76f5cff80d28828d0d4881a47183b6da59a47a445965cb8979321b7055389463d473ee4fa3015ed412362960f719e7e9220a4c02eec35036c054087826d6077acaafc74d2731850dce82733e78661a95e6ff64f8b9d6eb0fda6b69643baa2db0daf5dc5c449165ee1592a985d0d6daa440f678a99c3b16b2676085d3620257dcbcc4dc076d788cffd3e8f0ff56bbc0c643ad78eb58e05754793289d5381c7225f97c7147dd5a7f140fd450e82b2e1000f6b7d18f654e1018f79de198714e8987d3c6f9963704f967e0f290abaff49027d7ec0f1cebb11c567d0c9df274885095a8e9b410d43bda85fece3b09d2084141a34602269c00ccde78bc3a3448504707f1914e029f262f647c8dd984c711a80618ed542ea8b7690936b03481d1eb3bb112ef8cccb4a9c3a826f4da94d7548dcdc0aa7ce4ed9087738a2d90a9ac3b530006332f0ecfce00af9d7fe4260b501723c57e02607fe73ed2c030a12a4cb1fc4cacfab749da5f31a5ca35221fe51ae3d771ab270e279ad8dd32be4104d9ae82c371f6c0aaf5fd2b5570aa952819089e997ffea8f6d2381bac162a29a97df76b674087c29d7422c2c6b9c74c6703b1149bf0103696fe99f4fd701b7f7b320d81eb5fbdb9c863817b2bee36340fb180e86c3cfaafb582e52c5e37c5416c1a48acda8f71264a1d68dd827037227b92c4a7b53ed05cff01cfe5db7cac4e2ba4f9c805ec36731407dad0d789ca6bd8d88751a10c4ede6d14504aa8112806ad2df322381927bffb688ab447a844ed702b2f842fda1eb9e757b9618dd418ba3b678f63955a8782ab61b84db870fbe064fb6d4af305df5108a460c3d41bba8d4607c6b37139a5c7d13795e141d4a0a51a8ef71703727f516d87e407326d918f34c6d09d523adb0721c1e31e301e4e9ae23ad330701fbb46247593690e02a391c4769c21db31d92ecc72dce7e0fdb280d6cc792901a04b021c079bf51947703b2c553cadf69d0c5c1005f9caa401bbd845ce176ab94fade02fac27bf207173ea2ab4a5dea10e377818d2360d44a5ad116bd345653f6285ca844c197c52bc785e61d2a1ada7b5779f0e6b1620c6203bf317041d2143ba5857ab14acd100acc05b240c8edcd23a60bcb6bc5a6e17e2b327379c3c68452e93d4c5aea295ed3ddc8582e761134c5f0b86b2d63cb082cc6c2218ade95f67804f0367fb54b56a54d1b6fe8ecc0940c971da9884a433951babf1fac2afe699765fd15dc2713cb00e9027c3d1ed6e9a296ad311c935daabe651856973ebed39f4a4ea2b80412a9daac52bd1fedc24331ec5cd4ef44f7ca165ea4d4ce4bec68ae7d1c0119a02b3d8896fc98089bd7d38aadd2c728045b8fea16159ec348cd65f2015d549fa7e17db7b1e36d32a0685edcddeee4fd10713fe6f36378776dd3125fca939f92ef0502d793ade1dc2e8c31cdaed5467f94e8b88acfbc5d2fa94965650717f908262e71512a1fe56c95ef140d04aaa156226817c9beca0aa86b45fae1d40e3413087aabf6e7a1db64492742869a9c1001cad773ba38b2806bd397d6e882dfd8c5eb68fc957c7eeb2a89cf4c61d4d5e2a2a397b5228fe5f5865c8ae3b26fece4e90b13e08e4351df817ab10b6f62a8723b66de6eeb8a0411228bba59e58237ab078f260c0cec388d3ce83cb9f5350324fb9fb597a4d73a7aa99d6084feeb3e4b9508b1d3cfd43c7a7b96db560f332e0e068a29a5acdd779be4301291c35d9c49cc9ebbfd93ffc5c43a43888d774ec0f2b2a296c6da35c5d90db8ea174cb9118f59119b33fa58917a4c86c6a4c258bede923c8aed0b3a5c6b6059d22e993d2ca15fd903e4289aa1a331dd287e1d04cd7d4882dcd44e65c111ac40ff2991eccae4c410cb65306539f87b6c0c1a2986a891d4dfe9644e7ccfa58d5af0e387c832c5346e8ad848c7ae379a9a7b3581af6e060e9eeeeb800b5f2fc5dc417857ca4a18f22a224122d17ef2cbf22d1f10625c6da14ff8a2928d82cea6e5e6d270f2b5c4ff2e71d594baaf42ce3c62acca56dd792c1eee36f1e9b95ffdd987b223f6af12ecef5281d460298965d0b183288aff7087b016adb63f0e6e877ba659931c3fa4d9af6d77c6b6fa12aa955a3c3a531a52013b72e3d8f07b65639035b47c03f8b3ba4411049f7da545f1c608485b5204555c90954d2e3cc26c05e11ce77e8222c900559c59491e07cdf536a355f2ce85fc624da1022da054340b3a418032714dea35ec88b281b71eb1c54cf264e0ec64890614b60d962699d1b5d51d02b275ce462d4e643fc725c583d6892e6080ebdd82b862a2a28e7193df0aefa4422a9467082f5b4939779bba7e6cb072ac901f77d24b62a14113a822eeabddd59a3e660ad16f33e68aaf4e8511c1645c258e9b3537168202f9a19d04716d9e363af24217f16e7faa4a94212d2e3657790825b585238e5aa888220e9947fdf0af0f049fc0677754ed69a3df08c89bbcf68542eb6ca30f5b516f56bd6f29c597f9b495b3b44368ff29738e0a1a0d6269816ca0185e03200533a888e317b512f40ea32a9edee9c48b8d286e201416f1f27fb615dfd2a096709b4706e2b819d2a84145fbc11119434d7ccf203f3fce484a9836cdf468a18c92ad6d897a1ab736e80a55745c45d23b0fd737433a4b032bce253fded0bc39a9e0e614d187e75dd915e6861a0cb4d01d06633843100bd908aea2e23de90177721360800dc4567151bcab101d4b953990aae632db5e40d906957d49d0cbd936c10038beb057126369a04688006fd0f7c4ee83","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
