<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cefefaddec529931f40c3bfc1be3a40381c3eac6135d6a87716e293a308ea3073727a3e9ca621f40bb8f12fd5e54f60e7529818fe79dee33ace707fb7f8a0573ab26fe04483f60f2d2087128c9a860ae0599ed1c763c79231f61d53b888d5bd4c34324d247844f3f803567b2f88c005722a068d7dc65bf402b9ad5b4c038e1ddd7439f8731d480e554ad5705345a29347488900790ad83d503dac46f280a0701d5d0ea4e33e6f8ad95cfaccefa38bd2a61f173d165523d9896ba6a252a9621080b0569aff28e09c9f4a0ba1b57ee8b1d111a83fbf68e4bcdcae902ba789307298cc90638050933252908c6b09c7870a10ebc9b4dcd845e93e56b960c047a66212a8694a46204f00aab3921d21a000b6f3a74cfd1ea207bb92554dc89be577907efe5fb707c24ecd6581675fcb3ae76753e29cb5e1b46bd9eaf9e45cc4c6ec5aaf900d60b6e25e47bd9adb3418bb1e89aa6235774a778ea1b47e0e1a83f46ea73afc40e2ae91e5266505f42003d7e90b7b165091f741d5bc6fee7efabfc00b9c885f73d9e6d6cd75517c96c689b20f4ca5ddb8bd90bfdec2e99c427ba42db828e51dcf772e08aa4e90b87f4b360f2b9a4a2d24fcf5a43f242bc2bfe0336ab92c71b6ec295874899d7a5b296875c03313236d770bd32c75548370c2fda3cdae2422f5531d4ab8ff806eb5c2931e5847a6c801d83bc882a67cd0d5a629aff10242195e266a040dc2a2248f280930558f8c66f832e44d28f7c3903622cffde64d112abaa0836feb7d53ebb2725fe1baaff2cbb587380ae81bb5e63c3fd63103b6e28b616b8094fa6e003743206150cbd0dcc7baa18daf3f498944b498f5c9def00824284d26fe06bf89b2e3285deca28eba409fd7a6fd64876d998f57a2e80b6d674680af76cbccd65f262aedf6b8d50dedb26b2ea40a18f357b252e558e0f4daddb94d9fb2c9e768fd84a6a748790eeb935a34c19a6f60cdebb913130aafc3762a8d1705cd058b6ad5cd91e046b85c526a3065b0f26a22bcb4f3aacd24d658229a7435061e0935c0ac6234b8a4cc92f784fc1e0256cf151a1e33f3b8fce89bc026b91f45ce69766ff857db095a46da1b4b073809e3e23af38c340091304f946a79c51e17b8298df2edcc0b2e1e1fd5e9317faf197956bdefa2a1072865311104078f284f62996844c7de6c0f819cc3f2f2a5c32f065653055eb8f215c2923782a29c31f29d2b29be3350f88a896084abddac0c394c0481c21544d956212485ba564c52a71ceb416142e3528463ddf135c8554f18043feb9ed1805511bade8d27e8356d0293b089606cbac0be7f96000c582a5567a2f2935249ca512cfd2e74fe98e1d6a910a0ee0d629b7246e8fd13d750638fa367e709bb0503118697a876825d4982908f303fce1be6df8c468d09ef2e68e797eae74ec9220b54ba75b6987dbf2a2256518a8783ecb941c493501d973dd349e2ddf6fefa4014d7dd8896352666ad32580d5a648a7e90e9c01c6799f03f59f27f7f70f15afdf42a8c6dabce2732db6e9635fc56c414299c0752b05a1fd78434c38fd6f1628b32ca14d164ecfcb44dbd56dbd969bdfe958a2b2e535ef2c785f6834d991dc0dc38951550ee569b3d855f66293e59407e3cb4a017b6fd7931326eb491a101bd3d0a964e41f6d535eb2d5d126f6f6dd3f750babcdf5fe6f9c0b3debf8ff1c9cfee05640008a373a84d5bb6f01296b51b979b709ca8295aa8f5d278326743d473f7022ac441f1919448f63df5470a3676fd40c8392a439c62fe9ad24a3b8df6d76da9293b601cf81f7cd7216e7ba7a9f62035811a1e9b276db903fb281653b632ac6148f46de5c48918754e2dd2170eff1d7d0c61c4fef798f76882777d8ff2a4aaada1c7a0c9ee627e5047b6e5ab1e99c616cda72153642658313637edbd6c63173556f83224192cb3217c35b2b639f9e86ceeaf64936d05f6f96e566173d964751763ba0186b995d2b2a7f8e6edd0c9f01bbe252f21006cca45311a95c6dd1cc01129975452e2077a8623cd3249c5b01a3f70463529a91f69d6bad03efb667af27d5a934777bec5cd96e6f0b869e31b6ec03add21094ac36db8667f18eb8ca994f3dc31d4ef991ca9e017f859ef0b68c00e83ce78d7b6bd6b4101419a3102b6046a5a21093f88644461bb68a5ef8152a1b97b2154fe7f2cb4eb34f71e65fc09494ed03ac4f212f913ee44ddb8f7a7f8add6d342e98dbbb60729d707ffd08a9c0c57acbec27bab2b9f8e4adabcc47ff0632b72c91b5184f2bb4f5ca0bfaa9bd5b4a75d670de1368b3f63282f42d5710d722a491f6e6a67e6e9b961dadc68da9ecb8da927f4fc51ac80cf264843f0d34e26e5643f8f21e2b3047fca35c0c0d063ffbbebe2ff9a3e79b432483fe35f456ba65019b3581c5c637b38f8f20ccc7fcf0a11bc0ff44f49fd24922c7c6c2c3c58077c2b78c0a0fa9085db5038f5b4c2790461a6cfd9ea326b8fcf54822e93ecfa671ba8e23b17174627afd21dbf6bdcf4975ab7e1ce288977dcb91dd5c8ec40a44a9e5ac72499952ca3b7664db874ffb13d2e2cece1b4efcf5337dd84a49d2ba717c3f59979b51d3076693e265adc6b519cf641b9749d338ea3431c7723b9a02e4e45265f469dd91e626b1708d4dfe5f64144a8ca44f4cc8df092930a34da774d122af395c6ca52a52c473313e604e73c2d6694e1e4424e70357ebae37ec7e105a61f123ad8801bc7c35fee59eedff105c73bbe4bb7c3d072263f52b67b00c3b263fb620c6de1a6b8c9de8a09466e7053e98bafe12b42e82fc9d95dd148f6ee9037d2f02600f64f2a74ce05036888a40d78d400ee554c8e4aeb8ac698ef82e130f6f2b947d82d584cec07baff395112f8b57b726abef9c6ae158e5554406ed7fcd03782f2b40e43e92419bf75b7c62be7918962497a7e4e9e55dd7d383f8d04fb9bd100f241da7c716502a8e18ba9110bc783a56d71cee58c1da219e2a8fda0aa3d24597a22759e342112a72d5dcbb1ea75e21f1223202e8d3ceffc62e61e3da97166321b899146fdda3f0114772a38d8531e7a113900a49242abda46489a4a4e09deaeab106bdc8bbaedc1e4abbc2339df718823f55adcfc700f5f8bf656e4d4e41fbee0fb83e1754bb78370c1bf931397d9918bec5e59ea2da8b578eb41c72fdff163e58b5685ea557f6b41bcf26dfab0789d1ce0b9dde9cea9291a984fab8e3057471294c6570e17821fb3d54e02760ce20399707b2c55e7236584ab8587ad35eaf90442087d6fe5ce45fafb32c78aaa7b82f0396c2763cd7ccb79c740d996f2867cd25000df4bc7974840780f429320026b4db72bed0ddd47bbf14682571216512d6a34857fdb38f9eda648c4b2198c995e46d53d1d0d4f6513f8722d8ccd7081c154781b47b190334b98ece2959b4653d8564e8b81dbe4c7bd4b401f2c083a9de59a8670224bc13089832556443bae20dd778c834a70d6a2b65d92224963a297107b576fd914d1c8dfc981fbf60d837a4e1680979714d13d6bbf11eb7da31eb19b95858d401651097519e6b6c7799d3e31ae4505399a61b2e665b9f31eddd108cf3fff8dda1246ca41f132e67e204df0885c2d7ab0484b59806ecd6b92cd45b9abd2126e78ab1ccc638d6ab691180d4e48038b1012af3ed5df682170b17a030f4beb936074d8423f482459b87c742b68232ab4e2fd3813d35beb9549fbfb3d541c42fd05327e3bda135495d085a86dbc4ab04c0c43b83b0472507f64c6ef593f118a546bf59f7098165598d179ef19c5074a0d9bce1ac06c7de5e66ec57f703730cc2b8e36e19c02b6dc701cf6f5d039aa8b06e2506467ce4f9abe1f7c429dc1737cc48dcf24d9d520c17c9b0916b01f5ff62effbd3c5e33ad06bb66e5058f262e04907e15ffc49eb2320209fa66f02ffcb4b38cf411ca0cc215ac5af96fad2293171cef61f09d23e08c93d6f4a637b65de466674cd8e5ad4cab66461950339a40e041ff58775c20012bcac4201d1fc07f159b03bc0b325e7b249a911ef5bee4a94e8cacc3488fb4bfbbf46eb2ccbea87c4365b105c5cf387507ff337d5bd19c6872b3f61232e2f56643dd376d5f53d238885316e98ffee117736d4667cbd62451e5cbb05128706634a76acf14350956dda729c36d96fc00c0db024a6f9989e5f2dffa7c3d9fb29dae38dded50ee9661d33a8697f1c9c797ddff2dc79cb0662af5175dc51509b4b22b0c67690a33e968f1097347bedd6521e3e23a3e7baecfbb360e4f43ef488abafd30b3d7123e02dd0eddb05350277dfb40390fbd069f20062295b63f0a59cfd2e134212ab76314fe7b4c73c42c368caaf6a4deaab074078e24afd4543e9777075b03b832cdb51b33a0279a550e567beffd613656812d68eea8e21fd755a60f09156d6613d3aded2ccf56c09d8565bf72a878805f3e50954f9b11ef8586f2acb311f299092ade27fd59026ab6de9c48d7791e2cce14a8518aea9536c5ee4806a6686251417fd607dfb1323135a9e20f9292c6b0e2cede6a8f2c472b9112b37693eadcfba7b55d6a262b0cccd480346173d8c73a8488464b01cf42f8d36470ef2380ecbba53f21e8972e90cc606150aeb31f095e06107683f6e4a499cbafee8a3fff5f15f98f130175df35cbcdb7d4b81e1c9c8296874f920435306b45eecdcbebe0ba540c5e92b2a02fbfc031df9658751cbc2f31b981ce45fb71ce28e7291ae5c7e275841aeac184a35be82e165c95e6f556f21467ea11c623b895f1bd4cafe420e77f53cb441da7d2bcd6e622237ffdfcdd778a8ba607d2d1a006fe6a59ae6c01f477b88bb087256de01f3e9bacd5e73c83e63353299cf8c54236d2b74765615c96d11cc291451435b62e1879802f5dcf3b2306e976b75518ca0fe1bfc9ce4d1d7a9b656aed95c1ccacbdf4239950be6393687e47e59de0ce328fe109b5063c32f8db118183c732fdb75ccaf49490c7a9ac7508389912a5561c0120760f0d792c5b1f0eb93fb4601f5940997cb48fee12ce8eaa4b495c4f898cb2a6ff8fe8915f80747e65f376b0ed9f56726d447c0edd9d022d02e93a1b4b1ae1f02007d9e5f6b91082e1fff435764e56eb51fc6bdbad2fff2ddf1db6623c279fbfd87ad59ed7d1e50130b7bff3b90d2a62f757d90ad400dfbad72d32f0c827d117fd849e66b4a7475bcce94671d6545febde1b1a4baa7b88c69f679842dfec8986fce6e4acb3c9b30b64172d57e8352b1304a931b0c6e9cfecf3f21344aebd7e353197dedeb0785d5465aa759645d0a4a844200605469543f53bd50ba0ab19621b29436faed723e20bda2b7cb923c66fdddfc35f8728ff2eb6c318bc5137c4b9165eec738761aaedc3c8e343f205c92c0aabbb241b538df6dc589dc0b3639e5a5fb287cbc69f390cd077c41a0c2298367b412dae074ccb2d6940000598ef5ae79eb224fc9c2894e876a9b93ee88ff2fdd753021c579e7fd0adaf246d0a207cebd2814379181f27cbfa2d0b95662437e506e6d71a89fa17749b9053d7af327f0111b5116c0ea1f4895bd4b82aa759aaf034286442775728238229c334e2104a63d05e6fc377aa8ae95f576d85d550b8b2edceaa2af79e9fb693bb8fd078e7b61b95150215d3bd3fbe7762b0b780581191128e7c0dd443f991f33f1a3c5a0d2a894c357920f19e8fc4c39d5c1ae5e9fa8f258d553f5902abcb875e59df5776d5c56ae1213bf815b4cf2d01b6bf001fb8209428ed1158a58ed27e2e1abc43768fe0ff3a2e880644764cddeac902ef7fd298e8ef9bf429eaf1f8e06e3196e960c0278d53e148f6cffca5ff6e748b78cd56b26bc3ac8d54e4613809afec616069380518064d50388ebcffc216f09dd82ac6785529eb88a961156dcce9ddd441b923435992ddeca9d3a030f0c6f8c8195b701e3edc6c825b1d99dbedeb3df84b972f2c329801668d11e184d4009efd898680b42fc617ecee709017b36d96cc0b3e3357c8cc89bb20bc941aef2e6ff43dacd11a1ee3b2cd595e81968acf0be0f69cf6d5efba2dd75c3d555e590125e28bdcfc4f4e19b7293cfcefe8fc2adee67fe58108658c893c97b7aea0d88c83702917843726c48768c95ce89e4cd02ed0e58f7cc0450092e07f5adb89cdaef5ef50696d83a1d1308b21093c3f25ed28f7598df8001fa249968d091ae939de4b28f7127a9631c53ff46b1831369fc9b10b320ae257a4e3a67c8f070e513be308e257c7ec3bd808d078ea21393fbcb1ade9946659c88ce2014d8492ccc77e98d547b04fdb5eb8f76dc5bf6afe955e2c1aef443e5d7c4d370a8b7e20cacad8b64d5a5a17f3e47c080d98379a18f5bf84ba6b54042ec373e8501cb9a71d9608600ae2475aa16d81cce07884d0483a5fa15050de8701eb7955fd354418c1dd9a71fc69075f853346840429172a8afcc2859b5511537e9b5eb19c28fbcdd53b70ad06516e67ae4a03279664b347d70ab950ad741f9b7b88269b54f1ca509bc9bde591945f3dc4b6fc72dbbdf92bc1be10a3f7ec0e810b1ec3e74043376e13b03684a404ec7cec3c609fa8a97c4c011e60f4eb6e40c55ba77a2692116e2dee2fdd1ac22a763197302649ad338a74126427d1fb43ed6b52a96abc72afc5b63f7d001b0c40e633f91ce2fd491a49b386b5a5c749863e7fcb5bb4637a35793b8b18ae57f8151743f911a5a5c9afcde0f383b7ee5237d4faf8b593abfc0cfce39e2a6e6c5675ecd948be5f6fac824021786271c79b976536ed9a54b12916c538416d776e513d395c480173cb9f6ed1d87f07b6b8784ce339ed8f4c200936b3cb9b5b684806362cee101e8babca3a89165336e7ff6188f68d09a0580feccec4123d7e8438ccb7762f795f8b44a80ad08d4c0511d7178c46a314361946872fd4a62c54d7a7da967001eefd54fdff2fa596840a38f86d0a2dc4d12d553176d908242cf068fbec780b2ee6b297f3be256de1163c65e267dfadf37c492da537842b5adae8aacca10d9caa3d20b14ef3cb9b0ee4fd5dda91fec6ddaccb925183395b09f6b0cd6d30b57dd26dea9432d07aa4b9fae381ef78f412f7f39a08806130ba0931e0d7b453f8f86c5e7b03cb4a2a9a58890ef1e2c156edddc2154f83936dd09a4f7c9bbb5d6f95c63048cd74b8568cde7e0af02060f30d8f4a42a9543f5df2e8326806ed882645c2adefcb1117e7c163cd980c33f0a421977c6d99548a686b674b9910624b0de458379dc1d2f5e71775416b00d1236f0850899a0295b4a559206b7026bc6d4c0f765592c89fcc7f2aa7bb4f9656bbe1fc473ad007f68c9dd4e8cd62d268fbcc1820b8b7d7b4842b2890ed006f10c6653234686cdeb1d002f8f0992e5a6f4b3caa3b07882a39fba479654d0b3039c9cb3a8b41519395b4136f55459597b6d6fe5dff3bf65d7a14cb48b643684439f55761ac5438bc1be61360bf5e49e098f45e79e5b551128e5eeb96911605b189ab9df66356a2ea457ee257e9f41f7337dca3331152702e32cb60d373a4f6b3ade6f082481bffbc46d29b049da02a11a1eb79a870365014113cc959bd7fad219df1c9346e740a1e0996e08616a036beeb75729d3bf2b8e8df97334051072c36696f109a6f0a061189e0f36a4005f41f173367a6c5706a3587f577d8df2fcc2dbc90337150f44d6ab25100fca767ec31c3bfc238eeab4ce55da5e54c8924d64e7e807f4fe22a8f0f79cee6aaac0842454bbc503d0cb1ff712a746898a11c51b863e349c6279c8aa1e8095b08eab01c23a7384cbd849cbe92b2a1dca0c3b310ca0b7f59244c435f872f6a862c034afde0293872aaa13ccc8d11702b197ca650ed560d820b6d91e150d36cd55222583f0773fc9eabc3c7b3c64dff7e6337079a0b6fa9c7ef521f6ef4d8a33f20589e891e90e603869310da66b37f8ec6d7407d9352c1ba9fb52be7fe2d75240f078a8035095d8868cf5cd68b595c071487f7fa8910ee86b0e4b4f8eadee026016cdb5ef766c382b4b8e1a83a9227afee2ec4da491b931afccc387ec967776138efa98e77937a2dec28e0af7e081a18dc9ca1b134d0c5d7815bf5ede16459364f7ea957bf4ea7a34256e224bbd4d20bb178316466d9494699d6c8c27dae664d395f59aceb389061b9c3abc40402749636c258bf14270837a732dc6513dcae6099c3d2f3e5cf6ba3d899f5661bdedb8b39a3058e18d2f4a930a57742436a310a17409ccff605a857a57932364ff4df33f48e22ade5f7f5d62afa681daeb85acc5e98cbddb887d8a72ffcca05d7257bac0d1a66a801ad53b1c30e0f53a64818929fadb66e79d689ee747ddc4ac9a7d24e45d00be8432caaf2a1061e12d3c11a8e31fecab908b56ad0a4edb6aaf47f715f38d59ce3e27ba2ab6e4398f8005c417ba7347c386d665135d0096a0805c917303d2569c1b6823faccb9e6b1b280990b5e33c530ce985e6004c71918aaceef65008633f07cc900d55e096916e0c9fcdaaf97832d9ce5c3efb13ec1c8cb8720a1e320ea0800b2b82a3d74cbd5a3c7098e362d2839dd362d43f5c160bc778f5b8dbc38d54ee45804ba28cbc347f748e4ca874b69858af82dcf079f85bdded2b9ad870c5f9d52a32b0f2fe65113046df4566f5f8ffdc12bb0fee5e5fda9ee51d28360b13de779d8afddaa0dd05132c64a47cf1345c13c546df78d0f639783af5b934a8cf9ec07935f1025077143c36995b40ec21bc81954ef38ce8f791c43af2e96df07a4be20076154ddbe965c2708be68112aecc25aeb7ee005195bc7c7c0c5a0f4845f5da9f02d01d2cc08f52f6ed6d7f5d9f8db188b58d0104c2bc869bfef6ffe3313864a7c6c2b8498553c974138f38a2ca94099cba2b4b3c9e66240046039f02154c6ba768ed27418c67b82983c0333a2ad1ac9f6489163e63fe8d5afd2969a1fcdd9909de18020aa16c2724073e6b4a9b3988b511a1ce739fa02ce7db39135e563b17736abd964bf21bd28856320b55ddc7ee424055cbb6a0659cc8befab8d0e6509eb39f726888ef3d49ec3d2d4ce66bb5115b0124be34c6192b403541fe02f946ada492b2be4107b393ef04505954fb79db7538fa97db6a5726e3807d1e3c4d20ad5df5a15a64aff78cd5f5da6a5ca04b0653afe82b9d758bc730a40941da339d0ea7f8d5ed3792d5b53d72a0e8301bc7bbffcccb8e14344616518a5e408938307de00a495e33536ce5ec0858e51fb6426a51dec5c230d915a9c750bbe4532f7bfdb5ee87652e432fc8f9df00bdafd7a84b3de64afdd6d1288bce9fb46108b39c73c9d8bac3bd6f8acc6c6514a92b6f6fa6c6d6c24d890036e0ef1edbbeb3dee0bb7d156b27504872476846286ee9b714a5bae56d1e3900bc2a0208e74f13da034b0da301e16d9b28bf71be96efcfadba8603ff29b865951d47c963e397a8e6cd886ff65636c7e97706d8b280cac99d4563e2f027c7d294a079012521b69e62fe00d68860879f0a8d9b89d5a437da68dc8f82bd1484920ddada8397723f0500864c4067da778ed858b808b69e6ef00631c6d1f0f4552c8a04a6d2df3a137c5bdd8bebe52b178dc28011ea7a3b1499fba08115aa6ee637e35d3c75364d1d099e835920f9c47c2749ee761deeb1716f03b258596e464faa7cdc7dd7a8b8be5539a6b769d97849bea9553a683622c9a2e3cf7b143d36b323f6cbf087b2a2341622d57566f296f8c14bf070a1686684c84d523b03fbc26aa3bd79453a66b7a5db6a796f2f0b6176f8eafb64d6634a6b1f595fadcbfb251c26a06b4596a6780a65b52c68a71a98ae09f9f24a0ebd44e5985c1d912353c75e867fad6bab9ee32b3d65002b7e9605ff24533d6ecb22de3bb10a292d3b615d24543a3fe4dcd48f5e920938d22f2d9dc93c5f5bd17be162d98da9d75afe3b8b2063d45d73967a6f393839f358a7010a005151fa5a8ac5126c010648fab204b3c351c20b33d2cc2a3b0bea99289a66e8c3eac9a78a4644950229933539b9800d809313891ed3cf43870aa30499bbbd78e628fd63e37590a86218cf6ccca9c8e14fcced61fa426f6204a14b85d0231f03efe6f46fd47eb1ace63b849f8381e0c5d47a51b09faccee93b52f74517560ec0da7c9333b809a05dffe0e72476e956d90162cae2596c51210ce6c4d052f389b581655634f483c5c4fb91eb820a97905fcb2996a03dd4cc5a721290017af4a62e0abebd82f7feb904faea2c6752a426508f57aaac691bb6e81435edefcc20518d61554f7b12c401a0664a7e69103b3c1a34c4d3c1029acdea7855f6908991d98ed5860dbfc2c3ddfc065c5a68d052cc18568c0220374ac95d28a5bb5aa23fc94b302449ab9c4b477523a9d440d314663df4a92d46290b8b615f1c90559e8460c28244d1a61457e268cf113d50571c5361210e003c0ae7bd3a9beebdca2e7692b70b19805fa039e34c962e8245b641172542fb22834f4c1f1d20d3e2e17dedc7a9937b944a097b6c9f8b8052b38070d62c36250f39ed8f246cfba1a4d05604f3ef845ec8c3a318cb8aba9e0112f8cbfd93e8fb05cf41919480e0848ad99dfc982c3115cabf3835756c5a8399de964bfaee800c9b6bd089bf5f733c9794f7600efe319918bb986a6bb7df1160efa95ad84d23dde6b9218a21be2709f0f3122bc3db3cfc8a03fadf520db0bf5342b7f9128d192bb6ebfdad2a65a671ec81ef45826d206f6dd803823782e0c75f03b29b2eb4f971d6aa3671e507a487e73763b94de290664ac2b5aea9935be6af62e3239b67e31a3f5922a052bc303d4e30d40f74ad9537e552de06dff66258dae712bc9d72f93cb11484c97c5de9de88d6df7a0f66a24be19b0455c9d5cd3305fe72646dde8c66458404074e2cdf23286916ac9f820ffa3d9db9f36b005b9c1c84c13cf69d868e65a82581205d25518656e002b7afd104d46a4744fc1da32c32f546936c08f0550fc17a27525b2218d77cc4ccf2a1bd51b50b284d96116ce246c8e53b12910018a45b98122bc1beb0623f68491e70d706148a2b620003212bd2045066475eecff8fd4151d9f0a1968c3b90d1785a083eb094d73e519c5eeb624a0dda7db7f40646725e4c687526dbb9903a1395c2cb65e57a3f275265a666197f37271a36edb68c9129031dc113821c4c00c12c30a990479c5593df0144c033f25a0a63e1fbd428dec497cf9aab83b17d75307cf5b88fe3b9a80a805d757b08480d0d38669d09b1507709bb2ed0e0440517302c3b57c1e3379e93eadcd1738020252bb6cf109cbed3f46322e482d0fcb18d3899989ad4ebdfb67b698f038ed9243cb869aa78af9c704a046afbcad4ffc3c8c87f11edcdc15a67be9c451e2536f42e0ba59b8a56fb6bb84f4da6a0476e9e7cac5a56caca331c7ed1d11504f0272ee934eec04f8499bcfb9fd22cb8de677156064ab53a077cb2aa412c0ebcf1f2f8d737c3caa3e5ce5938ae23ce6069e90dfd0c8005bc46eb3d901feacac388a0ae6e4f6df405be55ec7894f4c7fcb96dc19501a302bde11d892287e9eb9a966786c278ef90fec5569f3a00616bb3406eb24899bf4830abd213738c97672aafad6d580c926a430390a79635d7431d0e5b08d071ab510d7539c760c19814a51be5ac66a45ac28afb060d7e2382901291c3a84c34a1e6fa56351b02463c3f4f40d5851518c6c01830b0de4a13261ec67cbecd98de5ffe23fb7063976b4d7aa52573645a2a6f3704c2c50da42ff1e8f53b3103e12f97d781a298b92a47ab3192a759b2b6578351ca499ad18805fad87033bac3b1f25db8577406fec85727551b7452de25e50453dcf3a621718a5bb72c9d3417bc84d678da214fb9a4bddeded2b835b735543ebefdf5edc8582ff12752581a2b62ff8ee01a2bfe67811e061a275ba1e246d554bb533cb8c17a4a649c82b982ec1b36f86c49d7cef344fc8fad49dd740191b6b153d6d29fc66e70ac01b90877ca05f973670fce07cbb8726b1f0b011d429b352005c7dada794b307bcc7d311439f8ae1c4702b96d63b6bff4d1229d8ef910d83f1ff95b54052b8e84216049a40ca5fa22bd2f8e4f9ffbe11eeffe202b418fb6b7ae27ce40d9a2df0d463575559dce70db57f152a3104e055ad6321d1368589b93a8597d9a3c328703d84bffbec6c4da1d1552e9a395760206c024dc8cb3c6bb9201242bb682ec4256561443a1d9b0641426b1418b678a621d614045aa6dea39a97976a9a12bab0795a1a2cc572dd43b84a6a3654bf774f5501f1b617db1e18c0a370dbb471700a51b7287d44481e35259ce34976ee0a57e2352b0cabec3393db39a55f3427319217be8abba911f39c57ac320433fb78b13a6094fa1631e5251c714c1515e48a998e766e4673c5f3bf49a6d0af573df4cc0dfc279f41f5156a37e0d2a9ca1110e78c18669c15b4a40efc26a90556747ee46246cc07815bb0329570b64e3dee96bacb993769716c7443ad75e6ef547631990760e7a4fa53fff4fdc54ab7637555d0135d804d9a5616e01d780c1ea49242df45f3364209ab7141f99ff3f1c4ef4fc0435f324cf917984aa63b560e4c88c01dea5b577c2207dd84979160bd2ab137410a17feea2dcb3797c448a734883ed00c0ad767e6a67c6c63b0e244e618efef0390712d23d6a2b456c4c2c9b42a3223d81bb25e316057daaa91010a2a5ff85094fe3de6910701eae1b7ad3dd1c05a738c1cef46b47a49a547b2186d48f881a93b77e9b4d6a9842d2415a184506d39e46872bdbe5e144701daffc7fbeabaea54b47efd3c3c48cc7aa9198e752cb2bd1e5367b23b5fa9d701ab50d494c7521c648afc7fe4b43405735216a5f2e60780f9603f1cf40a4b4cc5014e62c5941db6fb022a7511964259304ea98806b2448a8f9653789b41b5a9533df279c5c3706b749fe787248ede48c22a3081b9ccfa345d7e2a44067842fb3ddad12ffcf66d77d63d53ea9a31fac091fa5f77e92aea35f82673c1a2cd8b78f618ea08d1ff2e7ec3331c20fafe7c769e5a88a3785469a8e79bcf2078f148a6d3b3d6fc716b1f9dec763ab39be270f9bcb2fed6f5de2fc7270f29563048a25f1c13700a3e2bc59fc2f34ee085a55aff10c38de0b5d336dd3b1aa221fe5880bc4301456f798a92cb88e643118dff6b4e8ef0b99a84182a7adc3ce99c5f4161096a913a3407760ff808db16f3745adff640f3bcef9a413bc640485f55d3656e9888f4c4ef5f3d9ee9d56c2272fc04d7c309d582e55df2d61fea42c2d87a01eb051909268a47fb0872e2b5a57668a4dcbf7cdcb14c595d7c604adb91aca148c8db6b9ad42361157ea3f50cac62b10b6d17b1eb5879ba5919cfa2b4f10f02bd40139c868035e5c88c0e72bb96635b7b8ac5b00f35572a51572ad69700461c7dc3bd483ddb384f2c66d48afdf6cef240a407c5607bdbcc0885a52e9a1b11ebe0bacc8493ae996fdb5599c29a06b37509d9f293d524038504c63c74027cc5f15139a25d2dfdb475271a204fafbd37bbab2ffeda7421977e8c188736066a9cba39b4f4dc3a8f7c0321d15533f3b1e1dc095d49402cf1b9aa925670b6dbcae9f0e8f38a8bcb0edfc1115755dce55be9b2a4528ccfdb6b8ebf84899b42ed6a048d2c6fc7092d11b4befd6101343958b5cb0ed2554f4358b6b44ae4fed3f4c6e49aa267d7481ac006920aca0505777a683611896d9bb999f10f28b8768b9380b87e95b56ad670e001a1cf51f7512ed3c3119597cfc1511d759bebd42188674425ef90d197037075aecde5a3f4d22c33c53cc0a6d790c43e5dad6bc57db1e6a1c13b0c977f88f50c04a796840a97049873a9ad8d50b66508efc5eb86010e5081b0c0af623050438a214311712a80d7e9fe0db8915727a0aba09c5b6eb1279ca50dc63bde02b31db7976582597cb2db61cfeb39dbbcbcaa35d9a7b38ed9ebe2ec2480cb5eb2a3188a4d4d981c0873b5c8fdd6213831d038fe36350a94fbc55dded7dbe824a53a463ab8768f812964b6f3de5e4f226a3d5ec14be26d5fba5254f721d62e730b7e34eb57917dfafbdf28fd3b09998d760eec048645cbc85e993d572c4167587dea7fa33e05324a154d71e30e96de0296ea93410109fb3042315d1bf13863f07a8414f6dd077e4d284a5d90a288937d905008559646a4e6a78c226264499db1055f2d48a58863286607c3df2fb4a6b03d27acc537857bd0065c4c16fc5f11b2d8692e234ceb4eba685defe9f5d571b1f7a058bf6c10940a466ddcbe28cdc2c60c38887797681f720173c306b68c524a895e7bf077ba83246b3ed15c7f07fc48b43bde4e929547012d4d492e315539580c74ed827cc1976242eddb79cddd1bbb21420b2642cd731ac91a4dda19dc03307a6efe45d3a4753d1f537e5ca9ba0d2fd272abcda52418e37a19e71b9fbdec4cf2349c0c54645a78ea203a7269536aadbdc98d8d0fce33921d831f9fbaa197977e11d4170df22db6dd54d0040f86b978c8e9380773554fb877cc536da2f7206ed4d4a05de2a044ec80e6ec4c2426b1d5322eee7de7f6d6414ad5ef164a5e62ea0893a4cb70357a66121a5ea467f4e494b1079773e86cdf055c8c1b30684787d9a93375a5229a1bebfe388c27cd6c92229a3c1c84e473bba84d74a6bf0d030080589c95db3d55e37043355ac8bafbd8abaffe301a159e57c9dd64233fbe0f7237d4aa828d5afe66e9ade11d4c88beb83b2f6a8a64aacf3c82cac7aed28664ad24164d7d463301d1cf30e43d1b4e5e982f1a078768c2195b7718febd895d7e033dd5aae200c005e52644ed97c60a6b598995eab4f1af773e1f5e88eda6f8478a5c396e0d1adb911d469d69c2e7f4507c5ef04bada461a438a70f3e08f06624334d99d2f6dd9859b63e95ded9629a11ac99f3343da462443f9f6bdd308ee8a3a753cbf2959445156658817ba83ac659e148b625c43bfcec51b457d24dcd24334baa9b4c288afd57d73feb9b1df914ba013fe755590a68fde45d621805beca43a3949686fb88c0c87bea4fed770aa550c28be49485f512a949e086c6c4491b2a592a86ed7be76eec174c6135b665f288e7ca41336f1196564d49b20f18c4e72bda81886de0acae28cf5668c8802d6dbc821f4575664084bf85085bf8b529c231d4369ece6817417a3e6f9560dc284aa42b38f0801bf4c04253ceebe69f891a7e8eecc84f483cac44777c68c2e57bf4b5e576482d66463adfe6ef99ab56afc58b8d104585560c095687aac2ecb90f573e78fe3c40363f05d256fd1158888e5e39376862ccda99553ca5e83ba23f2623f45782755c04b26503470517df03e1c571e4ab010eaf1ed8962ba9e1f592fee7f17737e8672595a43975f08effcf4218bc1f46caf30f7a0ac67547d5c3bc85417b37ee00d66a830195260a65e8cf900c41c89a2b057dd296abc92e7b92911abbd70284445f3a84594dc7d4dfe98f5443302b307991f2711418309cb063d1b7bc6746a2cdb3380e61e6cd581278e73db816205cca6137e26c3d1df87c1bb0f12c6d44bf22b94b2731e97f3a2b71c33e912294b4cf62aa72876f8ac80f31c272d6e127c6dee7d4870d59b5daae35ff8df47e14b5db5084629a99742a263a3f66ea176454b23a1e7a850dcc55909540c24c3516331c8e2e216c7be8d9036f13ae9d0a4875b404d895a54a2831d5ef9aeaad1b3621068f8adf8338bfff5f50f5375f9738e1f0d9080c923fc947f8fc858a4f0b5ddaad9501fea66e65b5d9b92ea68aef66a3c4b37a7ad9a3d39ee587f857b1b063d0b95569658db8b4307b15593f2be9293139cb9895a7688c223b65abff3dcc5c8a693008384b42e9f7dbd7e5a1cceefd804b8466501bf02720896c6c6301f9214fb9fce0add0cb4bcf2ad69f2e8a7ea785e16888af40e782dd28675e5101f66d0b53aa2932d2fcc95a0b3dbf678c77ba6f7fc5bf075babd76c75d06e881f30e261739361b555ab77a5ba347eda367ebf0e8fc4b9b7293fef2fede0ab1b2cddff932849844fb3578c3ef24a75f6abda8e5e1695ac05df3c0f57481c9750e214c29c99bd90284156929906c9d3145b2b6c1957ef1262db4122a1ac961d1ccd69f43e8c00aa1d2b33506ef3ba4e666e94b98d45f709c5a0360b91ecf869a741aa383ac4a1da3445a65896fd867788201d8dd97cfffc168f5661836de0aefc66e0aa7f287e42454ecb5c36f52adb31ed633f0399635d2a3eb207a95dad40ca9875cae6b7f4aa7e4389854b71f809ed261d2c6aa11f41814c549f1f77c6187a799b3f8d56c597e906a9bf91773c8538b2400f22dd3d42d7668ce8a303b79185a7738920220a3955c9eb2fc142b61d1867dd2c7ba07f5a5d87d9f391c369b5da5850918f16beded756559303cb6033638ef3824acffc831c26a978e29725226c6d6d5c874ed4071dfc68596ed9a5fc65c092752453c3815c6f684b3348c718d84601971de0b6d446f62a517f3b538eb9e99dfe74622aa564be0ce6343947dbf5d4944f5fb7e02ca903a4352c373bb605dad843ca5c80dc4e3194f9850585d4baf6df6e65d9af5caa63f792f02a1509f62633533a19e9ca9c96d62974640a693249596a91ac9d707525bfda1cae0e7b7af1045742750e0c163de9f8b1e92a62c5780d41e9e0ebc92368631957e1d06c903356ea7f89962ea7d6dcc5c99552256fd40e48a7fc5ae133da1a978deeb316c36d0e6a180298602c6b842669a771fb61ddadf209264013bf1ebea5b191cfd3c55cd5a1eecd0abf80aaa26daf29dbebc9e245adb8b4e19cca593ab528d2d7ce69d36bcd7090ffcd37b10da3096eef3d940ca52a9ebffbcca36292da2ba376ff3029ee0fa306e103680ca5cefb1211dcbc857479da26143826973e7c24cbe635c200774b647ac61366806f076fdbcb18dba01b78b721255dc9001c818b93ceda8cac03c86c3e1028280333597720170b4bc5dc2a41bc0c7b832790efc1b9b55597fb255ff90c3cfd47961b0e9bc2e484694877e15735c38becbf4dd03745f6380c091fbc030f3af83251869c0ea58dd9af1523f13a99acad1cd50e838217a2fa0df132f1e09918c3eebf377881cc2073470c6ef95f0874ecbabe19dd4c1bb7908fa1d2dd1b72a826873fffaf2354236bf5637517e03f5fae1422f8c111ed07de4e2fc59a02d25c8adc3c57ab3d4308b52f3ab7a6e29eda5e6d915f86a6aad87ce9d96e7bfa559e20cfff2e448863bcd1353f56017a2c4dcfb37b3a18ba7ab8a648b116238b23900cd8f95c822c5a650c68b551514440a5abc5f666dfaf8c54bbf8237057b681264f5d069f9f77d1a0e30594db212cac9571a4636b2b753ebf66f677d3bfdcfb7b330a2b20e2ebe1145db05d0cb7984f32392c7d8161712022e565831e6456fb58ef3a5b0c987d953554889a5edccc5e3c7ba0ff2d558dc5cd096a5ec61869fd2db499e4c0dd0c1a29c035e078e99123953ca39f8025ce0ddd4499b594f3d0b1ff9081d7bf4b9457b61afcf8b483532f202a4a8900f38d4c66661c357efc78223ed7634087ef29e1b50d5a84d793ceea91ccdf9d141f9c20fcd4cc15d9326b3b3b71494de79f61cd064df43f8f7e65f509e4fd88985e2dff349378cd6471c33d533e55ffc6e40b507886c79e368782a07463eb7740731260610da2de93e6ce367ba63c095f47cc9219915008f0f64ecf321b821b81375b2d73be8a74b1aaf8b0f215394046a6f2a093d502e5cfb8a9697cdbc1d10296d430fffa7d125e7f22d6ec1c9b5def5c6bc609ed7a9ce2f8914b1df4a9eb9931f83772004c0063f7055a9a24a19664932892bc9d759a32dc27946001976c5b62e675f942f1be2224f47c1043c99ecb53dfc44ae4951ecc606b3f8c3d7ae433d4426319cd18acc0189046578359a60b3034e916ba84a06b0b6c2ffb59889b749dfad97a802dfb219816030f162ae14f9771c006ffe56a7597058e95950ba2e27855787c6f1b498b91b11807539f499d846e5c3c8e148e8a3562f455109ea88c037412482834f3cd15717575d1af16ddd872476be28641f101","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
