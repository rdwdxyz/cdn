<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"487cff326821e589b59694d6a01e459186cfb2c90c4d1c21877b5614f0355a05911b5993e84249c54e66b714439974fe8e9a9b615d99c9c9195226064e226d0069494b7b1709d78f320170549c081e8d6f25bbf4ccf616c640b3ed97808831d89d969f50256e9d6cf281e8d49bbe30ce756c3176f3ff614b31c2e8492b5521f5239ee0de85b5b5588a476ceeffc59fb5686da7c5f6c1b123114fecbcab784dec42fa62109bd0685f063a1beb8a2fc5468f31edaedc13f6b9dda3ab398ceaea80f859d1fc24d0df640ee105220996614984f40e115069da10927ac285bdd3172aa9998bddd0055cee31a5137ec6038a89ab3a802474654db162b2bee567b271dbb8d63aa05ff86650197db02d314832220772907a70ed741c948536e0edf9e0834d5aa3d80dffbd60d6da4dd9ed2d5a19d78d34251c060f6c94bac9cac3802db9b5a01171df3914d57a36253ecf5c4fdc17228c8576872a5f554b90b511ce5a7eda4347aff669b039d5abbfc3722fee9a0ebabdcd6887d16fe366a45e26371469030b3857f5cf7a00a02e34a998bb060a1bfc3f1d86616053fdc332948b687cb2e74316ffd8bc6ece343a5c76af0ee271cdc241e4cd02825dee99d53a7fc7ecdc8a737567fb485fc74a2bc74a01fc6c15fa67d1eaea94abfaed62c2af089b5de6814b2174bc40455fbbd4e15337dc89b689aa91d06847473bbadc632be94f2923f806920954c632f2228a707073719c2e1af750ce1d0632d10c3048859b2e68a02b2ad19ae047ab32d39c3436dc8cd3803fb23438ed29efdffc3507edabd201aa664979bf9c6abdcd66ab60f650151f5495bbeb5ce46b67adca05bfc3f6e67847adcb964a45e97133aa810eed41513d8c3cf49d2948e0fd6c2c1de51f84123f83570e3a7ee7e6f8be30f0a21a19a7b8057870fe7141c915bf1f0e015354d7f12b2561b60da6422d2e1c1f881969a971db6e69c3ab89780a8842f12d7e0067f272ad4952da63f82b8568f613bbd83aa1a11e8defb6465b09c2e3fc31cd17aa40fd2e1db6724763ecd42f4f10595bacded6428b3910607bf67b7ce32e2cd6210c14e89ba17ba79166588fc2f881c7592dd4e993241ad6ff31879e02846cef2bb6aa15b63e0deb0d3ef18dbd2acd877d2acfc38ca3a0bb9e634061368bf0ca60376ee8b9cb6f9612cc202046be1aa59a10fb1edca5d15f870c7b6b2c32f3f42daeedcc3dd8638c41fdcd26fd139447f01725017b8576dff23fecf473d7c4159019aee115edfd3d6d55b14a0432172917ed340750b65d02f81d9fee6d943f0c284230ed1a57cc767a8009bb6ae6eea50cd7a7ac26417be67de7ef60e8f4394facd52003df63ae8a5ab12051009b683c419eba23a7484ae446554de885f78dbba9eeb6ffc7b04a29bcff7f6d27ea524eda6d82cfc32ced015d1915fc4bb2a75342af5677728b4c989c1a6d840276b53acd5e24939d11edada75682058aacefb45981c1ed98fd60d36a26765e4db57edb961728c5f1060d673722e0ccbf0d1427a302201134537bcfa071bc469764be3d9186628968f535cd80a3c3b943d2512c080e91de6b8f0a2ad02cf2db006df9fb34276a0dd9031e6536abed52cece2120457f8d7f51973b3ed90959df066829386196ac251a6ae2ecf21d212b5d5b56a78d0991ca5538ed4bf61515c4fa79ec394581fa046cb3c020143705e03542a7a25afcde1abb1be1837a9f17d9a8c9dd793352fbf81bb6df16c121a2ec6fb77afaeaf30dce93d4f8138e1eeecd59add0be11d1fbcf0191e4fa9d1ce64df4d16fb14640521418526d4f1c07b1a3f1d786a707d1fbe1f37f9cac9671640b3dddc775f2f74a4f6811a618a7fe940d44c2659f9455085621d846bca348c6ed0da9cd88d9ec736d10dca605e4605443d10da04d8b6058978ad87bc41d6f6b63c6c7a6600f541fc82aad61f783abfc32465dff5503e635de25da2eed4f83a02bce4abf10e0406d113d1ee7566df7c7ab01883a743ad1f83e8d600495bb31546c0dab80b3a262fc3381131a13889db8850ee1eda095e51a7d2eceb54993806d7ccae2d9a3623c6fd01bf82fa8b8c78c7f3845b6820f9dd352ce6a0f3b1b03d1e8ffaf1b9b327b56294127b847c4923d99e4c1043dd4435d3a3ce13f227cec41a3ccfb79a8edbbfc9aabc334d8e7b7083dd880775a261862cb7007e0c17fe42590a860d9edbb201deff9a70ff6400eacf851b00d64cc7d3dc7377c5568d2b5bbeb6d8a350cc3a6d880b93c2400b2c572d0c350e0a41e27cf8ba70cd07db483c494ca31044d369e7542e10a83abf7c7ebdfca62337c27e33aca43fbe4bc5eba28983e070cd75dabeff6fb886539beab85bdb6c0c77aa0b58065ec5b72a4169ce22ca99b6d202178a22200bdc44f470c5e0ee5649d903cebd23ee78d5f2aeec621a1cdb0598b052bd6d9c7dcd22ad094334655560bca1d37f5b7c5ed85ad6c7b393d668b1bff1c8e0d978b652d610bb007d1d1c15927af35f76d404503c3773be03d3c5b464e77ce94cce029362bf214421270374ceee168c3aba4cf85ee5130473680c4edbf1d922d6acb3fdfccdb4720c4a4287181d1d7f75a6924a0564e6d9573c349b8947588c853dc7a0bdfaac9ef9168819868689afd61b7ae77dd1c6d69fa6b42fd33a0813f2688adc75a790399a90547e9a84c6bd8e49f09815fcf50b9ef59dae6269f767acb3d60e3897612a684cd13382a94d34106e4d5b24f018227e502c5d4dc3fc194c5263e9904599f78e9d3900939f4ca0b1a987c73c5819a885dd895e7d41bf62f72cca1cf73a10fcf450520870caf278396696e0e1c0c80ffb1b294f3798ab034d9a4db308bd93fbb5440eb5c006920c6e972018cae63954d5d61ca6912467178b5c8c64443ea5f488ee5d1ec8308bcbf4518c2750b31a7d0b4c16f3db4e0ab33a76fa93e95728ab963fad0186f0d64b5e894deefe68141e5b397b72fef3ac7983022481e4de0833c80fc2e448c082b5d978d7a8e3f206da87b7cf9f55ba4942f229f07b771be2a86939f89f77121a836a9c71cce30240fa4d11b464b8a5b0c226534aca06d073d1ccae9d89b71ea23e5ecd509f158760cee8ce02ecddfbc173bef583f29a40401de59e0b4b13b63b7d2337dcba541bb8a01cf1dbd48d45050ab6a30f09a23a262a3956139fd6d5f224784ee11a54c959aedba4afb9360b5b4a38bf4ba9513241e58f7a2b4defa03bebc480161ad3d67b19e08f0dc6eeabb950844e2e509f8893b789b5f201bd77dc8346a722cae6e5c66456b49adc0b7e6244ef52c932b13ec9dcf2ebb8b1935809bb1095abba9c18bb2a954f902d2281d9220e96fa579b9f1057ac6da5a4114a42fb6813b291103e9e374f7ac7dbba761fa06e3c7e3da768756c2be6a568a75c431f0b39a244687d885bf87c45a704578d3571e497d6fc1afaed73c5dc1c29b1a950c50c7c8ca1f4feede525a2dd381db66c471669cdbb1d3689b516537b6d0d26e678ed4915ba8a43d1be30103c1f74189ea44d76324f20af589901dc6ca4a5ad62da792b2c070189c48156b15e1655fc2d20be28a3657f59b431b787a64a827d4f56e166213728c555dc7cb4a9846668dc9e265b9907715d6b8141208fb2917e0b0899efc0e62b948a0c6d82e074fb54ebbfa9031109cfab82b3cc34a40cab1ea09004db00325974263faa9690de805ab81f13c98d4d2a890731617b0d347d26915685c45ea9381ac62088e5de15b7074186cafc8076da23eab1f9ecdc34d8ca9ad25796b73b4303096895b0cf23e4a38776886678bc5df1cf6b3bd5ae4389aa35fc72110d3d4bd46774610bff4fb75c07f6f74770b3aaae4793bd05e8f5664b3e732849b66c8e8a92b0d91b86a6d69f60b5f3b04c459c560328abfffa6a9cc6dd29f148d3e3476924d6c5fe0581d9071d34a8859e2e24b58353c93e02adea91a0e59bc0d2d2dd00524834dadbf570098a30b466d7f6d11b1ebeab4d33e15a055301d816dcb4142d0355d3a52353f03ee8c4a8ac92174648e652a64cc2ef00455a654d7f779f3f4c34755c2e428a9899848a1d4cd23b58aa49af655d182593c8c1e9396d41f96e49302d1d33003ada2d3e42e55f45e63073fe5d5ca63167f446ba0150de9b65ef0c98bfbef20d8c4b4fed32a0e6c04a9ddb6217f34ebd3242f0417793e32a5a29ed435b322a91509ab2a120b739f868c240318838c0bad58644cd2754e73f1f629bab871292d75de7330ea50555e94b20bd15744d18276bd8119de97b6535027169a1c0eaa7fedf1e10a64764ebdbb94b1ecf08e398601e04fe3fd6d6d1bbfc3b0432aea6129bbe7337b8125669d24224172884e81697181157aab8378880c8c838b24d382a01de61e5288fc35254f0d52a8e66e6c96615d70b91358c79229fc9a8fd1aa6bda87512f64498eb24c6bf5a7f90f15dd8cefe4a9ef4b697a75dd4df985e811e99de395c7869ce841e6985fd4962a91d8e12d68550dc14f4af421a6eb9dd80671b829c5b3ec16483eed7da39d25b36fc21c51aa023089532001176eb36bcd1081ce4f895a7b9a4f9eef6cc7fe39565b80152ec2ccb843f4df807bda3441de797ffe96e60f8f8e0e0747489191617bcd0cd32fa39c7c1e4d5f26caf9ecf2f755d22bdf967aee19c14c599f2a70ad994a139bb47a5302155b2f86db973af6856c5ded8756df1a99a0f2a3dca350ac676e6f02241621017b0c3579838d8c2153d311444f44a6f57815bea321960aa4f6e7ace9ac93bc5372f0cc88cd72b80cf11c0d024be6a3d5c464fe9329829ba93151c6abebab0e0f64dbac3e61e682084d229cab836713079ae097491a5f60825eee000051740071929bdc3d79e6999660c10cd6f91f5766d0d02d98c770594aca0e4fae70447c2575cd6e49a28bdfbfb208a5caf505c1c246cef9f40495654ef9610c4b0242c636648df09ef677c6c40f8c687dd443048834f47cafd0387e20409fca5065a5d23e3d548caae9af06736a7bdf8ceea7fb06330416968afdc9fae3f563c54344d325af30b66428514d91c153b828cf62909e4f0b84ee82827650f948fb2cd694b1dbd74cbf0229ea4590034d3815a27d84184a7250e1c5ba5fdb36e35e2162ad03da5ab56bc14de1d52394c026aea6fb6400475f040183f33a42c499da65ad4f2b0b02aeb48200363f97bb8959f7f7a6a9ca20ad3b9055f8a60e58fd3c06ab2c4970f12740f4d70254d42150fb211d354829cb86ad429ebd5aae8fde39a870eae25d36b9799971cbbcb8005a7ff02c31f5f51a36feef1910a8c30c4143bc62a652c84e392f6b501cf8a70a7e475d51477c5647a32bd566ab3271f49f9f58e2d4248d9b53b1219ee7b9dea518ec6abaf7c491a2068daaad268cfc118f42774af5aba146caa73a74ca5c37b96e392a984657983473c524830dad3319f9e3e9417a41a296e05bc941305fef8f567a546c1c6c67d66f46445364c3f0b817edea9565e44c45018ddd8c384cd227b386a58bd186074cdf0ffce8da873310365b8fbf64860778db96b5a5a2cfbb6679db88c1de57ddb73a41c39eb343b1c293eed252d8308f50e00860c610db7b4aa68f323d0d1a0b8549aa078857963fe05731dd865c973aede5915d824eea8082e95bb65dccac825da5ab06be09e06c9732e045a7eed9825a0961dda310d665e541cfbcdaf046bbf96362210907d0c86c5cc90e6b7f814c832417c8762c6c13a00ccdbd8340a73f00f7bea3a2a30b658ff3887af305bb2d751d1501448ea290a3dc5b7d287b6ee94cb032aef8be9ff390975f8284e0f14fd95abcf7b4a8e4d4c087a388e5c38dace52c6000233922f3f55156f286f4142bf6be9a11d77a3fc4cdb1385be479d7b0cc77385a5645c5b19d080b520a8653d255ad89232b3f9dfa5b73e13cf6b58b7648089b9939533122c0325325f771cf0d846b296c343ef2ab9dd50262e46c841037bd97ef84304a54f7df67a4721759c405434662d0f3bd6cedeb369f50198378a845447b00e587bfc25a25a24652623f74b6c2b5152b88b0fe8fd0700d82fe3b303d867b42adb417d3fbf5f3f34b3b2a2163f83caacf04ac24ef58ac84d6588251d2fc2a15a9fb17fb3e1d2dfc9c78ce567efd3cbac8c7f97f2216a28cfdc074af6a1a1941c944cc753e485bffe215f3d97c172a9202102c09ba5f8d410af61a33c6f047f568b754c7638895bd614c4fc7c90db6bf5d82c75a0ad537acc536482fb7f3c0b9ac9828f086d6144e4e06f9b6fc3b1c7b9c53e0a9832c78b5a18cf11acc3b3e65c558a3e7cbb8825b0cc873408b7ec681ad51c89add2f10ba3e9fc1ded8b3d7dd3ce27faa72f58fd08a35f1455e362401f9e9839bd1b9a9b02c203cf0ca8b794b27aeb9fdf3f4fdda71bff8ef219a25f24bbdcfda35ead9b1006d0e59a6c9ec5ce66dc0ebf43e0707c50fe346ee813dd87cb2135611701fb8b04bc47cd17be84ee1f42e808d81500f8a06e2ad751f0941dd99aeb9f394fd897bf3cb39f2a57cb1340a417a6f4d1d135d051b641746a6a57dee16fdcc4c6ac912f03e6cc76df081a07741036a80c847f5930ec2569e73bd73112da6ec8cc7bd14be28f28e28de1fc1e429a73509e0a1e18371da331a900efffad38e9b35f91a739b18d39731af337fc82c96167801e08ea94381d87c53b325d07558a7df1644ed4258cbcd112788258206ed4926d0b7b66e88df119b5e7a39adc2b45f3b14d0d631dc4a18b1810176b8fe97874d910dd32544366d54abf5ee67b15b3bd40c6c0cde1e6ad3e2595ce23cef044e727533ea1c452efe41f13c93ac8eada3b33d188172a9f1e5db8c289ae6f4ffa2dfc3c26346a73068e0e7f0a4c9c65bf5f1b0bdfc88cf2196a74b11cb57e3881ade66efb3d784bdc798747793bd5d50c5dddd8940472b086c5ddf50837aa8c328ee41f3fdebb8f4c6d07d01b299415e990b0ea14a98330fe19501364424b9a14e8e21a30d36081cc174fca4ef0a2340ef74c4e272cd5b99a0b0f5bcbec1f756679c77b595c21acfb37576ac5e38e984fa7e13b9606a140e7c63cc24ed8a5b859bf2f35fb3bbc848a0844728fe69eecc2a4429b47925fc68315042d8769d653fd9e5011c78533a9a00fa3216cf5299971a5760f51f2d887f6300fae52325cb546ebf1194f7e2a543f2fce063541c6a6c6aeb2cfedc742abea605e3d3e45cf6d0977c4020d2e93ac84779369ecb688a2c49269072bad37feaa915f2f7d1498ce79ded64afcd4401da9bfeb295c5135d3803b247b2f33bb8cc1327dcd0bf116cb19979276ded5b9072124d0b3eef71d024ee72fc6ddfe1f10e16eed05aa791c4e2dae7e7371d8006797255800b9b0b235f8ea320efafde22f56835eac9f8715c35e66ce12c24062a993c3a36699b2c4a09378ccd03a566b17a820bbe55481897b753e86f39f5829890005691a87851ad6a5c6e39e9902da4ad34afb867ece77c88e15a12ab17082d63ae1dfd35c1b4bac7054f74e765274ade0f08599d08aa9853f8f00d29837a194b5fde11747cebd9c1820cf64997c295b2a5cdb43de1c71b5f38c3ca55d6d968484d7585b8feeb03c088c4642183bd11861d6fd36297d06f42beea6de721538dfc13db4cd4f174782f6afabdb303cd5fa0bd7b43ef83df480483483eac351e549433f71611c67a12177936abf8b3522b53308dd608a22b0db852719ad01db927d0d008fddeebf98b56dea74ee85f2e18bdebfdf2834754e40a3f0ec689d7bab738386bbf3465d0581307f2c4218c9b6c90d1ba9fec99d90e31d291e44b5b11c67c67b80e41a58b45265d22bbb7fb3c3a1bc9e3b97cb9fee85ccb60ced562120ac6342447c70e0a1dd4b58fd63706bfeebb4863968f123e45fbe29653bbda131bf0ce798fd523e5d87c8201b49705e841fa139b607dccdef0d3147d5eeb84b4e2a1a89d1f6fb23cf07bd02968d6eabc97ce5caa0ff29a56514ccd9c6dda6650adecdc4f8c56a98888c7dd80508db2e8f57cb4a3dfc403739d1484ccef0dd41f09923bfa916ac2d76d1c4ac192849b3a74baefc554226195f30f61918bf697d4e2536a38d5ee419b6b868424ae72f8addc423eddb8182ffda5150750d8d732952bb86766858b6f5d8822c6861e6f8620e7da27225ab8e3e5c56ca4a8091e60ca1d224b78727b1c904b9c08ccfd9bee848feb3f84a93683db089f3383be4447fc0d03718b7ac284fb107bbf63e5afa84317e17c18906ffa63cd5a4eee1a50d2a45f9db08f05084c8033c91727a792ecf992ee741faa46dc9bf514b64628bf47265508b7836eeffc7eef39ce72cae0dc3c795c462cd4866974b09777866e9fa46e0671a1134240e1ef10e72b73c3492a507bd3646d16bc697759bcdc8b544687dcf7d7c80503f3c9e6ac68b68ffcf88a69f396e6d7ec262fdcd806ebd8a0efb4cc75b854c8a5b60409d92a14cabdec9e63959b3b248f4a106f072633a0919934bda4fc8436577ef8593e8d359a9de5a2dedc44f06515cdd9a5e00cabe09830271fc0e45c5a3056578df7d3cbff7f250f95f41f8cdde9fae04940bf72c720273fa8275a4c7384f30594d6affe3beab738fd48932e777201e21cd21b7318df42d185717ef40565f5858683222311ed7bc1afb426a156bb99f461f1c3700f49c3a1159c83692366c506f739a2b3722c9ede550dcb2013c4ab0fd5a54c269093b267a763810f0fe6c57b70ee7d4d7dbb5a85d06807ccdeb547b3df31f709bf6da0bda48db1efc87131deea7ba7624e705cc9d9bc57cd27dd274184e18f32f74b35cec14ab989d4ba7e1884227a790384e8f7f3109eeb366e8e79a0ec32a3340c7854d6ba9643d038fe009316e23c1af351fdf06954d12a9c0574b46c531cad6cca7917faabc0dc822694f11ea00b8c20ff501c1b0384bcc94f8fe06adbc7adbe5a6a9a0d2528ae2a64e485bad6b2803823aa38076678a2b46b52561ffcbcdf048a1748f182b7857cbc3a373a5da9ba6b26b384a4f2fd4c25fa08eba951b80e843f1091022e7bd3736f0521a0e747af23a2149a4bd799c61b4dc3a466b4c5d29baef0f761a8b5c25cab361db71584f7b65490ad580b96f4e3f360cf277d5f326097d88c871630904fbe6f4b7d5547711e0c4499c90f8408b1f1fadfafd523c802e9bc37189815d1bcd9056b0cfd7b5293ec66200b625aa45ca1eb09c2179a09decd208b23352380501a70c8c2203245dccf8864c85c8c0d383ac4af016585325cade9c188843747d53e4b7e819ff2efd3387ee86ec8cb6d4fde89f9d5d39f87b574527102dcdd593069344dab60984d6c96bc9b2082d3904198b5dceccd00242e9c07e118219b472631e082c70f374b1db50b067bc9c12cbbb786d2d89909c0cb2b13d1dd52eaa6f450093cf580a8235500b1b5c4ea3917949bfd89a683a141531e268b2637b521f0670f6ec0f0199b1c3476b2c516c1d093d840e7c87f2a0aa0d0c27750c97b9c2d503c3bef0da5e8fd59c41e1b6ad6bbff98dbdf2d71d506d1568bb9b9999bfa1e78208d874da0dd8b5f91154f49a0705ccd0fc3d9cf473068945fa12fc1f72acbf5b6eb727c675b27b6dbc0e84418922e8a98d2d0365dccf62ca99ddb1845b1141265011ffc98764e575268912ff2798e029aeac89a846a5afdfed85b2098f4b37dd4c51132a18104d5f655e72df68628712d06298158c54cb42dafbbdefa8a1cf423da74ea5dc3f6b1dbcc8e587b3e66011973f4a5e6c124e766610823d7c338d2319578ccfaa317dc0d3dbcbeba21861afb5051edc41193fb367d89fc89f4c0ac1447a42979f241a8c563685653b9e00187fa940a7744820827c0858ab84c8e66c653ea7c409b256f3c6e6e5f1137799830afbaee7699a20e7a6fca5c1cb84b61aa1f62f97c438bb80678b929f827f5739620c2b8a493a1565b7bb93e6c07218d43c675f3d5be4f3824662fa75d5835a3bf8e16cb996307536f539c24116bd95d50b994f6e57c6cbcc272d337c3ac18b9652e00eb6cae420e7ead524c6f810b4bf24e8d81f412cdeca5298fdb909c9728cd5ec4a8007eae1b98064400e50cdf0a7017d648260a11c3887de26ea080e780e7cbe6ae38d806fde9595eb6f945c55656c9840108883e066a103e793cb05e9a7a842fb3f69d35a625beb437c990c5fdb4fb5620de5c780a06277c742cf30a61f83d68b1a033891b05b891d3f8c30f1c42f22478e6a4f7d9e619cd6218f7b203db0dfc4ae6a8c0e8dcabb1f380c869d0d4a9ac6919689854773b17cf6b7e827c75ede0ef961078284f5fcfce2aaaf9a6f8c3619d5d7217079188e1ee85f1c573b2f3d6f532750cb4e5f295a8f937a708462a0b3283a01d2b5cc2c0d91e3ced7af990556f01888538d45f4eea67d1355aeab583b19b70540afb4ad10372637471caeeae483d42bdc282f75cc0d13ede3bd8d01dfa5abedb02341bf3d31c234e14dded30f8d8aa6d9af6e024118b5f569adaa5864a2529cfa0ed3501fd3d4e48ee8fb80c23737bfc20a7e75f1a6965092f2626f2e5aec15b3baf5f3082eadae61733c7dbba0e7c4cefffa995b77d64c1f40c4fe00792d05311427b012e1bc83dc2d33aa5289f936c6a07013980c5ef861255e42a77141d2925d44475bf24d0be5d25e01804b640517f9278f0aa12970c69757360352ba07457a68074387fbc92298e2c8b1c1fb5b32b76653459919215970ebb53cd9f545c6660ceb8a82fc20484a33b5a8d6a43c15bb103e6d9363df9ba74c0566753c59d21f44f358c503dd66a7c6da51a03f8605096591ce65150e0a46ab0c4c229130f343ab1ceaf8a1367094ea3b2abd202b72b2159b0687f483bf4d3452e79eb4392fbddafe7325970c50302fc9fe6929123d69bdc05ee9d4f67091e2638a22d51f3dc2bf648c9b1856b39e90f3222fe3db7451dc7e00474d1aef413b654ea66b6f8dcf459129041747ff08131535c9799da659346f369640a84511f9ec3582a0e055881bc4b58a20501ba4d6b3cf2d35c6001274d1a8b77b4eac279282f1c66454f6a43b7ef6857a0ff54fdeb3d01c2d79ede1e96e91a27c79b4b10b21e9846b1cfa9d6048b0c914de053c98b752ffb0fb7fc3bc45ec003c529ecea7ab53d985363e9773a31cfaac59b8e33784087a673ead92011fd83d6c3a1fd32518c3b196c868ef57811ae67b137ef6fe2d246e45c5049bb732b34408148d95f3b943db4aa49f59e72e02908b09cc4a9efe6905871e376ab50b2971629cc9e196e10c9e10b1b8e2d89c474ace82b3248acaadeb3a62081c8e3da5fce4bf1d77753b8f6e9c9b806a303ca5b383335eab575934e2c9cb3a4ca29fb518a93509ebf7a7d26d442057bf28b47d6ff596a8f59a99278aa08718503d85fa073161043231a7451138efca43be6261fad6f5e38893ea71f7d1e040f00746e6a0c5fe0888efc52b8818c67b9f3e7444b989df5d99d46eafc0991426f741b89f4361fe24857fab63f9f444343eebfcd268b544d9af1a5660f4fe9b261eccd4c8c3608a22825ab5343548e435c65b5076fae6ab399877fe8db6f907b3313aef6d95777e3aa5273b57db955bf1c0e94a9f85a52284eda2cffe2768a7566e28f1da67fb2a1c6b8e1fa43a5d3c8c4ace94ffd2c656f7da020ea0ef3251e9db3b85806181339b6878b5cba98d2109202ae473ddb213c2437c6e56f74175c7a4070c4db95f4187966815671a8f94ee9a13e8831d07ff29cbd69a9f500559905515b64f34ed2090c844246a562c435f256b5f714ff7a0a513dc1f9745ed6ad1a35be98f385232fde350d199b9cbb86c6b3b66d5fb3e363c148a7a965d5b1009506411acb59ad0e12ad6b8ed0b2b811ff38b9bf070717437bac16e74c12ea8453363f62ee0f08dc77a8840e199c236d042e6b5a79e3095f057dbabc7cde0967d724dc5cab5f26934153fc8d813c07e54614d4aa684e523b91eae9ad26692716d3788194742e9d5e8fb48e5d4d60ed2810b26f1b73764f194b3a68cd84a73dec58fc8a38324243fffc393884e4054d3e7c3e7ff418d811b8b4317df10bf9567550e504f09d53a7cdc2ce305a2bec9c1337c5ecf71b5d7add466a29624a6c227dd105ee0ddc0ac827f95660f6cedcb3714e41023302306e824b86ac1e37183ae0222f15c200719982f12f4892e0708dfa3cd955f84a2a70fb07590986cbef0a25680a09335205050918a8290743dde0d6ca788b558b33e094395624b0596b3d6e5187784998b773d904e5890fff2f802af09ebd74f1b883ba6738dc8724e183f1b230832dec4e631edcfa9c19bd1277a6af4ec668bac6fa67bcc002205083ac91c916736f3757473d7d33924f82eab842820c72e97019014ac3675dbcc7a609d73ed991cb45f49b7758dad4ca0ba0ab75f9c85f17ce1595d989588af6c3dd5ac241985b768147ec146a3facff78f848cd7c87cc170ad7c8b4a2b0745fe8fb88ad51a46c7d0d838dd073f88f6fbf77eb996701e73c88f28c0bfdd77a6cdb8b2279ca0987a891d229d0e813e789b891f0ec6d407adf2162c951a8a36611a25c6f7a9981d49fcb9644553447963c700434b7045ba1b3bc43f0ec6c8fc0a099d5fd079856b0c65c39c441082a74366dd35cc9436059def56b2c28596bb028b865eaa029edc6bf97c71d174ac77cfa86a8ad95a7b8ff30fc3719d8ffc2a5f20ed232ba999dc99dfa26af14d62b5591030634b9eb975cf0bdf5aa08e71bc6d1b91cbfcd34c9d2b4029974fc7a50798a1a6f4604f091dc19f760cb52abe1bd3735eeb135dc704f3fbd787f88dc937b906b219dceef77a4ec2616a6aef56197354f65bb6745f67cdd30759fb86d8805a7cdff490ed052be894a421c1f1a9719715cd700f3eecab5215d5949dc7bc2367be48797cc6e7fe9eb8a4a16edef0ceedba4db52831519b61aec01fd7f2b0e49dd94add84e2d1265636ed91f307c107bf604642ccd4413a62ebac8fd61744f6f93c0bc73b978c10fd4dcbf9336aedd79b294715db7b0b8b99ace65ca2751d793ddd0c352406dc9739ae39afee36d6cc9853b52a9abc53fb2c890e0b93167d82f39e81ceb46a0cffbfdc1fed2bafbd574d3f9e976c5500361058f7ade42d8b23b45d58006bb3570caf3ead13d39d48d2479b14f13d669ad934ea4fb3b0302c48386997a1cf4a450f8cab1f9cdd2eee98089ea579b59164370022c54d892309fa60c4d5255a7837b7fcc8e46fdb22e67307681ae2d0c99937f9384d05d164bde0d75d6c6c00a6fa35e90c8b8be183a63647920d28045c2726e97396cee19da8df45c0b1b110108c0c72069be2d6497fe1f3d663d0bf9527170de9fd20d2395cdf59992161247e7d35765329811887c02d9750dc457cbec1e4223e112950d824ae9f5245ecfd7ff6a603a305121d0dfeaa6f119c5cf5d7dee844900dba7aa1920d1ceb52ea7f69431aa7d4eb3dc36d2345eb2022efd2a823d505a9ef32243f5e9f84799dac43cc20bd280ab6ac652f72dda7fbded1a2d950a487a82651372445fe6babc035ce16274c3dec135b69c565755f7e400231d37701257281d272e7398a6d9c631b7c4ae0c2316570c8787463a7277613e0def0ce1ff4754dccddb065e25f6fb55b73152b6c5b3ae88e4c97679c43300ab62caa214aee28606d974feee8f2551f090615fbdce3ed7bc4d46d892a4e15d2779e53b2345a26d8d39598be6d078ebe832b165c96403009fc11efc425cd80a921ac741d54bd6be0745ae31508af315aa0735e000131e2a07b05f7a7b13ab4a31fccf44cb6a75bb4299920e69e3f64a77334dd151f43f82095bd4ec65bfea8b6b5abb4b47d86dae0f61b06fe5a9e5d90f88d71333ef4fdbffcbdff6f256c97f088336cc7b867c83e1bf26634f6216f7e55ba222d8ceabb67db3ee3ab404115c7376d655c4a52f8b3d1f646f74ff5048add739dc4ee576ee6a109cb1e1a124ac94bac4c04450750a7cebb4fe07702c40df7bd08fd603645f8d94a424053f144ef1f9c748610d3271438f05917bcb4c88e78002fdef26a10c3f307814bcb95ca41556c9af69eea6cc1a94cb9e306d642fe6ff73b7c0a2978b2998900742256f12da2c237052cb94aad7487a799b6ceb65ff593af834d514db5a3a7f3daca738e4d0a7940fe1e8346abd53a7101ab00f443e86f9ecbcafda74ae4f8bbc5fa9464191262cfd58a73fe951ebd606ccc6ce82c1b68a2cfd8a50f4c9e952317fc1eda2a5cd5ead6ef2d500554c1ac505161bd238021c18e393c48aa402c6a0ff31b90adfb89898a1ebf5ee9cefac1b9f2d887a341ef17232b717e1809a358269233a24b34a70c3ef6afdc2d985ba6347f4421ed1c698bb77a5bf0f8d8244edc4f7dd5447620e4f76597280676f6a6189e5f2bf0df0637eaf4e0eadcb353aaace10d2f063c2db7ffa95908b69f59470e9a8481e864a463fd845f7eaf1e2e2009af7424c567ba3b5a3b72d23f2c2c967a731b2bfd2f93488e6fb7e09457a963212e40f6519f49c315e123efbfa6b3398c852a40ade3d4a54f9d438aba00255b41cdac11dd9d14707abbae76f7555a82acae7f6e484333f9b9991c7f565fcda322191d0781edc0e7b7109789422208ba196b0e510846f0643211129e96efa2ab987e3091d9d8aeea719a652d9b126faa8e38848ef157d73eaf09bdf9f98b394128d2e5969d1051083c7562a6f719a41d1fabf2de6d1cd82fd781a17823602152f77e356649cdb5da288f42cf174f526b97c3f0bd01a63fa80259d2b1d99d62383ef15db6af0c8303db624afb36174a7e2d5670e00086a0571d93839cd375323e6952830417204fe47039f886e7736d146ad1b530adeac862db131e64c3a4c0e80e313d5d5ec14c0148a9de8173bdcc41279948128e4ff4848f7a13df729a35ce55af96c37eb8ef2069f8a679221520216a4d989b77d604af72c346fa577f3ca87bf2bb2eb372fb18539a26511550e01124dd1689a8a85a0ee9b274d7d5a128b2b7a60862e36bc7c7804c904c44087304356781da746d0932c3bfec64961d5b1fde33b28fdeda0e7716fa00daa8bf1917bde29ce2f1b02baefe1ca8d17e918e64b76fb92cb2feb4ddcf210f823936b763e9e3606495ca7a9b4710dfb8fd2e767b582b6cb3348dcda860840e4731dca43310843488489a07de8e4c66cbf267d6a7aa3c526bdc2002ea2dc13bf98415899cf9f477651958e2ac59cd075c9546fe039ad4c332e229e8e3036a0e8b78762f62ea7b58cce5768f214df452e3dbbcc8b29228b731aba5e76fc0e017b082b50048220ba44c6cc674f8488b2d9459b1357af94f439d6fe4e26f81aebac62d37a7b98871f0a91da60e2519a2776fd3726c879e26440c631dcf18a1355a8c2a4c37ae73aedeb8027ad769a8cf971e3cc32c18997f0100f6a6518ca19d4784481c82fc1a443b0f2dd22f22621f120b407b1059bf6ab10148687cf6e6877f2ea97829573f64af1c00942ab1adb6111e8609b7fd09ad3b37809135ae2f0ab721a0c1fe0b76b9cdb4c1d9b9e053fd962f04b03e2d42229828f7d8c9b901fb38e57faa65a5d4421d34b0b3a768944b452a73b3d4f561634ea900ceca601a57198226bb67b275371f7fd0176fb74c449ba7a443398f62c34f810d3bdce08bd226f733bddca8c8a24d219dcf7d749817b118e303af0b22595b817e1ec6add80e1b2b26b7ec5ebcb09fda1221ee1921e6d17eabb60d487d2cf076ba7d1b9429bab68e7778324576fb7111e5d2cfcf5b94c5e52b20e6b613ddc161ba9bbf1a22195098355cfc678478a8fc852f2aa4bb12f8df4b088a6937bcfe6b16f4e605cfe17dc003d0d93bc482f1abc8dea4518485d73caedaf15af3f66ce60f20a74b1ad46d07ec897ca73165a0ec911d6ea3b83f5adac5e50226de8491b8592d9d86ef8e52af4d129006e8df1649995e602e6a7925345032c2a0895d96fb75f3e52cb7582eb6125d8e8f77e00f48b7f50a69d97a424ae6ea21b642f43e85d1de01f23164df6cf08f96f15c411487462170002d93b0a462848f6f6be7f045ee3e976bc774989df3d541e0189125a3e0e5a89f19cf362d97035312d6515bca62feb44bf014c3663be17a401e37115855a7edebef99ff0e651a7f6dd2c778c79d53f0b3cb6e336c2c39bac103a3dc76c4a73a37fa07a9e5d8cdcbabcf2fe86a1be2a7bbd1cc7ccee1dc962d1d07d32c899d8cda6b7dfa470e5a997a301b6c6bfb7648fa7a90070b0c87612e4473a735d737097dd8df31d37d6a123ba8bb21a83356abca043f6c600ef022de82870570cbc825cfbded0eb93d26620ac665c1739b3bbbf7f2e7b9f72599540e3d830135290030d610a4c046fc0cafe83795c8af0abf940e187c771cfda149478222b85b845426f316fc9776f39cd91d650e8e045ea049f5c27190b57980d1b403b6bfcae8624cb7a2f7ce8a6b68269355e88f331689a59ad902cd680a8a67166643c7db41034deeabaa68730bea229f9c0f654ad42a20ebc62e7884d7161542284beb08c2784c387cad7efa9f06f59e21caaae30841591092eb6b81ac8c484640bf44526791416e3f300b84b7052716bed51e01e5b31da5fd39821eb05f86582e9e898aa3f97cc437e537e5d8706431c7aa93f10093ec2b3699bd952c0f238bc05a6afe8863f86eb1176182d56d7804459da8ae47b0972b6e6580a9088d886f7c843d6c81b61a2df28287eddbe93fdb4fcc75bec4b0968d449dffab8f64ed30789dac25eb25af9b9d63e05519b0f806fb8a2fd3a162fbabd63a0b2595f2a45620656568515936700011b12f8d2896106e521dbe475668ba391f3a9aa2c3a409b84408b81ae9f83b2e1803b299754692a8ce67a5755eeb89efb93d2a6b5b307fa7f1d9fa7077bfa5918af587ec0d52c5c05f7124d470228a7d17795deabe7e8d2cf158d41a13d271902358ea1fb928268345e7466fcdb924dc0c0c7088581704d6306e479582b19aa177cb36500a81d703915f21dacdd56d193e197dbb8c66b048e79925103f2bb048cc6df0a6e5a49c9759138ff529a302356b5292b38301ddd6141c8e6f06f25d3ee5dd0b94fefb081df58cd068257b94e1fc4bd2bb1cf1a0a62be3037268851c763f9204bdde2bec1e2bb929dc8da3a5bb1d592da614f92be1658ae9f170278738e72208fab7f3a800580bf42f07f4d59cc866ffc00ba9a36ec96c4339328ddb52a48539cb2f323003483a63628dca2e646778eb085ab066adfd2e17896045f231338bf3b69d85a402d61f6bdc17dec657bd64f652ae9b305df162297b9edd755d397c15dd5b49fa9cd9b9ba0957d76961fee21e758e52fe5c580e25a9ef2c3606a8bd40963091b1074f6394d6e32ded7b6474b98d604fba60ebabbbd3681cf6db5f8c889b82de425bac58716606deff9207839c7fe35ef35cdbe58b0dd1b687a8ad72d979c2df50360767379bb3c7f2953f22e2a5a3e64a4a5172865ab2f9181d8c75bd368dabfa1fb9125f11e00dcff1d55592a2af174a54644086a8ad657eff1ce1f0c15528c8555cf0726277226862dc8ec63e890e604a6a6267564f86949574f439995c04433ac751098711170ebfbe388e573b42607aa9f540496a71c673b7f82442a5b81b93e651dac2318c5afa6f57dadc5c12d061afd0c34967d8d1ec1c54e6b2369d4f2cc8477330388a45a37b60e6884518e7e413733240142e7ee4a76d72a9bff54f0c45cf6a8753bdca34791176f69df59e95a4fafd9452c2f50162f6422fc363dc4c771df41ab94c849f44bb1e8ffcc72d45087078f2a130d4064bf4d643a4108d96dc32fa62b333e8bf5069853ef8a4ddcabb104e0812f6fa299460e28cd9284222f661ef9e6b3e5fcd12076d10024a7da8523977dc951f48a7bdfd26654a6d6ffafdf7d5a0c035555c45bfa0a57f360e34bf592067b8af4db3b603ffe79878e13fe12a47c5ed39cd7b184152e8abf857a04cffc6c30d3d4f0b74311e279756bbfa0a93f3a6886a63e98cb542aa5b9ec5c059516203fca7725e7abc581","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
