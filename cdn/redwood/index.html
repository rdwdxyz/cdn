<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"06bbaea323904fbd4563900ee6162143200c696b9fd9246654013304321a35526afe51fd3f2c97f07e7fb22ea7dbbb812899e42b8ac03df8264acca6c8b2e7fc69f60e11d475b9206ad68aa126fad11e66d1e722e35c539eec2c7738401528c6f7fd95102a42d648f1a2d8e72bd4755178c495100bc250a29189c7ee229c133ff171005772e9879db90dc21f694fdbeb0ac74914891e8026b87d390bef44238aa56ef673ac63623587b32e9afa2efb6daeea5bfb1d8c5e334a1f1ee4ec10694747c732a5c170a696515fef32851af7cf31005304e5aa796ede4a61e0ed1f381fde4e46d44240b9a6e96e0c3ef9d96a4cd91d6d61c981cbba42dadb44d3f79d74d619def9e723bd74e9107d25cc4f951a85833af8e2a655169b46e15443d8ba430da06d2240c0d2a6137e4e96a4aac524206be98bd32f954dba7c9d3668d662680e02c98a2ae5b77b34b0e0fed980c7c1edb68c7535031e7cd1c0e94cc7ef150766db6db13ab2cdb7539a6df0f63fb82950fcfe195bbf71bc921e6e890a22441310ebf8f35a33df531ac98768124dd0e076c95cb629438536d36554fa631c40970334e78400433157ca26951738c452c4ba4220ef30c5ec8749fe24c54a1fde282a5ae2cf78fbd7ae284f5753289ea72f293fe50fa96c3e7188e8d76ed29be57dab3fc70ec5bce8c19e1c5303b870e914cac9ca838950ef628738441dd88be189b32b1a831b618e3bc7ab6dd57153dc503905e79dbf92e71674a4e62fe14a47aa9db7fce5741a5ff97710534be8402deda85b893e7a6bf3b10e3c84fe065bed493725d75810f55ed2899c3ec8e35dc4f6adb001c7d83006e7874a6b305dc4f91638d1eddf4d57570977ca1f3a7a353b88cd07ca6557462240cb63ab6043186080205579878f160eecc100b761d01ac48fb195553098932b8e1d5cf838dd6c53ae43eff5afb84692ca42d3abdf20943e825d6c58a6723578b0492cfbeb55bec97ef42e0c2e080697a731081ac9105975450d51cd4171b8238f7695d518266653adcb077f13772ee03b4c3ece334b2d02406a5e9e3de8fdac6aa30d5df74310009077cfb90781e7c3139530d29cc1e640cb7f8ac77333a9ac44ecb8570a0f07569df0ae69d4db9304967a0c9fcbbf0b15939a62159d3ec1cf514944e5649de17fdce3d957dcf9b9c51afb14ee7a361318838a9be9c93ea6e18efc6a4e46bc15f361eb369f54c8369726e13333f64abaf2ffec2bcb579f304dd07c4c8ec93ceb9617d63db2fb2e2c6755416f18f83cdbc339eda3e9757427e9a6f8c39daf7bfdd17160434afd088ad1d30210551548b15887aa56655838851f88bfde338befc6234c97996a9735b470d4d991b39cc497027b063de5b812a2b8026d7aa7f5eed2f1d436adb3abf6b5a1fbf5478ead97d610334b063c18450bb6ac212044980e9b830e7683f9415aed24ebf65e386a4e552c9e1f1d09a2b2a7ef8d2fa104a3a96c157336ee45427a31d4595abcae191f12611c20a52bae42da8fdbf2e5e372f0a16906a770803811b9703eca22e5884dfadfd3774c579dccfe162e8dbc02996db04574a9a6cccf0d4d77d9f4c84ec53d1212648cfe74123fa0200141daa127cac82c331be5e79e899b61795d0abb3f9a984fa37507379add69a25d7094d0d70efdc90972107eae4a8b6c781480e334dd75d3b2f817dcfbecf5dc7fcaa545e7fb6b850d2a57a7f15116ea07a6accda944cdfb81498b0af735e9713fa09e04f9854227a3f1a3f3a0159c160616758b3a36cfef856c7aade1891a5a758454a18500ca8c50ec909714bebd814214ce79095a1115b47711e63826a1c5ddf1c87cb7fb4d17cc088964df7f9fa7192683455d4cc72dda758c5c5605871f5f518b1d99084d07081f79df43af9e84fa8f1dfa237edd5fea49ba117151ab722ed1f3a3a3749c52a1bbf15ed7cea413aebd18cd4c992823cd34aaeb0ff1cc242237c0c789772acaefa04313ae45bc83f4d0ec12d08a83e42edeff8543e505fa1fa4c3c11aeb78bafd704004a9ef21703fabb319f60b53cdfd84df9156e4e80fa4dd7648bd2290260995d9de7f88aaf54a6a50326f24413a89121f3fb3f518b1c2fa4ac713f0b9ef0f285b8129c2a76303abd4e6b72cdd04a2f3c0cf110601d82f94e50945e8beeebe3d5db053a90d9a3347f17b6b34ebcea92291db3547cbda8a83f03839fc939012afaa6f309b23070867bb740994119fe80c90b58f89ffaf201f9319ef5e69fa24cbd1f775e3f1017c1161b84b352af961ccce336baaa4030e966cd5c1f22d5164936b9a7c1920750d802f48f1b82853969cf0f26b04447f06bc02729faeb90ed23d4990e915a95a508e05cdf945d3477031ffe4c9fc9c14ebbda02461913ff1b1a31fba7eda1f807f06334e29e2b0fc3a2ac569d2076ee6cbed22ed1799be8fccabeccf08118d353b4ce56ab957dacedb61ce619724d2a467a14b03719752d1f2ce24d9e2a020deb22aba7bc9888f75f67d862d1837be46f3370c17f6d81cf3dcffe20178105c0856d95956c6abf71297184b3ee05fbffb78385b5856d2f5fe4ac8f2eeb7733563c2a36fa25e6738343187bbbd3b682773f1cbc8cf86d32e23d4e1d68df2a3be47aa48e9a98b73706bff684d6f4a6d25ee43edddf61059f4c4fdaf878115a38529b8245aeeeedd4eea57fdddfaa8028538f22d40c844b125e6ce0b608402518f99fd67b2301f1de32258440386771ba19e5324f6f7f275bd497b386ef9b1417309b9e1ac26771eb48d65d08d0da6e9656f81909eb41aa3af0dd428cf1da79397390e95a20264d1182954462529052c47dc97a47a61530c393246259cf8d3eaa7814ce8226e36f5e248e5190138c96ac6463a087ebfce41b47a9188ae6ea195e3b55fa3861e8119a788f58c19073b51f5cd5703216223bd4c0b02731d7a1488bf171f1f072c1c343a3ee4686bc6b594991ede307699652e1fc1a0d6d45f8e6caa7d7ede2aa7f25b449e5f0627c8fcf13a9a7bee7bd88f49bff4f0b644b57e991e4ae4f96e3274766b70b1cde0807571862a3413c8426153862c804728fffe465dfe66a48470725caefd460c9deac6ffe517d6205def148e4fe5ea6a6eb684fd598704a582f9c651de41ea2bc2f3014855a77566ca0f5742946d5ff0ebad81f96e310c85ef8ee529dee6e36230dd1239cfce7be880ab206193772df35df3879f2d96d332e0dd4e1a1a6ca69e0d2b366df9ccb13f4aefbb56f858e7968aded117063dbe4fd219977d78b09e7e6a6b481b7961f2a45f35b0c7ba61d1d8dd1b4143c33e614059888c8d421b0830e825ebf3d27507f57462501ec90494365c2c616f6b22d3858c09797ec4e71673bddfee07e45eb2ac86fa6abd8a87b556969d258f4ae21c35b601e2d0d7aadfd717285aaba3bb883b3b9e47242c7ab474b04f66c1ee50c234fdbd855dfe75a742011c726484012f7c6e753a1ee801a93fd65777130b706b0e800ebb1e4834c735d455894f193c28dc3a9d8abdcb14857b883b4247d56787dd6864b6314379df943beb5f049e5ab40dd19d101ca9177b98ca3867cdcff5c59510dd8bec432d78e22bb52c956e134bf48fb261eaca34bd3ebc3daa0483aa68673b02fb1a0e168b8cd29ffbb524c192b269d570d64551c68897eb824a020f797a65a059ba956c630cd7c31dafb96e66d1ccd52c9e22462d2185370b3c4e4f2466f18ffe1b288bbdf77b5679658a2497587139b7a84beb28592bdeb756fee6ddb28b9efd14d6ab77fd335c41d14bb660d0f5240e2b27fe3f6635cbbca0754f2b0b7f4161df9abef1ccf6d993bf258cd13b478d153846c4654913f91c8c6f9a74d6e48c6e8feb49c422090fd96868ea0a6b3eddcba0a991d9605383a981143e78d623e0ff0628f53f1002a847a96ad3a94401611e8945cafcda71747cf618585a77156a2470365e7a3cf08e1690ce26563912ee7744eb2350da8508cff1f7abd10a6fb46003883ef6297e78aff46b5939575ddb4431529b2a3ce3ed5194c9c4e71cb8b9bc188d6e28b08c4e6fbb6dbf91a6c7bf328b106804b05c186d5bcb4b3dc72b0f061e5ddf723f22f259bdf46854257216d8ae774b7c62612f771fa8679cb6321353c03c7cc844633b33f50922cabde998e213ccbd1d71f05dafcd63dab0f37f21aa4d697e4c731618f818074f3e7127b8a9ed92c545c57551d7e0519874a7ce324a71bbc5284989c5757f0601e422f0c731ca5537251570d1da89ada643b48b9b6da3bd5d223cf86ed842a6d4b8829a4500701ca13a6202084720f308c66e3e7525f4051de2b6db712eb1421b4423b117fd497a8fc5172de532ba63761492f5526386a87686122a8c950aac14f45b2aea87cbb0f0fbc9921bb7bf7de2cbedeb3a08e440d3c47821411df4d98328036bf45958d0defa0cf4872aed5acd6428431baf6cb45e0a2522ec4ec02c5bb194a0f5cfa0dac883fcb65ec9a6d9bc4fdc755b56ff3e9e69bdf54d05e7b322e9fe47c1d93b04bbc74e61bf041cad1ab977a58a01b8c13e23221c0d04ed1632ea2461c9595acebd2744861ba30fa09b7b4308543392529c3097c70b25e799672c9d414ccb3951c98eba356cffafc628037b98fbf5f5e34eb68361944d59b7aae2b428accc6f0670625c9018e746caf631a3cde826184af6f96d53b67dfbcee4ed7371f40d0de16993f3bec14d56cffebc1fd4798129a89846264823f593dadef17220fd71ef3678f3630ad434814e1d3f86e0224cbb63748b63fdf06397fcb62a31253ae2b3da6030b6f7950d55d7275beff95a2e36fd7862a9f955fda0939fc172942b511186724988ebdaaf9acea771b0988fae530a4709ff292e31b4cb712e53a6ca24fd6900fca62c1f0ab7fe530e17f0356ddae27e7d59175e6d94d1be7d92be4c2aa6d34441ca8df1aa2452d6f952cb5d4902a34db84985697767fed2527180671a50d63f7d6d196b39aeb69b0c27ef1030e8ac002705ae32358d1fbfd17735dd9ade5c50b4a0337146defc56b2f2ff6677740d0397141ebef9aa16139ab3825e34f900eb6e5b3d64086a1e0f6f09389621024fa7e3a85e7059200e71e101646242b5a5a49f1e30e358c23b7bd633ce406239a49971cd81e9a700c72dedea21a8d8fd5b2c0119c37d54c3ddbfe7df0f140bfd9e39a194bdf625b4ee6d4fa70de34e38299a3c7a4a399eabf63621e14e9d258d46b66aed6e9d9bcf576845825afaf7cab74ad9a89e77d6417e4d6634cbf92642bf0462fef0ca577a061d29945eac805ac28a63a980046fa90f58b7e3c04b9a05dd1df86a882cd78d5b9a587d90c69a72f3ba032e8c27196f8740ca39875f44f46151d4fece0cbba529cdd9d35d4770c3ca8e49ea80cac715d9bf6f400fcbd8ead81d5766fc1506222c22066ddba0822151777b7276a55fd6d24c2c883877eef9dcafb8fc1472da648885a944de6b7fada2bf99fbb7632bad3f18fdcde5a020f58e85a8a5b36b380637da67e716d541c3be22dae044456ca7d3fe9a474a147021ecdb544a4d1f726f25c9c507836b60e55b50f6cc68eb9a15b99c59e9fcff78178a3af0f2842ba5d6eb86619f45f7259b6665b65dddcfe54f33b98c26e002be42201b39c9114b5e38818a97b5270690ceed997c23947d5e4fe1066d324bf2ff1d2fc34775dcfbb4e7b33f2a15eb05b15b95a16ca417faa452197301c6ae952ada975f7d9b12d0424ad2c78b2c12fc248f188c7b90da44b6c8cb54b00cc7379c7ff79c0fd5fe5434d5602ba3f218158a0b9a72307589a7f3e8ac22c542c74163dcbe0ce42ce5c869c7e39d12305fc829c53d479f0ddbe0f92ec774c2e0fc5cccdefad783b4c02315727d7dba0af7d55b3f5e45c69ed5f1cb0b0ae36810c856b8527ae9d0c9e50c02c0e2d7e9ca857954c4d278f61dbfa8e961d73bf8df9f441a6d6f248f7dcb84034aa132f90a6c8c1301197394a4ecd77c0de6821b3a21429e4e4c21aa6a6434c8ee53aca75b44a4698db778b31c6c848c39e81fbee85a8c3942882fbe78ce63b23df39b8b7c121eca45b27350478b9801bff56f6c65964f546dd4a1e7999bf892d459644f7eaecfc5d375ecb123396accfe5ad227b931de4f2933cdc6a01ac7fcde95a1bd7721517052f2487cf979499a55ccac2a146ebba52a4971804e5e467787e373aa7903f7535368e710989f0b5241a34662c5e79fdfae97e7eede6f4389da5246e84ff2aa43c80e0ce4a3fe8b399e714c7b3ee26a83b08fc738cac24d98739051e411008c7a7632104a1b3b9230ab8ea36b3d1b9e7cf8b095f2edb5c99ed713284721075b32c8d0d6af9935e97d81dbe58e4c8aac01fd99faee2fc987b67c94a87a240d154de787d1566904d770e75e86e6cb0510635b5cd54fb5d52a0e89c97776087e04819bd8b550cf7dec2ba1eefd13fd76d306d9b997e2dd82d09a1905a33f3998a3495a23c2f140eb205454266631d534499b681596f77c16ee7169d23e8440507facf492fcb06e3677947d7ca7c4f72ff6bcabf0020b5d8c071a47e646975dba35e0b7ad78cf06343e9bfe10a8e23bdafeeaa118433483a47b99e33837c5862c53f0ee41776c8b0dcaf1725256ad4633439b1fd53306425a1fe0aa3cabc572268182f6eef1d094d8a4a57a35821b5f782dd8a80ee826a1cd51e4ed3724e372105a2ce969c6a68a3e4212b0c88c3f01a5050d3667aba01dee4d60ffdf06fb9cf20d458d4274bb350535dba50a0a0666f00ff4fa17fb7a2b34f2a820ba1ba7eef06c3152f255e00ceb38e4611182c7df059476c8307882aec4fcc4e6030278eef26e749c097f67c00c4c8ec41fc1995f6c156962e1efc1a740044a7ca1fed66002699497a54b5a0c5142702adc00b70fde8c0be5e425b397c9bb32f2ab6e5ec6c6a6a87b2cdf8f2645137263eb16f1cc6a172b187e055944d9992e07a2843a6dc5816c5c3250dbbb32ff39ad932ebd01665bc2ffb01164ceabff7643f0c76bf3b32006c308895b58de4070933b906936df8b3ed5462faf3f3df0f0df9eec50518e3059d44d8b83ad9982abb6c7e1cc46c1735c860307d4dea4f9f05103071107de556774dc84bfdf3ebf1b3081ef63be81d3cb1f2a6593656ede6ca4239046d96a9b1272cc732076d90cb75503d86a3573b9e3950d60dfcca4d9681c42c254167219b541bf6f50432ab8a5ce5abd65ff84a43653b98c18f58e795ee7ab26955d55497793f810e2f5fd7033cab1fa89d7963c9a10c98ca8e419be95c0a6214da25048330f8a47016e79d4365db10291398b30d97c1eaa20f432612edd7604724903d659d3161c387fecb09e871f6b2a03ad986fc9056f90042deda5c2ffbdb21945b2fea3db09c24a3ed5762ca09a2c1268d5aa045a9bb367e57c29696a8b54cfd1c9368a070ae0f4bca4e835d69f438564df5494138fcdcf89ba6040152c868f9ac5bc01cf7c76d0f92f01ae5e3933aec812db42061980e88ce0f4d2e0dfab2295827ccf209590142a7fcea86a59c4e565c3351f2a21c8cde1bf846a3f59d98e363b3da5c6c91e950a303361d7784f86a7af44f90a005b5f29759c6b039889feab16f91459728e04dfdaddbce55beff6e7a63f8d69a5c94f6bad8a32d5f9a1aa75c521d8fbde462856ffda2f4d6e777da9302e999cffb439904b83c8dc28b493c5489995adf9c9d5be5b64c3b02162426da15544f9be6bd5275d717f7ae1c1cf32553840165998bc1eaf55bb6209080291d0454508d382014c3c90e7023451d2e58649708e4521aa26f1cdff9df86ca3a12dd8e5185a2cf2bec72b61449c04efb9bbe66a4d7dfe8a7d363817da68df0374534083b47f66099536b81b0e8a3189ddd3f3792c481bc69b02b9a834d63881899d6aa1a2fb4a5a7fe27cfa65ccc007d6aed9c089ed0cc9cc0ccfb49d20915ad1acfcf9d7252f0d0bf7e6d9727233c34835955a6f918b92e71552addbe6d3f1671c550b05248c413989d5d57be8bacab8913b37d508d4a28ad1bd39436177c4ce623c3f3d08194992a74f021d52a529835dc7b950a7f80a8181c894338fc38326ea3ee2351d4e813128f4cde3aeb208266ae8dc77705dce8157e3818568af74744eb3a09f043e20a9633776e817a4b838107227ab1228c82a5978a0ae18b40a7348e01b6180cf7ff45bf9ac572eea47804e1b985033bfd9d3ded1bb34e683457fdb748bfaca654da1f2125d3bf047181423fd2447f4587f35809aa3bdd91947070ffd3f6e32ed7a2e953e567c6fe50edb233ba2bf9c8b1b7f21db3448a57d90800ae6b31f8e81b939797c20d79453d0a129a0bf835d5c88105b34e6a690b76136c9d1f3493c4e369297d23ff6442e056974ac83a7b47bcb4e56d89bad115d7c8234f6642acaf3101c5a7dbc0231a25f66a3cb2256680a0b03514a741648f81d90ed32b7904fda07a12cdde2f8688a0cfbcefa4ce5f7fafbd6f8f34e6f4299205b1df898fe7d675e8164312b68900e292476ee8f25288e35bf3d78637d21d584386cca6824be8d498e8932f42fb4f93d56180dd14aff126faa5fb1e98618aaf46b44ab21b0e4d0b088e4f2f7b88520404f70d74e65bef07712d5ef09bd527917b17a7fd0ad99142fc5db3a778d1a4914177a6693f1c97bf0963d1ab72c32df0a2dedae16132429c77eae6998a5a9a450e6c66f6ba9e03878613de3d7b869f39adc6ef60245844f5475e8547f10413fb3c4b7d7219d585707293e2d4713ee582d477c2e0875b2c7286aa4c29b3527684ccb6896341640d80fdc1d8fb2f5e847c4da7fa6358dc98a6e0d71c821e0706dec4ab14548c4f019bf3e7c369c0dbb702644aa1cf5b6b3b337059c6fd946361b7be62b7e724e658ea4f409c14e0af8d6b4e105809323f061c3d00dbfc54c627d6cac2de023d5ca4cd801063323d5ce1e978e37651609490c386bbf9601a3e475df6daf4831a3e5f31ca05511a19a837b348c8795af4df9bc6205d7970e2816106d959554c8fc0114d918b248b52356a4e303cf93aeaecc9b4b93c35af7ddeee3bd145276a2ee7c8fa83223871937ec9d0c04322bed548cc99eff18a1983cb32e214785af377805221d6bde6505298779b6b62fead9a9309f305ba4fbfb41cd6f9c968f44e3c856e9666f88e5c12529efeb7b97863d0b37d3124b4a208d4a1d0aff593afd2c5ea22752bc580e5d76296e04287a553348db10f464a8f35ac9ab79b9181c9b02d7913b0483dffc5041c6f862562a682c1936f3217220fbf3c8249b76d36e51f2e656f13f4b8273b4f2a94acf683726e60c74ee25c04e4c68d4f6518fcc7e143664bb6037ffcc609836a84d01b6a3e081820d4f7d23ef5be2fd4ab5751e537bea5800876e2685bf840b9dbd9512db678d9982aaef4271ffa1c783bdb1eb36a53cd4ed5ca7689de57ee58768c76dbaa7bd829d4f758c4dfac1128696794e08ac1f2a8d85c335601863e6170d46239e8318364e730a05c5ade662bf1b3395b6a852a15649895843380adaeed1bddf7f753a4a5fdf1bba70acc348ba744074cfd30111c531772937d0390bab6bbd5261e9a3df41ba393391611bbc68ed83c2e52e9c00de3cce9299efbef79a442572dafe76c78412ff3306f706d86629b7eef2c3529126d999a9cc6e73c5b523e1db26df6bfde3f59c0fe1a9a4243c09bfe3ddca80bd79453854275c17845b2675a787a51b6d120d525485e0608cc42523eb1607a0e015ee04583f8245586fbaadef34269e63a2ecb58784705fa3ae664878f8f6aaa3e0ec06f60d74277f4bc35a9d4219181c61ef1752fad03fce39ea9c3936da80ff65a002e65777a845ff8ac94b0650bfdf0f41c3ea353004770d3c089b799ecb870c2c464c5357ff9001f88d8671d1c36a768f85b1a45b0b1b0c9d06e91df22ee1e4901b42bbc46896324ac6224e77861a0af63befb9574fecdda62fd77acc5b4a21a7ab153ec141990c0df36e606b6df8f7c030147f3bc595bf10d8a1fb203496d3f11b730b002e0ee84cdb1f6b86a01260a10421021b344cdc75da604ccb747ef5f6d728409ce755451b83a42d1ed1ab8f580cf53d0baca5431032d3270d0a71417d60914393d46cbd606a86d9b4d04bd54edd88c0419fd66290892612b487adf4a008287d7e099181bb8bfaa8337cee7f2ea3667b0400e45fdf3e40c894538c9da1b31d2905d5442c2238ddda354d9175157e92987e771f64ff4ce99be92f3828e9859e918a874d070f92d7d88c297a8294910af53da8c3115eaf817e3afd5f9f5cc0acde8173a358bc38fd1ec56da5a642022235c875bd6b6d58819a632313f17af69fa2e2bc630bc8a3787d4642f16690144d82a995eb78d6963455a8a658e6f1c3a1519021fec7246f168181e1026fe8c403db3774a7a1272ab078fe01dfeacb0e0dd687ad3daadcfc7d98eaa8e673b812f471f3cc73d0ef8d185db2ef31c27fd5ce532a3aab0461461ad5bac162f9bb8120a8303e2ed1400d66e6c10e01cb82574ba6f858cbab16000ae1c1af2076494d10696cc594eecaa65e9afa54dfd71efcb3fb9688b36a47fef4f58a68cae7dc2444823072f1e821c2f876f7ae091a9ea34c9d25d9a3c1b1b1067b6e250439f5c75593ef116d79b03b57d8b79e76fa43cd2da729547aa8b393c2a1a40910a405df95e47b2e89e209143997d24b74462c02189bb897ed30a594750f8d235c17181395fb4febbd47156af3fa37aed9a1f846b58a6202347be03bb8ca2255e9895b2a701358bc252390fb4698ade34f5974609f12bced1263c08302a2fe4a99f9b306114dec17dee360f11ba861c0a33664c59bf07fd7bb4e08581c8af98efa24e532f62b0aca506117f918d5d132d3f30eb0321713e124160368571061e08729b30db26517b6e470606b07a757fc1e08e84d80ff303aa6d9c2a5023b3ca740d0dc0a09909f61fecd0556688f20414257c56985e2b3d34b63ceedfb065a21f47b2eb3f12a4c3f6d6a7d7b875c9e3698f6cbd6752d5dab36387059cc818748084202bba6d43f5c65c19bb82f738fe580db01ff903902a706e657c272f4b58a60e77911998dbad5e7cfd29f87f47bc7270d40d36dc9a0896a7cb343834fd97679db51e78a5ff890a0cd99a3730b0039134b8ba4a011d243ee46074aad5c14aaf361739842e5d643ae75b480cd90ac3afa359a5ea11d36866f7be282d2362d850c7fed29ee2f51932265e17778be732e968670b9f286e152f2a39c5b48a074db9b3af690d303d45c0bfd8af3c483fd67351d0ab835d26ef5007a1d1438edc525ce5beec2305087a5c249d22698c440b5cc8da064aedb453fec4798109f66feda2323849295fe7da1b04da7ff1ffab623ebff34c1e3680caf971434bba5f7e98fd16381e3688c704d25811759f713aaa431e0d890571faea78c7e08acd956fb25b0a2bc064caa4137b050f46b9ba69d3ea6bd5431c2a21e5229d5e8f6f5e23eda910c106cb07a6a84e202e80c13bc99e9e1f861dd1b6d18421034baf02a638cadb2a8dc95aad29205bd883b939d91d6f31d30131d69a0965c4c7e37964cfc3080c5f1482feabf738eb4db91837bee841f8db0f7145a7c5a48d303a4e4f9b585970f5aa0913e45f5df7a29e290781e17dd99a66b86f8ffbb5ff981c043944de4295e09fc70a7839d27915a3c069015d46b6a5a69ee061d5cbae6bb9d0b179705523555e50532b798be3f31f78ffe204d4c2b4c6fded2f964c17e48ddb0772fd1da51c2a7872f20373c98454714a8f64b4a20fdb5a7c1d17bb7f25ca3bcb1fd37ff20a4d38bb6e6e402734021fb0e581fba6521fe84c92adc69e37691bda8a552fa1f7d41ba60c6d457490f464843f61c275f647a03c0d9ca4a08b205962bb3c42e7272c1fed30b643976d50e0ca3fb1155f127a21528affb7eaf5adbd7bef7e015245888542221942ffa941761c5ecd0e237df109c05f6b5879b42ebefdfff1607b730827efa99b5daba4be528c47402436ba193717eccdf7886c6a1333d474d08fff0ba1e3a01a61bd3751934cedf911ad227e00e1cf77b35088df138d9e274822b3364ed0be1cb0a2fc91c169bb4bfc72706fc6dbc6f8a7a9099092124f2734f47f1bdbfaea27f6dfebdc099c66b05210ac918218d2e9c54cb91a649b83560cc729246bb44c8dfbc7fc2470421ca607179c0790647e17f6920b27e0ca5026c02fa8fd6bfa4fed3ab117fc486cb5af70f9f7f0dfedb9f3dab135c611e38d5cd0bc9690e0b95b734791f9107461274ef186cf09a7f6454f4a60afdeb2f4e08179defda15151ce9f72f49a709a61f6e9eae9694a74a8273a2024206a6c4cd72cff6be30d9da46aa036a8a194a0c2caf6e2d0afccd72055bce5b041639c20fe74cd062d406504a7c5641292f7ee2e9bd2eb69fd2aed1cb83118e716d028b879a6df1adc110361279a700e4e85edc0219ce8ebc15691a9606dcdf8085ff3a8fc4a397399277b16b127bef5b29e8e748f87a6ab506dcecab80a3244030519d94cfd878e27a92acecfb8d3c63369d694a8f24450afd6565632609846bbd9624e77cbcbdda9ef90bedcbcdfd074dd031ab2ff47af4f85f7b3da1de398983d825b28d41bd23acfb56954aace995ce430c30dc5d7f32d5f1a08e74162e3fcafc9af65ec3161981538cae0a692039484a3dffc5056312db694efd86b6ab8a2061a5c01866cabf2d194d65ecb816258dde23cfe299e4d592fb2a1c020958fb385dc9d4d13ebb2edebccbcba91adcdc76216dd649df2cf9b8755c63a1178ca1f0a0a798e34ecbe6ffdf20fec552b331883b74fda718c476da0ba333206a849a28a63a7ab385616c9b06ff3f3a6dde3ea1857d9c73bef64e323d5f9ab05c011722299b97daa18bf7d570a82cb32506247c15c9908c6d4e7b519df1f8ecad51a25f8d3f56782c17fd0f24ea1a3cf4222891ee53e6920d1155ea8652b4aac44792f16dfa25e782663d7b1d508d0bacf095416bc3f9bc550cd77e1fa0e89b15f12019fa945e8d2ab6cbb704919ee6b4ba96c2ac4d0104de72b85931156e10a31df0934e6b0af6064bb20675fe5cd8fc922fe9ece080a12bb73fdde6572214ed62d11899f10514911d680572a06c33f474568cbb7c7c57d7eca6253367a3aaebaac52eac61f9a595489bdb9f5d814a462a1473c14bfcbd664044947f00065a547685fa1615abfc7cd57096d1c5fdb7d0d8e3780f9c3f7778b888cab07d9f95f1063b3ebd1c9664a0613344446233c5627180ed0d5ef84ee5f6ad2ce4afc07ed60066cff04ca7ed54fde902a9b7f3e85d466eca35e7b1bd2b69854642a828cd21136a166bdb198ac30895e9bee4d442fd2df07fd4e2537f6fb0ce151fd83ad398956686d22031ace91052dfb34e798731ace72a2772ca1855fe7c8b41d323b18ca5230aca366f7fbdb005d5c5e68d8d7e96cd5bfe8358e072dcd9b2bd4d976b4e2e4726e340d7a537525922ed371d81622b3bb04fbdb9ae323768dcb31b99f350cb8f858852143baeaa62b21c35061fa4835f7fa68a5f73c1fa525248e9a5dd271c4b54ab219348329725f1b22f5b1fe8460b4884f16693065d081e90913ee55273545e8f5198dde3091249f4e0866053e6248186973ab6bd8d10d78f2171bf44fea684b64d678f1484c558174b24e40ed3c85f96234a5b1260b5cea8d5a173ed7255f9b35bc9ad476306b6c93de68ebe86e57f27a57e64ef36594e5e8bebe292f74fe9b19bea8fb83895bad7b5b3dccf7e9ba64aec5c35b3e6af3576ce18d1697845e12748dd6e83c2df9bc00d5e19976cd5781d2ecf94a4e7dec2393285bb22f458f9a8fcdadc869e3ce983aacf4a6c148a49f384fb48d71f61ecacb969810a11b2e698d77e7f490c447e9582a80719144ff31c30e96c159404fdbfb0014df71a18e52b1dbcb850c8be16f73ffe7c2b3d8c4bc46e9bb4f89a5d932d39b3a61ed6d77d2b9f7e569ab9f96c96ff10b8254cd17d052ecf2cf990bb8466f7691b601b20b4826be34028976352bda3ba5fd8476ec6db8d1953c7c93c559332d75414a53d332e013f58d7ad54bef2860f6c8cda48d5a4c75fede444a0749cc678e7f9d6aa7cb231c459dc1b4eb421babaf3a52aac7cfb81b006e3c26ad6fe426df7c20be6a079886f329fe62e8b705f2ed2b9d0f598fbbf8a8c6c6dd5b1cd6e9813addc9a2598963e283b5a51c61252b2f2f48b651bc14430bf634dcf18b2116284c4d8d7dc35e83b550549f9b136797b23ebe52ec2b7f3dc32ebe06fec75b147dd9e63cb25d3b6ac4c098c74e316f84eb07de0f3c0b69e99676f402b4d12902906c866f431af37a4b0d9bc6588937d697a927b8f80d7434c3361694ac5b3e6e05ab48a201fb0edb78d301f531f3f427d0e32c74eb901a6f75b5e7358bd6a62c7372d6516c194cde911ba251a247586a32c10e230119c4859e3baa13288890b317e65c926d934104ec3238be2fda5a4ef995d475325561db44165a1a015a40cd773d636aa5976919612a96171869bc0d411ff4a8604d76ea702aa2f695022afa7305ffa4f118c4abe60278f2e1af1d61f04755d7723d5b78565797c8c54b69789d04f753e4b64eea000a0399bdbb8217ff5f53a8b0fcf390e3baa3146deceac81fba4ea452f3d6fc883e3851aeeb6f50606f82c3a4016d431bfc2312639d1c8354f4f26c0976df2dc6f89360665a02e3e8871966f3b0e5fb2094565d74fcc5c09918a6de4638480f5b7a00547cf89a9f5083aa58c87f2444bbc65c433be28435100f0c2f3bce58b0f19683bf9d4d2004dddc6358d3d0582770341c27672ad827fd9962a5e437e9feb7903e7b807bb2eb9681450a39dba0482f30c21e60dff32bfd024f76187ca3e7d5575bed207c23878474ccc9e97990e4e240d78b963d0bbaa41a3c324558ff635fe20ed86ea1e6389a8eb4f24f808e83380564e82fa9d03d21d11a9c6c3b1a051fb60aa4964d0ba0fb4e88532796e81cbd5c6eb8cb64c8338d750233452a1256ea93e49f1ed93e98c98e3e5ec88bd13b851711223339df59740a141ea1271c38731a6c9817368f3ab20f4923bf9d0bd986d6b4fb894b5a8e5c2c47f9d2101e2889402b7049656917f01f52c3aa6db10ce2f8378600e395522aa98b10f7ae6b4654211cea87ad5169cf62022d5601c78170d13818be66a9bb63a08e087c5ffbaeadb822e3050c151661a82810d88e2977c3ba5495077e5b9cca50e3e754fa4c5dcfd39b87e67aeeb741d7b453ccd88d716d145467d3df64d27e37302e6c46ca9f616f72bddf36db7084f381bf32aaf29aa02e6a04c8468122d1d18b149969f42a1dcb8d584469afdbaf8e0f42c4de3935a01a44af072bd324a0daccc8e5ee623259d262a21316d547f1a68633e6a852777524272271884bf477a5bd20535a7ee3e63f6f779cf68f884b7088bfd150a544efe0a6be72868ea49ea8274df5789a547afb5463beb9788bfa66e490494287bd7aac0ee78a7c778e04e5655881e542128f273ec3ece79c4b9650ca9544ee863664fbde6ad3b068d07a648dc3b7c39a5c9c3668986cb7cb9e70a023c4033669e8c43dabca7b1e9a04ea3f42042b613f79a78318f8341942ff1beaa2449405a2122cf82c19a661bc4ff31eca981ba34b7885a6c1ee6ca5278091f4b2d326654b7b24831bdc34ef2a974f36dbac1b3bc37aafbc5ee795cd11c5d33556c0b38c63683f94c5e2442cbc25bf49f4c0b77842cfe9ece2742d4e521346772a7a980a8eae13db93252b2771c0ea1ff5982115d54f540a69b7c44dbd0e3726d895bba6980af9b29736dfd90be28f7bcdc815806a0f84b1b1ef359697badc5a84418b7e53e5317677df4dee45175ed3c9e253e71c37f971c4a5f38471d55c88a82ca67ae471f418a604ad4b6cbb13b994026b13000c823987d8865afb2546be5f2b02b28dbeb23f61083e0596afa2c8d4b5eb0033429221d5b79f58aa812f00f01440efaf4a22f27370f8e962aaa3fa2d870795759569d469548904ee9c1b9e57a2fbb8c5942a2d2f1c1b5f13c8834bcb3a28821ae35e6624e68d64fcd066ad0e97610284065e2ce31a36c9889ac1a485dcfcfdb0516733efc40790d96273d824ad6a13619ad78be6f4ba44b049b7260d74af8f86d58362845b3fa8ca59f114c1814dc05458f03af7a373194dfcdf075ba81ac9554601beac3b80098844583ccb73bc8add79867c3918cb3e00f53443b68b519ba479d0b0cc10facaef5e0821bc62872ee3355ac4712e6506ecef7c6eed35d7903a3151fa7983c820b3d160a87d74fbff437b6e9b38babae44ea5bc16d4fd3f00fa443a9cc7c2b382bc310a11deb090360d47413adb8cc9e6eccdf4727c4e4ea18e733c4b9acf836198a4d799f675157964b9c18826d34757bd79a02ec5ffe9be972c5c682e9b33e2d872f64230c142c2395f92505dc09068944e8ec86c84f0962e94c5a41a5a53d322fef8930ec88a53f5cdc7e6f6843088c11db5992a066ec5ca4729a631bdbd356e590274b2f51cf7bf8be1d07fd53ae662bcb7d1e5b2bdfef49209d85939c789b1733924a5605fc1316e35c2e22f74ef761ad2d34c68bcbd6bc29cefc934c1b2c88bc6f0b0bbba44a28947dc162c85260168dd8d5f3b8aab823612d828be0d438936eef13eca1dc6489166ae067d823bddd8ef301fcd99e144b824e4908549c0741144a81941ee53e5a7d34e95fc56537d89a745d4e331ba2029a8e47e44f41eb537e2ff1a16c9794772816284a736457364350d2533b9994f3471a9de6b5a784ec199c8366f246877e207e01a95a92741c8da6b3231fd254214d941629026ee9178b1deb918f5b3f287d2179a628c159f53b942f5f009b9672a338beb841797cdb354574450a7f9bdf8027085996b3c910dedfc82fb814428b4476a962b1743ffb072df47a8fea1e7eda55e4053c8c5c254b0221fed9ed2571906af5a0e5857d8fcf57792faa9915d46cca454fa5f29143097a939d5a20f966ee24aa7bc71b7a2a366fcbac5e8a32af4927cf05796a088892474ff59b9360ffb3fd895b0e0bd4a0fd485c9b2c832dc79ee28414518b79599dc7daa5b44a75c541e707411c0e60c3c3c587ce4ad4cd48eaced97dee7e802557d0f359f96612a6755e96da7a6c67dcabe8fba3d118ec4a54bf62f7cd606a07a1a35690d939d3a52631135fe1db6912390afb3ba02db9dd7c86a9587c244c35cac1baacf4caf1d848e8ca41e962bfa368b20e72872d7d7580f539aebda79df8df13b32d7352227729012bf76b8c61090ca4d6dd6447576b5f6da38cb4ee5f5167d424eb58eb66ae9170955693d6669821674dfc66cf514776968e7446bfd56d9bb5e97f106f7eec2b5c63e087ca5979c64e4acd757620ea7a95a17919ab86a15ff8501752ae7dbe8fc0ce6a5f4e44a29cf7b1ef347b73da8e31ebdaf44999c9e9ac89d717f05d854c0e9496c1b5168ae9a909c410b6465c12a04e446a834cccff3ef3b2acbdd3f5b74847c7845c29093b7ce91afac727f91b27e6b06452ac7bb8b3b9bf7cb6510d72f7ccd27a5fc18a25f5b80b4855b4752a30fd46116a71eb300098c65f4bc2cccd04c341205d7fa651eeb74d29ddf749f4866be48d17c23808f1c2ad200dd37fa8a0c187da4dfa8e4642cbafd80239c224d36d0bce6c5fa4b0fec4872d59c3cbd766a095e2eb8a21774b32c2071afca31803bf64d02c68ee80704b887942940c345a03122f4f85777d65acd390357cdbbbebbc7bb7e597ce61ee57fe8f95cb3c83e8f9b381effdb99cf2442aa7137cf445f44f526219333383e7b7a2102f8a0c56489c24e062f2c6ea57367f2fa391efdf1ce15bd0914904f9c71e42fb92face447a5e4ee84e22beac44756ab6a4815b8926bd0d10b1f30eabd6740278d515dbce85715786ba50a6ae25fe7fae206760905b7054853ca959bdf3675c8e7721cf24bfe81b262af5ede437bca97a769badc180b0c5a75d77d9501a08156af6a007a310a36e8cfa4f5e996dc53b4ca96ab0c49b4e96aa79dd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
