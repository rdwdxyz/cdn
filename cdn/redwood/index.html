<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb39b1ea842f1c01378265aa3998e669f59feadcfc1b2249541b94315e7cf508166e2a52415f987d0b52bfcaceb15bcc29de1d11ca8fab288c8db325d52149c19267bf7f4086f59a2814fb6917c0345a73206ee9482e7c5c399f2065d9b985753b7bcdbdc8e77f0a286c15f3f51062b5c0bf6a22a2503cedd2100fd3dc8a29f6d2e53282ab24a71673414e6a4533bb4ee30b32289f17b6745b8cdd314eee70a2fe5bd61565c7820d31495a56848bed89b7da5b0fbe7a6e116bfd563f86d908ac58671eaef3fb458e9382caabd6331bf1b6a58743c1b485732d2bdd38cd022b094a9a4b83fe120df3a18052122cf10bcf5d3f031fab83e40b9d640f1f7becb15594e5cf0b6fc41ebcc5f49603f4c282c818428c1ecb215d99ec352ba6f1d242bb8c7718a8a20d68d20a3b1f120d8a7f0bb325666abb151833d5c93783670dffe66d46aa2d17b1461ef67c4809c4a57f10ed4f456f14e16d599b42812dadbbf62c394efe7e5de2161b093191d613b80f6ed65283f119c8c1be3a367efd2674ff01d4b034be1b691855099e9820d6fdf66b7f01e5cd75baf6318c7538e00b69653988c2271b7d3e1083d4eb920e1967fd485c1e0ab682d019717763c87c6589a11c6e98516cbcfe96fa159f5af1a19a51b03a7f8a2325ac1550a3ff9cbb81a8674ca77ee770b33ec36f81cab4c9560029ca10ffca821df5d1459482f446b425eaf1c96903e7a5049aa7f85c4b934ebdb374ad5a3c8ac111ff484b89c5e1db2247029e2d3818ab23d45524b5e2daaf7d3b5fb1b5db7da7cf8377b092ebcb5823880318a2145ee622ff14f78398d57e74a30c83f6ea95256c15e595130fa72b2516788ac49129ad17a9d450b8f847514bcadd2e930f32670df26199a2949911fb7796c90c38a3fca913d80f3305bf45b6113bb0d8e67962c9009c547d87feb47d7d909c0977152352c850bca1cdba00cb18df767d7971ff67b05eb3833952619c9bea33a0f9ff99b27b57014c1cc39977767e81c57de5fad87d796ecb3e4b8617b29286c7196c873b3cbbf609613aae52bbf01675914b79f52672bae5231b52cf68dab324d6f942678b89e4529f9f65625a4080e9f3ab7e2f6eab864c3f21f02a255c83c8eee7a7b090196a910926615b8d3589f8dcdd95307a21997609cc6b27ae04e51d51acd66fcf98347005398b57a173a43795fb661a076d981114368d638277d2f4bc6ce6b167dfcd8e392e225e9cfc35504dc1821171567184f8150ef8bd50a6fc0de420a78d466ce4bb8e8ec33424aaa455cf2d3c618204f9f320e009059d21098123daeb143435dda4ebb9ecfb4f7647ac230852974eefe92d7a08eab225af0cd42894b57033ab69f216ecd1dae1d42589f4f454add78412fae76b1b79f9ad26ad5c7fbef053860c6742fe9689271cffb4b5e43323929a85de60e8e1965681d5b5deafaffb506e87dc5671b8a76337688ce4a8dc8184cfcfed971f06aa6dcfcb280a160b67d425ddce5e65bf62e34b0b6440aa124907cfbfcd01a6c361c30b2ba751dc654234fcf91a2720c68d94e1c2b9a0a4a36c1759ff24eb9a00a43131cc5616a103b876614072131448ae610d1e1bd1574dcac751943cfa600d3ed447fee7923bb13948fb1a2d00c8c9b3e79089256f022c8019c819e535912475aca6f360a9e2aa394d4dc69e1e710cba52f23a73e95a8d5299faf7e0f48ebee7e27ba19610cbc9ba8b59f5831c5171ffe5622ef5f606140b55b3c96213c2f47c4e1063c9d05136080adcfe205d9954efecb3a5cf9a06fc159e72a3055e7865f5bed59a69801e70fd9dcf5afefd3eb0fb0e2ed2c09cbf63505a5f58d97d0a30bee1b6552a1d37eea7e34401e0753d11791f45e65301b160cfcb855ff9e11c0ea0713fbe1c4737bf67dd9186f2261c4111f69035825e5b9d32bfc202b7aa8629c1cdcbd62498f8f3162a40b5f2410b88a3bb3a47bd900c0a986d93070849d434d07e10cae74fb69fe9b2706df08d019565772439989841f97ddef945a8d5bc59176ea709365c46e92dcdc55d21464fd1417cd668c06db5f44668b76d3f6fc170b4a750ff37b45c24d51925264d97a92ac48abab3f49acd0b5f7dd8b820046df156463b6a9b94c92e64cc92b75d4854bf9736cfbfd8fee722b38a249782927090558daa0c72c6c395ea0e0de6ee614f45309fa1a5827cfb081687c97595749e593f6698734cdc4072066ae709891cb10576637c2aaa4f576e4d6a53ee987cabcf794489e5b19d17cee40bd6cd12729ae69781345f0aa9bb67d68e5930203def7a973c6452428dbe88e7d8453995b97947a7c2cfb0e6153785b705ada890ee0920b865ae713b3c09e6d81304aa8823c429212986417425c8ded7b13ae0ddf7461725517b6e0b15c1dbc2f303efa904ef1f8054ec331d2b7b205dc36856eeb147fe51c7d5cd0961642b61f9bdc170b69207132af9c332de38b8da8501d8b130111429525028544f9db574e086fc370baeba9d44beb0a6672dd40302e2f8c8ec90c694026fe71593717dd241b3cf7faf1805978664c09abf49928c31c4810f77470902232dc09f8402cd1ce599a7f353538a4b1d95d4187107f8d1d0c4257286fcab1939b128bca82df9b9787be4cec8a695537ebe317475d4fe755589f50c5c7b4fc156e90c3674f090a8126e359dbbc310031417bd747b71b856e44bc211ee0b34899fe12196491c0760bfe607c48e0fdb56c74487ba35771ac08412e67962cd4e79b1335bd89510e1814c853d6d595c811d57849abc27f397679ab41342fb575052a413b13f1022246a7757a5269b9d78e117243d336e91d50859e365a81cdb851a04360665e5e9139716e49fc45949019d465df0c5ea3a54524057a2c1c00d02d702491d98ed6d1b4f7fbf08c7d9b2a449912a7ac436e98752059e702bcdb11b7c88b5d4c21b012682c9fc06063842ce391a0cf5a8c21597f10bcbdcc645e3e0ff8dd721ff2501469abfb18558438ef2c86f4d8ef409871d0c7853a07d558ae38a4421fc65b2fc556540fd523f1ae9dc6a33b35272595945a3ca0be2b120f0013bc48663df30e58ca14793d887dfa2cb8ee2b43c820126bd2c5e7ecf10f7361ca073e7d9f590063eda86d33aeefd48d6792370d6c459ffdd52cf4d2878b663dbc1a0c9855526f9d1f1398889ddfef0d38308e42c18e22cd70acad4b68ff77ccbf5bec899dd2f1f251ce55f8393551ec9fbeaad7ffa0041c6c462c0f5f65bb9ea9b1afaaea009fa67a73c90ecff7498b961b62ee6743e3e3f3a115483478759d1dd3421902b0c27ba35a101006823c65185bf1031578bd74421b82cc7dbfee584e68999d5e982b860e02faed51491562c81a41f5f7a0f7e813bfde08d8eacb24657fc2eb6ffd6f4791eb686fab55103a6f89ba2e30a2c38c8e2ed335f1f38df146eb9fabfe9a22239455b1db01e669b994a01625240798f85d38f4a723d5ee41f24e9640fb98c800f068727c279a9af56a623be12a21defd8f1d9bd72681155a51ae34e6826e63c402c2437eae862bfec12664e2604b15e724422418fbf62c428f27a799ad231f7398f0127ca9e6ced14ac81feb0ed5c6bd83afbd0739249f88699cb284785663e5f0f4d1c28cdc5ebbd4f552e9294979275bbd1e2243d1c785492670fcd683e74adc5ccd6380c4cb62e45fb19022ca397e189b727cdab76d0f3d8ea488bcecd05d22881ca4385be2aab2489a508645ad6363a39ac2827b1985529e6e96644635e85aaeeb7cfded02908f1903c39cb1d5b1294cd5ff33742afb8a7ca5ea5fe601227fd78d6538eb63390d9f98e4f4e335ed35f6445d605ff53743c4702eb32934bcb64db4cd502aee37789fafde39a9d8282c2bdf92280b7a5e41682d89112d1ca947fde09b865e084eeabcb2ec30917b9e26be9e74072f683a06d69c83cf7fa43d9f93e1f8dd5422f9829dd0cb5ad6ac66b4d500bc4af43c53ad83c836d240b3629af4f601d7f1ad71752469861a9c72de3b813506230d9435edaf1d8fa467ab65d9bb556542c749842f007201397ae7e37a51155b3b97a271f532bd6161299a32c4ea9cad8f89df06e66a284a0ad02e5476ef62b4788c8c8fb89f4d3b35223856fc43bcb201316bfd3b672d4d057e0c8695d60f070419e51525bfe4087c4fc2d24cd566c2517b743de2b2901d5ad238be18e74a0ce3e399ff719bc75224123e7a40af49f28a8777022728d3601e5f4191409e1785c068c5ab3352d66d72e940658b843c63ad94f3ed7e8b9e0b0db3f49d0d8efabaf08083a1e281bb98c37727f329f053e72d4b5293876958d7f63941f8f9ce8606cfa0de302142b949e02d4bf34258601f9d48cc9b3dbc3a0dc16473a59d4e2c83877580d23ecef2ed50eee363e89fc82e54d59e77e1a744a5be5fdfd9626b205496d6764b79f5e96b12a20bdc2612a21e78441e5bf0e8860dbebc9e71aaaae805e922d9983d49f3eafa92db9444e13ce75c45bf712d0c9407b1086bb4fcedd16e5d7515f5999ef02650c4c0ed3f1d0869b8b717629cc4171174d675dd1665dee874ae5d6db48f6525a486836a124367f5cef33d3c9245bea79501594a2f415f5647fe3f07c2960ed3dcc39f667c6b5baac300c1ed28d75967ff6a7bcfab1ceef2e8480d764671fd25471573f2ec129995d2783d9178111697d1535a47ed47d490744dd6e013032854859eed06ac85eacaaff785ff5bf06089c1497842457c70eccf58cc5bf0ee1ec50a4c852b606256e5e1940732948c43f36b79f9a22373b0b34cee9d0712a7e93ea139a4e033087ef485bad9d829731348d953423352ce93a1fb971cea85c0581ea998b87e08049539f0800ee2e6808749ebe87bbfc48e698b0eb8156606ff3a56403013b7009840bdcfa5c46f499c33a1bb4fb32478ade90793d26bffca87060f39d34132a8a7d533ab6c591ecc80e930d84ef003b7feb2b0b4d5f4b4fe2c42ba945bc69c43cee51bdeed653ef93ec577bebdcd0c28285b875dfa051ec5afe12cbf517612351b760d1e8d77d0f41b37a1d42fb11228a2cef6bd194a2acc696b4ec571e643f7238c3f342a7c492ca9af7c8deda4dfee62669a6c01f0d8a3c65bea4a9dad98a32ef01de9f55facbdecb9fad8f00a9e2c151a6c24d3f8c58f7d816a20d52b023c1bc779e9effdc67b4d6f9bbe4ac9cccbd7ba0498b92dcf2a387ce2751558b60bff4677016e05e6b607fcad3a62c30cdde0e2b02a326964244000475c3d2eeb9d8ad9e9a9e50f8414b4df92a14e22b0ef6cb4ef04c43f3df6b5d5fd42f68c459e5eb9c2e5c71ff788f8084b39a5a7b456dd4552167cd22cb2685df378bb981fddeee61a2e49d3b7b92eea59e9dff14f591e129152ceed001a33042e208f3044a296f50ead53f96e6f71a7dee1a5856b65f99270174a5c0dea5922b3e6d185bf5ae949a37f3219364136a7f9ce28249538b4b93f9dbd401ef19ccb47eee025d0fc38b3146b40cca1b7eb2e51f69e5e54e28ca263254fe2f3f89bb3748619745cbb51808662fa994c2f718075b41863cf9e5490d3196797fe5595dd516e589ec9f7fac5004f78484e86101d1cb0985146c4753288051b7298913fed132f212f93e9b90a0b86b3cbf42e277cd43c337fb1c00a1f11a4d91347d2131cbafc6b8d81838d81d6040f61a775276e7c73d427daf4d5cec56f229004ff31142ab4fe881a93515416df866cb118b5b8d7dd5b9552ab8ae9cc604e6fdb19aa16635b10d5bf2abcd7914a81b3828075edb5b81f82564e22072edfe9cf67ac4caf39cb1616d60c5f30b29712213e813f5dbeddac0af794aac9eb40bf0204922afde5dd87bda8a57705440f95737117940f370a9063dbdd82c6bc856a25f28cea0b0485f368f5bad59e74d1b68d7398cf074d1a4de4c8ad845c0009472cccf3242daca7f2853981ff200788758613a2a053e5dc5173141cc2c134d89ac18fa8500c477470a3b1e39ea6139af52a17bde532548dc5040ef4a1717d7f0d96a3191bb0d774e0a33eb813e787693e9780d2a820c766089acc45bed762ce347d6a40aab37ec1cc2766e893c5547808cac4db479efd36851b9434c917dea6c9580ebb9ae303457cc29765fe2db9002a6dd4d8de4a536d74d0a7eb96b5470de7201d7d1993b62c4fc8d8522ada09b505fcfa0f5723e3d7062b74a6396cd464e7dfe18f01363537e526a672b090032cf05dd9b33b30149b914262ac13585d127417fd4ae4bf792b815517f143405ab3a129d6eeb5d0e0e98dca8a7b84dfe4e4063889098ed3fe1e316fa06d4ffc0345e71e6eb75e8d812646602c4c5c09a31a2ddf95cce83da0dd785d5049322684b9ff62f11dab89877e4206f5494dabb5a4b1a2b95d64164cdf29a6067e2c1c3ee1f3661fc6fceb937fe3082f7a1609a0e4d89ef32dedcb5e2055c6fd7ada5a8e8dba9b9d2df800e6a719baae7cbc21a8f68f2420139f74e34396c746ea9ce1713382b6ee46a100d35133b72d5d00b80e0dfe92879211844e7bec2f4bdb21af73ae47c28436a1d0cfdc6a5fadfbc33cfcd65da6d5a9e44ed1b46449e6265293a70b04a4622fb10f3dadf55527774fcf47a5749df6c14ef2333aad97c78828e8f47d3c5df242e60b2923b6f338e65abfb13d63dc20c2dcdf657cbe2501545641b31e41e9dd872135aa3534f54f641ecdb9dd76b3b60b7a3677e32edfa91720d94df4d1236d24445e47ba6cfb0300960eb170569f15630c6eef1024b1cf4913cdbacbb99a52c3368d0f11dd5cb575de8ec37bf3c6d0238c5bb203bcdd25fd75889c6f4a0bbe2035ff71abb29f08b6ce9b038105471ce476871ba3e7d35ec9de9bc2b10780c3997fa398f432715d076470d340221939b0e1fe6ba07a619d605a78aca0a40c2e5d1586c6ca86930b789a27ccfb1a96b66a3b11d6ce0e055b11f55551584fb6dd62baabe9122d7e4ad00d57cbf3def0072b207f7450089d5246266b554e013568cd0bc7554d923dddf31ff17b843956b4719f8664860db0d5ab02cb6b55895cc3910c5540668a29e89efc95c5febf6f6310f8dd7dcd0029d73b7f48e41011f757dc4e53248ba7fa4ae583fc0047df276fa8b426461ef6e7aefadb042e47a5e3ae18865c42b7f13175653cfc341c28ac371571497f31e9d491493bc77b01bce1857445244abbe3165e3060701f7f8e3466b66b1acce596379442387a528ebe8a7113f7ade3b061f63977d4df5fbdd4f3349266fd2e3a139753ac5c27c30958fab6773eb508e11100c93eab122e49b6fdf473cc048f016d87b21a4ab68b4f518e243b2cb14e8842222e36131c331c5d3b365b39eeca65be333089ca9b500854063a7b80018e5c0ca1a8002decdcf7344cedd6c1b45c7b28807705cf982d307604213875b21bbdada7801d9b908fa4a8eb38cd546fe69e03e6d58a87b9b61dd7d35cb3dbd2c63693a1b3859a2ef79f0666e3be65d7ab42db96a959d2a94851235830a23be770d55c174be44ab967894e92778c7016e138a097a418f12b4d2e70e177c6769134c0bf59521c2bce33bc00905f323ff2598cbc979a5e9fc2795230aa1ae94f053f077570d045ba1845053c965fa7cff3553da1b4a2e3fdf1fcb15e67bd4016cc2ed4080586b5c6fdeb6d69608d9afb005fe634d979906f6e09a32d4c50078cabd64c678bdff92728033be344711649450737c5e98ae1594a55f21cb4274cd48f6eb096abede65f524409453afc766c49e6a207020035d946020c0a430887eb86dbcb011efa74ce77f862c927a8bb70cfa3cf468da69bbaad6071d943afa6257290e381d2e8331024dcbab3fff52f8d299541fe705cd70167c64dd286c5e02ec1432107be50a93523a6ad9988e0427dd3a67b547c13848f3f9372a14172073429acc3e9a17fb4b680997608f699a0cfc23ea95bbe588ccb6c0787a5690dc2998239c12b7d98a4de3f9bed18dc91100902cf6b1a0bc42bcdf1f9f2b053f1b049e38b480e83a2a55fb83367516711a5108b5ce69a23b5b8a7771fb30be71c60b5c4c71b965178333a51fa800e986986cd82f3929999ff0420e1ae4800a2b9b3fa0e131944610a17d8a8112b3f4bd969cacb9da7e0ba4f1bc12e8074d0245cc0e82dbf85a074378c30216349a07270ae5da9ca8246fc25f2d6f5b4a03090d9383d6865566e7c706f10683d62501d5081c9243c3b5ba9658c75e2e1ea43236445d32a373d2be28c2eda85358da7c8f78bbc32bb6101937505cf33ea0c7ba88c2eb84dc761c9ae3a6505a680fe6152f5c0b16a6dea23fe033988aa6523fccd5ee554483df7e964ae596223ba19f5ab6dc67fdff4eb1791518a71a77574ce4f175f212a762a682de0838e87058f796f3a37c64a3cce0b1b60517de29080dc02ddf1230af74fb37c1515bd1e233dfbf03a1a4e02fbba3ed08deb9f9868163cf4c47bac55e12431526d271186de0b63aa2ee0330ec40420c65f22da090ad2713d655a4fdbadc1b6e4b895094742fcb79c70f9cc4a778c2faec47db4867d152d90ba5bf8bacc2b0634e097efff558e170e758c72551ab7508cedb2c4b6c82e64a0b887d47878402f13a09834bb447c3057c1b37a90eeb52f6f970d4bd2f5b28f425d6d5cf4a151cbdcda0ec6b900e5aba891a4be58b2df99aac7f6729af7ef84d245b454b0c3ce9591e2d18735780f0380aae09263901f0a47c0c7d234c3541c5dd643c1b67e11c22d8012585ba9c7ebfd9112dbe48dd56d93824321305763c50b236753242fadc1f5b86c9ef87ae279b128a883e9a57a71bed7d12cd58012ad9b4934823288a692ff2922a666c06d1f9d83fa8a08ddc0b20d6165fbeba7908ee4d1feda89133c0725119e66ee14d819f82f877d52b05cf197588b31f50ff1332a06cc61068bf02047d1940243f753ca22fa7c40c517e56e082fbe90f6ad85abb927efd3a67c458ff1dc2d69c7e73011ac26f5af6dce3f19e5cb8f615b0abb0f62bcadebf1a5363d4abf0cc17d98958a97f0338283af1d84c0aed530de02d030bb5ec003af3fdb52e6379cff234e4b7509738dcdd13863abc49131eb478561aade117a551857058a2e092a6ad7e0300a62e2810e2020b69f76712fc717e4cfa7d7f287f8b515ef61512c12836d1fd362cc5fedf7afb80632d2567544556eb5d6f02c268a5c4976be14429b23e060fedfdb7327da68c008809c48df1daf00d25e06dd9a9a18c88d3e34438ae80928f0afc3e7bf940a01a15b68a6e24e6ac738f5f830bedd3eaf568c1a15bba3571aeb207d2201ec966c1128f74459a17923b4f58aed31b1cb132b4b78ab15c35afeb183ed8931c765d7302313b2691d0caaae833f8e6ba807bcd63ac1dba8fd1c4449e2f9145c34368e49069a96ffe21d76dfdb6765bdf1901a954eba4ade5bd7d276c2b89e67c7a052c391e30649e5d864e63a66b4a17f43f794f42d56a2fcc4622bb4ecb1973361e841a17c755f1a1b86a36e3b0a4b14482dd1217f1f5f18135f020c79030562dcf3030617575ae3d2fd367c4935bfadaf07fd0023663a20c668970862e9501eab336eab2e0c53d6c32bbd493923f238c15e5e6f66f1cfd71fdf275f2a333928a757c1552802ec5ac9e806b11068dec09fb7dcaacb1936313b9b08c5e47ed16a73a1aa9d4a68ce4e382325ef5394ea65a7fbc60f5549cb9fa3f762d2c8f4fdea1c9cb4a5fdc27d024f4686d5356145cfab6394c49618eac2705f01770528aa1a32fa3f13788d9ccb495bebcffea09903da13aa278a5bb3a26e9f83dc233864f82e22563f5828d2177b7907477f27a0dee987fd8331563563332f6d6627c9ff75689965b7e91cc93f32d0843d8fdb6933a598eb7a6d695485dd37b6d438faf98c76fc3b208291d84244578e1632eb517435dd6c9b81d469f52990634d549644022158e05623c5fa8336b645ff712f4f3eef0131ba119bc5000f0d8f2f33da0bca101637ff0e025d53f83eaab780652f2440f535b5cacd20ab74d9c96fea12e2a560f7386334e151991a6607775f97e6956082497a326bf3454d1d8d3974e2fc963e2f75affd3c28fdedc33746a8322b24a261ebe2662598f9c55b2ef09e91886c47abef3ed0a05ab9470ca83eb99a77795293acbb4462a7d40ea837db675ccb1150f0404b42bb9ba872e5b0bcbe902ad72ef52512478f9bc96406b2f3e524ea180fba10492a6030eb1bd045c34d9d8204e5180169bc23bea588067d1d30e6352cfd830ec7682147259fef911538f2f919da30afff71871770be04500d57fc189cca8eea8826e3ba1a92ccf894b82d9cc69927a5b88cd9e6142d8e89342a81086bb85c020f797d2de7aea59b2ca141e52198fdc29bf56255241150782e93bbb7321ea5a1928a31e30fae2a0b9b9c93f3089669991b05e2d52520e2a2ddab14d3fca4a156ef2435bc2285789b22ce601f58683ae3265a274c060ddfd1f456eb917a8d0018953c24d93a4ca83dace9ec752b1aa440b55cd51f48638e7e50247332f9bdeade67e78c1dbf74d776595daf9e6686f5787ce7d0a4e1cce70f2cbc4a45417dcbb30db6587755d64b5ceb5fe5f7297e2debd30265838ebd3ccafa073b5b663c0ef81d4b406ddcb6f40974311b065adb2897994fdd0010543a305efc970e66811cc911c7f358b61bc357cd6ddeb03e4fbe4471df8e55bc73e89551d2d297fb5f57bfd9cbbace8852c519758b872e17cdc4476fcc9912a33ac6f70250186c310018c44a2dc84c01d7104fa132b1e69b2ea6c43411772763d32516feedad4d131278807ea2f7eac726c71be3c138bd8c2b58eda13fbe0d0c6aca82a44ea37322c8fcb35dba7689b6e2b538834009d24d6a92a71566d155076d04ab5a2669d96f40a9e83892b2f89d4083303f298252d23a06a902e1b1fe6bb429186bea620e495e026b10493f7cc9f09d381e8c6ef55c3533607d52434c3d0cdfef664327f782d544d305208cdbb2f2e5bdb1bcb8e4eacb82ebad56a4dd22b08cdc767e297d36dd923230165cdb6d1a49ad5ccf68108ff99b916c7d02308aaf4c852e2acfd3be4b19c79526df238045ba25ffadb453fd6ed112961a20258869683b2b5884fb100b1ffdca047dc0c99f941bef7fc35a98b613e93a45baa585c9c4d9a9b67ad568ab3e93a593175acf38d63dc8cfedae99fe00f39bcaa9991db044ff473be762210a13ebc8cf6d5f154b3ed2f2382bf281dbd7fc56714181b8151e123fea62ce47bb9adacab3bab2802f66673e1d0b646886d03111625b0d667feb8985ef383be888e9a40a99adb1f94f92e67520961b3df01222d4658f7fd43714b987cbaf14b2b53dee20d6f2d725419ef5e16c8d2d8ac93535d3ee59deaeda3cbb937d401794c78762f1431128c6f61d5f637c7aef3e2fc71e9f92da20a1ea582a4f1a0cb2f17e3436302d8f045bef7569b8a9e3fb08b7a8ba7058acfa1055714d6c8d1405b91113df61ae77a1f3c33cf182a8006bd33475f0a87c46f6f99de2ca2e5ae798a5a571a585ff349222c217b8048d10d9666d5545895fecdf63386fd6b7bf682e383279cabf12b9bb380b074fb366832acad2ab474b3ad236375fa12fe7a3cbcec9be7c3b925419f32a927e4983b7dcf19029ca2ebd813118fe4a41e3e920cf3823fefb6b25d24292a840d72feadc20fb86a51787ef90541f2fea24cac61a694d7dfaa070baf5a650cc469e174d82483706b10fca5e945b5ff52ba2e79c9611d6ec6dc1f31ba8fc58c1c5a1e6f4db0e864c55762c50671a956b753b7d8070986f7088f671298e06b5e4d375b299284a09207b3a7b698ac064a1b84031bf411347beff57505a2c8c7994b3ea2d7c6354658bb95840d818ba37c943da09580fc1101aad3ea9b1a079dd9dbde0f06a2944c38d8f8abc866b5e6a862236211f8a615a2b865a7bd0a0bbe9a887d0b893796943b4e4ba57e11c8b7020c3b13ae8bf545478fa95c43c042099664d8d9b8144b2ff81b59fe4cf531b4e0069527b0855efd1fab7406b697ce073f2f3630505a702b6531f65b3f9f60997c3edbfa4b10b5c6239330a9fcb4a0f06e25fa4dff55e8a0e9e595e1bdd645c045b1bc73e4f198571f5ba29024e5acba42834d28502cfc262e76c3ad55205bf16d612dec9e18c6c639fcd984168aef815e00ffe3c3a05b95c1662d35a62f6f4229221b41a972237353419e7fb8c487a3827cd31ecdc89852c8a37c5ae7780d7d5623af7c65fa9f2745fc5588858dcfb0b184bf9f9c31429636dbb670e424ada92dc366e9f662755f691ce8a3b88a164c696d23a5be1738df3e8f34d4014fefe13430ad8dd20a3f36bbafbd544a7aa78490b213ee3d06077bd80959c8ffac4ff5da108a5b3a286718535d120372487778849f36289df736ce290764d4bff708f5cdf9cf09a826f9e452e5eeef4cb3c26aac82ed5102fb5f36ea3d8848de04c256b0ab6d02c49e2ccd6565851c3d7ebae4aa5525199894775fd49b7b5b8042b23b3ab39590fdb65ab0c54841bcef9ba353da33b815265cb2a8250f42476d747342233ba2a70a590610439b52c144f12f416a8c7633a965e7ce756c0066509e43583e507a5742ab0c0a6480302a56d653502b6b226ab1cc808cfe0aa4b02d9dafc86f8d1ff2dc7a8cc62e11a9cefe3aac20f63b780b4502b407515968b0ef05ba65baa1a51ff4f5acfc7676ed30ce13f891a96c3b6ff16503d987419af941a4d24906c3307598ff47ab2fce1eeb140311584bccbfdcf637f15346f15d5693624d3ddf75b56dbf7a69204b98d362ce5ad0b4655b6f7d2940cfc84a24ec0b4d70e5023eba33c27a84f4c01e80ece239d88ea1dac5b2966cdd66a8c30a6d18442afcbf9ca019a70ec514bb48d4795e60dab1a9dbdd4e832fdf5a18406811ddd60366757f8f0510018d7424e24e363d2603a12ba192c7c42026cb7488f35e6f70051d8c68cfcf9d5114a59525e9932c6e158679f04a7c8e66291770cd9b52bfc7d4dec52195b2f1432c205c3ec4c6f7d89fc792d82334f70c0924ea6139988df8e6998b248f778b896be62e63e9c71216073a0086b3e2c0228c8ddf77f9cff3446ecda980ab9eb4d1890d6b2014dcebbc4bd8c108f06f64c9bff12e553b459825c42740a6baa081b034d30436ce30aec302695c3ce1c52c5ad4bbf1b84220e6469a2a42bef264213e7230a433d2fa4780dcb0d414a74f0f9d66bed20715d575ef634cb6d99b53551618549e847f51ca3f16a9914395a4e0db6ce7275efcbfd3cd762a9b41092249943749f73f0e3d6e3cbee100b9d775370cc91fa91b908af500ab235d520987adc7bd309bce4b7823bd505f7c2103245eb1f9d237df05c8b4ad5606fc8c4566a0d4b8f7f7742f7d7561eec101243e93212cf038e055e7c54d68c375c05b39eb10f8b3184ef6b5930e4c12a8c519e89c551afa7b805b3af99de71ccc3900c57bfccd1b66e6c4dd0caaf9c626fa9657225faa974d1947c25e1909f5cd9250831178d4d632ced7dbf16237a6ef38ff2ce182d9a627422cfb56912f90b832b69292d01bb7566cd0478b96492bc06fa5a0d3f4df00820a8517cf698b1b4685d64fc784bf3671c16a7571f97e9b042e47b757a7b0bc4ffc4a81683b575ca5d740224a7bcaff776ad20794daedee454cbc4e21b4be463461303e2e79244260c088d9fd35ae07057cd6e3b17415ebfcb7deda2f839d2d9f96f5d3c56216fd3970bac6fbdfc01385146563dc68113bd39cf9de096646b617b67905f5abc9797375f90b5ce59833683eec3659f59fbdfbc3a2924421336b17c358cbd8026f8440f9763f4f5471b292726b480133a90d878ad8f696bedc31ce6e812ae22f5a8f6e6f35cd236e8a1a0b73db1b74b70b3910b7e8aaf2109de8a5924062228283d6180651c5f1df9bf3ae376eb5fd30345a6e71b8623ebc947682c258d7f06ce50b56309eeb586bed28a4393daeb5d9d01f61db99b2d513e5c9d8308ff156d9461b6afabf5d9b17ec79f948b7071b4b626e1120040c7ca3b804dc57d0672a3053598d69068d4d3cb5e8400a4a37371b96431f7f3081f69ac0ee778f50ebb297242c8fa3c6bd8fa3ba0f1980771278d9fd8a5588c0bc33db6822f5d6d584c5117a6d1afa93400e757dc8952b05e245bc0d2b25f149d4444574b1a90ce099459a7cd5ea38392166bbaab1dfd3955f6653a4228f102ad4a4afa886bf6fb5dddb5762c366f9a524a0c5757a1df1ecfc42cd860e994eb98f2c798afdbeeda79a2712907bdc63ca599ebdd4a87dc04300ea05822066a442c8af41bd5d6faabc175a7ead93ba32291af9419f8117a1775f0eb562d0b2055f41afa1ee901a597b825e32d3918a5e7f84d1fc71540f21c63879c014243c28ae9ec74fdf0382cc048b20382b81f16aef012c850083f007a08282ee47abf971cb493072e6482e26eb1830e0e0d661cfae1f59598d92058fd5ab1d7ad84dee780f70af8f93918bda3220cbc418327b36421b641dd8fe5e8656cf17d09341142a2afd100190a8c3217e7253a532c2b8355734a78b944d439138937a294f8e7afeb28be4110e113ddc0c987c423787e35c0085f003f9ba65fb90bd970c8f36e0c8f5d5138794f95b8adbdda561d648259b25d75c032fb96a18fe690912bbdb5d04966022c6a8c7d47e9788f17b637716f8d15a1e4e1857d97757993fd19d42e67fda62b64d913f8f64c0caf7b88c623d716c7b49f92f7b43ef8f394aa9318731a5086b7540a17581cf33399e72106b38a76fb1c77633c76aa774a917bd630a518bcb33f089acaf7fe25ebb72e205a3ff17a62b288f1615f4d087047229de5be86183cb9bf601a8bdfc9308c6aa5b0935f3c020c9d4e65aed75d791b84e42eeb5382f6c709a1c73588ea6a99a720122364afe395300b1a4eb6465e078538e3f346f1727cd6f8c82c333e9a4e55d637423f5d467be4feede322602519a172ebaef0e1970e72123c9861d9234e353c9d91e6ee918cf6c7bbb6288dcb96a2fe83554a11861266c4f4140d3e6460c0daf5b079e254c4d803c8ee90b48adf8960cd7fb2d0e2dc4f060c0cea11ca31a96965d3038d7c79a96bac250ea8a17ad052a90082cad75562fc005a20b62bd463bb5abd80ac99f4b022bbfecced46b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
