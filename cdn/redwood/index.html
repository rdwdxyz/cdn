<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c50a928f04040d71c3668c02fc009f69e906598c6ff07394b391b70938d22a2c5444921c85857200bcad3103634a62637e3b9926334fe5f4dfb5985f73e6f37a741e0dd7a4ce53d0e759865ca71c52cb20fa59b7b8401cf2ce0414725a671d2c7cb216475351ae1cb45f4c40fc2aef6f0135f821e2f17486b7c31723df4ccb364f8b7269505f4a935a010ad1fa1c0a6d413c440310481c0b9af2cad17b398410c41c1ce88490710aaeb0831070f4687bf9119f9df4128ea706bb0866a1a61d915756da41b815a74c29d79cb37e44d1b8ff8f228d8f7640de37182ca71ced434604d9925eccca9366c85e5d10ad7bc55fd65912ff02e1fb70bbbf4b478a9b12b0e7dec824a5d9a490203b14e78a1ceb55c3870ddd4e44166571b430900e280f083c9839521faf9dc60fafa49186a63d0ddf57e4653aaf72aaebaa1ff1a78d91b2d465fcb88c51193f9f34988037dea08d430855263c6f5adaabe3a43818f2e6677e45ecaab1d262ad5b711963025f06c42bcdb490840c9e4763dd44a7599d9558749138e17642d05789fcdf9c0e811c6dc22fbba78468deb7b2994c459aebccc96efc007414bc69804066272d2e5a56a01398dd271fe6c98cac15a42441a893ce61ff5ceff890cae8258edd2423853843612cfb95483523803fd006556caa7b5261b598c6040a71b89055b3320dcfb275126474ec8e8613d3ce897e1e252dc9bd911cb23e119d94d486fa8a1f002c8da1b5e1adbc956bfc3efb6272879bbcd33d6b42a464f282aedbf10839f23034b62c1414bf714607cb921419bae5a39d7727ac9a7974da67b45c97f61f92a22b6fda076eb67befb8698f7759af75b09f71a151122268397e399641603e1c1094ca08c0e59e598c02857fc6af69825aa0426be22715de133691ebabe3c019c3da5c749d7649c2f6dc689569af0944261cbab60aef8bb6693437b35b0c9d9bf8a60f9a3f5469a89b013422f7b8aad3bc7ba5711b3ed098f1877ffde7a3f5b5c6ac7757679fb2b4c47bd9746b210e5673a739b55e1292d6f9fc6eb0f2b969a58ec8c7426593f4acb218f16ba81b16889f39b946a91644cc7f62ee4aa4dd707e40523df1ce54e9d56fd1bf10bb96e17e42f77297969b859a385b2d1cd4f6c76027be3131571ca7e620c1d46b4a949d0341933e4715241ca03c3abb09391156eda65989faff51c392d9ab2a0dab74ca2d02291f062fbddd487fd60ac94f638ed51a3338bb35ac98b09623f71f5ac518ca63dcf77098e2aedabe8bd53c99c8adbda5409b845bce08d955b363435ba7a38c917e133cc99d5617362300fc47488aec72aecaf95e1966ad15d0c430d91d1a02daf3a9b330a39e8a812ef590095dbff9dbd1e18c09f63c9832590961e1043123a1065ff135e65c7f5736157faa8058d5d7d83c38a7a33770be47a8201a2fe2ad19a8d2349d1845cfa1fbf1bab25f3c2ace8dd06daa982c734b26846c0435b3f1b6ba3753929f5121f13ef31525671e9f9f9a4d69c66926242e254cfe06c88281a9ef7e2c8d8d68561038b111a366f47eabb3d5af941d1db919590cc0e6a528a9bb3b2431820e69922898d8bc24204c7eec44eb4302a95fdbe86040263a57b631c7b931d232f34469c6e8b6e02a66130fdafdcd448dda60140a4d84a85039b633dbb9ed7c30d4225920319326bc2e96984712e672e530653a16d0e2907ce0fdaebe16e7a4ab37b820dc57caefaf1ca126f25c199d4d8d3f4a80cd4677f200d3e6dd57e106dfae8cbf0bc7ad5b46760755bd926455d5a386f9ae76b578cc371006a156567fba8c90f5124584991bd835d3c5ce342c7056afdaeab06329f670bbcff278727d77198e4b654fe6aff2cee656979973dcf61d80f53c0c11f97347baa405bfb780ce0cda77d89f772bd3e307adb79a32218bcf9b98c1fd6230f0647a12efb3e00e97a437a55a600c9d83861cc3fc134bbe7511ab466f8e67c830cdd5bd88ab067bb86723b4dbce3085bcf6135ccba2f1e6662669956d9aee9348ade84ca2dc90ac3c0636e443e1b1f4381797a1ec2609ca361c097c3e94d6f2cd2630ce7b08b96fa41fffb4af0d6adb819042c902d4be96647d43bf1addfe10913f49a9558b3d87e8c340cec24d3235d7cd6ee253fcfc2f22b6424ba2651a630bf503d14ea0b4686df3950e5bd069b3017d3b141c2275c09fee8069799b21de06878c9a65cb3a7b748ce68d32fc1bb802ce4255f1856cae4087ee53b0e90a90356eb428db6d3936a7afcad71e92304da179d0042f950a4a969d153c811bfc276597b9d5ce0f1c20657d43f050eb4220d35fe6db3d195a3f1a71be7112023d6e31f5a44fd6db120fe9a06f6d7f9224e02aadeeb5e4c8068f9b26ec12d25f987efc3bb8661283b06ca6b2aa491df499e5744560b74441b29e43f04d2bcdca6e60dbca0806381ed21a4d59b212833873706022d5174c7202c3a6407df81754d1b01a2495c03b875943f17ba61c410cc878b1a392402b16935f4ace3d392bfaa05ef0744ca6b0b45e6fd869a35a7f78478ee9887e761f4613fe420325fcba2562ac82b92db610704ddb2070ffa64b50cab94c5456afb6af825221c34ee6f31bb200af644df50fdaf33abe6a639c56815ad806edfaacdf87c029fa0fd1c7d2c3c8a963df555da37257be44a987895d16d0b62e4e4be57812018c16df1e53588972ee22fcaae5a21eb43218783ab031a63d2f5d574e30e7124dd518a4a281e8f351bf69e806d2602d5abcc1024460681470ed51ddffcbf7d1fc739b65ba5af56bfd6dc52341e93232c3f75ce90f704a1be1bd19c1c9a58af5f39ae2e552829c81b8f3f3cedddaa19526652257c3393bf6bc207dec39c0d5ae089ac02c653018673695d0b64197f91c643f661443940078e45e5d0d86fa43a5147a017a74687ee56b46b1ba0b6d2f3b76bc15a35df0ff7fc2c20da3920852a4b6b3d7126fdd48569fe08b5d222aaccef28b77afe7d2680497fa8556e94aad8af061c5ea5d488cbd19d618d3fef3e08dd49d86b6f76a742460539c5ed6eb151cbbd9092a966efe9a2eae57d1c2b0f7753ef642ccb692cf2cfb7df469f0164767ed2f9ce0957726e9e9197398df71b3e29c1eb75dc1b5315e0c01514657183625ff1be007978e791df96091efc22b0fd6e1bcb3d46bc77f369712bd20bb54f0d35e6e2e00fdaef9977d58697785caa25dfc899fd1b23c4f5cab1682c84b94815f11dca9e672b65d3086049b21f6e4023eda8c2d6ebbf14ad32962b8104337187d4fbe3f6624be0af7e9c7243c07e4e60b3aa6a040b7271afe70ec0424410a0d5f590ba3430422716187c94ed2bed4223b365c2ec90c83bc4beb784672f848a5002f4c77818f3a2b2e573b099ded8c7e44510c762bb086e4edaf239e48c32280feb32f0ba37d83396b303d75780b2d7c163465cac63bda53229a85cf4283b4d5e04fdf98ad4bda38ca9cd7dc3126d8ac9ecb9501655eff3fd223d79447da414d5f847ed450adc95e2c21b1d9214649e679453f48da7840797e0e8407a013786535b310af7d8f4eac7c3fdadd618b0417c3a6eaff3d9b0f9f3cfb02176dd663664483527a865a607c7f7a1daa16b786d4a243255ada8c8acb70c8b66f0cda52e8a1980d894d3d48cb7e185caadfcf81946ad2e69ef86c4112fd9a0d3565e741f0a0ffca22e1ee40778610252b4a3d313b0b4a06ba9defeaaa039c7a623f2f66fef7fb49f56eac0116b0511db2636bc91d51ebfbe3a77dda6151c3ff2928401eaa4c682f32aab6af0d0afe33e8f3433aca438c4a35a16ad49e7a16a40888614bc8f925ac2e78c88a36dab88196ac1eef3f7e8c8fb3d8c4487d91d1b56fe1b1735580a8aed68194860516a956da16fae8b9d1096e3588b60dfe28c49c94577a4489f0194c07d074d8b852acc6b0a095d39080563517d572e0abbc274711bf9b945467561cebca0bd72ad1ad616a64e0f3fba07f5f3e319d295189635a4e265f569c56ae343bacf6d751cdd9c309c6e66251365c09bfccae08d31f2117f22020764d6449f9439e1e77e4a9f7fde6ea4f3c0b18e3148290f548f91a9ad9af67b7810435dc3bef23bd4b077345473fb4b65dcdc64b21ca0fc86b7c7a879ccf7ae9ddcc1bd6826490b52b75447ef33a8ea8e3776a461205f0831458c67fc305b767804025fab92ee963e05f3732cbec90b30a99e6966a2398a730df6ae314ea97c4432104724979da052d8da4ce469d7cfbdc4c68e14a9cb9d62c49635b43f401e51adc9f132457fc1027de6616d36089c558643ee3fcb4b38fdc422a5c02d404ea64163392e026ba82c9ff93821cc2f2dfc32f9ab29409efd1fa6186ce6ae46ae9422e128a1fad3c9768deff4ce00d7c89788999011ecce778a2573ab2db5a0917845d2ca618535371bc97d1ed515abb929cb4fd18d8a4dd8a7fad0bb6194fae34329c16a7f89213eb7bd4c240900d35cc9d7745af1551a8d5c39d2dfbb1b807be57df86cbf2e97e44742ae306a81785277bb4e9029e92b83722175b9822a1c84e20dde3f5bb06d4cdd8b06946834496436d71b7deaa258858c9ce16da4713a5004f23dac4b056ebf6ed352b0be9cc524dc483c796ef67cfba10fda6b2ef7f9021119c754bf4e24d9c5f9581a02b16e953a65698d3ffcd9a387311db7cba8715b37ea316a3c9d6338bb7d46b261180cc726ab1b1dc5318606309155f96c553d4924d4f48bb4dee7964ce3af9a1bbfe1f630fff015be7a09bf33395ba93f11131fdba1a894e30f87a9263790112a495db3d5a93d565e5d8be804e7eab956dd594dbed061d71ffc59b0d1e07cab0eef644ebb765cb90aae725866c6cb6eaf9e7e0f80bee3bd7b111231cb0291283ded6d7a06ca8d877a8f49e0fa0a1ac2b821fac086235050817c315a127f20bf5e887c4a2a6a76fafd45ed70f557704838233756d3064ffd4ee5ad19df7f4dee4fd69fab72cbd8793533bd6a2db40e484a885248dbf4760be770681f6f2b6686904fdb551495ea373605f48ed6cd3d49405e17a6e1b0a1ab0094a4a37ec1856174168862b2546c6a2511248e79f3abbf9594c68c34208bebe344abe97f2535a51ab3088c945add1af08a10c1b5e1416dcf9817a63ab2b08e3ea5061a3ee4e7034008c7bd72c4c6badf88428167e0e92826bc43a7521db66803b866355d773e8214407a31ba1dc1e928684fe072e090ee66610aae0056ebb7a1cea01ce0b51cd5d3b615bce3bb96bf600c5d23e625e1efbe5240e616683e91ac85cb5dd79bc9a3673c6a4f0f6f5958842edd3a5d3325082433a79d42cc65e3e1b181bf3efcdb2636341074c39e32e4091f1f7eed61d4b066070561b8fb5226351ffbf4195507f4f6f71d22f20929361944cad1ffea2c306be7895d1efd8bbc7a59cf4051f47f92386588714a192163d88b3ae8ca6708db1278679c5755b5b652c6aa4b47e4ac86f0176832759b31187b06460432a7361386f9cf2efca6b7c1868002a09b2368c4172f4a62abda491de7b6f5967452bf4d4b280f5e9a025fb1540604bcbc2feb56a3c0e3dccdef218eb9343dcb9756607fde4cd75dee914b0b5b0a06e5c5d6de3429c113584d1f39a8aefe2dc580c0f24f01af5d8431d1611afc45018175f8bb8e340be52238b4a04a8f1ac09b7f7f4e4ed25481c29b2080d25c8a54678bfcf45d0b4f4806fdaa06e31a5106725553c2295b5955f14eb6a54cd8715b7b270757d3ca59fe15960f26e1ee7e21f9d3c1e27e64818c7f0f59ebecea764a513e510882745482d7c89b461319e8c8757d34378b695cc88d8344791449c8050079f0058ebd8dfea555e4ab2f9a9b545ca8fbe5b77761892b57bb561312bfd351e5c03ff7edd33a19575f0895b7afeac57916086717dcb4cc291f0522cb4ff8590e86cbf1a90537cb8da6c0a5f2540a910c0604e71c03682cd70e8ac1228569daae41b0e8b9af951e549706552988f176f7234145ada8355a9b0f051c031e808080103f0041a67c3c9ea214c57184d0c56a4c825fc2a4946a477368bc572a0a44616522329100dbbefec5566910274d9f19a431ec008c387d6ca08a47078686616becf687c94b8c46012745ffb674f8e2b4a5ad521548bc4a504819d42f773c8fdafc428b91d2baf84c87a79395de47ad97b2f9bb68388fb38b83ba92cdd9204f695ecab925fe2fe0319eabf27983e5f2f77900adcba99e10e02b3fb8c747a7138185de64d8c50979593467968c7ca1a24aec371c34d8f62aae0ca4552f56b0e899965e88e902b12ee72c01993e7dc4e499a73a06c4e32d205ecf557d7c96af4ffe81c667587657ecb867857b6541d5ee09d0d7a7f2dee59c840b7c1ff46c075c80a8a3707bfd03197da7c21c577bbcf2d5ed098740ef2d50310af5e0b22843c7411244c066d0909c5fa80a27f573431d6347f06771a1095a517c1d589908e3fd7b6cb7e1e6eac71da47ed899143ba324adafb1228c9eb30a728348f7b8ccdb20b1c2a993b521a5def428133ce4146029ea70ccb89d53ddcd57ee02c1977bdfeb6ce2a8382c9fc62915792ae90e243a9e65ba6f01f61333f05d6d270965202827bbd0cfd8aac80a7121f287e5dd3de487910e873a6bb5e5a6c73444cb6e332dbbc7bd798c79a5b69162d4f3c5a7800ec81249d016f3b9cd5f64bd830bb2fc274c9d970f69d7fb15d1c76472672e1822bb14ba0a4fae191b5b17062c9eb4759d801cb4e054ba5dcc47a8101ad171e85b532f6eb226e12c238386aaf5bdb9609d540b7521461fd87c5446cbc303152197b14a74f2c677ef7145c483da99a4b49f0953a99db74eb18422f2b751a3f7cca56f8591af5ac110bee63fc24b8f85ae3cc4032e442f0d433d0928c968b869ab9d4400ded25593c9af322e54f8a6d8e5c8ab41487ea3256d49160445b20b906a751172a79ea19747d7c3ac3a657ae09014122a9100e7b85a01cf8341c2e62c5740959c8c6659cb7032b8321682ebd0c5a6fa4cbfe8e7b3b9b9a98a16070633e1529656cf84ee881b63741d1a991aa649a98d432426f10568877e8704d30a3d24fa8dd3a320a9c5d1aeb6a0fbc73998a5b3a30a61d27c84746e339d157e3671e67c56dec09e3d1656586fea8258b81b1758aa329774bcd62f369c6470586d55897beff269cd77553bd6731d2cc2de4b6b5b94fc3fcfd5a88fce8bf1492d3f17b09dd105917f085afa5d3fc74b854dbbb2820011e98fa85770979e0753f700f268c1de72f34dfddf1b8e87a51bfa79976df5b5575728cd963f607c396f3d6ab9180b60677481d983f4318e3d88dbbd46f14b582bb381d48ec248ab6d3a3299e4c3fc040b69069ca207903ab096e3ba2d91053a1b763128c208a9d2593ccb1f8492885f1ced054d166bd860528cdf27946c2f8ca3ad8cc336f3b3ea6546801d506e6d3e906b7361abc8d829e698cba4907a0392ebe2a2cf1bf5614db0de471474328e7b1ac1454974c6c22a600936794b0b49be53b7e4eeac500119f5da80e7ae40f6a386fd71d279b18045be50c4af4602aba251108e6ff6a648f6fedad6dc2e134e08b88de1f661079882d4738039f3488fe2a91091cfe593839424c205704e2cfd39415c3e4c81563e2373c1a3d45e5d93c209eb47f145d3cd1689afc75247f3496cd439240ba2a33efd4a039a80b0e9a0a9e1a1755407b38b5d24a26771b5a0130da9b0a5ffcdae4625b371f53861fde4655b5659d09c4a06f1b001c3185978b8343fd5db3da78fbd2a627705d946e2b336190c3dedfbafe2c359021e8f421ffd7ee06f6f977e49b7665c35cd4e91b7aee8e307a9b4a33fd086f92008d39f8cc9550e129b9de2368f7d96083c4c452f9510926b1e20121f41a62028f6fb8794edd593b4f33f455d7b9c1ef9aeef19d5061c465a07381ee4d30635442dff4cdc389734298dc09fc1127b1a53d02784fddfd913bd8359fb1efeb7f9f30f1e15a3ce5839ac9f86239ffb5a64bba3705f9438b1bd766d556e1e9a8c3e5cb8d9e64543a636e4a1cdb94f51d8181a61374b44539450e39f0b625cb2874e374c2d24cdf2beb8a9b9fd93424a9045e23d2451833fb7523114961e32511a2ab5b4d3fe66d39edad6746311a7def561d1e413b03b3bc4c1e47c8e3a597bc6f1ff29d7f9ca0432aa93edf6b763a1b6787c5e35cfbae8d49e88a1c72badc0cee79fbc1a9f4b0e002970e60d6e3c85365248d2ce3aa6a2529a9c17888c1002092c2b0d50e10da78a38a842c498925fc686822ea7e5b76fb5b155eb4eea02499b4571d89085ab7231c529e2d3e62f2cbcd9a869a2c5c83e435c09d30720a6667de30815ea5b94de16d188353df6545cd89a5ea2e2ab997635966ab51c254259e0bd63026e220b312db999f005013294e7137020d77f3d57a33989cc15aa76a60fd8b02afd6a8279751ab6ccbe8354cb42027379038fc47026a8f53349632204c0b47aed13d3554ff6940c47a8a3765b44f994dec71b6439479a8c6b1e67336d68b6f5649227d7bdb086b779f188a57f32114f4350833aa02218ac39e19d6e5d4839d5dad640366f020dd9499aee9efa097f4b6db033092a1e37f1297f71b93be757f720b01036df7d269a4fb14bbbd5dda5187f7f48f51d32c807c89d5c8ddeef608bf832580579581279a2ebc1697bc4610c464e135cbde4795519908ccab0d1b4c6dabadc3b80247b72e51ba4667d0053eea54888b808113b1e3b40a50d2968a241c8660d46ac3c13e711be4a06799d56ac901dbef3f19dabba55133c98e9f5e54d69f080ddd740f4c8b7ea1e10c0d8e58e4fe56b0f4040c11bbbd505a979cc5ebe8be3308b6330eeb3cf2505105f48d114bc0daaee9e520770d55a7e92d593ecdf4a3af334d7c982b2fba9633976167d745e38326e203bd397981b20d25d554ca58094fc41e54739805287e3fb99e9bcb98679c199db982e291f744846690334a062e751b6deec05917ace59a99ea5705e5ad268723b11ab76c046fdcdb42665cd4ce974e6d38616637c1da8a7f30786d03b23355e9c26b0f3cf08d5ab2f7d940b8efad6e598713b32d7407b915f6a6eabe6839a6aaaabe87ea1648978b517be74915e39f9f902b11cfdcf269b72a1df9a74a52241b3a2fc79df4b8f24c322e11c4d2c9208bb062e7a04323ee712ba23f5c4fca36b7c50f6797255b86555a9898f485930a7f865f51164e9da40aed1ed469a09b43c442103958d553e6d39adbf92d8685ff9bbae11db99a730206f1daa8ef8f5e9aa44c1b0059931f756160c448072612296cfa09c384b2cc36fadadd2eb7a1e6d474764f4144d1ecb72cf7f97db3ab64b57f83e16ad2dfdf906cd54c81c510b0df4d113d33b8ab36d07f6f9bbe127f5479a585d4ff3e5acd49fe59ace28063722be1a9719fd845976fef65619dbaf9becf97332bf07235362216e799c03fd88053d43acf046ede5a48fb0e9bcd618866ccf29e871082faa287e68a120f3deafe2f853c644e8406cb93ffec94ada33830252b106ee9802f4f451070141ca14ab11d42a34332f3242d9b8b55097da91ce358cb5dbea4deb6b38bb5e2cf8c4dc254a0181e5e9439ce7f4240fb2bc13d7388fbfee6eaebb48950ab7cd0511f5d562b61f98a4d2b22661dc73ce3c6b5e8bf8a7f258c3b792f7102d332b33a9088499c01342c0c65e8b7da59607d1cef274d4158fb5d9d3fce3e824b4f14fbc10a974d13cf9d09b8002b5fbd9b36fc70a08b34bd7e2bda9036fe4bb1c9308bc50b33482125c89d8b3de99ef1a8680fe97a6633a5b8d170393e6a74f05b7e6ecea9b5fdf3d77943268a7cab6703add01bde6c6cb9223236d257c2b5570714bef1614fdee305595a5ba08c1dfc775d055e7ee2d9921be65443bf169af600a4bb477c40e80658bd22dcf81d27c72bdef9c32bace44e0b8486eeea78b95c3d30ece61343c5742487a471fccb78a8c7aca5ff9f57d1e67b18026d5e7a58f00f3eb1f217cd60f3ccdfeb26eda884f2e5cb4982dc354259670448a914e81ca791f812bb5889f0b8f02b12f30ce8b6048539a26971d5827437751de2fb6b238ad005e76f1f6a0eefbe600942db5ef7e3e23f8b03328f6e5e02994b7ca1dcd4121c9094092ddd36491521faf98d5439b5acbf5c254921efbc0c206f8d42f8990308efe36a7c8d6f960f55796a9a295b0c458b6e6676b96e5461bbf3c291e3227513ce8c50f0f07875528b7e4d3bb80d3af330c2ad8a0ef562c2f002692d7d6ec4092e7fe493aaa62dff78a8051d445a54616c06778b67dd1dd94dae5d1d98c1050fb2e55ee55f6c5de0174d95dd7b319aef9b9dd267e9b083cc53f6275a4bd0d803b9ee3447c8d95501f58b69a73b17ce0d276c49f721d7fa51174aa52aae5c286c2bbca3519faab37b56a006b759f21c65908ebc145e52f0200f5514fa414fed3784fb30427b7f6bfc8fc0a7f9b5cb7eb248b7371967eee2a22355f3b137c913cc7b78711b342cb8551a10d48a934cba8f743516dbf5924642d1b5560b9c7c10c01eeb43449dad54e43b0741af101c2c6bd7bfb6e93c03e23d2718d42f74c96c160e1fa1f6e45eb622e5790167a773061e727b649977cf3a3cc7d9abe270d3b93e37cc8ba82d815d0f822d94bb7936977d9360de54a6029f089eb062c11f51f97c95d0ff0ee969c74c3fd01d537c01d1813e7a6af54dc19ac8f23471a1a0949e21085c947e4dcc079e0dca24987f778eb122803cdea95fb6f2f0383893b1d478164c6f82a7d8a78758be9a9c877aa564ae46b288b54e2315b03268fe8f9c174f16380fc9b519ade840be28b97960296d8a883b6dd418da279f1497f798bc09f705d182d9627818552f84d1e0abc7c172de4d3c84073f2b1970270d87d8a286f4088309076a77c9c26eb3a30787a765238abe8059805dd0330ddcf6f454b3a853936060f232cfc56fb1a7974ccebcae1594a29597faf513ea4ff4544856b0fcec415d43aae85884f1f82c0037c8ecde6f45fb994258e17eb15993b08b55b7c1376a50d894ce1526054429ce5ac7959ca82b33da4e18d753992620d4afdfe122c1f53efe25e5d27d1db1c802f9492fb7052f9646c6cca10c359a0aa99d20a38ee00598924f4b77a73eb19d01540bd1bbf21866c499d5553a111255487e8168db19cbf6b9c527f6a3b4978a5f729c638e3d816372a959152bedf942fd746a1b5c607ee6541aab79c98df9f811e662d6eed369c0c80586c788b5330b5f0488692e06391f5c9ac8c8c49c24d106c69d59f32bdb489f1aa926e246f9da5aa5266c454ff55d0af76847aca753d4aa77545f0052fe1d933c7dabdf59a46f7fbf6325ec5cb0e3f76f24e42c054fd27b40902c73b2b8947ebeeb9cfd28fc0046d1361db88811de7ee8bb5d82a8c1a2d7f769429262db93e7308e39e23ac8e846bd79c89ce248d217962bcc19ddab3147a7ef35a4c9930afbd8b5b13c9566c3b539ef7bde1b6e0009ab3247b238feb8dcddeacca04d7ef441e152581484b7fe133421c03385206b9cffc79ceabe9a71e7519879ae14a08e58546ab4f6685a44ef09df158136e3f840781982a45491e1b365abf4a00b12a1ece9de6161f338306e999caa9f75a72dece048e15668f7d56ca0eda847e8367952ba787b0d108feecf01012a200ee51c315cc187508716639327d6b4c1e920d2ac2572576aeda90060e4eb59812add046d8bcbfb00180c3ac286ff0f9ffc96fb9be0bccd546d12fa8a63894d95eb362264367229e2a95e18c34fbeade4ef860181cb2c2e457dae8f8191d2974b06fb59c756926c369e99761346804f4b85cd492ca16b9323b40ea5a37ab12f4cd989e68e167df32b54cf641ef30c6f8c056221e77dcb8ca5f1fd8432405c1a51c53e1a072abe73bf7b300016cfd04a59a73685e94ebb3247d655fd56de65a854397a552d9ca021a010ccd347bb00d5584262f0471e4a3d6cb38cde0ca6997d621f5ecbc43733d8f2527b60b4796cd8381c3d677545e29bc4fac864b692e908d2a0972e0ab24acede0bcb78f943b3d8de19f108afd5ca499412082919879d1c3df0701641cb91571ce38dc942a3b0e5dd01648cfacf2df1fa5db92f1a3ec078b5067d329e6e161cd0237f04eecef2a6110af40500205525db8a92aa8588ba4c3c755d5cbca4e160c5261fe55918c46855e4a8d3c796c6e433b8789512e11eba34b6a9e4315588ae8d69ec09b784d18522200e5bfa5e514e3c0ef3cd78f7f1d270504eaf89f25747d3b484975ce6dc11a1dd14dffec8a750616fe08891dfc70bf8e134294b7131139bb4e2c695e8606d50afef1d2a6b0ccd1c3c3c5de5885c69cc56996aede619661f786ebad6dd9ad4fb09c680bd8f653a5c791ef61403a7ec1a632f0b10e6aef15606a2ca135db0e63710242bdd1f4a456b5dcee3c3960ea295f2ccdfa6f939d26982c348560d2f0161b8a2ce4cdfcc9995ba5174f3974c510ec75a583826ff3cb3aa2d405422498a7e23685689e54f8ae7442cc3c6b3a2c1a6b1925174e5ed7657b3b9d3efdf5cfe78e2491181e362e79bc2c424b1434200ced8608d28e8eeb8699da9218cddac64e53560518c2913e20fb75388b3ae908866e21e78fc1dc41781474ab867f84bf169e43b32a07388fb98ad93e995d8f5f6e9f1641887e45c7f636cd2c0c5e85377b03ede60891ba3287a977aa057e1b1a948fd401579fe35d99bc2d7ee1c4d5add54df9107eeae0c3321fe662d5b33bab3a1ff51905a9ebd6a3363b81abd7f751da3780d85f2662b5eb89aad13112a189cea3b25015d401ef90cf4607639b6a27df4a029bcee46ddc9f8e324ccb1b606bbd41c731e8a346779c89082306f46b630998d3f7ece73f551f8d0d661d91deffa6f44e0984a8e1dfd2ad81a652273f900c8d5e23e9e5dca8a13271602a77e484483edee44cca4ee0db8ce4052c9698534d203d5471b9a76530f81112b784a0ce70af60ca96c9fa0dcde90d5714b2ffcf93f89713131031314d391dd49eaa8c6a1cbc76000f6481b1d3e263f7eb74ed8e77bfa57d99b5c4c0a03d5cac44b0d4199dbfb88957d7475bf4ff4b00a590b18f54a917a57a440ef43ae36bc5515566b0d28c43872ef50c1556b9eb7f63bb337532716d4c642bcf1eaf806635ebc6bd503c443e130e890ac3a1bb7c94bc872882cf62213b38a59ab64a23e46b17ad81aa529f365c321562ca7ff90f392a3f027448be4ff5d2825f1989dc43e5857da1c65c46cec3a7f3703b834f86d8338e5a937e3c1338316b8a06ee15f04b83c9b1a384c267b8dc339be7c89d290b7f5d25acd17e4614ef15a03bd6b94e2671a26062e7263f7eba214085fa2ecf73ee9d0e30c6dc77a0bf6f41ced169ed5599ad0620ff588e02d17ab8b39a0ecf57348761b8533d4b93ac65c08fdf49f503cd2006cb67644163dd8ab882aa3ee1fb866f096b76d709a469a9d3b459108c7e8a3f455076238e35bd35eed6b959ed8528600d1185327b2987ff70e1d92d1d9c2d600b88b04c58f1f87c3d722d7fb0d46055295b9060c990b51709729e860c65f529d6d5ca17021f7fade408182dd1cd3af88af7f0be8d1898f138f3584f6ce98afd1ddb4a619e89cc797fb9d476bbc1781e2665639fdca5b68ebe07732d7f3763ad8a6fe0f7f33714879525082de0754dfa685d5bb8a358663f2c0c8a5af8e448e763d4b056dd7af960e2a6b1a75857e151a3fd4f8b3414256893db585742df1b1723e7dc515f2a0afcfe1bd2bc0544724af39f61c311d8364722b75f479e319858c467e0d60221b06da6fa5df26b564a51d7deff9db9c88f426106d9a55a007adc1a1442fd8a50bc239ba9f912a3894d1da2c2651c1bb12536c2e044bcef3d9d4dc82dc971c167260f158f2d8d6bb7cc9cc891f0e230ffd4a8330d0e2ac86666e22a21a579e20b71367e64444fc4055850b3c369a373d0eb4ada3d3584658c8037e96ae8b512c21d7ac0e67b6d5e48de839169ee4944263de5bbacae8ff7ce945cd98c87a1dadf900530d1ee58bb7ecf939065110a89d1582fada17ce2c091677ae5d4efe8b9a073185c43435de2d0c530c87bcd50b8569d64f2b79d6bf32faa43910a692362726c0a1f9fc678ac1b2813baed873bbc56d602958e3dfa5d40fee6a078231169c0c70a2960f03fea1a569feadc02152566559a8e14329293562ae6a212ee2f365e22b1876e6019bc6be895eab9c0e3256bf2975ac28b5c1524e948ece1f9eb13ee84f72c45719d1256c98da5d4da404c0a24fe28fde09b859780bb4d6b10fb4168cb5d0292279dd07265ea102062da0ac965ec18c3575a19d9a00b35debc4e4cc60e0188181a2f533098d9c0d76a515a29a788885d4148c204eb96091f4aa7f0238e38933bf3c141be32c4a2b1079346fef8fe46b9dc55a598944cff4481a75432476cd356aea9a0a98ac5e1ac6f993f49d87007bcb00fb9af392e044f0257c4812cb9cd7e8289bbd1d5f4c0dfebab0feb6441005a40374c8830f6d1f155acdcf686170210459552f8c42928251dd343392bcb80a7e2e3e4707fa48624f06f46b52449c6d2e5b0717689194a74d255e3205624413cccf1abb546c8cf318925db382dd4495498299da3205d85276d697f8d3f24e671a3a8bc53198e0db58c5a24b6e17ce796f878319305cbfdea716eb82e9ba59edcbf139ad41d68c32a350f97d8d519f89ddbd52cdff112a2d0f53dff8bfde8e745e7c30a9c398bbb43fa2eab560f4088f4c477b8d55c4fe6737c3140480fb4e20515e6d4ad7fc9ca5d66d8503e2f49cedc4f75d44ad4b969f33dffb55264748aad6fc91cceec6c795b3de7913d16650f382c5d37f8af23344bd9895f333e183b5ff0b2b29c6d5900481ec371101bc26b8036bb888429ee04c53068af60d86489c64e2793c68c4a4f873f6ed11aa62af1851bf4d6ab9f11c58e131a1707804e65ab3c4e7adaf5eafbb91ca65de97c4467cf30ffc0d850a552bb3dd40dd859096a531d7fb584048aa6ba4d62c9f154df14f503dbedffff0212283f688c744aad22671ae7d537667831f1ff30dc3437d28226a238a584238c1525c1b0ec5ad59d2b0a415d5efc34beaae39b4c705e8f4b7a378fb26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
