<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d6f5d1cf4fee72bd6ba6060a3f6b0da79496be0943502f15a658802e77fd3401143d695490b89fdd1590c75082d87eaf438a260a030a1e8cfd9f3e71d3e1b6326a0f93658674b0de8ba10c7235fc58df6830b38dac90cef875d8939d4195b0429a11afe9de45a47a5bc89259bed14426415f4d25430de3f2e213cc37f391bae3ce46472b02c244b43b806c56bff9a20e3b6c7e8f4932142efaad9d7b1d21ac9817cfd4422a846cc72ed14d7b94543593666022764894764a4bc3362fe0efcd1051d760f00a9ac1729293f307c25793c9e6c48cd6cf21c44de554611b33a857d51c5243e906e919c5002701776303509e756c989c39f139dab0420644d1e449ca569855563be0f419fb4c488b54cb44c50601de5a4fb4d1b3012642d9a12dd6a79698ad09b481c35390b23e9e21b82a7085837d0a2600c14b6177f4782871c2fdbdd19cf52fca01a5295251c2935fc82d0c74a56348234360ae566cc20b463e2dcc9ae3fcaef1e851f1ddc2cc255f591b40b8336c353df4a58f00697cd34450fec76e32a824258d1e48045847ebf3bace781efc8946c20f3b194925fb9ca94b5ff2f3957784f05226cc5f0163c510d164aad2c01ad8fe4776b946630450ef02ad050f787e2be5e0615150212c087ede159cd4e317653f5d4b1dfb51307c3db46c3b2aeec5db2f7e67bf4dc5c9254371e1fd11b3074067390ada75e230dc399b5a1c216f002e31013cf55562b97e2869104f88a6fb07acc3a14d1a5b854946654fba7f5ee405e601889764570efb135cb8a021f01be4f203191c220f76a3f10b8a4a0cfda607d77360b0ad68deea144fe572af5a83d410c0c01653c41e0f13ae4d8e76db9b9ce774eaf13da328a748aea08abd13a195cdb7f3db38a90d2dd0ab714893005562d8e89f8034c3a543b451c3d314a909cafb5d5501bf3681133e8cb40e4f072004217979e49547f9d3101ea600740837a33aa06a5fa9267db5723130aa44c5f98f575fe9b8de239c18f5d7ae3678b7f2e7502ec540bf77af661706e8ba220aa6f10164a777401ec7d1b1dbd7c374b1a861ff32946c157d30ea0692729e8dd9779322d2236b794f5d28686d1f39500f599991443ddaf6e383b680a4a88d84d56961038326f429c9224fe9367225ed8d3eb38e68a17e74d0a31ac472ec6e7f61c96ce3fa4e284c9506967855042cb43a610b66015579f01324c8054d09257186380a93caea6628e16fc56a9ffbb12f61f48e9bfe18d6cf6348a03cda329c134daaf7ab79eb1d42dd6b7b3f548d7d0cda45ccaf98b7efb0edfc07b3a0bd212bfd3147cfccf867a21c8a688f5d9a5ed0bfd8c343c89d8e51a382afa0fc9e2f62b63368660ab41cca32d73782d5a8981cda4b03feada7ba2c9e087945321aa74fd8cd270ae88a05ff22772218168053f70d46825e5783c796ce62ea80577d678c6b2b6a3ea6017c3f1dd919aaa45ec0a626ab2b6d938d4664f0c75b2d3635b4524b60f72f31b05510253984a24d0c69db0b6e65501d3d827f85abfe3c07bdd16a3ce65560d469c3d7247aabe6355bbdad388eefb05cef20d50a492e5774f7a3d8a975c622ff7fd6bf9025aa5f53c11bf4dc46f5e8560e37f2c0ad8b7dd614349801be47f5770b149ffdc7db302763100a7e932f918cef19890aad38914a6b56b115e053eac11007a7845604cf3c13ea31127c1705e967f660e65e7cd262d72de1123654003ad7499c3a3fa2b8e1f65174ffa1819c8c871012c843afc1d668415668b15dbef19302430562eaea654e99edef5660b301e83cacf76bb4842b21041e6e2189a19c074c2f7980775d828754d6af12d21472556f3d990750e9ece7089bf8e7580eccb2cbd9eeb08bf057d57275accafff518a5f39a72b17967bfb8cd9d093d3a293b81ace53d317b458d9590ce70fb4ce4fad7a53bbc59ffa92230bd3aaade189246492815e629434761d39dcf14379593385e6a199207636cd37b6c56b61525bea3cbfb2c13895eeac2dcbf2c4b16c88549f9ebb02eb0adc9755e54620c93b8cfb2c50c7806c38481b0a909c5996558aca05bb06a8e651b701b58abbed2c003d8ea41b648cea1b235053ea5339ddc06a81bd76817c0a4ced025ff3c9fc2ce3a69882d9f065646110ea5b2049152b581c09f2ac54d9fcf8410b050481dc9b8fb3b16e8f633f97a9fd168703226128cfc5453c6a3e079808e22bdc346dc4573502d40be95008941613db867ba09a12ce67c84009476efb5cadff7148234863fa892b40e476d4fdf9571cf0f67a947e5ffde67c060242cbea92f41817cd115d8f5be1169593b804e9eb1ec31c9b5828257a7cbc1083d4317e9cfd1625d651060229c83f3ebba63d64d4c4826dd818fa938b62c21584ca71c2554d625e190a858b98d50e49f1d5fdafda16da813ea98a347593ce0870bffab1b5dc11831c43b72cb8fb26d3c311915b43a4698a41c710da6a40c45eff4622e92bdab49b0cd8b7a1e46f9fb232499d4a2a3ca8d0c1d1dfa3ddd9e66a6a88431f5dc9dac48e92db3e1fe4499598a99be045ef93674ff7a10636dd23ecc3c13148c9e01e1ec88780dba9c4e2df390d53bdc926d9e9f696a98f38966672952d659947bafa0df850452f6236e8db5dbce5b625ba990ee2573fe366b1073c0dc91c2ae4a22205b65e917ff4c22eb5d320c71b1f740271c44c356a3b4341b736d6c371c8e8d71dc3fc0b3c328f890e11e718daceb53552bdfbc014d381547587d8e46831fddbb52c6e8e71100130b6f5421b6088fe3f7a677e05c55b55f6f54985060ae033cb638b7510c8d3db909b83fcd04b9ede3c735d8c3cc56f9d65150fa8041894b6447f0a50900396416bdb66a5837ff2a6c670218640ab4dd4eed3292801cacbcd5047aa5929befdb90b5fb980739a23ad1cd3abcc66af787e2b496d52274f09913de99b0dee5672ddd4bbe6e52722bcd01efe276b42e44ea7f91e875bf06065aada72334239aab44761963d04c976c640c7bd120e7239c4bbe41970c06657c49c2497f1cf34623a7d5f3b13fd0f11c9219d70b059e106fec93318b8eda5c91ee9708ef8d20a8786cf7ce80b82237221af142181ef191578bbd6e203667c3dbecbabb015b2839d5014966b661a2160edecc7c4f71a68111808050418a135eb897acdb06ac4d8a19f8495cd9fdee301a995b1227f065b391bb85e7b0e7d29a64fd2d8197d7925a1f226c78aaf7182c9416b1a80b2bbdc4873b17ab7dd5b110045ca72d213c6a46c6407c0666ba98a4bb0aea0173011cdd60eebde6c3ef83bea848f30b2256c7ce5a77d2dde0cc1c096067e490c1f4b1f8d35282db3d8cab75f53cb9be122a68c9c4b4a07fe31b6b1fbee2c42878488f04e987fd6fb42c8b27074dd0805d366b9ec487d7c9b6fe7302647e18626f3c6d83b02da3ae3e8d6230f29a048179356883f9c23b47195d7ab031d047c473f9afb2d722cd8f96ba9222d48876ce1b116a10c5cf1de3f8621d535c3c404288a2a3171ddca1173a0c294bfd3622dc178f8cac426c8290e8343f75c6f0d82e91cc97ce66eeca518b4df94dcbc9f633e40838a4c7305b83943ee14ac3a6cedf2ae7b52fd7ff32387fd3e2cd704d8d91c77dce16a04c4838c18e70741b0bddf96644831c56e488161000170a3252f3de25d0d454a215e66f4e176ac4a8e6d74ea26b3520436de7e55c9fb46e4406c743ac0c686a5bea8f03fe2b1bc841ae7bffda061b726b52b047f2552d1ae9cd275d422b3e5dfe97159f6a944b2ff68545e8b5ad2552286432bec2ea3a986209f8274305218abf990c250c27664641c490b1734f18632c1ab72b495824a093594cbcf9da1b963b71cb08f71dbccc89527351469c6db4f37cbc3ef9ca3275444558fb06a3a06c0cb85b02c595ac1c9596afc5f712e2ba2f85fd0a371d256f974b78c700b9ba4d089a22d2e187e276fa0cdf00b7b38f2dc98fb5c5dba0ec4c12b76c88ac601aadf5934deba9fab7d61a155863e5ef3598a98882eee20845b47bd5a838e4829f5362bc7f0aa60f76fe6f795621b59254e8ef09a20f1330631c556ec30a06b69509d14884f36ad667e37e4b124d14da335dcc09d0b2bf7de73f0c37d7be6fc116c4f9da7de738f73014238e49e0643c7c4783aece5269026ccf61da10e0dce0b3bd70667bc26d7af45461eafeb6e63d3130a5ab8b311b640cb8056a5488d5b194fdfee085bcaed14320703f4e254d76ba0706d52e827a408df524405418790906e4b6957601baea17a3aa767c848dfbd851dbda2dfc8ad8896e7a9428fdb34a0fbdc6104fb653bc505f364f04e774915dbfdee736f967a7dd0dac6f04e606ab05e258cb652dd76bfd80a841131da76abde6d4cfc168718a5b1517cc37e94c385b2df98b6e9688e96b5e44426b8b5ff37fff26a323c4828cdbc1328c6fc65deae5dcaf80be7bc4c10533b1ba49a66ea3b5756e487d308bfe81300ba1699a1c95506868ad6b65206dc891df1596715518f3b42b09ecd908534e480d255b424c6b87b963971b2dc76082dc8c5c5cb63cf85e2a338090e58d93612e1411f8f68f5ff33902c5d09c8de1ada13082481283a9665089dea613dff811349407684794c2249cb8e90f43b4f781479d69de0a8879af2866bb7505a4b415f3d3182228a885937decd161362ab8188fcf1d10c2bd65a3a3f5ea560eb05e47322768aaf091c6b0f8bc396bbeaa3da6aa4a88d89941ac3e80e30447700b2c5d578281520f4eea40712dbada6871cb02ac637293831298d95b15054ee57a7bda94cd059f961877f2373b8b5693a0691c6557152082ffc5d54901625493ab5d713dc9749f0a2ea9f8ce152bc3f641eec472930857712fcebce9335dc23d41c29f2ba2c445dbbda767e61106b6ac8fc4bd3acf6e22f12759347f586c0e7176202aeb5a997c0b7125e8316f24ff9fdba99a1a6ad6fb9dd7ac32d1b4c4f50f8e622e5b7816021c9bf4b4c94acac3216da59ee351ae534808a87533b2a6ee0b888402af7a0c673b6639a5a5b54eda3b01c90664fca926a8c945db652bb4240c3ba1e73a62f7d065183fb6aba285ebc9c078f084ec45777fdf773f84337b68100ba79451e41015dd53c4d2606804ca55769a48c7d0edd5ede6ae907b001ce2daef99b7a59b753ae20203327db64bc4dd0d0f4d8ecc9b68a6e8e31ddcefce193fba208324e5f6184f3cf51d8d193c3645949504ed146b453cc9a5ed652e7ca574bc3667ea623f78de1639bb452cf4b28c7d18a3e8cac1b84a597b199f5169bb56cb07361e6fd386b17ad9c7483ee956f91b9749bcadf038a1e23b140a94cf31aa090782766abf9eec025e397f0cb3867a52c90553ddc1bcf2f60c1fca4411d28466965dbcc4f12b0b8538d1acf92dce309acaed6f9ee1db9e4ef9648ab585cbd32bb4d0c7973fc195370f8ee6a3f5188fb613eb352189ab7e0149d302f628237c1970280b9db77fb72cfafe30ae1a8e31100773a29fbf3a3d2c8c89e20a17cb39d123db29521345bfd62e75ed160f2585ce16f43eb6acf4be9dc1e5bcf364cb0fcfdfcbb4032456cd0dcea706df52baa90bf2066c0fc7d45b0dcb8752bbf1951cc6ef16b816748e31deae437855b87a40155b89fa809822bfec310e136dbe19716c667310692ba1f297eb9a06bc949e4350f013be7e6caa1f3bb10484d9d44655f18112242a39699947a31226125502fe02ed5aaba62e9382287a86ea138a4a52e92b5f4a96f77ff92f906707ac9f957019c719bd36125eff04bc57c7ee39cb10031272ba80566bdcf79362d9677611dc444ac1c864082cfe0dcfa5a05571a0481cdbfe484c3dab14effee7ff152f9dd59a74caf13ec3da2260ac79cd4025af8a0a93c668df638e8f8e0725e85b113f0af66a9576a607eca275ff4d5de82fa81db68218136ce70e96ddf7775594848fa50feba37dce6f4f50d0a6b7d8d7a3c150e7298d3115b26bb203767258254cfa82f144c6ff0e4ad9c99284264fb634952b5e381811e63250ca89ccba65a1ea55ff52179e554601983f3f57b59046bf0b98639b4aaeda9a188cdfc73bb87bc674b8bf8ce7aff6e21d65c9957be503ce6fad6d9e0fc7abfb77f7f7dedb58efc8676affd96c498f0d3df3fa9cdda2fffc58c45c018d932fd4693a7fdc84e38507ef0872be4173ce478d90fe3e0d3bfb7c2632cd8f01c92f964d2517dc3c2bc5559c207dae19f77e6bd5f52e6bb90f61c719c8042576a1c2f5ed3bf9b22f50f4b268e188a013696cd7f330aa2609da4f2620b04b76c883c733cb7b8c60acfffa5b682388bead487bfbddac8dfae9cc00fbcb52d031cad4c6bf7ed4eae4e08850dc5d5d7389e055c30617f4ae89a03c40f559e163acf10fb75575ea9f127b8bb4c1dc5214a7387eee1c364f4842bb041a7ea0342b583454b358cd5b9bd07119944054c6e50c5cac3f228660d045587ae97ad68cb0fe9b170747fdc6ddd904f9bd288154d4d27d7fccceceff3e1275d46c15dc5af3055839bea89793f763732338aa2439446114aaa0e665266d611ce1f54a4b891218d71e98fbeaa0300415d2604c13ccb56bf6ef2a0b3eb9db6c899ee8ad79deef403521a258b5e521af69c906274bf4be0e060c00852ebef963663af951c4bd69515ec01dc9a3d03e82ddab371a05535956b17c94949e2c3ec6e3ed8383e6550eb671218752307d841deed988baaf3ea9059d8332019fd6fc2e1270acb0f851482a87879eb910486e4586afc7b52907da3c91b0368c8e3d46c84470233c4014eec759cb7eb19d67fa9c40b9d05ccd1806d96813d452f26fdcb5bfd8be1f4d04d1965526e7cc917b2495316f1773200041ca519d07d680d6f74bf400a5e9e2c57b0bb509be71bb87f9459c603012937f6b2e9e2c5e1b13386500b039b3841ae421d28e30dcf9d5fd4f988b27e66e02488dd5491952cb98fe56eb88020181672977b3c0cffea5e7e0556df2d47a3bf40f3f8e6601df254655b3855929aa9518e98a172f4d239c91514a12340c3f26a86d4c6074f57ad8699c1fa55ea92d9561eb92a4598c650c994e9a3b9c0ac5e3a935613ad088d550d26d9f63b8b2d8d6454ba76da9c8942980ee4277ec1cf691c45dbbca1dff7d52f33215d77342aab2f46aa6a3a24c6e4a0e5abf4bafa5a54b4842b365447c6bd39e6c1f9464296b4210334f04769146ff1673ce40430864cf1e18cc3fbd9d93c91d0f51591df863671c89326385b82d2ce994463373e27b54f6994f5029a34227e15e2ef5e4c364d7ace4002a6fdc135183826d6eeb40035352d423a45db1752a6b9561d2b819d76014f12185935155e10d64aa34cf5e69b491148082dd9ef45083a2043c8ff2f016f68f668c561246134d1cc2998fc40df2a875336043ff516dce5641b9d7e4ee035dad9011ce5acb616eeb7a78be615c3c4a73f42216607d110261afa74131f5275f6b87f42122ba43e8c777d21346befb86a0f84a2de8e03cab63483d6cb9effb6a107328015ea5867636bd754d52d607facab161f578872f3750d1328933a449423fba9e5626af5c485d2dc07ce3cfe27223979d4dd20d171085703974bf56d9f884c07062989dee33db088c03c3663b9f94659061bc53458a1c6e225a4c13aa10f479dce88781bc0a88398de715e79533b133632d8103b4696880eb28a450412066ed85eb69083dfa5f8cff9eff2275fe62f2c9b37fbcf80ff2d23c602ca1174e8bd4c33d22f130a56eeb3a8e0a653912e1c7b939876da2e932c863a517ccff2b5291c49623652d485aa3a1bf4b0aacb37c88dc5492528c84c3fc3ab503e35558421045c164b40065e7b68f8996a85b552afba0cf6f8f81526ed45fd444832b6820a109674118e2ffb4676f13a1e0c1d242185fb8d6a55c2ea8e883096a6d32909948b9a86eee893e7766a3a19b68fe9cc81616f8d10a26b1c337afa5d8515db9757b1379cbb33db472a1f8b1da4516d8c86754c34dc0b2335f32bfd65a42965410f1425cdff1c7eb3a7586ab28208fdc200003faa48bef45052b8ef2ba97350bfae3baa0f7fa97d90c58cdad20a478e3973ace356856b6b53668d8fd0a8dbe6b6ba1c4390803cbe62e4603b7705ce387113c3410d61246deff28f33909be6aad2b0a9b1fd5c90ff521f0652ca83f554e329435537593cca0ed6b13ce5e1547788ee343022c18d20f905d766aae8e17c17daa7f53c84340466113de3aa5b332a12d1aad13730572a8113fd94148b793eaa4826276e21d42cf1335be14c6ab154339357c02bf0a9b4cd4b5ac7f55a1f84ed346f84760a107d24563ff01819909910c7ec413d0bf789f8da0bf617285059966ec25e6bd2e0383aa031c1e40ae52d026311e66e0bd9ac1b81de393ce63331b4f33b4290ac9a45b22fb24cc7cfff648a90a112d20a5b4b4b67fa6a06de193aec0c365b147b08e133480ad46fec6ea0c07a39d61ad2c02e22687c413ade136828e2e38d1902309d6ddd63736e85cce51fd47acdcd171b3347fa1f555b11d39b6f8ddc2f020c7d9b3c2eef11d722d46428d9a9ef10aae6d47a21d5dd2ed6ff73b4eb4ed165373a59dae45991c8b9a641d274d53e110753f6a9ca6527b0c0b950706f9e0ac2b4fb1fc793056d7f5a63f52efdaaf0f43ca0d7a24be2caeae4b9b9851e356ab62238db53c5aa33a0f627ff2f61b9afbf02f83041f516d483db27ef53cc353f579e7582fe0a6003c3ca3d92d5869540dd3e75b1225319646b3ee3df0fb7c323bc669a64b7e53e9fe7d4dd5f0d44900d4c2f507235f44a7d6e42d33b9300758d1557791161707b3931f24f6d5e02e82f8be3a1de1f93242e12e2f90445899f2b9276b57855f37ed6926b914f1dd59c549885c76ea18d152f2f8bb3b7fc37425053c0e4de1e117903de8d540cf318cf5f0e5fdd037e4efa978a4b70cee4327a062830593373c87eb6bf8733c42d0e65faf1c69a3aa71005987e2332416b07df9e04457c515bd1cb60129257a90b285e7d28ffb45f22ce0f2e7d9f0c4d12050c1d47db5d9edc134dc205732a2c38ae04d2599412ab11cf2a388ef596362f19c62fc8e302566a4af245d1e8caffe63872627f14eca72b4da4cf0e56edb6d381fd89f8f0a64c621da8310009cf5e76807f821409bfef760b18817830bfcc11a4ca8ae52e23165a502358b3851a2f37685d212101e340037b2e4990a057ced557a80fdf5e1900b5023ab16083064966669052ca12ef9daa819ee024e51aebffd2ce7c90124985445277995f4a62dee6a77d4461cefa6fa6ac326ee941c8d29cf2b39a100d1fea4b27973f26ecca76da659c554d793b2e2ef254521e049b25bf18ea0e2fd1f83f433fe0a29145130bfb97bd02d773e69e29e70ecebad3fef4ec747d0e6c9cb8dbf305f98cf77965c609febf2184e5112908a320f6df886dc71b22a75d60acd7ac39a9ca19b9b215d496b6d25d8825cfb8a68be0954fe882c9840b7da22c5bcf935ab82d40857cac5dcb846c88ea8aa86dd0179a8a1fb26c1f6ee592c495a5a96944d134455d6f5e404420851d0a91115def2964c18bdbbda9e54dd52e35909848f75b86afa293376f66704c60f4a2f372e9c6bd9f1df8ba2ebc9019903a5ba361956561b074fb2fb596b55f52aa410b211126ee36a7eedd6b97ae7c37d5e47473a4a0a6eec822c748d8996f322e92593d240d3899b04602671d963df24bab8933406ade69fca01982cd6ec65dbab49774219b5e56464b1f8f3e8dc6114b204bdde105cbe6f568472425071e9209e73fdf0d4869b501476da0cb6555fa38f77a8a0e6476a9b3a38e6b15ba2f55866e906504791fe14c74bc0cad6cd2c4129eed04763696f4615b166cc6eb494a7f23e2aaf61d509f8bf173e7d7671cc45aa11272154efd0083d6fcdd3ff12190d511317ee57767d452855ea8cdf4de7e1e119349948e999195269cf262717c692fb53bd856049d71982b064ba9c674dc784dba66a0381ee2362dea19f34d2394d88b191c157c551d90b2a8a5680096ea8beb7e106d6a1a599f682073e17027495c662d4cc73e7211ad3287a109852856f062e9866d3ef3397b610b30e3df8b6465688e628fb0173c9755e0ab3d4c610cc5798e179ce5875e2455c223f54729ea076fa475a398d808802facf9c369000a005e18c9f2d168470b2bae809b4dacc0c0cb631978bd13ab6ba59784dd932afb479da9ff0a528c3d2b2a237dd3021df0b3c2ff1e71639dce560749daa0ac219399636cd09fcf3c257295ec4c6d975532b00147ba1a777cb4c1b891e88f5886573930a98ae9f15ffd6354c4b26f19de4e4820b32695c26ed724baf5d7d519598e6dacb0da5f5d4edd0ea4476e1f108365e3006b7b195e2e1bbbf0c6fd6efa768b439c57f663cae748b64338d410b505eaaacc0db63394d101bd37118a245abd3a916cd13b8491a3cec0ba90619f48e853bdbd4e95a96bf4f44e525a2f0a01ff907858d93f0460c73849bc086fb3564fdb584defff528f041b956824f0ad7e7ffa2524fdaab0aa20c56ff0485def9cfa21ede587dd4cd2289b8cecb60267b07077282d136fcee7b1c2a6b9e1081967a0dc81d5f4b4bf20c6dd564ddf14110e4b27bbbcf009661ed544c74bc3a57686e3169e0abec7ee8868007d8566730e83ca04a199f7a93149b815d427c088a61cfde7fddb271fe11669734112dc366d0e2add2caf2bacd85ca6b668609da89d0aac1a71985943e3ac6867d721fbc4efe1f0c252559c104139e2051d618116575bd0c52abe0b2a141dc9077dedf363032380db4abe155120106a9fca19a94f7c009c65d78cb068949ecb906ad00c9ba2b40d110aa23f940520326c1f4b4c3c0a6bb1a1c84d105cf3ae42838bb215e9ad182f43e06d9ca2c2fe6445c909daf8b247e727e8f6ca5a92cb429116a0a75adb3fbf5b49a35ac6b76ec6e7b25481d97fc83f4a0928ed22e1519ca1a3fa8da9b69557faa1d9af7ee0e4b0c24495098337da0950b01451cd061f93ad9f20f9ddbe268f06ce7a03504c3ae6640d1e25cc96d39806cb651798e97ab42cc30916ceffd8c11487dfacd3da123a11ee35111e1022c622d12efa691bae790e4db7253f8dadb2d436614d8bd64cd923579833bc8c4676adc89acde2146210d072d29379c0840578c427054ff0598408baabd17b3e212462fd6027a35afecdb25a733d2055611957ea2acd0805592b71b6b5afa4b5640678f49ed54b95260ff8082d39e3934741c171c373acfdc522d9d6c120675d7d741813fda4777be08847bf5dab58629fa25feb3246d75aebbb0d0eaca9b732c79c1e104717eafed11f7946ab92652b808419d2b5bc8aab48430f321a6c2a55e17410e3c754181f2d45c07c4b074be9c3167ecd45e7cf23822fa672af0feecaeeea37a762a36a6af4c22c3d026873110fe59adff4a03a54f2ce68d07157b993817bd6777c17b0c49789c0a5e8fad092ae65030e9356ac1eccf53b28e7217cf64c2fe3eee3779b810f85a08e76050dc57792da3400521290e38325e2c69eb7e16b1632f542df830248bdeffce6d124b3d6906cabbbca775fa32bc11edc58fbf28d2302815fee74616fdd971277e20a3c948109d13b1ed413a9534ecb635331ea5a89bbefe5325ea43175250ddee1ccb25e49f64141aed2d7989fcba2fbeddc45e54e7e48dad7b2ff993c071eef71a23d6997bb3fc6771385b0a36fea049513e84a6fc1dd97fdb06216a5c8ccf0029af5f4164118a9296a7df765527d4f7d743f6bec58e680c68f814ae4938c1fe17f09f56670ed9922f1d9b05ad45d0150231971109e0a6213ce652e0248e6cd1026af86d7d6c7962cba8d3f93a816963d746f96f7b7f9a51a01a5a9f440dcce6b2d97625aa32f381151282885929ea45b46b2dbd9590d68f9d79f0f7ab23133a2664d9baf7f5f749c751da1ab5030c90a1d40da536f7eedb2b8d14f8212dadcc7376497671f4aacea815e901b1c9b0d1486bf75f77474d17146453235b63ebb78683b0bbab88de0d4182f4ebacc9fe28e9f813b6743ad4e3acc783016ea6e5a303e21caaeaebdc05340dab5138ddfaade683e15090b56c355755988c229c3127e4188592b3828287aa7bb811bf69ea48e84a4b698581768e065ba253406667d21c4af827bcc44f74baa7d08434e8f5868a87d4dd4fdfda3832172bd8fb487e4b3ce7e3d1131392356efc40c878528b2507021f25664604afb11e76319634183e7845ff15bd6f3425fcd28a08c2d778214b10960f6084e5bda10fa648531ffbdc69050f4d88d9c1b7d32968a4ab09c9dbf5e77d3a33a964982d7dd80c6e8fe1f662df1499a046f8ceee9a1f77e2da0627b87bcf99b0914ad7189715743c1c7dd758a9f7c7da59e1ce7f42a035533078723c0d60d8f0b73be066d4847709323c8377cdd7e5c5ac596118c2903aeea05159a336757c304735b891523f4f0c9d178a23fc047189e61f784ec20c516f1f5349d77899654d6ee4793b646f055a322ac5138eef4166e10c39210e2d01ca8c9de0e91cd46fbd7b67c091b079cbc2d668e1b234c9c0c9664a3e184aad002c20b0c7f657090c2c4c2110c344b31fdf5713012d8cd78c6f71898bac9d0b41c380d7e3194411616edb436e88cfb10cbc4ccd8510adcaf452ef27f10adc88149b8646d732c3617fe4169b4486364f0a942ae7845f2b90561351a4db5f5fcf8561af509db3f31cb1c1f610112f47b648393a0cf489441283d216bb986d00d51979c1f8a6e2d7795a618d0642c86db339c16c0ee4a2f46ec27f37062df604a8f5986cba02b28d47732f63f1045819493014a03ce7880084ab7216ad18a7df4742e01dfc3f4f2a95db96e57b2c399b265c0080d63d82c70f9525e1f2313feb59e2bf1be4b20ad5d3c30f60b6ba4da3fb0745ff7f78d0e7c25bf34a78e3ddeacdd5b1344225de8a180962c149f1edfc72cdf4ac70c11da33dd68d22022a0847f627e4da57c60930016e8fadab23d8cd7b6a1d2b641f011d644390beec76aaf9ef52c9e558201f61614fe98d43706c30047e014c044d18243612e45161dc07a500666190a4e1eb7c9d03915cc3ecb7246be09843edccc17a8e271b6f42e882eea2eeb5e5c900a0a3a3f092ca6d92b14501bd8096e2949244254623eebd365555460cde2133336f318e7eeab25285801a07989d928c6fa7f262b048961f81523199001c628f541953b00bc42ac3d78f67064c0a84d8f290848cd6246cae5ac34db3017ad7c52ee4d6efdb865a5af90282842fe1640f5f8d2becb30ba43c8af5c243dc4a874cabb5d865241890837714f11c982d3fd17c1129b34f3b3ecd362322fd674256ff27a75acb0dd7c774a37a7c570e011a5ccdd269eb7c7ad5fa7612e1b0bcdb0d2758abaabbfafbb452141678987c854c308a7736f856563f4a670132152e39bc3b49052b5e9e282b8b4e665320eb056fb9b2f13f64b1f5b08e78ceb0d2059fade744d83d8284bf1e1e46a7459fbfb00c633f299da5a6e869836bc06b2c4d33205daef09fe2271c224289b741f75c3e2e287c922a6c57b6f8d0feb59753a95f3f4953b83f69d5f00cf2829f612653478e21ca8dd1c0d874c2f810976915ba6432403473e4a6197625f9b2b2dd5a36d774f9b6b1097254f4ab4c49e953216908248044a6215a3b921ac8271912c3d21b0e7d1cca50560098e9d53cd558305fa6847514b4aefd957b0a54272216857032f5118224012dd47c4274c864bccddff3ec63fbc7e48cac2425e00feaa6913b2b9c5909be27a713bc9aeb0ea88380398cc7508e9bc72f4811ed9eed435fbe6ee4000f57eec7c828709953a5a8243fc58caa92bea337051c91d83d084e338fa7cefb40ac23cbc57614057a3582136e461479b78b7f9461318e12b82312211dce41c738c0d88e4125469e318844eca91a49f5ce90a225e0b64e8367ed3617ebe61a46b24c24a617aae76b609c6c9df7686ce6270a4cfc21a358bd9e5f6c97297e3f3bfa8f203bd4122884cbe64a1c95c6539ef7aa40de23e1114859baec6cff4d3775738702407d1415403e8d5926c60668546d2396605fefa8964042c471412dcaafada9747ca9a10e924ace569395595de7558f319417e4e5ba5db60e1738d046bf27f7197a6734dc9911e049c7497b56b87f5fdaa6f92a8c611fed6c5a684737411db24cef253ca3033ba5ed51677100de964e5dcbc7da611744f3e7bed7518ed783ccc5cc566546a3d8b5cca0fced00e0faf3df9f7b4a47d2cd705fa87b3b1c57d395b7d4ec039967defad3b1080c28fd2fc6f4efa65b45d37914d37568e01464783ad6eb1ed95788b5ecf2e4d6703799c6473ff4ec12ddc44c4848ad6b0ee12766ba1102e19c963170355fb55200b2cd8e724bb38955acd70d7d91551cebc8c0f95d54cb648b84fbe666aa01ece72a6219c4a55069765c74c450606172347d773e2b5468f6037e1d1c8bc9fd695e81a8e3082c829175f882f4247a6c0af032b263da25c1d3151a94433fb3196891e9cdba23f309df24ca69bde33b3a51b0075a652560443db4b9225f2f4c2d701b3efc99c2ff2ba679aded7b670b59665f302ad794f3de4220ee4c89142e6913d0221bf1c22878d4df6d99a98693b6efb4372a884e57402f1e006c732eee77f584ad0dac81347c2b5dda6cc8ad6648847a8e78cf457ddad8690f1f4b65933c3a9a1b2d23201f2ccc34678878b4854aa36259aa37e154361011110f049d2be5599a96dfcd7c7bdcaf35641fd3f48c07ab1d185a98d2f28f81700c5a009c8a644f3d2b81d85e56818422eed2cf52e1b0bf1e6427775dff119f87bc7c7414a998cfa90c8b264914910b1e19f4223440a4f7d7acb8daa36108716223a5b1453327f6f89c072f149d7787a0176f65e489b9df4f90237b95d7033e1e76188bf75f40639660d88f05b8885e73a5dc42c50c7572545f3615189609cf7061f7037b32b979f6c6863fa8ca4990aa5e22630d50a1c21db94cbaf1ec35b211e3d9c7069e89eb1f0cd1c82129fd96dd8a778052f90031676c3cb289dce34d60ec44931192f3e83caef87d5e2508a1452286fc544ccc79cd98ebf958d259a224c94ea59dd3061ff3cf28f34f9d6b264503457332ad63b3faf5f9b984b1a6080971d6fa1d93b8998fdb46b432531f02d1be74aae29d46e89e3526205d16e50a6c6808e7cdeda4b51d7ce95dd85f190593616be373a54f3d25eb5f497c71c5e0279ef227c6613dfde80653578435b26799a6d78e41bf436d05e63ec7259fe833b696acce45efff5b4dc8752883e3fe8cf07ae30f73faeb8b14af8ddd6537e9f242abbe582429368463800a080f8d1c96b673ab088c604efe4add26667a26abe66d17dc24b5165fc45233ef6132c16cd6d25152d680b795f5d8a650d5f5a403401b44d31cd466c28fec984478e484e262992988a63957bbac190a6f1a02d1f8bdce207e768ae16fdf6b021033d5cd57e4d5465b4bf03c9dd379e4e426ca0b932229f434f1e006b99ed47115f170ae12491ccad550b3d536ae4dc8eaa6a7a2ad0865cc96bfd8ae1412c39583bc98a6356b9c802bbd5603054759e9b0a62c04c38c776b11c815a61590b795a64c4888f75a0f24dd432fef86a0f383f40d83cd5483d12df59416f47d6dd737885a88a6d1b8c017e01d98131b3bd896260c8aae4fabcec2abcb882a18969664ce0457d678ad8b7871dac0f296a17430ae204b6f3969086398d3b40e65f6b23623bd11fb9d06b68aa233c7a1fa196e927c29cdd6485155cad9e09e5925b97b4f9c7212e9ed00d36e6075345e7a94f543cc450d65ee14539da80c99220e3ae70fdb3a2c344d4da930167322538818c59730b85785fe5e6a647b2eb62dc8ab662d801fba9a1afcc4012a20699a0bd599fd7d1285cb4930df3aff9ecdecdcd1b3470d6815024fa276115d9acbf94e6004138324dbfa14fce41289b9a842e43412bee6bc66a8731d586d92b9055c300b62303dcc36feed38b3e156ebb66c264cc65131cb52cda5da43bf229b0b05f004e269d4d03c495242f29fdc206b7a2f35ab07c89d3693fc644b330345b70d08cd8f81cd8929a1b0738d18c23da074d0ff51ba4ac1af0124bde851c0b9a0945e9ca1f2fdc0b558d09858f724f5f4eb17d8d98128b8967a1451eebd94b76baf2d6c5577ca3cce9bdbe58602c29175961dc8f3634613dd3e8f4460c63046241a71d43dd1a6b1906f037ea33bf0e7e6ed935641f9bdee387a40872eca6e2e1ce0431d98e943722f6ab823adec1eccb4d129e95489ecd0f6b08d1ae4c0c956ad97a7aad983c7c23e707dabe7b61d11db1b3341cf02897a0574ef0b1ea8e39986136f37d894c887f14985124a37cb24b7869741c44873e59c0b9e06f21ebe740e560309f007eb79ad483ca96df14a3cac99742b893d178f5cbba5e0b1f311958b2979f73649d604c5131fb03dd468a615cc933c5c8dadd664571806ba3869af17bb9730a0fce4baeb57bdc21ecd24fb7a915a0eea5dd85c5a0589a569c9519eb703543c95d08b9ff3358a53ed330f4a9707d386d73d9d2c0d950483dd458ded37e23b4a738c5e5fe74f64f4350105b6a3d5600977f699002b0e5fd07ceea68f502c5f5ddb87e12463f34a7d3dfab8961523fb496325d7d82a609f53f81de7641aacebe8134e962e3f6e083b4fe0e42f8d37ed04807f5fb67c7c7d44738c9f13579e1d4c397dfd9639c9cfb82325d6fa41e4b26c2149d95477b41408ea1b669a86531e065c73485031abd8daa60bd63f7f134319779fc5babc10ca75561dfef64d3d5f11d7bc4d4b717eac8f7d159a3d1c3f7ed11a5a615bd8c581caa7db63dd5257fa0e29a2d1fe38d559e334aa0507ffeff2ba87169f647ac6d1dc2ee53e4551105e3917499a519e09cbb6cb2604f5268658796b355503fb1eca7ea07223a066334116296b7f2df63a4475b0f0eedacf717a2ebf4e3e4ec93305f131b8a9b0523962853acee5b6e1409c807b711ad809cab012aba36647e0c3564353f60bbba184169def8c5d039d9cdefa6c5f4ff757cf03ea99992e7928c5a246bdc82aea365c34a96a72b7838b2d3dd0dcdce095130b78f34ff0c88bbf74a5b9e1c2f4d608f67219aebb6471f14aaf517642815bade64e48fcfe35eb994f42aa1752c225880a3f40cc4200a32325dfdb8365d5199892e3a8394ea7f2c0cde132dedf4a63bbd039b3fe347b8462f59c81a3df7dce787760943ab883f7291bfa5d31279455d48a6eea1228b624977398082e02ba86f7ad195bab13b519398bac2ae31d6d4a4b4aa60f1b9052468ec3c6a86daaebca634da92d107c5a8ec3fd14b74cf1595cdb1b85edf5b15ecd668280d2c70e265b88b7402e175fdf2dce95e40b6b39f0d702619ce63b57a0059e57a8915a408b1fba4cfde27ffe8e5efcc254433b6a4c37b2b3cccddd2add7fea1f9bc809907fabcfe0d344899562eea0316aabf8a8dab6c71566af00c78af32648833afff66ddaa397dd07fd4993475570f20cf86e06b37e685465fb7a8f6989f2eb3271cc66bae112a0f3443c3283efee320abc4bce886d48e934311676da150b08738cbff0f0a103e6e07b66c81aafb74824386f94d035b4fb8bf9ac818cb073869c5d94b9cc8cee04b6c1884309b83f8c83a3c3ff4ecd5b97a0d4bd1518d554a645e76ebf93fe7d2486b549e21cecbf5ac3a0303e9955a6215c854cd2075ddbbf9c6285972e6b9bb10183c3a388bf69866939660dffd75aa53665439aa07711afebe6653f54537b1ded43221076bb205ea25def2b6522ce1a740d8ed90980131cc08f578a082e52318d86e7a82e61a4639004598b5e455023fda2c6f6d8b2295253be37dfa757f4c9060a7d3bd5985549c94e0ca5316109fea0ce42c77774dae1ef154553a79b389651765670b74e54e71b443c2ebcb12877d0b0d00a5e260bf9be1c3ce3ffd686768b2bee50811834599985bfb03194df6c83320389f4aeecef689990d5846985b30a90e1996beb9646437460f9c48dda5df","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
