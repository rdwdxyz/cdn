<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b96db1b8aec301ea78e5d96f4e0a80d28d39d87331b07d6551afdcce943dea59105f20c7d11a64985378f1558db11cd879dcb45a1ebb34476042a15b516198eb70cd55c0abd6243fac8b7d80dd5178e8ff513c202bbdc88dd169646d3acd0d51399b873a424aa3acb08fb08e9fed7b025bce87aa240cd6a22064d67606488be38a518c156c711648a37b131e3c156fe711d152ad3e680c76c83ef12180c512f92aec9310816506226741c3d90947b7a5072517934609952cc132540aeb90c416faaa6065667fe1beab6b4d758f6bd82a1e7e256cb310d2dd121315eb61c41bfd9a5ba31a1954f11c67720fe211e687a10c57da09ba5668d060c882404f55728103a09df0923da27a466ffbb190b67b63b890c5acfdecfb5f93c94b7cfe26880081fd4172a09648c4b427b409b439f2c327f55f2d8c8029597ed08d9992a90cd3a0760e716bd0c25b4070fefec13cff145f660b379f2f0c18b207bbcbee4e202da11b56135b5e884e479b503274ffeea462c1b95472dd78902532d7eea9b03e2c836e1cb02512154d7f661183e27e87c1225f462d22453262544d6d81c244c622b79a74122f010a76590798698cc88ddcc090fbd3173bc9f6f92ac7ef410769d0a8ce251860dd5494aa34ece5885e928269f619d39afa1cacd5994fdaa6cfec5414b92fe0778b951223cffa8f0e97b674dd0c00b34f36ea70de3abd91725f851e0ceeccd3d2274969b6459acc0c18f898588d3a8f7d15448bfc274c17cd5e0e0313c0617500520b324c77b88c62f3ef87c204dcea186a8113a0e8691b0dc6dac6388a11c3c2bc6b4da9881da2291f26a154c7f45ce5f87a8491a14afd8b7e613acf74277dda6506f63305daf5d49354c34e24b73d4cdb03da54fde8974ad397ad5ae368d36b1842aca3998406699374116f1c26476aa3cadf656211301af26fc24c7685f655ec74e80188b746b1a16b162ad81495751ddb0c28cdff8e8bb69d44618ae763ed25facaa7cf37e924aac85f36cc6add80d0197bf1bf19fb3f3600e0e9410c758c985059bbbcf48573b9728422f92891367f2887e5a9ac56842b952b1bc981378aaca3c24ea197edba2df2469b68ae55e5efb52bb12c42ed435cc5d2bcfe1bd3dd130c02fe49265d4dc35a7a49bf8b013fa2794a55c6436aa2b97a2c9f299837cc01282eb8ce85e7cde6da4d7920d73c485e7e8077c44cacf95e3fd865a4da4eb16b6bb4bfde718ac9cd91f24984be043dfbd618f1ef40fee6c5219363fc3bd1533048b1179ee58ceff4e3b5a0428c185ed5be9f869f2e948b931a3fbfef97be40901ca27360abb676c15423f770a302852d776a2d0154b3e2842ab8cebc3362a70736773b3c6003dbee4d49177f58d1b28560c82c97a69b1307ee1e6c8a2041e366917498032911d00204763fd1b6d5ca2f8c0fbad10594150aba69a0d19d6ca3bdfd77106f55733163717cfae066c8e56e205e30366020f8c54d364f071f01d607d84d7a2ae43fa364b2f62dd024806c3fbd18768c2eae0cb098a7567c37711ba1c173ab86dbe12d885d79449ad839993bcc6dc8fb2843501a6dfc5d69f08cbeb484881db1c2c21b0a8f70549d159a7100bd56d77d989bae4f2d250b8d36ac34dd37204099161cacfc630f77e951704913cbf1bb7f74b8df0236f54952db6b9cc58fa24da98ecac236acdf6041dd4d14cc0bf9b9e20d672be3d12c0481a78f3ff3ee4b5af1fd5a1588ed4779bae00e4afb80cf6628eabb1a85b2bd7ff7a8c89593a38b5700b501e28028066b01a94483308ed75be740faf142ced14d09322ed96d749a3b61a517af22e54050a42da3b08261adc12029410a16e26699c55308fe49a6b874e870720de95f7ba4944c899134253f8fb03a4c921a00379b82989db018b05efde1727051e0777086ebbe0f39ec6e8d0811ca75cad56afe1fae7217564c682e16e7f730b56bd71c41a62b1d5938507c15c78a14072714f369141556634fbc8f3575acbf29d2fdb270bf2bea9774f99d6ca492706849d039e6f1e3452ad1b7ed1172a1907016e81691d6c82dd3f3522e2833a1cb55e358e93b9251622dfebec7fb620883545f3891a13ef461d80f600c0c5a5b1d71d858c7b5949f4f47f172bdb8c3c177951c8e6070734c363ae1529d771d4fb2d2e5d5018a5e1c9c3e28d4abd5dbdae0180b54302e41d4d16fd07bf457bc3f058a46b1ba68a450c26415567c6ad2b5cd9ee5b9ae0ff044f769f696b37606a677f755cfcf3dfcfaf1cd221962defa8e5c7584e4094042aaf5ad51fa2750642520474adcf7d5e98d6bccc7482aa32a547e8421fe9efbf19d5f93067e753251bf570364a492d7d5329fd1458729bcdd9c629f63b6a4d81e9edbfc77625063ecf35bd7d34f5887a90b8a3099b61d64a5345bd472c1a52edca9833776d6f127badfbd1f76de5896608cf73bd474cd7ba0d4d2da130cea95e426908005dbbfecb05c6681f1b1cd4a454913c6583c8b7c4804e0a704682fe1a3aaaad043487d1edf47b1b633a362bc95aaa0308a6bd424832f196abb75c711152254443921df2b85b6894ef41ac5a877b3a558211cfbc5d92ad6d424737126e97bdb6bcc845f4619279e6a302bd6b651b8d6c2a0be6874a5d8f4587663244b45263f1f4857b586164ac6b46314fb85edd3499a71890ad8778058e69c986efd3745fdb24d2c0b0b7371959b0ccb0894af604b168031f7ff0e98ac5a58a0e7945945f47d35a63c75957f4fb8a3e8c454a271c1b55d35ce281d3896477d79a0abf79724d2f4a1233d2242387b4cd222a740272b43d559c2b08fd5930d369d3ab93ef31901124479d8d7b5131364a6c8b3b33fdfdca4185702edb585217d0d633ca0581ad4581e086b79f3aad6205300563f3c7685ea9f89a38cf740476ef235cbffe72ccbc4d48057473ed50c1a2f439769abe9a8a9c5c28c3c5b597989b2b18f471ace3ce1e5bfc542a52bf73ce06c60b8e4e84c9fc2d87b3d9a84967957bf2f01083290841f844efb219e995e084e4fc36d49b63bdcdd52cd23ee3aa90f014f0b7b778af415e61a9d3d485fc996865a52a1e306d7ac2716fa95b35ee44ea31f05c1ec80b4eeda8b65af3cd56c138f87f0ece7c9a1abd0f26e76eff4be298a8c8582127430a37fdee5a38499dc036bf143d2f7433535c7e1c743daf3265115addb33be80652a4fb6204f9beda2e88cd10762f2414a2c8e0530c5f4c8621f1fe929ba7415119bc6f388f325f5a1628729dbefc3d6848eac6e38f49211d7ad16ec57829fac9333350f78dfcf21309dd0931f593579edcdee494ff5ce2f7119f88d47e5a8939a726eebfbfb590290f499c60c6328db2e34fce2fcdb538b10eb1e71bec59ab8cfa6ed27531565b5c1fbdc78dd66d571cbad06bf3966844fbf015f2e683b36e59ef6048b5924a79463dfb0df76592681bfabb0d4bb3fa3314cec0aca9768337e1085b0870c6eeee3e2bebf289da7cc0f2dab5dd32808b5284cb6782db73528a41069a430723ec2ba976e07c00d08e0e4669f52edcc0a825728d27f463e08792168fa71443f4b9f8232d52506026819151e55fb01170d4af4559c432c77b04204f11cc095fb94aa6363173160f0f41e81488a5d7628ee3b306575f15f7694c0d19326d48dd303ffbcf53f96b63581618142a5df8e4f479c821129615a2b8cdfa5b6d0c03340b7f654664c60e8250a93a2ed11c12cccfd89fca285b394590d7205abce13018e6b638e7d646c79aa6c81a9bcf70e1707f55a57809da8d175da2ec044c0c9b1a34c8e0ca0cc341abc7e585e6150627ef5658d8aff7244484f18e20aea3df2280e7d7e9bce8bd6d7e796d8426795eaa158ae08b7651c88e14b551b6e0eb16022f8a131389374ef5c51baca5f57fb9f03b729cd37b3a2c6f499341f51a5e5af2097467d34a0bddb648151803b444e3862fb1c1093ede2fdfd3560484a8a21469fe18ec6d28289aa55f311e99081238e3998280243a90deb3381f7a9786dcb148f0f8468aef75fba90081f8dfeaace2cc68a0881851cf59b4d2653a7b6c08ec099ade0b3930dd3f75374f41e6e7385ec1dd8668bf6d23e98bbd56e1bd0e07b99cdea526b1a9c4ad582b07aee16ccd93c1e51a6ac7d6a6dad5a461b06df21d3ccb10f43ae54d94bf6fd4902f58540a80ae86caf2d4a701966e283614fec366391c2cccc54963a97d025a429c58a06c07299a69e7c3a8d667a1b26cd1c809c5a2724ad0773983e8c3cfc1a03a3f0b0338981a950b5d7fc5b4758ae83a54380d8a56e01b6a804377245d8fe97901fa98dd523be55cc0d961b774ffb552ac11c582488840cc31ad3e853c11ea2d5e90bab7143dc8efb09fcf6feb4bea0b1df52dbe835e76d1db54c79b2d7ab7270c3d3af6ceeaad1b51a24011876776e01f4a6c6c80fc645bdbde54572c514e33573e8db16bd9ecab7a7e41b8b803eaa6a3503a4ba12bee09d59f0749b167e89eaabe4e230980f107dd21a3b280f5b26c09771e4b2b155ce7df5e46ca00d8843bb263653c5dd722b604d96a26904fce488a4824bc84c17314da2fb8bbde7020bc9dff4cb720179df64be6ac09c10960fb848da72b9a9abd434b80dfb9be36596f6f4f33b0f013d0a1bf35f5dbf3f37218177a3c4eeb83bbdd59d3831e27264de203cb10287fc12107abf8d89b6b858d4bfed512208e443997b465a5c0fae691f2c25e9f2ca74e28cab3f78f9e8a2f7ea360dee3add3b4952a82c9a748a985e4ee658c5c0096020ada2246c0ccfbc99a64d7082cb49b645f6683d8f4f51affc006651b81ce7336f09fb11540c44af3dfef08940933efb9ebf0ad02f38faa9a08fcc847bd9d6edd9eefc3baef7427b9b580f0ca7521a3f02525f5b9b86df8d592daed18a3fec8d2811683e5364bc1a3417a77e299c280a90e1b78e4d8546eb47e0daabdf5e502c6a9434bf78d362c9731567183f2a64883378a3dd6040e03ab74b8487ed94ccdf24fbaa495570eea1aca488f841d7cb9f4ef52f608af016b27e9410c3636bc458ace850bfc6ba5d9f6a5b9b54e92f3af36d7e3c864c52e0db635b8a44099e6211e9b3d9ff4788d77374d7bf20a4d29826a02f5e0646aae06699ae6edece0155166f3bb77c33651188ca7029cca39c8e2f0c6f129cc295d91aa4e133a1c849ed8a998052eca057c4e99b4b672ea8d4ba2032835d7b6466fb9c4b517e792371bc9377da88e7c1a22b71d8f43b0589dc7726de4d4b18632e5551d8a553a394f702a870788c3a646f442d23ca0aef266fe709f0ad4491581fd07a5ad982905d1348b6af9c7829db86fd255ed86c4a42986ee0f72072362b66a66837c63349cbcc09e20075600e132e4be8a7e8ce8a565d4c01055a43ffbee0e1a1b3d3df9a10ea2136121ed16ce8901dcdebc642edf899334b419c5e1ed4ddd00f7aeb1330733eee511121fefe7012fdc2c18721d91be55060a201934735a17786e01627fca404f25a46aee2f982c701041d1f07f8ec4f4c4342d29f4c8295d1892c9aa62b2192f2fce00e81da066313d74c242b6d237fde806f4c2169aa4f77577cef2412aaf3a39afbcb01e4813e80678a6b1258a73785c4597f10f37a5de297406981e231d86262f4aa7099307b6626bb6ea0f35c3161ba015db65750ca7bd0ecbb042e0cd28b0fdc06e47021001356915ed1b84a846ace9571718ab935ffa77a9f27384755ea4006a0a5ac2358e9fd82e653456a6b3e391e9cc20a7aabc282216a20d0d989d7c8ceee2c492afda65f90e3a51ab7e8454a1e9b0a696f3f066520a2dfcfda72d5d6738f950b35c85c76609924862d0e4f0b2b0034739b4f98e35a03ff19a3d036953fde5b7be740383382269fc4a458f923759cf774e78f5dc1b7a070640d14f359ad1cec2a72511a03dae5fa685fc2d45cdb19454377cd2c5dddcc6193514d158a36a46f630d5fa63b099e4e2fe7d1a2ae1bcd3e5bd490a276ad3d629af37e55da1358b88c605def59c45f97d577d5e7c0d445432b75c81332d3c51b3bcd22874e508f0942b054bce6354c0e8fbe5d7699db8dc5286a5758cfd33ad7e7b4d3ab5fa04dcb941ff45be9d417fe54bb5c89069b6ca2af0c0efa979b8ec371903eaa07dee6a118d69c75c6361beecad27deb7a5de811e3aadc0b93adc99ffd1a5c3cd7707cb7646867fac99e6a1412977ccfee4d6375af65090a9580eeaf44a2dcee1b3ccd8abd6001c9f4533ec72af19fdc2966e385e0fa3c2d90d19f1d6e5193e7a3a330de5ef77d8aa413592d4d31a96c6a3d3eafde56a4e3640e5fb8af935e4371b2c868692541ed068e77339c500d84a6bf2a8470e9f4a46f898c3f9005a0f38dd1db1514162e18e983425fc34ee1ce96bbb55fff979bcad4ec038cbf7071c3cd5681c69ca247ebd243d8ee8fb7ee924d2bc7bdc26ad21acbb3dc4ddf414a4652e9da505d89db6066a8252f298e00374e67c2059ec14a9730567b0e6a7034fecee9962477574f0611f9ceda184a54cec1b9d5cfb2ba3d9575a00aa029d331056aeeb40f4eb87b74478f8a30e46e8932229dca7afd4caecb2eb9a27376324e8d7b89ba936a6cccd431925d41487b94c8be4a99486c88a88fe75a909224fc76e6b439870e279a2f8917f23294bbdaaeab08696ad192667b84a82f58c1ac51dc883543efeaeca85cb3ddf4d515463aa0e3aaa4f66b54174247d15d2563d9a59569e3a192bb1fdb14b47cf5b29a541cf1c83a444c2b34c30c37e9c51a324d365a9ad558f57d4d416a3bcf8d846fa53881229a2657d01cf79789762be1941a13b993095651364b9c0b1b1533ba6ad9e0850257999bb42b09daebb23787c6ad0adb11c80ebee76f2902fb74017ba3a5a31deae33c3a137d24bca2cd092645d1034e5a89c75b9d839aef8747a7a643f004a59cefe3ab05a914630e5cd28b0f2f3e121d983a5a7b692529dc550eea36a22a7382960c8c948c47f73ce035154e4cc4531eb5922bd4b52a41a3dbe81b4c0f81714d57673eedf5f601a11595b09a024499848b67530c19d8c6dd818b4a41e67188e5487f45d91fb070eee7b6cc817133c843ff6f7225768978e013bd272906a84a232fec1f005da0cf28d152afc532f144692eaf5cb9139b91bdd6a577a661e14e9c064485d05ae2067d916a7f4844e97877f8bc99001198ac7010f9510099ebf563c1d316233db71a8e5e5039ee4304273da5a8c82ad91b569849a8be334aabb05547db3bbf7b523892346f86234cd7005d02cea381e528b755adeab23463ec7170d3af5d25adb80e2cab87c590079a61c630f348ee326ed1e6951bc73bc3c4a8955348262064fd21ebdc7f7aa68b45e3c9b9ceab587507ccb2794b30e8dc8b6df8ecc452471d73f00d3f80703227e1d63563a1fd2277175179c414954ea8dfc346579da920425476a0157d4c1e417f914a444162beb1e066ebe83b3aa06448f331abe0ab8b3f3b990f6b1c1105ec34351aa137cf3a1e6cfcb771034dadb0b0e13ad7514710922c840e78a8b8da1c86d92c3d12b54f9da936e358d372c22a2d4df17f4b4d81a42ca3437cfc2cdbd2cc234d9c349af695836b139d4f4b11ecbc50af2b6375422acf1bc1285b0671f0c16c2759fc118361b39464fa7fd537e4c5f193e3590f58f68f21f06c2f6a4104806f08c7a4b6e5c5058805a45a1a4a0d89f872f4b2e5ecc42be97e9898b7874daaf223a45996ac3c871a338bf43ef0dbf4f699f31008e1d41215be2ea8fb03038a70358d944b06dd11744ed9b6031fb5f2f571c029263ee1f213c326be0db1cef6aa1c6b8a4b186a926dd921c64597a7ccbdf5d67140324b7778f1ba577b6f66c30ebb468343fde86a50605a748413b50e6f122d8c8ab8983593fb5a72105317cb8c9bfca56f4344518e8309606937c7bec9a5541b4faaacef49b8b6e8d0b71d5be9f606ab31cd1c6cf3a67f8d2527c86398bc7d617a24dd6245fa37807e7ea4811737fc773a0a51ae4a28a7688c03c4af90c05a4281fa02bdd8fcd5226d49919f734e9d0b8b6be240f4a2903e3afd29ebe031c1a0cf5e7552a57d311ca92849f0239bb6c6e6a2c9ca50ebec38f34abda56e01cde26613166a473488356c5fd0f17c23c288fc276ada18071a6f452f1455209e5d69ea65d237ba4a2b09784c7fdda3765dc046674b1f0e9b221bc2b836ccfc1bb73bc1ecc6bc105802426a3940390b301c3fe4a1854902b8c5e0008731ea0771c949a103f4a03c8318656eca9cb37389eca03328b70ce6e7b7062ddc3784158dc757d2c14f7ab4d97df189aef061241fa5ccc78eca782702508f92d569430c7ddae7891a771fd4078297014bb5cf5cf9f754496d2bfc0105b0581234e421549227622d5d754d10325d0f6f8ff5b9256300ceeebb09bd9e682a73a6e8a9c634fd50afdf8dc4c2be5e4991565c08061e326001f7a562326a26b23b84c8a6fac21e246c419c24be68c71c2915f04c71a4dca416d976c23b7731c831cf82971438cedbe9e981455f9155fbf868acf30bb8f981cf1ac600ca691025f53c484876340741e71f6ef3f739a889712586ade70e6011cf54a0b17aa8693f4f9a392b3b156420ac37bfacc270de9d66edb0014aaff19814206717e8ae723f69addd367c2607161c4998acf6480173f0c67874e10fba8a6aaeb80c89ac585c12d16702560ebe0d9dc6dc69db1c2bdd9889fd766ea11d04875a8f32f6851d4f3a218ddfa1c2d1984d73f219ec787593ba7cc90054a72d7cc10cb73e13c6d8ea23aff841d418b231fbe25a347927f40d060f32793938b1b23fd107c2423f05734e95485142ee70428754f6d70f288833cab083e5f587bafddc424d4e6bbb66aaac6c5f2c664a76e29aee02387632ef3fe0f0e6737d7e24d6da47e91962ff225935597d946de866e65b1f44d03e39bdcf39e5686c0cdf5db549df67ea7a7a6d9aba104e19eeba3fe062c83c482aa512004bc46109e069c13b7a36284d347393ddaf39f592f267422bea881b5bb7798afdfd22fa69aad0d87098adcf96cfc1d15492511dbf845751cfd49e5b053591f478ad5908e981232bf5d3d90692d6984685f752426ccd907f726763e4ab9789ccc9d001de465bc0f2712c8e7f104b35225e822212f7b89a8342f43051582dbdc060fa04e8a5769551e8ce2ffe8c3afc5659c9829b847409cae7a2fa99acb4f9d3baa82109d56e826e942edaea0ef0cb529b603b7ae16dd33cb4129dd0470b93018c7c8c23290e422b096f411bccbb2f510977c4d985ffff51eaea38f6c64331259ce7d0c0894280ffcdafd207b63e7c7fcf0b33f825a8e8afbd27328ceb3eb6df9313147ddd1ee69aa5b9113ef97f1d4cff066918cb755d0da35cfd31b5b02d0c66af34b97a5750cf131fe17ff2416d23b6c9483c94821438b5702ce6ed9f4f0f66ff535a589ce574f98157393fe072cb1552e3d099014cd217ea1871c26c8bc9f56fc7f468814db189cbee190b8692daef01ba36cc45b408d5a96d02526876553e4999be20a9771ad402a240dfb212b84c3fbddc62ee3a079046008d852fe76f9b6719812c036e894abcbadea8dd890e5359334170db3748e47be2d9404ed4b3fe891febe80fc4ed2b7c4de6239e796dd213a5e902db69594dfa6be54edea36256bad4e90b2c306339e661ddb78108c88e22867ca097dacfa018cc163ed682f51a797331e15356cc76d2516eab3b0d631a6dbf5524c0fe1f899f857639e7587450f86c245a527f784a67ea79e6c4a8778a1ab9cd2c843ef9e4f410de55db595cf84ec6f0107b52f6e4fb3dfa2969abe6260e28c2886f178ca130949145888258126f602b1af47147c0feb9176952749d7e6b10cda5b4aa13dc1168e7d1fed5a3ead306f5e7ae2d18f0e118620ceea0fc296be9f2645c6536298874ade24426cbe4e0d7f247c61cc165814782b8187c74b7e1bc2cca85e1d93fdfdab33479de083199365ff74f0fc80495c6bdf28ac4261aca4f826ce48086283295499bf1d55f1fbb1d6c6798fb1493b2c2ef3443d8527fc4fb086699386db0609a4cd01b6c06e0390d70eaae4f9cd2f53306741e291e590007e6a8ae0c1bce0365f3439e72d0e73715b0a22ec9b26de7e6d44c1a66f07583a2ced72a596924e6b0335f06bc6e080a82f22fb8a122edefcc168a7531002aa862de528099ddddac26df7166ececc17c150d831814248e0a2857dee22b346476e48e4dd8a1cd9b266bbda79881dec2e31a4415864a06f5867d45e4b54fea6ff9d802e7cccab276648206973a9e4f851284a39b7fd83c93efe5dce0b51c5882b803063d8c24e4d381e8558488f7c0f68ea62575397648f01c8bb3c7923c17301ccb0e0b8359c09bd44cb7c84d0a16540ab8a4a958cb2591afc026f159549e36bae7e5e7fc8922e299602b2781689b39a2c8d2008ad82602b7d11036bf340ed653abd8af8504e4074288a99a817bbe4eabf072eac6095dcbfd138b971df89687b0dfadb21ffbb1a2c38cada3999afd46a9f58abe582bf203d4059fb3ab2a5b62c725aa00a2980f7cb313b56f4e4adf3c111ba307044c3e84e1103bb665f863594d5b7f6a294421d909b72c3db2a33bb7a324a6b5e050679914ec7f9d4614991219933a32abc5ab6ff6da32049fa792f7ab64ba9fab59d574948ee6acea90a8606110efbe48423600aa8d78c419d90e0cf5292229649446d0bf077694789653d1f034da85c1c9393090a085108b1b16e981e61d69af64e7ac5174517798e2ec65c60545e5fde4d9606d302f750753a012e3aa1b72ac83655977cf9aaa79112e3def2cdad9864eb5944bf8282425bc13fd89b6ce1fbe78f501b54ed4d4f0b168de39ddf0ab48a06e2d1b71f4184e1d8bfa02b5a2bb173b6e1ebfb758d1c0fedd904661727c8029e297fdb0773d51df2ae519fafbfddfcec303e9c12eae70477aa19c95fa899d0df8543520accb46ca82687f079ad99b5c1823977b0eba6b4193ad79361e1b914f41e1955f216eddf6535216a5dded07ee0cd4af0dcf199fde6db501bbd7cbb41faefa3fb28450c5c621f3b99bb28449b9c6217e7b61849906c9d5910979e56269f97f6227250a9422ea390bfaa8a31e71600c7fddb8f790b3af6e05f3fde3e56cb7551ead8989e70da33daaaf26d9ee74fef44ac9462d89e2412b3b942f6d5c4d736e2a0afe3a4d278741e4dc9104bb3a340910d668b8769dc1e442b94b04ddd92d29e14be77a3cf59420d5372803bf73eb43b9c12070d54aa4f605eb9e491cbaec4ae0b7fda67e7b67fa948198d01dcd10b4ce4dd3f5e4eeb4080b0c3893bb5dde222c5ea0b61c125fb368eb4c2b7650db91e1e29d2b0ae67267a528aa6e2c83740cf6d13104a28f3af624c60e973547e10508d3923f3ee403f2913500bf1c7f70fc14c27269443388687d3a1fea0abcb8934bad5dd66bb7d982bdff46d8799e0a4087178889e6641463dd5e42e4cdaf3644ad3a0df67bcf78ebc2a244d5efee91f6aca217eb0b6ca1d70cc300fe2c1bdf794e9b6868bcb808b0c61aefbdbfa28aed1e634248dcc40c6beb0cf2d70e74ba366749c1c82a2367a3ab91517c1cab5bd0038fc3021a3dd2d874905b7a66b29e6694f704a143b07d677ad3a0ca0bb8fba4a7b4a865170681654134e14f12ddd6ba41865364e7949bf4adaadee0c7cfbefae75e3619e54acee97de4f2686e9ac99104c941a4cea5d38f4e2001e0d52a4de5552e140ec2fe743d2ae8a9c4bb70b9ba2e210ed1d71773a10c6aa0b87b78c395ce2a1fa41747ef81c970c89990a6b3de601c077bb7b362201f23b0c6f758e4d8157aced0c7ac13feeeac32b49cd19223fe9f539f683f06c30b92989fbb5a71749deedaeac18cbff5c2b14bfb8e5405faa40389ff98c63ac1a33043ad352d283c972b4c85556f68e96734b06d293248a742bfa60babe02e865a2dba323848ca2b983f0baa6093e4eb62aac8e635318df6e85f31bbea76fe2a0018be6fd3eac2ea0403ab1b06b7555171eaf207021ca9b131f74868516ed81487cd81c2f0560b6ba1a4a4c794963c9dd61222097c849abb1615d464b72452f66cdb03c2a637c4d6757d0ba79e9f2705dcdab7c07e211381f37765865a987b4a6e336a097baa1c0ea35be6e7b0f1d25f32542df31700d7a25cab347e18a23f8605e1dda1da1e04156fd393b91b7c4375cbb942a4d97a92ec62a94a7834132d0d0b67b536a30656e7a5c83e28d88eb72e235931d022f3f7d335c4dc45a3365890e6dcfc473b90d0a2f6e357345a473280a787d7fa6e46fee005bc2aeac9a0581cddcaa7a1307706e52e6a8f7f932c2d92c12075017a8e1a7d061ee733de14681e6644121b15ff7d17ef8d454fb2b2c310470491f31e51bf70a54181809aec4dcc1b9a2fb4ecfa0b17af29bf6d75a5705a18c8f871edadb87a47fcf2ba9d254b37ef80dfc39d07ad552fdb45d3caec70382c6be8a7ea74f5d98fd2e5041056141991829772276724a9f02822e72975e1a469db5558948b726ff008266a45c71c79c38a768f1194da284980986d4608cf859ee1a7f4b5878ceee35085acc328a1ed43ecdb269fb30537f7815b50ef793158fbb151ff9ccd901d730137254e7d283b0a6816aad350388c3a2aa33b8f3afdaac8f1002ba01c526e2d2441d19816ca9407b81cb7393640f13c7ac07175ad3e237b2fa60af3c8938fc3592e5bfd0469709bc1e092858be6c3d5c6db28d7c9f69d8cc4b3f9ff5a2d689bb0dcf52989fce885c9190c32ba8fef04b271dbbd36efe58e286315e1b7641d850fcc022a5c5e37e53cd0e8955387625ce8711e4fd4ef92afe6a24581e97d2b9957aa3fd591ed5786c227dae31e1b0d65e2b8b6c3de8447b4cfa0130be6e91620077d8778fe3c1f23680037b23028f6f527ab07df97248dbdc0b8407453e5b576dd67db655fc85b0bbda2e482dd43ad0ac6df8b7a50d8ee61d8e648f24e75b9d6d37b562292925d90df6ed68314e617992cb2aca72a7f848636b1314c8309f3895a23bd21289133edff9863243a61a5ca77930a21415e30aec6f8573e0dd93eda6e4208d1f36031bde8c448d446a77fbbac99164cd19fa828b4364be831c8277832a9b40e9a21a34541498126f51a57992f9e029a71fa865fac8f26eafd4297441453e01091af07f4ffe90c03768faa566878791532d6681ea61940427e0157c2b84290ce1ee691fede15c4650b0a5c93db827e69bd20e3529549ab9d6bb09fb3ec258e9cce56f609a786ba2d46a410b982cd8a88888683897f1a6708151df7be42bcae85e6f25f9a5e982b878a9b02e09f66c508578df7bcdcab4ead8408e4ab11bb87b8a9532a4e7b7a94daebbc56be1fdc3380a4d4943e58e8137a6a4e6f4e52abd1ca78cb8661d23c6f582fd0bedc00e36075051357314926fe9d26e99c32a0a29639556219253b6e403cb2dc73c4309a57e8c04a19606ac62b9425c326dd5e42713ea13bc6c81ce698e13db7f6f0b0156a41908ec05927fa141f31aa9a95ad913e6067f06f911feb7aa70ecdbb30b073ee68bf5afabd6daf32423bcb4dbddb54b3a0e48197a32642a0203bd6f50b904c8fe9f57c82689f13c2911c4e4feafa32d065871c67920a5a518b80cdf686be58278dd7d3cc48bc35f90cb2dfe910b43a2cdfb6ae269d4db7b3f25cc760838bda5da274bb5cd5537cf67da6f54acdd620923c6095ad11199dabea831379e8a4486425efe625a4760b6601ef62625df30e9ea379b50a52903afddfba1662f029df0c292fc748471ef3995e51f40e292ae869bf0925d6092d7b9f6921e383e4348ac92c3b842fcaa79b4d22049eb83c8415bfa84ab7d3902d74b1f39b1435f891d6cd5d76e2297b3e2a525bb2c22d66fdea8d41df7f808bb18de35a786fe9de9e8d0fdbdf4be4d134fd20e7ea6d4e9bf6980926fde812562eb073805f979d3771c480c7fa4c5ff06d96d64e676381c8ca70f122a55dc53a169840b599eb2e0c0bc7fa2c51616863640eece7656323dc5bee84e42e9c738b497c38d9c0d8c2f0a22e858ab2cbe926e79074997dfa60f3e882d90647371b4e6086ca4ae65303a9d76e3585ca49ea7bafabfe57f80ebbe874112b1004f65dbba2bc632c804e2a4988448d998adde3677e71ed96fdfb6b583d5f5ef5c19c82a7e3ad0780f1f6a5f6c6a962c63c1f7f6544de591c75c6f7687456c013431175d783a5d09df940c96c8c8f0f7e658cefd0c9d770493a85245250a7290cdc7ade782de5b693457b9327f56d395c8e047f406668e564da893b2604e625faeaef1d94950a5e3268177ec1d08462dfd9680cdee1b99e2d62d2d1318a8ad7079dda549e1a98130a358c6bf02913eeff27eeede66eb5f32f4d7d17c45f168cf69c62314b47e34514c98565582143f8a6cece527ba8a99945d0ec70ab668c890685bbf9780e1843aebcbeba796e975671316803bfc055cc991500dc1797de242cdfed70dd4af367cabe1454f34e547d08cdf298c405f062b6486a3b3fd1d3f2637957c471243b7db7f10070568f547b0db1ad0c928e31f5034db566d24681a1ca106e94670dfbc93f5fffa1ba8f6d2ec036e8c827702b285522ba5fa04e971485bd0db86c5e7b9ddc4de2bb2939b1a692821e7d1d5cb63d043887ad66452f793272499fa495bfc117b1b14694122b661556b81dfae79b7f9ffaa93b6696963ead956247e1393be8d7da343cbedef6a3def79e099995526246a5ff5f02a2f5cdc7c9dadbdf4581190de631843d3ac1e5367aa7a85b1740216a7accc5f64daf53d015fd783ceb51d7d99b12103d6c50a827d32a8f9f0346fb7666d29efcc8b43f7b8583575d2b2912a7e0cee73a7f1e8803c3584e05471362aca6e4b85d36cadc08b3a6b727a9329fc46ad3d471da4455903269d4832892a98bd066c47450c5afe58bec49de180d12ac0daf6fa8a628c71d39079a0c6be99df34b541f22b403ad1b0da0b03f32fdb0bf14120b7fd2d291641d3f85fee7975b2a5f41a53049e6253458657b08f87d01c6f7f185a76d46dfd799e18f96069401d8930026460345019bf04a482b3d6359fc9367d0e51a751c18471bd45d5f3357d46b85a238bce01a4ccc8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
