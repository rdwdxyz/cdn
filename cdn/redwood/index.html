<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8760c13bb4d6ceb1dbd2e750b30946c3eb9c9f84f8315abfef3d61183fc6d9f06dd6691a1ca0930ad0565d946060b58cefa0c467c28161eeb00ebc8da553c50ec7c1d88d9123152b2f8b886290864e23e92b5b56d307779d776b1e74d5c56bb83053329d77fa7bdfff1e6265846e0d6508c3ab1e3a42d2e52ff340c2d59c52d2a873a922c2dba6fb867d0541d5dbb1527e4b15dcc3feae46548fb65006a3895ecb2ec1105fb61ff48a00c061dcab85d8ba40a0d9339b8f53b7d45dec19831f7b842a18b318964b7459f47f216d24a0e8cc0be703dca020e609c060edf97440ddf9ba6bca70baaff75ef1b4986cb2d459f5c15c5d2d6c3099b76ff19eacc7a1c27a1d61da3ddc2e5b9fa8b25506e04e93626666d2ce60c162e1890bbe395e726559d67c547cc0d0fdd854c87ac5c053c4d24c136561191430d0d8434e6635e6aa1cfe5ad5e269ccf7e1889ffc79f07ddefd620c115fb43da9916aaaccce2cd006a7d223747cb13743af3c52345d2dd009ae50eaea8303c52c9100dcef6d237fdda23bbf639ffc08f8c94a7ded1f1f2ebc4795f62ed08c3083ce242f019955f54105e0a13afcebb1dc27b6ce427f413c02a3a10e07c6f27206c162459d62c1012f617d0a53bc4f9959c2c7bf8585701ade86437747796837d3ff26888ff9d6ddb36935cf12dd2b8feaead7ee9667fb0242472aed0848c279ead7cec4583e2a58f44c98f7ac9332ba0c78f87491d4470a0ce918bbdab8fa8f10b62230fbab960e8fb483d6c078c7339e4f20ad7238fa62f240e7e9f420f73691d5c39fe8753ee0f2623c05f9e78f27a8c1679308e3348029af30a66e03daf4e2fecdc03eea60e79ae3f6df63874d4bbf7176dc0efafbfe7fbccc3edea3869f7d1221ef3454c5541b4246df10ab5f3a9bb65e34974d07d4d1f86292ea880ff1fdf81c89355821327b66f9f95a56b2c53e536d747057d83c3e0688530c08b2436f26822dd807ffd64add0e962e8e78976d4288051943abf90c8385ce7258e4bb381ac46009cb0eb42b9d5750e2f3cd51c23af3d93dfa9943c4dcca775ea29e55a9056954c345c780fcf38e8bd063a4e1e5fa4c96512d5efe1e939180decac8a320c6bd047de5d4ea1edd22d70c78fcd4821058dd0d330d74462f54ae871a1d0b7cb84949fbcf098c96ee7de6b0473ffefb8796d85344c53e2249da730f58389f8d4e2f41e6c2bcdec8681199b96896343973222379198a8932b8ba1cae66bcbedc5e5fee97fc758c6af9188ab67c4ff52f416a83945e91b151437694342f0f9c5b3d4db4e78c83b08391754256816c51ecfa321815557e27ea6eb78d4f3f5c10a3b2b279e923744e8ffccf5eae3c25b82f9835bcf51a417a77a473249252a8fa70d1d59e0006d42f7b408b8d848c9dfb038a6539f0058cfc0a506ed1b87f6f7d1e43202aa2f2929803dde93b60eff1c0f56c4d9fe258e2675a64cd8713a2e0b121f66733f683043106302ded90024b587d77a556e04596b7db0d1021ae0d5f806fafcece7e3c986c89387c0107f5a64481005487b9b2bfac7ef67ba102ad1a67ca86e1ea67288a5560fb9102909d4ba04cce865db2de8e09af2bdc28825a29b39db9987c09bc66d9ee7e3d53176152c5a5a7324a391124572db28c88030d2283b0eb153f2936b17f83238f884ca4ddadb3714500a78e153bbad0a19109aa7bd93c05d969e380ff96bb6662bde967fd81d27cb2f85d4f40bd38c94f10a7f7b60a928513e1d0f42947e330cd7a852ba8f88b3edf0c056ae79fb4659b3fef910c485502e7a8f05e8287eee24de2f4e099e6f531601efcf880d7410048277a1a530a105c617e7893661f6234365783ab43cf503eebb28afc87bae51517a5d378ea51575a0ecbba243b621270c282e75e67303d8f3f4d6b646beed956d4e24e650d380cad2ca60240caf324f22d41a4e89b4ea13ed34623b9281b96aff234a9c8c3fcfecc9e144ed9c493b86f88bf600d7ea243a3830293575f8240100b530626cca26178774829168aa0df10fc3d124c0e3af6c955383d603d54fd671fffb4c93d67fb7085529efe188f281b5a74c0f715c4b6285356ac9146e422f015709549d89a351397389f38000167ca2b2dc831bba4139cf9ae713523be1f2b672d17866c8daa4d76a5e02f40d8c2445f63c76ffbb9a2f3a46fd8b74c7b76ddf1ac5186fb534f64c3fd3b9858bfdfe9b05a89dd9f37a33fd2899f15d08b3599ffae06ddaf7e0fb8d5b1663cb87177460411fc29015feb254f66f96ef0e27b53e595f3b31b9db16d7864f6f25f9533ef0d61b2d1ef24b4060cff9e8f3b633e298db26408167f184b87018b602374bb9d0b140519b3f67cfaa849145d5e548ba9d635bcb92fd0f69c08d327b3eb2ecc47e91ec879a4fd112684b3d9b48cae40e3f3c85818601d23243c7fa3e2cfcab7193d4ba13e67afdc64ea1ee1cc7c594ef1b685ef22156493cdab40f776731b4db5506e541eeebbc8065e8498c2b7ea9c04dd37a285feb13e7ef9bcb60169bf4a7a501b27d01ebd1e02d363877936cc5fddbb468562dc7e2f2a8f42e97456c5857df5ea0667d9805d5f621aa67cc494102b21e2095f2e7634ba7bc5de4257fe459db2fcbcfa0073ee6cb4e61d979846dcb9f12632ecd45e2383600b639eb7bcc3272bbd9134e5321b64b922035ebcb390dde7686ca36ce29a48058d35a044d3324cdacc272747c07e39dcb9bafa3eba0c25073bab33c1fa3fea40cfdbaa5882e6b833458f61afff070d31b54b5d48e130628822281b5e30db046607d5a885b5ae9e1dbb35f6eb063fdb298942338ac515ad4a8e2fd37203294af1442a4a9af99e1268fff3634373ab8a0a02ff7087eb467d087036b0f57a94b45e2450f03011e9599d4c5d924f01b9b1c4e0aaf720a5973a602ab74ee244550181dd1589cd8543b612d86ccefb7494308fcf0d155c3b2fa3bbd86d034da5c8ae0c2f6bcce5c55bf9cef2fd65a3b3c984185a55da573d846051b761f4717dd72ec9deaef57a5b69505df50034027d4f0b3c707e3d6b62c94d566d2f8231af22c55c0d372104be664e8a7ad035a40d25e9df0a7ab1389685198de4e73edac68b8ab92bd8d0c65277c6dc713d1c4ecf5673b08d16df75fe0655ba03ed696cfb23654833c348b14cea5cc42938c81104dfd94ced8984df36e26def44624576819d3ef044f34bc9d63c0bf61a3dd6b2bd9265cdbb0594be10e538bf8582299f79089081ccd14fb9e900b3d698afe6354799720e95afac34e05fda524fe776c905f5dd1a45cb3703fb753e9eb90c5c8594581a3555678523f2e0545f534d11cb9525aed89c6aa904c454207d314bb0ebe5a9bd8ec41be242b787e1f5b94cdb8d2e0dab1c384afe58a96c5a52ec71d90d9423634a7bdb382e4f838fdd1e22476daf91910b42e624ac8d6ca3f1c1e74e18c8ecae670ab74fefcb8fa396f44e8ed7c535dfb4220483b918e90657eb3c28fbd546e1fbb7528819f4bb51da19a659df42c901bc2ce5daf190318b216f897278e261b6872cb6f400fc99715cbe51d9e91cb105afdfcabe6de131af85294c9dac66cdc16a84d2614409ee5bccb36aab6d1aa492e9304c3fe5f199cb99d88b4177367901088248306fdc399c9be0904fbf3c7bad2df29b302be70c5bedca9f02a2673bf0295e78d4c2e17df559aaa8e5854c5e9dbd680082fb9b8ad9351f24d7e9971ef2bf57fccb39d7cb45ce1ed38aeb7579156492e8883d4ba80ec70a15affb4779db4aec4f97bc3dda15df003a19bbe8c134336070c23704845f055d687d086c468f83ec9a82db96cd79130b6f2d2484bdc8bc86e8d0b6c8ce30dde8c50bf9b5fb89d3fd6b115486a846e2fcf7e6644d59c3ccbfd17a5176ac7e1dc126715c9383037c043110c54b9a0c1e4ae8899b7903d3ac3225892cc7ffdeae40220f6a960822dcbdf5342ba78d2807732929b002b3b7e76e2d5e20ca814062c8cb625fcacdad1af6fc612ed475bcb9ebd8daf9dcedfc9a17d2284273dfcba33eea7c773e53bf0258f074fb4f438f23ed8abb73a19055d309daf964ade1f869b484847f96705f225f97283bd2ea70c99d616705188f5dbd44fb55bd889e8f5ebede5bed02bd7f8b131a7988f6f6973ce3c2f0a7ae41c3d7f8839d625c695cd1fdf6c4ce01d33d3f61c9f32ffda8c21c71d7ef530d05e830bd026611fd6b43f8572c2f89ae1831f531768f27630c823588fd5395f78cfe4d3e0be3d7a134e3eae9e770341e108e1c3a08125045770b0906950d6635c5f04ca54fc3d5974e8b06084190ba0343483d00f04c8f6c1cb80e2913cbb4469bffec708345d676ae08a34f5a9e935bda764d19d6cf3908a9e7f64e336e4e791c768082211744bf70dde041092dbca16b50f3dd62c15faa30016d687115af86ef0fae3a8da6a0344a1f500840c4a21c0c4ec128ac21fe0c1905083348714a52e4a2fed0095aae8d716abc2d972a2409f1ab3ad86cfe11d267d60c6cf459e772f4b67eb442549c2a792407896a4be667788b33f58d07b4f22e1a105eda52f421606cd3d81e4267dfe264d35780b4b69773e4e6020211e8bb22a2eb9049369c0145d28c12c9a90a0213f54a707a62292ab4a732e5b3479ff3f6c0eaad0577fcf3fa578ff4e2201235f9a6c5aa3626bf2ebc35f73c4b7d1255487d173f20fe1208d26646e553079698d58681719f7e32022c8c8a7684dcec781e0900e9f78279cc9d328a7b3e0896ae6ed5da2eaebe12e84bb8be0a2fd3c4014a3efcc74c61108589f230f394ed2ea322dbc48e94df29cc5964b239ccd6ab3d07030cdfebb3cefbc35b07e9c377c64a07f72fa77e19fa45e656e6c86555c6bb7c1d843dd755814a857d70c1157e9e22547adc8442e4419d878d9ae4468745833fc8905ef3325e15970cf528f2b445960a61487df27840509af306382f6ce8d107008c4c0c87c9e7d6ea97fdfce9b25fabd9c4dda64068240a7e1a4bd69a64dd70df005fba766537f3e557505c30883b60b8d56f1e64cabee7bf049ee45f18282cf6a421b3e917b6ca9215ff565825f5d2fad5589b939ae4504d222ea7b14ced08e1c8a969becf90bcab759051d2ab5676b0404cfa2aa2303ffbe174078fe1804f6ad99a0ae4bef682609224ad692d86f626eb1105f499103a7da21b833bedd9dc32bd5074fdaf5ec35e04b7ea04d35477ebab9322ffaef6501aac5eeb7d6b7d08e82206b299060121947fa0578c1ac07e87259c0cf423de1540192e32e67909557e2a7d6d5f2a0aba5b1ab17ac22eb4858069fb2c6c1d17e723d4748d9a7b1642be805af4ba36465754e2d03968d54c94b5843fa45b7ed5dc996497dbe4b200d8b141e16e02b37d3746b3c172b765bd85f5e3e1fdad80c22569df67550175d3c7a20b3651b8d39a1c2d9b67d90191661488e5ce252f9435f58eeb9ab4eeb76bf4125925e8567e7a52851ab682ea1b37c8ca669d7ede0b3c95f842119395c48ce3dc5c78eb7fa4766de9506c447f5675227bb89f8af499eb8f8f563a548fdc248a7a30f2ffbc249aa67c0126790cc4aef5b0862f053d2f46466106ec3be10043b2d1705dcb2aca5381d5e481ccd0245a47a4a4428356fc7bfcd91abf9359a5131f8ccac892d47177c184d85f59f166814347182fdf6a0c902f47f4172b25d02fa950173660201c40804d0bdc222d33d00fd124f60935c699b1624f5a18d4a1f122b78d9f303f4cbf35c9dc68dcb5dd186925ceb719196b4a1287a84e04ef355bbe102b98b09490055dd64f15413ef53198a8765084e0bce9fe51d77dfe426d2d750c0eb007d533f668a547cd65f0e40ff013706216ccd29a8efe9ac62c5fc3c0d86d0c7568f9e80102688d6fc4cd0564a1a2b2cd083f5169fb20ad04293df53c180bc8b17cdf93f0aa02f536125518a75249a72e860adff3f18e4e3b272be1286781d6986bf7f668525555cf25ec0b9260c50b4a09e13173076692d0bf187db72e9611c0b8edd66da859d4d2e761abd75107a4355e453c48c5fbf7f301a944e3d07a755595f7ba1126c4d608e309588bc7b607707a8743369994d3023f4610f7d5161d12c7f79299086e873c8b226cbda594fcc082951959e801dbba96f1e5fdb2f4fa524701c9b5aef9cd9df712972a1881ad5e0b2104eef25e362faa08e43447d1a62148714f72451a57946ff8baceb866833f2f3ed54b13b86a8025fc2842d7738c460e27a96bfe8875d8bcd7833f61cfa91fd7f9891266387dc5b14eb9d284626daa477b64ade0e15b23ff3af2665735bea1cc5c6522912771d0d0b4cf8c19f48dca94edf1dea0b73d470e526b099ee9fdfb497384d75603974a4b1fa8b962fcf3f45d426dd344d3ab39960831c8d2ef8ff63f2e0b31f524a2707dae5ea3878e21479cf2b65ce1c95d378cced035fcd879481d8d1ec3b332a246c5517dc13ff91f1623d85d5e991921cc146e15c96a9ebb3f2df76096602365477875d37d8df4d999b24f9f718fff385b5594a6e3b82c9819f79930a138f317b83a313fadbefb730af997a9ca37ad6284ff8e4e210843c4ae0a5aefcebaed1d172f7c2de3d38709a2577bf27ff9161029db724603598905736a658f52e5d0dfe6069011170d278cb9d4a40e6279765707be3d0475ba137d00f5183001a90cf1b625dbc6874dafebd453207d75f534b07fa7feed5f9b1dd464cf9a4ad2821cbf3131583500a9877d96c6a0163bb36bf6aba5f3f6fcfaf6acc6e0a5cc64b417efa8ab078366886ff54756ade5fe6ebf6688580432bc79bbaabd5878ba0e5b42b676a14215de57f5bfb804141f7f47c4db67821be6bc794c56e68b9fe834467bb28cedbec83451f028b3af32ff3a4e44d91bfe36a7966932462f585a4a7f2237d8b2a2e87d6e07d1003baebebf3a89e247a63efc6816d836372f298566f0218b18a919b2a31f5d1248ef24487a1e0d66a3f954c0fa578ae49a0d0c4a511312a49a4b3eb30199ef09bafa826b83c279cfefb5847290c22ff8c8912196d3f03bd4f4973e657c6082428fddf1f7d3ca5ac1e8266c8768068425ccf94e1c6dbd8e7a86a83410a8589ec917f11f981bd14cebeea886c04acdbf3b36905c9047a82f48d7397af2d7b61a978493aed6a02cfdb73de98374238c1246b9a15e61c54309b7ea01ca012b0eb65a235d0ac314c4eff381f9d8f316aa52956e570749103a905f1dd72bd22fe86efd0be9f11117f3c2446eeaf81646350d1519db2ed4b6c39c8962a409e9e94f7a91ddbacf57176f530c8899b718156cf6c6da6dd50db8d1a7d1816c321d21e9b55d10759f4e94a8352b4c666f8a9bb30e7747ea9b570285c7098fe4b0ad7ca1518d3d86d3fc4c09bb21223e34eb63fb706be7dce6241842ef5e9f370ba6cb843a67fc7c42f53eafa2e406014d45a922f6354a3f31b629b2eaecc0a7fc1de8b43359b2ea0e8d865ba2e88673237dccf2a459504e6d0c825e5838d147a2239bdf68b33616d95b8adb60be06365d20af4b51f67a365b0dfb452e4bdea4fcb3ee1b5284c92829c8b0957aeac8c1de4824287da0fc86f6a3bfb87480b692904d42e58924c571c0ac7ac1da3a40b57d1f86404ffd7c7985b03a0694ed4141517087dd4660f6beb065e9f2ac12ed3e74b4ee6e1c3128bb371ed40a7d1cb6b05e08a04bd521529d381116566532d14148997d0273984dbae2f44e5f3514ba2cfe102b72b1026cdd321099b7503b824a7188b5b0a31cc9078e68107f47dde405dcbf06640268064271a1b95795226488161c509596f24089042f08b5152eadf16250bb403f097263cacc824a9c21d8303d1a6c39c343cb81c50947cd89d9f4c0f27a4e6c377e9b17439f96269357458bda74379d0aa4c978ca6f2c3ef4f2bc868bcd0787415082751bf9f0c7316d4d88c7bb483f9eb1e2b26f36c9c02beab33f46d51b88a5655ae9d3f67773f6403139f6259f682cf34bb72cbd8e3baf5a07feba48fe54a746da90586e91fce27a2fb102668c482244a355ac18922d63b6cb71490ea3ca19f2c55024981dcfc33433e16c4dc11d06d89ec5cc6168ffe65123787e51f39635c45359ca099fcf57d20c306c434b8e5104c33fdebc463a5023377867ede12201374a85022254f298e8d28af70678c8522b6ae9599b3b109d1768cd04b44fc6dab32978d4bb1a5a669486493ecbb74d26a874815a9c8752731e951509365c8080aa06d2dd4dd8176efa71b276047bc91fb3229652c73cc84d760bd7c12e13ae1f8d1a9afc33f7a725293945464786c1511b87aaa55e3740f571aa5d9408325967e6bc05adf9ec86b721fb3cd721c5f0466e543b456c8f91a7b54a3007d8b4b7e48573b843ac114532c26d6ee27e23f0f840d38a75edd8380ab315d841d21258fde2668dd17bb1f3b8762a7cba47ff7d8fb1a62bb7e42525fb017ffad89a61a78181da5f387151bd884d76f50b65ce30125f21e01c44ec98bf664d3005cfe6083559accce35ec608f904c57cf24b3ff5b5b3c6446b212b0ae1c27435b286b07f5dd538f483e924cfba88dc22c965a112a3fff255403c41718c5ec91477d621f8659e56fa79d956eef13260a64cd7dc60941d026d5296014a5fe7f956cc4e671fc0cd959a5be616c0c99b97894565fe8b7b4e64a35384ac2b6d7464453557deab15cfd55a475cc6805f94ccbc8cbe5d43422c7beb104ee31c60080157dc9754faa25fb092e61cc982476c6959d659f2733c63d0a3fea59ad16c4464be92cdb9bd347464c52d16405e5a2705cf090e185a5bde6b0ea8863cab14068872c6c3b881b806ced10a6b970e40409043100b5934cced3c3b21b20358d44be39bc52440e712829b061edac5ed6d7ef8d6697ba7dc64eb9327f02874501f7966a62eb980f5dfcf4d732f225a20e5c1904ae6d3dedda9af623a457ea9950a69c16c5ca8f2782c1242f80d43060f9478c7b82ffc301f2060c9f4249263281c44d36d4a7e03ab2dce5c086bad19bd4ee8a58506841f6502a3d8ebad52a44dfc87ff7f77a2513e5d3857bca1e4ebe883aa9551b77ed8f4d404d0e77d4c6ea4745741afc930f389eb8235606aa5009173aa80264b1934fa277b185ddc8421e5f86a42e3e2a4e241e3ccf9460d03f754810540b9f451c9a7b63ce7e3cb978c886ff440e57dc84176c72c345b92b7ba2c7f2d105dbbe303ccec53fede4db791f52305a5a3b56ca9038783d94c7bf7b7206a0871b7cadb64f13b313e593aba3015aa9ee7aceca3c246ceb890a1aac7d851d51e9bcd1971b3abc88350a118afa9d197c347454034927a79654b0e2715eb9dd58f3e5a8f980432817e0b44c3511f022eccc5bcc078723ce4e8c22ce5b2b069b6ec888452b2cbe480b86483550ab600f9dc459aef2f9d236486dc3be9a602431f8c34fa247b3a65a195e912f8fb7a3ada83c5c9a2f5c7c290fa3fdcbd0e96a2d3f020d7f502f00f6fbb41cae2f2927be4cf299b39e8da0d394e4f39b435ad930251840ea994831626ed2dffbd975e545593484050ed612ae378467dcb13d69674653fdab2ca6814c5dea5a182d77622e913749f18840b30c332b444368071b16dabcb3824d2996381b1d69127ef5d95ff55e09d19ed1e234bdfa87ac48e4c89ce3a8d8cf6c6b794cd25533bed1077efe4ec8de9102b8a68a2755cda88124170932e3fe40f20c1ef54cf801ff3567fc7f452162e28924bb560edc8b3173c6e16473f510342275897ee8cca1d975031cdc9609c48fb3f62ef0799f984e5622f617ee9e467f3f44eadbaf584635a2bdea2faa67121e644b267e1e299c64a660a0a29a853409a981d1e46ec22703d29e173e22e04798a5a83462c2b384da9db506e4061ae117c31a5a1619d46cc27805ce46af6a7d7917b9293edcb3b95b3fd352c440c64839226d1520c3fdd5ba83eac0ed30a6373ca457aecbee7c6ba2cc2b2277d21100b469cadf0be6e06c8cb4d50127bce3afb56725fced692a97f82d0d37274cbfdec68cf1865faa1edfa5a9b9b961bc9711dacebdb22f0f3384c538ee79e052ef42e5345b56b3cb31204498e46d4cc8c809f3b7af6620bf149ad9797e6890e2d4f05442fb124d9ec6a33096b8b01b08013d7ed49194ad37174bb0c16d457d18d0d38622582fdcddf3c8cd808f38aba08f982eb631caa9c837b49a16d4297fe712a86f893e9faf153448b553fef1f41c352b41dcf88b5f69f17545601aa9c7f9375ba5073cbc92ac311dfdc714ed70213002cb34476f5f05432336e2264f31de0d33ea6b56ccdcac294fbd7c6bfd988fff28c08e1d4db570c6bf783ae4d68cfaf0ccb16fbd5a13abffde5108ae01a5ac95554cb3b4d4035c7245865a3d6177bbc142d147a9668dc4ab76017f8707dec998b29a990321a37bf63f6db6a06ba3487c4ebb5dcc785e19ee8877fce503bb2e515b05977aaccae9dcf9d9c63e3f422e264d72f4beee40b977c2a22e53ae7c749b49d921ef17c70f76e1e71b513553aa855360c0e40dd0bd2f31a7906ebce69a5a9f0907255ef8efc0de691e9672536cae937cc392a46e0922c56685f09f27551e1481c2f4067fde1adb2d83a7ecbb558bf1d6fe4bac8d22c43a67449445647d62b5bd84f00925adcf650a8230c727ddd84d1dd644cb1b324bad6166023b092888b9320d29c8e2be0ea2ca19e7111d0e4af210141e3c98a0513fb5e1bbbbb3d71e743d452eadfb05df8bf158f0f3912c1ee4368cb5e49d02dd52d02403ae43c491b518d1f42a61f96ea4dd706ec9c9b2bb90e67b6606720faf314d0b095321f6f8305691ec992a44e1c3ed2aecb1fc17d8a65f23d1fbe69adef1034d5fc4662988e21e7848cca85171616a9387aa423bdba41f7c65fe5e6b111b0d0227244d271dd2e4bffbe67ad0c91b2e13803104e22a62e66a961165e7c5f7aa6c6ff9e43ae35990dc37e50f5910b1b439364dc8436d21bcc8d8665bc57d9f86f8b99ec9804bf52f5bfbd86da513d14651a6961b310e3689e5468223d1e1d7f934b90eb82f541cea593f7f79b5576c1516152c65c1f25effc3310896304096cdf3e2f6ed27aef4c1bf150c54b2efb642ad63cefd8023b5cf7431a61b492d6529f077798981d34826596ecf2fec9aed73dea2bf0faa0f97fd4b1fa5e632fadd6edf5f224b75a75290a7d5f43edbcbcb5470313904935dc654d13c480a30d194bb12c234872f9e837f7632ebbf47fa1276eea00d9b2451e671340cf639cb5a7d5f4ce0c64917426b523d5a552bf371e081553cdbeebc60abc51ef10ad077977301bbb8aa22ac28c9895a17f4bc576faad245535d2b192596690342971fd4998f37df1b162ccd3a428ca9972434abfc5e0ab723f775813230dd8af5ec7e13bb460f57d47b73b2167e9f4f3db3685294fe6b1896243e4c6c1962cd9c36ccd8a7f12b17c9b09c3954e851252ed5f54fe83b328dc3b3fd01b9e7298714a75d762dd8f783ed6e556ae737bdf6517d141b0d361204f0619740844163fae5857c1ff1cdbbaa63f3b421489dce21c1286d49430f720e77050b87f92ecb7eee06984966ddcc2090c1a740dad4861fe35458d6894a139ca6a0b33d8614326c662a88cf4b119c46d1ae434a9360fb1f77eea3c21cf7db3dc1533bbfbecc5d833b1393da981d66d48689d485066e610e83db7eddf3443b3525836adab694000facd3df531f31206a2485e48c70157fac8c73e1a6186bdc599d5b37ddfa356d02aa0fc23d7746278149f30ce7d88e445080bba1e1635ceb3e9e6ff38c27ee959051a6899cc6ad62413506c4543c0d4d79704aef5e9f0bd86c3eb51ad5ae5f6ccde811dee9d71fda6e8b0eb702c0251f25f5df86b658006abf10a87ed1c863067293161ec618dbbcfe13115aed56fe71ce938b150f126eb5d70d7c31d240d1604ca0e8555ab1265b858e787f3cfa63512c6e347cd12304e867c25b1f5e0e2df9722870ffe0a94a7b0ca21e83cf43eba276b839a6ef30e6b099395377fec42e6d865f585d48b44097dbc813e07d866a58b4a96a804f56582865f5b6d1f2b424bb3d498cbf5ccce35198a1e37ccea40ebdc5ca669a1724e3a9713334b7f8e82600a82cfc912bfeb1e030968bb38668aeb5ee9f16a7b1a76cdaae1c5e45ef97cba8bd1d94758d1d7e3c20eba7f43772c9de942e801a326c19c1be23eea32d277ecfc27c3fbbffbb98cfc119efe0904e91adc17148028f42215a7155bccd8897c5b02687334b402f0ac3f5f651149a64fbc4298a1f025ea6f2821d7df0d8059a74fd428eb80e91dc0813ee4f4ced4560081ac0f7589a460927d60f45528e86f087dda188b920f9ea87a6ffb723588dcef793d363d3ad441a30717d0f187775bb41e31421ab6584646620650449c62cc2c3ef9ae31c2578fcb8fdaeef4b691aaa656cf18b5e2b604eb4df84ebd30460c62093a6f87b2f2d834986de96f26dbf0c5e4744e38b5d5ae149a6c3404bafd0dc1c1d91f80407be42116b99d54169f8a2108c43cff66cd62481c601784f11bb62a6f22011051e34c7c5623e98196b2d6e399f78e190792f402887834946613e580b6bc4c8a1e237459ae1ba6ccf655986f254c1c5e531fe073dd3587c769513f6bd5726f2818634178121240f6aa25c012a30aac429910d424481daff302a9648c77c1aa307ed9dea55fa52485944fcece6b6812528b98389d1c9bb81feb3c2461640c9654d8e94363cbbd317f03c8d3c0a4a5bdecaae8099d45292f27c82b4bf4b48cc74eec9931d300d5bb46765e60bd43ca3f20a2c8be9c728b8b1ea4a325b0324d38251983935a256b830cda60166369997d56fc4fef6b956700e24ad0bf1fa755f1a2c1ccffffc04e888d59718b860767b91b9b89511716694bb2ff63e32b9edb53785021c8c2853e5992b2c69d252eab554d3b41b782fbe918bda222c57a5057179336fd7e54ba15700f4a81fb6c6dd88eb90ba86607040a62d6c0d6f2e275b086279c30e0c1557c3132b1969bd2d68020468d696182c6b4d58935e85f9983bacd8d6fe9301bd27b53a499be33748f95bd49939d75f865ee77d512b482229c5e9ead1224a26889cfb877566ecf2ebe218e3a960ac4be720caed403713a7174da0dc6a92219cdbfea32486e72891b1386e5e3ac1d9079135d89cf8406207d67964b18e813c97e0ba607c0757cac048b64e01f4ac4af626414367715a22788326a7626b3a347996de4481283ab72cadac2a602ad44473c9b11b74acee659fa21a221a016080f5706d3b598b9f3a61c11565b81e438916d097628eabd87bbbc4c4528a8e253e6342942faab0e378aac72c5f200420b26eb4c9af4df8dd3f38813555a0519167f4f4873372174bcdb9c232d27abc587ebce3da99c438bac40d80e3ffe4907f9be97c7556811dc709765d08251c21dc880dc9d4f6914d5efae1dfb32d4389e974b2cd9fa4c881dbc556cb84fcfb941c796706a4fd0c07c265f114cf00c6cfe4a5bf6076f144722d1e434e7b03680e75df81aa232c4705c94a33c438ed8ef62fb8bcbef9a8c1770d36bf8d59a4bdccd7a161a7b7c3272fe5032277f20fd69b5deab113742c8fa19816e54ee5be115c5aa868eab37cc5444fc0f684cc2db4cf892701c8f5cabde5298389414a162c1e482b00c49ac41b29bed96e74ab6fa6c8c7ffa8e0620dd4068b827067708e412145bc3c06cf06b3c74e61253d3b891b7a916d4fd429c66b600584dd620e41d1edc04dc7e81fab7a30bbd87955081749852a143a2b654498fa8a589b7788d4a7d867201075a8a2d817a77c0f7a9a855a44922b96ad996a5e70aaa5f6dce3c5cf906c0fe2480ecc16da949b0eb1488833a40c89840c7821b0977b8b83e83224b1c67b31273ce0c026d07d3a4210eb8d5b8742c53542a96074057a762dbd6b98cb38d6a0360d2c92dd41f681ce02a993b26fde1dd5f20b62125e47d48f717c311e79f1b1c7b1c7a999a278ee755c6e89423ae0497aebecc4b3646cce72f7b90ddc524faf2885bfd500fb731f4f9ebdc23089f9e794341edb05f640f67c613516aa3feea3817b28fbac3f3482cb7c8cf995136c84e99d7e2d5640fa20ff9a7943a27287943a98df79f520e91c54d6d613b19e76a321f381c511932cde1bad12b1862be03b5b042ea41dfd87f5a66dc6ff142a78ecbec33feec59be6812cf9398307be8b904a4c1fd877042ccc8bab9f5893204ce07ae700b2012f558741108d11a37c1eb0536b03bc5b6afb234d48413ca0960cc2df47648e07596245294e8f44e6cbbf8c2bf298fae3ab13803c17a4fa7827cd47e8d05001d46c3d505c36c42492f1fa583e4b844f9c5fccb9ca9711306e6728b2885742f646a9c16e59a37edb1c919eef836694d32a3bcbb01d10591c3ca9a31ae747fc3fdab757f07d6929ea14fa188b952fb82e86274ce192bb9f3a050aa3dc0bdfa7fa4f70f1d699d5265f1f884b8a2a20d8627f6ca48db06b60b9dbd20481e4264073ccb70316f3ebb32e266c9a34ce0ba68ae159b7e0da87932b7f4e0f378573f1ba73a471694d50a46d044fef6f1f2ffc38e1922784b2af34509bba1973c1e6a94f6aaf8de2197d514d6ef756baa9e87f253c9e5258f3a7d8f828b536ed74048662a278aaf7a3ab7d8c3bbad5cfa40f2241b981eb9b6585eee2c70a1051bf6ca3293f0b72b30d0715b97694d345dc07a557afa0b3f3b16779463803fd4efe98ac7451a24aa67776b2baf8a80d981564078fb8b1c41ab8a58eb32f274a5a5282a7a361d82a4fb4572417ca6b42562098f7ec594caa207b21ca72837f23f08e7777c10cde411349f48072685e10dde4c7e7736b0b41bc9389a5ffb9652764bec800957fe3f8859130ba6a2b0668baefd982c8d2685197bc6e4eaad7e2078ad3849abafb3b63add2d3b71e72b15c74bd1b8ddce07f1355a0505abc56cbcca8943f4ddb6f9eba8d1bf5f1b5a9579a24f6d5be1b7357697ec8bc35bf15bbc1f19b0d2ea7520055b27625e96cae934797f096d34f904985a25f96afb55a6891f75167e48956350e5b1b16f8eb1f10f662743d075923551856fb31ab29cdbc3b30fd33d66fc86d4223573f6c124cebe1c7d79aaebd3411397729ce4522f0261f61188b56740638a8163c54ca5012073d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
