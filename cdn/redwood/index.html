<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a0d7f597eff5a1c50e2a88d59616fe5261012d8c8222ad68cb9960949c74528846b0020066c0577075adc1faf3906f9b91b872ee5712f5056f3e50b74a27133d16e1d4070444f20248d236937287e49eb7c432a358cd78d3e2ed0ac22ceb3bfc7bd32ae77353bb0361d769e80a738478b000b1f424e5acfab9900080e44ce604394a6550f52038146dceb03c2c3bb4490c0095b262d8d1379769a16f4bbb1d39d42cd31c2d63e97a44ecf1fef59cd26b7f68f5c2a772cbf66bb7f642bc934793eca0ed4a9acfce5567a4a21c78ad11549061dda8e5415706760abcb79a1132467fc5498d62be665e05a58b926d499488a545dae28eaa5f411be62a3b33ff540d4db16028f92cbe0a24689a9fffd4f62a1b7cc48e8d6603c58a27bc39b4ac488876bc76e5bfacc1e2cf24fcf2a32a04f731e4743cadca1f53979d72ff441b405baf33eb85c005ecab20deacf771cca0b2168734317eaef4682387477ce4b69088b2e505cefd377a80d3eb2b4639badebc06679dabac53f74735ab300267e1d3de139909410f03d6f1081c844a0fed94ad174e5e59e87276cd1cda42ab58cf37fe9a978d531c1af8b69cffdcf5cebefeea5ada85e8f7afea9721faeb68a3c05c19d42f2df72a282cc510d21a81660d83a1800a1c8c0770f366793d9267fcc3e50df42f74bd4ee3b517a5315c0e9c9b6eed8b960bc95de4a82623cdb9f92e58ecea959bc32c4587b9ac3d124c649925f86f52fc0a2c76cf6dba3222b9034534c166e03c6ca4ec5964ce7837476072e48a7b653d9aa574577d110c6786ff8a2b8a5b29c21c8579933a2ce036913a9106c42414d43909f4e331246becb542a6a1b9cda375be66b81fdbe04949d65a1824bd0605b0a924699749b3830d7af4ad2a64b84b011306edf0876be66ea9ee7590c91456cbbb9f672afcc35bd98f3d9408ada4b7a90ae96e245bffac1473845978ca9b5c17ded80c5aea0da9807d3552e67e3d0c98060dbf1bc21de544eecd12ac8ac75e308e60929a69cdc7f89e471480281d935ada1cf158fd7f07d22ce81034b0482a16fc44003d7cad83c9d32eb55c5c67d353491daaea9de9eb702964324d6092315e18b46cd4781e98237ad2004f3622428b56f343cc79b800737003d8a8bb5bbec8e212809e383addca2cec5057bb30212cb815134ddb004b89abdd0a4ec2c88d723eb35672ef98132576dcf4ed04e2a467ddb6066a7bd5084dcae9c39c822c6b2cad28b6328d08f119d0d29ecb133d017c5270bbea73fc247b43bf7d222147c00cb5faa096a0931d63a098460fd6f67b58ba1809046a242dee14c1b42d2a30cb3378a2e1484be1ab90eeb4ddebd31672753eb0b93f0dbc292f5285db358424fa97b59a33c6bd1f3d776c80e8ca725377a7099738f953a6ee7e5c2c724fa5b4d226ed91a31168cdfc283b34f11ad8152ce36c71c1a5f9188d4bc828bcfd1050b708dce32c1a4cba4f81dd366304962279e4172e3b84ff9bfad1b31759c5ea842d3d4420ab0a659f16ee4d660909593348bad4270779909155f0ffbec66b4e1bc8b092f9b76a9fca0aca05a8dba886a9d62c9f2a1e6e4df295ae48321b2343042508a4d04679788b2ea77fbf371bb0985ed32e87cce98240c6cac2f6da8816f1a97b5903798b24f48421b62b60eb4eeabce0a497e652a4b9f169ae22a9d52d96430aec02c1bb8b1928d0d8fc0893ece3454c6c291aed7d05bba1f98160a14d9429c148b319be2e914e30406102feb625f4ec863f024af36baa55eda40d1b23c867524c541fda7f7349f5f5b06f144628f5f29c45bd212557ddc5728ffda59ece7aeba548781ed4e736b44de1a6064e297b020eb4b4f819b545046fbafae87fb5f365cb9cea13b0a0f9856ede500cfd20dff11aee3780f7fcd4811107340a868c1c3a594e61d448efcfa4da269027b754768447328d2064f6a5c21eb1d6a61603612c576f054cff27fe517646c1debefc9e59e39de2aca3f334ff9deeb85b0fb282a8b1eff127a05dddfe5329504dcd45ece3e1727c6daaa505b8f24e20a818e91e37bf91df6f5d0102cd0822648303ff039894644852fb408fe3db98b28874e8561b91c6fcbaa325d96407f94264d1e4f2b562486a2518ff45d5a92a0827e09a805c7158a40f5e8ba5f473d704143b93d5bf9d7280594963f4b11e09c8426636640e05684fbd823167511d3a217c8562f511348645b5e222c783c8972e233380e9dada3d77710803b450ee2936c7c749e3c5b1594c4d6b8873e8d6418e93ed62ae54a343ffcee7159e5b48cb83b60293277158d849e815a4bc38669f9d3d3ea7e1beee869ccf1b502b3ac78814f37210aecac1cc58178b34e2c778267b575e12f254d92e10ab179528a138ca3916535d6a1c320c2168fce8c2dddf633ef68d706173d2a4dbb202e956526c11dec4132dd94baf86cb627d6998ffc4cf537ce04376d9c49a10306f06c61d42c53285dab858508aa86b149abf4045780607bc1e7a66a10efbf821acb1ccecaed0ec0f429ff8a48583ab8644a74793c2830ff1a32bbdc5889cd7dfc282470b8bd6780c2dc2e6da7767b6ada07db4eb9603859df81ae58a486adc6ea7e37296eb602968e037fa437d362d938ce057a8bcb764796ac7584e741560f13c968ef437bd94b23204148e7d44a09f3a9639edc621f2a9a35b23c2515d7e9d600734d58801010abb01fddd9122f5b4951ce4fc041b59bbf1c0b11d7699858866d96c25359bae62d2875d88807800f7e420a1feb417884dc1309704cdca685c0f35b94a8b72964a23557532a5d6aa74577f579e6fe2df82afee7e5c632d49a06591804201d6ccaa510bf6a8008186f6d143fab2a0f28147c557094cd36d37768cd0d4e8678309dff08351569ab14a06f1c40d175e0c30b7b56d2f7fda441e4358aa85a5f669733763c7755e0aef38f29e38392272957579886188e7bd49f36fbaa5150c48ee55b797e68b8edcdb044afb8fa7931f43174744bdaf2eba0a1f4865ca5b1b1ecc4e40c4446607a0fe94f1f80db3642ca0e525fbbd2fd7c01a02a2874f1dcf7cfb490834b14ca847d99579a596c951f52daad2127e9dfe0516ddabbc70e25e8c32ebe643320c593f64319dc57fcac508a8186a67bd5458a50756e2fef765992f4b917f802b02be1129eee89eda2531c65a5d78893e6ffefa1b59e2583d0986bb6a83da3e2196e292897cadd82444f26e0544d0a0c538b6ed5e44c48f174b34c8476618b6c66c9524053219b887befbecb95aa5811a7d3f1ef29c7eec02f9a375d4b4a78328826f25dd47c27c60081bda601608ea104700f15f8188cdc2489903ef9a2080f86a1e37152c5a2bbb0ec1fb270073c9dc244573bd19ecdc0321e99de2a6c8ac4eb8b6bc432ac231d8a1f5013b79184e5d466bae9f7f16207b34e80c5e61f05aaa667221cc25fed2447a454a8a8c1966fd0a8d25c6c6703bad7b1fedf89240b27d7d2fb30802f8e42ad0df3590c64fa1d3078f9cd40401e8a305629993ad4f28ea3edc6c877c53a10cca1851dee2015c02e1dafaa058fff896c99b57d901f5f704bddbd4d27b12464335f43977946f1991ea555658b8e6f824c024d1836059d91fb50f42f943974b5ef0ce2d666a4c33d2b269a012e25aa09a240c192a8d077e21460e3e1f65184ebf5c0cb2081b377f7a6916ac5f0c12a28aed8111be2a54146e1c990f2bb6c2c825c701f8d5350b554fb92d81603940492e41b21180408ef71eca0cbab8f79b71a64c44498936846f22e8dc0053601fef933ef6995f1790ec21dadd2a9705c8df9b87323f764d47c505891bd7f537e60ec43b134bf0e66be7a5eeba50444ab7b48b787ca802c4dee8e237439b750440662c5223278e35a9fd4e57c97a209ab63fa505fbc5303cd2ba86470acddbf9d0dd20e09248b153d8388a41e22c5d3470458a2c7172589c6fe138516c78ecf33e1c4e235f88680df2f7e78f718f6c7a3f68dcdeff79813b6facd9193a7c3f4c113149d715a66521171f40b32438558d8c59c4d1861c3f2ca54fe7d4d0a1cd98898116ef26aa65515e5e305802ef04c7cd8496283fec44fb801b2deb17b351472bd7a85a0b08a07f330373cccd1e0f1837179a180c9af49c7626284cdd80cb458912e289ac0213c02f96341326c4e58de89b83907e6eeb021cda3fcdd397f6743d2ea9d31eea29606c6b6afca41bf8430af125a8212bf91555201bc41ca876d5eed363857c043197e7ced9529b5b8d75100c3ddf10f178564bbb8c8d3b3d0ef713d255b202b77a7e030ec838477fe14f48dbc745dddeed6ef3917dba85456eab74b5a13cc0412c0cf572d659560971b9fa98c8204d3eb305fc0a091dd529c15ffa1a03681b8589fed7e895ad0890e8a150037543bacc80cccab82745b71d7f5cf275375417a4604bf70b53bd3c6123a7ef582a383ea4d4edbcac2ab1b7c7832d5ee924cfb8b3e41daaa3a7a960ca8afdb2e53c5fedb44bfd835e599469e1f47fb2c40752203a704295c4cc7f218493f2628db28c3ca0cc323a07f2b234309138c977a07f56514a5adfbd73c0db14d8efbbb0e875662fb703c5b14ac77683ad1e816f38b882cc47e36cf64ea5181c8f33f91df1ad613ea4c344441c696a726224747abef666854a5dd3feee9b8ca9cbc1be01b725032a845fe36b29afb8180778621e4b0f9161f4c0335df4307222d41bf38fe447617b91621ce7383bc7b69ea8e392bb9287bb86088782875c95b46df8c88a6cc99ee3157ddc59e4106a8fb147857fe734becfd82ab236ee5966fa6167fe8f3d96b0b03f149a91323c7b2307649ec0c97139ea77a21b8efeb9fa5634582a7a4811fc6cc71108e51f9a672dec180065d1a10273eb0e3957fd6fc3cb9eb7625f8ab1ce35cfe0cd25bc505f05a6c5537d40a2e5b8154aa168f7c63e5e4c91316ac5d22933f5c13b3f117cac2aaafab622bde6487727dcf8ec1e65d2160e5d7f3891463f8adc674df88f41d5b1a7cea26e8067d54401ce4a5f71e050b732cb8de053fa411a7de49029f5a8a1477ff64d785273cfd43cdf8f3783d76c73701adeec21a056c0d4d932d23f8a25fe644c87bcc2bb847fd4d11656d941ab252a3215717ae201583305d645991819fb36cb795c7a19e7628d8dadb5db137ee90668000f6cedd5c65c0f8fae6a668441a41acddb276fdf8034fe8f51f93aad02141e380e15dedce0d1f0bf5812678ac909394ea9c4c3bae439f4d537918c5e68dca59fd792aff977cf8879cf0d14a3d94db7e370580cbe2146c95bf2a944c7b460a8d59a3c8d262696944b52feea9ea4dd97eb430827184be11937997daf385c774e29457b1cc6fc49ea2fcd7dc04fe4b564e0e515b91e182964faf41975b71465234d5f852aa78008904b70593854506943701a27ec5a49542f5e93cbf75f2544c62ea52f4f3bd439d3c5185a168bd44e7127d5320500791b15dc24d317683fc401cd246cc9b0279c22a12d1a6be7549ca4e41e0a40a95c3fa08774007015c0dea6e7138acb0bae064f286ffbf8eac02c35e463e2244e8ee89b0953237bbafa4b9e649f7c1330d91e2ee97869cad57a33f0176918277339dc9853169b4960a355ed8b4112b5db9cbdee982260b7621bf858b8e7cc32e778e0ccc6deaedde40654f55c9351f050ade7c2ed31f961b1300fbb9f84337cc85a241f2be223f07b818c39a912b43acf78141ce858940ed8e4f2571e52a3dddd5d564ff7a07c87ec8fb7f71f3ef2ce0ca6f342a252091c082b7f4f4b48560e145514071b81a8f26df84855c4060a8d4a1b94441e9b9c7a64c637b28f65d69e6c0b60dc255c0c050475e41d53a33e41643402be35cd1322e852d729f0ce04535e5cc1e74b5a9d260b4be19fff1c7e29e1df19cf67b9bbb4a94a1b5f642c75a942d49168fbf554bdfed8686127b803eef7ac0f6fe649501f72722a8b90bd96205d32a78a561ed6ee08c0610a8b347037fa792e88f9383038575cfa7e279fd825d2b81c09bc3e9fd77078aeeeb1a2c8504335f2bbed105cceea461dd57fb04b1a6639bfac28f74d15e915d5b81eb4517915e57f51183009c9d35efcc2b8f437a8b28f54fce0bbe507e7dcd53d83815105cd4129dc45cf5f98f6c228582c8de750c219a1b170da8bb72533f36499e2fcd1bf39f8d7cb013f65356ebc73350f93c9dafec85bfa48aa160164f46876ab293420d7b3fc6582765ab51fee3e9c38ff6c17a63cc15e8cfc548549d36792d0cfbaa3dad7a072d545b72dbead63e9c0af8f1bfdcbb2657425206f854c6f41fc3e7205238f7380cf5720badc8caa9d486d8a1e6dcbf666bc5defa337eface2b58a70d48e2e9510ff0a29fded4b0c912b1e6f326904fdb12100bcac91241d92355746e7621fb6fbe8e7fcf1d6a886a09bfdd5b7c5c271c747e7a8eb12cd6d59c8c25ad89283439d92fd60287868155da03dfccee791a3fd6db76cd4f9e00ff8190e3d55ebeb79e7e1b1993e7afe329e2a22094a636814b4a50ca2fe6b9f7fba3c60e01b81ac2a314ac4eefad026e4c841a389504687b592c8ca2f35feca47bde48b70899e157c58e53b5e7a258a2ee242348631fe6319bc62baa1e96cc29fae2c8123f0b09e3bd436dc1e2abd14c4d40bee3bfea083b95a4c20300a688f4be721b54de3431ab36a468d1750dfd37cce7a68fb103270833c57a5a9485bbcc0b54ae98c13f18d544ccbf9cd91c749ffab3088ee426e69efeccc064ca97d640442fb878a5bed3da66e93c0346cdd2acf734ac7b4dd143159a738c70b76b2a0204524bd1cbccfb9c844682f016ea2f7b31ef2eb1d4ce85dbd6d9ebf48b5da5d9a9c2ddd4ae37cb334d2178f73753fd8d3a11a49cbd537f3636a1dc1db47940b96cd1956aa0a071719fc2cc152d7c77d517589a4d2f37e200ade586e85eff41060de38955b610973fce09b9c4cdec8afa32a5d9c1c0cadcbec90bd92597048d3b6df8340b2b73dd743bb70765599dad428a092bcf2b7e08a5b6d017b578aa5eacab0f5d5e913fb833221f06d25c869f7ce6026370a8c10a73d115453fdc22957e54e41e42a6887326499a9361ee3ed7a05f51e7c0773c9e9e96c4b7e15a5f45b3350a1f5bfa42ce1c3ef8deec5762be6b1a44a830997c77a1f624600bc95c990b700d0fca3b302c9b7658ee99bfed2a4a5f637c6e308f36ea40bfad03e44efc5d3e936bccd89c103922ff4ee6564d2ca6058c1430d1e8660fcc66ba92e054b40b34dc43790999a23d4bd19d74c9da19967a1386c6fe403820472cfd873f7206918f9061386de2bfa51eb221d8bbe830d9a7acaa804cc1d03c448d8fbdc689c5e41785de02be25720d66a92d2cc2a6daa78ce55c99f0a0f7edae7cf7dfd0b7701069363b0ec5a82c32616d5e273c2376dea4acccf564c8921e661f36026dddb79faff541b36f2dbec0bf0db7a1a310de0ab95161fb3fdd81e8625c531979d649f39c923b8eefbd382aa28d09c827e8ba7ddf2adedf2cd76251d60a5fbbeea914cfea786202d39fe168b42f9214b50f43ba33eba1a54797612324c5048e1b6428cfbba83471a6d81006597b583d9a7992d32256929e763aeb5dcceff929a66ba4d51a114affc6ba1af1b789ee979518a056fdac10bb63331e1d7e39d81de108225e6b360f511f149b994df7fbe5fb0f857622cc7999ac9807f1a7f2baed1869e8992753707774f35b1fdc700934b5b0b409098a5d85e6344eb7e641f0c2e8d0f073274398c56ea1829f4571f6d78363be21610bddf3f7f8897156b8a7c23cf55c37328a5d5f646f31b6d86d86d44260b8ed9e99f0fd79355fcb4408e58db61493c08a9bf710b93ad2b838feaca70a6e8bc9166d6bac032d3080d30944c083297592290ad95a60d0e010a45b2d0120cd05dcbfda9ffff161593526631b1b5365ff89547b34d6e3a775e0113e5a5ea499b1f9fdc7451577bd80467a3622a9450e1dc7ae955c726d54f5ad8527c1f5207ba63b11156981b70eaa31085c7ac69bbd0b5b9f5b125f8657ce10afb2b4d3d7e97c3f850b6970a554909cd00d5af201cb666abb89af12e90e8f504da1566d06fd5108a609b4bc6854220cd792e7c7e02449eae696b8baceb5d0dea1c101df2aa8ede61c523d52d1bd56d86034bac5ca9f41bb99b93a77ff9fc5ef7bbe6b84b1fd31451dcde46b4d5ffdd9f70a42f01d31a8b6422656885632cf0cfa1785e40feba55ae0597ff72f9f35e0bd20f7fd7cc6c578d1d44abdb83401f24cc7c4fbe5865b8e6628002c79ba43bff0cd22d71734634db34a5e8e2237e3bcf832990fb1be288fc2aa3efdb4d1e0ebaff2ad741ec69c4ec4893c5ba14c8dc067ee8e68dd9a7164005e3d099b00485d6582fbb214ce50814b887bdfa225035c10071859b063df9160b4cdd62937ed37802e6e7a6bd36930f6dd88bd507afa17eae32b4a8ff11df64332e843d97c4dacc14e258596b796fe7b38222a01f7513c57e2f396dc2305497df27ea722cac4b8e8a1b71911557b428ae752f89dc5cc092e4662886d95324740b77861f7ae6c74e0f7c2fecbbaa066cc58a7cc7022e277597b6b0f404d07b833495812f12fef3f198b5892b1b2e4afd9384f92d305c242acb153c906599ad5d4605b37b7eb7f1ca88328b9dfef5c509223fced7127d1c3e9a1aad4b8a1c5bb2e075796aa2876fe3ecb85892eb8e8f578129128e821f248c1b19c1f165f3f726ed6462ae6037aee7e3cf7bcdbdc2da853a44a1423f1fb161dfe5aeb9ab6004753833612990be2fb23809fd2f9fd522a23cfbc96c630bbff65ad06089d662940ad3993a7ad2aadba145a6489c2584c8a304f25ba7720bbd208b2aedb76de85f351b69ba6aeb883e9b98d2b6ddfa686a7dedd5959649834bbfe335bec9a59a027d967986da44d609b0eb19656e7d292559434e829ca7c66204444d154327cd60749c8973bc63e39bfdc21c5299ae5d42a9fd5428bfb28ba4dae13960360a698b9e9af9c75099a8f4ee0c249b54c9db6354640e7ffb6544f7b4a620a3d9745a627fd3c1418a165e3ff282d8717a81d4818bee964e411bb2429e97a96ad4a5d21bf88b7ba64f23639789dc4a7870b749a227b1125b9e74742545b491dbb72b24601ab2edb7e7ec81c39509dba9de13984b761db414767c6a1bc82f540d3a3fc085b956625bcd27d63e1f17d204772e7175f5b476e628d2e2eef6d06ccee0478a3926a7707aabf77a2b37c3800dbe90331dda51512d1bcbcbcab89571268e291c604d9c9615af97970b0ef9b17ca3bf7934b3c4238b49536f860104822e3d8038db6f13e3d1a89a3325a476e899b1909ce39ae9879cca7ff6e3ba08e3efaa3448498ebddf25c295d37276c2c91db48479632878de3717ec8945a980fdad852bf3233f181bc441ada6d6c4ab94ccecc39219a85d9f7bd74919bd43f69c0556ec9c468437a766a967614d37d8ff95a48dbd16f45db230ff21e619d088b25bb995701b95485d5bc45f7ec5f9d965c31077d9d7ea07461b0f39c259636b254259fc56a5225a409a50c26053898696cb7c92349b6b1fcd08f0fc6627ee88f2e531390ac42d40b4fa309ce8a2e4a1c30ad084d7620dc8148b4749e7eb4dff207582aaa0c6abd0c3ccb0745124523d6b73501b61ee1d8f912e91593e7926461e4bb13c2c09db72bf7672d5204e45f732fc7bbf73ccd4da53ded199331130ca40b504dc212a8b05d34c31dec777bc2225076bfcedb045006e6cebb87a467799f35d3ce25fbaf9d74f24e4a92d6372b0cbd80059f8b87925786811b09c6cb28e41a9a3158ae403d226f593fb80b5a6a19730313b416002baa1f023429814c9f749fa02cef6417acab486dca5e4f9cf2861f86fd8a4e3ebfc86f827a61dd3193b66154f9205a39eb6e127e88efe8f2eedc144f348319f98cee3926777766b8ed1481fb4ebda279c01adf810995c8354b8cd09dbeb7091654ef7cbfec7cc0ee0a38e33bc0329fccb4ccfd0a285cda263ac9d8ae792931fecc94f1b5f07bfff89806902b5b15b06ac3767506853601b64afba5669139dae3d74896578c700e48f10123b606e8b58414b0b4282323c2a9ddcde22b8ae6fc29d2fd6d58b84f15bcde2de5c726739bf9c0f36ded9c31b147a036a5094ca7282572ca3a01c49bdf229ec5f040d9afd13b4bc9edbec7caac7a9e5a92e2692bb125856ab5b24d3951ac6f8cf65743bf1ae6d277f3e865a8145be7b32994617e4882923b02fe5a9c57d511b12f6cb2281cfe0310476d5fb9f602ef4c7de5f89649c08b90c5b911d5adf55f58abba91371bafd5e28c4c46840ec3f7d8229abc71c71712c0992e495438535a3e1891c0d2a81e162fcf19eb0ca7e901ea9737fcfcb7f0b4bcde3e7b3344c79e009d07acdedd6260e54e2f5860f2e61d1ba373d27ae58ef5c3b3d5dfafbf188e287cbfe3f19e9fffc9f6b08daa2087ecf15b3a005a0b3bd056fc2d66bde843d4d43aaf67a6c4df2ed3cf1528010f2134a914c163b38ad24d7c0d461f8bc56f52e3748a11a962c4a5727d0079cfe9a7c6978d457886308a0d66d9392795daf4443f4b52f47a7abd956628817c02e97e93cbc2ffaa8a48639c8de92072140de21af4be9180d080fe46975210b989b76fa362ab697789b4bae84d75172f645581dbb4022d9599b06b3c3240ba73d5c175800391bbb6e90028f3e6b5abae3ab4e95535e05f1e76bdc4f1438b5553d1b66946a4485fa04d8abc6df4924fa3f92623611ea00e36594457b9d8a0b61e1c09011c8307af6c9509ae4927315872831baca136ffc83c620e257e13ec7050da2a411b8fc2e92edfa324c01865161ab1923421515a01cf3e865fbe6b54aec4267c42838ea14f0c0fe3175b0e0f7098306549b7d23a0d37563a46ca26a52cf9a5bab90540975004536075f1b3df9725e3efb18413b58b33a32ac6f6f6b012af6d4df2584f88189e3320f2b458326f6c9f7ae75e3675fcd1c572ceb74337236bb1e6fda0744c8c41171f9474166944dcab05a08c9cb0c0a05295c659173cb189f4d46a5a566cf5c61e348bc5845532402e7da501049812888ff8db764a3fd285b54e7007c12a5c8965af50b3711be388c5a2390a94d787c04a64661bda7eab3357a06d3099b094a95decb5be71d73ce007bd12b90ad74f0e5efabb8d7c990a8e9769a30a6a29a444a2f0b648b6c620e5a3ed0ceeaea6f652bcf289faf9f5d42518a5fa4f5c0b38df1e557ae0e53cb1b6a97a6a0e3bd35bc4320375ee10f24d421f8ccfb2c9bdc24add8e22ef385f2702d959f8d77b26edef46d02290ab602beb8a9bc739e3b741871b59d7685cfe278dd0af443295a5749bab4045dcae6ce6f1229480d49fba2ae8c8dd0267a1bf7e85f6a28f0cb87bbce4046ca6d4da945da7f36e7e1fd0f4463cd39fb08bf56d0baa3aac5adcb38115f89d85597393cbc2e9c1bbd5225a0bacb9cdb9fc7e4bf8a5874107559f3f540851a99d98e204d8b192b49f8a21cf7e3058092c3b10d497e598f2fb3cd47ebb9f801b32acde972072019d63ee7b8e95fcf4c5e753eb5342b6fff2670d1705de1907f2ba2c9f7174d2573985b91bf09e7547524bb350843c6e8732fa675a4d0750b080ce61ff2ce58f925483016ce31a2933905fc907971aeceef4039714eb606ecdaf6158cf4c4ba27da00bc1a50958a87e8436afaeba5308e8f4a332c758db943a8e58ec9627e527887722641025041fa50290082484f42a893968f7c882b791cf3b52584374956b3beb61227caf0a1bd1512fd9b77972121321d9563aacf37c769f96d8c7caa485b675e683813d63357ab257ed15b32459c420806d20a15ddc4002ad721fdef27b961908a68c0657b9744b761b446bec03ccb7ef0817c3d6805ca88251c15188f5deb5d5c52f38343ff46265995c5005e520ee58371870c5046e553fc5dfada1528523a5f2903330960a12f699682501af2bb7284e1e7a877ef65cdfe559d8dd316352472902b4c6598d6a982f8c6f718f83299027f893f2a296467b6d8031e4f8946f1da0431a18111ef42d53f16fddfe13833c703b4f3ae2cadf134e1aef773246befa3bf0a95fe12d731629da4ee62e5e8a0932d2bfdd84b6eb93d584ccefd6c59da97c99dcf38af7bec0b7d575f4cd47ad170a88b051aef76b6f9217c91998ceb48f4dea6ffa4dc28bef04c2182c3240c454508d0ff0f8e0aabf984dee165bf6afe93a872dfe32690b20b385cb7591fcbfb95b6c2e54600d50fd296609f29cf409d767704a844dfa448491f7ca0cfff09da023a4a9a387e3ad9a53be26e279cc8175384fcd0af905373e5d88650b9bb03c94981dcf728b25042d0d7ca937da0b1743faa53ec0c69bfe54da0a974d8e465fb7f8c163e2703ae56f2b027e04af8302d063c3900c4b2575c85e22673a4018df69f5d68e21daf0acfd1dd0ba7622f6e5c311ff846422065f536698e8cc8fbf519ef688983d1c260d8ffed04e3c3f55cc300d52615c3f9d9708065cf9c93408657aca1dab587b22d7f201414c43ca3025443dfdf1728b386917757993b17020e8eddc515855a59879b7a2a5331b76d2d8a774d2cdf627f693e9256e274d9de75018e8ab06f8bf2677bb73fe292b92a3917b216679130a6e7793d04e659918ab19b472b1079a3e1c1ede66d6ae887b8c4b8622910b86c91012e14d882dac245f2270daee1a81b90e8a267d5f23a746e809ea0d4b18a2417d46794d4f3ae0ddf46ddbcd440db9975291f4d0a0723845255383598f3596e5a10cda2fe4faf122f5f810bae5cb1c303bbd2dd969f97bc37feb89c9f2f6ff86665448ed8ee361c699d1c3decd9df50ba2a749dfb3a5e82227565bef9296a6c881840f8650aa47b52f1fb889956d3f0f4c2cb6cc28d3767ce8f1c2cb15625987673652413ee8a7efaf4aa7b01b9ace866f4426a6bc1f3a6488b0b5f986edc74700bd6b71e0e0435361da9ebcf1660ffa271c3748c7cf2b7f49a3ff1dfbda973cf34abeca974c17839ff18260cf9736a2d0ddc19cb525a3e8663c0acbabe1800d0f3344133276d36810e67d95e128a83f6b012743c8bd5a1b6067242bda5a32fd8b0da2fc5fd2762a95e7d85a40f650c9fd0f9cb95c54ed7cfb1b9e51631a082c00dabe7102abe20623ebdf903069d8d88cfc83778b1656f65935adaf210a9541658ebe9d9650d4d58d791002610c1f52311565681dd389e3dd727a3a0e2efee63dd59b363491b75e2e583aea0cf3834d797143db9f8ac2f77282ab19dd414097ea3c53f5e73cc7b07d6a40c1a5f7f7deb8463457bfdacaf4a3b96ff99df95a2593e2c6a9e294768fbb0be02824b7384496506cc58667f44fcc8e05c5d4de51f366c277c4178d58f91900b611ae39361d91d47e4ea15377d89572a89fba12958f34bd50737f267ca72fe66c2f01a8f3751409da166dcce0d4c5e0d0c1c1a2c16c0e88b55c818b3cc1a68519e59411ffc557f915f8f5c8a96b2431ae1400d037170de7d7c9af90b92063b74951b7a73c88e8f54eef23d46a78cfbb1562c49de106e0136f3e85367e53d97588786c731d4aa81638c5c0165aa6d1c8bc34fbe8ab11dee83b01178631a5bbed75bb3f0902f025d5e3c0ba9f882bb3b994c7b16df842b46e25c5e631443e16239634ae8ae9bfc76e019aeedadfc802976fa563c90573968b873ae8202b3d417d053373c3100d5f63ab13540ff80cc07d67f74df6dffd0e6c2dc56334e05e596f06020afec5f6bac5e803f574b2dbb53ad64794f432bca8ec9ae8043afa21f2a98683f4d7872a201ab4c7867906a98f0f858f497fdfb0d5f7e14038e8c91cd6228c57fbf6089a86668dd0635194c393f2d2348642ae599b436bbb19813f5d83b753715ed0fe55f051a61d1dc3baafcdab9c1e4ad8b683b3cea705a21ea2234ae4cc20611360d230b45c860b3a67b86679774d850503019ef9c039fe2b200e012a3c02878366e78096734af1e6d217b023eccd58b5129a66bea2afb83a8374e8ea5bf7d7880beeab5d27cf7fcb41eb430d0df6bf4e1530c7f6fc842e6d25cb2a5fff1657e4bb6c50bcd94791008c8c649a549d8d987b2fe660581279f2df793574009fe899542ede1925254d880955679b44ab8c356569a0e635fb9904cd9c49efa7994794ac5f02246d193f600b0a841a1d206ad8fdcd2507ad51dc311fd85c3062e5b96ab7921a612ee6139c7665209efa268135977933d042c7f657714ffbe0340930f374fc431de4e9aad869d169c007471062a4c39b1dd64586e17d049dd98f4d0ba907a7239aacd5015e4aaa92efcbae9fd9a1a21d29f34e5486cc5b1cbfd9374a4a9a639caf9f2917bc15cb194af4f67f8382d091d8ce8e9612dab168d26d25c053b8bbe4a99f3ee9109af84965e33ff4b043b32756765e43d6380ccc297115bc446868b1125cb245d74f51399ba81d25db7685d3754ef3b58d6e1d7fd45e29d85d5f4db8c2dd419891745725946e4c4040047ac7324cb5b00eb6bf2d7dd5f7f313ab0b3c4023e79c50b3240ce9d5b877e0cc14684aec729b17856e1ea54d633ab77558ea31e9a3cddefb16b8b9dcba082fcf0dab58b080d4232dc88ff65c6dca98f61de75624abbaa966af2c98a33895fdca4eced475d9634909b6194036fb82a811b4a15a4532126f80e877b7913672604f28e38adaa4b10410e7b19c3eee314a1fe276e75fd082578e50ffc95ea2d5bcb03f25f3b82246311d16c635cf80c433d5579fc71ec1d3c15db3c867b91025ea8b1be26abfa727ad55a1408d1a55054b0e608c2c45918b633bd751b6469b21ed00093b0fe625fe34cf47afdc02c9b11ad6d0374acbdf9bdf7eb9828cc4d44f22704ab53ed297a9ab331646ad06de99370f21988b03eae8ed8b42a2fc58e127cd2de77e364f4d71540ff4d8e9023ac9491579adf6c835254940430a2731e814e304566bbc7d553cb376a4aea96d2f9a2b41ba4f13a086d6ed8a3069f4cbe1164b828098338fafba58cca54dce1ff90a569fcad82cf7ac46b3f240e997381f8409f2cb326ec8b4517bd1e8259778f543cd7a03fda85fe38d66948024d3622d4e91fa403d0740266147accddc20aa95b7994a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
