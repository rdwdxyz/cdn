<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fcf143775f6970bad89626bdd6e2a5fb13b1643c05bb1d565194177962806c77050989adb3884748436e10e80c5a8ee4706345818d7310750b8581e32b026baa210a1e0eae940ea6eb1004eab619728a556fd6aa02dd94ddaa8c3c3c679227381d61fabfae777521109e2a974b52a5b0828916706bb4941ec56da8780708c46a94e7be7a855cb39a32036a29ad0dbeb317164c3eb9a55d28b5d228a867c72fca96a5c8de07fc9cc31567ab949ed7aa90b85b98f721e043e948e6fca5bc827731a85245ff3d963407034321e869e11b4557d814f09ae55833f19442f538b5bc014800e6d36efe0935e8c89ef166348d24d4426634f2774060a3189749559cacc1ced443bc3a18121c6d7ffd761a76a0205fe927cf07799918438c09927d9126cf62745e5104a418a83312f3ccb4ca390d397f1a7d9cd256bf6dfaaec8666cbfb372f26a7716ff9a6111df439b55df17f12dae0909e4f528b6b2517a447546fc28bb502fe06e9413de4ec62b39b5855a35ef8f8fcaf6f5ada6c7227b505b1f40573849778c81545102620148455d5e5649d758097dd5461c33a1877a06c0eba789d13e2ea91a0794a2f18f0a1b1e08219371ab48fc9919533b1854232c8de80edfc984423afbdda7ca61b09087e3e0dd824d677a19f23e96b80b46af8d01a6e374874ff07b38beaf4234c1f75fbd3780610e1a8ec5715f04d3fcfbb3e87cb5be043e9f2cc2d18b871b06ea31c8105fef270a62fb0a51fc9dc15ab51e6d498d4df1bac48997849be33c4da4b5028d7f5bbfbf051d93b84f71d36117ffe86a76304c1aec72f01760f6235fe08bd3e2cb4e7293d2034b786b9fc4b45be37c212e5059ba68cba96cee4194720c722ee1461dd0a6e4773f13cd3fb1d047ef29a300b8044e69e3cea31b90a57b761b52af686bada0063a823d3665d2c63c55dd46f790249119c192c2d59a9a5ba1e1c5f2a039b43fbe06c9928a08c3a7ccaa4f55ef8db101832529f07faea329fb2ca8c915fe2aefd6c7cb47d7b6c8c6a9276e37bb99f99e80dc537824394be6aad6c92d6dc486e392479cb83f858db7fbb80f05c81f422a47414290aa705a82bcfcc542f8e3df65957d15af5246dc224c9536c69646e1a2082ee40de9a30d78ad230b7e5d751c0707ddfae458bf78854e69d7096107e9a2739d6123ea3659cab7248ac339c043a0209f0f5ab3dedf4c607429d5bd828d2a3a84ef7722727fbdfd8a7f61602b94854b93678f0a01a07184bded853d960c6f50ec59e342a1105cbbb3acef0ee037869c65a0f5b177bb9a0c287c38946e5f05a84e14c405c08baa05fb54702d4bbb0034980b22c181345358c3ed5c89698143aed1e6bf805d060f576afecdc6ed9cf4b80ff3edd8b2a345b8715112bfe26b02a8ebd999d4685fb6f70ef6d38d9e340032a5d2af2b174f60fa34867c676a839a1ee6ee1f5534c02e08a076b25559ed4a28224c10911cee56ecc9b3e2a485a26c462a15620a451801b26d7d5e5f96c4839f84ffb0a4ab087236e66805fa2476e061ea2c3e05d5ad6ad29c52a0b0503535e523eb86ed7a3fd8869779680d719cb39672ec004b4fb99a079ae6e456ac6f03348bc16e33190bb8ae19b8cff178a9af52cf5aeae829076311ad692ffb283be052fba6ff1defdffc8f9be9a86c52691def503fab7dd3885c3fe4802205ed93e9b66b08fe9ceb2f5f2f40e181b308dbfbe7720c04da2f46cade53291001572847218ffff073defb76275a76154a6e8a7ebc576865c9aea0556885fd6b7772fbb2ac4d1b783a8dcf45c13c1905559d83832057c95f6e55e62781c6f639450661609ddae27683c4ad882bb8e378795380fb276185d910b7e888f70acbedea5f196169e121769e2c25382a4663aeda74d8c846a07779a2eb4b8e39eeede93406dd20d73e3f5d9a5392819ab46006834d29e6ab37d727963bb007f3f47e94e38070e842ab3828460d2adc850c7ca2cc7eb6a389bb88f5c26af8a651e23665d2185961c0ce42f0df463c1ed0543625605c9537b7d7a6397c8d35423fdeb21a5805ceb4c402d55e3af05137e68428aa14d8745bb3674da5cfc018ddcd596891d30969047bc543ecc5f1334932c4e8aafdb93b5a1dc53fb4da07bae2dc98880181ced7445bae65e4585d4c7a98271fb8021554952f44c5f84d8d877bba3a1ff92cc9e30371a7f00d9a6bdcf203b601a21f0dc07743d36f3efb4dcb57e21f3b85e11d007559c8b58d0a042a2a170eecb8c6db5a0a53b5cb2f41dd9c86c7133d5b38da67e58349ddd373ad7e2a4a84d0a50a73a53b74b7a5682a96b4707faf53bde868e30984b179e8b35ff5219c3812c07ac90bd26756eb9d5ddf73320f49537008cd4fd8c8c2d0e0399426a41fc84f8458b98259cf4d6649c6976583f17c0b07a98980bee5382da51502e83381af9a09496379527275f44ff3ec302f7caf581076609ce7844948dec900b4193a589540326dcfeedd3445acfbb3b1d7707e5297af84a3f9c0856a47a36265e500760e9b217db87b16ed7729566a005ecc5af2b4e671f22e7f33a96f0b0bee1c57f3a0fcc81724f943d612d2c94be85e22944ef6dd86eb151200c96e2fe889555fbe9c514bbeb9f30ac0612a054bf75fe79b011fb9f647c7613902abe6758b93428dd763978361013d64f188eee0d579e3a49f0f971c68c0b7d74461a8ce3768e54c676533e020ecc45acf8b5760a34a3f54440446c8f15d1fc5ca0f43d493824a95e322c47c27cfbbd2431a7cb62a65666f0a03c1f1daf067435c59b20ca5f04427d8f6f551f94159ec5e1554d31a33573077e408be8483d1e75623cbfaa6af3ddc048a8ca6dbb1b0d907bb97793722fa7a3494882c5b887b66eb98a7f7c1a78a03daaca19cbf0a64d8b99b4bec541b9824a69ef5661e4436cd5f572d97235a6c1a73be2e92f4497f7d885f63a1998315a42ae97b821caf4c603105874502d32972736a6477842465e6a1e71d3d34a58df5f3011061b40c8c5d9ae1a33fa3d003c69ea35c32ef9f106c8ccadf77430f0edcad66e235734c5cc12b8fcb47d1240418b5f93b5bf4a930a756f01a8ee595120449a5e8ecd64bdfe169e763ef650240324a1fe48a76d9eac47bf5e54a468ebd192a4ce51d555fbd17c86bc9453d8c0418708d65bf97d7e85c41eeeb6d682dd032db1576dda925b67a7ad0165a3d8bbe1c48600b49f81abd468b903f583f102eb5257733499b1528cbbd926998dc7962558869db240f3b9c394f925e31228b887cde45933025b29b20b47288598ac7304be0cf90e090423eb330e552dc1ef44442622ab75e4262cd4cc8054612d641f59bf24f36db5d54af02ec24f0ad88a3e3b3faaec35e16e8e99031a0b6b5b5f1cb9b34ba98d13633e9262c14c530fca67dd0d00661e523eb573f2a34cf3526b8c36917739b6d664ff4cdc7ecc872266da5e2f55fd899fb294bfc1258cef81c1d519f7defe1a73df8ac2cef5d55a2f85016c1f44bbecd6c23d39740bf8da1525cd6832ac251480f76a0738dd7bf9ecf927bdb5b12ebdc7b21efbebc36e4509e5835b78e09682f14398527125c99e7a09e2303626e1372d6fdb54a37e80efb7e4a6402c05e646e91b11137b3de1d2c15ad1b598edae1d9a1b5bed3f04a09fbd29f12e72da0e6d9a6ac89a10427743b32e0fb7631b27951a203e209711ef8102c10fd2e96ef01d80e5b04302f50cd761bb4791a47bb79a4385b2079961e1800532969f51a23cf1be792531f291b5819d5530087aed061972a3d6d1e3e4c3385b4e3e28b96e45cdfca8665cfe7f63b73d827174dd700d52a41ae6b742ffdede5d5a8bba20015a39e5da9c18d17503cb960f91f3e70fb9edfeba06ae80a54c8fb72524d75c0bb0fbc5eb53488a835be8de7a7d96a862766a8cf42cad001843bd181deb6ecbbc89c0014977d85865a0736259cbef1668da7e6097b76f5d66b392f551e786474d3c45983690a3c59d8dac43ecd896730f680cc0f2c3939c50b0ae5d486cd73515f448e14c94b3231fa0c0af93d5e821c405d793adad20430a4bbb6a81f8c4b898e8c93df22b258122fffa5bc16e0b77df52246c5fd1f8e74f14848d68ffdc3df0e243c60e496e6a959c5c0e361c3fc3269d50552c3bea3a1281fc8ae45e45d2716a496763b0bbaf4147549691482ce40f8a7c9faf326d7121cf23b4bedc35503c7206d15b2920232c21692121512dea21e9e5b07da690efb955ca9d70eb618231da202571e89f3b5238a613cdd3592e06754b58930864af1801f032c1f013ad79009dbfc8121b9549f3340114742afbca8210fae5b9ab4ee2f978cb8f6c17509eb8286ae97e5953403f1932e088f386ac2874a08c058a7a8babfc236942000b23b1fc72992513f6eb5a45466b9917d88a2a791114255281799b28d996c666afc1a23e8f6c5e8fcc7731589386c553debbd044d872640a3ac9882d34ec7487b74f204c1773326eda1aaddbf6c81ddb7be23b8b53c32b42a5a52fb2c38d1f09aacf00b2c64b50c249aa1a2f398d1925cc24acb6bfd8bd3429554d86acf9d3bdcca10ed44c4a3bb3593d9d8389d5758275535f8f4c0deab83048899037f5bb64c53ab64cbba749d792d72abbb01911643d27d09650c477c2e3dd218d37095b8d5a8fd0e884d0317f8c4d15b029cfee191209081fac4f18a203f8d261ad0b574040122bb11a59b9604a4097dfd40259ad42a2f8f6ccf2c5199959befb1c8001febff92b5fb479f8d04bc258cfe89cf86ad2c14fed44cb46e25a14e1add26e21839e96e39e76134933ff19b1245cacf2d7b761cbd4faed60511c3bb23ec945d0196d08a4e8e1016ca0b9122635e28ece154182fd5bc12c1d54dbbff5205fe001bdf7cb530d34d6e2c6b443101e64a95ffa825d929141a108705c560443ec74782e6e9a9f740c7dd2a8637f6fda7fab2aec53848e067914dfdb2bcd024a36d57c01820a2aece2b2b8f00d9ab9430807f2e0e173938fcb2c3bddc84cdb2ae0514a6007a9b4caff1070e5bac5de5e89f09102606f6c19524466fda16c3bc7b0d13e58afb329284684826e9c05f1b4b6c3bcb8a1f82d2fa98111a0e44acc3591f9f358d9885d9840b485c4414c1aa6e53f7729575ea66845b668f215d7dfdf65842af1d00a6a4c31468b84f7145e8e3aedd246bd5e983a0f89be654c147f23f8b71389c4653e4badc5d5902007e8daa1e61f8aef3f9bedcc5fbce90bcb5c167019b58a7e814bfc2e6d07a7acbf6148b3ad3831a2fc0364ffc0a1cbb7d23c5e93ad4a81a785d3bfa3c054d053eb7ca5c1c78605a2261265e0f7985cdea11b336e2ff0f6c27f54314f6a9ef34109f0deb151abd90361839935c2764e552979e5405a8f54b89cb1467dfc2cb9d9e2e3149391e9336840f8db533f79b7bf4020cd8ce5704af6ecb263bd829c77a09c5fc882b80e0604aab62dfdcd1bb1beb679e9526ce0fa7eb4e3519597fad18e643fa36e4b2ad0576897a37bf5213a8dccdb162d4c5c486c3240382808640bc06c134bd9eafb8555086dc0e7a0769451106a120a582df3248042a80972da83161ddb23db0ebd50d2b3a35c6957fbac751a096ee852bc29aad758a1afd294c72fde736654a1faa4d5ba5483d90274feef0dae4536d5510e14991aaf4164aabc4643853c85ee8031dc1f23b8aad870db988fb81ece807dc1fa39e9cfceda0077652b5e6abac2a9b667eabbe823d3d16b13afa4ad8e969d16759fcf1debd4b35ddf03076f563a23ed678e63b9dd327ff843324dbe358a98629b597cebbe1190f88306e7d293b2158159bd40ccc3712803a17c6bef08a63f2ad360bd645dcb8218d4883c0cab0c928d605802d873d66c5f6cfdfbef02ee7d12215479e21cfb6131ac2734235e0371e91d8de82c882dc397b1c967f01047bde526feee07ff52a5ad9e965d7f907e52564da2aa2b5f3c5c06d948db21efca8e3778063d1d91d04d77456f1b3051d39125d0c5de0892186a199ad88c7d0afa599c80e10756254072e2062b03198fcd7f2dabe5540b46ea2c19a6c64ec5a749dc93ddeed53d600d78a756ec0546a9f6551b0d6468b65872f684274d915aaf7992ccea7d60a7b00ae51e143f1fe8574177297830a27811b7725a3e07b561fceb884543a8fdf70f55ead935060aa5e862f044cd3a270990e96962a7e6051c51e5746dfc1f65b7b7b997ed6f12802020b1d22e0712805cca37370b61ac7482f368e2ddae17289b0c191251c2b1d67ae8ebd692c4d27d319d3e5d7f9fa20d28597fd30eacebae7f80ba3a43b417c62507661041ebda89c334287c84595251ddeb6bb079b8c722d418937e8078857e7b5fbc5976a44c46a5e1b967c901fafa442f42338196882d1586d2dc0b29c1bcde667efb2c81b3b0238ca0b5c20d718a7b8bcd25892e3455c257a755a1e256477a3a1a50ea9bb7aa070cd2a3197e6f8b9d0af0590a06b9e5c4bbdd74cbff56462f46a60d3ecfa54c3fe9433fa7ec77b72c26b6135664036593ef32b063df6c531b83623c8fbab8c10e6df3a696f22678c69127bddc44aa1096103cb8e6b3154929e66b6675260ae870cc9ec1c468baee285d90b932033f1964afcd5885443748c18e4c0cabdc35002ada278c87b03d051ab30569c6f705c3e778535a93aff851918f6874cb81b83753d3c6cbaa7b12c47f799e0b61cc29c1aa482eba4a7ce56b8d1396b90b2ceb27edeaf558f763308e2a7668bc9ffc961eb866f1168cb0651402cbd32740f8c9a29e52b51a760e67b8989dd432a5098d412cf677a529d7fb844db58b12e55c5b6f9f3201c378e12353e3e192975610753e15e9c0068994171d8b2d8e80a9cdb7fd0e51d67764231d2a31c7222b216ddf059a471bec2b59ab45c3c8fd8995afa9142bd440831828ae80e328eb4c3da414c5fca69177f68eaa940bfc41b8d0e071b8e260fd0d99689e336d28af7e10a779c60f7919ea6d1b58f60af5e6e58b1648ba925c22bf90a0773b26989397c7038826ff6767f5a909809a83c902c39ed972c9af085ea2172d2815d19d11d7f0f9956677ea0afe15ece2dd6f10f292b69673935b249dc679904b5286669c2e1d17dcd08a6f36b2a2ca4c4fe97aa972ab6857b2a30076bc3dfa8b21f2081df579d23368b02464ac4505e9fc7047f315054b482450336af984974c58d83ef4f330df3798c7b81956330d8bf242c9e3abac16fd878af1107dc07b0a62ea4824af0ca0db20b78d2f310a199b24adb2402c58e021b08ed4201d0c18ef21997929802be7a71198c2c5a75f92ee8272326ceaf343d1a95b960a17f036714aa05ecc03e851e702590d6facc83e722de3b74eb3035d1313529d6ddc785036c823af543fb7e8ece5f5adc057151a53079f130fe7a6462ea098c9a566681f4146e6400f6d9ef53c62f040dcc47362881f1e3e8bed617564a4abea99767d23968ef0bd6e88d2510747ae260d1d72aaa9e07c2174f36589debf33c522eed4367c4ad8b251bded7d5b445d13f7837a01b5a2d78243c249f027ae822b18d04c4ce0b63a43ed15f5346ae2ec2183d44cf9022aae84101222bd5b4658599eff1ee86063fb0608c29384f13647cbe6011571be50fe543108cc57b7ebc080d1f7cdcd8d760ac436537a87a8ab2652e46100786cf70cbea62b55a2b887f8f860ad34b3baa0ccd066887805dc6794fa43f82047fbf16270a8c2dbeb1fa1626ef92c798860da5fdbe43a8adcf853e98b23f691b23995796b2ebcc0f2ec5b8f2befd62adb094a4c7a47e88dde2d6b504b99c3c361c9682fb30bbb282c018086a16b9984bba71eb44ee34008883682d016baa66721a39071e11b9838c79f4bf0450a792b20c2cfa2c677ad647cb372d8fee2dd555741af6ccbac9ef7739d35dc63d28efd82322f020912ad5d49ca95eac6ff5a8143cee2b155151dbe70e332d580fe126179d60de16ffb1fc0da38effe7a4f41ad678af21c03c9a06ffb5e1e30df0eebb9b9cefaeb29ca811e4cd05faca882941f9dcf4e354b8d62a900844be99ce7e5a76211f13315fe81c2f7ad7d170c0ea3303a1f0e369f927643cdc41f31f4897c84d49fa8dac7035f34443d8915e04b0e16547a355752c98e4b6266b175107026709ecc34758f9f786464527cae7b19596b499de925ab1345f96610da31f06b18be105e9f9b576dc5892c4288b43ce7b95f1a78dd65b22b1eb01f9fe7f5d1b4c5d892bc89f30266a04c3e0e5b425cde259e1cec9f82cd239460827c1a4073b046e580f0f845186e234122cff76cd4906cdf888c7e7ab2e2c9d90f45a0c9a4d8fbc74cac46739f5dec8c7a306a5925eed7b30832e367fedca276c116782a38d971484d97080ad5017bdc69a56e512331e113fff5ab2876cb31443117ae58ac3d5041bee298fce9828c322aca89f8acfc391f0072fef09ee975ff2eb11d946dbf7e8741706a7bcd6a4ee5e20887f31ea4fdffccf771401ef915be1552579d67d8a994a5021bf3c3f9c3b6547dcb4484df7ebe710eda668a8118cea90e1702e9793d3db03155659e7037942f0deda988ae4fd4e3d06659c5bd5e7a76d2a5005137649984d7079fea676b1a884a5416a20dbad8ef9267089f07e3a29f9c5b9fa713123e6d5bb328bbfcb61ec3b0f1f56a383fe210acc18d047f19b2b19732909a96d32046255d998485d991cba0ee1c4631727e3bb528945e8597f9243b60efface80eddd843d781ba9b65e9059ed23eac677a5ed8ff85db352ef14e2f4477d30f2bdf4430b672887a4561ec2666221ca5e7f7c17461a25864d7d6c4475ac87b21df95a98fa3f13343b39814613887603a2c4a13577f8cad0b945bb804a33c101adc7132507edc1a5329bc44575146c928cb13033a32466ddff0da5b22b1f0e7b7042bfbb9992bc34ae80b276db11ef745f6013991589d538b1bef99b8eb0bfd5fd3cf05f88afd33dfe09fe7c7c27c289d2141b034c8ced8a19cda3eabb681126e89bec2b7c14981e511ad878d5af66c59eb7c6101200853ab1c6caaf816655679581435d0194a2b2c61b7bc45b171e35e6a3c85c561d2bad5ddf5a90c2ff8deec0fb6ca4f96cf87dd679e7f2c4b2b50a7459baeb0ec369fbb2047776e03aeecbb2128939abd7939f61fdb8460a8705bd61f0b67e1fbbad8dbd9b03716cb3347534daa1227513a8a6f3eeb966549cd5398fd9df344bbc1ff56ada4b9c7a83c4b565b3d520f18974d26fef208bf07cb242e6e9ee0335cf265decf844d7b12f29f81c4ed4e6681e68fc5f0cee296a09242f434662c76da9839e34a164cc038b30f7abcf9107b124756dbc23ada4daad5d1e420c930374c9ad15bf22ddef667c65d1dd1997993625f6d0b9f9281d2026e02778e2cbccf998e720ac7ea86fe18004f6d039c311bde1a9d66acc1c2cdb54ce0e15f01ab54464dae2235ff5dc11bf9693ce172bcd7126e4a22e71314f659801c9d2e213fd6680ce2ff71341267dab5823dc7a8339a8f2a23cda9902aa72fb5c2a6acc92415385a9db5d01f8b0b0d232bb637e8d2872e37003d720350633478e453e5d5bf9d385c205ff1885f070f5ca409c81a72a64a5d66c41e3f3e3ae9cd9499dbc61ce0a8536213c5623f9e856e2dcc8f1a8da1ebb873707fc190dc7ad4e5ea749863a2fa9c1282db15566c95ad0e703922c628a0773e5329527ea16c2445ad79507627e1bdb73e39b705e4bdf33a6689178268e99bb77a5da38e1ffd177274e961057f031bbcea501580e26706a1db4c4036d179051223a93625353d0267b0d44172f41f4c32fb1c89fba2ed0b2b7213a840b2095a105571b69e6f843dd63a9a8c3ed7cea14767efcde8986af5fafa045b153af053d672904365a2fceb73d1993a7355a73963906c00d69fde8dfabbe9e1068b03f04e01dd140f35954866c3c6385ab3752d890e7196e163ef61b9bc398b09e2d0b20180db972e2694b2e8ac8d1daae068dc70c764227b117ced69ca99b6836a9a85f673c2faee3dcdc1d255fb44b04279b764d264f7ac1372c6f06bfac43c7c155da180ddc8a061cd7bfb880a2c429451ba8db8e1c36f345e24e50edf2209904f364f939ed229be6fc85c6dffaba7ad70df90457d60be79a57e2eaf5b6df67d4a9f04e01fc170c2496907b9156978b767d852b42ca906dea400ea3474a6accf2d7baddb4a803814e6d92544966b7fb683266cc895aaed62612400b87b89caae21df5bfddb9d8b37e485d6312ea25e943565a3a088fc221859ee1791e285054cd84d04337c5d1a46938212dc3370031c0d2d896f1d9795489917efd7c8ffb0810afc26cb927309d1a2d2b161834765fd0ac16b7e239c7dc5067563d1f8f89899bf1da73d6813eaeba97c23f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
