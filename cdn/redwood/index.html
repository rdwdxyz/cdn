<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94896869b82d9a13eaf762e44e58ce64976c0ea5a22f9e1b5f488b41bf5ba55bcc4d72f9c97bff2e74330ab02a9ddf0e43d991a08b6d84a69cb0439379cd0e3da5fa5d0fb62064ce959a1bb8825df50ae1f59c81a43e0ecda09df22a8607f49c3edfa574c48d52316aa672288070f60089244b0211d6e480f5b2944899b81bee35919bab953855ec1fa6ee9c7b535ad5d6941743e9fee9397e8ddf137e76df8635f1dff62c7b6a102330f78e49dd70f2a8d7ef05379a96db6ef972fbbafa795ba3c72402e37aea160c93ef2d4f9a2a46ac3cc275715f20c8cf7654cf9e3a7564e08adb0b00cbdfad70f3ff6f8552f0ee4f6d74c2639e476b74df60f97c4ba33b79049fe5706e52f15727ab5f1c8733f5d07aa3925a987837d6ffb1447921efec2b92374e4ac27f1e4105f8cf6659ce54e7fadb27973f502f5d46bb9481563a7b6b20177a9f6e9f401b123b8b1c8127330f885fb9d4c38b2b24501d6bdf7e8f70a24d8449ba7c821a7b09dad9aada187132c1d0e848f3bafec871c6f66f3a98cbbfb15efe9e48266284e92674076f3d5b44af7fb9f8b301934e84652207bba586f23f012eca3cee3c2a6d71ec7a612ddac71002f3b42b88d7ec447bfb2b75dbbb75f3a8a2b1ec19f7af76af61899f18e5a62a50938ef4eae7f14c8ee74a7bb3d2eaebd40c377226b9436adddccd5a553e2a74af389efd8f1deace4cc75576c07dc3576acc75cee8d9d6593a49c733bd10692a6dc94efaa5a6472ff198d1ee9135319ce40225b36fb7c938fa31a90f445a8a220b7c65af309b5e00b18a0ed489c47cc33a43ec7c27179e3735827511970124c030c7188a406a78e9260fc4a1d27fdd2a0f13c1a0d49eb8a6eb3208822fd65b0e653543740bde3eb8feb63c607e8111a6ab6aab13b2cd3e78f3499d9d402f1dfbd794aad9ba1b3bca56e7dfa221f12c5b063913d81e760066c9aae29bba80f5856160560a8fd54466b31228422bfd3256582b95ebc961c9133273df4da0dff1d95fff6c816ede327c6afe24b4ff9fbb168ec15c6f92541397c37154bf0d82c80ad423e24a10c0dd6727027e26db5b738aa562ade6e748252fdfbcf881a134343c7f4b243f7a28af16391f66b1ab577ac29687a81698e95c3da101cbcdf37f0a4e748991da6a4c4ed019c9fb145d86a85cbd8ad1740f2cf6d00975cfb826ecb1b52f720268c928107c808808ce313a7673345895b575f24b977311fc233e2860a1443f1b8264fea0b6350a28cc434482c85aabba8f065d5ba9b5f4b9a2a342feb3416355cc89ce1209b5389304268fd69f3aa7055b7db7fb718bdfea18a53c4345d26f19880ee83324c523f3080005b09a34cb6a3ea67454315673ad7e350e3d97f4b4d67828d6fd812ee23b383e20e07d518db8078a00f1fde0c4be3558ad8fa88edda41b8affcb16e6770ed932aa93ac58894094110724d12cb2cbc832a9451a9310b3df69d720584bed9fb84be22ef71e029ca0845326d83f87dbf0cf91c702e96ba0ade3f2cbb5dae624244577c822bd469e67b4b3b8c29286afe6f5d1bcc89527a9ade7a42ef0b6f2a9c4c2e2f6622988a37d6e0643e9060f0227dbb5046b72731b12a7ab19f2e353770e937f4b85d2b2bfd011927899bc0a1dff3b3944efc26dca9aa34c33dbf9bd915781872afa727dc3646d3e41085953b4278f830eb6820b4fe13c84a4b4e3751c3c6cb1a19f0ab47faba25a59b81f106d22ddd958699ac3d4ae8e9e993d7449f90cd691db0b404e2bd412a75d8ef9e3830c5963d947198cfa92b3b269ca68b6684bed956a5e74f58051018cb252702ab4e54840ca3538c14fd69e6ecc4606dcb19fad699942f30028e94da7315e8f4179e8ac9c808bbcf664d867142521aca3e04d81d8916fe1bade67c13af2da5e607213c1ac2125b3664c0323b06646658df039a9982cfd159633800a76cd1d5bb0d6900ffd7da9998dbb88391da50e8e2279173f0f173e3a31f56f1de059021d100e045a7c334feaf6c0071fd37936cdca4289972d8d05cea992f0fefa8f7226d07b697a49694e32f0cc232feb64424a19958884052aa5de61ae70c66060023f7a66fa87faae7e33144e6b1d79aa8edb58221cc64ab7a07c7c53dbfa54456b90d512fa7e7a64878ec590e57acfec60c95bbc1e2eaaf70317c43007a53672bae87282a0b63987d106dfb4927a9fc4cf29c9370518241fd590911af58f2e6187b6654bb69d8e9782a516344f9e6edf714230c5314068f09b6477afb34ed4f9d9fe21a992ea69a84846463ee8ef5833e52cec1d36df82a231dcfc5c4c928442f683d54c2815979c46dd5fb98bc4647935e96a9f804d025654b8b312f12a86e7475e3dca66752ea9b72487d45f1e3f1f7d0f5492dc6eccada51b26b0dac68f446a92e4a67fbd32e0b33bea0e04ad7af6897ff70fd19dfd740cf7a6efb25c6371bf0bed99b05ff45336d7b50c6104edffa8fdcb5609158d32f0052fe16c75fce1ac7672373a179eefb253459cef56b089395632b5ad67416e6354f942533a9838ebb02e5df3833170164556d6e5aaf7b2c8ce6dd6b8a4c7dad4a37db3fbcbd1473c00ed0f530a9cbfbcd0db356ab58302ebfd442d9e71177ab143524cf1515c209a8bc3a64cead4a476d96c3c4a918a773ad73409f79a35846b2bab0fdf44a1aeab2f4711ad5553d027d10208ee6b0a84f668a799b0e3f331368aa9f7c5b342c2d325029e6590fa2ee13d5213fa3306119e5d6501b42a8bee2a48e10d8dc8c852a85cd9ba9a0e6db5d632ca42fa99fcca55a03b24d99e047098c1abf21e0bb3c279a2fcd85242b6f64d4101bb76a7223ee23bf437de1b62c75e270ed55e0f665cfc83669b6049ac005b4b62d04ff4fd851519b70b9acf0bd3d2470d04c123a42a64bf8d1ae1f4ac7f42078e5319e62dfc10e69bf80c12fce9c276a609efd892b202f56cd9339ba714366de1687df7082f41769473dfd6542857e663f22a435164c8371bfabf416bcf0e64614bb470a8e2d1aa83e421c6ada24d49acc4d64c51fb69e56ec2fdbfe4934a008c0946a9cd244bf9b4a157ac1939896ebba46873ccb5c3b4f64eb71185b7b75f6bd8ee1db231d446b053f18c7ee0cdb27cc06534e9785d1b4d07b2f82fe03748b52159d5ebb47d862b274b775da3b5081b1fa08f9917802bc24b7cb54f689e7fc03bec25e573605fef10921408d433746356cc4046d672e7ccf8a202a4cde0a9caa45ad50f54c0adf0141edc304b67db136a19b39824ad9372227b2428c280e0154a5b674f67babe2f3130e7f0e1a80c260ddf2aabed83fa6a297ec2810bb3a1d2d895e979aa6e02ea33d703ce029276b13fbffb235a5c9fd5e0ab44d7ca7a1e8f2761b98a9d09036973fc98da835070031fcc8cc9711c0479ce7630ed15c0e3f5dde837c83d9ca7108b2a89e1397bedf03804daddec312dbbd62f22e345a65e0a1904ba33e3954152b5d4e6722e8ef7f21849abff4c9d818663fa359d15cb77ab506bba09cc0598afa3d2ed2ae1a5462ff8a54675908e94ff63cff017545659c461130e546328ae2f135819d4c415ae629788a6f698930c795f5735d622486d8d801f2fbdcb6bfe0b9ebb40f4a4be855a7f7a28c4da4aa3889b09f39d84e501e697470b6912681309fe1a965cf57774a3e1900a2c2aac7df4a2958468760622e5b21309003e44ed13e10ff45d5a0c11e3a51e1160071e03b2d6877564db267adedc5d5fa40cbc3a5c1a161fc7cc90d953984324b3aca29c3e80be404cc3a457970be6c89842dce2acfde0c6bf5452f6b7b48975b5190fa4f8a306f8d242f62c8a55d6363fe9ea2922184f88ebd911bea2fdb1d9e97522b857a153cc33ba23e999a0b87b86a73532f7b7ab3f1b78295991234b79cf5ca7e1ec65c988e886f8924be0f16d9c1465b2456a8e34a42339fbfc94aab066f5f018474cf141363fddfcacffa43ad674b7a54fe56f2053f43261273fcbb8ff1db357f731ef194069f9e212efddfcb972a8aaade3c8b7dcd921956804bfcbfa3bd64af4ba745976f3fd1b4bbd60c7085d290d16c945344fe2353de2f8303776dcaa64acfc0732bd00d131b87f9b9cdb19646184957b802840a4df5a24e6e45771196596792e585032e094fcbc1619bdcf7ac44965ee1924b79c18a7f7451ef9617ec135150e22a4159652f9298b3dec9593371f50430355f29d0887c2f41ab8e8ed5a1a0cb6be814fab0fa1ce9faf705d47e2f7ac0381d16c06ded90962bf90cba2796b3ff44990533d7448b99d6414202ee70f14f20e0781f71fec374f4c90b69253971346d2227ed516db86601b2ada4dcaab623959303f9012e98ecc753b1ea2d154af371d1c9db1eb51b0c207169261e7459328db36f4502bfb39ed2a7d6e5691e9f24db570ec43e94aced84c6a9fcfe2fd6abe7157f1234045f63537571f349394b8da5111ace53a7b4f544882303b44492e379c67a1f17f30da480a81805ce693df374a6fa6a685482fff9e4974af8cb4b31180f3fb3d3b7abe2d4680d5403939bf44cddff9ae94d8eb8f988d588565534fcd5a41b67f0526cd1dd0e4d94f3a41111ff6e2ac6fd7a780aec111d37a720c21f366296737d6a5ddfd572a6ec38d15f6c3f531356ff890de397585650cad3c2b859fcea0a2e399e9ef64f6a720a2967c1b97dc20200dc570bbe4b9dbbd88c9e2406ee65c95b5551e01a67c7386c2f66f597a310f7dd2f59d0658663a4600497a0efb489f22c02e8ed3a033566cccb6bffb8060f43cc72484030001cdf7da3cb90ede3afd0db9d116cc5ae1aa4a15ad2dd3ad8e84713bfa10718dc1c25dca713023d45518f4872a07aec19dc1a774f414b17e86c5f4020abd10e455fafed35a571b1b1f9abf074811b14a5f03eec349306a63c19e2e8b569ae2442aa54f472501c495f2e566a58af10a31340e625fdad3d94ace0d1398efbfba628314ef17cc44d3c4eafbd8d5155c88bdf597d05daa8d486a33d1a9df5f7a7d506b91b460fc7e68320abec332bed273197e8b59ceb068780a1d7d40a40330ef1347a0bf3f5fead22f7cc6222400a4fb4c43799600f8ea92c795e834c278567558cb279f332708470743b28438be1a2b499ff27e1f49b2e427bd5694bb09af4f6c4e18f9c0df32dce58af0aaabcbbbe9f58bf0c13a9100d2557955adf45b58aa76a0507d4fdcfe3eec720a379d4a8215777e274016deaab43dc59834280e6e57e93e757480a30247d0cc5c476c9f1cd02ae4c536797a016785ac5c970f4d14c8f0593d6924942ede3f1ab19382ae5f6cf7980d7c881b56825dcdb8888c545d589bc372a7203f14dc7c79ce70f97bad60d10246a5f32cd708d5c0246437a50451b98e18774d034344d4e5b1c140e92d12c0e3c3fc0ad8daa266c9cae6b0b3c7a41e450b99ab22a4890d2ae4085c59827bbf075dacbb221b523ea546ba2ca9280766cd36c7fd6fe6a83c3b5232a1da8abeb0f0bdaf393ed2df29eff57508078b084985087c91af495d0bc54ea6c870bce4a2eec1be3392cd2f10536c550b644a70bfedf25c44255cc914d5d74f15508a4acc79f789c68d4898e01ffe7ccbb62640444854a62a3a5d1156355d4ae6088c8f2a8011b17ef0cd13dd1d68e2155312a5c4fe6e119f78b8b69e26a4a0985bb4c0911962829462e4e65faba4326e6bb7785e4d148c8e613804a914650029454489d1649bcd2bfec6c63dd744c3fabc0f8a334d4ce7b3fd0d2209f074ea9fdf657e3ae619fa9f417d04be19f537b0e33887b899bfde1e53d95d92970fad7497d4815d4ceb4272ebb665b6d5906d9cfee014f7c57cb6d704e12dcb188d9e6170f311c0b7f18d5212f76a199aeaaa9577f2f3d5eda406604eeb913c1865dd76425d5d8427b7923a9d6d91407312f4d25b9b785a0dc0bd45ef9d9ff636ed4e9c98ae409b76a0e325616e6267675a0fff509873c375866dad8b44a2c609cd88bdf3d5d1c4c415f4e32be24061e24ea2973073b4c23ebf271b44f3d0696a32743aaaf95553c782b2d31e638677a54d299ac18d61890777eeb73b85ac41dd9f1e819c8584e7264f93c6ce64421ef89db6e4897f79603b0adac6451af53c71cd267725b2b10fba6cc6bc1438c4668ecde12b3aa5104f931da05457c52b5825052c4886e1faa9fe3929f3305e18a7f7ba2cb8e68f0e36c422d70ae1003b63a5020b273f8dc558693ab09ee96d8d763770072bbbfd837a69e855b73c1b220c2e554551c88cc1ad6851dcf9a769c237988260e5604a357acde0081e84875851fc6a7452d15868411f6c9c65203441185aea673e7bb0bf29d9dd3abd2aec33e811c7ab5c1b4920f831040572439910f0cebcfff18f526a1b66a7087f2742b28efcfafcefa38243dc90cf43d8e31eddba7dec40653c1ea10fead7fc2e2c58e34b204be2efee1e341b654e770e5121e22628cbdac655357620393ae52f7363b7d0ddfcf1829d991b260b2bd39e0a8411327749209309c186961db6df119074d4e88dc8af7b2ef82ea2d6f061bc2d12c414f0982e5539a583e3b1ac8d5ad9496ab14800528c2368e23ce6e12bddad5bfa1ddd8e4a218e51db5f7d515e11485277a8976d25a7fd3dd9fae49dab54d95760bb971d6b53e4a9228510b026e4e1a9f5f02a3dfb7dab4e01d2cc091a7b0297254215dc6b2ffa56804f4ecf3cd3146e7ac078289b0ed3b2b658b2b34c8cae30cef83280aa51ce8909cb69e3c9d3f2c5fe710622a4af883d8d86d753529f8f31998db06b65456d9835b06da18c6adbfa2915b43a9f689ce826f92bf63cb86ad62295a23a86f543cafacd03cf3e9d76d3d5959ac72cd89781d983a571177636fe29b2065828b542372534645b988759507ab888e466c331abcd463b8c91460d0a5aa7079bf9a060e2907721f7be94f72c0d8d93ac2cdc61f77d4257783c918328b95fa5ff62545f651fd6fd28c1b2811afbecb9f41314918c3401d7f6d2bf5d40493260685a18f30385fb3135de08aeba16350cfa1c3b560b13d55792c6854ca090b7ff08f91117b287ea40b4ad3618aa882d3478c30c6152d384ce90dbf91a55fe9bd7daac1b18034384ffd110a2a1489f5c74036d5885579923add7b37a500bc06c2346a69d5e3b99c9ed48d35ca22d4dc0e11ffd09e87f6f3d040a0c637c1d389b01aea5c8b9e632c2bd29a79634001a0d2becdbb38a2770e7fd562da0123f9c63025f62044205f94528241a432ec07a872ed2093632e11fad273130191d2b716567fa79d7ab75710c5e26284e49d079357fdc31884ffaab47144789ad3d8c557b03e097a5ac385f378dc26e0c9ee332639c3c8e8febf6d627abad2cae9aa62075e6922188bf94a7d0385c6d9f371ebbbb139f85de382754bc18817e2b529a0229cc33f7767e39099cf25fbc4ef0e0a577ea55ddc2cc28c13f581b8b9345ce54b68a794f0390c7282a3ff2b95c3371fa27dbee88102defac99249b5b36976254dd682ad1105bad260329a59493690beb7fc04e7b0ae5dffdc02995c631ba143c5d18c774f9861b3c699623be65293841562719aa7b6611b446a7220ba627c0453e1503d050b6d7235a5ad27dae13efe8ad4ae40220d10c545fca8b46cb1b546ce80ec9c32b0cf5c985e0557d8ec18793112f7fe32318f04b0329521664f97b7d1ea56647a71dce49a988e04f8315f2cb93ad6154da4a335c72a8f0069c7b6f4b947545a1e404c1992237ffc49bf24cffda5a7bb9f968642f0de74a55c0fb9733509da5bd126e0d36785808bca66ed02ad729aafe62c9acd142d5f8091d901505a9217cfc959469b2f03b666df2dbe1adc86ff94d3de9b355defaf03ab8912099c3dcfe2d38fc9d840e18b9d7a70e9272f1e34bdb3444f7b43ae86dd60da8450b70920d58b3c75f191dbadcd1c88613b678a53ec223962907b203acbe080e5a1dda3c64248bbd173f9d28e95ffdbed8a435459a8c72c9ed162be66ab0cb65b1c2d5bcebd433b31ba8a8b98483b912185d6e788cb54999328d2b543315bac044bd071c418b8428fd6708bf3ec5653b376ce62d7a2bc865e09162cd2cdb4d9f3847a5513676c5b64027b91eea91914f91580892f337c661f48c1fd533d731fbdd80356249aa33bd02a8f463d7b6d554dd278af6e7c99c688af5e6aaf2055acb7839b4106057f7175663316c75e12f24cd998b1c58a46c6369012b9ba6903621438e940f75eb788a087b946e4433404eae5d8a04db84ef83e366f17f66cd86356ca31867f55367391cfa0fe420dd0520fcad4ed4f06a3d729e6c8cdd47b7e5eaba9f21e0bb3a775552c1ae4c78bf61f81bf8bc65c23bf40f7bacc3e34ac04266b763111faaaaf6c78072117915bd417eccbf4d25d436e53db434fa6ef934a244f962a7644973da5f2b5c56131c5699d68d8db63d947084d0508a7689fac5174cbc1967720596e8784038a89a08e4bf04b5e7ae35ae71c1258b83ec950624bb9aa4eb9f7fa1ec193b040ae67e00896dd26400dca14640d313fec1452435b59a70950385dbea5821e95ea3cf44779ab2e3bbd4dd1e6a4827c0ae45056b5c9dd24d04121b7dc9a3e2af8d20ca25d4fa9b011af75ca50129721a6905c5ad7bd9c0777a00a27dd7c30df6f16acebb5e9f9b561620bdfb269dfbdbc846ab12f17e51b9274a6c2ec8549d87becec72c846524271bb7a005985f9fc7f120b27e30d10793f0ff00bbdbd6a36b5e063cb867e3def184de2ebe89da1d4c70bd7c57e3dd88f6b011ee2556492a2c9d539ad8dacc5f4e02eaebda3b01764e64a28bb6af9fc5137046a6674f564bfe0aa11c15a572e0e4887fdf0a8aafe4da29568ee56df2d044cb78867b516b9565faf087ac5f0f2f856fcc2c19c7dab7f1d38341131493a3866ced0a2683458b43299e450eb66eeae3482a8681f63f08b10db3d33fd845a2986e139e9a54327952531060a67e1afbc2c2cb9ce3f45286f284ce8afdd04ce5c6e6ca9932a749c6b282e673545e88f3d3fe08a60565f1842b2592da048f9923afc0581d5b5a2a8c7c831ce8da1931912b9148a176b451d5bcab90e59cd136163bdb6ac5ff164e7bec6aafb80eb3f100a67299cb6cf795fca86ec7b65602b478b2a8e11a83a7bde994660c7f326b6e3c1fb8e392e6d580e513b10566e431cbfa5559698d441466e35fdc98d7e05a735dd0e9c24d639878dde8ecf8fe8268c04508a25ee2af55d565f68ad08045d336f376eb7b98f433d252370f7b64c6b76531416fcfa22d44c8b75562d9a38f1fb8e036325bb2c136b49e9ddcb2f624a08d25258dbed255264d99f035bd1f0c01bdd4df35e1378ac777ebc6b4d255ebf29953107254d776476e2407d6ed286b0ed23b4768ea80d89c33a2182863923b855a91f47163dd1bfd481ad880bad8a0b5af9c21d3bd1ff0d056e99bcf3fbcff137850f76dea1fecc05fe824be4eb4b54597e54251282cd046517343f4265921e93238586dd94c46aa5acd8ae4d49520949faa2ea9f2e9071c69090346cd62996823be4005af39de07a9de326971ed18318673dfec76dd7ac66c27651539a22f13b16a75a9be78f82620da7b44e4a51a6025e70669748d33912abc4c877713468347b5b6b96c99b4514096360a49c0bccba92cd37a6141625341fb94905d9e71ef2b50955d99948cfa078640dbe38df8e15bbad0c7f4503565777cb32905ca320eff9d4e6644abe9a4889056f64e485a7750adf0ed88865b3d65e6762d951481eb13f91c349877afc5b6474bf70259e15c2b1694d962354ed9babebc47979ac47158839d51df486952df70c43f228d29aedfe807f5cf4ab63e2fcece741478a181ed84dacd4096b55548593bccecfbca31154d65c03b0fa92f4719a280cb4522df6cb7e09de521068ff59b9ee1bee7228c72ccb8fb9b69329fc2e3593ecf26d94c3435148a061b06337c819c6f5470c94d09b9cb9004bf204e4a3a000ba1382cbaced30f83687ee9641631d1d327cc793af15309da74bb781ea3f0098323f04822d93c9aab1441902e69b488f93d45d54c33609391c2e7ae503b4ed29691f83a3a36805509840d22bac55aa2643542225eb7647c403b833c86971185dd27309088fab9c45b09d6b300c88cf1a25e4b94a2edaa133e488d27a3ef03053e44892e245a641c6fff0e4ec2e50f0a3fa904d37c5dfc0ac7eed58bd2f07ebbf2cb5e69abecc8c414ffa3b46e925b6ab8002969054ab6afa8b1d849be0e367cdda794e5816f671c5e68a9074552f2e7364e8be2d8b0832cc85d5d0b5fb7920e276a01dadf16233b77d4555a6dc133bc1b8ef3bae0ba49f124a05fa27190cb547e26bcdffc78117cb638a9cc77729bab90a73c4127b008ee2ae73d12958ebd3e2d010dfb0db4820e264a95c388b3a720f4bc5733e9412bb6ef854870e29b881ee0663c7e910fb8ccb2ca808b45ed557d08632cd9cfd627b4bd03fdd7834d798fac28b9277a3966b77549fd4a9eb0eb30bf6c80ba453f36f5140adfb5ec8e265fe4bd5f432809c0193aafcf3c69721899fd37b52d2829205ac37526baae0405e3f67d9358ded732e7baa9a9490c7d36aab42c3b337e61f351e6d9702d8bdd0fa7711fbbd2ed4c9559837796ed58ff5a34aaf3190e82a4886a4fda8b6668e32c455655d4e37b28bf0e99cdace4fa2340d2d82efccfd6801b054c1a3d473cc8d7273027f34efac02bef40cb26ab42f422c3f81e614d5a63d59b2c9b924985872775b4908878ec6b2465510b8c703138da5c5440b3c9f789930e8283d0fcbf35cb30828afdf954b70aa5301a6ef3e10303648b57c7f3396924ae597dacfa93ccca1d2ba923355bdac547765c0b0f0160cf127bc6901c7a6d1edabeea8648f3c473fb05219214566d7d29a726b2d2d3d186876f256f64addf1ba43a6f09d38e4c323d48127864fd5282bcd10ac291ab51c2cb5c551c34ec903ef1669bf970e3f6f7a03b862e45853be182a9abed5743e8d39afed6f49dea94cf5360687a519f5878ae4d3ea3f520050c81476c2c88bcdf7dbb6e269d222fd107e025214e82cdf19fabf1f8e736007a1cbae2b3046352b2837badf193c336c3fcb00f02e7dc7edb9afb6eb818a0144ce2c52e9753fe0d5331d36658617870c6a21848b2c7491c7731034f26f50ea1933dbf903f2a7b07477429291885e49526d893818e0c6300b834535128182323e13d42b1cc2c81d1ec9c7358740948e47ed46e2bab6276cf69a7a761621d0052df03d3303aa15483e6d1e5b66bd7aefb2012c5f02d004a794a5e8135d7628dadd34857fcb267e168da0df8a5a903f1040c88c5e96d94b828e8398474f9c2dc44d45d4d451e60156eccc22f7df0463df15b5708efaf77c27bdc0399bf5c66e11f8de19ab23e6dfa91d517c8af93b3aa86b80b8e9513a73666fe4cfb8e894763d33d0a1f9efda7cf34cf3c7ba09e2755f0215dadec8aa45f4f2f80b3be776e2bbd2a58ff18a36df6a2a65a03a1759a750f8584ead1752b12f4fb82360ea30853f4b6e53ceb1847fb5f7d2c59b6ecd5d23b52120723dbc8f0fa326d028ae973f645059f913060bce298a968f19a9c868da8e64a53075acce7d9e665f84a46c0e0c9bdf4769aceaab346b6e80699193d6dbe7d59181d3044735d69e314ecc3a2dc246633281652c4940769e600e9949723ccaeab61bd60cf26591335cb18b59fc692afe6df4fe3de866c5c566e3d63b36d96f4155709022ae059ad0c62151a881812cf67a1195792b7a73cdc3799a225511625bbd0879aa344d0161b65aed62ce1d5759869e5d68f69361f6f27d9c4b1453a045be8b5ab9d8cea7aaafa4cba9c57ba7ece6164e3439e659bfc889d1f6d381b25f2b31d545a02f9b3c9d9119450fe1d1d0dc719a0f3b0c15df6ceae9d68a50d72cb02e42d3c8a10e0ed6a2263c8e9c86beaee5d77be0ff19bc362e745bfb7fbb30b50205e060751a963bfcb5b6ba3a75fdfb309616dd065935c3faab082d42856339a31fe2f17d08d19495893260ad0133b133d28ff548f134a5e32f9e4d9c0a22d8da2530955d651866db61ca5726adb108033cef399dbfc5e3799a9e1db124af8318a0f73e085f14051edaf9dead06ca972b1846adc39282fda6f86b9d1759a4a611e8f71ea19f1990951d583b26160097498f39750333b326e5e679f0c413c6cabd57e083c1c7e8b326693dde53ed9796bf52d5896ac3d3a0ba1786e31c811dc1213b26fd4fb141529fc0743c59971fc3b37ce0b0e3e9e2c5099e94971801aea3ce0f6ab79bb4d34e306da223e480ce904e3b90ae8de77e7cb0b39600ddac58290f51e08341a1bf3f183b90d1816f4c7dc6bcfe774f4ef2cde0735b3db988112cbbc1a09d177cf178a19eb23d9e662d65e8585381cd2a3dcc6d2db9a9d7539c851a034b1fc9798c31f6ca04b0c773888ad4f8c6f178ca0e5ade6a180f6f547cd5e3628f92afecf59fcd8694d3112f43d5887aa75255b85155d37dc8bb317ccfc0647f7a31f7f3db9aaae833713de5ddf3aff7b09678aba7f62f508c72b48c77f6112feb00f154dc8ed41a919196aee23611985f58067e67f6ef23640da531b9c87f1f21b886350cd809a746752b74d8b49017dcf8c5514960ff72338a1bc0bc4561ef456ad8fe22b830f0af14bf7a078c5c3559afcb24da50ee240ead1ac44c3d640a3e62f7112732b04d1838ae61ad3088d69f8303a3ea5ce42dc91bfa0cb882fda81101e3e2acdd74d7eada0d3552ae5a27002856ab9c819cc90e19f4e6865974259ad81c2b5342caf4fd4f67784da1ff18c4f7613dd3a69c020d522de0fca6ed7753e83d3ebc700fe2bdba64a16e2e22493bbeea37a460aaf90807eaff71ff569fa99bfb34830ea59f4e224d0cba768022e28e181d7883458e9ed6f7c25db5ef6e5a20bbfdc0ffe1a39368fdf5d688c8aa98657a6389f20c9d330be15cc312e4a5cacb9c2f74b30ef135a26ee38e905d3c15a40c927b5ffd26d1a13c57109bb5365770107428f363b376aa71c7a23d345f7a257eb7aea7b596548246ae16ea042d55befc3afce5eb8a5b32bf653625e16996d24a8d7c6bb5b270cb6b3a5664556d7a80ea928055260a1abe3588e695887266e6dcd8c189facbc18ce8f8f65439123f470ba1a216101fdac8dcb791ac75d8978e686b4ab4d91fcc8fab3c4291362af1729346092c01ca08ae24943389bd72845c5e4e1d9feea5a770d08e438704e147d8025e63e0d418987c4a112916dc6ce4d1712a5a10d8a6dd016d407899b30ebeeedd91ad5c7dec87ff314affd95d91b87869a621962ad2f369ade2324c6f8dc461e7d8c94aff19682a196b4f862634ff0bfd961da5a48fd60b9428ce89740a00bec3baa22a48e2e0ca225da0375ae5f333ac19f47c33dc96c4c27973344564edbc177971fdfaf844ab703115b15e93280fa21fc261aa4d1961f7e238ae1cef02d9d5d1d992ffb1b48986162a3d625835f858c8badcbfa7f831c0ec682c31b1e9519d4fb524abaa9c6494dcc24a29305db8eb71a0c60cb53bff92de66ab6edd79d39cab5d3a45530981dc04d3fad5135095308ef6b76ad590b38e6f176d0d8e017a7488af24d6722c26d036a80a9ed02c1431a1b0b11d88307ed60e807a1c34e31d9f671d7353b9eca37dcfb707097325f7f96d734c9020fe3bfcb42848ab0cffdcc8d6cb1c1e1e4e6da63c66fe1d63ec22e73b96c5ff835d154f93959fc87263e3b5f239b9cbb346d4dbd6e97b540aa2c1c15663544563cdcb0bb0509a242795e1ec560e7d9516f3aeb142c791e424baff1526b546e2a6b478b2ac31351dcb01b3f64353e0c4679220c6ac930944d2673a3da78a698a7820b8d1cda04d1a3b4f952a12e745b93930ad5d4a2ddb3b85c354b9c89ebbfd97e9d2f10fe06d2e8e936bb93e3ce7d4627027dd145eca6e30168e87a00a338d885da92d292b4004e7cfc0e01a1424a75c37720acd01e82819eece41ad9279ca17a09fba0042f16069186f1b879d562a130f6bac9d863fd7d5174fac60c27ad0ebaa7a485977ec7ff071b89fa4cebc1503d3499d307a15dec99649d669548f7c4ee3602575af1ae782dd0283032509d0de82caf8c615fa8cf10ce922c75cca9399e8d6d2be372696c63b7cefe25323c77cfcedd7a900b14f464c54db85d4afa8389471c7b27b48868695d7cb09994dc2d965032bbc7a211d983697caf050f1c3e9c96ac6faabafb2967f2abd77e8358b2115a88c3edd1e38f0cf4c72e6e1bbf79da65c4a30db72add61355e249130a8d03cfd2ef616ec8fb1ccdd8ae569be3ee8a807f3a272260c3b1d5cb79d87ab0207d11edaf716ffbe4a936f17920a303e03cf2d62a9a77ee951d7cd328b14631058531b661b7e64f9902ba61f5e2aca0aac63e4e8157956d47497930f774646a506269264566eaadfeb6fb9c6685876dd1d45421af7cdc35fc46368d64bb90bca1919157afa9db0a13af4b8b9bd17b83fd427bb4cb1a2811e246ff678d79db17070b103eaf5e14464e5956c2a7b2fcf800129d07faf940db81897fc5264a2ff2442d4764e4f981dce06c38f5b6678a70af0ca19acb426bef155b549d277a51a5ddbd19f0049d11341a43e4878186dd838b7f8741d03f9a263122c20e920d6502389f7497f7cd17893da2d81ae82674ab4b39fc784976c7f99df7502a189d017d1b251d196b53cc46b1c0c7a1b9c8ad4d21fbb1d86ae89d09d9bfda39bcae19ec45212a323911d31b3ae68b23c0c2cbc4572fb7ffbcc32f54422a365a8b4fa54e307e1d84c1d1f74f3b0c3ad31f13088b0f9ea85aed4db5b4c325ba2baee3974a5265634b9bd8c2d7269683fb359f7c5c541821c628513d17b45828dba5a895c65e20d7f4c242838239ae6920f5bff4d182360574e0863a4deb3d0572b064b2e363325cf5cb8d793a2e897d9c2b9d6995d9ab1d36dbc732c2b6fe38945cc12d81e6cce8eb100db51563cf5e69d3fd1ad53ce1135d24afb5d935631d809ce47bf6690ace3824ce08507863d343aa773bdeff8520cd61c556c03ce445bb39927a84f3054bd8e34dc520f4441ae73d91a0b8414b2412decff4b57b153032e9fc97ca57a7203be68410f0b1f62560f3174997cd6c8ab18f7a301f46cf443681305aed3e85829a56a228e3731ff08911db08f7659441348a42f3e6720fcf48467a286495e6f78eb5d2f12ad6a874d158cad1f7b767d78b5de8e013fde42e164cdcd9cafca0453f69e463c3e8d51d8da2b26729216d6a5c55d84ef26dac531cf94135b799ddece18f4ee429bb133da63fa7f26c118fade77bda1a9bcc5b96743fa21b27143024c2e48c6ba67643e1fc6c23e7808320f2e2c8816bbd123b88cff8f829a51288705a1e90ee7d8c08203caabb0e3a394e72993828d40e9a59abba050e569aa12f3e2e3c4d29373dedcb16c30a97e407b9d5b24e3aa8b305738ee55f7f69f9e372a3eea71a88efb7859699e7ebeb22c40cae6ad8fac637adfd0f4a616d5de58ab0a5f6e02b5000b7e273652c8e28d0c4ecff46e9d1762e3256a0599e779ed9060647947ce6b8335acdb5b30882a2dd1d9b96430b430d77008b0c851870f746d5110dd1267eff1ae365375bc265e7aeef28c67050473b54bc3d51d25104e7aaafc93afedc97e2639bde711e041816c5c489c96a45782e67f8177084d518d784d261cf4e5357d58c47f44c69c02dc83d9b6ade5a2116b0e368606db58ffeb242128493dab292f4c5de3f569717fbd42febc9df5292e2e93526808b8ecd8ee1e153fe218e3eb3b383323d4b2d79eff9f9e8d1ef346d731057665bf23549a8ff3d2233fbcba054a38c95d562d22e118e94caa986dd84ab1d96ffdafc5891d196a50e1d9e516af2c18d6a00f9bca0c7fb3811477e53193502d554928f2b94f9675b9c19e67e6e3b8a5b0a61fa606055f049e74d9a7a867b0e7668c0e6be1dc70b1eca0376ab4f808d2bab9bb135647fbb4dcec20e67fa0ab486e6c7b66caa834e70dd17e5fe3abeefba5c35c7532217540ac39819fbf2c8bcd546c2b3bea759a758d5578bd33e2c3731b2b2a45d76e1adc3e9703d3bfd3d839ae7316a7a3ef0af4138cde1231921ddf9e060c6aec02bfadcb24a959ec55eca0f2f16fbe22ae5967d10337118d32688b8760cbe3243e77c897af83d2c7d2a839962a66287af5b3069b0e5f653449432a41818917808909f3f054d3009cf14675fc6f664dd7a498f8c535a9f05e1fd1a7caebec93bae13e738053656fa4865fdfb80a7712f72c207beadbc5a38e5c4da7ed10e0080e1b2475de46f6b011b225b2c983d1cdbd80f90deb11307853f9c977e836e52031f5cabdebb89481c570b8daab48af3a2135b55c8f1ce953942a91dbc20e2d3e52e91d6e4faee55e3a0434d8d34854e2a775d8ffd3da2b407d3cafb153a421334487b90351b448778bb53bf0641c65357664d77fdf195583c9eb2c9546a6b31c00ce1cd482b721264ecf215c6f554d6ff3747d4989801af8632c21a852c4a7b1d1ae4860668764ef25048a4b277b48d366bcdf030f081480a9c3eda8b44335c22e045d8c85591069f261074c7db11e054f7d6d84a41c13d6fd553fbff7c8d807828710aa558a5a7ed8a093214049009dd44d8b314d4de265dd77fe067725a6aaeec64f1393dba90b1f6d85c6985499fad970c0c6699498303fd837998a53abf0169e0f6424569dea71c612562930c958d459eae427f3596e530d33b644afc50023227a5d061c5f461707a2479f49586fd3c0563bdec87d560c1547372aea7b34865139ea4be499164ed09365df6c47e93e0e0b4ea06a5ae1fba2f98c2364f118f348311e7d56eb2902aeaccadd57976de07c020698c688ffcdee33436c8950847769a06052d63975b60de356f99e6d24d9c283fcbb0995335c555328a279404610f45f4011142cf641c0364676c419b64e35658c9c1cef814581d6097fb8479b6f875d7311f0f62f5aa346ef7ca3bc329ca2c5c2aea599cfc5b28e12ed78a10a266fb1d494f54798a88804a29aeb3fcfe3378aa78583f6897edef3831dab09c3540a53f55c428eca88efdce2998af8ec1243a4072420db28e1dcb3d3c2e3b22cb7109064300bb0765f28b57714e6841c8a182c657140b3ad4100dd465ed52b185d4e9b4ccbe6bde44a38617a2a8a1809a100da9ee87c11fb536a05260166a6182542ae16952be8c4caa02e00d6bb8577af01a43d4f419ac9e3114dc79c8689db433f0efb1c9c5bdbc8d44a0cddaed1698982fdd8fddbc19d3bb951927df9dce8e591182d4f218c8f94b818d648d42545513e3f5e4194d2223d73711d999c3ed339978cb7be519322f40a6c588de34e5e3fa41ccdc65dfe8f96f17a54fe664a33a6b9b086f289621e771cfa649389594eae43ce3fc05eaae43c800f06bf3c9493b0ac098e399203dcd4c1196e70b72d312e8aabe6b66bb1ea5b9939d5f58b89e04ac2c3fb20169d165a0836e26a8c41317918ff1cc463b48d0e9595da767872707a6a459ec93b8a5f88fc987f896e7611f77f1c4b75c10f27280db36da84fa24c930f64b8ef42349cab3bce35aff3e2c1c9e2dbcfacd0c8478d24e4c99580e42cccfd6b6ab6b0016e785e167b95c8390fc6afb79ff0bb5c85e2dc3318e274ff1f70243fadb68bfe3c41ccc5c645703086e53f03d0da679b5eaac1108a2597b0531afe7a0d29aae56fd1375a2932cf3fc6884542551f335b9e4107dfaf8915355affb824157a349ad0c4119e6ab1a2295dfa3568aec7297584a7434e2ec3f8757afef9703068bc9ce9d1c3ab37941bc5014330426e1f31edfa70a37c9e8bec6ba6e7b77e5df731346b50bb7a965cfc91fe4c3719bd74430d9a7191522893bdff38e0f87cd400cffc7b1ff566c5a505e02de75d4072505610bca9b0ba26a3b9f11d292ac9d0dfbd40096767761fc5272e0ce10d3327744ac91485204201742e481f437f253cac31f492e5a5f8c975f8ad26c65aa67e1dad2dea8a50f4626d6c26c6ea095180884b5474eb1554a4a0c582d863","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
