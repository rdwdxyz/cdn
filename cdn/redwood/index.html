<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73cbc1bb42660e95269dd2b6e9bf6619badde5abcd7471446044cacf62e268319ef60c98a5e4aead8d07b03ca9c1a9cfb1c00a15a641cc2f7f561a2d419b4c0aa5dffb88bac27549b2a78c53551528ef9500fe606678a9a5a6bb5684beaf8d8fdf4ceedfae6016c5b759d714c8a46ae25b97dda43cebfa06ddffbe473f83f4cf41b1c7b3de9738acd6978622a2859f616af02befb43f310ce7fda0954f1d1c717bf3b341f2583f852205dabbe9a95a1b0cb7d3d84205deacd50f351038fdd08ac6041ee12ddb8472bb8d7f47ee1bbe4d18e66bb2ceaf6a8d254a430e277e58ec0e4c2f0338fd81868c453a3fd79f901791908b462117223b7dccdb996334a7b1ea7a5c4d304a71e690dbd62be2c5f67d696fd685dfd50ee5c5b6f9e8138ffec0073fddbbee306965a1283fdda4253e7ea1defc37d62e1246415a7788477be4f47a422ca00a309a88f32088de23d3a21de7a4c902d7a2a82718e335f8be03abc7fbab7f80cdf6dcc6312a3bd21e138d12749fd6687b4d93ae027d3aad9e7329f2a8217ffa7979fb15b0b4059c60404112f9cf42ba3fdedbe90eb45069ea4e92a98baec0e1bda5abc5fac07f85c562eaca5640617b01a6d50066dffe39e1b2b5f27dc1fc6ca4c794ab76a1ee7d336cd2d51c626450c3cfdf9998f88327ed9a5e22fbd479adafe83c15efba2e238b6e7bff79d106cef8ccc7faaeb5c6c97f13e1f49f8e4fef1ee1a43c06e25eaba28ae30f5fc8f679f6d48e1f45ece405919845aa13594f460c011e1d4762bfd37ff592994d8c7f39c6c15c73a59b22518079db9cc4f2dec9b3c89f388056575fcbd4e6b877e2d1b0cfe12e7b6caa56dc0a84869d3e67f2b1a9064c15da23511f8579ed6c95bd6cc050f309708affca882a7b9d69aa58ae09a09ffb49071411b5825dc6dfb4c34dc53dce0000f5de5b49c877a0d729ccbc45fff18fb35443b8bcf92e174019aa9266ef20ecf9bd6aac5a09c27bae8cd1bc72c4fbef15e9663a9ac617a0375fbf3822c9be34a2ab500135ba0d9994f3cd7fc05c36d369b8cb774e5d0c2a5a4eed139be7bb836babb00bdf3b34bfd80ba6ebde7de50d1c825e97394637618ee49ad68d4e1849d5af12e9891c849a35a7dd17d616a92e89e03c26b962fc299ecab5bd20f11d4df95858aa9a7d505083d2c0a70c571bf1ef6064d5a09f15e5385d9d2d7b9e7101193c560f1cdb7cff56f557daedd497003101edf33d769b7c10855ad7ef80648d4e01e9dad0a3eed5c3fcc6e462603f37ddcb2ac16263678cd15ed658467ca6ce567c901c5ee6ac040855fa6804b5b092d6750a8593f6a0b1ed371fe791635aa0faa4ed927ca3550df1d93d0fec9517fcbed9f1eec5c2f6aa34ba7710ca4b7d722d89f7e9b50eb1b6bb82596bbe079dbc74c2cc30622521f399fa5f4c0043d09c3b870df894fb689df974bbe993db31ac5cd902be0ef1ace5833bac3ffd5569986de06b741a96eb626c01f0a1d225bcba33d3dfeaeaf687cf94b331de776ab50b86896302e4cd8acec714ce9e12b325c7408982accc69231fb7fe117eba0929a803846e01aec6e3f9062d461ec2106985498348618f922a3236e4aaa8d5146b8cd6df5f8de97d00a63ed529048e8bab33b4e6949e12fd9474bc3fd0bc9e4763e732629ce750f8875d44c734b1fdacfefe28457896335e8cad7aed25472237e6272a23a87e3d61483bda10d667588efe16737ed0139c8a99983f6cb2d794ca308d05ddb22623c7253a9eac277bdccdd645deb01cbd50c354a838e6593a62d6c7e131ca77cd971453452fefc4edfc1de5bfc59c59c4563bb7669ba9c9447a7b69687d3d734e824d89ebfc60de4e87d348193514bfd72feebb614009272a791ef577c742ef2ed24f50e675460a4c9617d4ec8949c4032ae8ed49e38c004f47b2e2890a3840e2efdc4c1e6234df97a921cead8369945b77bbdd0cc292bf6fb1b0594e3a396ee2679b0a9c45bd6173f5f8491b00efc5644d1771282c33bf4b8ebeb40295121a4e809e81e78718cd6ba0e835b89eeea381a2a3925653a0cedac74d16df3e203362d593d82a70df643cd2f21de1ad5874ee39d91b2f02dd59f854bc84f6ef7508b52496856331d06ce19d07ce1603db78effb828cccf96f2d0a37069aeea37740d272325da838c812e9e8b5b9a5a4db01869644fe5729a0521fbe55eeafaf0771933afbd4a3c135812b9c0a01b6fe2415df96792104396e5bcbfab831b25e2b4a37b0ec5e0404d586aa137671e7ae5cadb275186d3aa6c70f7ccc09282fa8abd6b1c83c7cb07b8f183d0899d69d79f198a31a24479aa580a3b7d0ca0191932344f06e73a63fda9f4c0743ff6d23dcd41864d2c96ccd17ac3b8e4c90af6ecbc3ff5777985520d18927dafc4923db290684044e732b3cb3f0e20190518f82a20bc7a57114d8433b16b0ba9769a59cfe8a9fef2a1bc4e70d79f5f191d6e0411c6e7bd82291e097090da18e4c236b56d9e88f9f8c3dea5dabf83c15d2941498cce62af80e6b9f981895700ece332fa0bf627ff5e89290b4b4bb6863144ee40cb092b9ce0b7880596dc5dc5e5dd989e40ea615bde1e818d88e7f7107c1c8c924ba2b18d4d5366fa153c6e52f3a53fce695b4b54f8052f6d0d2e7e6c335efcf027041a95158fa25d70ef766be79c5a3497d48d4462d2f728a384bbfb2069b095a5aea5c8a9d32e34ef90ca2f5b806781ff7394823a692df5b196d317a8a919762c26b97231bd09d29d585a8ae530a1df43bb3a6f1e0aa94a559898fe587ff794682b6836977f2fe6680b3073926f999293c2ccb23a08e2e8f8b51e31a0af42bf0de1e95318f8015d44388754a74099d07ac9e80d41510883b33ee49b7eecd1453e6176bd0b14c1a4dd31adec9a85cb2ce5da3b255206c3dfba901e7afa4045b05604929a1136fd83e2d4596875e079521bd3d16511b06bdd5bc193a6c3bfbaa619d3a344da7021bb1d03826a2df1f086fb8fc0596ea6b6e63d32a1f8a597578cc489918e1f46c745f1160eb2c1a5ddeb157e411cf89638138c82e3cb0148376aa2f2bc102d78fda044b13fcf1e2356d40b065c73aed712f8d9ddb909247f90e82501d3c49d411a8861bff702cee4bd9015982b83e5eec464b5b19a243df1b8a7b6d6e6bd00042c8192d781c911f4904bef969cacc23b62ad7deeed1b65fead5a58c59c57f2fb8bb445e26a8b23e954b88366488edd5f6cc71b595251311aee62da59b4b3e84b556f14d2e982e05ac230b36324e6888ac91912a81bf06724671517e81bd945a99a1b323040c8b42b7d73a8c4eafc9bc95f6f3421b26350bc66057e7b9983f5ac7cf049f6be13c37e15a9abc971a47d3934b6320c27d8f5d2946b9db4bf248bcb88ac47bf57858f9f18eaf0e2350dcc2734d4ce02b03d94f37faec6a817e2a0143c5c88d6788a10dfac4acbe8f8becb04c3eb0177f7f59f2cb5103ac52cb8c6b377f005f90bae5fadfc576a60f9ccc63d2522fa36b0e84a164cd0f9e3c2ca183109a63d82bade98caf28a50eaff26353974d56883642763f101147f4d1f7a88192f909a02dca14212f6217a93a8e2c97f88aa7d95014eea5af55f8c20ff6f7711b7d2a8c68e18205edf332617f9863c45f6c9b8287b3696059e79a9bb5ec27b6e31e49659ab3a7b9214ad8987fe54ce532ab8bfa965b32d4e0610ffc05fe4610bc8f29759f6e1966210117576e0f06797103ac5b322c70a45cf05cbad01ac9a728d4356a79db7aa7a64f06035b351a606d6840ff4e3accf0b972925394ac4d2a69c580ad09187d0bf30a8b54a1359129254f877d3b8a0ba33a54e6e4c995fdb7dc344b1a66669f1bf377f0cada5437ec582d394f2653b118edcadb0198ae880b67381c2c1a205463f61e1afa75d5d071b6788587742da9f73e325a3302e8f9f6818950232f5b8ae51e22dbd0a419399ca2db3e6ab1285288ae5373f43ffae503917dc70c4dc16682a74feda86d64bce550da1f15fbc70ee6c380805ec1ffcebd4364e71573514c237421442af838bf057024ef72142ad83e0df4a44971346fe710f01223de023aeef13124fecbebcf8e75d571892612f3e0d7afc169f0e6be4839767ab56ee8e43958d7d0b5de0516b7f402be68fcee0c5837e488e90e0578d6d0e2de7e6bc196bd84540d6e9d59f2a0367343514a3788651f476e2d466341a0ff12fb7b6fdecf48f697c04aad3ed4fe86131bb06ed9b6486969cd786ab09676215d5f93f20e3a889039258c58e2156bd14b50aca841db4c634f1975eb552f88cb05b5184799d8fdb0e83a74b2ea5491304d7bf71f77b8f936bdbd5b484f538499742de8242be01805aef77212920409e504a61e65c7aed9775d15a5ed32855b023226f54dac3e13dd97673942dcc5277421583ac7296e1a6a22a5fd5ae5f52f464f2359b68f8271b2d416c288013f33892207d856f717356230efd4b2762bcc510b4ed53c0c8f19ead68e6a3e26befb1f60c280a436dd200e2ce9b656b44cb71fdecc3fa6631500be8dc87df4540209b9b85fcb3f00baede12e81484ce1b60dd4f5c4ad4e291a463c4fb60417e9a0a066edf8b50425094d1230df9a74b6a2a4062f90b39517acbf4c986529715d531db93f7a2c0172555d009f27fd8aafc6b7ec63c91a42a8c6476df1c580fb3a4e1cff60d82eacdd99a50178006540a1a996595833cad7b77c99a86da54189323ccc98882707d032b65e49d2a8cad4af8a8eae4ecc95631b75d64fd595a152c08e4d01bb94fbc5152ab07731795893525a7e9b081342b3eb1c6ef0f8458beaf2cb9117db955b49230ad8375adf682bbd4848908ac31f0d81a1ded59c456541a94143820051c72ca3da293b25b0c9274fe787c6a28937fe6d5f28bad8d0ad56ebb3ce75966b2ccbcd8a134f47ca89c8451680a3f35b9cc30c8ff280a179559bf68845981ffbffb7d2cbf71611636494a3886f4a929b60565f3f8c9f96d5a0bb6854f006699ad2d4c42af2a2fb726e646d57699b59d7836f0f27160a2193b2d4e10f649d81a90e83ee24cfd5ea3d08325750b078df9fb922cf8cbd37366bc5b3451b52e15135cd1f46ac7be825a4e691ebad230437b536fb8b548f647b6ec7034dd7ecc242c083a121723549861c5bf1b933b476acfabdadf38f0a641b5223b5a70a499ee86a8df862891897700c675bc9cba818ca3c92c37a710f508b77ee51c0f3924b5defcfe8cf5ef739c129171f2cc620e6f4412eb59b3ceeaa590628acc8bd1f2daea4a8ab92f71b2b649c950b64e972b0c3c55ef5def9ba30ddbb248d016b2b305b1c81d6b021f8f1de7cea4831e4f62bb8c073821adb75a27b78b4bd80589e1d7710e2fe47e1913d37db36f564919b83eeb522ba8c107a98df4234045fe449a1d3a514d63a78f67ac2d22a3b8ec84a1e3aad5a358af2799c1bd3ed99b403e44c67bb4e1d256606b59942d6d442707b1b8efc2f42889545384bdd2aeaeeb54b2bf30fc00ec4c79f03ad19094e833f82efbd2b941a3aa3ebb8288c9460627b21a9eac090560eda418f73fd6aa2915ac7340b0ac2ca475b4ec7e27d1c7ff535afdf631e823affae55ae5276624ea1964e8658f781e0cc1ec7a59d0aeed8ec5ce5fbded204757b102bd09a38fb00a0cc94382af392f257aecf49521f0679e2f5d8f884e243a3e89a2d27658c53fa2b944babfdda1a96e1203cad42f57f5877f61964e73288c914cfc2092b8910263e97916f809b86589c464dddf9c239764b576e3f49d543659cff69a370729ede3410e112649e24ba5119089932dc6e690b151c56e71b03bd1c757bf9551bb72853f292514f114db2790049534a1dc43b00dbdd4a62b76cef7a05275dea04041958f37e93735d1975da4138c0249cd887e4f219023291c437d26c19bdaa56f75666879ea240e6aed1b03b24182fdc0528729ff2e5a493b5c59c32d73d553ce053530265837fd240c5f725207bd3f96724436e7068d3d6c8562ac0424bb84f5b338456fa1e0e9d6eb1c08611c2c9ad33717a75106c34494999d83bb62d69f10680b1a69d85bb4c18313a0bd9bd223b0d2329a97b72cf1704e3ba425e10cbed69371c243ce8b6b3835a7d2dfe6728da512441753e8c8630213ae8d6a32e04dd9334d0b6c1b304ef89273fa77f2e51c2debcc21f04f4cc0da7feaa6ddb16f2fcb0c5cd763032d1b4cc3487dc50d0f21c9d1740719f370ca78b6460c462845c3bab14ae6e442ef85b1d765a7a799dedc701c5fadf938d785b8aeee6045fd39898aac10922b2fbe4a53e18b68f97a63c1dbdfbc6348c6ce1b3583bbc39d51e08d30c1b2dcc47eafdc92c8942e0ce08eeed6b16d3c49c0f96d28f977c20e6a745c7bb9d1002fa1a9b45de5ebf4d5843a6087cd86778efce409d92fbab98d0bad6b5c8c44a4ae96643ce37d958f1c3557c2b99ff4bbb889c8ff3d4b20dc814d9af43df8192ce90fd4770d01814756ee4476a9aa44f0b6111a221cfa9b2c96f4abe07a3ada547a78bfe08cab1cdbe6484b3ebbe2a07b3c8ba2cfb8511fcab9c5bbc0ae45ceb64715585f713429516189d1b9d33d9b870a3f3dce45dea1026bee7c241bb4a7f17ca31653f7fc8b342114c96b9bc92ad6766c6d399dcddaf8385d0f16635125a014b5b63763818a733568e07c0563c112bf5358ba6483f6e8d6d8e983f5d3c45a2e2a9cb9f288303132090f9232e9ad7f6d6bb4c218ca8e3a58eb8fa7d6543e71165ab8f49164c1788487631cf5e0070777c3bdf5d93c90f11853c9113149dbd6d70a834844e9cbd8b7333ec8e7f244a94aa5afd375f9e87a3e13af9aca09ea5228fb4da951e2bf9a6f22290b3bda9cf192b2862ac17123b606b0e2d0f24e7ebd5571693b0cf530323170102f5f5307327811b51b2a51e8989a1f2ff2b85de259d33e43f20d91c946164e560df0ad78425a9145f0da42aba462dd6d30dd27ae7740fda9990242c9a5570d17e32a21bfd09e20c66fb8dc0cd9c5bedb1cb8c07722f9f1797617e357f8d4d3f6fb3faaa849e611baf5121a40c33e0cd339133c458edb05bc53206540613ec08c3d2572fab5fde4be968a56a1b52cf7a35bce9f8d31d13131fa6e1c99f57f3e1a9e3356f412561a34d51a211b89294a9f8fb9316935cd246142f752be5963748da41a858d537d04e3a6c20ecc3b82fb19efae1e6cf1bee9f3d7b77864b341383d604f341bd14dce944e05dda34119287756a0782148a540b2841d0665d67088fc22e555a5df31d70662856c9b60937367d18f40bc1877f11aa1e9fdd372a2a3b9d6b9a8f4bf191964c3ca7f3f7041aca585519557468b4977f48aba86c9fccc3db969b68091bb81ce9ccceb47b16846e9d3b2d35f78b27dd03ea6e8921974f2645c8d047141eefc4e01f349bcfde866b2a51a1a9166f6b6f8204e8c6139794350a7caab9488c3867bccec8a1484dd12077d4b78a8485f2d8a9100fb6cde6354e5846c2d7d0f656619212d3a692c4ae3a6c2727832fbd764a192f86dd32f73549401bbb8586faf9a7040e42565865bcddbb42051b5d7388d0628ced39c0b68116fe685d62ff4fa2632a9d7437c9a52e78e101415e979860cc7e31dda0201a1904e8721e3c2fbef0416f16a9ce5898fc76ea041c57fe5dffceedbc1aad4efb5882f93017ee4483bf5388040bac1f647aa495a29fb009bb94568c4892d34c813ae6b842ce5b38fc7f49fff909f9478cb88c295b25caddce1648b53a1112d30b482da2508b820d40039b2eda8f66d2d6e544c6a43ee179a9776219044ded8c8490c6e83a652ea98a2d330fc4f029b6eb3c912f2cb3d21b49015c96d4bdbbc92a6027271382a255bedbe5ea81a9b06dd113a671d53ede1a99d97fc8bc42b40759165cc8e07bbc6c8a607db22c82b5c4cbee31f00857f2a105697bd460a2438384560db18a43a1d8f9899a6e3d60ff1a11274feae9b2f9b214caaec365bbc4ed11d81024022090821e8cb95cf14f28dc96911658aa44677edc27f4d7e82836335455087471204577844127f7fcf03298becaff049b8652d0aa00081f5969ef9d4da8556cbcef8324eacfb7d7c54ec98e755fb6a400830a0c9f38a0b825ef7c1242a5d932b3c656379e0e15e747ecabcc9fbbf071491c7dc8ae3f88e1ce3e36118b402a966d6676de145d38e71534795981395ae492f19df741250b6963c1a8d6025687d1b1926661d440ab8a703dec0e3789314a531c05fd8cab66baa63f3e5c4257145b771224128640d88984bae7e79950f23dfb9e77120b16de97d949bed664625809e099acc7df3db48617c41b1dd898f0575ed0973ccd09534f207a8414b866f79f11e4641608014119e46b9463bc8d190d2ea74342c834db58740bc3097df17dac42dd9d32c5152618ba51e28a0bc0cff6fdc20faefd690738f20c6827ee1ae375abbe394adba55b70ccb891cae4035d926ed2b30a75bf7b6e35749b6865ffb1f3c89114ed18aa3378abdc9406a5f9d28e7b5a24516284f2b6f21bc407256b972dd940dd5c8da43252362590cd63c9a5e5614eb578b3cdb7ed148db658fb34fa39b4319dd80005b9d4f5af9e8f81fc8ebf99bb641cd9ebe9e1ba23db8407a6648d85c2473d833988dda173f24f7e5b4ddf69888b146e1d8bc680fcc351407ce1101c771395b18e9689c29bd5fd4c92b3ed077afbbc79eae68e632d5123bb719dc90d32526264d3db3ce017a6a830023679ae789e43db1cd857e8f8a379f0607d73ccaf83fa4bd1cb1ae134f8dbb81ff9ad6b317f23034fa4e264d7b5558c1bba0d2aa90097d551db09c4299abfd49fe19824c64f776abe32136247c4d90fb557f5ced4e55d18fa28ebb64904d0f888eca40708637d60d0728307f1437cb72d56eddf5bb121c5234767d5232f817f592cd16dd1557867067256e78e1b66727cbf72d361169b68dd1f501c39b218e8ecd9b75019bb29f935c6fba199aaba5b04adac3787676995cb577431bbc557f6ad5987e3310e75e2860a0b5224baee100ca69e072d787d3d64fec0d3d61db77000565871d229448b26da36df9a163938332d6d332193a907493be050fe5944e0a161dfba0c4c247f1b9fb42209ab589e618ca2e61984419af284cca6f6ac30bb75682081a0442e6dc50cc7abff2a8e2a9a28255d0b7663bf3dd55a354c0fef57ad870df68d63571ebf069f6a54d179fe8f4db7edb3076430e05923a03c605aab43edbb13d9d9ed0dbf627a7592e554ee83517bbe4d723195d3988462da2b07d8b82e6d7319f05f5ca627a47dd8b79932f6865a368108ff5371878c6bb41db16d06765fc32fd1bd9598794cd630693fec3d3b9f31062fece9425296e16fe268cb828d6463281479b55e97c7b0d016430b6638e5d9abb8dd1f92c49cd4835844a6adc853230a696e1af92806a7eb6777ccfd346451628b94aae2d3b2d994c0ce2372249129408994487ba9ee288370eb928dba7a818c13418c66f18edf7dc2f5b0e3c25a1a02e8b8acc1a25c26a89514d0a8667fa5ee9d63422dd6122098fcdcac7579f5e7d6b3d1aeb78d4b6b6ab50914c69e1e82a4d4e18f52f157dad0f5ef4ea2c9c95030bc3debd7fd70faa3c68882243f05f41bc6cf9e7dd984b046e44f9a83bca0f38f047ed42a9d5e8566150b43c74763b5545851c688d0017b1b873fdedc64d58d44c74fdaac54ab9b30e7c621fd78682435f8077b34bd7f1408c1eb01a3ffc94bb1ae2abc0e8ec057838b407915b7ac348d19c962fe852809cf46e31c951f5549ab35a2aabc70aaaafd61a001e27b870e32c0ff6f2fb1fed57e57f68828cb098d76d065e60b01f57479405582b8ea7c055818f51ba371f761fcaa83bc2658e684f11737719c9b11055940873d36523f94dd532addd105d497ec4efbcb147172d718d04053a3d2a4129e4f42219719e5dfae010463ae8c58a20ff89fd0b81798620e272de166285e1bc2cb6cfb4040aaef7a07dfb9db88d1ec32579d8a3676b0e3176b024ea7b43eb462816b36c7f1b6ba61d69f7473c5e2ed1cb19e853a64964ae9a1d5e908056b3c93433cabed38e46bb83557a61304dbcc162c79c8a7da0cd23bf7e74a4611fc780ab619f43c3af277e7935f482c83812e9afa6b3cda727ba107b658ebbe1701887ecd392fc511b8d6a8f898fea0ec27a76b8533890bb037cef3af6ce8e14f93971b44b6aef95afd8c105ea87fb82e4894655ffd327bc64c8f5dbae6a9c68b3e5a4bc91903dcba9cb47f89d6cac99f04cc772375d8f90402e773e1fdd424b543c0f30761ecf0548da63fc4225fa3da8fbe7f0e900b211a7a545bdab40e8b64954e0313149939d947c74395bd57346c90bd06c08d846a04c29240a59d17ada17e9536dc1f13a87427f0d8476b4d37d7c8e06cbd361d0e61cb8030c99c1c5b852ca5c61b38fc0c5e12b2d50538a46f6d607e06a1febd2a3e82804b7c4b4f07496ae67e024af694b122f6c0600c22bb8436275ebccac19a6c9775d23a553058d18536402f4096deeecf3f1a50a507bb9a224a940bd31d5ecaeee8899642755c1ee0469b80898204a040b51d20bf92f02d5db748d0de32f02c3dc096dc60d165326c81b20430ddef76814dd919a211092cf80e91a4fb5b080bcb3a6f9723e8004c3a158737f7bbe1c3cdcbac426ae6292d9e6a8cb325521145b380e1da51d1e43e11da2adb5e2db6bad90e978a96072454b944eba3948c6179f3b711adda6f6cfc7090bafec4fc3c85815fa5f047d3350bfe8dbafd1e33b7f55c87ba09e815f492c15ca2b68080571507d1f97889bfe8354a043f3e94edc159d41dba9ba2aa5f374a9797b215f756dd12104d404cc5eca3f50355907925f16c8fa07cee4abd055af7b173067358bba917c56f372b088177b9e031be53f19ffca6afd8eadc4c2be1807a3da7f22a5b88f2aac47dc33d8390242ac59ee9fe996bafa74c791600cbc3a1bd8e0cc208545be14f900cc8eea48b0e01063977c591d3e0bbc297149e0d94766afc63a25080b40abc88185468b662eb9a756d321c4b3964d9767b474cfbf4ef3e2830ec479d49f38cbf3d9e24bd3057ac683ba0dea7163faa225e14ee0f27771bd35ede6e4ac15d4792f73f69b5055ae47f0bf61b97d580e5103b85b6e6ed4368af175f1b969dcc49fb4745e5ef553f080049e1ef962b6c781ce9d4b89489f789a619764c8b198de59d963815bec799fc0826c3c64826554f855ac0c289134dc6c8e24fdff2a8ae36cd87a2650a9896a48327ebcf8382cad8344122d3c510494d62fde1bca963765ab99e54bf5c96c77bbd0a9428d7ffa7b8865905cb30f2363268ddd1b0c34c0a101ee45a162478dfc335a36f8ec08c9be857ccea5c286b6d10c7e166e324a6d812e7493ef5bf7b25a4be0d9a676f5bc0f7b4937fccda1ef9bf33414d1ba997d7c9353ae5e97fa23af559c8db6946cede951a235e1c8a5c25bdd4d9e4eef1518e4e158c100f970b873c110845b00f95336c05ecdd729fd8805c31dcdfb3e50e6c68b91fb1f37126187238170e21b008d5fa9b79a55b35068d563655f37f8fdd49f58022586c8cfc239a2aaab90d3e464bbb994a337069574734b1bad434db06094488acf20e861318191e12d388baad3b3ad8e7233c0c27d4713f69744e0b448ef432571efbe046ca393abd1ca5b00067ffafa4e3214b7b477aaedf04ea54ee3955345634959b1485106e190997862958df7cc21a1638cf1c4738e61d5da2c85a14bdcc914af315b8b2eb5225f6729fc743b6703680a1da11db4bbd565134dc057e287739a7e619c030c89e42448ed752d2e4c64a69dabbfcf1c9a7cf58f37a6df63dd2f477d79216f50f06a53cd6d1ba78ab73ce1b960cd3fc500e127cad8ac63022a759e82b0842731cff951df9fbef2856bde3b38bb7a9873f8a9f55417e087bd61142daac576d89910324dbda8fd1d5d8e48a16767ed584d57072a2005db088b1e5673f29cb444872339c59c785803a5b30d45dbb3e5e63a24bf9dedc084b449ea894cf34b77371aff05a5221371cd1ed78d4ee941eb359bacc3fde51142ccdc7763db3938ef27f92af324ae9d0554fe9df7bba9164eb339777b407ebd4e073455ce45bf402e7285f103073b6821c8a258b24e5d76a020a940955e48f236a3c8db9da088e12d6a348ca0618443fbee5131b9f2a56cdf1f254524e4c26232a3b394982d294d79ab0c85b9bfa31121152749156d3d23fe02adce06651740638e5a0551a221888fb85564ea80b217bc797b8b8f93405efab55f9f1fe252f7545dc364efb0f83992d11162050bfd3c09fe3c3146dc13d6d08a7d46c083104d3858fb662a5062fd6840d9d15c538a6881510215453b372c85561b60ad55bab54427a76816f585fe0ec15ee431788bfa5055d4e4bf640023f763005c430233a0229ed763d690d91e8c9ba0a27b269cb7ebf83725a82b0668e9d28511ca6b51b32be6754c2a11cc8161aa2259681cf82893d81f45765721d2379073572233adc779b9d849645f1b336ae0bc705e0d8d55ad43fc81242402025be9b71c854f3a2e411d9ae3e0ae6861371d01daa640d88d06f9836bc5ca3877111e7d3bd481c203fbee2ba426fd4655de5682aee7d1e7c7bf82601273203fbaaeaff02b9be1bae34766e44d63702e50f26e6426f3b3f04e490d1e2c4a8bf864346874794a9d56d3b04a9c626ca7efa0f3032ba6bfa88c6102716ebef0665babfae0fc50b3c24a6d2d8f8a6e8f5e31cedd50352e3a4e365128da2a47fbf3cf3fd9dc88ef96d49a3a5a38580639eab22e159d3aba3f34d3a4654429142da9826e21b74ebc33cc7f2c0c7c15bd9c3a7189b338de3b18d451e70ab3ac482683c5025797af35b609d91bd206c0a25f6ddb22bc1fb9bbec1f66e16a83fe1d057a23755b399329aa5550bb66ff6626b228921e04928976d4f86a7575b05c7010ec29bce55bbb0da8408f2998921a2ee9ebbd1e13066124032ba24af29dba428716d2d53c5ec1c4e04614ee9d18acb42ae937359d1dcf3125e8402dfa3b96b300c813e4c003bc52376a4207f47d39b76cf98955381e027adfc3869e2ed8c38e3138f9535e02bdedb08a7849d3f029aa651fdea082c2ab3ed870bca1fee9b9c350d59732e5486b460b186b3ae413d6e97dcd51299d36f2069c1f03175394588098fdc0e2e00c9d792c0e10c95f298642186b9e8dd84e12e3156fbe58e5060ee3ea9f42f8b87881453f96e12fcbc80ba4287b2ecdc0f0239b11e28e8219c6ce41434e66966b15222669a89f176592fbd8a1c2ec826b85e3a953773d77a5c2e97b3dbb85e111c08919f24ce016889e9fa0689ac8e76147ae232bc773751dcb9dd8c6ae89bf30a04f5cd84bc031195593604d6feab9c978657675c87357861736e4cb544675127f7fee00f763c5bdd2cc60460aa86e2306aa829340a3ee7cdda6158546eb848cfaccfc12a2d89bb04152ee8726e895d99a7c5c722161b03c3a9df0e36a494c8a4888cedae94c2388bdecdc080df2c7d8c52254e79c564a7aa10817ca69e78fbf6f0f3f171d41fc382d0b30245b34011659a9b07d16fcb62869ced32acfb2fc8c0e11b7233ec9bc91b517d680614050e67c3a0850d85341b399871e7eab8d8a5957bbead35eef5d8ebf10c8d914cfa7db77c1e23b698e694b58aac6a0b9d32648c84b1fea7ca6ba6e6bffadedbd81f4a02111968aef7f90f4d3f301734aaa31e71895f105725a8b22ed566319a705e2c1e61254c111ab905164289a15ec837783f894d88c82e2079679c4aacbfbfc37fef4e889798f933d87bfe27a2aca50ee4a7591e51a1f32ea960b3898b55242286f433811328da07954ef4caa2bb145542ec257443a156b87c482c9a1bee3fe2c283672fcaa4bed0d165502bf49dcd3624ab38452b57e8079bb24dad8adcc124d914494e74cc7c01ba734ac24bba70eec2245ca0d26be25d2e8b4712efe73b7a1e9c1cb9ffbe7f68cae814b8a609ec582351bd3ba38c953372df1411f1bfdd5ec8679a63cc15c8f3fb86c86593a2e8a9f40deda72cab0b32c350f083bd387659bab64bb87bfe7a8a53883199c5f40d4a6ee6926b7e5cee6805112a1784a62435587da740aac49365bbe0e5c19363bac31c88a8050bafd62fa62dd8ae52a93ab7bb4ef0a3d01f81384d619d9dcc04c4625f925ffc9f12322e1ad1d8b2828f358d548f193ce723c25db8aa452dc3dc07419df22d05ba1305e6f2b948b976c43e05bf1dbc0b961251dff12d235de74d2585084472807746187c795fa76446532c005de20cfd2f879f2c705eb0200dae71250d42deed9b3fd7c49bb903dbf71d1c36b4ccc588fb91dda95dfd71b8af0e359021b37510be45e0f983d1dde752940ac6b686b8cd17ae136dd7178790d61d32fae51d13e0162366feb74d02bb28a7a8fae5a334cbf27729b36c0013401d6d319cd219a6a2915c10441bbeede5dd1f56c80f083f63bee2414969469d42738939f5f69636b76de8a2ed56b4d349784770227052235a7f6ff84b9b113f0d2211243db43470f81b41c8bcc383b7b7b06024aba6f483053fc7a7371c109796d60c24f36a96b4246b5d912905f4e9728a2952bcd6f5a0fa1f008d5faea773dd140eb46b5da117f4af0374171ef7cd03d4486a3325e20551fe0aa4861d55edff8d511c7c887410af697f6d5e4b14f14890f4f02615d941df20e817f7c9465d67ca68c62c03ba4ba8bf9f5b2234939bef1b6bf3f4d102d0610125fd4b1dd5ee676579d677b8fd901aab3c15ce85a3f93919f10ed223b20a5f1a8400a832190d21131033177b98560727c5ab14d074f35381677bba93d28acf70a357f3eb58140b7adbae1bc7d0e06b03c34ceaae12bd363563f106bfb39d65db5e710946ff4b6929d57bf1095efb6a8d34e06498d00b1e7146c7df613fcc13cb50b45e321c0dda43864d16f6b3c9107e6b7bad7585d14498b521ab50000d92a5108b00169e0cb6e845546546a792ac77e70a7018d47f8085b5769c262703e5c2e729d34fb3a60fd3bdfec5aa7ed311dd502998c11d01be308aa40facaf8e3dd8ac5301038a36c391d03023f4164b56da554c9aba752d123a998e348d4e5493","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
