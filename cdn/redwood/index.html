<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6846d093005725e5776c59c2c669077e9ec62051b58ab9425b4bdf154fb13e24278710fca989f66f5bba0fe065b46178917fffa39f180c881c6e2196ff11036f7355e822ae7905a13851c7d9ba745109f563a2c9e5bc3d2287a0dbd76cc0999b180ffe1b7e711c9969f1ebb7666575ed23975e4bcfa451f6941534cc34235f2b2a634cf225955f058122f559b0b24912d56a1f084bd5a6282511f95c7b82a5068efbb09c6856d04983543f901d74a0f8ee5876bd2ff0cb40e0b60e0d7625c1796bb2f2bda85b85e0d14e155bef8a8b4e014ffaf23cec599d78a6b890d713c712f4922576cf6d175d8be7cd73cc104d88c85e84f5a6a2ab05b97390e44251872d6a1cfbace77099773aad318972a0864a5415facbb0acb63cca03b0989b884ed510b49e621d36306753efbd3a5bc57e06819d8e2ce99cc9fd5829258affc8e5fad5f5708e9bc63115dbc1b375db8035b921146f61cf57b36c50a0933c05ac3d5a0c1cbf035e706631c4a54d99fd5467671a9f8150da536c2cd714d3857fc6d09791b9e68d1142d4f978180c366094168e6cd028f2b431a4f2daa710f923dc473e5e6d67273d61c9d168c58d809724c273cbfc1d34d49a007ccdb02262d4deb18a860457fe92e274f7b2ca955b8aaf7869e2315db263faa1bd4579a875c901a36f8dc1306df801fe40b4b05b5fec170580ed08ecfed96acd471b8cfd6e923fdeb65b99ee3d50a4ff272e232840dd506dd7376429a622badf8050a450141d20e33d33712ff23880f3080e93eed7944a11e58e88a4eb7d6ca08464777f6aa19df4f0c441abe0295f90d421471180feb0cb8d6a6af597e9754b60129e011b88c41c2548df3459119841fe39969e55d52b5351562e34688576246d1d62fd878942e0b506dfce34592a0c7dc28a7bce8470f62fcc15942628891c31c97d761337d086560f5a1cc98028fec0c964b2a415304505aef48f198bd6a77907e931261157c4d1e987515f2f782d72b814fcef157f0bd33352ec14d6d3779cacb86450955790a90520bd6aa3d28fb06c4484a52399ed6597c508956826214f25ac2a6ae426757e0557d651307ad75e11b96a5f66d5f51369a8091a31771f4af04f8dbfcd8230e2d0ce8f9184589b5421e313b3efdb730db41789026bce80b19a3c5b48d6602b877db21a06f18cff2c2528d2dfcf496ca1a703dabe7c1f43e8b7310b4d5d7ac19d7460b12076ff78d16d65849d8422eb22715168e27f69e7ef7b567ca453cef473b05fe374a8390f6b4059a5556517c306dc97764fe5d7dd5af8dd658c4a2da78907595880a56fb960d403ddb71fa023f4e315367bda1bb7c4a2665bbda845d899624ebca0872cce56e6b818cd184ddc75224425bcbe61c18a0173d9abf6ab55a8b87a49c541c21125d8ab7b66f487eb5ce97b00700b9b0c43ef96141da5d77f729c108df7b044e62206383bb3690e36189dc716a3345b63cae9877e11a91b39f494881661814141aecc9612095c1e25f63676fd652ab94a01c0c414a3dcb46559e4d821e86d01ba13b82f8d09d0b624e245ce40830ad0c5f1fc4c884a7fa12a63818ed730cb4777077bd289d90e2bf1c022b4d3f4fd139e4391bdef95385c3014e42bf03bb4c3a3b4292d5cc6994af47b6833a990d413a558ab395cc16c871aebb875fb73e034a5b96f5e60c1232f3f18c98063bdddfcaf2a76843cd8a981d6d6f92d0324cbf82eb0540542d80d57f3201898f954063ea85d62c38c182a2bb7a73a4bade28270998d8553c7a1a5c44ce8f8a348d428f710fce9e33dea0440031043b57c8bf8b384348181f98a364923e4667b13bbb38e87c0a18ca6980333798722c179a3e22eace9190d9d594fe1e0c47b1d488c21158afa61276c4a519fa269775637f02eaed8b73d069066410031a5fc45302200787cfe6aa1269df3a4b1e2965ee7e7042e25afd349de977eb629ea7ad2450cb8a2da0c715ca7aacc182f790772435098b1e336f4ac08828b37e55ba33fbeb0d0042a1d3ecb3b730057bcc3062d5b19f28460cf3e49d0da55c036222949cac843e8ad68b179debeee5342ab0ee9fa800e0334d8fc0a14cd4682094621df98925b6d1132332e20d6b6e5b0e2c3149edadf88e412e3bd1c44c24b11b8d308a359fc845dfada4534377ef3ec01b950c30d09d296438e4f49dea6603275c667aa4579584972e930d13c65b6d756335c170e4d3edd85794469619b9dbe00ffa0fdd4a5ea510ef0ddbb077aaafd848808517757f8993e857e7562ff4ce4469d4d38f987852a218488d984a3bdf92daa10b7ae1de357496480bd04da1253ef8826c41d121668192f9ffd2c50e6dae5000cadda3d69ffe3f11a2d82162165c3dc6680f4e0f5a423f2d0c9f391da01217aed08d9ab7d5c874c8eb8e858ad809d77f04518ec514c145d0eeadbcfd77b30bc40c4220444b2dcefabc170bb4b5b9aad4f6b5e7f5f688b3a693af60a596f2420bc413e1e250563de4afca136d7a8806b5bfcc9a1b6423b0bc2fe31e786e4f92c35648b5ef017cb8745c3e95bae64d0c1f96cb58dd7fe81dafc6a1d9b20d95a35e4a7413e1cca6b4fea591619f0a500f165cfbb7f196d87458a1db01d7baa7bba2164ef52d418ffa3cef59b1062eb73beb5f314f3fdc0a8d5291a27a638144b34ec41f1a53fbaa5f73563d8728937eaf83170e49f8fbc0780ff2a951b8cedd48de97c15166aaf45a5926461da28524cd1fd9aaaab2a1170ebfa4be485b937aa116356e5b7747c472a212e6deb59242dd060630251d8089f4be2600928c84c78f093bd69560ea1accc2cbe55b0a149431ac751fbd0c5957b999a9ea27d8c241af4b2970c44f72de4a2f187d4d9ea5d3dc1445b20e583d04926c08e44039a9bd0b23256b77ee858a6b19d7b2b372ffb2b493f7ff3f62380e9d0bb46c9ef6787c7b8f314f74674d88e96fbdb321ef001c6067805a3aeed0104f2c313a12233197f00b08d7a802f8697ed0a7f732702be33e442e2af8bd75012df1d66b90df5c3f5511ca4f097c8c037c8e3bcab0eae5d91fafef8eb31f7724ebf6bec02549477d474272b538976023d4eddebfa3ee8ba42c865e894a848305bff1b176e946c38c10efeff083284acbc77ec589329d7d92a62e808d70ff80c9785e1bf408172a5b2c6c74623258576087206e04424cbf036b9cb0f79821bdde70aa3b821707bc81205d6641e95d415200a6ec59d51c2ca52de45582e51e5f9687f9125c01b87b7415554218bffa4e82504cac106c4cb6bfaaf91a1864e4a14c6751ced9c3266738fdfbaf54d1917c106157da3a3480ad437108745d240ca8976d6c26ffcad0b6ac0a69e8b37658d3358c935f0f8eada1023096bd30d48c61ce82b1e97c99d4cc6097e04cd1a85cab7f3aef908cc06e9dbd5428d9f40a9d9184d840d68cbe9c3dad527d30cc5ae899d62ee01417781ed38cc2877cce39d8f154201b298694ecb10b4db96398014555b87295e0f98ade7e9368f3359e5f443d155d3a133ecca25a419e0aef3652998a264f35a1624f29a4121ab6d78ae33c1b951207d218aaa009329dee093108ad60d6f7de4bd9f10e8a30300900547d3f5a798a992e004323922f434add77af7bb75e4d107772b5871e40152e8318a2688d9badbf4cf2827e931749cd104fd2092f076487a91b16db7c0f22fcc1ac4ef2bf74749ba6ff2951b5e43fde4150f58150daa7e9858d924be622dbf567f3def0a072cd08ce2159c3a3ef90f44c7a2c618bf1ab5e70fc59995914e9d1a80cd3f03def52084ba1c37720d6fc826ba98ca221a3e7e3bd06aaad9c6b1886be875b51a2bc69d0bb85418d88a6ce347774160ab22ae9e1e986cfd5d078833040d5298853266d4d763508f739116d4108f342acf5cf55a6aad124d4dba214a7794b1a3645b9a7a7ef4ec12e5c009a40b2ff7542a12c37d0c80c6a03109903522b69f0f9fc6691e5f64b8bd598d33d7dcb27fb5ef31bc9bd0710af9a1b20ae1d81ef7e50fe5ab853f1f13317379143ed37aa89e81de729be3980514890dd168016889cf59c97cbc6164eade370890dca15c9b06bfc393163642ea50ba08d41a3ec4fce76295b25015507ecb557c7da7107971f72282e9d6930c7b8b00fe06e933fac03584e949edb2bf145ac6ef88c88a4e3083a2b80e15a8d00e1f73d81b0b4c3ae6c3844ff34a56a4855824a81f9f514307fb18aed136c7a3d24de32d5d948828f2f8fef77ff1a30a8447f8afdef97a2080c7aacede864384bc10e855c98730a1c2088b9392585db92209d43e31797faccd7f69c1c8f920355723781c0c1ffb5a26231d33d6390b948548b17dcd5d3d3f5b430991c88ce0dfa61d200b61e1f5a62512cfeecb62427b3aaf8017b30474996bc937baeae5c9f7e2729ac5ff8e0760b84e8a3a3e4cab8770615f1b8b78c01afc7f4254060f82e1ac82d3f19bf3ae9d42326a7f0b0a72693a49a1e911829f2728a10295e9b178b8b6f4e63244b7c5241f0070e1651f80cccb15f6ad2b82c2f17a3ad699706a229c3fd77409f89de2a66ffa0c35713db8dd2b7907b2ac7df220f9ba30bdd597ecce5cc2d5b50e750f99949c6eb08bc2da2391434ed46d224d981eb080ad0c8c40301f9b54689bc6146419a803d88e9a65bcef6eb7e38aca33d9bd310dd33c8bf2f1e10bb6d639c592c84b7ff73941165ee47a7d802b55258dfad032a14cce9643076d66c13cc82033488f954557b0715dc550efada7dfbb500d0e7cfb1f76423d14801de561e96482a4eb8883a61906b9856f3e9e686cbbc1f7a0f79c0bd4a3414bf868a0abda8c20e547d892d998a7d9b9627ce56452a2b4db0b8c689d6788962903911aa48fcf5cfe3b953c364ba303b05daf49757af4c47a4d1de15ad934065c2f87eaed33c4db30875183f8c5b3f5d3be423449812e88f8de7bbfc3932a28e6cfc5f4375db3b2c6a3cdd207455e8c8f99a6f71163f349ba96f44ed8476c5af2459afd5253a7f10830a1c244397b275098d4dfc650217f1275f1796e91724d7b8c8dc086782f0a317e04affb762297b7b0b12de5782f1fad26d4ece5662dc62ed77dd1dc08610b6a1ae817017830e0c2a789496941429cf03394deacfad2737b626433e6b92c2ffbac6889c1fffa2889876b0482a695216400ba17b241543566a2883df802052e6a822e8bd3a87bb660887e2ebcccce97289560c7567d2beb1d7bb44cd6196506de74f579987fbab9db46a11af9d4dc99541037b3530020aa859b72dbb4c9096129362524f37f5c9754eec7cf23a9d98ed076e31a14755c242249be2c89afed523946ce9536403bde882c9ef988d285e1e06bd79d1236a1200efec2c019e57ffba309c1203410fd5ed9f6fdb724719b3d7b18b300aa704d24babd74039d0001611d794be43cc87733ab7bad772b56d3d0dca8d992120a704466162fcfc601a70cbf71b23f10d62decfc393eddbc1c55e2f1d0875f57f6ed7995d345c265d54c096b10199505d8bdf42e8cd1f7ca6d1f827b5da23fb9967cd25f3d59ea4a2e98efa0ed6697f77f8f44ff0686de92b925b7d7c5c5079fc1649f9cbea99ba6b8fa18fb0874438e1f31f3ea8b30308a5030afb8d93e2ba7145903fac289aeb92b71b3649f628f36deea301f9b0e8ccc28a6f457c6256a482d9bb92cdc2c21255a4b77b14bbf8c958c669621a38afceebe31341b39817d349af94a0b6a5c688781e8a2957f154671a6c7e0fb26a55d912dc7722d287b295876a528e5eb9441a085941963286371e3dcea6492b3dd8fe80edd3b9ebe0558750272c1606c43b915715561321afd83089ab67f1516c2bb57875c91958d2c6227450bcc98f02e1a2cddfa61d4a85f9618a411c8bbbe5cf070bfcb2e4baf79107498963850ae8917b114c4ae521db01b6c1941652e0e006d6ed71574f1944b314f50bd78a4fa9901190d919f2b88ed27a0d6383f7041cdcc1d85efa23011809217ed62b649a75427a1645b48b346b73c76657ce33df35c4032be7373c0cdbfb740e3954001a976405c53bbba8b8c75271f03c563e75f5683427d4ca759ac6241b0fc9307d040ff32bbbde4df368980f0f54178bcd0f8d44d8ca80847cd901074105f0b2d323bf333528914446f34cefbc3e59125df6c980948bd5a8db6af60aaf614ddfdd1e9b3e4164979384428bcb26555a3365425177b3ba1bae99b62fb63b01a63a87dbd5efc82ff7361804f53619d80af743a87cac8cf672cfa592fb7a96c066dde9726200c5715f6f639e3d776b01286e192f1e3aa18e8a2799c145cdd3a4706658d0b8985bddbaf1281489b20a2a3f7e5defa1cd5c2cc76ddb5074e0165c110d78ca749abff1e41a6db6135ddbe725bb3498c2718ece79a12505a8d0f01a109c8cdbd3a9d60db88cf1b53f956d57ea4f52916cdab9d328c13ee4a865a40b673e9c29d4341251fc8362337814c5227148b1098687bb20fbb79e9a8994d7a1fc424cd959282d5146950dbadff366dfa8a81f1daaf5ebf9d8cecc2d846125d50b0da400c986530c0d66b6d113de5a0e1f222430a2844581c612ee72a1821d108a287026cd0317ad5420dad5abfd483108a7965cf00e74b2744e75b44501b3496839b5d67d2c4a2dfbe3b7a3f651e319a0affb1075988c939fa523c3273def61bb838ed0df5e4443987dfa4230e6b07c1db66c792702b6d47a6c3753b031889e8f06228cd185d363a81393ec882d4319c45b58e022f227883bda9bf1e878a2ac28ca0f28fc8df0910a54291b5f497211ea5cc1580d9292be3f3a6fc5d2e653fda13a1e9adc6744438706fe4dcd5af612f8c29b3ab2b1644d275df4b7a8db0466267e6eefebe0b6ee052272e861cb4577c5c8caf50f2e9bbb7153704b04106b71680ca341eda2e27fd80fbe2bac033a8a93fc8b8d25110e73d3499f447a060c9114625eec4a8e2d3a42d9e7f486305691b122ad29d6925afef6940034748fdc7d9f07a2ac20e4f54c3387cd24a53766e395d4f7030804b8e661be79a4197818007ad547728e6ddedcbddefca33be0f94ac9c79338e50ab1d287a231a5883a7173689000537aa4350fcccc526d6a3a6e52569f0909bc3e318fcdc1e0ec5d0240f4190833c17da4d9462888da3683124241511907556c311fb1abb0fa64f2499ca0a6d0dbcc989f50841f6fa8966e1dd9276af2fbbd6768d6abd54544171416779a8fb6425246ab3bb9dda44024bb673a277a52a90f94a7cacbddc6fe8a497bde598f8d26809d67bd2a3d9cfe7019e38cfa8b6c66d2b6e266d885dce1e3f4c140ef0236aa1a7e92ce518ab4f166c1dd369d804d5f366b2c8ee0bf463a77f697fc208953962891ab51d273a0c9012ef31010d51e8b102205f82e246dd275a724b84b4b10f7613b40717fdd25731bf71274a7d07af395253cc43b6e52c68c6199d872356c399f957b824bcc18fd09ecc1c3c2b32693ce65488ce376308d55c90b1dbf1d5897b3df7fcd49568dd708ae35a5b1a2a12aeb3bf84206f05636a809d83762587e44200a4b85318858b7855e89daa31ef8d5fcc9a8d0daced1dd8c2cac0c6626d9cdf1fee1f89cfd4244cdea11fddf34eb0d091ffea295c23717ff820c854fdf18e301a199344463d179fe0735564acf8525ab787866589da86bfa5bdc7b1236e58b632f06cd86e172c348b478ca6b55798bd77d44d3e6d03e1ec74e0f7be1f96a5b8c7396814bfb010ac8585bb1a327c1c5d785f0b1d91c78fb48c1d3e44dd18762e2a74f7d0b655278e2c3062544a40a474acae31574a984d9f235d140d8298a6e2f88374ffecce5c030630b56e73dacc1df11b5158c0a2a1ec3c42a35d930c5dd39eb7cc38fcdd738c354b03b6b6b3849e2178a6028c56e52f66f3399abb7f9b8e413cca8eb5b2fd608fb43fb3ba2f85314bdb90a17c04038eed6fec7093bcd4b3c4a7cf3daf8e39f1453ea3eba1acb718842ee431052c30a57b83eaf8b476157d6376b8e3e9ed0b57bc61e269ef4f17e41c854242a6f00e5f90fe95e2bb4ebe85072683eefd631203c6b5d3f13ed326e5eef2f6f822b71222ba615bac9772c8d96e1d1849c8280b6bf61bd918382353c12c3e7541ab888fe3f5a9792ba35ccd4aaf52e041d4cecf9cc0d403c79cab6932e52d555d5d5c04d3c4a17212bfc25587fe0fcbd558341d0e883963f8459b8e5efb36ea9a31891e3a28f98a0ce880c1a0bb0913cb9e227f42b20298cf189829cc9aa0db16514630acd404d306e4ad880b0249454fdaafcbd20e3e8453e9f27f29e5157914eb699f4bbdc4c9d99f642f07d11c5e6bcda7dd249568dbeb01c8983af750495092294b5429a8385fa83a7172508cd4e25c83f11e6977eea3263a2d174bcbc0c869dc56eeee3742fabf997d84555f57047778d6e90c5ecab1b7944908f611da9091c314582666fd2c6dea213f5ec7469b3bca0b1fdd22ead1919940084708287315940e96d6c85ecbfc47d055007da68d9db6b800cdf9407404fa41f7f6025c6206868e8044aefab7117c12d5f09433182998a065784d4137728c92d5f35a7a984fe0960719d1989f0670461bab6798b0bc030650ecbbb493623c9361eecfeffd919a6fb5fa3f2880d44c5a9db14a9ccbd52fcd039fe01e5553c20fdf73c35530865aa2ca1d97492c0aefad5cb7c7f086dc15e4ac2b670347749cc13d0698256f9b43179bab5d091222e5a49df70afefc96d6769b2fa6e0a4b90900fce2d0b835cd06ce491223c3958e70908f08bae8ed50ac04e3e2c0f3dc24ec610a56bcd59e9f734a10b34fc9df0450acf4d677e4156be807c33ce509d8e229d5cba51e844182a39d5c563a0ec1d3ae94fe93811fbe1e2dce05ddac9caf678469fa7807793c4984da5240be0dabcffef3a45efbc7832ec5d0921f34af3a6ae064d6cb2de44dd3c993643ea43299b29aac24763ef6c77c11df35ac7bb39bc98c0384c499f49fdb31b18b86c861d7e18223fa055fcc98dbe0d9183e5dc79dbad7390a716fe4f43e7ec8bdb4536bb1ae0f96d98ad8ad41eb07895bf0b95d8120608b70cb14b2ac7d1c5b381f1be1fa6a269122d727d93b7de272ad2d866989dcae0d66d807d18bbde568e5ba7faea428d10512fff7a2eae68e535c3a6e8eb86dddea82efea7bf613c321bc32a301ca9c79d3b0fc2d6304a9f0f29895d32bc3b59ae67810322a87f868051fd8db5b5f45fcc34d00b3fbd9b4b70795218e80563c02bfe592af29a5f3c16149155b253035f8aa9282c9d6a693305dec1133d5628d2cc341f5c2849da3cbdebd3136c746db9d484a2871682e4e79f7a28404caf826c6e38926e04d941ec8ef7cb5a454c09c9c1a8af9a8cdb44e78b77c83e65a87bbf4be0a7da06eaac309bad1d890b0e4ae9d496cd07a4063c1a0aff07e3df61be1a2d05822c8a07ce36accad9f4b0418adb7f3fd7c5b8725329f53abf5476d5652c4750722cbb78e3c1ef04ab3ebc1637a25a16c8d9ad10663e350be4056b9a4b915c48b8eda65df011d97672b794e1c668e11261399ec71d601e79e3f80724688b5b9b98dbc5b2689bff07970f268a5fcaa35493e00f14636667231fdd03f78f678ea19e5cfabcd11673091c811b2b2a2d391450b99e157511cf50e68121d016abdb7bc75fd5c007dd6dab2b27aa808a8e529d4300ccfa594a0992dd4c2df6be59fa2752bf9e5b7a32327148c9e7998f8de603e64131097546b722ca84f9695f32a734e32ea526159a2ccc5e04dfc7adbbcdf43c5a990a64ad5b39cec976265a0effbdc1a9384ca1ec0729aecd24099c613bb847579f3e0b32149a599e35716f88c035c14c41403413ad1aa2002b8e6d5982eee4cdc44db8e9a30f6c00af9ca3efece890bd26db3751af012fe8fcb8ac4fb4cb57e27c972fa0ab0447913efc98270624511c1709aef637fb339e1267b88c32c189684b0afada2d38fd7756317ab6833735381942259f76b825d22f847bc70526f56662444f11c34cd0102ef469f748185e16f7594a4bb1c3c4c1e7f6f04e941b76681ccc81d3c9278fbd69db30d7a0e1be31454e95963c1e954dbc8bc2c2deac324e258fb0b0f2a4ce3f2aa345aabf01781ac9fd3faf015a796e8670d32660c6409f9d1fe3a03aaa0acd38a1a4c8b80ea13e7dea4fb333cdc3565c36fd3ef74ada16d572d4e4c5f2772f19474fd63c6f5b8ff0383936ce80bf0cc0359cde0ca2c3c09e89b8baba0d3ae5bbe5696ae63cf0286184c1bc91ef48d506a9a70e265eaf6bcf56d8fd854a1ddf7268bb0f94a341aa3fb04ac4d345c76d918b9922ec2f5a1829fa5614d85c78166f766726e5149d2654b487c11ea50bcbc9372e8e5cee769eed3dfca8e47ed897db93577ed127c7f84f94b983a98d6e066396d882d17f3454a006d3dad978a8e19198579a96a26e8832fed1f5e0852a23616eb552308d52709846f6c58cddaaf39cabb4b3a92d7b284d3df2eab8b6100fdce7c42ef2a999800a7aeae06d330e8d41eeb36463ad7230abe9ca98b8edaf06b4fe625f992f730d796aba0267efab3e951f77590aa701325a60391f079127b31b845bd80d66e63cbbe2a57fa9c7a5cfdd7ec988c6c713d2e341a447888586a09f945b7e4c664f7c101f4b24b4d32661ccf04eb93c279a818743bdb04e8df1b656088e4e8b888cecad6fa9b54a3589b2a32865169071a684ec936c23bd1f69a55ca29171120f78183d9516c6a6d697cf18dd02ca41abd47b327793675d9549b1b74dd9099dadbc61ca19d6f2a0f82c0304b4526b9128569c679d7f4aaaebe0a5ab8b97964cfe66019fd4ac2d78007c2de7fe1736c743f319a08b96316749c1f943dfccffc94d1e9456e74e29c6c206384cd7d6e4d03707b2eb564f4ec1724e7d10eecfdb49284144efd0a933756a13ea6e556c2b264cd727eb6e6e71b4de9a41cafa9bdf7eab9fe18b882c3c2bec8f40ede4ede791adb5a02fd270849d25703a9f9c37b5425fc5b930f04290a583047e982980aef36aaea7506afff1e11f1198be7e0ca89f10f406a60828a03ce96283e07094e757b3fb6fcf2ddb3e1f3dab5fb662f4d4e3831a06c910b67f34d7eb9294fe62bf089e5c67c1729bd98355374b2a15934f25f662ccbc9457304700a0c53c624952b3dc973eae0241a4c9fd4be8ce7e4ab8bfaef4111c6184145bb07c11609f59cb17ac9e0d3b01ca92ebae0abc4b572a0cc0e7a42d975531fe8b7b1b4c608bbf0d2e5a2f510273c959be5631a0628900d9bde5a6a6a789a2b97ba129d341099d6b657fcbfee9f8d09b9f985e2ea66b21cf6b4cde9d3497ed8e667fd018525307637f519e8fe1190e102b613b435e263f529eddd1c1178a69a53e7e17c7115fd361d3a9f56c71ca00b1bd708168625f8c424fe2929816f18a244d641df1759a75a2fb326692cf685be3a161cb293ad08d2828d3b27f27cbad0d86788e592f760b3ef9a52afff7467f221932bb03a1528561cd63a76f3bd85e70063dbd8b605681c3638e9f457ad553258d58930baa16ab458235b157643c27c439d3381f78a05cd450f579481965ec68453284f4c77f2a636960518913e080acce21f229ae46824d6a8971de0e782534e73eff22033d477a636cebd6e49a555c502a4131080e554d9058379c246d7606a0744b7ad63629fa3cea5ba04ceed19136ffee59b0b9ec5062ad5c910af0ed162abb71c501ae24bfdc0a2e6b60360adfb3f6bb04c255eee6542330bf9bd0c3989e18eef8bea909f4fddb65c0bbf6c55ccadd4f57405231489f83056abfefca0ac651a51d90ce5cd1c77fad9ffe85d5f2d6460ebcef6349f581247c803dba0ec6cb28ebd156ed19eb3392d7384f19e1c9a233a4b26a71a0ac04c658b0dbeacf8b4a72e0dc01e219dd00d376164765eff4d5d55b7ccb969f5f5242fb4b90910a9941a2e24002a09aff42315950dc0b4ae17d467cc0beef6061d9c3df978a313b5ff653fb4c7d4558e59866f1b954c71ea124420e50806f63a61779d608549a8423f3c71d048ecdc6f42a161191db4226e4136f608f72b317bb2008ff20f5803e0ee5f77ddc0cbc8bcfa0e9b36b4e67563588e705d4389e2ee0461a09d20462399d3fed004fcc3544195dee311a55be934ac88cfa5edf961d02331a1796b8da319dd6feb9000bc1da6615d7054fe2643773e2b67dea98b5ee814839655522bb5e4e6e19a8dcb13cdf19e1f98a76e573b300130f79a4f85b56831b3bb48450bae6f0f50f7930797ca8c99b35df6c4224e9c0bf105db2aa9c95fe2ddc0b2fabc5f0d0f8edd91b070da39a937ab60597b0048a00d56c156f15e5e372cbed43c927257b5e578dce8dfdb15e8a2d714b3c2ac00e6abf929b64f5836e9d65fd69aa63f86fdb8bb70418d2cf5a2753cc64f4c89c882577d209db789af3bea7c877effe6cf74107b357395a86f858409c4094b30f71140ff1ea8e4fb9b85936be58e6b1b2ff5627526b5ab752588933d285b582b42159c0795e27d7f31851bf92a2e8fde14d70a587b7f06949af4848046d8d863ad81b7ddeaf77a27b40a587a7f951ca546e260003bb83613b839f9bd9d537c1644099860d67d8fbe3721b28335b7647933e0509180542583c70aa2a5e8b59aae0d5b4bcc5cfa34e5bf0bed3319a7b096b2db52f0218fcec8711aa999cd76a3c61c886d63cedd3d4a4a76999eacbac707b27176e3e94d102ae438efe20d7b1f8c71ebb34a634a9f42263f25d80624d9ad7da9381de0985d868aa34eb7b87f676c6e65e6b9a649e4b7ed4558a26eb1ee26508249c29f4b37c7fdf484ca4314840970c6b086ca38bbb5185227254ef09337418106d945e6c199e446bdedab3e551833a9d68396cd13cd6b63a159a2819a1ac2e426cd3142e7682e538dbfef39be952f72ed05763bb9bd469b4034629b161a289c2c5fa0bb8f94557a76ad4a9e534827d1a2abdd4387dd33233daf895f518265ccd6568bba21f56ce91851be60ab1fc3fdc05c945fc533f240816fbe5fafbae2b2cdf20a4f4adb60e98e9a05bf8c3a96c296cd9043900c4cecfa5fe47b364f1549ccf24710bc6886b1e50f3b729e11d8f0a0c41c6649c5579dec079b93ab558b1a70784fd6f36acbab8d0a7266e6d9dd9bfb7a31e2164bd54d526d3f07de4d2b369bd00fde20bfc8db8b2c6d3fd03b81e2a11c9fbd883680fa208e87a07dce82865476b89041cd594f6f7dee53c6b577d7b384fdc2dfc326b4ed6db4b0a3a0611304980bc53449f1175f843dea064f9c098cbdf71f75f7e5828b3c4549e5d38ebf7eafd1c62417be92f7b71bb6da021c501af7a01b4df2b6fb1875fb36cfcc72aaa3a48171c1323375634fe8f0954b16ec589d6896be0b8d5305e9797752399935f6ba77cd01b90fc720173df5197739978f88d100cfb258a2aa24a9ca6fe45fd1062118e4c43c87647c76b7ea93c88e0a3e7e2e436d78c9fccf389a8f65556341d36ce1e51bc328555306acbaa94cf22b07467c5fb4aa955993ae5ec93ec5a6c1551ef96c55bb23cf9c25ba719c821c03e5b8ee20e08e91ea23c91190601c98bd1ce6548231837220944133566b828579849675bdb37edc9c9d3c472736ffe6a0b2e81baa4ebc34aecbf1846522085ce162e53229c0ecae504a3e6039ce021051c305bd9061724e418762c38d04f1e0bd9d6c0feffe68ce8fd962b0dabab1cec3b6f66758f2a9f775150befd452c6d1c4ca9de9bde73237363f10c3c09e2ba39f27d9ea833b96385d09b5e388502418c8c01278aee77185dd63991d308dcd04ba9cd4a81b2f892e190843a3bc38e0ddd2877ad56b358f57f57ca0c063b8c3a36a5e65b06f6477085dea34d5c158b2b2c21d0dcf946a6d88479cb46882c47c3503cce25c2a23165bf895576f071426e0bfa92eb3d498429bfe9dfaf6fb6f7f520938a228c15de01e0cd5b0c8dea1b1365c30469ca00aea4288b93debf1fe2af5d48f7d847702c7936e0015069f3584f61dbdfc8ec33bd7c9c2fa900b2d350b1de2ebdf675da9c48b2d62ec1e78709a53ca41e61eb1febff0d4eb1ed06ad09e4c4584a07ce1b5fdcbf86f0dc8dd7915fb869ef01f9a5ed9f68246ebf18746a6ed09d4061f5b0ee3872f1da2d9455cac2340d238f6aa616faefb5df254321b4c8b6f000fe0597e2e6d6030251e67aaede0a254ea0b9327b4abd04e45d010c0458bc95687729d509348f0bb7ddde7e471e6b130e439546ced3103676e1e0cbccf7e89bc82e2a8e0f3145ba3ebc8148dda77d5eec8d63a4144f93e4f1694697c1da163f5a340ee88189511e1425e8632986e32dd0da346cacaf66c4ee3c423f6bba79b89578509984cca6425194b884dfdda7c175f1ff27a9b98ec9235bf6907df56971138dbb39549f47112e030db47380f85f27d483eee9093a209e8076561a0f7cae69f1fd5b0c5ce80698c3b3fc2064fb5529068b56818738c50d43278b007071a74b26bc732c71acd816cfca9607ca9672b616c9536ff9237e8310d728305adbd03b06d77e5e1a5fd10bdbd1fc27610a6d4295d63843ad424cca147cba21630f9da6f0fc302e8ec955b3f083ca79cde4f082107c1af18aa1da090e71b35a10799e964b7942b558bd159d87280e153644e85918811d375ccd10e1ece889ccddd68713ef53c5a38731b711c4ba5b519ec293f0bdc6e189473bb6fd47c149676da1192cc9d5efcd664852bf7f1fa5b0524d954a3c5b292b779d1a7474307162b43a2d0cc2bf50b7ca2225a6c89c5aa96dbed812389cd72eef0e2a77b949e55200795b1efa900c878dac83c6cf64316674afc81a7b997a390f5caca15a953b52ef9bb0505c7eb738437d55692cf8bf21b23bd3b1cb60228bee4f5dd1ae588bad10f100f7941e15c13026399aa88b419a10dd716fc1f6c90edc9c3c3dbabd2ada34227f57c68bd9aea645b05660004cb56889c71207d2c228a9b415391fe798f875dfc5221b2f8b9592a482568c7d21ea6450f676bf296408620b7e6c0f4c747eff550f0929911eb275a567bdf07c6f2ea14f1bae13889c2aa3b86919627b2c7f182f68e17af238a145f0c288985acc2044afcb66ed676de06e228aef25e6caad5e88c7cfa8d35b26116e734c9613b98f839366e008c14c807c401fc54da573e74c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
