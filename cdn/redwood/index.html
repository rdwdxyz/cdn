<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09ff5293d3a0cedead5a95fe7efba89591cd5230ec3ff9469a907dba2f9df147ce7befae37c2988ae783f676c1653edfd03df83b8fbb2b8d312664fac748aece3ab6eb00f6967acde4cd300f9f3b8e62ff69f19bea5a5b9df6d3d968b5b7da5ffed4dc3998bd50638100c7671802545408df9ab20a26f4e90d1b5baaa9fc0dc8848449a53513838cd90ec742f6bfbdfcead2391a6d99011702e1e7b97761e714494a30c946adb411c193a2b1eb3beccf8b5ffa13c832cd817d0ac5af60c5a4fa8882c654e8446941f722b5273bdbdad3945d7b62eff57da954a6e505d4e48c2458acf2500ffd95d41def7135714c7a9e61ae9b7fd8c3c7187ce8a073cb276dda062dc7e939254bc8494566736535c7daef591801d8713e62575e27ef42543074ba9921fd3f373e2254638fe0f7f40600f8f2073b2af8ce7410ad224ce7c31d561888accddcb8b5170b10ed468e76d463db7d7e17a4b220546471532ca8bb96ff9826e5db2aada6dc6bc7ba452426b32227fd98c9b1af52fb35cb1f218dc27a73a1b150d93c5bba9cb7b14256bdb35ef42704826314d43fd6adfe7993df85260071bfe3ad8fb31ce4ea528654a38b0cc9ab824b5d64d9322d17fbcc4a6586650e5303022b686cae173350015a49860f7c6a87b36593bdbd468b2eb39eaece657d0923c5d1e244bcb7b8ee0ae6dc6ab6cd3b6c5ddc5cca673bb9af4f8afbd6ff466a2a96581e3d05ef5da79e44ece06175cac81531e1c974e9b159012a7d555b7d28d8d52f893f29d72a8dc15ab3d4471ca20cfaa2f3f844a543f3775bbcc6ceca5d1ce50b71729e34baea8f498fc1fa225e17dc19d113a61892688aaaaa2d298da6499cf53db718589c6fbe756aa151ec232f2fa54c3a6f0960a222d0c801829c3f5c331fcdeabdca17728173940215db9cf9e128d3e73bb7d55126e71d08fb1117bbab457be911af64415028bc446bd2ac69ff29c941ccd342150703d095bc03a27944aba36abbf331b79a57bcd8e00b87c67689e45b51c13cc475b07d9147942c8247dbf603338db0ea593cd67d9ee3dfa35ad7c352ebe57ab016f02e7b1bb20dc59d895b5548bd21b9d1ea3febf0bfb46ba2da1b74b3b8528b359f69a7c1edf777871dbc22a3444101fafeff19ea7f3e14d4a840ea61d6c55e59d7a0ded5f990aab2cffd2d6bd66ae9b76927b7bd6bf732cf6652fd99e1c0cec45a90b0f4b46b4751917e35d79d358c9aaf7ab551c21d1b3cf4e2b815cd0575b9e66acd1e91e1715f55f1528a72ba908505a27d4914424028c4060131a1371329181090542816903f3bc4a5d55a2e9cfd575f3614ccaecef76c882144243ea5a19ed44ffb70c1842126e4d265d7daa866d4f9ab294981cce63a4de87d4bd57b586574a3854fa1e9b4d53c158c9c8542ba2f42996dc51ac51b2b1becf0c13670943b62a14e23eb2cca1f5beee8935369359e56a7613b47c7db5f8294c71e061bb4eef3b4ac11cb57c59c35d0f48fb692b82b382e2f418a12dcd8e59cf5faf778aec1700ecd76ca86c4c34bb763e90fbd1eab971ddc12415c1a8bc56f5a1f1e9e6df1fbc0e16f71522992c2b9e031781c99c43bc2cabe0b75d67c799f3bbc8302d706a4609b4f25d6ec484ccfc0e194640980d2fac4bd1dfef8e1ffa8d95a5574ee986ba44a3b46febd6bc392dfa0e64921d2d5de2d180173c692fae356d8edf5b65fbfd0dc73e5053387ff04cc7614c89ac8d92199d148467415b5cc4773742349ce74c60220ad281d5aa8c2963162eb088b1d1cc8308e0be24e44f5f479ee0e48829d13a0a72c94d6876ba1f4cc50bd8e8ce13f9e78093f19616a5e0a8f6160c8618ec2040c7dd11d036040ebca8ad3a36b7e00b984dc1b154ac601f71046cefd100e999881e234d557b575dbc1ef4702a2649ee3c80d3127d967c1324b386af54d02ada613e2ff6e330ae4b7716d9c949946e3e62ead03d4b26997facd9b2050dd4a379375a7d8a50a99cacbe002aafa8796303263d4b854fc3a5981447b4219272de73d389666ed32aaf7c2bc85717fb81ec8d8ae0cdef3a1dd32c67fd75f1165b787a629153a4dba3ef816a6d5bb9c4c45beb33010f6fde068b7c5d9a59560305084d346efb4fa85cddb9b2a53e02342c9bb8a3926ee3fde5411239b6c6784f966343ebd836abf14b957b98182134be7d444fdb4355ec34e046bbf6c644578d08af82a9f9a3107fa86e713485ca0a4f64e81d0193141a05d016af18fc751699f0b318fe9820a2a1f2fbe5548da4fa108fbe16fc46f7afcb52680975465a2462c075dd094c55b5c4b7ab91888c4033863459aa91155ecad513ec40032821b73e353ecf111ca03951e0e1b1f4e252cab67d7c8b066f359c0854760013242091a7800b9d695dfdfdb2ea7810b7b7eb2708fa1df68e6d50744db9ca58dfe5ed7053b47c23a109ddb4967bb9cfca2a228a97f51095f288817771c5a9cbeaf667343d3e8ef091a6d5f905eaaf828a7f033cc4df6cb5378015125120ebf3712ec02a29e9fba3221ffe6cb5bc66a43dc1cc580f69d3f2d80283b7d9b8f9bfff4731475732f17458ac2d17d696d42ef80d50a010db43de78075cd8de7e6ee2c0bd8a34abe0279f24904aa3b29189973d9a3a172e512e90d2e8bea9e35ccab54bb707575676e2d27086f4dcb17555e2c121c94381feb803dc1d6eb280fc1d25197d998c050351cfb76296b68d4728bb2aa7b5aa9e1ee24f361f5055699c72ceba7ea2b3244161648e851d399aba4437215f41c40c7280ec88bed4ba7344ca95edc48c55ed674296853ac98554a62d31ff374e5caba8df1d19e729d7354bd63f5eca8119c9dd062b9502c92c046dc1c113955951df3d8e81037cd0c7379786062be0132ca0925c098962351c19045db2ea15ed00bf1036d8748fb5e284e6e760d4d3ef63748e8df364c91ae3bfa3f707e8440594065be6ea5e692042d3eafeffba4de495ab29fd2bdce999ae21ca01103dc7b4e0e317761abe8152be28b4b0388e71d097abd9c2a1238023f5dd1c72f9d79fb3f06e814b313689ec9e8449fb1cf3473cc74bbcaacf4adc97a712375ebc14d2ba3c873e678d7e74beacc0d2b6405763021f00b7f651013efdd26731eeccccd10fbba5f7f6697278ca1f35d5e687a2492b6921475009f99ac810b4692a8402529b6bb38f5ad4d836701ffdee83aab1240c7ad3d2e9e33f9ca312e04f046a6f707cad160fe307306d8afc674c691fcde781f13a372ff416e2dc922468bf931ecc7deedc350bc89cae8c513de3e318e1c3c60be0ffde179347d0bbce2165f26155655d1037f2d9b430565b5a4f7410e5d3f24b24ea6571236e773aa48746271f35b9823d98d0ac973b39ca7d721068387ac1736cb540230d0b7c93bddf7223c390df186e3edb79ec0ea5912f7ff26c89b13fb6f0312a6057281923bb1454a5dd75ff9f068f639baf382043711f0d597480cd5a2db9e4d424c181050a1b522d3ad5ecf6ffda6b44590816c2d6460951f019fde87292707a7772b2d1704fdb9b3fdc3c14e7d666f1eaf1928e37c943a4913345436636b9c9cdbc5d912df136c6500bc49f33ee8c1d52d5f3dca8774132d1cb18f66f11d274b5f2842789e1e69551f2aead608fe29d691ebb286dbeb4f2916fa332ca8c7c2152bb338f80a25da7ac7f8e4df7fc4a9df315d13d00742c3029b6e927251e5a61c7dd4e9ce8a446d4a4be6e084c6108ef5d2b80f54f56ee6127babcec6e0da4e68329d6afaf7899497a7a496d67dc0e562e9b45700a5abcaa099d81279f843bb54e0eaf8a8690c464f9f9bdfdf291c826e6f7a8a62bf46f13d7642f178870667a7cebfb51c9ab1190e9beb9fde06a2124cee3326020d361b03586b49410623f4be43a7d96356ac29fdc0f4d2a53fa742be223bddbc60f27c216c3148ca57af97037f67e1e049ed2a575fbba1220fe6bc3badaf7182653fbda0737cf59ef8e5e1be12746d1809294fd97cdae52b2abb1ee87256e2a294c35df41b4d5209cd123e70c65e2cf595787a7ddb4219eb69e7479995b9798fefa44f8784723228305706cf1001b3b1725d9ad5661395dd878b500149d7da5dbcaa8ee4af29f68f8b21eb66176918025040ea4fd2f0b55917a77190147c9238474d21da5784aa5b19a509ff2a3245cd2f99cab1f3ba9cf6b812ac245bd7e8ee27f8a526b46680c7f8100d9c860a8ab8015d627e223e7dd268211c6bdf3138017dc28f19f5730577da80f8e975ad68671ff27f949b37c1572eba3a478f99d2e0cde5b0da416aedcfd5adbd798b19327a23b59cef0585268945c8c3108e669e12fc0d7a385ef0d24ad01a72ff144cb08229c74fc8a7e0bf230be633cea9c6392e5bdfaa70336b81d3d3efa30cce3137b38ff041bbea15d901bef95e5ceb48ad771a116e15e5b6ab7ee9636caddaf104d9c9c78b1f47993db65ae9885afc33d1132bf8b0c8a6d77ce95d347eda7e731fff9bd1d56b2ee249b2b4365eb0afb6f316423c5e8fd335d0c9c4110bf2647644d705fa6bffae12db91e07b24fc327f03e5a73ba89587078017adec31e97affd85869c3bfb50ed9f36cebd06157250f0d3dd8cd1a2b8254b9ed5df3d6fb27e81a08c77ec3f939e769e22bb7a17b66e72adb63e6da70da56f31bd904652b640ab21a0519b4ec53fd283177ef09f6df4d8ae225e4cdcadb1b6d858b93d853b9928d984e1b1f03207c487b57a64ad6ba9b4eab5510120c12a3b24907e7760167171abcad35564179a2e08da63afcfae7ebe21e483be7e1bea66474c0ac00797affd3779f47640460dad992901b9a9550fb223c853fc2cc8acd27cb2ae741bb31886dd5837f60c49cb991400c7b2bdb557ef7e8875e4e38d7e99016e99852d47063bf3ae50c5c8b11cf8dd09e833beea61488a66320426ca1b61bc879898412515815a35c63fe0abcf637040ccd01632560e879f296837483f79dc0c2846c4cf8234f34739d9f14a1a4c8bbfe38a945fb6b10e67849f960bc95f80aeb68924364375437ce3519fe9fc01c6cd81ca71a4eed24669eeee271fe45b3d152bd4a9ea7c9d729c3a9dd48138dfeee5b73c4389abb0a81026e75f5407927d7ea9062ec111210c533e99c77bd8a982f992ee010231fbc2fc2a638e35684fe3dea78d33a9f3a582183607cc123cdb9f97f5444a019ecf801ae8e1ac5e48ca2d9c6753fb8f3a3a40ce738834a40c74a09c4bfffc9cc4e1fa10adc04987b7ff1d90f4852ad9f5dc321a2b6a85e2f37d61cec053a5cb7d7592ddb2e45272327879ac34abb3d3898959d35fc7265696c99497eb58f1d835cc6af86923edf4039f33455bacd91488cb89d5713da681ef7054db09a48a524babc3d5383aa8a7b547e14da9e4590b54cb65fec23f7b028a8a9eb9ad2db6370ce3476870d5471cffdbfce3af1a51cf282979da9fbee82e30942881ee30157c6ade5101a7fbbf5de17abb471ccbcb17b564b47212471ee5713983625ea70bec9b169b157dd7b8c7eed07a0bd0d23a113775c9c70a2219c96bb57a905b0605c7593fdc3d0c2d4191cf8734e02eeccf981db86c497c667d03402c06f7ae7e3497119a9ccef0867ded93edb7b8e2bc7ad4942bc003f88b1526667819cdcf3f36ad733a2933bdb548a3ef80e806599cc9791a7aa7f20802d04c3a310270b0bd409af38c397f61dfe64da2958aef4076d95161478fd7d402f9a5a1139893cdc131dd7204efdb7759789e8bf29db33a987b22fc2672f2b88d3ea0bfda36d6d6e1919763064f13d100626e4e8f71d037f7b5f4f2f80e93a0d7c41cce787c95b0a836925c6d6ad8a4d8f0361b48e6ff1f8055d5c73e5b4b12e332c65dc6f75dada65dad359d44f878c1b004aff5ce76d0f00082c27221d7b8487974777f0e1de59399afb48517b5f0aae5845a73c2e381fa4605ee78e0c81c0018f11f412bded31d74b5f1eb9b07f50f3013d2561665b2cb49f0f25456dca5be86f3408dff251bb86ae53b3f059d7917384e6b91a33b2c3ccacacf13b7d64b3a01d8bdeac85fcf014554ea29c08f7fdb4a268d6de07dc3a3925c9440a336aee86f94537fc2edea6f6c2092d78b69e1332113195dc6e80864a208efc18b96d20951523dbee27453712323ef88c2c5dca224a9b9da6396390761507179df140fd4ea91f63501c2b528c7f57d635aba1dff07753bdb66e68e8014088b17f7f0d8be51e0e5722734ff46a65ae786df04f316458edeaee296e6794470e9fea38e1228dc188dc0b9ab96933591e6a11b55121d2117e63038d89090ffb421e50c67811cff0646d93c8e5f401551289c957a3938ddd3db1824d2166b04fa454b79f364326504e6d1de82da7d6ce0464500c6a7a52c5dbe6224093ef58be90932bc2d76d6c06889ed1ea15469064b9a4c02b4395329e3f01adbafdb4fb1f0a170a38344abed6aaf55dfce6578e37800fde683180d318a9f861705c6d8816e15a496c676e741f26d52f4b69de4e7aed6787e80a1a33fdf45245f1441452703d33675209fb5ea75884499769043c94e58f038735efcda872f4fae5886ddc3ef4505cfdc1d7bd5b92174780f80aaaf742e14893701fd2bade4726bc7002e92d40134108f15f9d25e80c1ba77e3a25afa15270aa37d2ac88111ddab5081db57b5ccfa6fd04a5d44fae1195a4ffea671097aaaeb0841da2635ad579f71f35f9401cb7e166a1791b52c862bfdb4c0f9c8505c835aaa022ed414ffa8e82795939fe979aecebe2ce013560ce33b93792af6ee37e73d914efbb90bc89ba4a8afdce074831ece58edacb53056dc92eb785079f7f3dad0fb531371f8dd68aef71680b96d5c7f654bf7c84fcc4a8c0442cea0cb72073b55aaa6af46670fd7aa8d873d4b28043152f6cc7f77717a9d4883d3ca985a2f0ee86fc71ff6a22691b79816f001eab794681ed8780d8aa16925a8d380fcd4b09129acaea956c9dc63e903557cff3ac6ec73695c958363b77f6ab78aed2e3b160fd0296fe9a1dd69d209321c241f6b483db056f2ccefcc6101a0ce684ba7f9d444aa31ecd2e42611b04dd5aa8ae1c2954472a66d404a52955046ec8e30a63c6bf08e013a9f634d1026228238e089c6a18f55c7573458e714735c72af8adb17ab2a42cca989a6f24259519f72cb08b6f2e3612c2783fb45af215d135aee1b7e2fca037e6dd0514fd867cc15cab9bdda9b267c32c36062490fbd485c826ea3c45252a7bb47cecc18a9f02a93e7200cacf043b6cfc6ae87fe6959edfc9219e643fb3f64896f23bbcf2e6a2c2bf3959b375a0509b4ba7d60c24532dfccbb1f59a318a1a3ee5c8729aa06da94787c3bf9ed6bc1508a6413202d0317495bd8c4d366475c41f4b477bc6c1c6ce958974a73338d5e397732c296992fc7e8735707ffb393c451a1a5bfee2072e0a4d69efca40d6d3750907fa43fa76795a5bdda6d9aef4b1a6dc7d62f1d7cb436f90aeb1032ae7080a641e8d740e2a995b4491d8a495ebdcfc3186188a6017f97b52160ab4402b5145c4f863721aea257a753c5a9b2e8b5a81c52d02121a01c076f0e3b91653619d6e6a7afdaa7b36ee6066efeef2998bfdc2b3933c85a155f04cf0e584967a4d1bb91eb1cd80fbc123eb7199e8a108829649c3d31011b4e1ee0ae2aa026cc0cd4278e3225ea50a74cc08ddbe8d94b2ea8550af997b56e1155464221770ade4423f588e26ae16baba7e72f111daffa7f8f8d5ee4818fd296e0b0131741915373c2e116e7bccef86eee48f709077c94374cdf0cd041e5a69174ccc44ea6fd0642e457e611d559534d2d39c89226e5e085b6cd95c8410dd071a782dfd4931dfc92da208a7e7c414e3cbd28e02c589e51935951daa55d73cf9740be1997cf31252e207bae926a62afaf5ccb3a7be5ad666c42dec80805fbfa3170d57c51809ade411f6fbfe569ada00ec1fa6738a4612d8a71bea12e3c879b760545568d215ceda6df7c7081185e057caabcac5edf0d91419167d9b674b6444c367b02e147ac5286c635cbd3085773d779fe98e6e9f17f8ec336d1ae2277ae304fe4e6cfc4aae7fec45d814d8c431b1bde5cf884bef357c4a6bebf34f239b54ca828f62f2fec0bea4d6f651e2d644f594ab77f66004dd89b0d5989179019c6cc68b31dcbf64009e225b36f69d22523932973dbc13c768137678e1f1766dc9a26045cb42a2537f31f080a9452f886b62430e7a270e3a03705acc7f22ecceb3d7740e8e236eab11a0ea715fb05ab80186971b920611f4c57e708f991e862c6c5aae9e3c4e0ebcba1e3c1229f1971ff11fb8a3d689e7888c432d656e6531988b6891914be5d2fc71eb577355dead0c14d35d0517d80e7c428d420c53d43698518560978f82104628dae3c298ba9b68a4e56724537a1e202df3d043462da7fccb90374a427cbad660443c874455f2b0e51e904e8d88860dbaf0dbf83d6d503d450fea1b38186d9b1c9b1022214050f0950a0ffcefbdb4674234e67ab258fa4426da30e7d156f70ea33cbb552f93c0268e7e7c90adb7d01c581cc87c0bd35ca362d8bc18ba4f4224a14676fa2c6b9538c2cd649af8022e502d6ee6a5de4343be7f72309a64c868d90258e2eca08532d10c570c2213549680d559f487c9c41300eacef75c2f1b0ae48e6e588a610b3984714781991bfee740f953b00aaffab89ec11acb02caf00c1bd849ee3253762f8651ba2cbc192616cb8ed2599c0822f2c4ab7c0a0b875fded21ba41ed668996aaa7a3cf290f68347aafdeb4ab98345126484c02f60ca4b8bc6b948f814d4a650d9436ed3fd6c8fa95be26ef5da078016611c3f53b9ce708f89f226e1258282be2c7355ebd3c9a9e18023c621a5e4391a481419ef9c0e532c5373e59fb61b94faef9b434f0f0beb2706bc88847d3ab84e610318065a5369a221cb5da7578ea5ec4e16dd9ee862791f2b67d531256201967bfa0920f90cd8e0e58a34d10efe12c643dd8493371b8409124e49a401f38342aad125d9eea58946d5ed578aa9612b960044b9d29677dd9f8f6d4e911263d06c4b4c9adf559146fe62c31e79ac6f99996028b993193bac67a3a680987bbab9e4b8e43269d86d03aa34e3119b4a65d6e01e8fdeb8c0836b7286209c353c71e6efa8e74b8386d2aaac2c50d2c8f500cb20952255acf114ba7dd8a73948f33db6fd410e6ac8841ccf9595778b920214f1d8b1712a9c635dfce79034bf7fc7d2e99c2592af2c6436ef2a5ea2e5bcd3de7de90e17f301158fd704c1fad7dd58e18de18831df5b4f84c4c673970acd199e94e51a2f9a24b6a5d956158cab6cfb576eee14c933e316c9c1328e0408a277307872fb90271e00d2c054186ac408df32871a2390f516fa0c96d07c7b992825eb27d5e5525da7a0decaec48010388ceb90a6f6df789144d28d2d0d32a11d8a3a3ccf8f447625327f503536f255c0aa2c0180d0845cafedce3f70b17db1007e5ab81f758bc6f2113bf7044b616adb179d8a246dbc29f81bc6d6b1a3d3251e04e923a5b96ee34bb4271bf860b5f931d5ec20d3e8bbc33ed036156e8b4e0e2560d7b18b6c360c91f04bfde2f3b357ace1c32cf0f991ca59f4eb89b2ab304fbfb976bb7287c885f1f30a819f4a7bfb0f21379434682ce843746c9af1e25dda6fdf275440ebb708e9156f7b5ea81e15c26d8050c6c1098144c3b3900d800df0141c110a5445411ed52cc4db5eab4849a1e3828b7ea3d8a640890a72b5e870b6079ef7a9115f1b3192f46ed335280b17c3abacc13ad6c53566c99707d867f85e36142f3b916edb7d19dcea3c2d8e433264c76f501047858185358b9208f533b5956656af3a895771d46b514fff21bede2a7efbd9d7917b7e0e32997724be0db37870195a995e84f2db6f6734fcf294361a976cbc8f3bfa40b1fb71da9faed1e559b9685db4fcb80c471a316cb29017b6b84f29cd4d80612e730f5915318547bf6403ea7b166f40544943ebf32105e2c8599e572b8c8d2efef1e59b44dcbfff3fa6dfb8fce3bd31639314ece369e281e8818e2d0e77642be0fbbb2989c04ba458feb156a128a0151235ff011342ec6af735af43adae81169370e80fddcb9750cdd87975b549996ad942db48ae462b12a367c3f7511634575cefcfd262f21de9d85de80c35f5d1f0b0edd22d25aa4da9a7df357fcebc3052700710ec7ba90b62be712027b4c91f122f0d93267f365ec0e55c9b8909852933507a1d74d433dad5331d8b71c899fd7fceefb3f2a541bb0f7f24a37af3dcc5a2a7502c3de06f6857f4ce2e1fb37ea915e1e9777ef8cb99c13317975857d8002070491f45b4de47df9089da787815ec8bb145aac7ab887f13c4d5eaa5c69960e6d75b02b2ccaad03b76da7c2df484dd4999ca7c653a0e98fe880ce2ce1dace47648f91d2a2066007ee349b365ec9deb68feaeaad17a0c25d7d4a22944c6b8befde8ee06ea74e22633c437e8a80146523dd579d811730970d82dcb0bc0a410f9e2821ab279dcc54c59f89321ca8bed5665c85a722f7f2c37739838e9b2816c9128f6d798b654b2377001aff7db660360ef5fc071abb935d4a0b7f20e8b4d52ac8fa2c04c06b14b74e47fa339547d7ed26ce0450e92ed79e7697b26f5cbbffa55726f6b96d67195c6e29d3858ffdc1ff6f133f8068395cc299bc6b63cd31499088f15795c73a2a84acaa7e8be365944d944ac25cdbcb3c3bbd444433f3b519ab16f874a169aef8932f69b098c9738b7c4837b8e3f8d144a6c22da9ded332967cdfb8548b2f9aedf024fc61caa1a12588a2775da54cdb9462c25513fba0564998d41ef18e547a19c63c648597b87ccbc2b3d6a94eb7296f530541d644a430f667120a90bf98b4d1072191d8f0b1ca93b7e4b5a8babf4ea8ffa7090d45b6581a7cf3881408a445c9222d92d4b325948ae15d72fcb2d9d8d93496efb3f9eaa368f022620c0c5c41cd5de0e0814e35ac3a1e518f76cc7b3abffcd2f4f660d6b8274302290c314d143012221c349bc1baef2a68be95d788c78307a302ea4738f1d595013c34823bfe5d0615e5e56889adefef2945c800c33892ae78d0545caf68f4fa01b89d5275e25acd743f9317401372982a4100dcc127953cf5af01bdd175cdaa2899aef5207d93410e545fc3733046478b9f9d536c00db7ce44b897c182ff831cbe6ce32d917d7e377ef84f1ad57b29f28a660e7ddf86db437895e9415a49262089ffa3f4ef6b9fd7b901f8b55851f1bab061cf75e7a6352d757a5fc1b8916050f1743df786d8d4b286fc9eddf6c04137aa5effe8c684450404d065e57242b2c00e1af2c39c774faa30eb70bbc61da889774b9490ea9c055c8d90253739bed125b9f0239fe425f80069d69d9b899dae194dc660d79debd961e89fd37bd2d3885a8d1322b9502acef04f9b763cf727e14a0b83289ea6f290540bc4d31042c62a99b10185df6c5222571c6818d5b74886fa3a84a795e01bee5a47603e093a72896a7f8493876fb153c92ea1d59d60dd6444f95aa8c37258760e219424d3853995b44d91df9279032338daeb92ad3737047a4ce2218e0246633b090df565b3f2f4e305bd4b667a8c64f058a7def5d7c6e2f8b30e619852b9cc3fe4c3792d85852b87a2e1c34597fe608c84365798582c93b606cb5b59c60368509bef6941b1c3db0fbd020fa90a642deb26c5101257c4cfc3d531909f23de1b856ac6a68295eedc1ee3308920b7de4d2224a56632e632c1dace8e4fb28de5aae07af6c319a36da6c70ef015ff37ee5e990ba9a3a8432119d72a9b672d0109751b09237fa9a526ac1f00e683ef4cd09b3792cd62d86f5b7f5b43fd9a2264f582a4ebf88aa8dbdb369bde505a2be0e8ef2c84e63462770ff81600d94ff5b543f0f0305f9d68b11ffa8761f0a7f38f1bf69ad5e61238feca85e6979814f42d7bd9510c2fb171a85a2b2aa311fe62d65d300b1e5fef5ae3c296e39c2e712c709204e570b0e0f073c5ebcd6d8e14e8f6e4e341636e88b1feee41b1b42e8318196ff0a1550dc8b8997fbc8d17138eb9fe92d5be318927238aaafbb5317dbf7cc895889dfdc706ec20f2c689546088022bf42da2a960616cdb5b630bcd2c3b3af3073ff232b94c0e9ca023a1988d754bb25c3c7aad976d2972e8e8b82325b9873b017989222a9369acd66e3965ec8e7f9bbace56cfb0f360db7a5aed7e00abf00193a37f0eacac4b7897e29f37da371b7f533af91592165a84800c03a7d1a65428ee087d3179f9d6b5c5f38962e90ed40e3d7cff86a54b80f6d3a7b9e6337ef08e79bce82063f9bde3f921a7c3480a072e8b334c9f22b50fd144c93c3902188505b28dfcdd6b88c82590b877402921dd297f0d9020db8b5158dcbd21bcbb24228188b93e090ec0a93369f100eb9cc4f74a012b0e4fecc44fd80fd354682899658aaf2c02a1325819b2b5b8dea6778b7f8edc65affd72e45d2379eff921e77a575d5d346640b3c5420ece9d7b28a2cf6586ad0fed390159cb18318e14955a1e728f1b2097fe6a5002decb24173762342efb6257236563cb6f3f665a8f1dbda4161ceaf5cba54bbcf56b718885ce10851b103d10c29a75559dd310a09bd8c19bfd70d12090be979fa97879996382576392818920157c927b024bc529353e35900fbb032ae7f6979ff3de82c6c3c815a800ffc2e3af3103eb6d40a8fda8d7f20bdd3dc0fd43f583d48ad94c0efae2a9389dbcf2b28324d7259f80e54a826a2cc1a4a5993e2b95b65d1f86eee64e5dae44eec3af7ef7c5e6e4410b0afdd3880239163720ea2b9c9fb3a7ffdbaaf62aad844427c3b60c3ad8332be971b6bedd0da6d85b85991a76afb89651106dbc8b3ae562ec16e769938bb05a79733322b97848907a38e62d1de1e898e2d52b52acae6b50e812e9be7484be95177b94441ccc449927c9c3a594f31294193c72344b5c5936c74d190b6fdab99d170f8d11b58b5c798ab2848d53dda5b2ddaca54dfc46aab816a55e0009d6d0d6f338781d1491a7a8409ec4a95877c22d5d8e736847aff043b8156733b1647db4dbafa013574e6b7719c3bbfd6ce57d2f2567c256e91f8342b4032aab1f48931f89c6db14d0f64a0dec6aa32bcf9d3734fdce9835f795838bff8eda5c58460ac39a723affd3e1b74199fbce5eb887891df27248a0a78099c6f34a1958b82e35a171c383f46dd82362e7bcb6d363bf3f551cd6f4e6a0280c66d2727dde599554a89935f2fa4e639531edc1f630da8fe6f7fcacaafafe31047b4f858c773e4dd9c5885ec9d3f6f6eb8b0e5142c875ed375701239c2569184e957ab48ae32fef5f7e6e6641514908c9840039c29d9b6bf796279fd1bd0322b3861c61872a38cbaa6d30e177e08520b9e0e51fac66c0a229252dbb036dabfe10b932ad47139589fb38b60c60861bd63d79541d84392ab78101ddf39048a9fe3f5fb75b8f16d2df6ba7d23e1688d01dd66ce4b46ecc24212610ddab94327fbe2a142f4620e1357891c119ea34bc089ff7b69432cc22ffeefbe336c1597348c44fe1b732c3cf958a0d6d2f655df44a2cbc062b46da39a06ae1754fde652cb70069d9254b2b8dcb0f058b2a61e73178c41e01fcfb9573b6fdb725a9c601b1bb312705ee75cbd642117ee5dd217bfdd511d09a3554ea56f34b5592c30fc3f6a07f22e0fa1ab9151dbb7fc6a64c4f489ee5e72fc7f95c3d6acace25583432e0cc6b1799e6ee395d2b77559c6796abfdc4b26f3caa4c1e5542081b867d91e1a312190627a03b90e5d8c5a7ace6e3065abe4ada6faaccf77c45d6eb846248d794e701171bd2ec0a683080395efbee97af2184b2c76c83048dca3a43ade9e2c5c894913e4cfa7f3a73aaae3e8963d0cedf06b2a4b712f249a5b06604da9629ff5343caa34d1c5af4d267877f9085a610c6f94e338083525af144080d623ff10fac5a1026fb0d542f6a77c841bb4e0472f7bbd5b0e465b4e21f455e6e93d93320b6ac6fb7e1dc0cdfe35b04a3aae241b7a7a01ee5137c619a65af52102975d018d5ed608deee40ef5495b44b1c5b95ea382f0125295fadc605b5c64547b62f638fff41eaedc07662977907636f368e23ef4bf78a80a416fd38313dea189340427022a86c739998fee1938c2b388e522b85479d2a1590d60696eaddbbf1e8beb262c0b27773fc3343e7c44bd500bb2870fb2803a3f4952a41eb4f4ce3c9ef68b63e27272cff0885b9c52151ec493952848a12a214c0692393c47632c3bca54d2d40bca5cca1bec4bd9a1451028c393b9ef5de31bdcf5952a675c3afdcd671e5d76a4e50d4e074fee490c532647009994133afaf941e21e4a19e4284dde3b0228a4a1762bf42f0436013a358bfdc92cc2fe0efbd01f5ed07902af8202e6a329f4a3ce51893c6707b05f1b5980f0117138555033a7ce3ee3624f5777ade422f14a5d174f7aef312b2ee062bddc579f2124ae015aa9521ea8dd434775b7a6bb0361afebef6e52823e7996bdb32e43390739c55a0393cf23dd31c5a0babb0d5fe830ce13faf05f8fd32a40285e8d43598d0dbfafa545e009f12cecbb45f07b649dee3fe1698263729b3fd69be5f4c75bf981729d863f95372706aee3f8be4b3f6c5a1f4a6834be80a0e8c0272ff4bf5c1dd8eb2a7e651ff70c39e2f701b2b62f7e215c6854b6477da95ea94d2deed529108c8cc70e82510af18cd8e199ce9a4f4c955e5cb9715fbb9ce3ff07c87c46bdf5883b3c614ce66f4fd0b75dae7273526fd72dec14f760d7a55388f3ccc35feb9a4354279d60e39fe0e8a79704ebb6135fc6b14e51b0b00f64229f406eaaeb0c554dae5f4c22bfcaca4dd4a4a5c7531b96d595a44ec850a17e960db089c035060f9ff792f79438cc186cbc565049008ecd12a306ea6b60d62834b12d1b23035eb7daddd26377c615788bdaca91e8e61d3777da6ed1a74bd0e661db16021773d55bd98ebac07d3af25a83cf7b323c7bc6671d0425c01001a9867104d57b78ca453a8cf7bc7d9af773df8260a9d3d0d63727bcef8bef7bf9d9034f839d1cccc04b37f707093f602fd579286126f72ec124ed0174ef7c2af4b1a5442acb865e716f9ef8acdf73c7e9faace47fede4879b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
