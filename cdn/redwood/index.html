<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dceb1df40e0784b9c6fed68c07c897b5135ea0334338f9ce3b518acba730a17c67c3f4397493a704eaf3c82ac212d667c4b27f041b3a1584bc0b8a2556a3008e7d7d2b2649cda0edf4e81b6590dc21763b2c1ac48bdd1d7eb3aeff13c20f68bdbd65fffd725052860c50002aa2728c6b1ca8a6ce139b81b0f79c534d13626160181a395faf90188b3d0aede941c4abb3ec3ca3660ca939fbb1ad273da3a8713f1d7530067bee7aa7aa7ed6fcbc75b36a6b0a02c402a4a9c4a463c1d4b844e3f1684e07dc6182bf60216b32a80d6034cdb9a84c82190b6274962ba8db1af9816b37dece9714206e87043b494590d1432365b08bc79613df88ec9fa33ffd4e448d1b53864f49c5e92e4cd0988e5e42015aabb259eaaff4b9b85752b1cfbc32972239e3b0b2e4884b72107b80c4b805a0c5c5be18c56af15a2cddc229e59dfa1208e7cca1513786bf447368f4154136b280102b1617287fc2fb05ffc558ca62df38ef09f55af6785acc7393eae69af0a01622c38cfd9b5373c2985463b4dc06918c8874da90b0bad89d392d833612a108d48090b05ca8ee390aa5d54e49c8d3048b478bbfcbcf2ce2d729e3676af0c5e92fddf17ed4db250d367969571d40e2075f25852a840f76cd10efa2d68add2c51f0dc6da39616ee83198fa0c495d75af19cc5cd1756ed2d5f5e0080c33f927381fda4359b2d7284f1f39a15587b433242625f3e4af3720003f7c9ee8285f907d61a15c72d1be930738c4ccdbb7741f5ac1a0590873c4267dda10c609226127038cff663256291c968ec7c8a9a56749131b6467a9b0bb352806f92071e5378e5398295563675da93f4b21ad65e11a7d2c863f07fc680e474eea3128a418f433cbb10fd0c2ebcca96fa619fd2b896878ce17db60d4c1c67f6e42b554d9a3c1c35ed9e961d532a5667fce266230e470d74b98ec2f58b931830ee8301a14ff305051a9ac11db1b2f989bad7b2537ca20b18cd2b320c17e034c0fd9ce5d710252e92c434c3fcc2057a203d371e50f4c9dd74d8e56c47815212626190d159fa124bd18be51e27e95baa128ca463b867b55b1dd6d38e0188fe3d5b04f01829fa1568533bcea78511a634e1eb26f12f694e1b65069c5e2d00fbc590c5490a56cf287906af6a231212411546713ef62f226dff4c6aa416873abaefc944c3afb6837a2751dc78bd465f74a72a582bfae81fd5e4b87aae4b15135e1874eb36f44c27d9b84f2ec070202af87741fc415c42d19014d68957a9ebb2a59bd2bb5ef314ad1e67c0f7f12413cf086f97f15c1a2ffccff17d6b5e23b3b3768f89316f89856a7f373160478775f289d22430251612610f521ca52d0ffaecbccf1794b3229c1088d6f10ef5033473408aaf7384d386c6946acfe982e7ec4f20985a0aec1141d598742496a304c011328711dc7353d0e7fad5230f6fd0644278f16b161712284db42d4ef3e6f1edfde562efb3b90550fc6bf466bdcf20ce1fd9e6473f114d9a19af98fdceab7eb1f0cf0fa605e95af04a13fe2564a162e673f8eb5fbeeaefc4963198b0081121a6f5b87e5c0ff0b89ebbd44300fe67b5665da837ddbb51b32e702a2f6a6e1089c4c110da4ed7d8270c877a1d404559fae6a098c3fff4ecda10270959d673d462a1296c7feba4b87616ca0573a5cf479e38419906c0932f2a973bfac88690ad927e96fadc30cf59f0a2aab7b53e97ec2d9015040c016627ee568b5387fb48a4f3e35540e73f464f4d951aa61fecc82fb85dac549b0db87d669da62f676156be808582ce3d60081812875a24016f06da1e452bc0afa11a658007b7b68544475d13e6756ee879f928df297664ae0518d717413030fe62738830af64923226d606210a1ad604a64d7c9b98a884ac271d8e518f7fce25ee921c786e872d3dfeda9138177bf292e7f617626ef05cd62506ae5999bbfc1c6bc8231561dd91424fed943f10d5d897815b40591f2452f7691af1e1f20870607609d59e73b09b076f7066fe23fdbe70b1095422c910b16dfe6c3d222510b152568c2521c59bb3c379ad34af999ba7177913f643028bedb51b22856d79cfcbd9f439685e56d0f97c1e62ce7b10b254b6250ae2da29269ace89d1871b5048d0a062501ca1861e08bdb42aa87e47e123e398616d949d3c26130c7f7c520a4abf772c8fa6481f2d7d8edee9523ff85217ca2eff59f0155cf8791f088b07884734658856c8f974f044fa1a417fd8f54172f53cd66069ba418e11bfdbb79fa7d37e45caa790e27fbb8bf31de6c06043c45f4748306e4e8a0af8b05ac00a0c1a04b21caad19ddb214c3ffa4ddc602258b4317088560f9e404b80199b0ca88a3ec075449e8a725b057ccc7c1d70ca530a2210236f4641797196c1ca6fd1435d70a11dcd0210ab3ac8122277fdfd393ed0f0002dfaf2394970226c23d5f437f6b2543613d9f185536731fab3ae16c419bde03f059f831b1b09aa66a2550b02329882471a8d8dfa6fd357586ca805d726dda3a5b74596417ab9bcbcee8c44bf8c2d703278e097d98d1e44f5c0f152072b34504e12085f62b10008c6b6a262106102db7732ee91ee7ea8c8c629d1579feb0b11225d4f2380847f175d5cdb69ce95623964084a4f0400cd8f2221bc3d7cdee69d61cbab684e848d21084055dc5ba840d94f1fa54f7a20b2caf0fc5769c9c819cd05d627bafce9ddc839d89217430816b3c3af58eeb39a7d151e981693e5c1d12812dfeb1d5ddf253447551f21788996c77a32503f3b45bd82d5524ca0863aab591eaa177ed510b3ce7f5a07b5b1131ab599e8b57f27f14ab7c5c81a1e8bc00821b40503bcc2852d9793d6afaadb2baaff3c3c15ddd847de1392a8db4d75cf34c82f0dcec1e90151afb45c388925793e8360644c78e45ee26c98f6af3868624e6e5c39c8aa6ece2af5cef6a3c2880d98be12e63d902d23472366743c142cc79ac807c4bf3d275fb9902ca7587707beac8654b6b4a865ca4cef7d0c8d2645d540b73b53d601c1de0d07ef44b4d012bba2047430f24d34be015a11328abeb765adf7efc00c1444c4ace7052779338b52c9256ccfbe50b66401e9bd3fb472ca4a64c1bd1f7d09a1d81b5f494fceea12a6cf50b66d258e0b67558efb17f74017b3b559b58cedfba6a3d379ff3ab6f552faeaf5c3f3c84d9aaba404b757eed05ce517f0af8db1403975923802291153fda4108803fa0c7f84bdb3616cc0fe09eebdfbfdebd15c2e7cec88b03b3a13937df1a0026175e456c30920716a999b98ac31cf222b42f928175f3a5bf8ee3791b4e3deed33599d1bf37fe0adbcd180c84e67f766c9fe15517437b93efa5fc36360876ce1a9787625225ff977dec877f773cc04a0fbcd08096b513bcc7e2a04f8088ed99d4ca94bb761792515059870fe5c09a950d79c3a4e27d2e660159fe36f3f2d618ade5ca30c18d7e6a21813328b4a63f543afc112ee6e4e27999de1877dd2eb3383045e06831ecad2ac9b79f0ab07a754bd04a0f7921cee4d4c6066dccb832eecf899acb69c400eae73c3c9afae586b6e03ca4d97c8cf6d58e0f8df04d69528a44b74d39ba4fecb1732e24745a83e524ee8cfccd17cb30da64405f45b973cb3d4923cfef1b942bcd6dd54c2ab15fd8a479ac7fed18df65cd668df92277ed02e5c2a157d43e7f7b981eef2e0dea336e9abcd3e4a8d12111d371c317ad6275a2f1b3b544fc10791384669328419cdf7158422a8b8b243f27338ac9d294a6dff66772d8e71188448f5b79dbed11bb88c3b30620620ee839aa96f963d346f5f1c038a389fe2debdd2f0438985c5c4f81db9eb18c2ff4ca1ef3ee7054e919207c981af655e695a41596e75b6e5cad785897fda00b00bb8596409d797419667dccadb0c56c1759b463da75f5ba25cdb62a8466d5e086951ed8886556575999a598d68c88f2fad16f8c5842e6e00e302320e8efa24e1ffe1d084a7ae9aa1701cf37ee84842c4b4a99841db643ed32c59c248eee00bbd127656c21771511dfee45e0b09ba9fdb2b2a062e3df3c340dc310ca85a164671f3728b7491d3b0d187948ff440a1e6efe9ac4593e40c53b1df5be6f70f7fb228a36793c12ed99c4930b862110563fb5105ad3de095b88740d762e3edbada16a8e53c410d151b807c1e718d6ddb2226af4f4a48efe0881661cd0693f1ec579373bc6314b5df59d1f2688abe7ed2c9d8e232f43ebc43c0d369bcca54bf4ac91a61922dba9f303f6898c62b9ceae3f86ad571661b7e8353829ca37b85703f5863f9f3459e9aadc21a199da84c8c76dfe6617f1a0a409e04d0d3177830bcc6fcf6bcb59af9a3c84e4165b7a34d87361a2e51b000ded65d7af1ed0919b8fb4b42601ccfa5d29302b38283a48bb301d32f0e87cac5a93516b53f0685a2f4230f0dbb628426709582734bad07a97e6ae2f9c5c1189681ad28654183dfd2f021fb2e85d7939fabe6956ef4d36d5b27d2fe995d6b6b9477e7c7e9d450035b4d25ba3371498bd6ede9d19c198670b0ff8b342a4998e6dde1056284778c8076f3ccf9cec334262aed32f01e4c135200421c86584a15a1e1c0c025ffcfdcca979527cf91208eb9dfa87a3d48c0bb1f0bd26645ad3c000a061b49575686cb49b784bbb3377472a4a92811d166607ca4a4c16c8dcbd7865fe40d7fe76df04220e56a4840dd1f2a4c9f90a751c2393fbbc7b8866fdfff6862a32a3e04e80b269bb0345148062393e376adacce204a0adeceef5f71fb8887d924264149361c1db80e7f74c2dc18d478cac2b1cdb59eb8ab254639dc93d17a645db332d0d0136be6c5a51d9b6616392f488bf194e2e2364aade3f4c5aa0572ec6945052d3d8797781f970f95e6cda357dedfe7c31b9bcb4a609c2bc09e1e6dd34bc61b38d8b35c86095cdc5a676a190ca0ef08259921f57558f963125fb8bfd8f979b24ab1c7f31c2ab4add43bcaa5fe3f29628fecee2901d209798c82aae02226c3f07b63a66da48a4196f8879ee1dcac9066ac0cf940d432c2ed3b04aa203c371296c72572e043b57fa99960c5bb018d1aba0fbc95cfa5dec960f7a8bbb1f87a654dd0345c1feb2f2f35c7d1e2971076d9b88c806ea2676b05a357891f4c2640d9f3857bb53a1f729965bb64332bcca17f0eef1343b78931f44a5da20cd8a5398e542f6e7993c961047f38f0e7243c5260253f0c5f2f86c1b225af76065028991493f780ff6658a1ca7b6e909347929ea9c57e88be4eb0fa0e65f01b7ceb1ac624a8219591df7f327f1aa1caf5b767a5b272bdb7795535e79149f41fbd31b2343b45a2adf1d33d2845cbf740a89f7742d2cb1c350615b60932744ac4e34adf7874b3357eb206d386f92978b8b8f15fc27cd6192ce72045369aa28532e9bd2be585b80594873e704b95ab65acb9d53c370280a944df63d6f232c42863fb2e09b451cff74735bf277582ee983564048815e7bb9a20b66f8057e653a93925c90c4490debdeb62616650fd24c862f633ba37485d0e3d89693074685cd7d926fa96cb45a4385946d2c2214d74556d42462efb97ae7dbe525185875711d9e67cdd4596be5c15648b43b83753b4838cb8b8b5265a2e55c2a2b6c292fb36551d6d2feec7a1e329f320796868b618e9259a47c2cca525140e478d23de9dd8cfa4e9a518a59bc1b45f7caefa4c0eca1733f567f232fe1fca83e46e958af49f3316af98576030d52a62c53d522e5577aca224c50c30843a727ede43d958c9f0b7c5358a75b23271155e895c949a44bd94c5b87bc1f7887e8f517dc5519b4af1c1a16deed719ebdd543079f3af9c855d9f1b88baf36b2b7c15cc27b1e8f0325b16832bc13c28e412ebbe5ad3ce5ddc96b2166ba01078878ade8ee266741c50afd08026eb3fbd906619734b310ce05d1be263e275797134ded7b69bd4267596d5e8a522b0a12d71cb4757dbaa859200cd2500cfc2914cf507cfd2ea739d1ea5286a380369f644dd06c23e1006d609eeae0da63359bc34befcf91d414a75306b34830987d0fb98a9d186da6f9010896dd12641fd7de0b8924a8b38ed1789820c60dd3728f5c2bc747eaad564688c6004ee45bf0370780c10fb60919214f6d08e1d0e6d4d01eee37aa2d12fc3dcf34c2d72e1563c436108fc51e0cd04a1466fa67eb959346fbe1d264282926ce87910f94680b640f7778d2e466a28575519485590c902a0f312bf4527f955d6b0ed404e01b0d5e6358816f0764a7b0aa379be6703428fc4134b0a9bb5d61a976394d06bc1cc7fbe5741779992457bbe567f6a73a9d3156655ded615947ea1a7a0e413355ee73c0feb0ce7265854c2392afad4815f860ad125c28e99961379dd92510c7cdaf04d811b3c2c9613487f75cac039115078cac85e88685fec0c9bbc0f8cbf9a066706251d7ca4d7ca8461f9b525ac80832fd0222a59acd9b5e18373ccb4bbd0c0bd87bf3db112aaece0801bf2df8a2802f2c9eaf344666ab11de4d8c17b44eedb003cd9a5cd6fdf0d167d60e51abe26e83a6138cf793d1b65252651c4c555762c325b9370cefe68d48b5f8e625bb0c502762888d48285d76e0f8ff7f614092f96c265f932447fe78cea6e1df718ebe65ffcaa683609f99f3a19ff0e40fa4e5f918b7fdb6fa3a86fe379b9ed18f41abad2f796fbd4d4473c631c3f6b52a04c31a7d35c9045ebbad6bd56d708267f87669c3a68832285f885fbfe657e2621be527beaa3f12f1c1d284058834227a2b3aac4c21d83b841f4c6157262b8363cee100b2d561e5bc018f1e255b479a8e538d726aa9e014dcf04e415d8d977f9d6cb8e7501e92d1c76e6e6b374fb0f80578a654f3319e9e3f0fdb5369a4515109ccd001a2048808090f634b69ad6591c3b6be7afb8c799d97edd0be038eef6632b666fe45284f9c604f924d5603917a6d11e171ba1cd9055e59df608d44861b601b447010e0a2a930c637d7960b1c0b2f0ebcdf10a278c4fe4a0b8d3af780658afd2ff5de050769e3ffa918dbdf96e61e1dbee498c493d9ef7bc45ec723ff938f6e012e2df7cfe83283b203b6039fe57da0fa2ec76ed0ba651cfcb12a166a07f4bafb0f05a870f7faa30e45469dd22341bd2d2deaa9aee97c2c5b4f8441c2388c359f45fad050d5501e93da3df853e5e97b4c3db74dd625a75549d4d448ede053f7a02c9bea78c23bd76d93c66b659468e6dce1c80c524d487d14c31597d18c3948d65524b7bd787f99c966231dce548f8ecf847b4b3638dd5b9db0205759672b3eacc13133599d691e8cdb955b978eafeee31cdeb785997e737fcac9b1ecaf4a8a18412785b3916271af923a2baab768252b03649b134f5991de0075616da870208723ea742404e033ba023f51f9caf4f2610062d322fd32a13d0f35c64f660080cb6f155ab94f561c382d230459862cd88e6cf1741532804fe7fd679e0230e75fa135e2ff6167464a92506be0703017ebc3ab2d41c9e719a314b5a316e686156d217b8b3f87de0c05b16fe1f7077fd7d30f552f15c332b41e3cff5db1b00a81e77c6c6b8dbc464eea2b2ebedf0e85677c400372089186f6f0c3a2e5cd1f9bbf506c5fe3990f474d44f9ee1f8de70d5f4f6c974d752f7b388c9b9965a7fab868f7ce0a6ff1fb84aabc7e99178e072bd7dd220454b4bb79a7719db6a4e93f25d471aae10fb5dcb66bef5f9f206848f69f9c99238624bd319a83f7feef43458c2b1ba9824e17e5301d42a2ceeef5c72b1d8c2510358eb0c7bc4ee6946e79c4a9815fafb6e5ca4c452ae418985609c5e46d09205ba13f843d307ac83ccaf79583ea3c62b9ffa7ab57724fa168422d6bfe3d1cf5203b3b6bee0f262db37e6c3f3edfb5b92f782f2c434790751ab2017379f9d293a35879d342ce6d8031cb2663b4d3b6ef23143c215d0855ad84f4dca7c32bf8d95edf3ea3feedb6b1b176883bfecdd0c3884faaa51c197bfed7c1f4f6f6aed53e89e77a1a93756f7932c1d927c1d338725206b6be5b3317fe4af5c71585023eb076b043fcc141fa6df101ab31482de79aad18ea5d1b83a1ee2fdea0d72ccfe9a92bc68aa62b9ec90d7f8078376a850b01d51a33147ef61dee7dff82a970a03f4cdb39cfb1849e1ca89e4e93173f3965bb69367aed1926a84759c243bea6540225826c12a09f1cf96ef944886fd5851408b76200ad23e95675462fe590d38b479a294b2b9f83281e43d9aa4990733b6612002d9963428850f6bfb42d909ed44a1e130e6a4021713524cd1720eb1458af9e2281cb3e20c47a9d604aa1947bfc29b72f48167e9a186969297aa6da386c76915a5d93e960f5c21e4a9a439a5d0779bfb497cfb84959e950aa20f3c335ad275bf908b8f18e914b7f216343977f6d5be20ec606da9e0719dcebbb147cb4cda0c442f736f7e8058c8f7f1ca59150cb076c1671053026b83fbf78cb5586dbd2c68f3731d9f4ce45a64a70c03c1519382afffe84570bf70f611dc82902caf8bfb578c8eaef3c544b7175fd8492680ca97f77bc70e0f805c40a4697a9df1913d5fbbd7d2e560f29c4a35dffffe48026d588fc177230ea85732ca33fbc06b5d098257e8251ee7343369995359ef30e56aca7ce72364b315057b336d64bb06eeb801d3e518848b2798b6b8c5b9547a49375436599afab5765cfdb5d3932d0091b860ab5e8b4d9beda2a7d274518e30b3dd15c7923e28983d8db686f596dae3b7d93bb129674b95f511d318948e00ff849ec8f8fdb71382c4f760cb380f5860f213df669a2ee0e6b8de5ca913f7345085a740ca175128bbfd87b576fbe1e51a064e15c1e73030f9c1014bf48d108ffbe3ae52a0c47f43a6d9dcd34a2959e35d8770a006b2d103d804acb278dc9ebc90cd4ab7f238d708afbd1598dc618450c3612241786ac820684b1d90688b6584a50ee0f978b570d7b57a4215c3a5f2482ed2172e4d9cb6959480833057703b51669ba1dbe0df95af7d0104c3e754c5ec85279bcdece7524423483c3276accfecdf353c4fef90d4f25ab8ddaec6a4ab823565e6d70f0fa677ab285e42b9d0c3fb0684df549e024b1e227af02575a16717ded1e033064884c497e4a470881faefe3b6bd5d75387ebab52ebd41aec55d09641ac4581d0c357fede84e701a216a4d8374d02be3cab030baae8af40d8bdfa74025bff8361e276aa0ef704241f41bc29d6a5af2e416d3b88dd995ab9417cfa6062018855373c89c0b57c3eb28d4129e9cd2a667dd9ee0401c6750f8716855e41f904eb4977af7c46b6c28a207120f2b63d21e4b264a93302c7dd103ee63da1f984c1d70d0b84e56e783b512c83b427618be99e99e53557d58a0deb1146025405d14613eda9628a9246a49c49854a0d781ef88d3eb83e8675a93a9b0470093192bd74d872321a45f9779882b694c2a80627570ba283eef590edbd6295b9709286decedb9ff338472facc0a5283a876f4a561e0eb431de22e1c0e11d890f827ca1d3c8c3905f1988351d50a430cd4e2ae20441692fd55ddcc63b75bac61d2c8b744b8d89e83be7aaa392cb020987aad980d352f01f1448d3c7d734e4641c1bf32ea777e54dd985474a4a8c7742a64af9a974e6d6f5d7c493c5c61e1c02469ee437251cf0f7e39691f54500231ab6b7465dd15c04719261ddc8ced9c6d6e79e6b82a3c8b13601022eff9e2c718bd04b71eda6344c842a3d46a862266b8ce725da04fca900e027269bff10e5df0f6583fa631533e0966bb542015ca5107de912c31dc46fab8a2b0f93fc8551548c183fc990148ec42cb8d068c772ddd68072fe1b8ba9d4bd8ba5d2b2f821ed2cd315e218945fc84b002438193381b02813d2131d1b8e4f8c5373d4856728abbc8f9bc66b2141b0fdc888555893bbd7a01306cfac11928e7602b0f484b7c16296639260c15dff649ea2acf130bab4bee168fc984a83975b91cb8df6de431f42b22881bce533991b0b1a8298cb56fccc19afe91cebf274c84d41e740222e31440a235035c90ab80519f2ff9dbf320ee8501773c7274d3fcd46a0dc2adbadfc2e4819c94d4d2e317545cf56db035be26ed37d4a1e1cdb99c099d12a923b5bd31dca3c3ed2fddf36e2bdd8cd8c6e9b5b36ef14ae361798ca1ab3234665583da9101d586f0573d0c0e05a48e43dc72c1249593c2e57fb9559fe36f524179dfcad1346a3260b0a5478705dd433e807759e68a006bde87ceed0548940e280b5f577ccd1c990ba94d73e5351e71eb96d88e182d268e266aede780b46a433604fd0f99c042e02c43c2fc458a4b7fc9d4f54df068911dcd0fcf47dcccc56db58a637ea11ea48085ad6f87683da8e50285e9583f35e05f7c17e1a507010c7365c9da857ce69ae569a2714560cd87f8c1e9e0b8a0c72f8924f19f2c4d05df44e22522b8070fc2b644077b7c0de5add531bcc3394e9c50b7f0b562e91328f90346ffb4c85d6ac2964800c638df2e1715ec31111bd99c0bec1043f10f797157acbbdb961d95445b6bcd1f47b793595368aa99d6d2c8020cb761bd45652d6ba717aac10001d7ab9b125d23a2d5b0645f104eae4096b309c0bf58a72a9b1a8f9c7bf56c8a5f24963c0fe533aa89775525e7940f175bbfe5cdf722aa9951f077c17dca985662a84af3bc47568e0c172ccb71dadf5e54b2f3a512703eb4e4eb4b25f01c6b250956a058906338bc0f78ba10d25f8079351b175ab10ad2543a5a2e0812066be00096783d16710a7ef7d71687d3c2a7a048b10b1164e6bc61d8094dc749d2d0d10d2a1a4e2c5fd353ffd82095f9e5c744cf31de239e468dba1bfb25c54c2b7f3da57045dbeb22aa9711d3114584c54ac74dc9570f1bc8550d7fd8c7dad9400775c0d2798b2fbe105e8522d69fc198d85a263ea3210fd94bae0a2b6c91c2373a3be349d0117ab222692ded3a2f6a312bea5b2ccb28c937c75f0cbaf5ce7bf894549df4f308c634e8edc4b0f175062c60f230d04dc7291a7277e8debabc99eade94a97655931081d37f3f83ea9d884fec5c98486475ad6cec24ed0925f0775aefbbe8146dbdd7c8051c3de706f5dae8285d234c248dbd2dd69d2da56b344a6de0a4b10855d27ea4740fbdd2c537dc200d28cd8e292474ebae2b424041ace3e51e54d293904c4e1937beb1c48b77af25bba3f73f90bcc61161deec1d4f62b0edbdb7d90ce309e951110260a5a71f38778e19c9a57c5f03708b910356d17b67f1e3bd0ed0ef68c29d4c3c80f924f7f467158f5ba54f4ebc609a939150e67522f1ca387a5c349a4389d2819f52c75c657b1bb46cd29a2e11e3ab8b2b005d5393ec1a93736afdf1daed03a455543cb18b2711f0851d55c41857c21560f74dcd1adc887e64c55c42942a5e805760233d81c48884b432f47219f9246d09f9236ea9e7132fbfdaf1f22d854bca9ce3bd5ea325d3d2a04a65e068639f8f403cbb1c5f6b9f5e29afd04362acfae755c3c117eaaff5c2171b0b9fab2021df1570da9af920c6103aab0ca83d5a0f048a8af83b5fdbbf5b431da64574635b60f8e69aa23c412adec55af111e4934fbab4e7a98e11d0b1741d65909384fd4628019596f6cd7af87725efe144d987e1b7528539efe4c60569d5af050dfc18f43b8aedea58334bfa202344daf673100f8d2d37c0b5af604f47272010195728124201c29cb98c6a49af69952c7f5a00f6b299f266b56008fc1230c72d7b7e598c360e17838e5fa2c327bece275ff8bf234af421da0a0994b1a4d659bfad9ad68d050b467c5afec213c27975cc8ac8887096b2c9043b4ebc7f0a206b23380adde9b33d398df4d0a4cabc652932c4d161d6d8b29825c86cdbc376940f95e6e56de1a6a2ba1b973c3d10247c4ce44539ab9462f599c833575e3232588bdb1a404fc7edcae4862f0a1a3906f8f24dec1992cdd4d027a572c04acb9440f5d36951c31bb113b9832f240c5d74f3bf68704a2f7b99f28dc0ba4172f30f5aa63a7737c9dfcb2b0a36ff98293619ac08d1793b746a2b1f5e47f36809727666ca2ee74e155099cc9dbcac240163bb96a8313d3f71dc7d5a4ea043216b43128ae9c28e334215d9d726226c8053c570f8b22268836466a86d9d1215eeaeea7e2f7d979a8a0c22259c0164792edc02465fae2e925632fdf3845c9f159f938b28cc7dbd5c5aa1b57cb5cdac055ed093109857bdb4da0ae1484814717c739467f471da4cdb4982d34aa268d205ba78c30fb1ed0558f5c11a8a42bcb35ed3224aad773788ecce58ce770b00d6bf02d40741b23dd0a448ab925d4846d55a7c5a940d07984780ab1beeb2fc4407e2adc9cc30cc8cfa377c9dd10c423c12988c43ce6037e70d78c0fd46988589895cc7d988da7f9f47913706c7c811d943b0e8f3a57afeda25000a7afaa94526df8bea66616b9dc03d26e491da4a30a6f240f34cb7a0e02f8a3d8410f866edbd017693bc7788a0a47c9867a2d6117f716b236254a9c9ad824e5d24e66092b02347a86901efe419f57d3a8f3af4b6e2b3a9e7d962ca38cc4467640c2fe972daff66348e1e4bf910acd1f82790de7b15a72165a1083cb68fe996356aff5bd65f3a1de87ac8df1ac43c61dfd62ff99c1bf1af7a82ae68d4ba13b35df1b395d3079d0c41896a059dcc41f3b852fe4a7f8c1bc28926f23ce7b87dd9385e00f700781e7ad656989b3da492a8e940a65c4922587658debb6d11d5033141c440642467393961a6de5deac4f1f724c9007be9ca79e8b22f9be9591dccd5547c1cf078352f9af16a2b981474c644b12bc2afe470fbf88e28e42b1d7fc136dd8a7af0f5b7a9e868242835d800247bc6759fb2eea8a12565f6f9c6b77d0613fc783841dd16fbf79e070b27098036cab6be47399ac6b4787f6c7d55ca31f674a845a2bf93d55b92990ec3d594f838ebfb5dfa64244fcb859e9e861b864386b5e285a27f80464b8ba92753bb7c7b36d0b1f7e6bf03f9e9c8cfdb6ee64670210ecc1699fef37d5fce9697df6465880144da4f8982d3ec832e6b10c5fcb10da382270d1663b795ead6dbb4f0d11d93cf5aabd18d96356a27ef027c9613262fb00d88a7b6100bdb6346129bd41d8dce797fd46f35fc3508a6fe7a4b74ada6776c199fdbee2ecf81489336b4f74487a34b490b699a8cb0932651dc92b0559e2d903869529cea86806f8902dfd2ce5d4b744f14ac3074051ddcf14d49093cf9184628fdb6831bc8e588c31586d79c2d8a53e60a1d550c1441bf73c4d3f9191052e83596ebf32a591e4f34708f03ff71ab7ae769c51b1e17f0bac12f771f143cb45ca34f1dcbe68b5c69d17aaebcb5bed42e8ad3dffe8a619d935e3d50f26cb97ae1ded95f8ee8aca4b041b53990d52f807519a67cc946c59f01507ae9cb4e0852c9cfd3d28dc5f43595504622e5cc0ed8aadfcc4a0d745127c82791e2092a3efcfbe573494eab2030bfeeb5237c2a027ae144e9bb2d7e0b6d858316857581b2eea2b43c367b236710196f05ec93fc740abf796134a9aa65ee308d6b1639d8a55cd48107d074a84a53f643e72113ad3af50ddcf7822141ae24af9310737e88ed10cc9a69dce1af21478089d7f4c292fce76a40f61c149ce679d054d3d633870eae6a80bddc785ee6068af14c085a7b54afc870d1a0dffdd86be0316eef7f01a6e32d7c1db0b4cb76c71adb9783afa6c990897ad944b71c3687812e42caf3d8f1b43336066b39c7fd62985e165c2763766c2752a975ff9f46a7b414df0a3bd4cb64e33c2ddda00f236659e62e216d92f7fd89f4714045b8b0936ba3278b85072aff1d6970e4b993bd65bb5b48fbc9a2c33bc9ef8440b237949010bd660392ef0144460e6ea85af5f54db3b86fffcaab6d5f6a2f9f7cbd8ba2fe0f217fb3c060c1ebc9391e0270f44e67d90255a9703010f796f3b486be814f119b732cb79feaf328100cd3c7f2169404a93ed1a6f53859856cefc6e5c64ad1c641db8e45efacbfaed060d3611982278575714369694c0da9f4624f8bff23f84cf211d2d959646ddcaeefc39a801deabb8f56df0940584f4a7ac65a345390e71a784a15776c148abd63e06a5622e3266bd2d40502cacc7a81694ae26b496db3d938ed226e7d93558e69c4427950027b7576ff09f17358b09346d500046850f6e7529b2d86a1af9607dbac9e90302b7da6b31337d8cf562a616696d0afbfa2902d83d7e2c627a2082b158f0022b8e282cc557d91f7f88ac8162425b945353ed86452426199f39ab138652c64487eeb54f2830597412e7ed882eda26b3da8334e350b3805d12979efc19876c31682e9127000dfd88d9630b4fea1690f59a08be06d05f253e7dc8c8bb68cefbbb899a6a4d6a7b793484cc572913901ef2216b0a0e07a1d918cd392fd069c5409cb09c2d6fa85bb7318f71af820899b6adfaad4beed5c92feb57d14a4881cd3b597166a9b7bea40f63ec070f788e7745c0edc714fad8f443e975024f763c673b362a683ec6a623fa39ff64d00ee30f7c2083d366f7e9c1e3f2a289aad1a0625f0186d0b54c167cd67a593f2cc038e87c1ab4a8855ee845a0e4a5b9181288ad58d09177c99b9ae54a4c642b03340478e222b6cd61ba25b96329df96133607747c9b9eccf96daacd053830f3dd3e94ec902b1e87ab4359779209a78fc6f06b48656b9e92413ea9838bfe0b5aa147847e7f21f239c148445972552a0c8cae1bd3ec8d870303138009e7f9675423f556fd20cbeff4cbe7cdb921305fc2af45a5afd1de23f501f2d5a4cf00dc8c5810a756be7037f49feb5da49d0e7d188e25f7321a781f316c40f35cf7d3f16e33945b3b0136241bc849a12a8382cff0f0cfe8dae614fddbc0f7cdf1f201f8657e081e95b2124df2590ed914f355bff0054939b816c93f9385525b853731eb8b6248632c2d08f4fdba07b21495efdcec7e8c80c5f1c3fa8d101c62560b512b1b7d175116b16002c2afe667a89842f137ff5888351450d8620784435892a60a43ecd49d523f38dae16ff26dd6ab85dbe42a6b0de36fff1304dd78c6d2807dc453bd72d7942b4d5c8431d12f95db437087ad67ba7f89a8e95cd51c608f3db9a1355e9b98cc1134516fac0c5c05227d850b7a2cf94e480041f2c649dae06f866d7244a2a0817d3bd37bce0a65c4c9d57366ad650ef936ba259eb42c801f3c213b37cfe8728e974ab735943cb3dc62dcb3f949eb22d4ab9db94346741f2df86877bd1a01bd1463c6292f833a037918f6f7b3efe48e0b64c37830cf1d0ff09987b1c162ed30722d89a36a2fed3d03f3993d71e1fd60e15d3539d08c3d7a14c946e5eaf7dca944fb9ce92cbbc64675820c35d7e6bde7f3e53113d5a0ad42feb85e525b238cab18faebfed9187e53c8b24f754bcdce4d97e269c19e41f2437d2b2a256f182ef942a719466f8a1fc7c6ef0c4899580741340b34e6bd8aa8be7989a7358794a0d7cd4a5d3ad661365f8cdef85f078fc3f0e1abb8f02fb2b73496c51ee5778832f32239f59b44aba50fdd934accfd14f706a8cfe2132ba5b918a058a8e7fa4044114998742d12ab1fe2ce1ef205ca192663b2293e5869dd476b9f6756faa39d41b890d5c1e89f80b7a62275ff027b2d0fcc6c1f236886a67510b93e93a9859286976bb43e0bbf97f7ec2186959d59869fbe500d9a35f27d4d7d473813100d3236bd05c49002af3d3894f9344ee8a98f4b2bbdb10f6e3262562f1c26acea38591b5f9d570d9ed5d0b87f0a88fcfd250979240ea3afff5b8fab41d6c1edb610014d69f5e6a67d706c15d30a73fd041d6642828c9b97b3a1b4614e60f52a9c9aa6d0001c1bc30ce6ee42e257e30040f1c7905b48c23869d389cd98137f8f280a96c48915dd76bdb74c97aa24b4232a4fbe461bf5cd7751fbd4c03092c2c63bf32dab90ae85bcb9f5cc0da2aecb2c0c3b14384f9f1effbc5752dfecf3bb17bc225324b39e3de20d7b01b2ecb7dd6df1307ee8272364a6290560ee8fe1a779ce069028c4072667590fcc53a6b69b5b5753e08e2b27fdce27751dedff01f63dab3fa59d94e3107b358894b6b9f5373fdf96705b9bc87f742107850bbcc923f357d9a07962bdeb9629cf14032fbec68fe3f60a3d41a8370e904ad21dfc1b9a8c956e0e0077dd0966887f2333c01a0a386e538c893be40ef9ef1cf76702964fe8ff134c4e236f78f8ef2c3b265d1eb1c34a3f56c9956a6c57cfd2d91c99047f91b70dcd3a7e8bf9dc8c22f5373d06583db6b03f928d1528625927c508dcf475932b0acd3aa7c9acec1972d612a58bddc84fbe71597fa03f19155ff79aa500fd55aa493c8cdf1c6146ca7881a09d71a6e201b565af26f01d44daabd8a479bcb420bd0dfbdba3c159b4231dceb4d553e5819cec661424ee23d0eb3ed8cb90562d6126867475e648913dde3675815324881cd990ca9c8eca0d1b1c388f58a52c344f06e6eddd926efebf2bd639457bb2bff1368ae612b81524b998a42ff17a17b48efad43be48601bff0f5855b3311f2943a983b1b15ac475c1996bdf94ea1f781e625e74b49b2288e632587f463254503987485a3e48dfac630a0c60628a878f91364a055b6860db95537c97b4746300d90be980299eb864ca7967a4dcfbaed9e08fa1a6c09701d03cc1524546ed3a7fb644219e62f3a2165aed57797aa4f68d8815afe9312c249489f5404af9621453d2d0be25f30c2a7c5b2bcaa89ed65bdcb61772fb07b5d6750de89ded279232f59e617a6e2d3691d7e76c778dc4e6a08bd7643ca863ac5216f23f51cd2a8fd82d64fd418b7cfed2cbe5333bd8f992e020c29cff7271b5638ad66ad31cb8b55f5b637db6863b933b1a031be80f00b05e1d6a00cfe29a73c5baafd0cec23210c78c12cab860051f88056a888e2fa94e8e6ddb6f2df0328d127a6361dcc71128137a71d4e32e4974e0b8474f732e319d0ac015f27c69c41b852698962b2aabb5769f7960a2a42fabd8d157ac6b08b3c053086303843d474b6a4c1a9944e1072fcd4b1ca319231a7a3a9f766b07448ee25e675819de0f9a7d06297a74c2e29c727f4904c8692f796c93f8dee36226d345b4787ae3a029d571d7b7fe294763685d691fc1b8d3f9590b7f90aedc0f5f920f685dc9f09faeed1791284fd8537f32e0f4aa19a6d1b8e268a3b85cc3df437e099cd079c46e4562c087816d3d14edafb701a5996121c31de3c01c60fe3af3baaeae317f89fb1883bcec27b84a9425c47c627f069ddc82337933c9aacb5c7bb238d229599fad72c94becd7adc69e319d9e58f596ca133e697264fde6ac362803b0f5723fb913a19b09c0aba71600200ce7f15ca7b61296e3fe956667262b7e26004abe4b223d80df6c541ca899370ad98df877de8b40e32bd0ffb474313dac57bb6a79e6d9f29e0dddde982b124f507ba5fa62f0862b6e9e1e5c70c6eb069db71a73a9cb9ae376e99f174acf2abe0130633f334bff88394bdbd84c7af2ac15591853041d481e778c074dbd0e90ec71e9d92fc37d7346166347da37a16411450f1d0dc6c851b0dccf9c54598383f800b0bc2be2427e92b5c11ecc68c7692f4fcc89ab7c1b77ebb3d27f777e63f962047166959fc4b0a8351607005774d02d15a065aa485b27c7c39ae04693dffec340d08c3b798f2821c8580875c664630360a447a11a6b98dde302c581a698aa9a3a2618d07134357f2f123c4dff701230505c1402862348f9deb2293af5845cf790a58e2d8a2aaeea2162568ce5f9777500405a031a55d96bf79f137c1c5928b42cf8727bf93c448c6d7fb02f173a80bf43d04cbb9c8da3270c5cc1e35b0a09f434220299da8b642305ee6d2e561bd7c29b5866a50b5cc7ee827a33ecc67cfabba53b9cde40caf99d5394ae10fd808b2f29cbf14a68d0a501b6bd077edc5f380a740c0adebde39e5e422fcc4e44df604ee8983ec00444929180bf83da00ed531ad893db1950e5be3ed784d4201b1a59e878a90029b72dac7bb85c1dd565210a5fde465d2fe3d000bd7d6768ac3d1bff5b3b5c66b7caa9dce6c641e30bf6bec26ca2cae0bf806ed3795ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
