<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77ab92bf010e2e3991e874378cd5aa56b79bad71d9254f8496825057952967cffb28f0d2812d3b80421b8b7448272d8c1762334ebfd8b6521a6428145746a2fdf14d4e64eede7a11bab40a8d0189a643a1806ae44ca959d16d5450251cce7096ff38a11fd14cd51db83d093226a7b3c7223d19f2ca1c1ee03742595139dc38208701f509aea278d16a336cd9468d6683bfab52814fbb1acb8863b7fdfada2ac2646824c45cc7d47ff02ae0678b3d2fb0369154fdc1a73a9b31ce4e4f4bc017caf837fea00b1296a3fd3510d4fbc2ba9a8ad33cda6ad6944d8e50ffe9222feed4e61e0e641fbb899760be5d4f6a3ec13513d8313ef099390851f0831e63817f7d9310588933f76ad1a633f58d070935c1d50d8aacc39d1025f2ba1f24165220df3a60e0e879351e692e6b47b84c728a190f7c50ae543654f426c83d9e1b961c6f6bfe2af7e023f85575b753e2f35345f734b0c2a2112b1093774b4728d00eee83791988ddef6937a84678cd76595a1698bf72b35794c5091893a62774ce0d2532a089a686870b970b6d8ba468b1fc55108ee0245556a8b83b90e9d22aeeb4dae48cfe21f4dc636745bf1f649877f105d200fe93038f4a8be4ebfbbb9fde82b69a5321702808bcfd5d0ce898bd517c037e4e4b59c985bcfa2f7ccc7747c1934de0829ab0495eb4711c55d14607b1517b3e7d9ea9dcb7717275bfc734221ae7e3e3f24bb024f984bacc4700914f24f2e4772adb469aecac0f8ac83644d6e49c745dfc9e9edd1d13b8c9c5f5af5a099aa044ade03927805c4992c865f6db58cdaa72c9508c883bbc423f5fed2cbd6efdbdfa7a56be0d184587fd6a7b7e12e77e54c63696b63ef4ec61e2fc889e6e265096aa467d1dc3f632a20120198b844e74974f148542871b86b39245e897d285741bfcde074c91d1e9e34e835d5ae9e17f41ad03d0fafbe58bb168cec7f7422f8a084865d65902ed9b06afb1861ed5cb4d23c55c915f676cb7b40c972b74b72bc06dfb8db4380a1b2c47c194dacac0a86dd3e88097b5a473fe2f8476f3c4cbed1453491b137d393a6bf97061b8f8b4e872e2b9133ffb1d126f79015bfbe8706ea212c2cd3922ae74633d608bdc4d56aaa57066a6a6b10e93e8fe2801beda5c3df217b4bd7b642fcd4a633408b3ae2bdb67c39a8f19bf73dfd39f57a0ba1ef5bcca38c1f026d3b08e37fc058fd5a6e95463916f3dfef6a4370a20da5f33d27dbbb9f9e6e8940c8347f8d8c6f0a3152a6637a811d4ede9cd8692e50decf50f44d39fd5602eb3410f875127a9d22bb734b147ed9f557cc31dc81d606e75b5aaee1c1e428d212ad800934dfe1f13e74e60e166d44d95e297d328e7ee160cde85eae643493f4c484c626da0a09ff7cbef04d7a2349dfa5d29dff8cdc0ee4e64fb773b37085a5f0d929656f7726ad0e047f145abb1d6a6947436ef7bb61b137fa29d7e00b0ff091d6262c1543438e63791fd13d343de78ec24451a0ad330d72d480c1211e0792e3642b85a3958f9f51e0335c829ccf525c763b6d7813d1fcf7cf98da6bea30ad58b5f65bef02322ec314f90b3349759fe09669fa5b443ae4f03082e133ceb90c07355dd91f0fe498212e279786617815051c482cd7a9ceeae04a40e6d2126f8492acdc573e4721cacf807217d8019176229ffdbe4ab7e219ce78e78bc30d9c618f92a1fe8ec436fabd41dfbbca33fb1140ef95135a56278d58522f21d0b8e1b730728b5b1d7c87cd8eddb0e278d328cd4f1d14d19c13b3f00626ea52acabeb65e0c397a6395ddf97207f88815e7243e0f072c1b2e1320e1da317fbc2ba4359ef82b01b1ca3ca8cf95470b579a32b82428d046e1da87f29634c553e0419e4f1b2e3f72e6d9860953abfca6266907a5eadfc3ed1610fae31ec555203bb5f7a744267cd36a441dfb6fbe9d61f242405577fefe37b64bd9a36fbd23ece0b756ab5a66e16150a5f00391eb3775a97bfdaad05b2d1588ea12a3b92593f5238433a901ac7477e574350d7385d4654853708d6be2f7b27404baf2bdcb37daf0550b8dd2918840bbb9f1166b838d42aa2a7b535e3130162945744dea625d82c2e8a7433ca9b3c36a41fc3bef7149740bbf9bea0167032a05ae6b3a40e7eef4833e1f401e06c83791c27d98c3c512fbeeb94be5feaf82e8380fbd1257d9c1c6ae4d02fbb9fcdac5cb3e6b64bd9e6c1fc555983f1e0c82b85d98343edca26e622de1b06c36a74edd68e2ab8da77b262a766babdb21161969d039b7e2aa8088b7fae65c69f74f4a76143282ec3930f8a39e3003dc7ee902f6be390d59e2102a4154ad98b00fe89a7b2dfcc758e6ab53e6c7c4b2e679b50a6d65d56d6419816df4f5f1dfac8c143ab690a50036f7e0d547553f8b546473d5489d0ebe74822d2c62efcb5c6f1849cd495e168f79a697f2e72d80642d0e82aa529c1f2ff6c0a96a3b56635c95ef41f1531a9e3f1baaf5aae61759c729c1a1a80604456cef445367099bdbbce914d2ffba0c5542645d494d8edc3070d9fe13ceb4625cbac84857d8280552462fc9f70e35eed3f81583f98540ea2c5b8e4fe977e79db9eb8508334de09c1fad5a6a67efb4c20aef196e6647a0d02e3bb3ff8a6ebeb37dfb70d38cbee3eaf0dfc31bd2a6c96cfb4bfe57b1f8b955be9d60550f79d74cd9c17748a4a125d54d82b005f7c2e02d7436b06d2f9989bb9f96d639d3d98345551aae2022347ec6f190971db063ebdc29c1c939ced1a6dcfe4a06af98ecc862d6782cebcd5b9f8429b7133834cb2ea26e8018233649a894af1ac1c8bc1bb087e7aaafe78341f1fa216b423795f801b329d670ff87f7fc71d6633beb94543bfd959ff736a10b0bb4d98d823ceaee59a6b99054aa20638318626cb0cfc4f753343558d0a9b2d4e0834b6649ef6e3b6c5dfd8b24d5be4f3d1f9fa9a0b9aa60d7905820861cc854dde845a41d715c713e785f02b6b6ac1d700c82c4832b8455866877c16b093f50231da24853fc02fddfb93ed9d023322e1efc3245ed6aa49a0aa604ee0d5791ccaefad7d62ddcf1a85156d175abd0b206ddb33bcfe001e931438cc3262882eaaa4e6a738b341e6d9c15d1d1aa20bc46ba0b8b1085d22cb364fc6659699b6963d630316b2a55abf8d88c78935168dc2bd8a52e4f87da1d6d7bd090434985600aca1c48a77a4ebde25f215c47b34f01624794605eff29217d1d28e97d0014786d28ba52586ea0a1f15e342ecc922a8091d4779974dc2215b8f69df2fc323478d3df58a4f954e1de4a913f71f07a554f95d6d94c1f231ad968755da0b11d705dcbdf9b4ae6ff73d5f1b2033b65f92d7c8df0837111d04d6448db4dd3e39e41aa0175bfe16d27af4190767a2e518d484845d9099a17344083b4ba8f4adefb32e9bfb1827f8635038dfc5d4cf1caf0a7d4f0609d47e772493f4aceb5f1cd7edc0c8683583f89458a89e3f8878cb3ff60a081253e632cd6c21512b1fc3733d221ddb3e3864c05ba48936c6001201dfef466c92130f99ab4d43b70253169a5faa25f5902ee89650bd308b2699510f8519e66e981497157ad5f62ff94d427adb54d82127830c880d57038c82b48379c21227f74400dfa68c90d5271fb04a2f6642bddd662b7caa615537350111e70147f0d3eb79be2ddddbeec007cfdd61c7ab2eec069fe498ad6dac6c1949681043f3c5d66e4aa5cde4835bd560117693a1c6f409ef2a45bb7317fb2271bcacb142a53573077cc09111496bbcdab19c31864037b296aaa9bd10991a55c7ed1941e2f5be0b7817f7cffcc8311ea43755c94fccf404734ef121b6f17847beabd2cbe89aae6775970892ccf79a9fbe7434b1786ccb5e11a029e3dae23a1055de03ee4246f8767b08d47d68031a1f377de9df64b3dcdfd5428568c82ed995111b8952ac99bde25c0e4bed81df24358a31021c6a20750260258daff94717f454932f195be09ae445a50486b5e0fd5f0d4f8ff3c77c283a5f3a3be0169d3fef627036a0a193979acc1301592e9d08404862acce5761bfacf3e0db84cef1eac4ea7c77112e7a7e3969119f965b13697a0fddc7db130d0747bb27c88991edce255982722a1877e70a1b896fb3d2f18b48ad9edb6b93c127543883aa46ab951ba3ac38e10f30493b32f78d7d611e3cdd25a6c42bedf5609bf0acedc14f0462ece3d742e116e4c2bd2cc5ebc99ab0474bc555b3f93f670d26570198cfefa538db744ae41214e2467ed020c1c590d9c0630517bb6914be801d46006d74ac8e3332a5292800d9f374cb1edcf1d6e903610fa625433dffb7e69b4fc8c1ded7430273e53d16ad5a4d22adf26d8de4ee2237b9f630a8fee9823f636905df7c4d3bcd72718d924cc413e2d0d87b13e58af6f738507c8e61d80a36ba05e3ff881798685d8a26e9e4d632e842a1a703034d2bd1f99ff6dd9559a3de2de2c5b65382b139b5a156916021b8be6db9ab73a9b5767b7d2d3ad8622758d2338eab63389d9c66304433400eee7531584d0da1d017ef7540ae7270d5a1f0c0924a8506a2bc45fc234679c2bdde16c4e54888e38937c515f0f492aaf520fef9ad8f27a14ddefbc25dbaf5fdd76d3681effff59c8fabed176d5b59b4aecf86e02542934b73723cb54412e70af5b7e4a36457e414c94bed5bc9a93942b318d7067403f43e73f562df94faf37771eb5496a4f155a30291f93529ee24e3a014d81f6d9ff94ed2bbbc821e5ee4849011864660794369fe6ed30a438af82e205ec8951488481ed32d0095e353cfbf7f297f5da2d6560cc3f0ad1a873127147ffbccde25ae8a86411b81cd0240828370060bd5a3d214c9d27390ec8a3af8af9448a0db33d176cedc668560b53ae48950859d336cda551b16df00796ef1a6c8f6a19e780226b4545076a6dcf210e5887713d3f6250bd7e66b070672fbc5b1778d513b1e327176177518e3d989636b308db53d761c190383f98190a8958f2f1b9fe019327afdc5c67735ddb54196b3dd51f7aea9498e6b7941e8c54124b77fcdf80a5a46ddd13173d2918fe93290fcd9b67d616087c3af7de8d37ee3f961d04230d12d8b9836b064cbdbb10b90da2521f1cb8e2adc2945f131615983ea58d42ba6bb2c4de39125de4c7389f6c97cfbe3c2b86f8282bfc2584e1676a84fb3b24a7ae69e20da773f7d1631e42b41446cb5c8b7aed7f6cc3b0964c12a4959ea35917c66081749db443150f8f9b57ad3bf5b9dd3fc64587d888d9839e20748c4b61fd8ac3674aa8cccb9d7650b86bb57ade1b53e67f42c6824770e0a93a685fb504d361192777f3459d07f4bc902b63e780f1377699984bde196cfbd59160a074545d35d0907d5cbc12eccb478f328ab9df31c05e843d98288bfd737ae0fe7ac8b183e50d06ef06e912fdbfb3a510a8b0c3eaa8d26ea2693b798bacb8f03b15c561449e196104a6b6ba7b3940649e471a66d1c490df5c832fc38a9af015bdbd65fc72a6b3cd079baf507467a53d95771464fa38806e7b17b6d7634faa49d40feff53f7261d1e247aad9e4274bd5a2cf85c4665301edffe1e0e29dbe20bae1a9b577bb5160a130cc649f43bd671382fcaf3639ec27155ed88fdb03a93a21684e69d3e0e97b0d48af90f86ee2fd2a8f1ba181f415d8e8097c09785e9e4df6545be8d89d6bc47a2df4742fdde4e91c56b0205bbea7c6b7b90f9ca1908c2e8cd7a8705272001819f8d5450ec3266ec8777bfe7a93292a6ba47f2acb0e182b23a7225ca8b94cb8f35a4f433cf703a3b6e9a5662191f8cefc6bfd284aac66812e6c5e0311cc95d0496050f1e07c40a1c01fe313b238d4a0f64b408c41ca8d8fe7f6ff1d0a7b59665355c9528e1c9ded017beb100901aad4e6931bad8aa14b711a58ab7e20f2c908c6b70aef136667aa16f148684c5caa48f0f03858757774480b9f02949ff83e932d15b7a6a00e7850c7ec8149350feeab53d7bd9b2d0f114936766375c01c46a56b9dc8cef3404ac2eb4342b346d8a79ec15249a14b25306810630fce56446e62f4665b27f35ced027b40fc6a170f372d32d670542679bb8dd27d4e8a37b2e3fc6cc936355e5a776e61c64d3556f3170cae602d06cbc0a9ddc669c9fb969541bca98cabd5feac55f20ace4457b31316c718afab9762aa4099193d2075096b865201814119efbd726356682421f1002e34fb190aa240f885a2ba173ff814088761b7f996d021007444c6b3314552b10f9f656d87ac75f25d1b568f4d808523979c2cc2b80ae6adf72f6b45190dacc46b6e36a1ac719c90b3355d8fef03b7b8f543a2c69d25b442e5fe7b39da030708f41ce3fdc92110c03e1a0dabf0db9f41db196cdd42795f6b61b5348dafa59d51437e12046443f2826c15480014386c27ab4a0145c72922107433a7bd454ee79da3876ad82ac6b13e988fef45f52911f34dd32cb91a7c4aa94985bed739a3d2952301da7a04c254772908cec49d1f115ec9edfe1ce711121b522bdae6cf0449dedbb87fbc3fa884f9fdd91636f8e2836c27c0dfef9b71a9b5602680e942a1dd9585dae67e34678bb56425dbf8285db03aa159beab74952aff68a1e615cf1b539e5dfa3dfefbddac002692846e1c8d9929e91787d7b1eca7f0b31fff17548efb173cc2faf4ee776905cef64a8f3043adb6cbd1bed155dba1beec2c465583d917eff88fedd5d0260f4f5e24fd6559b3bfb31f3af67a9cd01203bc0cefa7885294ae4e279b7f50317b7ec216849cb9b51267e2628031cfde06cb58641a6dd1e526a56e095f1e25c145f8a52a50728b1bb966592b8a22b4961ced39fe64b1e9714cd87fc8506b26ae392114500127c7f62f17968ec3d4d157ce1884d35c7abd92f88dde83ecb75c102c3131161b41eee56ef7ff57bc5a6e65c28e091141edc7c1c3a14ef90871b7b145468084e08e588793636341301ed1d9f2003d878afb96836d68570bf0ab9698e47c7ce5b5233ed1ca986e2bbff6e4389b07e34f4d623168c43f2582ff56c540dd7e079597e0e3e88596d650eeccc2648b3dd625bd36cf44080a210fadfbc0395347d234c06eebdae438ce0da506ca1ea6a26df5d95b55f4c8a4d8edb1d2a9a868b151a9fbd506f4593bbf89c3afd229b60f77a90558c4ab0484fb133ecbff486cef0aa6feeb5b303fe28c4929cd4d7e50e7782d95c40dde31532510ef00e3f574bf5614737079d40885e4125283a8d30254ff3aece2b5f16de1cec6118709272cfbe9637ee50c361613c223d1879e9b446785394cadc98e6e600f25d39497a45c9f3c9ce6131079d10e01d74eabc5ff33d7398630f8c6d305828c117326dd4fc374619be7e065db22dfef405c69030bc08bd386b5c13e3ce044a1727f00975521f334cda51ea8bc131bdbb64696e767d5997584a651096f6697ac7d2c60750dfd9b9770ec54575df294af13e3853c04db824870c3a9c6fa6c1b82704fc2761519a57504ce161125eb3b0052d4b3e69f83a220a307088db4e0bcb57c2b5ee59e61a4425dc198a8225ab80cba9b720c9551fb35098e0f147df0fb2a237a16e652ca789e49981cb881399ff863b71fe8f2cbddd35e01e0dbfb0322def1b1365dc57f84823958cdadde1144225f4e5cfe88b56a1a6fbc75d23733d8333e22344570afc318530f71259de56b633024824094e742214889add4b7eafb80a99f0d2f943ff0877fbc57fd07a3ad1d7060e75f21cf54155e78fe02381383a32670ffb0d3053c2e71b36d50fd952283a03a88213a2ca4703d88fdb1a2f531f37914bb0e395ffd1e303c9854283d2f70e928a7571db223aeed0ed22064f3e332478d40b66c9535b85c828c1a48096a5983f00d88cf209629960083013b47eb84fc071aea4423c7c619eed9de08a07a84688d1a056e28f0b3a15d4abfe8189c5eca50f93d8b2175ab7787463adb8d70b918f22347d68c97194522a05030abc858762732c285e1a5943b8d90c2efc85de4483f00e5beb0b8b90c4a9179b732baf513f59c23e2e5bfeb1f5c87a2d1eb555620ebf5be96c16bf3ca1785aa4441177df59cf701f699863354b19162c561bef572b2d998554741e443519dcad88b3d4090e1e2907be1cbd83ca20b9372047d7393a35f071c9771f613c0ac28262c38c7642b7a2f8340715f7fa52dcfdfb410ee9a517f1626800bef2c2ac1126207cdefec569ca4fca8d2218f6b9d9934363067a550ac30aa0fb9efc5e266bd5c8cb0c0752b4ce854484bbcc9e25df425b8587df683eb4f04fd47b181e34963f122877907bc9af7956b098c4f5fc80d96f783d65787b538ca917b6313bef63055dd54d9e5f615a4cde3e6f76ae27bc42a0e6fa04561bc59202fc214005b6fb6f722b1f7739da3391a6c7c1051156a01270d39706498ac9926c13ab46f952593cf02f8d1f1aec1488d7fc5d3bae3273d08f89e97eaa7ec3e542c525a47a456d108d35e9779ca290a15c2c4df85b50ccce36d466737422802f8beb6f4bf2b8809d8e34b284f568d520d09b9b1b591967b1c149ae4003508d3e88535b2d5e3ca91a19fb8c641cd3e587216825ca0a106bf287dfb6de4133207a01718a0e98912ef3852935ebfcc06feee5d920c4da71e4a94626788c9658d6983708d71f55d68d1cb432ff808634cd2c3401e34514951f036534f5f814bdb7c9ea07b29163c5783842ecafabae1224ef9a3145945f2cd681a406dc707356f305a10b9810dd07aa3410ff2ebccc197d7b7ade216391ed18718dea969e6d047eb4c1b6116973eae68b95aa4715b7358be967bebad21548f9f7960cf3c7dc4e55ffa8c02ca73523035a7ea5775980e68bf2cd8496a3e6d0d982de37295624030f3bdc6e44739a3e3922476cfb4b09bd8c4a49bb4cb31e39ca230cc99ab999a655e4c6a611b5640fd504ab275cdfdc22e3fb549d58f37f69ac0db35b6923cb47ba68f6d88d39f82a76e4be4ad4c9a32c8c89e1a41f85d42a4fe0e6965875832d4fe211262764c5233d57c56f5a64b6f9cac2cbc496668e983f6b1525fef70fec091915a79eebe7b15f621dff7b324ac796b295c95f8328f42843fe34c31d7fb9d53462da3391b442f1fa2f454c8047a40894808235966e2b12a95c2ba69c0ad27f78b1ee90a5396e9b0f879c8c45468bb71cf0bdaecc54da757077841998d8d7eae52cafad0ca8f745811ef2dfb53d735360fac04171d9ac7d912e677cdbacfaa1ab350689616e8ac8dfc5cad56b92cf8a96b0b5daed3af01bbecb66ce052854ee710f6e46acabdc4039c836799f9e5cdf7e5d9ec9df58c97154b01edc2927d889dddd808275905c0c03c7a68bbd4db0860a94eae15c487cd5345bb6f8fd4a209683d7db253394fe8bc1f7b80f34ed2f3805c17ec23728b75f34b14cfdee03b2dd247558bfd19a1a862cb649fa60f5d33f682bc0bd46f710d021ada05d9dbd23e5249a39947b07fd974521d21f40ff1f5587b2b24721332d2f85850fff29a565878d9870922654dab60075e1de11fa41895a7449a5a0de6be78b87fac2977af3a31bb286ad91efe14031d8e0b9c133d7a58d7918ccba4bfbfbfd9c666f0a646b78b361c8f50667a8556b9ed0c4bd3110da222b7e751fb0be70f67429a14562f6f098ddc29d91fe8c56147f92fb6e4e74a35fe7f2d3ac93804b43c422c6962b10ccd1ecae828458a1ac6a9beaa658f576931d70fd238ed5d6076e20038ce8f36d9479b29c1510a23a92fe89f1c0e6ae4da0a635c0aad08f13f59b83cad41578cf5aa4f9e13c9e2c20a16fc91a75db0d42e29f16ddb010804bf6b3730e324df4f9b1dc9f8511542316a637b958de55c2eef65f6634cdf47798e03023c6c99ce220f246ac4a241dfce2d5d3b401176a7278d04d8a75d364c21e6b798d16b3d3b212f5d3b05a075ff2875965f8cfacd7886cc7803ffaa3bab654643557ba5c6e33f8d82bf1c1e293e11c311dc71da1b80c6a78cad6044fe369813af8f01a00b3de0c23ed039acfa44f7869c70714e98be49dd1649c9f1aa44771fb103b27a350fd34481ef0c7eac29c24345cc37d8c25428d3c0a4197b01ee9bbcd0df8a36f1ef535b27361d238cb9873c06e1c330b5c191180002f698da3d83b876c68d73502ae89af3236a94670807c57adbd445ccdf400a05546f5095c78b025c4a71e07863426bd84695139c0183092a0c7953a9f9ed79a5c8e5a1c7405358723229af9eebdaff3e3484f57d92c4823e9911df03095e7a6fe9472ee208f260b45e4067f554040a200a45c24c5e77af941ad4e071e7c72994076d6569fd4f147b3838f7ec41cdcf13fe750acb006a582e4f9d627c44df6553dd19c3be3f5f3bfa1d47b9efd1f6fb4db0d92a5f505f65e5bffd9c25f3da4ac80edc61ead63189e2ccec63ef64555435bc6130c2f9d1f06606f637144438951d51303189969a99c6f58a93ccd337b54db708bb59da7a95290c46a2478dfe98e6f1b82d5a91347f5c43570e369adf0ba0f9502c069aa665d636c504ac2002594ce1bf045b7469587e70806b9f81615bfae429ca7ea81b3045b4b0bec59d5c0bcbfaeeac8d35c302f0d5fc3390f8d0b46fbdf1239c0179f6bb12da653cab2b45eb8efbb5034d451da1a3372d7d40dd964c1fb5ae364034a4803718224584c158ad5fc62c105cd9cf048c907fcfdfd125aae303e93a83d7222c41903d6ae8fcf8882bdf49d82c9e279a4d4bb153ea59cb6ed6fc16fd11a60a5d554f0fbf90652e12f2cc297649d736677cd97f66fd9a42dc295795b879d04baa891a0861ec96aa4fd55a8276ec59f51e53632142fc3cdadf37e17f8863a963bf0cb0963ffc777754b9ee2f6f68e069fd98b9ff1aa383baf6b2ee8d34271be673d6f3f1f7ec9580b04cbdcc6c3a9a1dd95fda9f44c2f268b0e231458b02303e0b52903a7a945fca5df411b8b20bfaad63cffb81f6ecb925a1cc6dec70540fc1f2c926f661d1fd8f7cd0a82ee2ddcbf89e28edc51c4bebdb8c501511e2d07adeb23390e9f8e0a4c9b58e1745cc10e6e28426be5626135ae0451fdefe6a771414edf1691aab5425fa43b34cf6bff49b443ebc2ae7c33f37e34a21ac5a948900b42bfbe7323647961425e7caa85949ed608eafa2979c30419d7e2aa2fd9feb0279fa465a08013f7680f20a920e923bd88276133fc8029e827a9e6f42347a8c4714720a09dc59a95ed03a82a751f8e0fc16012c88b3c352cb73c4f27049b71f60e4a56185e19676d232d5aa082eaaf583b342b591e7132d42a9c67e93d47e6a4034c3b7b0f653954d175cc3ed7ab3a1a2aac06517d0b8574ec8cfe4a39c0a22f5066b630a5ad38b749052c2de16987de5c0ec06f4f65616597c216ff0bd76e5a1b376dca8569fc7c0df9cf1c9702101ee16d69da61cf15a21e1aa24bbb78adf02d72c2f195992be06aecd756c00512fdf29050685f82712135eb0753511e68872224ebd0bd7aef43b74befaeca39ba0c77ac6a7e3d4e9b3b70caddfd1d77549034382d149a60ddd9c81232dc03f25c64dbad28d8429d18f3dff9fa4b3cf87908d19c4aa3bce794b42d650b6419b1da275b4753323f1944655255e999989e0db5758c5daa9344959a580bc52b1cafd6b46b8f07d784a3f77b60179ba67c38daf18c1e35ddca03e62f48f2f09ceee9b7ebcbeb63e93fd5ea616eef2597b8eaa6bbe84982a8699929e2ed87bd68daed66d7148e5ef1dc0b15faf48179b50d3183914303777b94e96a8384680a8e83374bef24edd99178f1b8037f987d7d3eb0456bb46f92477712c0fdefdf8e83de18d733601fbe02012e049cca719b1cc26af9b40aef58fb2487ee61c40f46265dd1438c12ec66637ff66c017d92de35e92ecccf9b992531fd2a5c7221d227a4c878de53205f6ff45a12fb1c7b29e7646550b96c2b0fe1cec2122d46106d3e60893a3d74558c55b97d1eaf5250184483ea806365383005de9301ad329589e9bf311d5f0ac76af87262ce9d2e890c33385ab34de6b8b8098ea40236b08404fba7313f14b1664974f382b11ce894c20532e8dd7f2ade4a82270172260535dd9e711a15f877c667cdb787292296aaa2ef6426a14a394829396da07a3fc07387f3381ba118cce744dcbc5225b2453ece1d42b06bf167fbf64cda6f2772efcd71b8b5f43a3bdbc2803147098a4684fc755ef9fc1464be1ae2fda0fb06d4f38939e83e64d9b0365f3102f9db96fb1190ad5db5abb47d7c4832261501bbc99c888c43f1c8aa5aff7540890f04b7537bbbb5ec1144497cb22ce32fc9d462a42ef81c576ebca6f0f395e05a4d6fbab0d22c9eb41e7eb90988c13ca42a4802fa4fb9256f7ecc0af354df062fe71f53cc81fde1f4f807dc189c9f10c05736e12e8080fdbe89430fc6b726c85d462b9cf3118fa813055b84763392965b42633bd7c164ee30ccbca6a839163afe846b333a814c206528461774addf84efc0c5f754fdab442514b974b86d00d1f8e504a379679a554a3a8f55c6ec407514be420ed0670ba6487034ed89e510de2e2e751e6ee73bfbab7d7050d13fa2b282b8a685f5c88593fe17e120470098a57819b63d9ed1ff70f321777164bb9d4f2843e3f85e3d9a86522da6d66af84520a84be536b651dc28c744c9c9064fadc465918b1833f2de2415bdba8b3f97cb29a6bcd6fe1647329cbd76a06eb359c4380fc9dbac6d19a735daeed1667ea17c1862530dce0da6923a60a45b57ba22e7c8fc1b76b485d334e9cef37ec7da8005f47fb6af5f02ee0b1a1457c702c5c7d7bcac14042482d0a13ab0ea5f4f30b696bd87ed70801b76f3e67450b122566248af83f9b9624c6686270ee581e6d93312195b5264c482c1565a68894c126c520353526e0a129c90254450e5de8875479e2644a7a435319af1b12b54c3cdd6d4f1786f4d173938d24e4135e878ca432b85bfd99f67d6f46e056110b1dcf9e6b77c9a3bd81aa7be9ff00847354400dcfc9896f2c668a04b4caf9bb284e1a9e1c58d5d37dae5f28d1959a6362d1ed77f65afc33f4b2bdc0cb6c733dc6bb20f923f4b98c854dcfb9e3e842e7f6058ce69aee594604457d79af4deeea59fbe9b9d17ee831183c11b99cfed6e04ea3dce54d345c3e4c89e385fc7eab2d99b3bf33bf350156f4937102bfb02e94ac4cd9a68455f7cb3ccc3ab034e81827892b0b463a07cdb6be7e504ec0e7585592db040148acb2755a803f68096bfd3deda0772b526f045223d3c16913c0d03764e3bcb1722bb663ee06ea083e0615312b7eac91ab1f99785af4cb71a23c0daf14739d157bff4081cfe5277f4afa7cf082985e62b314ac29c41de62dad6f5574111b2eb1d83967975cf88ce090f30e499653cdac0907408175dbdd5354d7dcad7c5f21cd876d6c433199c39aab0148ade96ecacfc5e15983348747b33f7195fa2b694d42b67006bd4312c04c428350a5be5a648014d9d481b10097bcf5977033182a6570ad2b6f84c051eee979758d47dcafa8b680fd2117aafdb24874b6b28911f06b72e6452baad77f49f97ca8b592b7dc42652b77ab9ab81bff7145b3eab60705908adf831893edf7125bc1a0cd7033538152542648aaa6a36bde27bb1074ddccdb9843b1d49d6c7c452b97d8c0372b622803852e9c69c6a645542de8ecf888fcaf74a090c8a346258bf822a1914a6b218df729e8784df03f1b025a2788d14462ece624fd77f9a26420fe3237adbadb3c145e9093fe38e07477e04f076a40a7b39636a4155c324655eaf4a7190224d5b472522d65d2ce5e6e71ecfe35452ee196b332075fde0831cd329be6c3ae2cfb5bbaf7f9e58bc862c79d982d5c7390d3bc238d852db039c0edf890f435426b78bb5e64a13d034135df7ad1c3a7e4d303d5b460aadc61c1d8f851252fd8477157d5144aa43e532811ef9de31f7e11f834fea1eceb95a9ed980153d0901f72995d2baa27bc2141f695b6f90c3a27f4e1ecf628b5d4d6366bdcf9200fb0a67b267a1771608bb87312c55f792dd84367f1b409c167eed2e5fdfa47ff732793cbb97095f2f3b3dd4b8723332e6f543105fde685945896ac1c167106e3a2da0eec00e3dcc259ce7f65abc6f533c581d07e1390b227512e7be3709ac2d117f4c76a00cc3c46d149dbd7d09eaf3e40545bfd0a080ad03bf9a4d2e6ab4937eed50e42fe8dd5047726325717bca189f56ad3627e8f41d3f87187ba0617aa6cc41518fb6b94dc76ad28232aecd308684f83c9794604684672bed556855a5ff7ee837d22486afc89af18b05af7e4d7ba0e11ec9b90d0fa5e02a0e384d662e64559e9ee1da82f154079086453e66cb1c38c69e960532e900ef3999f3413c27015461b0471d1c295bcbcfa1251d4aacd11c75d161efb27dd794dedabc62397a123ce470abe8ade33bb8c6e43cb62ea7c812bc0267fa2eb6e86ad900edb607df1522313751dba54eb670297c725f0ac7a8726d877183f728ba1ae3e9ba1842dd6d4b2220624164d86c4ebc0580a0c3dbe37d880a3bd03085afc4334ba50551dac03e06172648baf4047fd9d1d00dc29d4dc2be383f175f5048a66e0c8b293b75d6fa6b917854c118cfd93b0000d11e805eee9fd2632a4751659edab749600a46052820e0167cebd2b50011dd20d4763fc416895bab924bfa02c3aa5fc335d832cdf53af4560a0dc37734fc0009b724fe40d723d0c421cd1bb83d75332ab9edcbd936681812cef60e60e8bb9ec0d7690cac88a7854c449928d33fbaef2335420e0131e70f453519711409c9a840e89c56c2216c053f04c47d1d6da8cc5df8b21b0c298c44b61d5c303d8f75df63aaae52393edde203d5caf10c22c3bcf7889388761f9e0cc8ad22fb7db294839b8e930751195dd11e1c4025ea30f5d5600922cde16fe97a6f92d86f8650b3079a7e2ff706acf12d564c4c0013616bfd4d98ae1af856301bc607c00e60c0cff10f87d44074757555001f7e2d5904dd33af105c497b8598cefe784df44ac32d077aa63670205e9b11f0badb21684b1bb813485590cfa959d276b580fbb507b00d407fdb3675442eb06bc8f69701e010816a7060a1d2ea3bcef214200fe544fe22a9e8f9440a978b79d8b190a447f7cef16e45352367868223723c6dd843f063862162f831949da7b4f0a3ea320049bf62fe00e6d6d0b6058386d96f093126d171f10a9385774019a42a3b23e6b343c348ba1966f736e713818d914b31c2287aa1850f7d25ac2a4c13188910ec098f240285b53b46307e40df58ef180289c5b9041a1444335da67a6826a7fd1de9d734260ca8ba7d33369c6d0f0c7c96b5866d69dab85fa98ef85767b262023a0ae345687d0d48b3c45e59f65f01cac3898cbb77cc7e67d0bf9c71830949c8688fe7e5808a73791699027ce3a38165771943c9bbff5de39ac32b4dc2cec36b1eb0f85b03a5ef3292b354ad02bc3ab4d7239e4d665161981e320e082b929b95708642d3c6595ad63dfd6bfab4337a7e2c4e95efa10eceacc9ab96331e452f32963eb19bb97dd79e5dddeb9a5fe3de809fbc5c2a146ef4b92d9d6b0f30f22c2de9146497a77d66834afe8ab83f9049db5330a40a59595b1c9d2665265d3d4f0b565f1c9c1b5cfa435d108a911dc8beccb9722b480a49924a398dfbfa6042fef538c9505d8d94ad54d7deaa04d9ff38d4deb91c86107c154074acf3b22686759dbbc5e52eb97bbd933999acd35e44e421b547d5a8f92df350b5cf8892a433430c604354155f8fe684927375ede674706c5c2a3279df958a625223688dae9894a389bd0e64e6fd8b21acaaf0dddcd482a53b88634c43bf8e22ba79f4e2dd7e3267a4a820967463188198b303dc370bd8837250fcf41255ae55906891b81910038f86a02456b1c51b11337c6d21a1c7cccbbbe08c7c1bc73721a84efb45aee5c6956587073606cdfb580137fec24b3440b2ec83d361a82255bf39e03eae1d5a0db1e0d8a97d050c6b4231f4cb0cd4d3c364bf4cd238c92ce745d2e7d215de13c6b3bc4b6d3c878e46a5f3591f4c110a958f884254fe739e7e2324ff66b26ca8f2cbf207bae82ba330b6cc6ccddf3feb9dc1d17924c79cc01b93034fbc8d343f12b6b3205eb4e40f98c743b341bed747943bcc6e58f2d983ef9b3f7e9a39d31f416ff1eba6930656bc60f960eb4d3b41a85fedc4f739d2176e57268a357d8c8dab8c1bce29a4d0539e96012319e7723ebb6c11fb3ebd9c8cb2a2af6eae03a7d2f7c2c5708a99e708271d9cc9c23284e569b0659b14609627ea107190c6c6591b93645ba3a5d7f7a2211b6da167971fa4d577e9bae93d1678e63adb1a3a38c5b84d2376ee0ed0f2f3d63ae760eba6b2847a855549a8a5de504fe67b6580e78514801de82ffc268a3a2b8f072b68ddeb78f923451baa03688d53e946969b800d4250f980139bb08ad3c1858998097ba0e67426def49f195eaaa388a2f7a388aa47e4f31a74a61943908ae3bbb3057c118708b3e0a89fe74fa805e9c7eeecfaa034458b5045757a7ddb9a122cdb7d1241fce84aea8e55b3ed002b85e7979871e0b588fafb152c83557fc5f7997b6bf8799ebb09165bdffa8e778ceb7089207999e93ef04b61280ed8c40edaffb6ffb5387b21987b484be1c023fb1144c1e4229b1aa8edd514cefbc883d1590785a070e24f560fb1500df699c77a161a3e19ca11df6d0d451b145f39cbf7780d4e210034fe601e77365f04c0f04f0667cc976255f2690b867a7f6932aa7d95d8eeb61a126cf731fab0ba05a5511439079776ebf0cc75d7ea4db677a0e3c921bb0a13cf70dccdb8df5dc76eb3a9f6f24c437d73f7a863a6b165d6c11bc635cb613f3b82a1425f2ad967971123866725d4e25597829c025aa4d0d99abc3b0af1434800cb341077fdffc0c6251092565044bdf13dfbb4d37fb1cebcf3224c0685cfe672db0f0fb7a847a6edb7d083768bb5346f330060f0ac4725cc0c6e422a490e6713c9d9be086e8414c86e438c4b5adee7ea83d2ae971996ab5d4bba400d3301e540d47ab73768dad43635e61defe4929397da7b88df56db945ae358db76aba4160037195adb9b3c342d20bd62eb369e9d6892fc9c595670e6841fd989d67a26cc064f06744af9e94d915211f40b31b05ce257e119fd36b3fe7ab0a71e9388e37bd89ba4786c0c33610054d8f0cf5c38aa8249ec5302c66cdd1f4e4674e4e1e054765656b1ea3071361fa2a6c6d45c2b745bdc43360084051e7e24caa4bc5fd7339b200c587a141222fbe51a4ff34d4ea5c768093627d0c980716afcc68517877d73b9da9a1c6c535ca7ef90557047147b56b531928321a0145141db5ae70dd244231e91ed773abffa7a187307c05141ff48270fd63355d6b86e7888bb70544ae499651a0d1102c660a10a2590c3a1b974688c32a1e4918a9cb892bb3dfca0c72ec6a44dbbaade91648a3a1e71cf91c00031c527bef6e6e4b2a151c886921a7ecc25a712b331256cfcd89f40c0709a9350777bd78bff84aef501205e937833e8f12ac12a51c5931eb5b960f618d1cbb37f3289b254d474ac4442b85c638548408a547cc8c0aa0379658f4dfbb1be8cbf64a1fe73313f73347942d1d42c541bcf4c5018478dd78a3aed5da38924b5747507b3a04471b83c82907d9be0b04188feb6aa55b5d4002fa1f70f08b0a197ecd77e970e782e55339aa3e41012bc800aa32bd20529e52355d97ebda967bcde3ebf93effb7e4a7d0e9028db95e042ef0f8adfbe0b4db738ea2f40c526f739d8031c4c34c1c7b1f84ed9eacf7d76a85792519b719f73d49455c4298b47965e2efcc87818d7803e1b0504df610622bb9876ac4e471731f0236c7b8b2502e2fa76b4e7bf12489a045a969222842895cc2e309bab99d6c7fde37f91d563898698f7eb3c5cdd1812c1319f392bcec48f1c5dbce82008b5e45cfc4b7f1dec0cb03769706fa8b395e3a32c26f2726d0cfc6fa60375527c52d39a31e6c994ab119aee2c3f56d956d2b19cb77cd621881638971b4d278acdb87c6a78195798e9670831d258cebf70f017bc539a385cc8d509c8e1996","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
