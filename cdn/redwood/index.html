<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc5e6da19a7177b60939192ad387c0d84e2219753be5974a950524f6acdd6ae40b667926b942b3d4f103681884ad2f83b8dde13a9d6b5d4b48601006d6288df5bbef52dfa92deb25c1b9ecb0439f5684073e35d02de2db44ac18fec49ac1cea98ff27a9b3317ca94b8acb76d4a3e8844a7f73ff7422442783849f9563eeec3bce142872d52fa589e3406959fc27818b60b6b460365c48a1bd3b2c8281721ba797380bc300e5eb28ec460bd5c6ea50b43fddcb7b2bf073a56592ac24e1c015fcfc8dbd6e8bfa9a3835bdf1b7d1eada0e80fe9e7f9b788253941c3d6b1a6930900591335043a4b067f6913ff88140dfec899e342d22354a0fc115ce8caa010c011ecdeb667f7919b080398d6eb8bcae1da32ef102a78b281e806644fa904bd13aa067ba16db7adb383e8dc5f32daa39577ccd65ab23d5eebb4735052a9e715c0ab190712dd7d64ea1f5ae4facd7d9ce94306cde5c5b252c83567365de9e86abe0ef2c5a8d481fb8979189eaa3326fc46a84884ff05c3ba716079ea5ad2b5e6fc0afbcfb3c49beea588d69d08463955e734790e57d504d8d247ff3435ba1933db0baf8cbfa42d7d5347ca17ae773c22a8c3713da0ffc1f97760e186fddfd271162eb196a964bfeb10985849f54427bcd763f696d02ad127dc21262bea2e8dd87718fae35b94663245f762f64ab3b1bf6f3c248722eebe95ccc11ae07f9c5cb0d1fa17ae79521d99395ca2ec9fd6ca5f587d986e48bff35aa2c22b4775903f69d2d19934cf1b0475b87b752c037de2324882e5eb1877071d44cf6c87b23792fc12e521257cb258a7d312e49687b0f7fc886737f68ef346949c51228c96fc9d5d11272732de14f33a1cb9831f81006c036afd6ecbf937ba48f9d5eb5c0c71b81354b963b5932eb0a3305c258c0f82cf1983013aa76f6a38a39fa9462d9b692ae4a989800ca53d69d5adcd34557ae0d4cbc5a63bedef9aa6f431ffb5a2a3aadeae1b3b013d76cf5a2719bbed309c41e5be92e9b512174197dd262479c0faf9b0ba3ac248ca5f6590d43fc7b36a7775d8f39a834a506d2cf9793824e9928b36da13ad038d6b85e0c895d2eae5b946dcc190dc3182d7a5c9e1f2ee2495f0a7b0a9a644d589a258b41a9bca5973688d0d7a6f376d83ea8c96c5fd15288673ca543ad4a47743ab88c0ca3a4242acfe0ad890039ae1f6caf9fdd086f84930810d1b8621dbd4485eb0242b7e5f615c7c578a1e3da87ef234bc4f3cd3a83aeb92f2237037ddc49a1fdd9d0d4c8263b172b7d36e044a37e0c0d473683f7443e9a414b8f9c1db8bc921cb7caa63a7f35ff7b09eab6591677e658540a1d22fb77c4a912cec9cd89ed52ca458db012bcb42552d80611638a231904a5d16cf8fe73d574583a2a105d7f40a88cc9955ede12c39ef9ba5f40543c9906e722556e4e3eb40f6ee07651cbb4e67fa23647103d04a11bedbc40f0b04a4128ec31678d583b8136f0a88b1716ad20ca3d38fb272843a4dfa46b546fdec761a878a4639cf6fc6818f32edeb43d5f23178699d8871bbf27d9a54c2daee764ddf5267027a430dafc9b105c76d7824a5f2b5351b42cfce580ef2a2322dd638c22ee45ed89ce22db5300019697ee6d3eb86d59f4408f0fd2dd494ab378d73b74890f7ace41ae23a3bf9aab0745a1e99e29c7b2bb9e98aab0f91eab61d171015d00a5567d13f25d6a5cf42b2af8e67cebb0f666b7b01694540efe05835ae3b283b7b3f8670ebfc471e4fb77c7c84646470e2de6ea80e2099dc562640eabc8f226d656bfb94bdbe84df6315e34b55279992ef66b99b6b8bb154e823165ff8bf8e4234e8e3e81e8b0c3883888716f8efb8b07fdaeb63d3b9872f9acc390c18cec7cd45e38e17b2c0a91b44d8366df694f0fe1bdfd74a7d2d9c08ca259a1d614c3cdce54e5dfd4cc63e081a9d17dc242538813c5e64c7dcb56815f80a07f20fdab3d7aa9ca192b9440e8e46adefc2281714a52f90a9a96edc9aa75193f31a635cd16e624251fa8c3473e3fe9d702b9ced8666838ab0b011c3596bd9a18feb40140e34540b86dfae680249a6b96a8bc8fbda2eec38e0405c75a5beb2aeb5751ee4533f30f349fa774dc6bc30f7a9c4102366743c295896cdbb38e1cde04b4a3093f7fe0dc6c6bfed160a758775bcb636e40f715fa495e715f189bf6b40460eafcab9959fcfd92f8db2abd3896eaf558c60ad1c9270bd536bd2a2b740d5412c1bcadc5aadf950b4ed3a4b5fc46d803e9d6ad58c55058441adb2cc1e2bb0c1210258449824aae44dda84f69cd4bcdbcb1e62c7eec32dec3808e931f1dec9af2339b4a83518201f8d61bb3d93f0a1fc601941586c3107fe8d1ae6cf483ea5cf25deb8076d4fed066cb7d210a3689ecf0c2e5c671d226f4bb5777de2b49ca60f8030b7587cdbbc8106124831d14efa6406bc04fed266a6cefc13ee4f28daa7af0cb9ad5177d70873edd51dc77f54bd6d5c0392530128ade56b0226ee68a4ee7c9bfc6d1f9e1d44e381ab6e5902122ed9ca74d3e60919f499ab8de11cb5ada4532236a5b503cb73d3356383d4f7a8cc00156bbb0030ac1bd6a2bf9a0af9f004a6e6d5c3aa5237170807225abdcae6e27db68832e26d4e03309f7aba6c8060edf478e4c48d0b67d1843c9e688c49bdcbead8da7bd2bae5e832f0d65bd0e6b22a165d6433c60997b3b6673c592e3d94664d554b031f2e2ff7dd67e132c35c9554a87877cc2fe643c224713fb1e09231d0f57e402116f494bc5baefabc34e28a34cab41898aaa40eb03a2ac4975ab0d2e82b2cfaaa7ed141c7a08759adff52d645c195f65146cf63d9c8cfbf41130a5626221a86ac6eed41563e1bea67bb0f663201759e6f635b9ca3e78b1f625ce6f3684ffcdf7d5b0688a3d0ca7a96772677afdf13be51d704ca574b3815a9963f80250c25ca09eac6b3df215a36a8d86372b3f3b24b5a99bebba2f42cb589582438fb385f5da1941efab8de1e89d4abb71d3f45b693a7a94caffdc405e5d8ebf2a3110db71e351eeb7574acac20319da9efd9e4b791e0ab6ffec7b30a86dfb3fed591ee1e4654f923a8245cd600df80b297989b49dc0b2efce1f6b78e49a3ba5430c3055ed4925676ce21111aadfdbcbbd65d290ae6a6d7b635a6bb3a8594cd82d364e5fdb09cd90cd6476883cfcbb4d7cab8d0ea19e01b768dda68e2ff7eab7de2b9fda361a627c1fd256761380781bb259878602e9d79239138b16762fc955028ca48cc472733cb422ea16ed2af4c3d959f034ea9e3bd53c9ffa53cc3d66c4ea67c4e4ff05ac0a593c9bd8a30eeba767e23e5cc593ffaf9727d43be5b6db27233a6422aede4cb5cb3aecefc0baaf4ca7d201c4929064d0de2fa0651973a063b953658e140692384113158bdc15804af1321412023010edb7f826b48c84462328765d1cf9a06a0c95c7c022937464709565cb83abc82f60fc0abee9097463185a1e2e8d93742c1c7a9fb6f3f0194a68e0d0838a1bdc22bbb5adf75fc9beb0ea93eabd04bf6dc4bd9ad26ab4daa0ccc11806bc13f9f66f5cd96fd074adabb8f585a38ddf128aec3fdbe95e165b409ff8e4d668b36cc6e7164d448f50f7650b56529140d811277cf5a3839a3fb7dc2d24ca1aa8a86b358e3b2594321a8cc6494e333f8cbeeaadb2c944b92619c7419820d807c13af4b2e8ab64e6bd8d3c13a1fb1bc8180b6b25da5dd4359239f7d83c88c7a9d416db34c70b61b197b9e5baac1ea062198d2df5d1f9fb91b130f4b697f55e5c26aa741dc496761d5b998833309305debf5f89f488521ce516132341bddc6369251a59d1c526fa18ac79836201facb7f1a1d39a629b27eca034e0e1fc11f10c459b21bb7582713d6e2fdbb37a3642c686b69b777dcbc9a47d17ee611019737b01899fcafc9b5f4a7a31cc622e2327fdc7c0444d598bc63d08902e0c9b363d8487232c534b485096ddeb88829ea57d7ee70c75ef0faccdb3261cacd0d9729cde302ea392f973648f9032de91f52b07ab02be9bdbda92d9a7540c16367ec56d8b52a7b663d74fdf09d806893dc3914b085a6b4913cd6d42c272b9971f29744c775531c43908211cb98d863e05bf0bc2d49e84474508e3077778a9cee33ff155c2341292740e289498048c5cd512241177ecdfc02b8d8f10f4e4963b03aa2e09099bb88c12cb3b70d1ba5eec927c625340e901939b31c7efdfb573a9aa7de71181e89bfc3af49343b6266d5fe52207c641de070ecd6a5bdcbfb723bd38548c8ee805b57cccd8adec60fca19888fef6bf8bc8a3f98186afd586f159a09a6fd5b6c18c5747e2fff8fce9a284fb892397f34da3df97ca4501b97c5d7309b39ff925de4119b5b1396ad96121c4acde837faea8a19f1ad024766db46ce630104622919430ba839112da1690617e6f0f3309c06f6060a114a153d27c532360eb34e5e566d53c15d5d8dc764ece8e4d61baa55deea4524a5959f7d5ca360af565e0297fa410d9516bee58adb8a8e9c23bbb47ba8feaa777ed436c10d0266b2771246c7463a979cb31194fdf9e3e6dca9ea1eee370242539db88b2b4c6e90b00f6b92fcc7eac618826bdaaeb9210ad71590d5127033f868bcf6c52e8b06780c3cdfaa79f3d9d30b0668ed918e320733a763e37c241c43551a42f34129472285c7521f421d761d9495748034ce5add148178c6727716b771a01b98e433bf48460f1059360b8aa072204cf3828a0a7b7eb6c36b09b798336e3d729393260a82cd895d72db675ddc99a837034bb39a169ae1ea75cf0a0c3f78495bc5598763a7aa7c9bf0358a373116f5644a7972762be16f6e4d20cae8cc2aaa33527f0e5354400d9668d5afe0e854750be93c4737bbddfbae33e3a255814a6633fad17d43cddabb8ddfc0e50eb928654ab926c89ea169c79e6fa72e0cdb4fd047ab69050e2049a8b49ae01ee26e5147286c2699e5b83a4f51ca7a9ab92e48e08c4d742c04440ce19ddea70d782d77dc566a8bf80184fcd4f269c0e657b9165aa574f1594ed7fdd29b4a5540989629987a877527ebd7ed35e88758d0e3195570addc41c6adf95d49f1c435cbe18a51a6c06e554e4ed70d9a2293d88ba49c76a55a636ec5c70150b1728e1c2f10a400e4838d2df978aad2c26227b29b18c359e04f0d751d1775167627169827a3ff25b2d2697b2c5f52d68bb2d4915d82eb87fb8362b9e84b33555d4ed631ad6fc228b7f6d9361dfda5e8d5f5ed3606f22751e16465dd5eadb8ba825a0abd57512f5aa1530b9493ab422c9fa97c374e6e2ba5fc0b8a8d8c03c577fe2cc4a778cda09d22700f397f119c4bca4f978e6e299cfdc818660be5626a9c6949ecf4f6a0a48f3106bdd80e526fb14ed2a7c36b789f50afa918f516ac0afa6e686bc357a9622e67c2c86a387d375f40757cfb0fb7401130825f7edb7c2d624ca2cdc23c0d20390b0b251a29d174c0d284ab41cbb550f5ce7f9bdecca72f817d26eea1363f204740df9fcdf04781b7973d3706a26e87c2729ed1688dd179e07924df6b3e46062013238de463bae2d36f85bd3ca61c9ad4462ab0a9b53adc736406c15e2d2b79962749ccd409790b2004d6ac2a743aa348f65bc15e6e85339356d9a736a52ec929d9d1d2a5f825a19109561278bbe8fa05b1185099e60f4b4fa190d82e9c51cdd7e1822b5cc7f70336e001b1587166c489a6d0a1b2a51b3433d8bb1f86f2fc024bfe79e39cf89f6fae3a30d8185f4f5ebec837bb6c5c135f5a2fd41f9a5ad993f250fa255dd2c1aec08793c9f121e2f0ab599f772144a7cd3eb3be0821bdc1f01f67e4c40bb1c8f542b777529b13c1e9e451571588c3c7146657f91222c04fcfc9eab969a41487333cc2a9b621761fdd517c560d441088ccf2501a88b54cf6f45b104531459d6eb380baebab2eaa16b8343ed7e82f056bbca8dc805f251d2d02d8c1a296800e58a4ca08665b694cb8459d291c5b39c4ba40f6b83c53847acec0ce3c61f39e5612013841004aacab887c23fa86301beef0b8879fad7ff11ebf900247a70b940522a35cc23f43eb5297174cb6982b5983d631682ce7065d3af11dea6809abe9243d9b6f321cd0ffbb1ec14d8bf874e083bbfe57722c2fb341ed2c67b141f43cfd8bb365076e447f158c463c762d204f401c95b11b005f5d0347d70b9c75d39c6998bcf01b42391ef3b34b1507e913810263d72aa6fec6f8869d28a8470ef1d7c5c1144772851a7c86169f5b9ca6a63993425bbba1287c3c239d3f835c939c496724beccd4caa362b0459864f782c1a9bf8fd72abc392ae25e7b42a0e7c0ef314a005c4fc33e1e67e593e8d2633233e5fc32d6a1f2aa2ccf83780df18fc1e669a8983e1a8c897cc9a212ccd16be2584353539fdbd83565bd8e59ac7af5ed8f67a629712953f8e148558b437928940214ae49d2246e4603ab5bca45dc960eaf862b2d4e8a6bc872988e101ca54b96c229c4d5ed57511e397a26a59828e547ea009c91fa885aff5cb9853a6e04ac18300a7c4cdc2410daff51dae2e2140b22aa65fcbf2a8f78bd77bcac7170ebbc34870f499c71b7cca61559cda101dcd4bcdf515c81f7838d89dc7ab1f56d0f0ef2a94167fc56277e93b404f09b8944e470fc793d554bac2e24f59890c0a72813e016a70b907f26beade78cddf79708420bd7892b2f449b51674a8de030cdcb4df1849cdfccf3d0c6b7937dec4e9d8a7c9014228017eca168e00c1a7f300281e1ca0f167221d6427dab4eda8c447d7aeec704ab67394b99280468dafbd2c996bd2cd233e0be549328895b656c4aafc762b301a24d969e872030201237e86e104ec4eb61c8386214fb33e2bbb3314dfee577633b048a2da662ee97d04bf9bdb826de01359ca60eccce4df8e892fa733e6279e662f583c975971485657e7e2b97f9fc52ee5fb232d48262c1c767f920a5094c409a252ad62120bedc6ea4bde36062748bf15ce9d9cecf3a4cf685610592efcf401948106ddc6c9d4ec0a0caaff680e5c077224909638b6039ecb98684ed93f94e7a9404eb07a948fe3e99b981778f0a30f73d064347b9e4dee26a43052e24eb625f4117a54663d293ff0c91f3b400c085f76029e50baa6085ae7f4cbbb28cfcfcb734a99a5d94b80274114bf857f6f6f58c3488e7d6697dbf9670635f7aa8466ec3ee609527c138d4e8f33b06d88d395982b5c92dbd45f1d9e04f2aa915ad1ce551fa2f1d55c87f76b8dff172db427987004330fbe236f660525b3fcdea985267001fed003883789c40eb775fc80b682cea10b25911753dff21f7300baa20272ffbe891fc4e61284ab6a16d14ec5a54a71fd18baa6d722ed0df767ff2913a4e0d45192a00d155c18cb34ea7fddc9bc226dc9fd7c8ba47555c376e619dbbabe11e73d013475c867c898d5f94259d5bcfbd9cff4d5c4540c20f14cb397c889eb41772032bf3a2dba80b363e9228fbd7a4b4a5c336bb7581cd3cc68b10735aa87806e74dcd9f6d3e6fbd81cb9df54aa6ff38c9066e94102717d4f03c8b2b42c8db5747bb5cda6fa0134ca3da233d0d507e299fe660ffc33be99b9262c5b974d49bbeb4c6d76b0dce64530e6278fac73009f8d6999f8fac2182c076880678de21da886263e7579940fe06e403138b3de609e59bcd201342352b4269015fe4c4ffdb19bd36cc4bd3ae5c510c2c0c31961b2124ef39c77a3098dcf831a0e6b9026036c03354fe170f0dd1f19b6c3eddaa53d8f2818a67bf06de801aa7fface56ab5d81f14b73f333990a7c2ac3c8834ba0089f212e3af2a00e6c491310b08c93b0b701dbf833d4452872c50149f02e4bd1075045ffbe3aec012d9a74138a82c1a435aa61488dfe29196d2f619033620ee879a23fe166f3486d69ce08f75f4228075f7c0e4919d225c8a360e4b18cc549f59566a01d7c9a31050c8fc0d3849f67cc61399297a5c2318c3f01b131e11949d5dc5f5fe42260478becd0f3ad25da0457ebb5654d131eb92da130c1fefed979460efd21b0c79b04ec29e153ecfdd75014d875b28d957282b968a91a7de4adb82800aa3120caf86c6f5fb1104279340ec4907e9332792ec28fda05a6f43cff33bc8202e7d4613bc2a28dd1d43c1bcaece64ad8e081164c4017cda35375acaab8982289ae833f340852f8a6112e104d2926392db1bb8a6fe31230d2e82de2b118d188003af3ceda6588547437ebd334f248a6bfd4440044cc639b132f83f713c76517027c0ffaae999cc60c4374a813ca4a8f1c7e302c2cf3d9615ea2421eb0aab4b48ad3c701e927a2866a0afa8eef55b026afb9d384a5b044d4ea72813fcceb41df80803359b19d4a961bdf44129e4eec6d955be39dc2d00f40d9dbc556a6a6f612592cf2b73f7c3a2abaf3813d7b9594dab718dcc5c16cd237f135e3d04ec70eaaa5fe609862ab31befc0c931d7da88f67dcc2a5e8564969fa1f5fa4d41a84a61b25d32fe664ab168121264c7434fac4275eac588f7c231e0599979a338a328bea0cbbc80724acd3d44d39e359426335cba6d97ca5bdc692a365f37963daaabf181cb9ec33fcd86b8c8d858321e0814017663ad89db5177ab54381b2debf0484dc10932103acda4f81c39b5678a2d31eae7a7e595d7076c6cac79fa40415e9f3a201b0758dc06670f49fb027a294ed31786c99f72fa524a31c9c799ac3bb614ef64ad777f65b870e2cff3dfd8228cc3e8a40d5ccc1468c3ebade20e30b7538787afe26afa020b25371b35f43c7e462def887db5659837d7ad5240d3c66170c3b04eb0571ab4967e69d4cc4ee0250fff30287a85fe5d3d79227a75c5a4964ce2479a168fd406bbc31cf149b8ec20c5ace1363481c8ccbed6c4181f677ed17d9d8a904be350676b8e12377154ccb31615c79be086bcddf4523bbd4ffdddf161bbbaea80f473665f7b56a2e9b7d26dbe0a52b073281458f63cd449062851ad5ab1270fad62fc735378bba2802e8eb50399ac504b012baef75eaa29707eb02cf8df91533c0145379b4b32bd6a7be54ee3e589563bb1436283bb206a70dcd18e70d402527eaa44879199185baf6eb27f1e1147ef4afe1cf7920cc80b8c47df44cecd0b63e1bd5508a7c0e7b1e32210ec8a516d8345f97193d11e5a2b829da32a1506967b9486069901eaa43f2b8ad0c06064dfece8a4dce37798cb77af840ba7af63eb14c386a1b64599989385b369d5b4fb3b7c8753c04e05658c26bd65e5f6e2710b3db5d48b99badaa7cfe5a4799fe62829039fdf54ddbdaeb2d00e79a96efed0e25f176500d0347ef626e68e48ccb93d02f42e1277e7adf9701005096e5b8856370844c377941501040a5a7c8dd00651d49b0f0fee148aaae3bdafda8f871126e9fa8c8c08f2b9704184fa7eaf434309079847591da2a215bc48f495557b7d2fb1181acffa529242b4af08ac14e23cfc4931610771252bb2f22555f0d2320247e9c32897addb6464178fd50ba6ea3f4b2b11292eef7cd9b42ca48228e45dd8dd1c56822fab17ced0ba8db7998f11d38360505b83d19a45de74e1aff29c1668e750dc7888d5f5a8d8aa4adaf3b5fb094208a9dbae4949a1d12d88b7d4ea5346e9b9672b2a7ab1b9336eca654d54762223440e7ce165f89606e76132fbb8a5ca278fc57a00cd60a15d420a143c050b272f7bdc788d1b1b7ed60e3edc7a213fbad4aa17d14e59292541f5c21ada7c0faf09f7b7ea5e8abd44531213fb670c9c4d2ac130772bb65161b1b3a48f451ab8473032f5a046a262647e763c5d0912903e9c8eafa7cf2f094f78a3c17138d8f93985088c606133c8e7d6bccb282255d17f53e710287b099ce65d66746c7f201a01957f8d333db0b94936d5a1b92c94212ca070da01d098555bdde735af5244ff5cde52bcfce91d20ff059c23f2dc4782451d48e484bc1966363706306d8cd3479ffd609e4ed12757ebd9e8160b430e7245f55e3fa4f67e31f2ca822aa74c98b30f5ce72e7c26617331b762f6d74979ace592a4dc279f1ecce29e5ab2e72ef7082d335721dbf9b0b74f76b6c14a7147102db5292f61f02da9e406897d3d3e42f6545069e11dec3f636b45ff0caf24162cb4b343790340dc7c6cca38affc25921f9f36d040eff1a757e6a401ad774f52a550bd653cd83c3c31becddb9b76b0008af3f6464f148df216c8e8e65a83125986394705bdd1e52138781f54753cc074e0bda26c9f9cf06dd275efc4fabbf43e9083dcb35516de35e1b7070d4e689b5c8e7f8be06df4b586a1e93e7a40329a24d6c53c275403bdc2ad2b20e9682e71c2a9805490385c2316a17ff60c20b7201c02fe35f0078f060e7f6daf512ffcc8f2d4f6d5f306a222a752f0291a75d125bf16ca8d33c87ff2b228b8de4076ac8fa848c85a6f45170c94260094490ece86cd3abb99e8ab783f31b9bbac9cfbdb09a5a8504673afcd9f84f8552732c7b2edb1eff1abedc2968a0a93308196e3a13cc4996af7b0ae29ac29327af0eaa122d591196c03de7ee047a6772655383701428da77c56929517e62980d022eb78a96845ae37e5475236478059cea493ff5a93a41806924cb78a687ab5973d75bdd0e60de947db79e61037b1a09d1783f3d874bfd43750e35bbf8ead6227cfe345d9e370bf33090eaa5c916b267ae27917964ca816442ebb34493b23be595e6f7385ccb8f5947173e275298120c4047d9264a45c8eed4f0afc1325e6809b97deb16007b6622e2c1271d3104943ffa6e474a5a68ac95ab39ca4458ea43215360bd32de5e329e81e43eb7ee36ee7de318f59666b920a3fa3429f8cfa99aaa68ef83f2bdab088d931f0869abbd222872ff46f79bcd113dd90a846587afcdde521d495c64356474f586774fc5b36031d38f92580351650795113a8d0b7f29d9566f8bfcecb536acf041391936d11e8b5bf386f28a420860945f1e26d850c848d3e092bf48d540f091e712bbe7e334bfc1e4d9158d49f0713e7f1f498bb65412f27956a19dcf4927508610a410ff0fb9da3498f5215e9dcc371c07a2ed20a5278aad9a4ce3f670ccfcb2b88ccef720e77d6f713f6708383e3c109fdee20b4d33be24e96a96f93c6e71a70893fb13d1decb5e06e5c91c554c32497258ff1c065c0fb45586453b23b5451ea43bbf4fe3920521546c3f3e1d672ac301f1277f8aad3a79354aab9c6873d3e701bbf6e92c19fc9695da29bf8182a9ccf479603ebd0458cc6edd04a2d1f122503755bc8ff8c4adecdde84dba9ae23a261a402b516f219c3c9314d81070750b47709917900f4b79a4e950e309e2caeb9d7ce951d7ec7604c731e02c438b154a5e23bd575a5b86dfbcd07d9ffc6537567fd06b4bd4ba74aaf2e5675e55fda65eb717cdbab6748fff4fe1a58e92a1d300521dfb0a7e0a8567931f1c1976d83ed1a268e793c379c1cceea33478f98bce3aadf48bb50d94a213113a0b533a75da38de51cbac38ed3de4e3fab1689fb9291c3545c01c9b86dd307db42fec716247965a91b3b9194c9bc59ec5df89bdecfcceb202feba8f4163618fc5f682f412d3b519324b71e16b14d39cb19d23a3f3a869ad2aa9255d268ec5687a4a1ac7be4087be27c726ea5ef49b226d8d28ebd045672db417eede318cceccec28f3d044174f2543254133781ae19334705bb4e7e91af2ac0aa1c4c3cd4122d1c9766018a69c74ebefd01e6f084eaa2817eedb6ccc15ec199a6308de9b4af82b28e2dbf6d1f749fc90110d164a0079b5b4987ba429738a9c8e326cddf11df88739f76a27941db34f4738e7e9ea07a54d8d01a0915c809844a69909409aa2aa1d7799a27939faf685d780ef6f37366b6a2065874d6924f308e2d4e367c3c5655395f4a57163b9222eea9068f868524028ef0b3fc5605635ed9c55c4140f39be7a3f939e9760b45ec1be4de417539a92043092f07c13afe178e731e70c75c9d55e2aaedd205973acce76407b642bf62d16a5a0645ea117fec66993b6408c44ad740c657a639509078ca23da6cd15bff5dc4e8b4a6328d0ca173a13c856709aee7c89c0ec41ae3f896373fda80518a1ab5652b6982784b38a6816997ea64514351f2768c713d3a54efc29007e997596658135c9b981bb4959ce0702e0eb3f3932bf2f7ccd382344748f779dc0926c92f581f5621539b385c02f5b20bdcf207574e2a9a3e1d559e36b6cba048b95ef3c3834acbbfdec9a278f5910e090fb3ddb1d430d5a7944d7e19fedddeb0e9cdb47570ce9f6202b8d574f6b9304ca0fb13762b1b1c6596defd617bb8278f8a0fb3c5ccf2edff49d1c1c4a3750748ab92d69930c2c37c255adb7e3661882f359eb7b8672b7133761f0d82efe23f12e0d9b63a03b505ddde18d42cf36f4c0d99e217e2ee95623d6e0d68c4ea5a3b1b787823f175d431c09dd727a58b0e9a1c098994262f872693744ca34a7f15795df42d58e52e48bd5d4b48ff9c0a37fd0229e51266cc893ebb54f0d7406275bbe12a49a7ed2deecac3d147170f18146ff7c2aace115d244fdf72d9cac4fc2320b873c1e87bd840f959af512e6e3bedb341d05b93ae2a38576211b1d9b60daed7739f48201e72d263a68637c4a011145200bfc46c1ad7b93ea4501eb161370937d1f49bc777bd9980585b41c672d54338e4def80b31955c94a82dab08afe96d4f3a4e028f959d34fab7e36b66105d5128911d398acac43de673a427a1b79bbe25537d9bc58d53afb441fdfdb697c5e312c4bca8f9e4d8f2895a5f450e61495ed0acefb5f25dc53e2ac482d4bcfcf4e464846aa5aa18ee1f70489d107451cfd13fc23e599e9d3e5deea2fba38c7c621d69364780db08fdfe71bec6b778597d140860fad43b64545e8e533c5a114e5151a83e5fcfef5e93fc736ad4bc383dbc413ee0b47c2a2f92c47bcc326af7b849df0fcaac82bf70430de9a21fb4ddfa30aabf7b8ae5247d02ca42eefa3c861d6b4d721d3bfe798ecd23713493ff1221740b312a49fc901601d174a8b58ab02b0fabc684330729c93cf9f58e1b0566fca832ed406a9b170037a1dd5619f648cedd4fb4a8dd6946fead1f520dd2a5b9d7cef9112be4bcbd37442c8a28c5071a81cc81c294c2482e428b2fa8801b8adb753d696bcc208ed6494fca31847fdcf0db1adb525973715d5bbd39dc4664d1e2f6d24b9f1b82d7ee219fdf272f9b951a93cf2d4fbbede6bd223d4a7f2298f062e5393694b29c4141b18bea4577d2a3a5fe59a7c65ec257475b44f918b8a5447de67a9ffdf4b546dbd68a8dc659f480b920da3daf8d1b42e21745efe81220553efa6a89b0cc73f693d59ef60692f2310011770bd5d78a96a2b7022744c1466d239f88104cbdce07158236b9f9ae2f7fc1dba76d77feb8c6abfba6ca7148f55b3a07aebbaff77daca2666a31fbcb6ac16db981e77d4b960150505dfa3363cf172baa80b51e574b745fca46dd1f24d9856151efb26e4adea6589a3684d98adb4f27312383a201a60f3dc48710128b8a7557b46b7ff9841685e20423c8d3821dc71b0468aa78d5c2d5e3d586346fb18d10be350bf42105bf91d7b8453db0e9443774b4d9dd3219c68bb3af51de5fdc52476103e2e0da1b675fddb2401081026be568f7d267cc69464220dca655097da69ae246ad7c74c028f2d9f71957bb9c7650c730acc390ae4e5af364e4b1be10d930b5e0460bb95d51acc814ddc8332ee029c60457c9aa6f38f401e5ca20f1a8a318ed402b2a2a5520137ed362af826e56ba137384975ebce80a040fd1f87a00c0869bf7114a26e24459f482069f45850df386d4c165bc08a31063a3091d4f29794e8f9e1cd0867455f2b5dd11061018f14f814e3ee67c7e196fb3bffbb308c4f34b48f9e79b4e535b747f9c98508e6be8adb214a2dd40b1eef15f049d501ff903fb4ee597df68b93f196a262ebeec361af9f87974a5fafa957cc779ba3038c50506923516182ae8b3f43fd17eff0075ad8df1f8dd9dd0de92c3b00710286e700f63f498ff080994aa0a7647bdfa658d8e98a7329a1d20ecda7eca98d8fd9ef8305115d4b44eda838de11b76d7451e565686193c41177243096c9d126fdd94af31d0bd46dde5b41f27fb0559b577d6bce65fb78eaff8200b51d45617af5fa3c6ef8eb5a54012814779be90fbf17a2bb1248081b59ed4f204150fc5782577ec7ddfffad610dbaeb14e61132b4ea63cdaebe1cd570223eb65e1ac428bd359d0d6e35b1f00eb07f53f03de96695ab3a46605d7a2620885e63a05d96917acbf64f578d29fbb4ce27754f090f6d262a9343af1a77aad52308d281651cb38295a954981ca92c5a1a97cbd73135c9e33638ea067318bd4af57aaf6a73375ec948c2b25fb65b51992366e7cacd55c9f105345b47d43184d0513480a13a2d3adf33a5f5c1d035c6051652538fff183dbd0d98214dd8593298cea366bb4656f4788dfa3b5e43f6e75ba0ace8bdb50412da616449ef3b80871e8fee3f41af1d08d464ce10de00dd2613f91e09c35b3adfcdb5cfe472c2aa798217f42d4ea8b77b673d4a6859037e7002330743f45c01f10a0c99366b64cdca2ba83fec880acb5de63f0ae124078e60c9121465619c95c417de6d1ac8c3cea8b7030eba0a5bf832bbaad4efde2c4f979d69ccee342517240038fd9a99a84bc5597a63bc50b342150719317a09052d1028adc3cac740bc2f44434a126640f4b39af44112da93c6237d7a0a354ea49a5e5a435f840f918bed188b276d9cb8af11b472a68e8b3f5354d18f905732a4dffd2659d721a7028e05302137e5c18452d17d3d9b86b873108fd26a8b33640f571379a022dc504b9a4c6a17bea67f927a504a4ea1a2b58759a7cc4641ec97aedf0f3aa5e9e9e7bf4db37eef5c69cee0edb9868b3a4ce7a041d6d3deb1918331a1a816b919a3ecf6a28d13e163db9b330b9dd0eb84218c001c932cb1395ce14540a628b98527eeefb8d7a927e1623565dded3221c6fbd07de85d29ff04cb2225b0d6d4d2d3cc1a8ee10f378866055dd15429e69689ff7e90f76a8f55299cf218b25517daff9a0817d606cbb83acc2b3b1948cd47e26790538dfffb0c6e0dac8f51b62043da7dca300d68b25fb7acc5f4193d9ed090f24261c7cc024599d13257277e72d75918f69583a42cb4448dd2623b881a144fa1de15043911bd35b781591767b914a559e7cad70c056d9b86ca31b97bf2325a71803034780613c3ad6976c753057dc92ed44b11a4695db9bbd97795521f952aeaef3011140eb9cd79896fe948043718a96c5dfe9ee0b055e68f96cb51e34532012c3a44c284f2284dbb0bef9ed8fd1deabf479e4d08ede659f84cf44f88c746068074fff533aefb904d83b0842eacd544b0db607b52e8305785344fe1d5feb1e61b85ee5a22dde3ccedc4fa0b673d52dd2804291cf991fa44e9f899b9881e946452c850e6fe8eba15b0b1582e8c933e49af531a53bba3b5f9dc7bc03f6f78ecc579db9b588da1eeeebd444e9a192c03d1a8ecadc7a4c921d60a29d6293ef3cb933c4d57d57c3fbebca1ae23104ed69991d49f2f9f362d7f45ddad5d380d2957c85f82a52a392af51dd106ff2475dd606b0b96ce31029419d30c8dfe6f5a862ada77c3aaaa69582b0176767b64490ca231bfc1653de1532c14f2e89097b56d2d17cb6205b99935e2170fe53846b1be28603d9518c95571e9085160dabbe19dd3e565c3a0ceffa915293dbaa347d64f2caf089e67a5ddeb27d35ff87f41b0b6efac2122165e10dcb70aac6f17aba550eee0e83727e642dee38849ee872c283239366646d8034b7b887bd821237db0c949f0443b85da5df9bb56e477f07de423c1542a7fd13a081bcd03c3f89ff7ee3faee3fff4ccff7f6e671e38b47c0e1c2fbf0416d4dae0e57fa9134cae400fe70725e60e7ed59b04c70725e53e1d9f0c0321bd88a1fb756125a8a558ab3580e0c86470d55ccdff10219b0f9f13300e1fc4e5aee3ffdf3e75bc420af9459bcae179f51f11804e3fcbdb1c0bb4ae64fa27a41dae3931b1d85d0c1c2a2e07f252b0aee25ae315e5842a10bbfac36a84d60f6fcb5a8b9bd9c21570d814c0cf1cc2f8f6d1599038f2061446b3fc451574911e65c764342fcc40c211036cf8328706937dd3409c387f7a7098784995e45843779850c9faef1e70b9c84525a0f52390c5a2f5f6d020843b16fe934e468485cc47e1aa44a166c76a9769f41383d734c59f586f761664240b757f3effeabad4ebcde64798bc9d9f2fe9eec94178fd5d70f618115a3644bd84847555dbeea7f17c329113c8fe9312295fb4b5059416a93d778dc86352eb78afba9b37f894496710747420893cf62b4e180b3537a4310ae3ccf7d8f27e8b2ff5720fb88f6c942c53b0912acfcf54c3602a461f71f249ae2943fcdd71cae95144159fb9377bf1a10395f3c648cbe819783941a27b92041b26fdb7ce5f7115f2a585c4ab08ac848662896a2367c355de4e1dc8bb6a4c903e0394f2f961e625db50027679816f79d8fe512c6185c1010b333a1a4f34aff527fabf3866a9798e61930c9146c774c25e8ef9feef725224f16a493b89cd54e1fe930df20474d9b66abb76b06bb0785bfbb132430fe003a22476cc9bda3802f6d32e804ee467b60bdef98e9e7ba6f4295bc1356f8fa96acc3fde5a84e0f960a4b95c40fb73dbc9e7678b7c9667f842013f634344fb1df484332b1591cbc5d60321ab3490892a69bf257093fd7308ffcff3a8115eff17c7dd1a44838a08155d422943052d43da01300a34df9ee60eba85324cc3fea23c9b5af64281a4d0d41d5b81e9c015d73d1f94411f17fa8f1d89c42804ec7bd2996eab1f815188f02fa8211d3018acc90fb9bf389d96fe233bf4354a0bbc6f70ca6fedd203d703b36f1ce5b36181688ad7509424ce02c2641810d327256017e30d6ced6cb824215bd7f8197e6f3f91c95b80ddbcddb36a769b1ee53fefacd6538fc9b6ce4909d76c3367b2653486f94e86106a806d1b491501d170742e6a68e09851b46f5b2887cb0932c08b2ec2b5040a0e1335839874597565f101496e5458109b390a38c4b617037f0a52a3b543b1bc6c8cd844c304c3626ca0e40ab28c4899cbbee464c0b6bcc29e917c60674624057d715d051b2339945bf0ded37559f6f6273169aa574c83e08d1d7011a5426e11d29eb2ed7e3ac7466cbe66574d7ea16bbaaf6780ac03b8148c9770e3c8ef93b664941ca18eff2e2adc710cd942daeaee6d8fcd2adca265b3aec2419d80e52ab7994de0e27452bb7d7e566d7254fc1da0ab68ab58d51da46d95491623f5452cbfabca61e9d0ef355b39c34b35e32457720b92475af90cba37a40bd208b2ade18ab22d47d06cfbd4693b89b505d9c1b71806ca174bad67410cab7a90ba3a543d3e9ddf906d45d5d44db08ed37148103d1532e0702c201d7fd45c32d774cac6d716c731b95c64534f9f36eaf5e715ba3cf027f24132e2dad23a55f3268201a05fa216860e7af61ca422a753969829a84bf853d7adf9c67a66a67eb8b74999351453b8a13cbd3add83388ce3e5bfbb1cdc4cacc6af5cd93fc7a300987af830d0b5a4fda9b34058529f07eb921881d0a7896660639f3692be2e93420ce1640f99b0a990b804731b32b90d102d5677d4b1234b29cd4d5badc9bf673507742fa40f805c071c22616205c14e38c227693cc2534b0463eab4bb56a89bc62bfa422dac6ef7b847de8e453402ef0582867bf77a229736bdfa6e1f265f5b9251971950ef0097657f3ee61c0afaea46b9ba98e90668ca0b6e39c285ff50424fb33f79c93ae8bc9fdcea6ae49d14647ded7defaac749236944233c40e67374235642d4a0a5ad46cdf760aca396357ff362938d65f2070784da0c8abccb7a58c2291633704504e1c4808b23b776a39752cde11dac807c0af7e0ebb50b9bdc2d10968e7633d6e8e2b2f9b4a2c0a6bcce49975221ae941561d1ffb18b2e3a3c3f5f63dff078b84d48c9b1225ef98307d52ad6d340def5d344e65f2d77ce2c0ff13668695fb4fac94fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
