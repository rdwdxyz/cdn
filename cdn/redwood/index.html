<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd1bc5df1c4f0abef3c979cac2e5a7c9a51117a9248681b4061f493ff6771fd9dcca8a0dfd44134253328591556db1911ccb134da27d068fd248b70f8dfd17ec2c29e52f94467e355d8a9c36f99edfa95c31c962c492a06c28502e3397496f5356cb1ac026f75ccec031dac206daca9e12471413fca6bc0460e7d16ac917465750aa98d4bc8144174adaaeb48f5ac0ab5cccfc40e7a5b99e2f4d8426caf043aa44bf9f9d1e4c4088f959b9900e946a1a6ff0967d856b98f25e4c83468e8e865bba36e120a3e13f7028d916e376d1410d2659cbb311509688eeb2e409201236a3db183cad2f1338856ec27b30860f719408c010c9ea16e41f69278c04f7c7a510d446e47e80d2d97576de33aafa76ec49f912e3c3e301e6c95cf2d5dd6007c03d4e047799de91b162053649d10b421cc0d12e85dd08851a63b78ac00e8212493c9583aa76dda078df3039a483131dff2bc88eb46e26ea702e3b59b2188b523fda97cb1e1bbd2d144b2f43f345126c96f40e147d6d3ce155fce723b129fa3f89f49cbff663460d62efac1186af69e7767062c6bc6f523dca5d2d3c615bc6b2d260577cc65c43a9eac7c6a96180c4b1540e7efe9dc6da68c74b8b260ccfcd3f0049075fe435be2543a438ded0e3ae52e47e3e52962f34b30f6ea2df345b00c7979ca2e029c38bcc6404713df9c79653d196ca6d10117a810078fa48fabee7ca347a79dcb1812d0564172949c266b56e52f0920e33a87095d98011b0a7e2029cf0abecdfdce34459c0bbedb8970f8eddd150a4d5e263e68e4293238ec83325a3107c02f6f1bf52f96b5102d731c8994d9f0719ad09bc228d6f1bcf39cd1a839a8cb32a19370b0f235432e09adf2f84ba085e9818806a5014afefc6693ee4287bf064dc540f0c8f4258b1bcdcf679fcc469ab3649ab32915d02006528a1ec228ca2fc0a9a5a54e37873bde4550b3c015948687934d9fa0bf4215724ffcf70dcad4ac9246c9a53d2a94bee79d25971fb34c52a5f57c2e7059f1010fceab7eb61ccb55d43f51de00595485812fd437100670257a895936ef6e4538d04bbb2f957985b880cf14abc04ec409d966b5e77d13f2858a61428c5b6d10ce03025d2b5073c027d6d4451de353ba499030e2f575fcaeedf6d3a39e595f68415926cfb058596886a5ed92467df83d513f293f782fd1aa37ddcb5f4c7aa2646f2f49b491c135b1127a3c263d98b891b85b9b2917aeba8cd1de54865d89e655fa93724a625b53b3a832eb26037561d73951718919945ed297a7e5660279fff5f496b95f7dd37e9c9c81be29b64f06243246695423015d76efe08246d012418e50586fcd4284c10aaad5f4ee13eb1b8e3d677c3241596e90f8e2efde20dca0bdb474c8d5881a766790a8fefd9f7e63833f9d94fb29eda822ca8ef153d13177c063eed08786a783fc6b9513a2408c8adf7ad70abdd98318590dab3fc0f258bff4e80377ed4202d84377bf0424a97fd91260ae7a40b964791da8efa5528f849418488ef9062c1fab65f6e65bfe524e6e53580f4a02d954a14f121cd3d784afe7afb6d872c6e0aa31d5755ea303d14db845c83e7faf4d181d0aa505784a7a40cd8ffd003d19720c10baaf1aac28523bd338719fdd0ee85924d893d26bc0ca546cefb0434820b12c6153fef8af2daf2f070a2a475df3b34c1a5a12f5e86d8b9d9c775b9bf8290c768bf2f87c4561c6fdb95014ff81fe3378f8e20b9c9ad9ebd0fe897f9148429b1ed842a71704d25f3d5567e5981dd4fa71ed7d210bc63be5ed9e91e5a379b02ab5592504c155ba7f6f9712c0513f3426d803cbe07ac19d011110748dd018c7c57bbb2c7b7bae42fda5e2fa474ff4a3840b6a76d6c14e67c2be6f1f9e16709a9b627db8b6c45de2e43432d13f3f1c8f91ee3355decc04262b7a8add48a395810fad654026b8cb8bd7974e91a2ccf5c9333d21b7d7ca7cbb30b7dd9e6d64a904dfe14a87aeebffdd3030933e6abb6e8fc1658105fe06f9f00f3123a9421e38da976c80356bd3f1b4723932ae9a6333223ecd8cded31d2dab2c25ae6ed40427f16b7de750ba5b616c0f33b8ff50cbf02d21f90f6f9b6471a97ee64b3fb82751ede3610d3e5bd1b5c5f9a2a4dd39ade32f39eabdabeacc6abae13349350b08697f462c05746b6b4399fcf3387de879506c6b5525cd3162a151ab0434478fe50180b0db2d3537bc4760c51de75ee1fc900587112c87e1b9fab8bbfddc9318cb8325c249e5255bf0952353ee014c999916a3dbc607ad3c2ddf4fe3853b67215fee130f1696e42e81f7fda74923000e26a75b63f10b8142a4d642da3dcaab22e56e3e724201a8f0c4ec80225735f67439f4ed0382910111a5c659d5a3207a6c80edf9b3b7487acff1b01b13bd48d8fdb49b24a0f49284c5ca9760e04d2a18b9c02f1ec845f3190dd1719f9e5104a318de1cf2fc8c1d7cca2c16d7a9c46202525df974ad73edcd46ab8f0b68c5d07c8d886c2b897d98751fdabd11db2deda0522d2d47a803567bf9737a59f6aee1764fec000dfd3801164f7bbc6b0c282905243177d626c9b52423a3f7de168fa2a8cf858d232e9405118135d97c276d6ab29176dfc3f5dd04be58bb473abe58e9170e9de4a6c7a0199073a9a9b926b2a337fa223288c018726600cdc16b7048dca32bc2b359728dad9cb885e4093b64771fedee0c27de5755b241d0acd186159d15dfa734439458e4c7782f2b3bc8d518d3ce7825856cebd911d42cf825ced5436aa5013ccd04fba928a921f57a2814a7b3036b30fe40006a4bf74aaa247547cdbef10c27f1e357084caece0b5192a90ed7c389f143748f335e45e3d9bc6a31269498f0b76fd5f437cf9d1c31658c616e4fe5747ed5877a5f67c4013e67f653324855cbb59283e3e8075a607fd870ed043a52375f7702be077b2a4be8a4519fc9d122757c070f87441efede338f06e910351d6b057c745e1f0cb19f523ed74a70c6b9953d25e32a5dcda40762c135a1d48b2dd11fcd9c5ffd0d298ca2d842a53fcd22f86026c7efe7390b20aa42ca93cc1e13d3f54eec864e9e38bfef1b6d55df6d26e17ce8a08fd72cb7fc3bdf0700dabcdc0afa13493e9c2df6681bd31e3ffc13512d33e2c3cddd2b05c4afc2b13018d075deca7b6b8ac4134b43ea463c59d76e9aeb579f7e475f4e566243aefec898e0f481bd748fa76d744c5d3647cd29c97f10fc7411cc73b961b7923e0a6de871537e8fc2a66ff976d902851b0357a42a591b8ce9920b5292f23ad598473af415793f25608da7750ef0c3fcc412a20141110edf6d24896b5c6c0e45b87345334f3755b24664b3f603768ca6e4576f1038e4e1c1acf7284a3081aa721157b4cb5ddfcc63d8e3f32bd242078285712662f9f9462194c7df1eb1b582e29cce769ad66c0e6d115bfb13057b9d60010c57acbe1eb8ca08e0855db0fa9f23d374b73d01304d57eecd3f540c3a417af33730441a83cec2f0ea06aa70e7c3b1c0535446ca82d9ad224ba553853a96076792650a588a218e0dede6406879b9912381a9804250578512619797264908db193aa8958a75b0fc60dc19cc7a810a4bdba033f5ccdd7a06244d74076258e77e769c8a9a0067256bac57c8e9b17f2914ab4189d7ca8ed2f447a904d028e4db62dc445a2d5838dfa79075f5e379d8ed260cb6d9494adfb57c7dd137ff0ab0a586921151ec0c5e2c7f000fe29c04ae4607067e3089cbd823d4678995932f6d7130ca620ba7e735855d2c8f493ae5c58d08273be930a2c3e7790cd5e9049e783b3827d03e4bff2c7e5e0896fa4b80dcd6fc4796238870526e4c50302548fb0e2ac74b37ecc4f910c3febeefc98feb5f90ebccd27d6c18dc40a9b58433363d93c2c5a9ad399efbf1b716a89cd0d1e3e3ddeab633aab90324d54569b96ea3ca12db29509bd892a71fc6c36e31296672cb22a1679ed716c2ddf2887cfb2bebe68224a4e0b0967c69e5ec648bd1906b9707cb1a5f637730dbe05544385c5b39ded3919d0ff2c1698fbc0195e54c152b22b25bd1a5371b1fc614c5724850dfda639eba969cc3d7ca6ab26903c9b030d2196e6e08c6f48f9f3ccbd853a5b94d0bf36011c7f3d6c2713de716ce5dcdb9b6cb249135c5a128845a7bab2e32aec1ff575f9fa74f67c1251d1e1eb55a8db1d22db60cb0e08f25ea4e3002b728a2c1c50523b0816848edd0d53d96e6f47653ec8c65106d1e700d8c4b99a0e19e422f65675c7541d1b34a261f46fe323d4f7dab4bcd3cffa1f54524b7ceb6a59b0cabbb00fd77eaa6dc41ff07bc8e211e5ac95c2b631e3677a8ea023599aec52830ed2f5747c01585bd8423ffb346cac4b071d02a2715647afcdbb52d8463dbcec23095fa7b53fae51c712e62c7e676b516e40ac9675e1324872009f5f26850968c3127096c09e689a31d2790ac07cdbe9219885de4e06604488395d87a44838a2cccb006c87b76399eea3a5f35fec81b14e1664d9cbca4f8183e58700646900e2992e5f95bdf6c36f7352bf39d8d639dafba275aa4c8db903daf47ea3a6757d52b14b3f813612ee96f6c42ea5311d50024b2ee91c884b2c66e7879fec2d8f0c9e310f207fd140b31e855ffdb888862dd4f6491f10115645dbc130625a858622266b6add9ce021fc3757bb65b1ec065645063bfbf4d4293e99ae39ab312fff45a506c5534affcd25aca2555a8bc6f4618d6f44a6e84e556e11db4dc6d2e64fc89aaa171320079653b27cd695588174cfeb8c4c73bf77d002f8928f5e0740507dd81673f8a590b10a22ce3517ce99bc954083042744fb099942798b5c92133e3a2c7f87d7b2abbe20910c3a03b62f36d3ad874bab8fcfbaeb5667db47aec8d2af33846a01dd152763c1ecf5e0edc6b338a5e2523d490cc3efb5de20fe6072e584f22c9ec25c265e35b8978b7fae47ead9608ecf66078fa0ae0502f6dc8540076aa56362349705a7f7362126d0bde88db8e021fa011ff0f78d86bffeab5216750fda61e69b7fa57f1c1745310996c89d984e2f867e9301cde1d1c5d86a410008177fec89e372bc1813ff596d816580e5373af51243ef09b25551ea8d3be21c3b8528e7b0ba71649dbc55f034303fdb1bd765a4c828cfe40a151983b94bc702af8975ba06959ee5339cb3867c369ee7ffa979c9230d5c51b296ae129b77447607b45914a73310207c505fe5850055a6a0b431e4bdf8bd0a9f3691c727c6620599e35fa3b4fa170a5d8349ede145f8b5004dbb14e53b2aa68216364d4588410e3ef8d982788e9bbb3ecbdc80272126dd0ad3ca40f1b22d0a91d021f7718087d0937d67447c7bf3c59f8e70bc8fd00af4f6a646fcf72bbf945fded08bc0151c64a87ec94fbc912d071ed1a906f2fb8f529ea4a711bbd65d279bbaab7f026a20072647fb39f6fef29d2670a05a9009f6d4079c888235571c112257362614b92c2da3ec865a681d20ef7e9144261a7d49bb558644c579062fe5ed65dae28ca8bae2ade43edfc0466317aeaaa1841a801092ddb82ee4a6c9a00a2aca3e85521d48601ae65dc11baa061178783856ee9fd724d615b4f17672f548e05e9b257153c0e96ed17a788a1b64785a6b057e808523cdc023ea912553ea00ac0377744e0361beb4cf691d4a08b2e3e2b4de96e58f07bf092bd1a787172348003587e51c187d4d5077098e23c4c83b487987725f5a46156f4c368e6a0d6700ed0ef434934c6ca47d8224b4c73eb08c6653a76834de109fb6504c521203f39a56972b0142c8655f48e771485fd59b54a83cd9ad66fe7e1e4969e65746319ff0b87cd92babdc943bf2f19f3ac1a5b4ddad0f33c76086f170171d6c84bd49326bf51e70b65cf07fa600208d604fc6bf2308a77d23e0149da6fc71a5e4f944cbfef279820cfccf4c1d422164c73733c8e64ee49b8e3c24848b9fec94ccd8ea8e117c96cd070c5a1548cdb24d3d60a7045a7ebb60c0130cbf3be5d53fdc5ab660238adf7cc51e0576fd95364c8bda4d4e47569bbefd01c08ec7f855a76fe751586e750aca81a1847835e8e9faaa32d6d3e4c0b94ff7dc4115ae1f4c14ce995fcf0b32e96e0b8faa278bdc4da15c9e7609288d6bbfe96626bbf34a2b6817225c6e2b6d7e904b247f67e9dac75a6a371093d10aef0a16f974a2275a54d00135eea4d99c24c6d0e9b2100cb566cdb743d6a55b43b22d913affc8f42167a8903100becc8e28db1a9fb36963e246887f4b015bf6b42105991b0a6ac1e84eaffc4fd4284aa4b89fb16b84cf24fd2f09f0464830baabd79ea644ae0ca581312dc09a82d8370c1a6a7de933badc9792c140f3d0508698d8d609f0b129cf596a057cb561f3bb374c4f9c8f6bf5e4327f107ccebcaa1a8f4deca750ead324d375059f78f256cd3f95b4a9d1bb29a0e02716e59b8227ff80bb69b15f83517adc63bd7f5a4b965edd2cec2824830ea3f33a69b66b0fac1d0fb43c4f215c66331548cc9727ad3c5080d5710312d1f477b15e87fd55e7fe5226f7e3eaad86d8a3c4ca97b037a5d8abbaff2f0ed3a0d8ae72825504db9e21689a5fb1c9a144deb38f965ce9c94ba0d90a9b60f182bb03942565c93b2ac7aab71c8200c349ed04ef261dd9cba92b9cb3a587903040253e561540cd719d253d9d8663089febc63ced8ada2363b74b431b62b894fd4de59b74c289e6bcc32bedf1fb9b56cc3ee0214f130180123722d7bdbc2e426b61ab814ca151e084dd757daeebab35fc5fe4e35e9566d46c5f9a1a10f81e71286b6187e8ab6d5ffc701296057052a505a9c16f269b0f78dcee454567bc3f6c5c9e320beb33eb69d21b52ec841da02a2137522b730171568dde945af95bd2d9aec999ad619908beca41c7000cd05a6cce8dc24ccce33bb180b60e20e28490fadb1320f54f6cec146c298e63369d91b0679866ffcfe64d6f702b24b4c5aaeff6aad08aac8456c68dc701349d99b12a0db74bad593f5b595dac835bdcd82fde406ce2bec310cded31e8ac83ef5bf17750cf90fe76bf43f7816b7d76483ae9941aa05d3ec682ae0ae6000be2bd7a16e5bd98cfac49b48e6acb4f741ec1c60f0c8ba268f48c34a9c52870544b104862bfd2cd516c32df063d9b40f9073b4a39c4e3cbf824bf18ba9ad667e3966f0af49a4200ea929b3622f5f465910dba823a25635efa61fa50f3aadf735d2c4b874a07c89781fae6a671ae93c873e796704fd18c9824b1cebecdc7cff8edc9ddde6fc15b959c01afecaf09f41d22662c2461cb6122187b8550545196a78a53daf2b2de7a4ac58408ce2a1e3f4c4847fba9c72da1419d560721aaa4a6099be719ec80050fc2be9dfa03d3e0aff63cf46de6953d4e4aed06b4f92f1284e95c05833145e530237697886819221322cca977e6b8a42dc95bc4e8293d593b24829a70976c559fec59e75c534734f75b70c238e99ffe052280cb684bf2eb3fbea2b6f678c94b3f9b8738ce5a7b819a737d523bf2e665dae0f30aba93aafa57fe7ab502a8072b99f039c79f3ad3a6c24f7082794b2e8108f1eb8f530f181218673a93ae06f46ddcaf4f4024178077bc2ad0591e125cd7df6bafd651643ce0156a4c240930704697f74e93422132516b9749b04fc1c28d319887a84c400425802ca4f79ba77672d2d1a605b8363648663a56fd24b8094e50197a9ef922e72c72efd6612b373c24cf8d46bcde2f1887c2ee97a4f5c085930483d4f7d93b648af154ce2224baac96b9b2a2c4640ecdc3a6ff879f1f55526a50239c121d66b71f34bf1d7cc96f21ac31b819c34d3283b5cd15666dbda53425b923b511a981afedbebdf79993da14c326d752625f3c12770db7ce6d37b64ad0dcd833820d63f47ffb69712e30591e2207ea1deaf36606ec4f5785fab0a0e3fd226d59389463bff3521a029310a903b512d44371043c6b516136862372536c67a32885749fb6e0a772f5c0ddc2e15f614dc3ba3383b7deea03d7682a384d66c93b4f417f868d46a8d9d21ae650c344408efafdbcf008b6ac01ff1dc836a394503fae06a48faeb81817f197592a1d78b5056fa105ff77d49f8db6f5d4cdf4a3e9e02cf26f75085eca8ca73c2b54e7fb93feeb8475de935d1cd61cb50eb917ce08ee73c58581248f9613a5e051ee8eb765bab04d2d0f15d72606cbf094ba63fe4abee6d3961f5b6a424696bed7aa11829dd1dccaa7b886cd58e656e07e70ecf5d360909ed68a3727683e2470d846f5e61b61777a0e0e50c2649b2ac135aacf6b5f81befbab92942f93267b0599ba9f36d7e9b6f2fa8fb2a10a5d1359a2b65a50c336c740711c923f60b582e5e3b0af11a0d899b4cdd426fb8eaafa6a084ca247b0e7f7885b0605e0aee0ae60c762c7c8384ac711454c0aa109df9326e8320f7e5d44de3db3db4f2a928cbfe6c99b51bb82059a105ddd3745ac1317ce5b7007f0b0b2add7d8b9e5f22e90198c9ce2fff02462548515da8934043b5391d93dbfd553eac0aa5855239bed92d0e2ea5e16b95b11c725ec9d8b917f97a129a794d81aef508b195cca37d45fb1bff77c7d12759f39849a52679093d58c8305040425d390d70ab3fd6c2ae859222374ea365170f152cabd8f8a53b9435ea756a85e762bddb918dd98813b57dbd8cc3d5fc2a5a8ebba2d1c78b4993b6570497794c90a08546cf895c9f8cb97c2f9718eeaa79290574fe2c35c3ef280ad118b1c7b18f8b0a7d36066a83cf353f698b73d9fd3ab5f894f44092f37a0a51bb39da6b9ae5bb2dc9cf976a4d7634bf3f692937aee6de2f2ffc02cbbc5742b5f699fe479545c67f7b270eee5afc73ccdb422905d43615fcf5c9e7aeb8128a32e90c2f3c7c1d54accb88f60b6516edd6b3eda97249b141bb8a2be0d6ce5b5ca60f6f879d0922d37d419dddcca211ba2cf1599e1a1e8763ab9d40b0f6d1b8ee7c01d6590e98761d17ba386c2df8a8ee4b40ab1d26d7b64c2a4d61ceceeef8ee8e652bb50f291e373444a263fc2d6d939b501de86a9e31a7b9853fe6cf6567624e26c6f044447d43223d38fbc5bd0185a508c61cc9cb4f1bd6db3388b02a40188cd37e913de36800bb6bdaf76a27ac38918485417eb0e7176e5912de4a15fee74c407ca69e760961e74f86306774d87239c861181896a599d3f0b4de199aa436b2142c3ee00fa2aa9e5be32ffa61dda0d36d419fdbc71c1d941c0042781ddf3b4c320021a74a669cdaafcf77b61ff6042bff13c7a669a2ded907ce2d896f333e0af53936effc48df6675c58291f6806a5ffcd98d44748076ef1937ee53631ac2bfa159080d0574422baf7968e3c157f6f6d68e41a53be573e00f649b2cf9fa67a0af087c5b8aaa928de24a56b531c8f2c84d0b2f19d34353b184809fb8f18472a1136f57cd55e4ac936d3891dcc1f8478db5210d9232a5f0af39a0e99f7652c7619495defe2671c6a4c26b21b9dc5f8ba603bb4b655f952c7da6186a17703f6682c6b9e8a804fa2c6c80e5ae83c7364760a872b3f951c6d546c5fba3a037ee3959c5a888318464d6948fbd1b6c7a4cb81c0e2b22c3352e4e0ae74be93aeb328076dbf52c3d9e31c6e175cba1a36c8126eb607377da930b094abb3726042fde29e6d74c550f573b15b7db222be75fbfc84c391de9f77a59807e4425b61e36846dc6d7c411cd2380dbb6151a7a78bd728ff24035a26507c71072193ba719ad96c62131ef6931d94dd3f15f27650163bfc3c35ddd8fdeafd42481d66d0562c64ec60b2ba4847add9066ee762d057845a78079cb97232ac692f3889491ed33a6c21c29f0e722bb4e44b5fac13c5e78cd9cc3d486006832823590369b7dcff69f6d565d09cfd18ced8b150fb1194efeee794b11ff474376e61240b8ab3dda4ee33141c98eb9780596e6751c53404b17efe13ba684996cb7e84505879f603297e2d8b69f268f6defe7e0ed9a54b4c9b9570dfc1e379d94a22503c782aba8b09efb30f56de31b5e883bcdd20b2934b3037cddac89b8c9b76456c60b360d9afc3afdec1f96a9f5f39158d85ad3135278036e3a1c9ce9ea2fe4ac9076663dea6ebfecef5af6d062a84f3c0860370166011512ebb2c074d2dff30ad3df1a27edbd98fe0a54a72a360031b81af345326c3a1594e826389365da6b85772600a030687dcf4a205b81aee088584cf9d380a3eb2f6bb7bb7005d64a2625c5749bde46d0aef3d4b2668dd06e2b229453d5ea520c1d48e56784cb1159c7cdac66b6cffe4f340a2688f9f3f11404f98355f85f31af3762f71a6c9603493ea27b6dd0855cb0af52238780a8881b88ef44c8f2735925a7382da78d9864c57eb1a980176d497f62492ef8b0d592c41a0b493dd56d0cf7b46f4b9e951eb0dae99ce12329c9dec6003dafd5b6b06dc4199254e95daac82bc32a20fa25f1adfb6b989c4c75053bd7be91e45a7400c32d51f8cda6e097bfcde86806f1f5f824630db0474dcb566e5146eea4aa22e2b495ed16877c812184d3f1573aa28f9da707efcb41527ea7ac510bcfc0cd7b1166e3aad1af2651570e57ea049d971a5b11050e167f535a0466691e5115805d164174a7fe1abcead94e88a3475220610e92dc3f1e89546978de6b5b8fe207fa2771dd079e6b03b0c871ef06c8759aa88d776dd055f8109e00fd6958b254cd72a8fe28445b2995a80b1368e96e8407548cb5dcdd83c6319978c6e481895a2aeb8b90f49efb749d73a024a8fb88c878d032bda89cfee7b859b2195586e8d308e64a2ff86ec445b83a5ce23a542a983872b6fcbe29e029908b9ccb8eb04af12c2d1a5c58415531be480f1cb2b216f706aa660a5134667529e9b6bc0ff782e3a438b6246e4c798ccffae09db2b0ba75d3d6d07ced2463a8bb81b684e5f3c9019022b308495e040f18db1293b9bbd73a406017bc7fd20874872249367079874432004e60e59b36fa3f42107dc7ccb4ed3ac69dc8054b528b187de668d9c69e58bcd65b0c60cab85f44b44b8a9959f2f6c448520515e2e1c52f905b4746122ceb21aecde4106fb8e4630f1ea57636541dce3991a226032fa8cde7a1acd84be25acc802fa2d9699c87c95b5d817eb8ab99237da2d3f0d7ac80247e46fdcb09ac78e77548f9a6b2c48525b57cfb900bce0dbf746621407551ce3257aa20697603235b38641762431ca6c47b4e63eedf3cd573e231a6827d4ed252d7392ebb98d438796f510f8cd88ef058117f99f7847ad1b037f29579ccfdda3715bb0b863c4119f39a5d5e577ab2edce083000665e0c5ef226816a4e0f1a61b0f0a77f5020dd428a9704d5cabe4517e3968242580230e2f5c1db7d6fba2c659d0327314291dc704bfe7b249897251cee2733e6f08fb70cc0386c646e2b348d1f0d3d6a08e93f00ea8ea85747288a41d8309fe4e99f33f44451dcb725157d5e19cdcccba9f5f0dfe8a32af96ba20ae54da4894f37244f952dfb0f8b2e943ce1a021802df2f3317f65db8dc85817c4bd73e1a0929769adc5839dab9c382f2a9d93a2764fd89ecceb9a99ccd5cc320584da3a3aa98c6c074f30fce2b4ba63c542be02f9a31deef7192e02c99558f897ae8d742ae08b1809654530a049832b17e6a08231b16f837c22dcddf31200298232df05206390369f5bbb1a86436faf137c6d100df03bb05bec83655671f0df7d0718df100d3c3a9c0530cc267a395cec95c371ebfc408201f2a98b1c72d8979567fee89ab49cefe84211cc1717fb2d5964c136a68caa2da4ebfd80cac754df989ad71cab1d5714ac116e7662d3f2cd1aeda7af594256dce8cbf4de635166d99b38e43a8214fd8e6d892031a974b789e8e84a28baa214e4327762b94920cec1235fff92bdd29f1f59bdc45182bbe815025b8c2ebf6e25d1f39157d7ba48856fb9e1713f640461a169b8936ffc248ab797222c92338a57a3d9bfc99570cdc479227d6b33ebf6f8f77f9762ed28f7473587dc581100a7444cbed6804fbc902f591e6f8d7c9c7856110902de12580ab6f9ad78529eed2c6fb7226cbe4100e345bafba00589421cef38ec5044ce223b07c71375dd26366a0e8f4879618f0e07d399fb1652a2f001da6a88c0dabcdfc61bbeb09a9eb496aa5f5065bc956b3c3d5c0e89865dc9d64ee81f641285b33f1ec042b776fed86f92d112e6a26b1f9120950f494f8b54aae7600a40ae77bbabca620d9f90c17bb4c68c73f5b8c3fda7ea479d12f8d2d7639c5b8a505e8205347d9dfbfec2fa942fb5d64f0c95c6ebe3dc32b7782a0dcb70c9e020c0d59ea510b2ca1913ea5599c2c2accd15fd07fccf0c4ee15631ad8070901a097be298dadde9d1d4937db48b2b5e9f4c3a5550be58f977dd0ea4d8e3e5164e69784ad1654a078ad8d3ab837eca79835f4d5396bb1d72469eceee0f83cae98d240187ee6d7e6fdae299d37a1dabbbb93ef2d4ff9d2c8032f79bb13409eafaa385d6057102ba3e674a6387d2956210ef947a2f5c9e402a293880c1d9cfba056bff5f78856f3a9bfc52ad00af868b40a769271613c8d5b04957b8e4fecf6fe82dfc48ffb516d3c863b2b6a675a3454d28cdb1b22ba3e5734ec877f1c2b1bc56689f9dc59aa71c20549179751ce85ac24c83b05bf0c956832b31a4ce50c74dbfbb5068648aa741aa164cd6d6fa6b27e7f650c013eb1ecb2d4670e25718bf3d1440347dc69ca66bd037ff53d0821b797496bd9bb0f3475ea281781b44da4c5a918c297d5aee68a05f5f1c1e3024bc36be3b9a40bb7c2610de06d980294b3529e0db47879bb9fa4c148004842ab40c05fc14684da10bd8a5b638c2b7010573ba3db932c2fb81f086231148a82575f0aed4b88950315c6a33e9eecae73c2d88310773877d1aed4a7e447df0be8356f521ee32f01fb3feba82e10dc24b217f3da257bb120ed15c20ed2516df8df837a30c6b0e085f22360769efc8fae4b4d33f1e32217e2ff65dcc62db4a5bffc22b9c463525f6e401efe504fa2a36873249c9c3054d598bf3282ef1057d825eaeaeeb0b94acac8f9b1235c6c52a4006295d2a4b77679ab7c0a207e20c760dcd3f55cb54832d4bc385172c3dd758f8bba68a0fe4b8847345d5a877aa8cc0fbdd200013a2e991849d7e614c7fc751c86c07672b2fab32ecf2ffd91a6271d037b87f1c1de0a604a402da8203aa54ac7a210cbe19ae6d93d8e88cc7fb179e5913c46524db6e3c1d635c2b56c08bdda894bad4ec37d4d123c093d65bad1afb477bc20e03a867db3807d0339e65b2f321e83c286f290a6f4891ed59d72495162eed109669c3eb5a03caa4d12e9a287891cceac139bc901031871de67f83a9ac49aa1f7d3f82281ce519f2a403efde9b9d7a4bb5b16585d03f6224639e3a5f462ac4c68e770e9585b582670ae16fe6a841a83e5e34b5144508a9303fe5433aba3b939c484a182ba879ffbb7c34c196db5f251a80eb80175ef1afc221a470df4e20a72f4148cc22dd7d331c94569883d4b565a30d13313c6052ed2ec0aa518c4ed1029925a3c3b14f7387bb58abab2961fd2e17a92971111fe92a75e7d72130e495b0d3f85a0301c7f04f013e7d100f918dae9a336547ba568981575d4b472fd516968a29a057fef4246a3ec0f77ccd105e59eb9abd27bd34078ec95419e4f72ca5be89ee83957750d9bb533ac5d2366d43014db197c0fe1a1b48f638e86f99143cd328b2ee22687003404e30222c92b4fc566b08a75fe24da5128c746c397eca3d57602b10527198eb829ba3b0891d29e2e450646e933794cab6306081f3ee83fdf387dcbf917c6abb12057aab7751cbe05e8e02fe10376b99de708571034121fae015b9a75fb10ed8ee7f9a9eb68fe3c84a676e3ff89804cbced0271293a0f006bd16ec14b886cf343ba8c5830ae72170be056b917bae5ab465f0d8d9f9117b30994abb0c9e72778bc0cf30decdc7012c2ccd6c7d11630d6fe16a26b37b52c6a4fbf4a22d541c3bdddb654b5ea8066c7725a9f440c3d4588aef50ea0bf511163cbbb7d813437ae06cfb4b17b052fd19bf742a38e5fa30c1980badea27130be78335beb9222e8d9051a3b419dd29218079233eaf68d3a361778e3bc08b7c7fe02593ffef5fb814061bc71aeb8615187f0c21a9d508ef9266b12d464a0d61d7b6fde59de754624716ce88fb66e770725756e7db3852dd30c4705839fe1045add5c0480435f836c5f36de385f1eff606c3807d7ae32f03cbd5b4efac5c687782cdcac762d75977286ed36b2f0a050360e616d22f1b5bc9a884fc5c06f7a664dac24a3099f8cc010886aabc7a37c31b10a3395536764bd11560d08859b295033baf349250e3980b18e47abcd7ca47e5a349adee7621b175a3693e759954d2a13173fafccebfa240a37b5cb76f35f83950ae81f10ebaa0eb4597c63f106951f82d124d967627d95e366e8dc14d38d126d17a3184db4d1c0092280f4451cd1391c983f02901bbcac93caa5e1425716526dcafa387b181284562cb1f4b1206c75dec45ca7843fd94285cec5af38e30aefcf73a211150ab7ebd573d8836e91b9ec659f5c281340487699659b3001b3f288b9f1bf99a853c00f7a5daa7d733981774b9f5a108d4258c39f25bcd2250bdd5b9cb6dd31c068c68bf66953907f46ca3088f5f38be55d5ebe51e75b997504b4d7c1c1c6c2806a3920893a29078104e50fabd8ebb5cf2cdf1b970352d6c1054e94fa728a6631c43d57586bebc12c9c814166307145d7e43025e7ca25f38ddf38636ea5daad758dd213785e4e76addab4d79d4324d4d0dc3a29a7a191296dde88a9e25fc115b7752790832e55e1cde778042fb8e77c701e769e6e14ddbee7432d7f053e91b5b4955057cab3a456241d6c2ef5923fa4a6bff0d2a7bf289aecc744cd8575d4db3651a11c2a89baaab628a13fd77151135bc45a9ef6db15ac02585993a180bacf75e951d1d5ec1662f01f6bc4e897877ec3fb3b21888ef0ca509dc46ae139777894bc2eed8d78f7b99cc379623bbff9d5428c1993fab614bad6eb17405a996300a41410b06a8c70698908ba774b6cabe9d676b41339627c4ddbcc23d01c148956bdd94cda430e6fd591a608d79bb395ddd7a117fc2a0ed913c83ab8b6d02d7530b9d19f56131d892fa5358c71bd86fe82463f1180da57b592b168c7928380e30c6026941681d0fbf1083a7d3ad6ba5d350b0bb8ba3e1650a3443f98fa41ad48ee0cad1086884d8bfaa995db6e8eab911265a7f9f06ab62ceae48b3d97ee22336b9c56b9e7f8422a3020a4dfe5fa1b8313f53604bb57fe53b74a5cf7887abf4bb4e6356e4664d88e2fdb745a728c513a71411fd69e0aae64fe84282bcd095b03e729cfe1b1f51f3d735abf133658cacccaa1f8dcc0d56fa40143bddd97a6604f23559700a12b55112e09277d884138cdb0d0a2e340d2437b9bb4037dde75d75802a56347b9fcb320ae616541f8a62bd5c122a3430c88ad1927610712422579f7a12b0330c55f52d0c0c096d95471d89a3970971b551d86637c910d6d9c01555d9dbc837f24466592ac38e6ebe29567d99f037a2cdfbee74290f8a0c55e86137ec46d55d3f98fb0bf9c49f61b5c21c9da045d3d705c0af5af5a0114f7ca2fc032f2c1a30911371166e6de0f3906cea216a483b69d238c57d498bc898a1021ce489bdff2d1fd1b4642e269ec61dfe0a549901614ffde6fbc4e6a0940455e2e8ac125f0a9e2f7a708b4266922eddbddad86bafb93a56f59fa83fb89b771865592f931cb0dbe530d917ba273234bddb430151414a52f4b9020af4c6385f857f73251d260ee8e0ab27a72f3f133f68ab1e21d94ef957c2093d4be8abb006ded57eda37fc66d6b854ac79ddbbf52b8e0af8aa1dd6e8f757dede00b1e52ee04138228fb1de532a17b625f74556abb2119f4660fe23b01f1adc9df76df693e1b736ede449fdae24ba5368912bd483e1af7b776fd74001595107e02afe8c5c860a8601cafc5417dcd204ce0bd9518a8830ae0fe3004e56e28a06bdf21f3783de54ce45549122b4c4ef17e00060c1f6fef644e1be67e584ce49eb4925b73a6e112dbd6d325fd0b1f1f43de5ea692f465a31118a56fc0cde43605aaadc333f15c0f856df7e813de1b1a5ef4aefb02c0103f9e587681ad96161c9ad05d7538fb6c32e28b6d54ba78029abe92c0342196a8ef4b3cda380ff65927a871d04e0a8d12199968226893cbec6e7d2a22aaf9221825ba5f804840a34961751e849a269160890fa23dd109abfe43fea3592b261fcd4786b57f7d7942340d74eff91c438def2976900352a1e8f42efdcda4bd85af810dcc8a1874667e2d354d05c51154c7cbc7c8b0f755517f086a26c67207c118a56716d1221af0b45b4633f56f531f02d70aca1d049608e462039c86a332272be98594a9c68c45073a7e8c2e55199f773ac5ea6a6a1934669ff414e1815950bc259c928e82deafb9f758cb986a5b9fc57663df46adde455e3cec0b2aef68f3b2c4b4011699245a26254547f99491674c90c5eb44a4001b0f4dedbf3a376036353871f55414b9cc102ca70c5a716806b61427c23853005c3415a63635a1828b4cdf63d3b80fa09d3276a32ca2fdecd5deae811fd982b18372f71de7f0e7895b95806404122966b222dd45ac9b91878c03081364ca07746a2cfd852400be896611caec6996fc627665d5cc33cfa5582ef78f8594f67056c7e019b1cd71d37d6968b95f423ef0cc5407e3e24917ec256467ef2fa3a5b0ed7f32a4b052cbb97ce0c4aa158215f7f612351df6a2c702295991d716a24a198dc52037e384ee2d04a37571099a201225923671277fdd150e86e204325453a7b33dff9ee695e874b0401aa60007c8017305e972a75a1ddd9b941ed1c95990e8f3c249c3c4e2e63c035be5dc7a66d2861daf5a90764d14166ecc9e0a501c13c46808fb74132126e4fa99252da058d660bc1c8926450f85e605466be1aec10371fbdc7c4620c710d238362afa0b56b13b14ef9b9f2ce8996815c9fd1e2e3aed192d882243f82bfed330efb54f7a861b94f89a9bc66793be0e6c8207f928f2baaab00f733f0a6ff055152cbad10b858a6f600343a5da56b65deceb789da85e249f5baa68399ecac537345cabdebbfaca82ed4fb555fed7898393b8ace57a84641fcb1cafa673344c25b40448a48547d5eaf8285c0f2b276b8614ea1dc79de6ce99a7175cef6e8d2c8df080c2ebbc8559e4573858f87a4ab71e376db7d61d791a0878906f64370a14a32db027ed06bfa064e002253d2a77c09bf9ace2a98b2e27a66fe70ca228a3acf842ef7e617bf6e727c02b427e4f45d41d1dcdbae95415ecdaa43903636d4668aa217b7ee1cb909e871a7bc104b37fedcc6b83838091e04194ccbdfbfd8b0ed9c48d82e303e50cb18e3a0b58ca72710ff085e0f9f87e516535d4b435513deeef5e1aef5b7c3f64f88d6e9b5bfda1c0c4584f669c7b8d0d3e3bcfce82e6a3160bd8dd49c4c24e04258bc4ce46eba27f0190e3a0c5a015e25848735c38f439fd80126f7ad67d26abf8ea82c7511bd72e6c8ed5ec838d3b5cbcaa431b56041f3a4d26f2ee05d47a9369ac44c08681e3dc6c044ab60158e3f07eeec9fa3c0bb7051d86eaa95fd078578882cab9e99f85a01e7cc039d8b3e5ea670a36fb1af0362f8052f29c305aadf3e2655d2d744a05149e4ad8743170e6de859a3d3c610af499580fdfae42ef9957e5533edb5b7605df1fdf5345802c5fbe1d1bd0ae03117e5894476559bcc7cc31ec2a3b4d7b271ab81cfb0d351efeeed1aec924d43f5d2abefd48df820dd2d54509ce060d7cbe76fdb2e0e37cadd41e05b0a108c58909a038655c9ddb3238092df2135ddde2bb293a6745dc1c5042595be3f6fc4faaa090c98e7fdd629f61a2a6ef81026f5fed34c50afef87a6820893ef2b6a7e98a6970863f6ae27ab7117012269ce0a1d6a92ec80d693c510cd4f73f9b4463e412fff16e43ce9ca2df58bf8f54c15e22a6bba29b385c82923a9fd72ed9506164a4daefd3bddb4594d0316257ec9dfd63c3c508c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
