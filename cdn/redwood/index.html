<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1a7ec7c446ecd9a9c3fb9a43b378c2371b9b8b0c27e1ced34b941aa7355d4741c469a689225c1f809cd492a71da9f7adace225fa1db2f613c640622e537e3319ab85caaac19a81434432ed4094616075a76d9e24c2a318fb766acf083c297d87be8f8bfafc078c72a1684fa8fd6e5384cfb3da3674dccaafba40590d7f38cb01e3705b0f1c0deee0baf62771f242147478d87b424396bbb0755f7cbeea25ecc9caf9418f7cec6a29e6d177834c63ca3c5c6194516418de37b1b9a6f195bb00586cd57a17d7995f3cda39da4dca9cf17a22b7b4d4ccdc93139f5b1ba87397c465923ba9d665bb3b7b43d19c9a44616b1c2f718379e63aa95c9d56fc120d9d4ccf1adc12efeff665f92d11f908ad9840851087c92a8885b8699328baf78ac89e0e1b40ab8d396fd149d13814d8933c354547c8f9d777b7e36b72c84cece1122aa944eabbb76c34ed48ff34979d43d3828519250fc8510eab5620b0156deffb0712b71a9d841de2330f6a3104ba70732db5c6e97051e44d85b837d8f2c45d9f0dd14b8dff3d3fc55fdfed89860ef4d84c8787dcc21227d1d4d74a7d6ca0d7c1343132b7d278fe1d931188be524c2cbd75b3321d4cb1397f1f1c7336ddd44dd3b15b99ef2d3c3278b69e1f0413a3982f6e6a28297a30be42a4e7d538607fb45caf417177678f27c48117c2f99477385108848a3f33b633c9de534f96db846873d651728ca894ae4a32f78735112471aab17dd4de9aa7ef97a612b5c2238b4134c16dbd9f858e1670bd5c2b731b233d6028554c94ca9dce11cee029da543679e86dd4223d23094d8a6f7582d64f64282bc7f358495ef28675946a762995a69ca9e4af1b209ea5afe5ca5daa41671cdccfc479a8cc4c8538005c84a278444f5ab2478f496b90a798469004dee19bda3b0b9ee83fbf3158b1f3053a3d853fbe896718760960989c364b44ca9df5973eb2c26413d5bb2b670f5d4de0c5e321840e3b9eb2535d8841d5a72ab75057aea0617b661576a57d5a8644751f80a4628b38f0e195522bc132f3104fc2a231e496c9eafc15d2173d269b99ef736e4888488c0e9fbeac1cec399b0f077de593fdab4fece1de3109c0325b54cefbf4c6e1c77523b990920cdf99b20b417fe2c427a4715830d17d06ff99ba3df2e6fb69a634ad2f0836a67f4f6c3d744a37c1ef5d358a898c2cdd18c6788320abece1a8d5f5b99eb3ba966f15b9f69da18c9d64acd555f74095ed3e9455dc44fbd4b7aaa82772647eaa16659d2b2d801faa30ecf6dfb7906a6c893af7c32f6b036158669eb79bc5ae7ab5c08f7fa40a387843308f9ad1bc820f708c62148b4d26305fa3476704ba6efec2bd710dc67b0d6a69276c2807d23ccbf6033648302c9faba88fe78e49e7cbe47dd8c94cb19fb6ab6fdb0517343cf56d91b4e9aa99926f6801924acf7b37b51da7e95c17c0943647554f4b1b68bea7f5c61ec261d08e4658d0edac9c4ab5f5e1de347bacdb84fc292d4e72fa7b41a43c64541dce241e60e4b3bc899d7afa2cf652a846d30546f7e7748b0dd40c1d205a7994923b3696bcfac21752002493443ee4e1fd3f037918176e55334b1bf5bca00f4bce0cd84fb4e1d951cadbe326631534adcc81371d5d583d33890cb396c2026a4319d6d687732e824963425c84473bf2f9c3f75a9e138a73a809b41f776715501db8801d0a252568f3719f0b3b9de2833192a6ed97f5aa5b6020671d2c860032b21cb15513e4ae006381a66f2d30761b7a308d64decbf64d0add4701ef99a2611b9100667b3e0cabfdec33cba58de6fef32a20e4caf9a74c4a8443ac9e167893a926478ac2d1aaa85c238b95a48da9a5f38596211380dcf26f265bc72612875f99776de7ea2152bccd165c2ebfd0f1a5224b9aa028cd8391ec38c904de4d13eb17548960ad293dc51c5f5d465e3baa58d18ff793420f406aece33edf97a273ce5951bf3522be29d19bccbfc5d96d86a27b02b011fd395d17dc838e88189acb56ade36f3feaf5ea113ed99e089f496c576ad747fc7d9329ae154f30c0a5010491bda0f7df5be58d135621f5a352e299bcc25a4d2b56f27deba8a016152d263bff81c993ced531c9c2c3745d8319e8bc2175c6ab6d6e8e483476df9aedd2c32a2c383e549d1288bac0a207561b87e940ec0b0b7418496dbada61fc23e40e0266cc3db83203376aec881f57c3c7e6ce151c7edc2407c375ef729b8766e555065b35f5fc0f59ea84ba32371fb590199f7ba9f507a1b52576da510f07dd5c6eba8e60ab92432aa87f64bcdf283b238e5556f35568490e8724c9016a3047f1c6338045dabafc5d7b2ae9d269dd49eebd0f8b12b8677b263d37d084980adca67dde75bef634549231adbdd8c929e0e863e604e96c845d819ce9b6ccd29c66cbdc22df19c7a92fc539e1c0f2a453cc18f623931cbde429479d13864d29cfa0ced1854d0ef998e7bad4ea72788c6ee28374a0254a3ee2c5846d04ed016c4af6deae6a7ad1b1fcaf3c0ff550030348e23b88de5d2ff3e90c0b45ff2d2a2b52ad7f74532c4438f1fe87bfd1d0844af21efdef4df09039a66af29e7958363ddecf0b37e179be1738808818ecd5e8ef7e14197c0568e3134710fe18e733b817d37bd5e1277adccf9b6e82ed4e7c46c3c8a2929693d9e0801f0159f0f096a91a55f969d4cc48e2e9459c480f52078c47713c63e35522f2deb2185e0965632513bb0f87c907c57c89d265d446a399ebefef2e5d830a125c903dccf7d1db3f4c1bca92969105b1164267a7ffd258edf584b81f5c923aa2306783164a0b0db51df4d4a6a7b3f2a4cc28ea83459853a9d4d7cc8e10fba0499fb49e75363496901eb4089cd3cfdea1a3bec571cc781ae09afa62b2deb768bdab9b7581526082ad86b822ad176ddce5b51fecaffe811c9c36b112d465bbf4d671f8af69d3e55e1e778afd61ea382f80c8be263f1be61909919441a0d6b1e888ce3d1443231041e82cb727c62be5bdc9f34f02581692b11cc18ffc73b7ffff82cd74660a4aa9cff5abab322892c14278801d876a5a81f0e661dd884bafbafb3d1862ae37ed36fccecd6fe96be0f6b3f26c6a845259ea3dec76d98ba32edc56db8ea664117c2ba45d42cf9c571423a579731cae1aec40c8a7a4d16b3b37f8f4470dffe6e86c150c9f80fadf49df96229751a38f1a72d56e43c2b86b1d9bb00a36ef6892dc3406a82d3e8c2deee54fa9e2fa9137d1e9ba105b5a01bb78a2afa978cb1356b1ad6ee4c194f452b842e8e7e50779503f6ea2af082d827a173dde092a2850a29713a5636cc65096569f32609eb9a81a992326d32be49ba1ed10c55f94524553e079d7ae18f136da55937c4815df8988c62ac73c61db6738bf7837fd69721b7c3a2c3c9d48faa8fa307151d8595802432db4a780f894ce63b406681f654e3e8b03489bc136ee8e6332be9dc8ed68794d3e7077994b951482da3b148283a23f3ea831b188be33e9c7819cb405e3dce9de6e366f7599170c7134e5da90d8cc57025b06f3703752c64ba7a2085814b9c8c0ac0fd9bb6a683664732c66b87934ded7460659fa26a985051e7a3de633eea58e2086e4a86970cd5d1ab12c9cb5b4ae00a908ed27776b918c4c042b4eac9813f012e793e81ad95177cd26f07ca35f4eb46302c16087d6b4d33058e17c9c89e876695f255dff2dd3f5e1a6c24490d8eaa9691a17d2e35ffddc6edf492513745146c5d2f2f51ff9c3c768d01cd78dacccf4a4a7cccecf5a283febebc96018f8b40a856bee1bee6a193087e964f31fbb21e484384f401c350e9c3d6bb7bae68ebd194bb51148a5359398ccdbb05f169bf1cd2b599bfe74fcfe5e6ed267276b5be527f6eac929c955a0115e6e2ea43ddd9a5993ec417313d87bb2e0fd74703ed9fb76624decc220cda8e12bd92c7fa6e9cd850b563763783370326da7d2cbc38b7c5dd16a84f43e07f8aa490851ae063d853b860dcc27dce52c2a35f5ae12b06810d471d963096cc045487e4e95125e0a815a753a18a1c76e77717116a8f297efa12da84db33a2d5672e4be58171d7e2499b78e44c02006f1918154404e1996d8e2c9fd216fa4b842e2a6f865215fe3f80b1c42d6caade0fa5d528bc61f24dc1ab131ea134c7a508d90767dd58b2e08288ea9eeb7fc998f32133a22a75bcac8252d64b1009165a8b27b171fb17f4b7ac91f5299bb34b7793eb3cf097d13edcd28be495222457c0a0f7fa4a680a66aae7be3b266c7ce5b045df0b68b4b183669bf9a43c5bb2e98e0d43f37e3bd1bb96f468c57fb5f91310fb810d5c91dea77cba0de5f4dc51eaf05b0262b0db265a1911d32443e115962bc43f870d63318c1f0ff5f40373ec2e525e43d78db9d9152b852ef64df30416c02229468e21f263b99a241337386602126137a32b36216f50e571d4d5fbf4d8be03f82c6f83ebb8e33bb856e8bb6d299e4632cb4b9e255a5ccfc78101fb47aedd9f9164b51024db6393420c4095a3b7d81c90718509f02f43077ef919dfcfa5a10beec81ccb925db8e7d3b56313e408cc1f5d54a70a38ab68904defa4beb4de89b2208991b451e190ae3e7fe7821da883ca1ce67c18864a3db551bf1228673813d55731d188c82f01227502d28edcd25f31af6a4aa1d584104efe23690a38710ab47d771a1e40bb40a087315d57fa9d63fcb312b90c9f1f935934aa3a6e818bedd2683d54c857cc770a343fc598e259d3b80a27d855da68bf9b4e9aa811796bd96e12372aef3a564eb448670238ab08e4e11d27fec0cadeb7e4497ef3c4b992b66cac5fd0933545e6ab17b44436fb9d8f9d0972e7cc11294c8e827a8a0a92ef9f3624fb79d458f62f20176ee652be0ff4f43230a1107985b911cd426fa2b88f43bd9d8e72657f86ef894cf8d54182479359f20af86f3ea9e9e9bacf84c260ac21b3625c320c879302f054548c363c6db12646c3ffe37e1e598aaeb24955be35e633c6022f17a88b7093853ea688fb4b59767f247d0d25641656b9160b9317db16be1b5544d840f06ad4930298664b25630aaaabded0bb69cac0d77fe96c012eb91bbf43c99a08136998970661c08d81874c2114b76f0106adcab0474a6388745c5dce579480b101895a11145e93dd672afb8e5b30e601c46003aa926908dc8691c0f4e815a2077221b3a239b588e75932c6292a567e8034340ee892235c164cbac76472aaa14fbd24b822153dcdb72593f0ea880d54b833143a0648331b87aef119bd68d9282972da9c23daccb83498b3c0c41c2a531c7ec21ffd3582a155f4f70ad4b68909ee259934452067bc61a08855e47c72e01d6cf052f80b7c7b4330f365d3b6c2b927d5e71fbc372c437b8454c00ff7d978aef9cc619b94c2f837eccb014d45b490a555dc25c3bf537afbfee17a41815648a41fd6a4f659edbb35a9b7aae88af53fa79ef09027f341b5d6bf7bb2b3a2a29430c4095028761962f62ffe0f467e9ea0a9c7fea06648148108869b929ab3d7fde5087b27c0b11d3d2a3631139cb6cfcd877261b43f2833bc23e7969c11472e9ee005e67f3aeadd8a12e316e084c49d8e1bdc85688d0642ce8d497ab8328e1acc1e7cc6cb1ca5815a8d297a9f79ffe9bb500ba2aff35a2b9d2b7f6bc8599d41c8da9cd0a86bd2dc631102ebc0f624861e710bdc505784646e286e1fc13221bb2011006703c87480074a61c790e641e12368226fa5345179c6a67f300e0ac4e495ca9e3f26bb4c83d483309b8d92619af7e95ecfbe174b69a939a4e676c72542038f3ec9cb74fe9bb101794c21a7ce80fb7f9a5f0bb7963ee8dd7e91c50ff7e42360f1b0ab47c11094217097700ef1c8185504492e345e8fd824aba785caf2574e86fedb8aed5cbe77ef399081a5a7c15045ab04ac51e2ad2b7041c20ce7985b951fa2ca68035d30047f2242cc2448498bed3565d84aa4703b58df5d02c4ecfbb08c8ec89b98b3d9108c27f9bf27396b5c26495dbf8f44068681adb8c7eeb6602ca673892585e90e519615d28a4aa4a51302d0a098a2a1e02a77d353f10056ae310e86631edb5ccded438cb951fe2f4c761711d10edf554807ed24fefa4e644d7314627a1b83dbf154d62d8a9ebc0adbe3e99be1f1c925cb9151f682fbc550db7a74cca3c94d5156be7767401b8051cc6a5a041cf34e7eb22a350b116886ba3ba0c273a56d3179f3eae1ebd80cbc58915912ff14817c4c41c1a2d235d2529610773082b03cab4ee3cac207c8ae21c325a89ec32b2bcd967c17f26f6a6a3afaef376c913994198009edce761c99926796112027b466d8a432a7aa464aaea886c2d5587da8dd5ee447f2fdc33f112bfaa8d506b92b169ee9b6d3b1ced580f59bab8b02b895b8eab5cc1a43fc14de673bcb699659bef99db9d83b7bc8a35d33507a909cceb2b039cd420cff4decefa360217265aa973275aa7d0ddc4afef7612e4874d1080a741dcb0611cbc09b1099469f325a9d3bdb7698f270a4f34a0c05a01d4abb02741cc536c54e6ae97d3d19fd898eaeb0bf30fcbf90e0f369755f30d5ddd494345e5b11d3d3bc3154775868c135558d2d233bbe479309243e3412efa773cb3821d3ced283a1adfc2a868b4c339490c13ac721d886b7447554626934e6df49d0ceabbbd6a8067f680740fdb5a392d72e8a77c6873ba2abfc87962b630adf2a2e97dbc1b3304f1b6f8857aa187882fe2f776811e66b4dc0c5079a15c8a78f304425a3ad383390e6b4db48e40280b815f2bdc9dbbb7b05baf6c2200e0eadf0980ffbae2e12cee4c7962ee825d5e54b08eaef6550d1620f64f09d08d0b5d13d69a2b3cf8c8f1386b05d26540f7bb17d03a549e6bac7919b8bb96f89c9c4695d56e806adb3150222c2345d6f706d66f709865fd4b56369b7c385457e0b9e0f19ea346c73ea2cea0d3da6c5ef0a9e5dc187708e07d3de5d568c2e80b8ee212c8e092724b439d5b572b24251360aa378b54749facc8b153704b43ae933bfb60fbc9a7c244a2140f057d4e578684d3571b24916d5bed6b516b1fad6de4bb372e1bec79bfca0d6c28019bfbabf90364cfa5a31d760145c0594591a389d258ab2de50a39642dc865f9523018368e11f6e8a86a01da13a5f3c9e4464362209965cd390a2db30c19b48d6b753113ede7d8462a73233b4bc862f4c82cdb1a8c420676ced16bcc9d7c3289c512c4183d6b57cc7fa3d1e50f13cf2f9bd2529f802447bb4a4d7a5b2706796094f03aa81f6fc34f5d1e2028fea06768a4ff2e32c64acade2f78e17591dc5217003884b64d902909a77697aefa72cef26867f3205b5ed8e7cf30918d6781cea6f2485ac4ae224b4efdcb0ce3b31a60fac226ff8a9c5bbd45652a47978880f3df7c1ebf2dea839324078849f83ded6bd4796802f38c9c2710ded4ef0f6bbc4e518d177819977d6972834a09599ba0f41e03a23895ea4245f35cbb68bee8260a26d6cc88b74d5872b21665bb12ca43e34546b350611a17455dd90da9bcac086a48a7ff2542dd6adaf882d601f3e6ce8913d43a781bde68f5217003ef0d7894993cc10034726b6e8aa4f489bcdf9f6194dc1c21d008b7619adbdc0dd295966354b8872a253e209a6070822f1e6c2acf7765575ee44e1d26a761ff3d2003426742252bc9af319e257211c4dfd84964dc25362dfdea8dab64769b8cbd39db69f032afea0c83c675991f11c3ddac0125c195ac55b4ca7768398404a51d0ad6e2af6c91108266970b7dd1064bd88fd4a6de14f37639f96e6f58574955878a896229c62f2db307c865bf710c7d60a1b133959a0283daf85821f5307ec15eab72e49350c57aceafdbfa96d119af2db075d6d8b5fead3b14554277d74635f7fcc2b419cbaa9bd2ed4ad917de0db9a45f98a242ee1a490115297fa2a07c63f92307b85823b5a11dbe022c5ab452de255d4075f5aab01ada23c5cdfae9b6f7649f14293c444674fda74ca9568c58735d48d7c36f1668aa5185159a3abd62c056429f575f4906315eea7ceeed8675be18426a223719e4419a092b7417b82e57b136e186878ea538ea26f9dfdea6c87ff13ac344008c48dfc19c84726dc007c430c2550bbdc257751e2b6111b8d2b31346ce68f76d9afd4eb747ae05c2ae450aceaa7d72c6265dac2e2ce40404018dde1781e531bc892d660e6c9bd2a50f33777b2c07c504f26d2a2cbcf570d52d49f518cbfe86106f7b0d0af4c20ba8aa552f3984c4720a7a5cd52c4e945edff99b9e4c70f4f5035530dc967aa60748361a74362880a54e8fe0c62b901571e91f028505db36d11bdce6e1dcfd3563f81b1ca1282ac09f9a7edf1bc5778b3d3f74b33b751b09413684dcf26be94be64f1e31facb6f7351bb2f502870617582fa7feeedd849c60eaf40c50e602b0127f64ca4ea0489bbf70a0cdce10f9900eac0a21db8c000834789a355ffc1d3ff5135d5c05c67a94c368ea34f77e29b7613cfc439a0d3235cb448105ee3dc9c41607442ee5398622793a247e9bfe6d6f1b7ad4e448a4b8ef6eb855cae2c108955a430a7c59cb660d93596ada227c421bfff5e3fbd43691ddb2ad99646b7a71a6487372c63b77c559cf64909ca70f7b572b005604671c1775f83464b76c797cdc98f0f045e5f3ccec120e008895aafa0b377892e5f261cbf8783c12a8512af520bc5f7c3871077b7df1c55dc9d35f2882ad6c7863572493018547f06330987c38ee619eb3566a5d221a4ac33094c45ee5c592d94e7286aaad5ed10ff6c086f73c2242aa0b71b76cfdc64d47def1803c8850316ba30c3a547d5644e908e8cca70f93ddd3fff3ef3de7a794397ac823c402281f2dd49f8194dcfbf5cc72de56ae8841c6590e94a9a7c9c56156b6d41f1d2a27eef9a7464c10a044a557a979aad594e67ab11dbfa086305ffa98da2d3edf1ff3231777ad13ded0ce4b3c9f6a055af80de0ce14b433fb99ebf4ea67506d1bac6bb01f6a28723b0b398c76fc93ddaae23a7ab9ac0fd5b28a8ff7b6f9ef1f44991b9f3a909f1106e947d24e863ec695c0efe33dd9854a98f134ffbe172d99e3d5160b42f508ec23d78f2e98d3338f168c0baf3f7d77daa2ae366453a146b5347cb4b0fd5d4266f3caa11e7d3119ad6e1dcb9c0c281f8d2a3611e827fbe776536c575ec32c625f28fb94ccd90b654a45fdea47ab9f2e2be03d65db1db5569680b1a524484e647eece74a456752a85c08894dc4ad904fea09267903a2de31b855b5c22947fa76e98fdffac81803fbd6c38d34e314faf05e445145f24e2fa1ddbf226e2a422ffa2106a08098dce48110354124956cd64431b9d05783a0d5074171d0e928edc58ca57783eee9305e7a610aefa4fdb19cab2bd25a7060c77434578651c55ba37223e9fa7fdbf86ef3dd22b9f03b007f8dacf8e2e674ede7992c8d8750cfe0c32c92ed0c7225e164d857db6eab1e215a47c36f2c45ada69b9b76c756b5329f617fa227b594083aa94ea36bb68fd9fd82f87d58d16a77e3792fd5d29b8fb8c1f412fec7d39b0c12ebfa7e9d43ed90867f52a3363bf00a4e991d1b31b3bd8ebafd99a2af66bf2fa697ac51f92397c358551c87a817b2b970a13b9ea0327c4f2a170f0fa5fdd9c7400571c22a342eb6749f68bdbc6d69cf63459ecffa4310b50994cb8d4f29a56b2bb82f58e06317893d8da564891d88ad5f399d3cb785c0be84642812af331b4a5a32a52ed597490501ea810b7f8f69a2fc1c9f8448a067976e09b46c88abb38fe8e4f128d4d8136128c7bb72549fa31692c92b0f73db178271c3cf6f8676921d69fcc144ef41d24c5d53733fa2650bb7cf53853f5dfbd30515e08efaaebda6a48a63d54f36ee967f06755faaaf23821992ba35e0f1957801b577047486e29c6735fc4f958ea11e1a073e14c68b2d36bef5b4894ef345186ba40a7d736b258f4884f2fc25cd1b7c177f1dc44cf6294ddafde7b10541bee16073ce7f8a9704ff726ee4b9dca77dc801db598a34b199ab44d20478ca40ffb4014980a3093e9d3a67cc7a92ca1bbb6c56de3153b65e7553896efd121b08c4bb370162180863ff38ecd410b4a0ff647c2908fb96443c30b35930df735403af951121ba1dab0225a1d1ade845f050d8453eac16123e3bdc29563a5f06a53098773b5825d43039d4ffe4348f05f6888fd4de8a67a77bcfa5c4abce022869724b620f22a8a6f66d3cc52c55b1404ccd0f40d7171293b5b7f580d20f0633459b3742fc723ccb15d385bd0f212c054edac40bad5d929e7b3c67c453fa08aea94c71aa6acfa59cd5b630b1e86b9997c58960ba87a1c2376a722016c0d890fe568b2f7047dfc24dd39e07091fd7d46688ce37863f8f7694df372e592e9fd75b25721c34798d30e5c5b8491e1b8e14338eeb7514a9290a11549561ce803fe1ec80a359223a135ebe68ccea8f340c0b1a238cbf64b63d0927f94e5f2be8f2dca7a6a6d1aa10a6d26cc887ae6ea4b3f4606ee3906422f7f991969b7236d43dfcaf95cf238fd4fb368e60759c52134a7e3e73bc41a2705a3de2e8af4bfd1a972652040490db98d116cbb784fda00817ec1990d019b2847a7556f13fa4633578ee8cb5c6456f233c0077ec810a43cdff733f529c03591c7135195594fac1c5c8988707882ba9846627d462d6e97e10f13a9838cc222d1a0acbf5950cf36b8a9d46f19b091e631c5894a3d1c7ef2078386c8a9946020c006dad0cb6a284329825d3bccd34a0239a429182119c41c375051c63bfc9246de663fb18e04efc2d3991e15da60031312312174407bbfb292e671266010475e856c7cdd4a68c4f07f21b6202d9fe7bed1595277d0dc16aec884767453ed9ab3b06eaa08a9b94c13a7de322ea8d3ec67447e12897d9b3635fa3cc6339fc263ad5cd39b14870b222712438bf87d20ca2e46cdda98e5618110d96ddd00339bc610cda26845fa2ac02f43315a5e49ca6cef9629f1c3522ee1296980ea71d96743da4ca3bfc3cbece8dc88a819b5b9d89155c57a79ef5f29605da174f6139b657ccea4f703867b50cbf1d38cef5a0b5ee6b1a142695c3dfeaefa55cf5c84afb86d4355aa745b407744f21cb6b3f7b227f76106a6054fb65497fb070f57b186254855bc5df8c168776f76ce5f88e631b19534dfd49edebe3646aeab1abb3c6886ca0b176073b7b19249ad099e2b30e588d4247cdd7c00b9629e86242becc624a81039935d18fec14f278b8b3ab653a7d65bb0dcaef7175af8e565a53375118104ae66f7ce829f89db4bdcf545fa25b8045797ceeaadef2dd249c789e16f0e4e77fd5339dc38c126929187a0831354deabd58d84c4e6beaba5a11e6c928026875f53f41189a126b4ae6f70fb0aa830d7aed0726d912e8883edf739343267254b1d09f7882887fd6ec1f42e0ab160cff53cab9cccf414a605dafa91fc7dd7c6dcac3d4d344ff4daa8201fb397402ef8babf8f1e8a9793024259e7466e3f63be1c9d3ad019fc12557c994909749ab419e6d4c6b969a88e25ab85f29378081b00fbffe8beeab6db95eb0ae13159747891bd237153fc68ecb3c45ea7794033626062bdd2e1d38b1b49dda1bf2dba539426ac35661df020eb0e1cb459570934a94be8e8ecf3193ee2f8a0d6b2f94e18a88f48d93d915b872d216edeedfa3ac3e2474b777ebcecbcb80de63117e25e8dc7d05f4a2585420eb6c6d0c6ea662d74b581123e2773e60faee21b126626c6da3d4e2e59befba614dc2783d3516cff95c1e872834cfbc57d16ed7877b58f6cedf3140de7d33d00fb61596bb91cb6b3ae373e6bc4d3794ee7d58d5c3c6da21b6eab9ee8965d8e05ac451844af00e1d75fd7177926aa5de65cb7dcb7e4032cb958c9d5af52050e20b6ff7df94b598b371b8c49a364039fb35c768081370212bb1a272b5510f3cabdc5cccae9dc65e995dd6db633baa38464883792708d683de188f03aac2971860cae1716e69adda47e331ec365f9286510811cee749672621b80cf3fde5ef3d6d5accbfe5ae11d3b33689b3a0beb6bcdbe9072e3b7db576bb8caba8ce62355a26241709141723e8e3fb6b12cf23efdb6faaf78cd4dd5d2eb7f48fc24682380003ffa1ed012552db806a940406c6e7b944382e7153a61c78a63358291854a880349ad7849a6895e303086aa1b6169bbb11b1b53762402311b1746c8d5324595e4321a1ffd3f4b58ca7c14ec42dd314308fa215e24d4c652910f82c97d8f6283063f141a0a20342185d1636c6569f13201d9c8dc64d11511d527c2cc0ece6fb90671d62fed82ebfa9d85cc04e280a718454fd3646ee0b195037484dbaffa5b25793e50c3904b2773306e77aa4b750e429d31445a61c516b4300fdae5b718dc4ad35a1dbd5cccb2b9c753791106cd0107c0760325dc9022030ebbcd9437289dd0920e476ec9f64326d3da4a1460a82c6591109f7e1b3a1bf2f43b66e2fa1796b726f081c2ba42ff933a04b81ebe1ec265c58ecd962c0c5e7e0531bff1618dc7f0aa2190d7626f4e8f710cd6f88f2a0598a5e7459c530c2d06b3657e6eee1f396f2379bc2b3c2a1e6245a8983f04d04726edfc94941913c504b1fc61179a3f24afb3fd25a9949ec82f8b3f01bc7c428f0d0fa0dd7aacbfef9b9e14d0222db5d8cdbbc78c6d6e4d47f978b5077527fcdf006e0fbd34b94895e4df2551d845ebc2d73d9a239225b60152ee5098e391477bb91a9e33697b9b634845d5285c66dbcceee18cca43fed61032d1a8eafd566efccb15fecbfbc5383c8a807e9a07eed39c9958b52750ee18d4f0facea5c7cdc62b9e63d3ac1766a33b53abe360fb4c00e58edf051ff05470844edbf811b003b38b62b69efef3d6abaf307fe9758ccce6da2d80ff2c8cdcca29f812ecd3d3d935500a7875ddef2698c76338b1b3642b6d6fc84ab6ae9bb23a329143bc7e59fed13bbc23b0f49ea73677c6b0630174f53887df7ab2263317ddfc4e27222bab11a341d930160787ced5165c0450409e9b890af59b9aa5036a2d53d3ec70f7e07298dfd38edd85edfc28d5e5bb2d7a329ede613406410daea5db929de759704e7fc07dd67291bf202b55ce4775de84bbe336beb75637a34320cd94e183693279191a55599b36bcf22c757138cc2cb271678c539c761727b11d8f6f7bb9f2d38a0064249191c249512a7e26936a050ae0b104a3b7ac829996d9e6bf7c5676de092033c85b2f9b3abcbdcdacc7be3d955a0ab859a4f65205549289238881129b9840b5113f3c794963bf65336cf32f3c4e22d4c86c4920add2f7c04d6155642cd70adc60931426985accd30f3483d54b25663b48d4f712724c6f3f2827ff958c8fd1c551e859de351d39248a7cce6d01000a9e07c96b9fd08d9e32d566a4f11458f6e5fd8a385df3d07d9d56cd8c8fa0d765d786fb1708100a74dd81e3ca5764d002f6b012bde8e38a8f8ccf44388110e2c8f90b7cbe477c047ece587803bba46622c66518c518f6ce9c7e3ff0306b738c9f4e8691e364894aed74cd7b4ea206aae0c41bbe0cebf8387b4aee6f8f433bbad4cb7e40a8fbad31615bffb960ccbbd7559baede225f09821a6ee5112d8bc6bc9bd03350f14d24dec9861c6d008706ebb21b9e5732d33f2df95ac4ce02d60fd3e7b8dffff07fd0056db7afda38ba0c0808c20e6669d12a16df5d8e73644757202a518ed448ba856d0c15a80fa8afe9392dcb6016ea163369e28d2f93aea32dfe6cf16fc2f3e1f5fdc8756b5b6c7a4b0c27e53a639bb8177f778f099f131dc69e0982039266ef98ea0d3df3d829341f6dec5f119e4d46189a1751148247437ae4b715af781a48c636f5d7534a6441e899da8e33c87cac8fc534e9d2ca1c0d7d2a3ae773223b2658e3836cec249570bb9aebe115db6a60f3b3b23d9e5061ae4db70ec5617a03f6f9e7de38e9de46a334caaffa1828be7a5fdd7e9d5aca9bd71962e6ede8ceaf06f6e602650f3fd2080393c0c39751a12961052ed18cf58a705a0baffcfc0270a97260f458c5281387d9b3ae69e83e85aa02c3b12d379bef2128d2ce2b2e39d64c89f5a4cf0b0e97d1532c6c69731fd2ea3c62e4b853a0323cb5aabc737644ba793df90d228c468d40a5d55dc492a6d455b7b9356fa41f0a8a416b928f4839ad7744d2eb327068fecf733af21da80d7475b525aa9d3cf9760e5900d3e9f041c8ec3f0796a1e245254058c2cb031daef8b4b4fc816a2468dd2681550242e6810fee0d42cd1b58fa192f97912093346c2a304c492935099165045573901fbfee50811a98af7586df5515ba3ff811820671ff4b5d706e22a01c96de85cdb4590440c95bf16a101359d5b2ae9ee0f1e5e26b834f329249e808498df97d8eccb4e3f0c92ca1ddf9356096e9f4f11139a1fe6ae483d24f62da619823ea29890d11609880aaf154ccb59ab259b28ccd7c134a181b1f70c34a58cc18f44a20e75013c2d247315fd639ed54633bd9b1fba05d5a6db8e6ad4bc1be01357df2e314467b0373cde6fc18c2e5ddb3273befdfb19e45895c995c71c570a2aaae55355460c116ac3a9abc5f809ef998a4d8c1a5da5745cdac3bbcaa01b798f6fc69a3f6d19bd4bf88021d0b53843b74f42a9efd5e72366cd2c42ba42d878dc02ec0baa5f21b720a308b690f21dc3e17130e3aa85805415431bc8e8b12bc852dce73d61182365d0d87ac4fe4f11a86ce2dc8f26a56432725d043836c57d09eeecb35aaa3b2bfe76d8792d029779b42b5c9ea88e0013e5ece7ca252472e2b82df31639a8a795dfb7170c50d010dcda3daab986014b0d804adc3050bc2ef5b480125e01f51b6fd2dfdce49175300a8d09c38d990e11aab25799348422ee58e07b91eb60ba9d3ae161d3d1d98e4c2572a866fa7a0c644252c0b5c98e99d0fffac647c445beb5ba5a46325f9c7be84f2f974808b8cb31fa4b676566806f942e84b246ea3d3cd85e74d88801b23816c6ff48127000fa8fb9526fe48183c83e9901faf95af637c14985fc41796c18e8c3c9ffbfa0b0d7de24696dac1382f555ab91fc428d8c4b42e1b0b8c1e0c40b37cceb97311c7e7f5349cc937309d798c22d0c1f56e5585f5ec35421bc218aefeef5c5f1ab748dcb84213f2828e1e69ef2851365bd1aad30b49b0b1205f8f8c3b89ca26718e1ad60ef61f7f7086ad006981d66c09a59effd2854bc8ac394b4ec8935e6765c045efa1d49153e9c9fa36abd10c6f63aa0a59b4fbd7f005e24c24cb0f5033da7ab37ddf6cf2897ba35b0b2a4810949157632c852cf4af51a62a65f2958f85166942594752fb6931c48c34abc436d2bb88136dd10f2b93881aa6772429ee70e868d307d913e6cd5c1b5afdb57c45a128762a2917af3e924e5d2b2945aab57aae94fb259ea1d16bcaafbb3b1f09d24a71743de3d9884678db5aba630af0596bea91e31fc7b2b7b66cb45a156c350525b01067c71730525d66f78aee6ca05d608b7892ed7ee9305c877d5a96356a2791f7b56e1b962754eda4415c460d2fcc74c2b57ed70adcbcc45daa49bc99e4e05c7537f0cc4793afef78ddddb918050eb857b7a79800f443b63461c101fec2fc84cab99c12d7fee2b17863833ec4c19aeedbf4655dd79f83bf9b850f80968d49cb4e719b56d1b0c005aeeb11b767acbf6672a4d78673dc9533efedd0fb1c16072354ce5a47a1167030d1872ed2bded2d775abe7ef4e2bd737d9c53d951d84bcd026bbc6bb7de38415df1677ddfec850741ec11b3fb449308de49fd50ff817ebb76a90ef5f36774faf5add0a09e8982e8ea3d294608f31631a7fd737a3a5b16071e25f52dddc9abf76a0a7c8f88c2006fba914c5d30bf4b4f142c3a0cd0ce70677605a952cc16caa1336d1e39f478bf6bae4f18ab6c2faab4a88a8138281c0eeed479d0f4241951f102b58a79a2a2d46cc3a38f437108403f7856266a0c205fade5b73ef7f63d3e72e256dc9f5a9221c6ee4fef807a972647688d6ba0b3a0969272bc096e8021185661f347212c4b9877f65b4d0877142516e01fd05bea9e7ccf0596f4e457d5ba58d9d042c5a312d1ec83fa666c1c57753b750f9dcda8b9cf8f9b3c353b744cb67ca1f8cc0e7100e6638c7b767a09a180a952da0a003fd9e0ac9f0788307d8b874a2854b7abd62ba3922caac70060004b1af5cf0410109c28b250762942ea5606060640572c5af46a3343198d62853b5e75ffc3ae2505f737284bc1868c52aad5846d583663a2e7b5fa09cab824e4085ccfae7395bf17757cb39009455de4bf95c91150a29a6a83ab3a49a1df28388c8fd08d58a6cf0029b5b98c78f7f5fc4619417a098b46cb1bb12c3160e7356f046f7a09d3ddfe839a76288c863bc098c8985bee5148f51e47309b7b8cd1feb9acd883f2a2d12452a9271da2bf3fde08f5f4eaa314f347b093d5f215bf805844a0de3f03309504918021357ee2f15bb81ae78f78974b90600cde7d43ddae9eefe569097b299e6b4aa7ddd31dc32f15f4a74b0f4748cb8666575e7f53aa65e1c073de9b38f2140f2a126f05b8bce42bf5a06a46f1b54bc3cadeaba24572109aeabfe4ec45dba553c1f0fee7973a0566cb580447ca37a5c1d40c2dacb401159920b80f3374423b62daa0b0219b9438d527b014cc821f8625c1e7fefbc0091a482441851f5e2a73ef89f581021ece3b72c91b9d376246a3f226a47adb6bc12aecd96b0d538ce5e24fab9c518ee6023f82637cf26e707b93d615c4cbcb7708e4ea902966951c8c9baf68791dbb70094fe867d44f0174935076da70569abdfe58348659544c1e5cf0203ec326d91711c347d5433a4bd843f06ede1df2a4c5863294de44d2f86529af2459a1f90d3d59985311e55b33f8cf4554d5b3504bda802e0694087478e25541f258ee0e9f0ca8c92642328ea67e15a44f335a2eee8a1bcd792b56f09b24a83811be11b7c26bfe643002676a598ba74c53df44d5fd485385c41c39e92cd299fbcff2752c4bcd9a475d6afdd6b3a6fa9e9b49467c64332d883bd03e8330dddb59cb570e6a16fbaeeb490ce6a5b8fb3a710daa3442d526dfd31fea6d9f2ff69d130f357a3cca5f369c490884773dd3e4d5c8312d20fee28101a79b6b4cf59657a30c1f2957901f4632edb5efc9f467c239dd97e633ea4889df54cee142921cd53819154ea7e910c9cefe1e3d3a965dc4551a6e796735458593bcf6f8b4ed4dc3557892d0dfb3b7b8d9c21e9c425f64d2633d3b9c3881603b6add829236a8fc95b4d24ad98e3ea2277c51c5ba662731a03a12265600496660b9db16efb746b93f1cd3f0dec7fa161489de0d8d70e68214ce576acfa0d926acd99b34b558ac01f584030d720ba71d177fe26592e112ec21a34e5e0be1ab17ba2e82a75e481e2e10ead8224e660cbc540c949b4da4d280c4f231f868eff38aa99218a243a5ab91c7ba1456689e76bf41f3e73f3c6a4b46878217b7679e3a25e3654edc8f20f44a3cdfc42a2dfbb8a5705502be0e937dfd8d0052d9287df52d183ef7be2ddaf0ac1745c0c3226f29f6ae8b3d7a99d0a96ea56282dc1a64fa5c89c786765aaf35cb521f99c3c56b0a4e296601637c9807e6607e00cd0eae99cc7608011e2654b98524c5f8a0676aaeb6de30dfc1073cb37998845cc8f0837c5ada3429ebf3e7e230a914b446ec02cefaa530c79cda24ff3f0ba9ad358af0184270917faaf3577ec348263c36e244f24b8506d6637635369903bed759fa40708d8493a165a1ec0c59312040a50a3130da07ce00093af3e7d8f9118b4a6a141f8c4234c53665e4b919a1bd055ec284da897bb53ba84fb8dd9f9b5f409139f22a46b02bbe8da7358739e0eee2c1f9b028b744984937e283d62c719e6cfd36b75555699142bf4c53e714ecd5096a60a605e620ac539386f9789b18fbb9d9c14445a0011fd34d25e4c6a2da026a382cde283ffe20282256a534cd6d4d545e158c7284fbd611642010369e1988e041fb602f3b0e129bf0d078286f1187c70d4ef8eee8b78087927d445f015f69e46ff9f3eff2cc22a38d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
