<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05af808ec2b55ba9a4ee95285515e3a4978b7c5ceedb8058d4df296745ce30d702358579ea09563a359bfad1af4ae5a353411cde93dca23bb57a609dc80be29538bbb4710879c9cc552f22bbde15873cd895edd96189963160408457b546b705a0bedac632937c7a799c6caf0879e358675ac94dd4e6d32188fc54690e0dda3cef43cf18fb44d4b6198bee685fa99090ac177b995463e56db5b0f0d2014b04536702fa325b28564762ef23010e6834eda84521883c5d5322e33d278d52b5b969d2d206853b4e82bd9da31109fed79c608243dc07fec2cdb41f8574318ff19e7d48c4c15dec1a4e7cb4113d17df662878640f32bcd17692800a0cf06adcbb96e9fe23b290f8784bd3bf3e3da46cd901e31b7861fc601e506d4ac88789ad66cf4a6e247e7bbde5b0701d7de2312ec6e55d67ee8ad0edecf141ac4e8a24543871244c8f65748196359102a4998a4e9f71cba22958a02a6a5cbcb1382d8606da556da4408597dc6aee5343621d355b6a9255d81043716bdaa9aa53a59efc5bb603b0114e9dae60ef3299d8b4dd138662a6a4fb08c06606616f4d442738cedb7b052c252b540cbb43a8e80e5f9c92768d95bb8c790efddaf6d1907fe69794746a88cb477c6e26ef0908cf140b3e21f87e2abfafed4456a799ac4ae20568b2c6503d7b8211e3d46a1164c88cd12ec856fcb513eabaf78779d42506a7cf32e55d1e053117cf56a3b8413a1150c6e32f4a2f9cddcd2839b127544c6cf9ee7f64d8095d1d922ad33f4f57b26fc2e12f98991a6a3013b5de5bbb4773c318e9a5d1fc0a64fd80692f57338fcefccfdbecf12a03467fd747b6bfe654ef545a51d944883e9c063246717fcf189354f169c42b34c5926d9a78a40e07f3a0e6ed285958658b2cb6c63af18719ea28ce7cf51f2ecdcf274371460b502c75d7832229dbc94807d9812dc3dc517c0e1d717e62207da4d884e0182ea3b923c9846bc6a42bbe43fc5983740c44cadcf463f961137faf6e9bd4a9206a8eb8e6ee0ca5dd90d963cc513bb0ab9bb673ed4ed7a4f9124020e994b7dfb164fb601aa4dccdbc480b9de3d51b432a65fd9fbabb41fc5061d5bc0e62e0d2411b438736691a41a177929a58fe6b64852a7a8e8aa89742b20bce5b92d7ce278012acdcc8a6485d18c806bcf308949944dbd86cb5395d1268f328edbaf3ab70ae4218a5329a16c3d1432de7e1e09561c008ba491d487cb0b9c1bdd390208d6e7827b0006bcfdfa26b21db89200f44e974452b78d4d505f998ab6e3fe94afd428a8cd690c05a098a17a9f5c0914c02baf839ccafafac129522205a8e2edba9144b9e0dd05c5eaf5290bec556b84531b81619aa7245da1ad04d52b6235462ab3106fa7e3dc59aacd22eb2a29ff6837373c279a6e398aa3c164d6dca6af9a47660625dd92e3a1b68b7ea192396d737797c8f9364dee9e5e71043876b328d93c93fe0e9ff9756aaea2eda80c39db791053837cdb977d71a378448500967b35ff612b500df255144354f7faf8e8780eeb15eef7fa33591bbf1c9e6786b80216644951d7bbe320c27d96d97752be83f1dd88c67c2ea9e68882e044bc7df86fd702db6c8cd2bc53cb0f9688fc0eefd504ce5c5c0bf8a84f2f0914e0e69f913d250e9bd647c3922df3baf431c4e71334fc194e82673aaab5712055d62c043c513bd6216348688d8edcc9c923c879ee8905c856b633ffb915db2c2a8564035d24386b24f14946fdc9c9722476c5603911c7655426d5ac292625c8739eb01ab6453fddecffe97800cb128178f50ceaf3de2965604f142541f64dbe0d0d90af3cd2c8c87e63170c05798e6acb22d2533e34b4150bf2ac10cd2818913a7f48281568620a8b5c817b6ba9780bf2cbc427abf1e166232e1211178c93f4d6303506f15fc2882d19e811caeca4cd2f21b1651c544592f7c3619d20a806dc3f3535ec31ebc84e5df0cb068f58fdcb6a04f5a0ec68b5c92c186384c0baa538b0592b1b13d010bfc38106fb798e8d11a8b6fb1cc4215d054655dad146cd60be6dc69617892686c9e0cda36416d40726e230832f27db13255c7dad5aca66f9a4acc4b0b8c335bf1db4b8a476d58ccf57649e5e4be725fb54357bd6c60cb5c77c0ea605cd82bce6486d2fb4ba5c3fa190751242819cb1bbab4bc70fd3fcd93c64524d62fe776f372da46bfa361806e3120c6f3104eadab67a0ff477c2f5485dd85cfde19482cb4341a0583aaf3b3f24f8797552103fd2db8011fcf89da91056aec683fc950ef483653a786af5ba2196da5edc0a960acd6f8dc45eedfe6186747d0363c42d19d83c8740ddd61588fd6e11282ba2181f701def10e7f00022f75af417bf626cfc246f960f76d2a5a84de8184f15a37714513700feac5436ba7cb2b6aa80850eddb7410b077ca9bcd6e08e80f8df01c697274872dd5802d472cdf2a1416d9ea9d7824692da5d5d13633c1a82075f720cb7cba904b5747f71311f19834f87f7ec71177cc19654d1728cbca060779e9ac307232f81bf5b21c32d36ea51f9ba68026064af871ae53f3796e154a6bbb23968b041d9b4462aa286dde0836c99d9cfdd47a91c3fbe5799359b07fd7c463ad8d88c0bf0b6a0e7ab75eeda4fa3a48402d439f293d128715054f52a405b57ba1194cab84dfd18d7e990798a90078d421cd0d1dd9f47ac63b90d069136314c55b4073e727b275fae998dcac59d5ce4f914ae8a43714c34f0b9c748682886fa95ca1884063915c9c70235eac615b010573f6073995389fd58df7f8856247f584940b6fbe2d9a1d2564f9efa88da45a8653ce59bc5efabd09345b6228245be641f70ed1f3aad6fd5ac81617d554a769e0c9d2bb57a55961bbe335607416d06c78a7532bd038c63bed7b624ebd8e13489aff9ccf8f6862ac631f02276547195e56ec373815d5d3405d21a64a40c3638609496a311b09a87a3b0f40ac6d6058d273839d9b2502f65ce06e08de3da53395d2ec9896fac7580cd1d186e2ed7c260ba38a8a133d813262204160f1dd0449f343542fb372a25eb933a1323fc81f466325f6973e6da9129e6bb7f6e6d29a0cd60a34229219b6227c18463a20597bd8a6968757af6b4fe77249b0faefd91dee22c7a4aedd1104817ed7288c91bf5485d410eb6643829b9327fe3a4e60232ae50b902b7dea959e5272d8de9da8e67d183271f7744758a78b7611ce414af2aa00599b2436e710043b4192f98161b88918d087e05e0dad9b1cf74ee382cbd5d8a0e9a8abbf415ad236c173f771f731b18a540b0507f95311371c97859328690670445379d8e628dd34736d838cdcb3f2f22ac8f2d14dda4734cc0267a2cb67ee9d50b849981b9680f8e0630decb58e4a713044c251ae658715626fa0df9631e877d158b106597b99398e41ef12e5b8cd86ae1e97900f5c43eeff366aef52ce0561413bddf0db10ce33ef1f736d0e5e7f8cc0f879fc73bf9b372b3172cf0fbb551965d7720c79b4b4102155047fb9fc25cb23fd0548686361cef653fa0b3cec5c0ca0d70322e123bffc15e02b67d9adc6c951d25891d7b5ae1a3057a0a6fe516cdb8f28e49e1d6e752bd74772037b248f6fd76f361b53f7cc64e0cd9cc95bfe2a5156d88b88efd24079ff960b9709ef0d80f71a119a4f1bf8628a5fefac4dc390f40c488ef5f885c438022ce15186fe0e0d86c683036ca3d7b68bc2cdabb55e841a0d40244eed23d6df29b56b54870985c1dd804969a1550bebb9412d1d9a3cbbc722a54cd8bcd8b50588d4d702fa64ca67960b20e86ad5a574df1d09f9b0a4e8ff64cee61b586581c69128587d54a250799f2a6ab0edf6c9d0d81f4ce7a33849408e7c9fde8942abe2ef46c11c2ec2b5309f920690a96e0d222862876380551a7b9ae511f8fdb66ca64641b3f5cceac075b98d9bc4c889877681e809e595689cbd1cea7b29d178308f831d7ec72268ace62aabd807bba825c221867e5ffd097f924b1aa0517bf06b47672ffee015995def4de5de0915c761fb788fc1a821edc814e33b5361a9ff98f8016345ebcccdf8d08c6633b1498062b81e2f8680c2b0c8d64398cf51f75f137ff88801e11b55712c4fc0729cd370a5d544199a1488a206cbf199401dd771da8bca731370f50abe77a3ec0d552543dbb9043911137dcc13776804cbcbc1213ab1a87363728edad554d56f50ee902c353be6aa39006191112f93d1a2a2199a529a0a07b93f7fbdcb7839a45a03e0cbcec897320541432306a0fb7fe3874582161b97f20c3bff3d76b0248bb0fdd6a67361119dfcf2109c4c710124fc45eae6c67ac3531f09d4e30122e03780b34ab5841dd35b56ad2dfca0c1b7b72e1b88f7c71bce6b4328dee55cd785a19b56c6ced5bc4e44bac890da7e10fb931ca10d44dd15781acc7599c841574974ad8c5f55708e8f7506b9d03e1c14cb155852261ef890c11ba99f8d5721aca4d921ad3832eaaca576bca5735406c788ce6e25215449d956cc37421c320dd9084142788605c272b4833c464ff29c309521077ed91c846bb92971fa8f4a03e3643bd49f7428b22306971049d7bf3ee384cc8e57d2b6c3cfabeeedf50e5905641c0bac59c8193dee2d6b4903a42c40ab4a194ae32e48a268de76ecf9ee10f76698be4da319249273c07ca1ee9c370f3dc2a12c41041c249609a5dfbeb34119e885028807b2951aef08a2c5d83fcf771754bef1179e0c2397d925820870cf5d0462f26d4f38ec27ca6c136a87283fd9e501767ac27be731caa7f8971586e989067b4a0a0409eaacd60740faf8aa5dee6e0a438e6b95d722369d7d7bcced3ad8006f7867cf8e1df07410490876dc4a16253bbfa00ec456436f874291c79367ca07c7296023a22fe3e0aebe954ae5f7488c43ab216268fc6150a273914fcbc87ec19eabea0c1bffdb8166a2598357c700c2bd23660abcdff1af7bc4ade80969f545b457661d760f92d11048bb6205c776ddca7389a8290df0779652bdf657317988b917cd43e9e5f428c19044c30f382f29528585be31a013f4b7522e772cc06167d9bf717a6572e96fa14f6f2b7b044d07d2aa225ea593b473f3e851705dc46128f5a504f8e3c86265b14f163a1c7bb5535195778074c4c9bacac7e9eb02e03c27dce343784efa0e81f805a9393e97894f4c0eb94300df09f12ac2b1873dcd3cb3fd1f21116ca278ac50b3b65f10e62e61703c69b18e5ad6bf137b8926f90339cddeaf4e3a18f92fe1df14e8a408b6b72c0000edadfc5f4df5a33aef76ebfb1eb6aed36b16ad1827164a660176850ab7d76ea81f4f89d45f722f43817f636e3a018b3ab2553449386537643f6d5e1b1812c4bad238c9f24fab451cf16e3f40bb744268d322f6d6d0e50546ace8d27f334c5d9f73e785ebb0322bc2628124790a9ff26a3232b6f465b01e8adf604024619f9ac316cf5c48a749bc4ad461eba2d4d8ae4e11a308fafb8df27145d3853d285cffddf740e99da37d0c5f0ee0f8fa91696dc09103dc61031993dc63b71c58e0f8d7e4bca578a8ca196970cf925269dea3e9793985b44be559183521bde2390f7b09e8a2d746e844c754155383fa15dbfb916963f5a16aa938e35d31cb6b0f0ce615f7dd202b6379f62d444e6804a13afb1a2420d1991db888ad86f9b497c925a49edf1543ac1d29b8b0323de67c47a27a424425d52b276f1126e59fbec4dee2582bbf4339a5219eef90ca8836ea5c3533ec85f3a07a027d1635999c4a87901d9d5472034d7ca824c4a2e0b5e073bf7bae734ac0aebd3897903bf3fddfc666eb2fd54c6487a721b75dc4692d07b528f7b830741323e36bd363e398b25ea5b8de189122a91a087086dc00703c333ef4f77226c9d0e19846b85202f3199282d700cd13addc5d9514d7f3b2a342a7ba2afa2aa6b1e6fde5f52a9f7d3e66a1a338ce193d001df3f28d4ba6dc19af925b867bfff391ef803b6f47e5a6e4aac3e12c359fb0aaa277dafc063a24f5630228b7ebb90ca6a5e51b487c661af36cd5feaac0ed598c10c3086669cb9016b27f58be68813a409d9ec9f6be01591600406098437f78465ab3cbfcc8d4527416d41d1e5fc98e697c0a733b6b2a185ebf97bccd654771b14774660742b7a7756bc06b79eb969a1a28bd38f372ecf0d4c06e77db456e70bb555df4cd8d9b5f8b4621c96e63481df6cbd1d8c1d9c9d9bb1665fa39cbbc28fd8af212607a74a86ac9ee329f855ef8e887e7b8a6040142b37cd10be67147c8743c038fd7fee61d1c9e2d98577938a8410b890ca3d4e8f91a2b1209cb14d2b16ab60b16eef652a007e5224cb6a4b8c8978273b4dc9d0f8470c0e2f2d95b39dc129c12dbde960d5e4f6d3623d1e2350545697ca638bcae5bd0798ef90fd2f4ea97e333d2e76bf96e1b5223b7fa70094d387bffcf2b0d98d99b52399c6e50fa9b7fb7e208e11c115760e2e89619708a8c9086a54d2f836a32e8b136b80a64bc576c024d8e3f73d317837116f1b32e46d17ec5b11ce69dd9c24271758568d9cccd996bcfa4cd9364410cbb66259a20da2a2fbf5ce1995b4183a5dc25430e4c31c69e92c8032a6e20bb2d5eafb8637c33c3c77e187d914af371efcd9f040648e7af8a51934f98d9dbdcd50e01510c9aa551ace424625da1f5c743ce1da2ad29160b41a46c39bd7643680a307cb7b04fa9e8b327b436317b92b04163010be31ea39c6b7bfc30b55b945014df424acb9f12cda76889e372c510b9a4778f28fde8f5b0d8b83942542b45fce1e788e83099b6a962e301e8729b6cdd41ff413b27fe49c638860277e1440c3cc953a9fa06206d9598c677ea36159de6809c6ef2fd64fe5f27652a7ba79fcf5a944b4b23018394eb4b175b3415b0157897beafda4eee7174c91a92cc3b935905a257797d2cb41bbf7b91ab684c58afde1b420a7e416510e9070a2efc44206fa97fd2bec81448af35b0cf080133fed6cc8ca44e2d04a7aa6a1e6a223341b2f1748259f01c23ebc931c58c500ba6172b5c61e0dd3328406f1b44fb7eaf047170181d28983f0626f2792041e2efa68fe6bc7f25d6df5356e7c182e0629975709288e66c0213ca6eaa590fa2fbf0509d51bafc48cbc97e76cc546f6737c7626caceb44bd4309d816d72c5fcd2d6b29e9b32f43527e94cd8b14391e65b9d8a3cfeb20772a401fb9fb10960e2c7db848cb33e0aa1a50e364f77b4dc95e7a7b6527d185f47ee5d2a9a68a619f7af043d1875d404ddf266ecd23fcb54e64f03d516222b81cc5e64b4aa237e6e66d3c94bb7b5ec71c29790592c598001ab681c2a130e585a153be88a844a3f90353fa63a1561fd496ae16295693aab9a25e5a2a58381a19dbdee4e2e6647fc3f003b37aacfb3892094b9c0b7d0fcbdec0981b3c80a3fbd1fa91ba9efb58a4341afa1ae23100b4fed6a1bd3b2c29d4e547ed9c4a72dbd1d802ffd56ab6efbe4782c74dc061f218ff82a3748ef054dfb56061300ae63d119b9367b5535eb1221155255a716375bdeed58ca6c62b1f876ba37cef7e33c12e5da4a0ac9b8fd4052804104edfe2541bd8d7c980343857c5d32e9fbf8ea0d58c98102ba23d90d608e9770d67498e3dbba8181bdfb59463a032820b2bc5247d081131537c614d5b4966443696ed64d4f06d466dc7622956a40174626a9994e3bf2f936357f4fc620e0be9cfc89faca4f2dca189b4468c6923380b9e022a8002105b7efa0e114c645789b5c138b83e4316aefe17d8241af85dc3e5f4e2ef9f7fd692a07bb93de2d66c3839b9019b0403643f777da69ad83a1c552586f6c8da8e8ee7f6bd1e5f67876036dbc1faeb276f62b46987154c52de65cbead3121d80e29d31556a2fb51ad6c57b4bf45a7c342224e16355eb1f8ce2fd077b8869f4aa1266269bc7297fff6073882fa5b580ead71573aa6a1f666b9ff57086d335d7cac47cd02b461e3caca80938c94d524f4e7684e7c189c29757698b00c874ad27eafb10f4197766198df8422eb2fc72cb8b4778fcbf55f9bd50bc4132b75db2ab96efd5fda49c52d254312d20b894561c27b459b69abafc1dbcfa408c86715ac27dc2f54c9c6dc0dfa63edbed23eb73675fd59ffebc698ab018dc1f63a232af87d2117a1188fa59998a96b2f97db87953a88cfa26c068e510d33098119caeac5bc16488fcdff91d3eccc076c57a8e5a34f96868ce7e7b40018ae8c9ae4f57720069b0e8fa8a7bb6fa19f1a6e996f1136ccd4e0a2641f9f1c125d7ae8d6f4dfaefaf74dbc910f5a13272efb84464ac53b7e0937e725f79d1691be1b5bf83aa7a50752615a613bf302e113008c159696d061cdb9b40f0f0667453b06b1b280b00f62423bb0ae73ee38afa3fc81487bd4f6dc1545ae7486ebde2f229003196d77096556eec3c6f40b17c8e85945e9acac72fdcc56011ac02f7ffb303f1b89c6c5fce2279cf79d1f90f29b54983128375ff0447779efe4e6560732ef584abe01ba0f205f3b87b08ca0f52810d7a28f89a021bf6eb682b7b4960d840d50c03b53217af36ecdf6d984419ab00d12fa63b84818867878d248473532f4e77986716773bf2bb05138c439304ff3a1a9cb74fd76fa5ff83097e3157d0b4a56126a6f680f8b2d31893a38162c11e4d04fb4cc56f0f753f108adbcc9954ad4aee27074b954f3fee7a74b093c22ce5cd669116ee19d88064cb454fe08230d4bd05244302b3163d6873d91709b7c6dcafc62e9f174045c2331f88ed4d0c064cf3cf0456bf55a489d7c6952536e28278426022b2dd104315324d5782da4bcaa75564c161cb19fc2ca1e6cbeeb3747fca9ded72e60f709c455f338dc2490711dfbdd40a6130ba09bbd9dc7120ffc68a3008d588c90604fc269ef8b301ab183922dd3721bfd995de09a54cec73e2729d41c860e673be14170e6f6789b41b1f36556806c21607819755b2f6e838ebc1feb348f011d6d7e0bdc3c24c8ffc0e122253d6ed40cf15772f2eb29d4ad75d5e9cec810bd1087429b61679d47f5aeb9c9c0c461d109d8d5111f031a33a9dc4758dcef9ebf971c16751be2cfb2e23b24cbb353fbff2810c75cde998e12e941db9d56ade5b978e3eb853db2619d6f9d0209fe3338ea83b8d8ff332b6972b86568e05952750ee161248e984df2732f23cbf397c67ee59efc79c78f790bcac8ba9645f744b804ec3e5df70cfc6f061375cb8cfe1bf4b4b6cd9a058a70b5e1787693cdef15419c436da4ebc66722e650b49aa5dfe12b687ae35627c135b0eafae7b13c3a912b5dc351ba3b8544df657d6fece90a4e2230c14860b94ae6b945b7535dd8660f15fecc318c8f2167f9170966beac8a1daf2060928a59a4964bf31cf44b8d23c1239d26cfda915cf8a485767ca185d7d1edf4aa6c19b8c847c37eb9db25b6f9e07638e16d647be39e951ae5abc923699e96e52c512a2955c22c0bc816da466e6d7162879910e7f0bf213af68f02bc559a87545f56e0f948c96f42454c645012052baf4ebcff0688c2a28aab6ccb703d4fa03fa5c4d0db40b0c30aba3c3f500a5685404c98a0d468a730d9cd26ce0bb5b18cd4e45418b43483cedd60cf463d2fa5cd4efa0e3e9e1422a915e0b34f1a1265aaefdf61891011efbab79c918ec30b00d0144a425609a8748863c0a707038fdf7fca42acbf431dfdbd51bc9c70d4e96687e38c875bb2f4f5759220268a283ef43f5b1fe0e71357398d6a73a6eeef2bb83a218f9ede1c9d1addb4346140b8da5de5bb938fccabb1a7c878e641f73b77dc5cb18c16f18bd01ae817039db5ea1b6e561fd59f5e974dc57c5ea5eb85970216bfe531bc20319380bb73ed72e7c777f2258ced67f9bfe7b6e44097fe8fd91b987fd56a652fd8cd8e782698a2f1721ad0c70df98925bcb10cb9356d2e598db1c1a8bb7c72ff19f3972a6b51bf4030a651b4c3f83b1faca32e8ebbc3d9aa25ffcbb585ea00ce58b7a99fb351aee923f90e1a4ed3305d39b6c6a59d0a246664515d9d6fabbb10965fa096181a2c513765212875494f0d6683c0b987a4e4fc3c1962a8a1990ec5326217da67df098ed2657a0773d73bdac65374766df46f683d1c393375139c6c726c1a61d8ebf87f1c9baf1be4f80852e2843e3fa1927ffbad42059a03a80b4e991b0c8ea68332c4409b679e814766aabce998cb3ed76ad16ed9ba1c8379256c6a476df6ac65b9d9590147ec2d3e055298f72088eba97f0c285cebb679816e49c7f0101df687e87fd42d6c57acff4d213806744d6f0d3dff664f944ab7d7467fa361629580d9ac87506f92fff9e310fa0c88ebd87ec456015d5ca510834ab3edc7b0faabcb0661a817968b08428a388cb2cc6e121759a697e5f728bbe0aa65f69748d96e80150b5812b7c2530ff536c6136126289b9dfe0ee4b79f503bdf59748172f4a12133e84e45d454f30edafcba3a1b36ad395d4804abc141d0f7cf052dc13e0dd4bb36bc964a2c00e0c55c6c7a2c4a63b109a4cd4526772be49f12c0445f0e5c1c4d53a49e031dc7d58601c0e1d188ba4c6170f1f2a70535f61a4c6ee1e3ed779579ff14f860c5472903c4737249bf1ffe43faf071414b1a34238ba129aeabd5a65d3d9a455c9b4b1756b09579b534ebd5f6b4b150378792c59f6008342407f13ede7929c15024e2b24f35166c3391bfa351a2fe794bd0041e709b181a8595fa5403bd6c4636255f96ca763e050047f66ac7d3231f65eda7a792574a3461988a684a321696d1f829fe917e18f17e573365bce387141fe81784321ea0766a84e8b29d32ad6b5e6a190385891c411f969c940bc4cae43d97ff73fdcd104fd72a961aa345b290097727d0e01bb5b71d50ba70e6cf30628c552661bee9dac7d242d36a7ba93065a0d3c0f7947ade755cbf0027fa36484f578f8c40ae5044710c9c29057d28bb411aaefb6e57a9ae8baa9e796a5e0f5f628d999b5d14a716d091dde54a1764d7deee87b4e8931d57c41756760773b7d79075b5bad0b45d9285724493084ff151ba9179dc61b9133c4b61ba7845fb6f7e850e6a46823dc03597e9fdf2e97d056efecc6609f772b4a75815d6f70c895dfded83d6d1fc1bfbbbb9f99af7965d4d0b1d1e1f3f0a3acf48f5df263463310e860796f24b62d96b304142a2b26ea6d7fe3c300dc72e5e56c954f18e19f8b6d08bfbebb7eed1b7f13f825b00049be0567fbd518e2c124d6626062d7f6b43005c3c6820707622895d1b86fc7de3b0057a8b0e1d17e696e9f8b0ec5e8de4fc9402046abbd4e7e8293135a7ca6787a3003482024e381b406a04665f4f95171d272c10bfcfeb00a29bf01cf8b0e26f2c3b7bd9efda18d6ca37691a51c42c459a8a168e9fbe6997d036eaf00de7392039b9806a9a0f58651a30c213b8f5c42546dd2dc804dcaffa051dacdbcb117ed09cca876caf5790dfde3c1a1a1e03c0adf7d0f101baf201973a09f31e1e3c8971f513f5bee5dd28c74739515ff22311009b51d4a6e42034141cc2c444829e4c0fa94a5ceb5dc774773b96e71024aeea61f15b388265b93348bd581c9d74d35cbd782e6fe08fea5c71784894b54358a5dfe096d2e41c315ebb39eb7ddd5b31bf96352842f3f34e95d25d55c52615751808e0774faf655bf0f5cff2e8c5a09c8a756273f457b47740b8f2086068ade20d4419a2402806a6a16c4ea8e5dc98fbeb8e9e3ea9041bcec5c11128b0fbb2a58ea5584d93904946487d02edf524075501752c04071f8cae07b88ac9500452a29629ce645e8da4de6c8ceae9ed353470e772b5070adcecd4e392d5b5fc75d98ac2ba48969a971dd40a81bff4b5b65e1e0d39a0f331a2dd4b8ba3ff1de2927bd39e7d260fda3294a5ebe25786aab873548318476451325bdc0ec3e4b1c65854baf4125e4b82b3ca38eccdd471bdb87a3117e6772e8f647b25a484e46370ac9888de08d2f05cf4ff894b56baaad2a8099b6ad199f12abe1ca29934809b344cfc9a322da1b5fafcb557ddf4056d6d55b711c9d51238c85bc0ed8fe52b9ce76bf9ec9cde5d62a1badccb8df9fdbe8b00a426b45e446a02a19218d82700cf4ef74f04dac1aeb18320bd159fbe0b9fcff859eefa352632854da3819f8ee26f66a24ebcd1f02dc57c625eb554d69538fdbd3c120416d8b65e373170152de559ff4cfe41d147c696b49a1c8b23eebf1e381040d9ca285740457bd9ac86cb60d684b99131d5a38137e6a7012c82324cef478f44a264d359c9cf9c9b90ebc51c1540a0ae4bbae732f9ccfd282cf07a259caf15ef4d84cb1659efaf27baa4044909b879214dd6a3ad3d0db21a161c64fc15a602e81a396e6d7b39d481c3b87e98b2c2374a5ae6fae43e86be7c98ab5e54a4c49ae93df4dea46e1c5391a95e1e1832527e36901e01814f249d55d098f65872e249637e00987f623c5cc31c9e9962aa031bed797547b1e26b90e7d97a9366f174950a0d3456fb8ddce215eb966beebbc0f610e3c870655a6af62408e66b89cce374f1b5e0bb2a1f731ad498743a09635c18289a73001acbdeec12e22e6489966bac1fe0da14dc61eb1f16449b7ef0d116c2cbfbd2ee16cf65ddeac9480775ed89a13b784adbad66a2c5198490515dfea6260726038889e7a627e22d05e189f24248b55e0c8754d8463ec767de75ebf9a7391803b7195abfaa3c358e26245a2f82cb807754425eb3c33412bd0ea3fbed49a67031a546bd156f7a99a0971b02178d101850626e016ad657a26d54d3f0dc0da49ec5a9508679c5ef0e4089b8ec76a3a5d570b77853f3f5fcf27af7ba621c7a85d903babca690983a3ecf3daaa3bc03861264daa8d3416b5f90c3c2ad33f3ce67f0945e1efa233eb2b1f18fc47e8748d97250698a748da2fa40d0755023bc136b28e4f3878c6ed384658b97e1f17394fb8b55c1da4d1b6c9d1b46e188b6cbef0ff671f109713c66250bb03fa805efe386337391468d03bf08b5de68dfdc5634695c0310bf7cc02bb9e6ace63461e72a5c21b43df6477bf7f4e951f314d2e50ecaa8e74b74913b089ab4a9ef24ab934d76d146fc2f162a4570ea742fbdefa3d26d301b77c5ef594b6a91814161d1419843aceb05c561357a6a3c1e3fe025cee166fc870eb22c8db99d3c985ca246641c962d2b6bd40beda5791babc327ca7c4728c8bd65c492a084efd8dba88c84126d25665d535b3e9f70a3df97a31705bc5cf644360bf824b071533ffbf0495bd39bdd590f706513cab3a8b9ae9077bf679da8f195a434837ee902f08de6c9fe70200bd288d27777903d2bdc0fdcf55dcdeef2fdecd8e0ff55cd561ed3d6e558ba61f61fe7afd140f85f0608f3ff3a930775c6c8df8aa03d3cf983ea88b1a4da83bf9432831016f1940f6fdf9df35c38e19a837c272e3f8ead7ef887340129e5e2af888520b892e8be08c73a799fb517f282b61f98962cb35ab17c3da8553251e6bf78ad7ab0cc9e0cd415ecc8dc46ef20b6d5097b1ee7dd184a483cc74c7535d109a909c422a63eae44418a4b23c6971b7df3048c7a40224eaf4ffb9650a3a7e491dba234f2a7c2e3c9d25f454e3fffe1a0af3f24fe63f16021ca969cb08e806e96606b780f892d8e603769d25436d44bc7ce4d3ffe729af5980fb315564d753eeb915dbe999b1b4b780d4246e5dfb850ddd6c9e3b037ed0669d4b4ae3e7aaef2c299647c5bb74570d980ed3a526e669bd5e53502987501aa3eb70b1689d5b4adb6349d633b8553ab4616e782267289261c9b85cc6dea47dbc0bdf589adcf0e8e23b538c976be2a8e53888056989ab378d0e9c7e7656a41546e4823a7ee115160f755798d3431f4241eddf57e1d09df27c0a2b114032d4617fd39b127cdc1899f9b928ab939428e54d8c66de46313b170915c57b1b74cae5d44be345b0e6f22a54c7059e27ab316a25af729d3775d2c59db37fadd448ca47e76adb7ed6cfb9fda4dcb61f62a324e9bba89f77d585c738a72cbc5c24999dd94707b4274f81797536706c3fdcbdd185581cab796034307ad1d9888ce382a31ad6c740652943f9287cdabc13c0045d1353cb07bb4f1ea8a8335db3cd2dee9d02e98d986be285fb90fc37ff837dfca89dec90e90279bc3a1e12a82d7dfb27add2716753801f8627d8d64d0c6a99d3e01f97771149e73c49a482f35a6d305caa6fbef6e26f2e6e7db2d6ca4257993c7402194e02d14d2a2696c80b6cd0d83a6f60f8d0bc8974cf32b7688f038d2e650dc400b8c69e6ff717cdb0790eb3cddb486d782cd5df08a512dcc900688afa5487d0dcfe2e90777274cfc54506ad162840ce5cb60a0a3eaa8c7b24a1b1d178cb1a80c9d94fd647a5c9395bc71af9a116173ec6a4bee87a3a4675934e793fcd28886971f01f32acc417edf6dbc80eb25e8fa35b8b7cea46cc87bbb70a48e0cfc41297f4350e90043284338f2bed9b171ce9d6e19b3ee706033c851c74912a19830ced982de5d8cc01b315bb6a084bbfe28f0bea859b391872b79524df2529bb49affe148d289f6cf0c01258f4837cf6270f6f0accd988377571bc8cb8facc3614c5dd4a128a0a4af6a510bb048858dd705e7cbb641306ba86cfdf0bbfd22608581ffd76c6b49dbcae1d1258ffb3965becb78c15171fb0e70775344d4d223e598352a9afaf769e010c3df327bd33475c10414cda552e0a46fd666b261d734d2eaaaaa77cff7102e620ba3e33cfe532bde5c819838436a3ff69035221fb334ceb875d47d35b4b295d46d30ab9c5ee2cd5bcf476a8f30bd65db2cbf5a5a79981f4031550a0c7d63dbf847757ab4f473e0a6fa6369cff75624eced0dacfd03c22f94d660c30e971137c736c767a785671e7f1230817c65a368221ab21e41bd5df48bd05f08d5a6a665116e0e62660d7c02e8ca2bc817e4c1f9ffcb73364b9bebd19e9c47ae28c12f51b41335e8fa0d8d00a82366f13aacb6fc5f503750f9e6c6243dde2c627cb2e8230670a5a98cb1aaf7bb8feeb20b61b731d8793a09a7bcc8b73155f88f1600a8223cb6b1e4ffe28e9fb6f4b7175cde08d6d8ff74fbb55604f8419e57fdb34c18e64bf4144aa9238a97370eb5ea4ba1a5f061b74fb4f3e041d4124025f9803384318f9bf594eccdb2fc7345c888e677f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
