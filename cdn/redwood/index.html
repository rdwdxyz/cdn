<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8d2d51fae5d0fce31db7d7e2ffbbbdbe68a8bd8d55c736880db2a38ece3e8e5a56c4f7c8fb7d1747632f84e93da8d5266c43f4141de3f7bfe4ec1c3dc5072f5382bd3fbaec37dfdc2b13c7290e7f8001f82167a027acddb465fb9731f12de7db5e32227141eb6a9e465d04f195716c1dad958de219a35bf8321fdfbfc16a7954c1549af2aef2c7359f5d21d7fb69a3e1ceb846c4bbc0e785efbc1e40be6d39ffe31264b2021c26a3bbee7c2e1d36730e71d53e207174197bfc2d984b5d2f886dc6d96d12c9dbbe1d7a5cd6491643543ff19744b2f529823a9fb369dc3554fa5515201b89ae5d4f6e1d541f60ba3d4cf6f0cea9406f09065e3e23ec6deb9923a2699b79d56508ee34da9b0b28cbd7027d5732097b79b9a6569936f49e4d597f2f949ee6dbfeaba44dee5a7d75ddd16dff09bc6e619fc77dd496ae8963e170e456658b53fbae90187032170898090e2d56f60c284d2fb9b259a6fbf7203c3320e918b4cb385d22e3cc66f1d3d6702c5164ab73d135689f3c6318a466b97c995977ac9497d1fcd57adc548ce98fed6d808502d4f865adfbcda12d383d7d5414553c30f4d8d4660f723b50ab7f8573a2e9bd1cac156e8ab7075b5370ea3acb6809fa5ffa2aa92ed78424258dd25786696d92453648f5d3075597daf3c38e129a553b3b6f104f32a52b2a6218d7f0e69bfe0cccd649cc47daf2a5744723da5a1fe10dacb2e8dc87fc821a58b2b42a06c549db4bc8cf9aefa689688909ebe597b63b336117637867e96392620f7bf5f0defbf4ad594a5d6903a2ae29c89845456a37be5c83cd6f8d9a2c26401b6254ef9c22b844cbdb8406387fb8b041432ffd7277d23e3ffd18b827ee05d0da18e5acea571515a6de6284ed54941ee49507e2812a76a4914154981743330ed55a0da7483760e211614078b6a5e52251e840d4737070a3ff1b042ca2266b65a1f91d4e12f90d2f81cf8c9f5efea78052c598161d76803211e8c6c0124da236cfb90e5ab955dddbfd545d5949f8f68b1f7f7906bb0cc26714de7b2cfd35b7d7f29b63f9d20be6cf1f05c2c59b4f1cec2495009371b75c07b41af3467cd44af7eb7bcb3929a6dd5d8e68a374c3ae917df51a02d6a4dd7342db0c01dcf00359a339ee296da5beac3e3c956f2d0ffec5905abe285c61960ef829f6497fee01ab56dadd60279e872d7c7ed57c0ac2a7e7330e90cf14965324924fa5b8ea23f2c6e4c8575402db7a16b275dcdce9461dc5c6523a72b229b381ce2865d57fccc4cc8a354789f6fb7c072958f5baac58313adf7c1eb51594e4768a0d4a25d90fc0e5ecfb6096c3b216be0c30a421be069df442c2fc0f607f627c5a20c2ed3d477b5683c328ee708aba6b9fdcf9b46aba790b10316ee99371c70666f01784ac61abacd3cb0567132217e19172f1f1ff0c34f6250ebe9fdad473bb235c5ad06cba4c7453ab6c07742bce8e281ffad5fa60ec05230ad113d39c33cbc17c23a79bc21a3ca04e0b1c2bead29ae9ca7f53db439b72f410b0c3709ded133eef65d67d9ee0b564844b432c8839e9ec75aafd66a4d73bea21051f4b0a8a48d946b036b2e23613dee750df53d2d94a515c7320720ec4e5d3a5549dd20dfa23f277f584d714188afc7543e685bc90dc57f194ac3e787ee54e8d92056cb93f1ddbf8c64a2df0ee42b31b05c0293508d18e61200fd70c2482574e9584f29f5d7eee6fa73e3ee36c93cbf45723c8ff72e00d7f42fa988fc1425b5b5e40839d223fe69f3f8c37722571640f498ccc7b37dd05a3aa3c9c783e09ca5a1b2214a195a8e8ae572cc9d5619a4ef13dbdc956d8bdef9f965949921042515e540916ef3b367e52265e3525717badefa9592d3eb6521bc5f9994fd696699410e9039c44eb39bd0270b671582f6caef4f14c2e81e3dfc0caebd8c5fab306dadff5f26524d610cdffaf9b3b2082ad91fea587c409e18be5fdad8e5bf0a56eb78d0959b3fd3e97712cde5c8125da821fa81cfe4cc45fdbf277ec9990e3166be133bca310561353926a591f53f8fc4bf57a8125750a7674f9df3d6efc03fd8de4008e748761157aee4ec5cdb8c62aa72903ef361ee4f34b11c506e08047972995c6c11a491b0aad895bb5cf0cd0fbd01bfc82907833991a7a39f0f3c62df445d786e7643945ec1eacb0ae14d7a52c0446a0d1c3bb8f038c0a68a0fd2b096522b079c6bd5ac2d51dc87b3fe7581de81200c2137a8018ec47cc5d6f4def63e8246f7bece4f81d34a119ade8a81d85ff6dc9af79e52b679bdcc65db5eff1e65c9f756d78a726625a9ba670ffbe0cec77ca94c02d0e0453553b810415aa60de7c257850c130785c7e3ea4d680a3dcf1d1daef1b527bce9be8dc140f516a6b180491e13153014ac524d60f527e9f45cee1627033304c1eabf1d8680e5fa6dd278e308016484cf30c5d15db2c9072ba6d3c1b7902e6d3d85b1f1dc107726541ee015848c71821e163554535a655e7a710c1cab869374f710b74243da7646906abf6ff9903fa9b7f1a11270f45e5bd03511b3d2db9b0078925ff8472b691468747e0f25a9b35964a07bef5543e5efcbecb2d676150aa5d2127e1d11e305a09d1d5d5a96ddad3bab3b426777127aa6c1e6ab63755f77716c2f87ffc15e519a27fcc55abd273307ceda1b9a8effff6880c8485ba9230c40e21d874476b34f6436518db423555d795316d2687274c9d76acbaa744242ddc475e17748b35d7a530bedc3346679f3c42802430d960d922468a5665251a535d148a8b76f94f7990e8ac6d01bd925275a704325bc7fa966b633ef82d04ecd95da838265ab2db5c235e3f73c246fc01448632a973f160be0a07c7d0f59272dbc0712e5c28a6c88724cd43c09199f4532300aa3c77b90a48dcc46ab3a527702c896c9bee68be9b3debbf391561feb5836f03ba6d6d226613c39161a6a233aec36f067cb0473048c10bf61a20a5159d83cc27e360af0ace87b693e9cac203515cc4151ef06e36c6ebf30d32229e725eaf498983049baef6727dcd8544c284dd2ac0cafee2288489ca8963318fef8e383a4f22b0be4243cf3d86d95be15f02928b4ff23163eb15af8a1d8bc3b2a4f992421f3c9c59b88a903f91ab3d767b1aa4eace8b71413e653c3f234653e9e5ada47c573fb40f524066c344f69e0d2eb04ecdba301e349118a9e41c8591c6f0b5f3674ed375e837d37e315e186cde75167510f2f940980ad61fc2601f105e37694894c44a206318be7a10a07a1954e2bb37016f6e7fb12d05a865627808ff1c17f524aca571d1f8d373dc79b4d5c6b879de2f34a7f6e588ebd0547eb0489d4381099ab0f15274eaa70db777159b4b3a294bc025e536237a5e07abd9d43d7ce5c1e44c772ccf67c933d88d8d4eb4f7a61671956792339905238ee955bc08814a6a3205e177fe54da363fba916638d15c1a0c918197c369385d63a64c076bf3a9539d27412647923d289d310cb29caa63419dc6af589994a11f76463359184b82669fdac649fb04ebee40c4edc4d181f6364148ae88812bce2605de68a95eaaa3e7660d7355175c341668d4531db3d8eb35bb386805579bde56cd3c3195d92b06e51ffbddceaa9bb56b4c7fbff6f83d20a7d6ac389a174f095d7822b7d850847ea35522e7987e717d68d13d6095b2771ae8e941d0e8e910a2d35c5ab33f37b8b0b3663fab194519530aecaeffd3ea2ac880c43a96e754abac1982ebb19d7202424788bdca4edf9d46426d2dc22154278e451631f36793aa61b1460ac25854e30dcbcf268fdd85d84e0ed42d75fac3594359f4ad0f43d316e3d938523b538420e938db32cf2cc748b58294ec479bcccd460f9d8666270aaca606528bd40c370ad833ae5b1e3f7bbba3ee0510a4428b8d5d1edfe49ff503969e68829ab403d854048340848ecdf63471a4b3a5f3df896369e59e6fd511adbf906f32411615a001f7c722fda0dd86e3b9b3c480fd4b3b37389cc3edc92dc0722e27f0471438321795dd4c0c9caae384b636c475b4fe2e5cbb077c8ac7f2a9d53489a4e86d931249930520ae9ebcd18ed96f9bbe11cc35f3e6edcd9934d16fd533cf2396c72ddbed666acb5f138052bc6449fd39acaca57b22d017772459132fb0dfb4265beb1a9cbdb71c9dbb2b2aed8185a85c1467efd8261a029191cd9667d60da82c346b7088b88b076abfa5256d7333cdd716269f49af3c56e8c3d3771ee720f1ba89a76a4ef08fe287638755dfb8db62da828365b9171c66efc3fb48b921d124c176e6ec84f4ba5fe49fc7c79d7201c1d72fb4f08972c3b39982040529d3393cd98ec629b9a05d01baf79c6599225f3dd3fd804811cdcb54ce0568ca4ed05d98beee4b7b24c62615d33205910f2b3abd2c19429e39be70686882560f6902478fef4f6edb392ac78cfc75023ed4eccb79a10dbc015e3ffd9d6fc6ddbdbc65a1bad4488cb2c7e0c24095a8c6d12ff2a03840f1cd1767f319c594521d707950ae0d793d1eb9cecb6a07d67d18197040bb336b49c68f2f51a694bf69f42b567e4380134cbeb2b3ed8931d3651c36e5914b8a94138a6b4d6be8f94c67e207b157aa01b278fb9c4193a495a9c251618633b5b026519309ec902dcd9b9bee020b8235e0872e49a6cd16dee6f010fd9147ffc4a013b8cbe07dfa4536d989dd5debe0abce069fd7ab048eeef793304f9f9cf681b5b3f596f38fd839da7106635e185c2620769a073aa9fc33f161eaf14c29846dbbfc3d20d144b40be1b6bc31b911e3726354aa6ca4e396cc11a26e2b59b9ca8ab8f234c604eec426e05e04b33bdcde9d6939bd7b49a98bffcc482265dbb71ef1ff5de6cf57fcdb7bab856da979c65cfd7d570c4416ce182057c4f332a1ea81381d864a5ef13bf3dd7a12db5c5cfba5b9f406727f78b120bac1f829ab6d97f98e293e6ff587b484822de4a22c7ebc933d4277bbb8321fdf345e5a889e910cf3927402461d688566527ada50db0e04408cefa10d47dc5311b1a56449dc8af3aeabda7e8ccbc2a622539dc083e918a104ef51b735e9b9f619f217799af792b4721e87bad23e98dde74c4e7c92a1073fc9ed56fc88f5fdb50e4eddbe12671aa16142a37657f19dcf34ea10211d90c61606578764250677491d4044ad0df99dc9aab296afdbef5c396d5850f23261089d2eeeb1beca2488a4ae43df561e6549dfd3917fd5e2bc14b35493487afdee18c6959e7c4ebef3102cc6b578e4eadf70a9c8a97a1f96f65c0163498cbd46e4122eb3876a13be5a4460c80c31c01ab9258fae0b496ef42229024099308696cd5df965ede3ef3407b28325832f3fc83de7b76eeb2e88b0efffb4512815da2d9f30c06d4df5d14c067a21db5aed6058679e98298f746e149aa44a0e864caa44793d9861bc8bdc65df366465cbedf4236b50ca909f1b63181aa359f1f7c900f1207218ef7d3a885b8c64847e74c5ed5f494be083cea57fbed2cd31dac3ffc629a72763fcddc7dfbfde53087b5f5d140ea8fbfbf7909ce013738671af3c24b1420cd14c77f7bb8433865b3ccd818edf12c0b7a3f0985ba0f1224db4e40d4731184d3466fbe21e3f4daa190522a81a4b3d83218c699e43720ec9b456bdcc2e09b6ae9b081820c3c7cd52230d75e6adfee1aea7a311dcf788beb20507026cdfc3a3bdb4c0a60e31a2121013a729fc3f8dfd1ad59a66db27b1179441af59b8d6323d4c7f9436e35eca6789558cf636802af0656845789378ac2c181a934549dc8c675d008813691d2b36c5a24e172fca1903b372361d2b48e50b87904172a1b566cf7c24d3eb586ec2524910ab1a8d83137ed209e17f091157d33a97d1972967c9607fdf3266784466bd5c4b875b6e0b9f81e0c869f5f145eb43e9c77ad09940357a973c9dae045fb786919e6a25f1ae88568a90c0ac2670766a3944736a45c2bb9dfdd7f0cfd905fb471f7de5584619886161432ea07a2219bf9f7c536fb1ad4a769615a3fc4db854665e0b2db45afdd25ac8e59803f45814c8f9683fd36e78076d5a9ced563d7cc84ff2ba71b8dcf208d69943b65017bff1d238b1c6c3eb4effc35afc86a0502905cae680967f8bcd0dd387e9f3224bcc0a9b31b93224cbc60e3a39825b29af74f4182f14cebd2b8dddf81896647535ecd6c936c221a2eb8949b21d196692d2584618559beacf3852edf2e51f9cb07f97de13e5f64bed3a2409b95f1179797c33171682d186931f4f8e775ba37bec34f61c04dfe16be0ade533b14a1469494f09c49d8c8967377579b183fc77c9422d9ca04dc4d3552037825c7ce4a42cc0562e6392cc6114157e9b99f47e57b759b26981b3783617be7aa37fd80640c13caa047e1e4f4eb46e679c9fdfb4a14696f5bd770d1c22ac20c616bf07a1f90cf4cccc9427aa82225a328040fffb23c88139d36790cb070a2634cbbd177867f9d6f5a31e657f6ca880e98457f9ea624ef68ad39d812ba86ce221d999182b01abb83d2b8aee05ab85faf648249289b0145d9d7047fee5b09e7d4dd61afa159fcd82ca9238eb2d14e3a41842eb55f206dee50809cdfadecc4887f7d9393817a8face2ba25d8b99e57786fc1899e617343c190d26829ef030be092f515b4a1d59eab3d6203f652ed9385d91505758dd9013ecbf6bb3899190ae8731ebfca51ce6454517b37e0a18a0fd81f9fde13f10ea681af70bbf8e28d11b16b6d4fa8ecb050f7a5f0f541b97502b269a441d8446ecf59fe7ab34f04e916bd6ef9ea2287f5692a8fee9d6ab39850c3d2f6812d2de232c8d4a80c1b00dda4a8f0c4c78e97feb2d453e97976cb433900741b2b135efb2015f88297a638ac20aa1564683b70d8c16736196747220dc6cde674ddd8a229e20c1c44dcf04d76832ab7c1d0fd2ebec19534ac7bab6524da57ab0c2f6aed3d3aa4bfd0c0e1abadd9723f006d5f9508caadc03c38521c395a4ded7219d542850910c15c5d0a09ebf701b876f280302bccff6f874881c9a609e1cd5cbaf2488e2a7925b435f0ccccfb9d8604ac7bb50c94a107f2bc17b59e0192ee881714f4ee1eb0790757a9246c2e5cde41afd1277da2e09e10a6965016cd9e91083dd35e4d5949f35d8471fb2d4503cc9ccd06a7c74ff84130ce904038e242fd58f852e0b76c3bebff1710868cd86a199472e4b6d5830eb332a536ec6c9b7515c89e6aaedaacbe003b37ff4581ab9534ffaf3d3cea10b34b6ee7fc30f7b7bfa3a8e09c4e0daa39b01c4d2b80a71497ad06dd322c5b9682b69d94fbe53ab6b3f01cf86b46b7da9ee9435a3424aab91f9ad64880be9bdc440c4f4a4c8eb58385498ed4aefbe919868f41acf0bf82f19e791311be51a740a06c69cac7b72ca4b32e5c336ffa2083647c7695302af7070b51f180e2eaf0d2e6e7b8900b4ce01f11a46bbdae3f7f0d7f550e6e0c794ce757157722f7643457836936b8ae98a5cf454b44ddb1546776d50c3908785c091859619b06713ff8e84f449e9206f460e5ec4a65d63177c0726633ebe711b0f78f96a8bed913f2a772a90a1b566c1d8fb8e764078dbc7a9f0323094bdbd5829fca70474e93e70e5785b8f3609f8e3749f1cfdd12ef62ccfa3841fd4057a4d6735b7d82fe7952ea66f52e74864fe89622296be1316e13a7f9aff1ee943fad48e6413f33e012d20d8556a2b0ad96c211832d5518ff9979094ed0d970c1d05465a954f0a9f7aed8a46f3537bead1f5cd18a96f914f2aa5fa21205ee5a9d1855f3fa3965580d2839e0464a705a9e975ef5486240b8d3c683279b45580741bd16114aa519611aabd9fcf8e6b73fea6b385589985ad27f46d62e17c49b6d5acd23f8aa0018d6490b81f9e238c972d701803934d00df974033285abd0573ffa951b614de6afff3942e948e2e98d31718ab1225c8feab52399d3ab5022899752947ea2ad935b95c5b1d7b0785102ba9a262d1508a05d3ba581ca70c5daeb754b8c1ca43adfbb737456feed81e162e1e12c68ba5ab549b50427b920d8eda242c645b69fb8d633ceabcf8a08157183a47c4a4e0de8aa732a5607a07c357d3064469dbea34b449fd264731e0c196e0eca17fb8eecf35242ad333e725c684bec545d6d1fd81e516ca6be2d37f9083bfeded4872d11cbdd92374d050c2caac01972b4bbc50a50a55365f7f4373606d7bcf8f4c5cd3fd85f3cb58f04e46abc8f14c2abb7c1e74821f11cbc0de0a6738b6fe92edc934d6a3760eb47f375944cd2870c98a2b5e9df10ae27b4ff2170a4d167545113570831c5daf56f42d9801520194b6bcb0d6fbc30d9c1981a28bc5aad6559a33378d8756e508125a7c1134e6b3ea7ab911f494a7e66f386bab96b78289a9fb6bab740d9a8c2cc30d271a17bd793800eac1824a5d51fa231a1105bd6e75b078e68e7736f29494b22a52767022dc113334bef5d8c4f45889251231959e776dc56dd78ea97a751c5289459e1432b22dbebc26c01d1fb8332cf28ec5560b0093cf051993ad03e450e605072328b2deed2037ac13f8aac66ea42b97c885a1afa954e35acfcba0c64d7554c9e88e59cc33bb8251f70d38680401bfa8de76def4cd71bf2246e28b30c00661541d92ba7f4c9d2c20d8a31f9bfcf980b9a25add291ec32227e62668513f0a6dd41c16080877a66d07e61ffe6e253c377b29a0212e64386fb8df4af4975ec1716b4587e9addf5be6e278b94c8ed96696a22df0190669b0c5a2fc8290360423d4f4a7d59c1b0ffca976a129fed0caec786561e9115048c5110264025cfbd5ec24c549c083efa89bba782f61f8e8de5cc48ff6a7bdd23a70d4bf501bc48e2ff3964901dd57c135439a9d1208894e699eec596c093312e4bc2fbc594c709c6c41ff7895a4c2727d015409a530c99f8ca8bfd7ed6c650ecb5a1bfc04b9760ea3ed9cbdccc321675ff344f345af59eeacafb851537255d1fb22cfc9b6822da05faf7c4353246fa662d541d7f9346fa7a78208e10d8f7fc1a0e853e2262e84ad03c6641dfbbb7f0015d1249a1a3dbb4eeed72ed9cd4281edae0e38e3aa869ce5a8af6c3aba041c95a470cdff8d3c8b73bc741ba4884e6ba7ed0074fcb7969b0bab8f711101ab62b5ca4e491da13a401a98ad701adcddc686f628a21fad60797c91092cc36970b16a6cfde51187ec88c9046314bbdb452e8abc7542fa468c1b7c5523fe3dc30a263c0b959912d8a21beda93810b67efa274abdd968a17f56989f21a10a7e6273199c4be10aa21b3dc907aa1ed96ecfd96183c8b517df0af7360f95364da56e0fdc166c5d33d0c3e9782dc1a8c51a64ea48b619717201f535aa8edb34bf26878e6e98ea0150d2402d4bd52b86f8ce60786684720ab5cdf335f5b680f39fa7006786fe2bb233c6fcf72f3476bc054d3826845c1d75c8d841321460b53d65094c890806ee6ccf19f41611b1562dcb4c274de894ab027af7d0807a53014ef32e3896fa41155c960f4927a17bb1aaf4a187013983d1182225e01ddb0ef7504af90e1734d0393a258457b9da176826a916cafc1d0c4121f5e1838af0743262abfa7aa5ae3b9a11ba1d1d81cc3baa8267021c0d83327e1fff55750fdab76000a4f7b7368a80cea960d92d135d1bb1017d75cc75c17f46b18128bcce7b77196e09ec3a8afd77ed4588da7164a27c525296f53fb2bae09b2efe19d5d5a60f73f766889538f3651ee16983d3c6930b2054dc1f4f3c5d7c2e72fbaf58bf016717467f1380bb26683fecf03ccd2ab49cd5c785c56ca8739e5ecc3b9db7c30b2c1b8f690463116de49eac8714fe3d477786a3d2f74b1c72a1e9ae542873b4b7fa204e97d3a5ed2907d48918051b92eec8b7f66a7455fc4856146169f324f78a5cfbbdb80882bf9e2a56af60d05c8c7d6a8e2c8f01acd1962ac9de35c65df69eeb046b1dd22a5fdc7cc89be838c3df6232cbf43ce30a8cab3629cf1ad12719983ca6806586bd1474999801de81f6c4cd95945b93a8bdcedd22fcb42202141282cd60ad8851b6901785aa489d53113bc0034ecaae90e7550220366ea258f3f05c7f088d808f5b5871f553f48a86bdc963692a66e34d82a48a719e3f101a5dd9e1e27f7372eec64bfd2d3fdacf80dc493513a287fbc7a6c4cbb82e98054aca4df904c483a74f1de87a948d5947a587dc17181e28cc057da452eb746e627d0c1007fa6ee736ebbe9990075925f648b1efaed41c19b7a384d308a3c43dd0f98372ea76bd5d0952e9f17dc0a7eda46fd574b2fe2291abbce1c158e69bf8b89bc230bf3e397f756816dc3d986f4b9a1aba78bf7257fb09c327e0a385c70a9ca98f584818dc84ca98ce18320aef4f9d16613ccffb42a83146d7c25a3f03fea1140a14ed76d741352996d9eb256a7f6a4d222ad19b3d8b611afeb8e5262f9d6e7ea269cb0cb7780c87b4c96aed4617b6539226fe1ff264f9a9302ca31045dde869455bcec85ce4ae8486384d2274e316b4bf274c5411a1eed0897c917fcc8ba9fb6cee69f890539bc7297a6be4ceb6963b6b110beaf702b56861f0aed5b26fbf42cf8cc4150c597b633077ccef101f3c1624f84836305f86d1e34e9c035d807e396fcb7cd915f8a082dbf3fabd0369befe50f15de681ea66a3895147fbf242a8a379d108ca65b35e550df195232c200ccb1478591e9a40e74a47125b5114e43cabd315194b4b204536a77e2ab4013a2c2478305e681c0a99b61a581770369e444d8217e714cfdc2025f50e0e0866bd22f71444429654f54b60190a4ad5b8b0af86cd65fc6c1ffff13d6ddadf966090398319266b3d3a6ab168d4c9cd43aaab35284504219f44dd2ae140926b9261359aa9f24c43fe88a786eda02a93fc0bbcd8cd30086906c2d8a53b2431efffc64d95ffc4f47bdb3ca0b1ce37199f87773a5060da21d59ecdd1330d22a57a567c49a9487863aa1fa320e5218ba86abc30ddc4b1ff2d11fccf8f97e7d3345172582d0c40123e866ac27db429da4f3ec48de5f8fb7a7018fd62a417fe8013afc140cb46a35578e9419b3694e6049e169e5927b693bc3639f111b62240dea29cf7de86970708c77518c7188a9c98fee3b497610640726498f1a9af270cbe97f4b00104093c1e92899d9570dd1da80368795728f0c7b790cde3267b9aa1ec3996f2b1a48f0e5b0a0f62bc245e1784317d7d64c7c02f0fa25aa0fecd367df3c605fb9f19f57ac760c4bcc5276369b9bdc387237cc76db34a6b9a22d18cbec1844eb11d3060c2cf6f155c2289199aa8f7249a1e1c0f5090ed886b5cff0b6ef8f2f0b4d3b5d09c53c363a65115f98c5e8132cf715b2df2e6600d1bc1c32a767de5fc3a2623859cdd9c9137c8ecc32111ee27d73395e8280021e8f9f7bcaa17113931e4364df12e2797305a4cbc2f6e8e85c1b00f940aa17016f4f60dee082bdbb7f2a8a94a4fddd2455c8c3133c4cd4784ec3655912eeb2a19d9aceead19f7a2a020e5293c1ced39fba5d379eed345884381fe3d8359ea0ad8fb0d4433e4782bcd52daec3278aeb90ca6230c6ecbe542ea6b3e16a0f6a45dd754e74ada35c2b215600e81f03d66e0242e83c64f2791d110dc4cb554a0ec002d0b734c7abe6c6f039453e7fd9dd50ff8b3ead48dcbf44929e766aef9466cc87bcf8e145ff45a33d29016a89ea24066851826b95401535374f8c99c473f447185551e711cbc464db939d34d2eb8d73775ad193d065ddb3743e4e091c85db8103f8b83df8d869141787d10d1156f9f322e26e09428c82ae28535b88cdce333774b263465a927fc0cff41f8a13684b092c285f82df5f7a77647ae704ceae2b769b33fdf20583a84c5d13dd751f77ea5916ebe4b20ccf721fa26e31e8d247ae8cbf35549cc70e2975c10a83037e9b5d219204b7a78650deb406f5b367980dd7cae90654ce11606c6b60777a9a5170710cc3a87d18b40ccb848bc68e7df68b8b29de19343530be2cfd89935e286614d8fc0f87fa8d9baeb45c998b86bf01a2f13c364854b45040f87059576de8966700275e1fc19055227f22272aa6c7a3e2ec09767ed84b1ec0ccb9e489b1bb07e0562519bc9990b8fe3e9dc298682eb85ff58306d0562cb38ce7adf6735f15746e763eb77019eb97a33bf4b4fbfb761c6b0fcbf6ae9f52b6264ad4505c5d6c509c67cfbc13c99c288dca90abc06be5ad27bd2c61c651d37d434a77ca42f7c2dd80232755f2aadd8fc3a962698c7cfa86123d96f4c3d9ad5a0b3619a89b452df22de96e8828c5fabb0d3465f1b8a28f7dae37aa47ccff19783466c7a8a978f635d98ad9e18fd5ff946a8e70c9daa5bfafd70955d4d7036a4be6286af3738c5368f96e6f2e102c9b0a014e9c0751839562a4c712166974b864d57ac1598ba0b41fd69912daf2bfb0247402c8f9415708d3600c8da37b7ab5d34feba3a52b1a6c0306f84c4990dd2d36f1f31435b71c4019dda33805337b8f4b4b6c5cdc77774ba24ad95fe39f9ec0189f8fd8cc3b087447f9a761d51896834a9293af6acbedc6bbc3a4dd11f9c9ccf8e327b8ecf4a954657b02b0a3ab188b4a3d2c32649b39ec45b541ebc972eedcd29e8fbf41cb7e38d3e55b3e0958e65c29ce5ab72dd9e3b97be3c7a3b5266510926241807ca3b9d3e7968c47c86dc9af03f014a14a9a460ac6fb5c46bf188a9da517688c8945e5432a9b4a25f4806f79eccf9057e4550c1d68a2e2ef8a6e96d93801dec077f85a62e5753ae457f428ec650a7cfe55fb0c301efff942d53af7f2dc8b3fda7039bf8e74faaa2509f0da398c035b2b20eb2e3137d68e2040fac52e736d962376dd5e569a0725a6536f97580819e6b18812e50d669ab015ef772abc83bcf353647168323c8078469374278743ab71bb136b060c72b48a965fd5988e4ea5f39cbb3629b62df4699b6055bae66a658fbc1c75889eac636e37e6002614bae40a7ef1f8441831a95f417fddef7ee84f45315f589b0e99b43aba26b64116639499b91f0a0c84d3f01221518cdd355fbb968351f9944ae72776de26fb53779d1917b0e376821281e5b6f41336e56ee997da1be01f3e7746596616edda511cb4234482ac7a0023d640f0c443b369291e44f728ca91492ea044f083487a4b5b1a85ce08aa037ff4f310a22a84f91b1cd52af29cf38c37456e6b1e3841030392e55ad957c65a13514795acbe9fe98a9d5a3db4fda7282c3d13a3f21974004691fafba7f9f9bac3767542209e0c4a5d84af3b015b78091ae0bb0759cfe06e0c0d45d834a262f3e5d12febaf6d6a6f80b93bd32e6fc5c93854df494486344ca958452673ffe19d99c4f4980d63218b18b17e0a735a4edd1c69f7c0e192c042d0687728d5e144d6de1e4b26d5e84be3b2716d37a46aacace7686565bb0ec17b6a3708db8a59a0ba088f494d13c20f69dd395cff22c8f81cfcb89bae764a61ea4fcaf9ca441bf958286d9d5a2fca4a67136e25436d43cd23c59959b11b20e54dd7c32ec91273e7457aa8b4d4b11c55dce5a0203a3d638fce8e018b2e0a6d10db516ea33ca6cb32def80162d4c978b20569264223821ea6af713a8294ffba91e53b37298833c4c77e85f5778d59c1e3c2cfc3777342b05afe9816e75dc7b2dfd8b8ea9e8a1227bb56a4ddd0b0e31274577171176aeb2cabb6eaaedc85127ec961374a3ba49202b43e99782c423191b9cdd1060d05922d9f8f49deab81df5f4ca8289beb9d6304971d976f67c27ff79d02a8e8f89bd9960885cc6da45296a2271ba8e084b95694d7db24bd2979ae72a689b5992fbb117b2f36858210e6fd618dbd6706611d1013717a22232dc25c3953cb3990967204948ae846da4acd819aa5281a575c701339deafc1bc94b2418565b1973698558db44cb19c1ebbf869e9991d6fd6ffb5b0dc45174e93933ac0467833c5921f576b17f8d3d04fa1131135ee7cfa1b6d1a08f0f7c022d5a1be55ddbf5fbcf3d18a9a0b53a0ccb9d964fd0f7c6041c8e50e3f57a2f381638b6598a0de62f9d4696e5924a329f04fa24b6d00f580bc52a00fad547ae6f340a0e4c446da611cdffcd0677faced0ec1b5cc3025e2fcee3a8e2de21c3cd6a2273ec8f6285288b2fa21e3e13710bc4e51ed6a1c4895aa813c01fc4bc7f78beed3e345873b904474bc47d4e669aaaee8db955f9f27f67a058e43f22efcad34fb3df06eb5fa56ebfcd1fcfe5c5f012f5d6a3b35b4d52e8285059e7d0fea2df383940f7d1750135e2c3be7a186aaa10ec9f15f12c5f3fd126bf794018ffb7ec26540d783a2544f61ebe7172e41b1c30687e4e2ae71dcb731409041e8579b4e8c57b67dcd1e4c77519542f9af7fb2692d92b35a0cf4a32f0a36b15b17a75723fba880f3d5cf1c6d7c3a8456a74278da680aa53678f399fd3fcb399e8a8c6adbfb6510822523a3d2e0d2d83b2b4a6d9283dc12e4c1e49ab3a7ddd193c3f8785abec231cc41fdeb08bd89ad162b565cbf136c04768ea86ebbc14904a6299e7a9fe44793a3e2c6cb06aab7efcec10afbafcab4c45ed3d09866f60c6e496a1a0a7df5eecbee56c9267114f94b955da2d16624e988b6e9ff1270695d0e04d65dd348e7573b789374f530bf7c6ef353fa964db354617c9d478448002a6c78fe4d1f91f33f829e3e9742ba5a4c0bee02d2dc10b95eec1abe4565c3db978d801b5a221d84ad495c34c3b3e0e9977218f4aa415da90b0ab1ab6ac3d99cc53f6d3f22b52009f11eb4db19a2e8720e7877856f6eea08d47a0a4e7b8e702463a9159f7e1eb3ec1d9d4700c283343c6aeacbd279c078a634ecba8ea7afc162de7a19fd4a7bab9b70e949c518ae12f9a85b465866f7d0ff054d2f48edd2a4bb2129474d80e860e41a0fab93fe873a83858845179d115d3f267b08ff14df934a85db65ef6d794415701a6ae2868ea1176cc4225ecd049259f4f0b4d4fa97703121087b0a0634019d607eccf797d096f9c554b0fd909d86a322e7d0ac2c27e3e4eb8b39bf49e35b96435c11e62a1a3adace03562b9a6982ef780a632670330376e5d2b1639afec1c072487bacf5f53dce9be52578e9382aeb4f884197f3cac736bb7531e384fabd63ea0777412ed83ee0a768c1e968d18dcd8844be11b1f0a63845af465c45e9f112254974986ee5958f7174411e78f6ab9b13cf7b51a7351eabf1d7096e72bf35b05d797c42f8db1b21ddfb3864ffb93c9a19fb069d4a129b3367a9edc4a1122bd3efe9e51365954d91431cb9962d7b9c87f2bf12126585e7461b0d06dbdcab710e9d32e5edaef72b829d927c4cc335f6578bc8fbc32843974f86d424cd6f9744f690d75f45bebabdba73f2d57f9f94e12602f52cb4b8dc2a54cf0f153f728d6ccfc410e44132032d955a5629ebaeb238eca8e650ccd805492019f2967deac9b0cf58b80cbd2f44f6bb77309ad98edd1ae945df7d773ff5db732a350e90edcd6d9bc91c88f5e56c92145725194aec8ed608445babd3843bc3e9370b3c703f3fa70baba89a7413d9cd89d7a88c8522a70e3950ea68fac9443fc909162c9965e2b691fae4210515ecb0da3c4f7593d4c1d2354fff49d67ae942996972b3baf3c28120201088e504c4c0e4221717949e7e267d9bf3c7bc5d7b34fcc5621ec9fffc8ab9b490a0d8790651bc38c8c8820dc711965731f90d9c52c180e2f51606129523bcb5adf93d7156b617630445f1c0dc16ec0bbd323f0d9efdbd1e393f7803d0e3a5efbac62ea4aed2607df7a4b55f9d356c0e855e7aff8997bf9b171e406731ccc3e54e9deed25d7f8f24ce01adcf53c24cef0ca50a20d9ff29c6821d64e4bc9aabd5f75975926f0a44f8dc5e55dc281250ab8cb97757d4357682107410a1e29943a0ca6161b44a7bf777cf83d389d5573fd7a8e8bab119b84fd1809df8ec909759ab5fe7b14250519841c555b359dd0ddb7d9347dc934b7529840b94e9d2ac1082d358cc37e22abc52836074ed5528a3b1f8f78f20c7706b7b77830b8d2cfe7a96b913fe1756d154cea7269a96cfd643065e8477f2509385ac0416976d1e3ff68120c00f9dc1828644cc64c99d42d4f67f5f4dfb87f32ba7a0719f00011d5d9cdbaaafea656ed176f4dc9608d982d1c2a85b52f94aedc2117f6d2e1da24e60e407012fb201175b10cdfb3c5deb859d67312dd54d93783ae5767bcd2265b60300debc6d305fa428350e8655fc1bdbc4192c9cff91027876a323dcb6635f52d5ca2f20ea7d956e2bd6c3e331ef7cc8d690e6cb7b038e672c53528b85e7d20d68ef66c47895340d493bbb4cbe4d4e5e21e0fc478aa59a03a9f2bd9f7933790de16329c077891fffd60cda90faa610870a1381cf99844f37cac13cf258f365535eed7b4fb0907167bab8d6a082f5735e3a824b7499cc553f05afca78171fe249b36295cce254590d80ea2557df8112b11cf9262248e23596b6ab22ffff3a9c1846d9862ce5e7d7c0f495573ef98f35077ed02ccda4f7cef17a7e70fbf870d344544a29a6834f6ef293d4649d014b77b0958658acbebd9f8f61711d583b551553fa551be6822964d9aba089bc3b400a6bed6f5a575073592dd5e51a52627a20c87a074a410c89b05fff144bd98bfc341d5714949b4722a1b272a78f2323153ee11146205c32dff2c39394a19de89500bc925398eccf860031066c5ccad024c8be13c30e633433b978f95fabdd69254120394680dc31de56831d7130dd09e8f3488950664b8c46d07c0fe99445cf5bf7e04001790e428e6211cb9e8560f4ba71e3da7c9b6379c9a7852cb723eda510e37397bc177a6f1f418d1becd64c7dfbb36747f6d0d609de0cb5eed90935183f3e8d3a7eb7b8adfe50955b13858ec0959cd0e52783da0d8342d6f099d6c7560a33512c8755a2cac767baed0bbde7aa47789f02f58af7b1299b331608ba0ee23acf802d6a665c6077214240a566c2b9f2eea4e1230af8774b757cf2b5e4e6541be6f9a597a0b35d74cfe8dd09c0a97492e971a0b295c0183c6916678b0d8986d847065d2aab0bf2628b4d6f971fc9102a3908e1936119012950954c6d0c4fb6bd044c73706967c9812ec0bdc0cd53c9636cd51156dc4fc8db502059b22746bf76e4768e6dfe26ace323aa7bf4bf76f7a2f30deec46b20b98197b4e9cf748917099d36b56a1489bee71e8d69d1ab7614689423b7dc872186516d37ce4e574964bac654e82115abc700dda959ca134dd136c1efb687025477fe184d6f7ce11ab636547fedf693d4bb04eb73471e490bc0a3551707659ff7c953336d3d89c951dd8a2b2568ffbbb6bdd84941a36e2d5dca80a89ad8c3fd7987831cfb2b7e30c39d133683d95cec9ebaf5ab54eec2c04eda57ac4c8867fbfcb985ccd85bb078a81a65cf5bf6d0bd1e460b754eac44891a7864c21f669de0cef31c2b43d8ade51c1f87c14a320166badcd49cf54114c2ed977ee7246d4eac620fb5a2ed301a6f4779986d046fe91dc8f79a74d68f7f241b00648464f92dac18b20f5a986e109341748b8509816cfe7f3477acaa4b13dfdbde249f7d2b7db85da609dc61701c7f8085fd8ea4551a2254a425b0dd5c7066185d7347ca3259cb26eab1d9087294e24cea8dcdda03782dea0f2dc54bc77e5663731550b853af34724292ecef7c530cbb17dc1376ff6b0aa0ac49f6e2422f532710572552038e8c7ff74d862db9b8e13b35a4ce37baa64fdbca87e6dcb4ff74ae0f9433ee9e32c8f06d3fe5bee45d78b00f3269fed15fbb61f9540f7eb929def4b627b0409ac86a1fa678a32ecfd5bec6ce6f650d6bfac1c7fd86097e271da2d50ac9d347b210d86afd3a0681fd692bfb15f51a75e817148fd622d5cc92a3b4f94d8e1c896f9786436ab851be84bb370003db51a8bb010320d51777ad992788c4b1381ff673a02c0bcad6b224844b2ccad7df8051e041e302270c278208516c60d79914c0e76814005c307402e730f1bd42cc183da6ce70ab0ab7ed23c9a8322607135845939522c0c3ea971dc014defb4f00cef9c388c049f8f8a104addcf8986cd4c2e198f5d3aaa64670858a52a4db32d17ddec51a5e69c4431","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
