<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"986795d5cede39dffbe8562a64c0aced684a7044c96594a17ffdc8df417a0c0b7fa9288ddc81ce36ae0468a41e05fed547115cfc0cd3c3ece108b66c4fe559073376db3b948ce75c308ff7a59163b76f29f4282354d43bcbd313ca98b7a5002d67aa7edffaef77e72997c959f0801127de6b06d1b00bfc0590fa2a92bbcd75c2b5455f93f2ab17a8f38f13b0cf0cd800d50c8bc24f0fe154c7cb64d12a465fa1fa885c429156d62b9eccb352285d460de5ed861052cccf00271e1376cbebe87f1e125b6b4c411ba63c10efb9d105469acf015485121060819bb47b5c397373738c99b573c8511570b87326db48eb964b1487b238d0371ed886d5c507fd743a41920d5b778693d99fa01e3d813a8b2a75261cd33d2f8245d74df6ce6df996c6dae59170f15caad45cad33fd9f496a32c731019e423d814802ceab5739806d96f1d063f9c8cf0a34d8ba50e6c908b3938466dffe4d7aee617ede989900c93a133e1591fac4629b2d57e3da0dfc922a98356e7ab5e8f473e7c23db3e57b1ac68a2531b9dcd270a10f1c22f791bdfb71512635a5a11af413d9c09222e9e88dfdf707a2fc00c0cdf5b6846134f6be952fba70851470b654fb08c80e310c2106b2c470d5ec5c08c1c7c30921bc2373293c6bc5dae561515ecc7976b1f263862efd3b27584c8c47c56010dcd7b561d33d956da772fc2773de31a7053e71b782cc277bfc9cfc0997c739a18e894380d1265224b4dd76b0bfad6b00de90b1ce63a3b749ed08cc66c1a0abb96354984e3ec095b44aee567051a63563ce9c0cabc905f1df96a3d418b942607ed3d9e60bde0a33ff0d5a3b595ec72f1ea2a303a2c549855538b720ec08fb088291225dfa0258fbd781539aea5ea23a29849ae169cf9c7767681c6cf1981ad36b81ac17653872c25e870e166c2455724bfe8ffac701f27c3172a23badc26ccb29e541254675b544acba68987e57a91001f8530bf0168600b8a6e7b46b46328a9f0dbae7d30bdcc6462d8cd250c978c430264df65d94f48dda6a906e914c154b28e7c49c4481b4ce9972a8191bcb85cb4e32d6e5e0fffbd7892e4b9e0e2a5cfca7352e811982ff819c0fe46c10817ea663021b7440dc148e0ea05096ce7f5caeab602bfbff3a1448671ec8e21436ab3a38216e7246656818c0e04deb32113cc030e35379165ccff73479e618e077026d2a8b47f2ada92bea446c0a12774fbc5db1bfb4ff859eef033e777e3ffa2f6b71fc909ad2c8fbfc1b498f96d0638e0adc721fcafda67b8b1e93ca937539e539897d8c3bdd367ec956993299b83e81e86d540539f71e215a8974fe5e51cbf4302d3c7068ebb17ccad2bd5cb535a95a0b060aad53612dae13f3b6f55c8658291c768b954223180a163e1db154d20021cc6041ea4480861c7e490e5dc34e828f18967853ea1247a17205c6ceed935a92543b13131d5fbef07f7ac6e539854b4d19d071448216ef890e62f9010bdd957e478b42a8be3e22e9e56fb5ddcfcd95d1c7012dbc796557de826c73e7214a7837ee0f9389814c0813b9eb6135d0c4958a810235ea716382ef7b6d5a50fabb1b4019b68bcfb722467679ff2bb22d6854d8da0c5b8c45441eca564b4b11ddaed2d43b67b65dd0935f797eed65203387adff9e39db1fc74a9ad201d0a9ce4ab2c119ec96b959284d7a944cd2886ae7f3124fb8fa349875b796351755b4fb3b712e4fdaf43e1fd535fc71591c4140800558951a78996db2fa73f20c17631dd401cffd9526d5ba267b3d5a8843c6df974b7f459defe340c71f447961a49318809e22274f7cf4b699a50e0cdbf6e8e4604063980655ac6257bcd59acf0313612fb246a430fb1be1284889bb3775a1c46aef90c8e54bb7ccbf7da1135d5d1f3d37dfce578d29c2b6df3208b3dccf8f3c86e088ef566e74df2c8bfd01e84c0159a89ee2f084e99d52b53e992aa78a4ddcdf8149728d25a0aed990a0804bcfc41688a913bfd6a5bc8229d1d653c87e39ddb32849f53bfccb7493059a0bf179c07220a7e4d041d06c62d10200e7cab817e663d81fa12837081f1f20d5928a9364dd2ddcc8bccfab8f7deb1cdb7ae50dd4f9cf0b09f30ab47995d8ecec46e84097da2bfa3a81a8957d6c0e8a826fb22c3dd5770658257758e76920a12d3d0527d57b6726c05c6966e13bd8ad53aab9ff7e4e42e2fcdc6f1821b04ba0d6a245fc1e31fe7bbe3c5ae0bffb40fecf1c8ffa3ffd99eddd743020b31fd9812dd8d884cb90e8ac9a940965a58afd2a32f34b4893f832c7f2b673ddb87508149b34716112f43a8879ebff8b2b83838a7659d407957d03e804a2bd017c60a34079082f6ebfa526e04491943a47e82eda3df95ee799f9f080d61bb5ffa03ba2123917f33a0d6d2224079eab2a50805ee3c8d83c9f42f6a5a9b3e9bbed91c21760559bfa05b056a9d52e6426b55d43b6ed94d2c90afd98ce144ddd34f2132621333b9a616c3b50266cc5d76756cb615918c3f1f47a333d1530e0c8c637793a21a1d468f07d18e605005442f14cf83592bd9b6146dac2d4b53259c856dbcc7bc0363468d04801891663c85a399745891b1545efe130c31f3c98fc67760ce85854e66e855ad3d0e23bb5d0144b50009592640923be0665eee9f99db4c74d6bc3d55575573e12be0d109e55d51d9bbc7b26b3952bf0d518501901baff6dea2d043ac4a55bc93196566e521c329dde61c0cfa93c1ef449cb93fb693b5054e9097b16b4ea47746af753c43f5240de6c8ab051916242c34f293aa9d056f457792321adeab7fda83db46453792854a2c5826f5104c9031d8cf33d1f30edaafd9416f39b879e1a5e7e0200217d59f71f54f991321db0095e13b2245b4ac1721ba08ba70554f9281859b0893e139fdbba7992e82df9a07e2b456ef8902bea0672e39384536ef566def0f81dde33523aca341ba002df8ef3b32ac4ef8e4280e586c7c90b8ce7316bb68f4deb54c133a01579a281396e57329f83a6ecc313ad0f350ec9a719fc987488758650b99462e43f1481513b1bcfaa706217142c9ffd4e43042d9a37ece8a30e5bd33991229a602c41797c9ebedddefeb0447737ba70a254690869eff8001a182ca46b6f0c4f47eb19170a7976965a899e7919f15974d4233f7e8e6eea2d3df420fedea2f7517e2a9de2b3b52d11b03bfa17d1e41eb3fb34e642eb045db74fd0c7bea77d708899bcd00658ca3ca12bfbe7686dbd2336311d7a50f4c977e14563c9cd38a332792bd6cb242473e5952d5e5f505ad492ff580ec3ef621dacd4b39857587477131de44258136aaa544cdfaa9390b20438f72e9255a541b897e278423250ce5bd5ed3f3db412123eef07975b3c0d2a8bbca48eb251bb6edf749c1a48ea231c7fde1bdd7d8f9e146b8b303656155307c9853505ad2aa08ae74630e323600b146e3296d2502ae058cd88831d66be8f661e0deedd4b6c9279fd4760554edd07c98a66bcf2acf60c5c0ab94437855da122615540c3b1f173c6dd4621aa738906f6dc352a1db82815650aa7e24ac1dfa8a39e8b6d63625834cfedbedf5f214c6dd23f968c38f3cfd32b932cb330ed6b012e0eb42173536008a7342a66950fdee802da44c55249e468843056d9b6a6331a7a9faf1478978dbe48f2e42d08789dbe9950419ca4384a9802f6b56795802db1f198cf4b8ba441bb9d4062860e247334e6069168a0d5143aa46f6e3ef8b91b7014af5666aa379d2b95e8f52b611d5ba8dfca9165a5fdd988beaca23de77f10b8e7eadb2c1a01d5078b9472ad9f6232b2ab7d237954d041bcd9d0a5ca869e436294b799d4ad589485a458a1b89afbdb2d110807f331393b3578785ac558ab1489665422ab4f028968f56c3d811bbf0ae447bdc7f87e4b7f09064a4b1e8c7c3ecaf7abdf81fae1367d2e03957c0b878345c59ea045cc11e978d1dc626f63e416bcddd6a5e946d11fb1b8dfa38ba74d6d310d7c25ece9d9d104f202c04850d165cf655f42728059ce27d0b2b1d3affc9317962d7b07e2ecaea5ea03b65b285e9eb1e70f64a4a7c42ec35fadef7bf987b202ec911de3065ab80a18efa9aac899d182ecc0f68a13d015597c6913b018b5be1a409415e044a5fa91ff2f63f69bced084759b10db9fd2edfb2efad93e5528323e7057202ba5d93afeccb564a6d83a391a965be4560664bde6cb73f8ed76c6bfa688941b5fc24e8a1321bb42026ca1ae032a8237c432504ce2567cc1a5db9c1c2abb3fa347973f23c9154d7591f90554973021abbce7c29046935aca43023f336c79d7420f37dfb5542e1ed57ab57a00f0ad960fc13782ae0dc5c1830d5794288e11a5398bafb1491f0ecb15bee102408e8b31da6c9bca3c7f948fe2d9b32a4734d1b6c2bba3ce89c84eb955c58775736b9ddc26b333bdc4dffdd9d5fd12692fe4e77ff2d6fb797958c3211ada693fe1acd97b97f1e0dd288bec860cfb7754e71abe14a97a0f6b194317726810b1329eb0e3adfbd436ca7d6ef0e51e208f68e27cd3d2f37be1200f5f74dd37bb58a1f0527112b571ba19246e7ef6e0f00285580789bee40e2ed490b1e925411b85c8c3bef8c637ee20160cc0f9a258089b79c6e95497db9ef5184fb234a2401a94cc5df7a962c591f48b8da4218df8e9c08893c35164772705b0f4974e8e5ece8d6090a22a7f6759a993181d2307fd3b04d00b9eb234605b3b17c8243c4bea45e9eb5cd97d1353d77e70c353358a2af1de48392c9a3730603b396615f25c0f406b4d820ee4e2e5e126ddb8820874c4dd10dfc2ccd971af95e34a51ec913c2af096c8708b3512c2ea82fab80ec45af0cf909f96164cbcf9e9a1591c855051c0946919dff95a32f105a62605e852ef899c1ea408630b21aeca436783de79b30a681c80eb6f939e149007e44ea6c0cfe7fb06f0bcd700d95c0ef6dc75445d571c030485e8221ffc30368332d870141b1bde1a392d9a710239c6b63c301e5ca2fc563ab3013999318531ed15a5e256d1906de3698166ed39849167ff76cc24283c9aed9f09fde88b463cad695a16d3bb4e52904d61a017bb325ba1fb583b1953e9b857b707e2a39bab6b3c707c926336e0dd871a0c42cc038f375f7cd751577b5e3a0d324754d503caf92b32e1e9e55025d5328fc505ffba21e5eab0a92c8d8f6521090a52a09dcb4fb88fd736147c84936f8ffe898b9c76cfb8be0b8f3c55fad8c9865d8ded5b33080e7fcd60676a86fb76a40662bc9fdaeccab54b0a20ab630d0e113d15e8d329b2a39484d8e807b7c48a67f3c2be49ed545956995f04ee28d97584489e8b7b26e5704586516e1bb18b2e10026c9d2e11cb9142ad4bd29f6cb0417c4217bec66f628427dd44dc65e146259790848bfcd39c6d493160c4d97db4c49a29bd3ff40631fb460f4e948b45eefe1e1e8b478356c2e2407405ceed3ebd90236e51afa9155da79e28840bb527afe3de54bd66ee8d91ac96ea29728e1dafb8562c104839677df84829ab80958f8cd9000c55c05abff12cb7fd367382e39f9bbec3ea338a49da4aad24c847b11724bb40916efb05cf907486ca3a17638738338d3a92d4714b74412c00a804a8405a884bd41faac60d158eab563d4061d997cf4e7f1d5bcbd09d2efe13203b0b1c570b11a399d8932c97173a129bb2dcb3e930753395ea69229474bec861983b3628e5220b10963b06e2b40e46fd3cb5a6f27a8a9e35bdb7e014a9f02553cd5c96e4fa3d9805453360a61b551a10f00b713ae6aa9d6c1d643a0f58fd6bcf4d7f8273120dfecc93fa661e3b6f52e1c61be1ac30993ec593931952e19a643bef5bf7585bc82becb8eca62d4a6459ad8d331123b246e17d215dfb6e53f825e6568ba01ae77cec3f1bfd2cc65d5ca5b788f8b8d8583a5c74ca6e8a03bddf9b9d80ea976d9c814098473864b9ff92cf3956429fe2dc80f704190fd561118ed152f4dba005f306198714f567f22ec8f897f5b7976625f64f0e2337f27ce7f279b5d3a911ac2788a6f3bb79aeb3512e74c03dc11e4faab786974a6917f459b0528f9e557ea81ed8499c5d824b7785e95f3ee3d93fe1cf1f8a2048b9d475539972bbbb39cd2e757bff2052f4b24da9fb0f6e3c66cd4a4229845aa0c73bf73f63e5c177ec4c038fa7e47efc1d7c2c6e9288cc95be861d9023ca23b2fd962e595ebf41aea85b6a2c17a40c3d148cc541e3e490ec2649326cc505b6162ec758647581b82da3568d7509e2aeef003a6d475f82ee1e543c052ed921bd0a33286a91228688fefcba0037d20afe57e35e81d3e49d9db2a21446e775dd6b4dc3c7fc1e41140b047b3ffc61fa5484e51caaf8224761143883f5c6b0a4857f9116f92b6abfe665e5a35c59f2e1946ba34cd142c024f20ef299294ab3c889e7d6d5bd53e57c13ac6ab126b69674fe83ff78164e08cd59f0a583ec2792afe22741f974940e8581255bea3b13d84e76ec8b2f66ae7f9dc62fc552299947172c801f4e5a07463ca91a5dab31ac741fd38158cc75fc0cf25d6c1711922b6114cbc5e2bb5eb340e0a6f15f0e8dd7b7057c6a0f4d5ea3965f610421c9d99a673f79c63af2d77b8894a79f962aeff98d5dac1bd336da1303d073b120a978126ecca2457e209d4dc4fd044fc399fbeb643b1ae385014b367df8297ba538556e4fbd3f227b2b8b61d5afe410ab2d804cfcd6d7821b40eaa85c8455c35ae41f29efe7647ad4a670dec34d3706e13c6c1a2ca3819f6f2ae4125b89e5a4fbd665cc8a982f3defb45bb8d5adad389f11c7939b88a76668b86ab78739c3923f345ebcf04098a25cd1379f72e0f8e55389f05325b0945d9cfd10f20d52a67a23281868ea7a55e540e9b89fe1de1dfe120e487f07c43bb3189789cfd603d5ca81ae148ad37e82984655759e1ae6ca90d85214a50a2e89afb1df1c99bf041f0fc1f31088a78ece621b1e009ebe4214a7e6ae47041d545c1dc3050637999339b9d0ab1a8b18343b42d2f61c1abfed5509505f39b327922d7fd76440c4c369d41049f2c3fa4f87cf94278a24c2d9adc8fee74c1e6d37ed0ea95c319e19555d9a77ce1172e877c0265664f58ddc6d36cc748ee7fed662fcbb431b19b666378c944910fc4c6e80d8cde383ee022c7f5ad8fccf4dd3adcb3e6068b453d62024fcb13dae76df65cdffe4c5815ee2945551958c10f5c722d774d7307ee4ef1f44d84bea8bc79d4be30f81435cdd54d0d4de477da4571ad94929089ba6429dcc5b9fe0b53070c5c1e9c6314a39a96580d72b866d3da80a8922aeb5878fd33aa1bd5ed95fe1f7f6a0de6ffc60a3075fff7965a9c1e5084e194c1367ecac92b95216d44faae134c123a8033a68dd3db82dc5e9825aaf9279eabf345aebef8f715d6ec5df1550a42c876f2c4963d31293cdcdab2cd594900d3fe52a92a7089944623e2aa9ac12f90aca104db0db6ee2d2046be81621bea41e3d090e5772a590b62e85e471248afcc85a2637ac54ae4fe64dbe3889166aeccaf5bd9398e877fe18b9c82673b8cd2eb7aec49adbe11e43000f41541b8693911e4e938d3339d2e1240f11fd823b2dc96c9fc14d0202a1f294d10db6ea8845475f3f9f68f21aeda77aa6144c71ca56f85cdb0e9c2bfd9ee01d5d3e3b0f43ff49a7e8fd724c729b4447475c649360bcefae3ba34b0f1bcce8fe832efe93ded9a9f613cc801f1681ba651f659aa0c6a6585e3323375d6646dc9a9fcba5d3f31d82426e01282cc546a697fd3e2afea01655b851c237b60798d20c8c942fb3909b472377dcb50fb505956c70add4db2e5858d1a424e57c118e696009421c4c871b0f1cdbf51205dbaec5d8325e5c22bdf6b254777ec7bcb485e8d9e07894ddfd7d3ab0a3dc8a5bf50d83ff03a65de0d9916832abf33d2fd99df17550cc42cbd62417ea0e8e5686d46f107a9a86e74aef795efadcee83dd3372aff261aa14b3988946b2046f4abb389f2c5242edcf874128feeb943d3a39e1180d972dd9a8c461a3597792e03a6b2bdf9414c0290f96249e0158cb48b7e6314855baf8473e9b6e4a0e9bbf03f2a21dd08d0f4042e21a2dd87448ba0deacf456d36ee4da54ca18f1da7d74ec1a58da4568b878323838d5f82dcb4457ebb608e3e7142dd1e754c498ca334f9981534cef045737a997b8d998abfee8a3d743e5dcacfedcf6d89985dc6bf9c05c5a722bd78551cd646c3f876a39890ac380ecf4a80a073795a87ece458497174bc0ef7f1311177d9b4bbb1d194b87d6fbbc21a01f9ba1fdd117157d02d11eb2b53776a32c370ae75bb3c60aca1bd171a6d44dd4475d13c8ff50ef6c15ae7eff2273fa93ea2f0274fe3ccdb82dea4b97a3c61f356eb4676cc5e884561a8a7aae041522b1e9b19a10816afc797b094e85ef616b60b18505535f00e1b99aa4406b61392ccce129f21ab25041e7e27ca01db5bd4bd4a4b4b1c055d1a740d1c0732f116da68edb5d44f0975b874eb0c84c8bb389551ee1ffa919cf40803026b077219ffe24ed67abe6e033bcd022e546a1d986bfa62ac53236e3d0b2864445d5d4909fed6270ab349625c4bdda0388c483817393c7bf700197a96ace5e097665baf465f6bc206084e0384e7d31aedeabd9c7128b71e71fae63e2a99a7087c934f2d52838fbf7e9228f354a0bd4b57e0c325096e3f9c6fd4d9a3bda7e68d13102c98cdf8e95ea8cfd5d4f0fbf887a9e8d0a7e93b33f9a52daf196232fad42ff1ecb96cabb39cd4be3a57099fc2ccf4ea2e5c81fc96a2438a92881beb211d6bd4a28655d85889c020e6eb3535a95fdadac1f4d85dfee26e84ed4ffed53aacebfcd43bd405a2da17d81088657e1c639a8d5c04d55ee76052655e9da4db6f5f05b71eff545f0e6248958a01c81f62a14c6eabae90c5286096f193960464e9780929649930f0fd2e431d8ba9d7659d257c7a62d3d15cd22452037e4778ba7e0513b333f597a4ac723041f5822c7abdae4785a02260e76c55b42eafdb885e03a58901a79466b457ded813c1290c46846c0da481328fa65e5eefcee34d3a64e89a44429a5a1c03dc95f8ea1c3f0dd508eba7c43e22f038f35deb6954e7f00540f809e9970dd9fc2f9d087937f2b689e07426b971c045bcadd2067c9e8e5eaa7e941f4c24748a18f20b220aeb844a5386974c86ef1ef26dde019e442031259a3410d806915dbd15e7ad2167c09e05c072021e8024fdb859bc3f425a9436939698dddfcb6a86ee1340ac7bf3ff44ecf74ac6171b3ace3d8a44c2d148ba9cc35ee37f7592a06d7f0e3740316b7358bb0eeb8858c69c043bfc8a7ae76368a119c61803b446880e646d45397fed861b4ded18535452e4c16e7f5f2f709a6b293ac10413fbc431cafaa561f41931eea1d9d025d818f7baad68ed204edb84e191bb96793cbe133e0db80828dc410b38fb59d77978d56af1c864f930ba90f4e687829c3b2bf749a7c7bc7ea7ce9441a6ab175444559a1f26aadb607bb1d1c8a06b1a43ca95a24c7a83b8392bd12c27f3f054b3fb798b277dc3a50b936732ecf49b3d0be3243ebc09a3801b7c4e194745ad6ca702de96c095b98ef6fa7d26811f77bf1683b6cb964f46c9c7cc483c072da1a8b203d94ff4d37fd9a8e396839987a5960ed0451bfb37485a49ae8efdf77d84de48bc2e3afa80199b1daa4c1d6f70a718dc3432c491c955ba14610b7b3f365743882f665b15aa08632f930b70f438a0e99d96d7e16767136d598069c5ba8fa255f094a9a94923aab6e75bec04a257bd506da5ca07623f4b102a3d49b8120eae17570804a9007461e42d5c7d06d2c9894aac5d1cafe9a2b94e9c2ab195159df7244e11ea2e6c3fca52e21d20982d4a1b52ff54e7c8442b8b67a1050440dc2f0cdde32309217fdbd7874a142d49b0f778f01c2197fe4e918dea4ed47d6be0d15d3ccc7c6487bdcddf5bf0ba7f88d6404d69711f37106cb65cc23d1167b5f701045cb1c33158737f5ef4bdcdf8e3d042e0ad4b764ef82bd4d10c2691cef5c36ad08c17c25da425e82e0b38f6541d5c0ee62c6aa54553780399a7fff650e9e874e5f2cc2a70d8855fa62dfcf54924ca4c74128c129daf75e860f2280bf37b296868a8351ac99b2a231f3af70de263de0054582d20f89fbafacfede52210f14a4b622516cf0cbe80a68311862df20b45fa35b8bbf0e321b090ae35b657a89c1c5fbf79d4bedc196cc84b68b36ef704e3a5f0a71f9e387aeee213d576a44c7c740b91a88900ce24754777d0d89649c0bae28fee41f6edd45c55d310ea2338ff1cfebc40e26a502de0b44c269a56c58fbfaf1730e4f9e903c72334b236cb3a938640c3066b1c2e1de8b34fbddb36b796f12e82ffeefcce0043c1ae384d69e7cd40fa721f331f46cf454f6b89745fa652b27195bdb299ce57fa60a3cb85d4cdb6258de1698d69a552cfaa60a0448a20f5443a08a19dcc2b97f23fc2fcc875dd6482c87d08563d33cd5b041ac0ce2f44a7b14bb4662841b7c38ad0d5a1f61f720934f75cd4098154fe5363209b666aabc6a9900de3645ac2ddf8f6a961938b087974bc8b7255734488a4d8fa39c388e76750d23d7c6af21e02e1a86324ffae71d0e90dfd0c9afaf1a1c0d8409e00c703ef64815c372ecc3b80d7fe333dfce0158aeb776b61526185f463fd14169669db71645728993e4e2e17ffec9ae30e5ad13f861a6105cb14b48ae51b8d8397a1437683d15a7c131c1f51d0a8bb3c687c8a3696b32e29b16d377a946009c35726c39cdc6ef97f8aab19a513bcb7b47f03f4a5250e4453b00c79db4ae6f2c0e584f85fb973dee5cb489ad3d9cd7b3df8e81783687d717d7ba5afac5a5c83d92c76ea0dfd99e1409a03ee1d3b239b12bf7725cd681ae245c406e7a1a1466a3878fd9024d7807aded5c83e0ed666910372b42a16384ef022ca90f09dacdef2164b0fdc94dc176b41af16d51b2b8c1286ec530b0671c9743ff2c93c3f6f21da6968025f5503a1dd361a1462f4b90eb57a8def5e8af178500c1837b9cf5fc93a783ecf0c5629e175c4162cc19391e4bf7adb6af1910bf5afb6bf24a69844d31a8b6e230bb26781973acf9743fef9e563bf2affe6598e6e65a1fadf87a0dabcab0c3da29a75ffe8d58d4660f55778ae94741a178426de2fd18ba53ec4f6b1ea34d37c0698faf0e4d54ccdf5ba5f3b590f0c6a9d3e226c8765cc84e0363c7bac9446f9042a87e9ef8ce505066071399fa98e41bce473b283fd0630d1d3f7369f4f34eb386b49cfd59f7a7afcdbc7fe257ba71232b45f5fa6da33891ab01e023271605a9c1c441c6b0af28c7daa7b599417c1daacbd89b5d8225a7d63c079de3e80de951a50eb9d3ea829eb8a1491482254f5fbd10b1e612ba9e4b2c9f8bbf0604966be99e8ec53feeef3aed1520557a2a568927344951555fc8d10aacb0fc7f7adaf5ece5d7c2022aee9a991d738b64a65b5b8cd18fcb445e9ece9ecdaa9ee3b7433968d115f36bfecfc477992583f1397e21f4b525dc7c2d787c358891df8d8283cc988a353b3f3f6d1fdd9ec66fe89efda191b6409b7d85836c674434fc807f57d90dee55bea1dadc2f1093a278732be3ebfe83d7adb71e1141b4106530ee3b6fe70f6fe227ea887e68cc24604ec90bc31d403ee9426cec18928d626f11542649d873159b7ed36c2739551716b3dad085e68f6938569916def4eb9342955db0b9a902b8b8ca40596fc0fd52670715d9320ecb3f49a2e88f880d0b8ff12b59729fe99f2ce8783e0697ae7c9f71900a2898d4faddfb3a79ac5453084a8ce111da8e84b1ee9bbd85987e1aa8d1f38ffa1eb8ff71639cdb842844c280109551657904bd18e5334b83f1b485a3077846d7852d9d42383db0df8ba308381065cbf5b74556eb155a9f9e562355304a2d7a814f3160e75168facee7c1745f15907c4f734ed98b2fa9c553ca4ac4f356ef35a6a3dfb39fe1806fb74256b4b2a046e3a6c0d47c93b0e47daa058debae7e1d70c13fe81c0963b6c7f5714603a892f75d1fc2518c51d5dc346f35a4dae22f26c0b604a860f872f31a8685e6613dc530525bcc8dc340050d7dd8c8ddc40ad8fbfa28b7226748c542554dbce81568996f70787f9b8a287ad43a07f9eeaa2048c6f72ae05823bb499c4404bc8ace2df66f388ca9cf1fb9111453a6067fe2dfecf85101efc65c442a8dd421875f06e8bc4530e28e3e6e73b05eba85ea195da39a1bf04f6fdbf05addc83e7a8c6de222b243bd4d1242b226a6776d16af20e26fbab49d1a6429e27060e74c0b7a6bc8a7c23736091e357e71d958fe33c501019949205ed3394000897420ff318940090ff762e28b29dfea029438b56aa5bb6f64f2a56790eeb3167462f57959d3070742421cae91e1e4d356fe4dd039a0fc7b93e873af967e40d53ab241701ba9ccd3c117630357ecd392a8706ea820df8c68dbadac067f82d5a265ee8b3793d37ffb6c095d08d896e19e38c370d2fee4d5771d0096f0329c0aa6c1a5494a93ad6f12632689f5e1b035a0ba3505d7c4054af17caf869e73b23e4c85613658574dc5d9df7d83f78f5f78462af3f8ebbf72fe15e62884c04b5508109113aa4dbc80433bb6da1c999a15041a3db3e1df2f54d29decf8a981f3495ac03566afe8c6c229dfa13b18746b1f1a9a9e9ae673f28afbd0e51ff14dcc3cbaa24c23b9f2e546f359c18ccdb96a4024409f623f5e5f196623cfa6c4c91d693e6ff86213ac3d9493f8cffcd6c609307d5fa94ca2e22240c2484ea668608f1c96b4740bd6f85bd644021b431ab29e299bd1adf8dbb10e1ebdf485a0c8568fd4a33f7e99ce0c3bf3a1b47805b5aa687002d5ab6e4b0bba281f75174c092573a4b46532aaa75afe8d084ad6b19f03663c4d18f43a4ef24b6c93d5896e993300992cd43baa97c21e831287aa8ea0ee387b57f732f9789b8684cfdb59a25492f6911ea6e501c3fd92a41fb16377400189ca6c1cf8e93826ba186bd2b6d107f7f7ff94cdab4923399ca147c1e345a5aabe2e63ae66cc079895e1840c3404b83423cb03004c39cc692c8058e8cfc4a523871fe0b6995e2d2555bb308eb38a681eb4764968a8a3f54196c900b8ef4895a7b581dfe2942595b8c4f60bf9ba7909fec37487cbd9a331b4a3cde9c6c0bcfc4a389654b2c850b4f2a4f214ff303cb49e9cbc64cd3ef8b6008c28c74889ccaf3669d8a2ea07e4e71b1db8aa7d6a3c94318ed60065cf0f0cc01e154a3788695f75268189f09047e67f1f2156552ab34be1186c48886b4b1de46f036267055371b43af32c640335b1b50c02ec6004028c14c4a798ceaf204255f3cb2e433c3f46960087c7d4c29601f5f7d41ebb75afb672a75876463c54c4d5ae2febafb671abbf72059f983bb3d0fe9e379e2761a57eeee1d83a930afbd2d7331e4c8b6ab56042317eef3fc1f2365159a801d75e158d2d50b14b35e0731fa1977ac0a373c2c78ffb2d5ac7125270576ff3ccb4373545c7e898e465db0b39f92df34892c95786c005a6a5e8fe5cb568693af55fbc7c7913d40f0377dfa7d4163e57c7f6e85034961758d6682869ddbb858d7764a89f0f28abcf2e9f4455ee989f35cbbc6184b00974c73e566a8d8d4eb49b2f642f26201341406653af5ae02127577b6460be2ee1b8df1cceaf9e58450d023dd1aee781b6f398c88c0efbe4c704f63f99cce0913feb575f76e8e09e4dd42acddea08f77e6c5f7c3489f7d62c68b719a9f5ebe35bf9706f4eb549e6bb6f819306fbe5c60f373d97cae437b13db20cf69452fc79edd484aae9cff6f7324af0953b0e1021404ef785ea8877d9d94e666aa7371f8ebb53132de80791ea7b1ac0660b522aa9af7fb35c28de75208360d5d32a734b37034dfec6785810415a7681a798d7af98e560d2f4e452d2cca5e3c827aa91ba072718233dc80a06962f0a1c126f490b78cef571fc3437d5271bfa12d8f0d7f5d5709a2b05f6d0054e9778e37c8a23078d630f38df4affa2d5b215eaa40db38207fb6f5cfc38c3901a5d51d3f130335991ac686a2d27c243acd45bb4297345cfa875876374bd0b9e156885fd9dc10ed9817db4eee67438c2dcc5150334fe8888a1e56912036d827abce8a7314a59d655eeb75026aa80217b6a8382d893dac23d6c1c5e26c7dca2bc1c613d27bf606fac7e147503edf5889a3e71a06f9e9b1ebdc02f0b75d4bfd5cb5b334868fe295f9a411365ec69846219782bdc7f0339258a7bc57e4b79c3db93704007a1ba2ce3b6b3e65cd7d2c5f82c52dad93b2f94fafc514bd5ebbb9cc2933e83acf79b240d2d46a47a2d33d818ed9641c555803c3fb3e34d459c4a1c9299ba3ad17b5a5958384389564849e4bb831dc0a7afb94ee42bcf0db09341035a20b8e2eae4ee05017263774ca02b6d502294744585946eeebb3e3b44eb667adb7c3413daa0ec9ba1d557a7ba50ad9b169920666306f124fb774931b000f185ac34a8550cb1ce7e7630abe67e719a03045816d3f25ac7a913baf2681e396a6eb8e5beaaf1efdc3378bc97a664c25cf6613182de654ed3588e514b1fedeff162e5a3035566c8d7b8ebb63482abe1ae90d12bad89a6805a37b1170b46a91caa533d745a2d00a268197c33acdaf142a4bcd4f042244279ede9e0b5b77f75157977782b079142624eb415dc8bfcc0aa67e4fb3ef3633df7a533ebcaf099fb19db025af85d2ccbf63c36eeac37a3320b62ec4e3a692ca8d883122d9c2076128ef332a45bebdf138c244ca774f2afbd918db2a6d9763cade39490c98462aaafd2c32cd2cde2d892c8dbde837812916da4994e8915fc3e64451f4587736c633a82af0c954d85ae604093aaaf0332c8d2f003bc6a7f6f33bd2d6ad91e3747190fded88f1faf763d3febfe5664ccafe85720e514c84609c6bcb1a6ea3192871525ebb1db2586613dbf5ad6a0479945f3dafc2c13f928daba4ae371a0cb0b7d4a5e26094b0560cdcbd9e01dd183530019bb57518a3d70f5787d85b0d6885db4fcaf99bd8d2b536bc7b048a7ce66567216d170b79646884bbdf1da1914400805b773ddcc72d2934ecf74771e607305833f4c2e6763804ac22696093079595e371b1fda25e50c87e6ac174e62f049523b1d6cfa54cc9807550f3346e6f9c9ce22eb6c85df648e45e434bf0679be09550d8b4b4d84aff5e51e1ceae02829d24ead584e7e807a3471d11291122f9380238199255901780e975daffd0c0fb1f0aec5275ee2a6d6653b13031d12f64382e8c150d3b0a690a6eb43b78824be7a9b1f8b050d8279fceaa9cf4f7111a9b424777a9381549f68c6b79b4091aea8ccb3753342ae73fb936d2369a944e443b7540494cab0c175e6e192c267217c97801549abb9427f0a23f278532284aa4b4308af5dca1ae4a307eb4ca09e419de1378cade08c46c4cc501b5b8894c3ea16e9f3aee2e2d3f1d59e58c0296de57ee311b92cecd6afbb896a1eaea7ce33dff89b8c496c40df85b30ac0d9b8a92053f56ce2e295cef3189e13574696dd1b1eecc9e62e2da8004a1d190ffd1b61971373070485d46e116814ab13503e8b69b341328939c3317f8131877c3bae121e677161d2e30005b7b22988aaa5de9fdfb4e10a213a75554cb8ce3c5214082194e7543817beb613f4aaaf1e0e2af17e0a04eb8aaa50ddd7caa94fd669cb07813e4f032b361b8c2327392457f45e2b4065387b3ec9dd7cdb016e3115ed80ea6ffb01d0ac3fb0b417742ab41147ed6e3b83e30dc8f90ae5ba67c0dccfa6c69ee9f267a49c56778f1277192421b7e33c0638d4871adfc0d7f36e593db3c3fdf9e0674d1227c9f2841e9d2107b5bddb027e26c5cf83200e04a6d9dd7649ead745f9cafa129e42cd9960550d1a681f30b83e1e8e1ef180170abad28580fa7b53f4a25d66f85db1acad177f16cdfeeb97736383bd2e04d1b6db399a34a7667a6ea79f4367943f77166036b8f89028bbc13144b90090ba422eb20fa4add8bedcffdb16f3fcdcdbdb6cf1788c4038b923480d59dd31366378fe196c3824bef56b98a5956376236cbb33c87d231617cfe06d80c7356b5a4ee50ec1e343c1f64a0006aa77c85f43cf6f8865990ef6819be4cb27ee90cc054dcdb5a494cdf90cdb6d3c878284de0c2061342e21130941714564f32ba87ddc22cbeabdd70ef798401cf3dcdd170828d182e73b8137c952677efb97bcbb593cce1cfae56d8df597c20e5158cb0f1b68bdac8db9b23e8b634acecd950b9591c26b0b613b14bb9209f54cf948ca8e161afea875333542525c51b9fa94e377cd9e19c550c53e32c50bc49a034d5b138349205f3672ef9001c46b7524aefc9cf2460239cc64512506af8ba6eae996fd62aee7464d6683f588a66a65691c2fddef8e0aefa523ce9ac03ba095a28c1ecdc3b49b2cb212c925e43fd7da53fdb011a289cd0b541836c6de82085a6d6b9a0bab18639c930ee0143571ee7124895129b9f3d429ab34769ebe05c06c6c12d70a5b20d4b64069ff46ced3b82e1fd4b1410e6f84332dfe44745ad9f603b57c1f11c02a3cec6b0bd855ed7fd8fed26ba534204bbc1cb485db085c2cff769c90249574ffb7fa8e44a1c4ab2358bcb46491e8636d6650d5116d7622c80398e0c797c62017d4f0275c317809a8d7d6585b609f5065e107534f342ac41af3aab8cc944c2b281422821dac13a408f41d04d4faf6eaf9d46cf622b27d26369a2e4022141ca76b97602c426ff7bb0596b9254cc381d2c8d5523e4b4d106ce7f532f2344bfbbf4c6cbcbd070cafa194844d90cd69316ac55ce3a4be444ac3a14cf92ff0049917bef4cd6078e3389f25ec58af0028cf05b8e9775e8b1deb95610bde3ad6a8321357c5e3bb8384c3f1b4a1938ce0f1f1868ca8a61d34b0cf1fb90b474f6179d5c35b3d7505b9030f5c03092b3b70d1057a84fe6219fde4c28ed4eba9d3cad3a4e2e98e53a033e6caf68400df1c8d6f97d63c0ed114f58e9012554c75194a71cd7e408774c7e305673e6467533f626624b40ac3c31b89ccf69ea2a5057ce023e26bc3775a9568a0fc2ff1c10b942d0c58d6c9b1d05492926bb66a620239be4717bab1ac87e69d9b5932119b02beea508929d62b0f4a999db49a6557110fe05ea2f3e309c79eb16182cff42781d9619c030f5d4097622dd8bd35c4937385833a84047904419bacce9f361812921cfd027aab6882e29b780437da14c62066b8c85dd08cbba68f652254a794adc7312e1ebf051e9d1791242daefd1471f2acd02187c1c0d8639d050bc001dcbd2b90d0fbb645ab4f3be3e8c42d39292d5d623b257e5bea4e4fcbf149945870121dd7eea6db7fe07a534e73f766e86a7859cac3244da2c74c1ec2270bd3dc9224479b44c90124ad162ac013ac6f493d8a1808fa8f141f4790fe8bca1ec05295512dd0eb1e4b047928cdaa8fbd5bd813667ab36b3adc0f68935d503d5378636d2d93982fc836d4a171e1a702a0cf608d03cff70c1ab379a3d443ece1fefb0a06f925b4b7eee90598b29c51247a82717d8155510eeb3643fef989f9795db773e55a8d32aa8b921f5e26a8aa071763d2c794263d3dc9b1255f5f0c5eacb0aebda278dbd1bd7eeadbd7791f315814c3c13d12b31d9bc4716a7d96ab4f39f9bb9653dee9b7aacfa18c6a4d3ad7cdc3d5e51a9acdeeb6b97b2667566672dac9c634b25468816d00e8643dd6131d1c2dc0a3be0a14b5faef59ef104e25f115d00b4940cdc3b8d6329f2fca9c89922caec0f757265c9424d0eb744d15ede23c2b397c267274c60393c53303aabff871db266e555d9b85cf81dfbce1ac7978d02fc19df050077c568c0735d039f0e9b0f980780ec7779701765a9a323f11d39ea9a9677085c8b893dadefed4ce010e19d010cc2f02ef0e747b4d4521ea0d72a2ec3df097a6231fd52e3275d7836cfb5af06cd95df8562742bc4351d4f966f11e1f745e3a07fdf29cc414de966db1afb80df066d14bf173061a442e1ec930175f9060247f78b1e62f8a2ed790d4a7707e9bb32d63231ab76d6626a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
