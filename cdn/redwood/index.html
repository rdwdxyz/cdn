<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3643db1aadb7511431452686d74f442c17907930877cb614bcf1c31fc1775d8e3117b3a466c0a2983c2fce636c4a884a7cb85cbf60bb35d791a2eccac1d72502229aad4170607551c0f420e9b6be89c711555b1a33988fe0228f269c29733be5c5e34e65450c6837fbaea69d58dae84df80026597f07cb5e6a09c432c92bf163e7fef1c95f1467afd65c305fac6d3633c735597a2984bbb075ec630d0576f5168024ea08b6aa3e65292db7e78267b28f7b9ef1f4dc615863dd5bb78ca071b7be642a38a01d14deeabbf16ee3afb71eb1af1e6610ef13791fd4f9ea6876d35265615eeb7b1eec5d2468167a093d51f76e34a82741b5aad1c925ee0c0c3f70c60bf7d92f6c8705472d8b0d5abbd4dc35a0352228418aff62b2fc2ce1b8b5afa31bcbeaa8b7dd25ad1e3fd3e1c41c7a94df934b6a9f5e1a978858118d436a0fc52e2e65956ae23c6149931968c8cc154637a750291656e5a75114baa81ce28e0e330909515dbf6275749b05016d3b319885816b8853565112dd132a9b667982816a477cd9e35a36099e03c6b2b7fa5f580ece16b7b1cdb3267433b5fe1ecb9146d1bb785f73b1cbbe704a8251a2fef8a4bd944b504359660fb6fdae81a46396ba77a7ac625d7b6e9372487ef0ac1f86142dcfed248e87fb63ff8254747f3dafc5426b7f61411d307cdab8cc382deca483c0d051a199b35f5070a82f02107b60625e39c7b8c7701b0a25c4cdd8870b66a34a9031547e9aa5ead867842e76f02ff76ea17c2100600787f40fc06824839b16313a56a274e4eab65d910a0a2e13061887779f4f386fb5a731e15a78899e1d1388c733f3ce9ab9ebfb31b4dd3eff581ace6eaeeedf367916d7cae36ba2c807790950b24409634ab7b3fdc32e8d00ccd0c3c812543efeb7749c379046e6993fa59ba6527ee8ba05ab25dd04322cfb058f5099e4e3ce00d5a24b8923c9868b7a9068c6d8adc96161f34f6dc28e895816364d35fb7c4c14737bda257c5bec92adb0f82e16c4bfc4db313f2a31815e71cf8c832920164c2f26681f8e50148a004aa7d4c7e94a5224963de75131eb7c2804f7f1e84af3af1f8d55223613e1693b939854eea8eb4934c03cc47835a8b741bef8de572cfe81c2d30f09512a44112da8720b0992b40e2abe0e9ed1f3f387db3eaf76b9befd92fd48b6fa8a255fc4427e0590eae89a01120429c712787147406c165d24a6ba4c79b68581f790fc4b41714fd89f2f4a1d66be90b9072cea0c82e1c46858f50979becca469a8a5a779bd1c9f3b64cb709a31afa1bdd74739eb2144d8bbb6b88768ed8ac23c74c8788f8d6afa2008f2e9f2908f6c8f35aff4aa64f48cb64ee6be8b9ece69a1069d9fef465e8b26f94983cbeec29940a14ef24af3fabf072c35908cdd5f95d7faca61ae990052787b5e3008ed1a1cb90173d627b0b599ff628a99dd16978eaf87ce629e4be694b2808c7a2dd75f58202bbc1a0af8e6d7e27b6093986a6e203fbf57129e4184c959a34bad5c835decb610edbb74acb200f7efdf1ef78b6c7e94a1ef9265afb1fb4d6acae620fcef77fd7ac19983b9d3620c620e9e1f3c107205d6e7d4a8972fc939f6011fb2a2ccd900e98e38b28261bea76544d18320e246ec5a12cecc1f95272cf89e69b3e1a6fa28671df0a27c2347b0561a4beb5804094718b3d10409a81c79b03bc4efedacd89e32b0c16c0a7ce3ebddd55c217663cf3ceec985a14cdeb54802f63b297e47bbf6342d73a53e83dc46716a36ce28544bda04e62532f03168b4304c545b9861310c24806799139536ac0870c53ee71974183df9f8cfc3e67b47b06a7527583638fb9688e18d21363b6ecbad610328bda14a9b4aec39c1e2fd6f9597f12d524046f65eee3f5b5b80aef084019d2eea81dcdea51443480f79e9aa9ff83d3b7256d6572cf199e0975c089bff8e09e961dd4300fb3f52c8feafbc52c31b37721e21bcf3fa1d5e679067783a83c5e91eafd05a32f46b770f5620c09bec3516e882b616892a113b973d92a9404c11923c840640293f41a788af62362dfe017ffa72409a1d10484e3ee7d0e59888b4f60103dab3bec594d3a3ae9330704812e79cd7dfd0c0554d426738cbf53a9e790fa074ccd12e2f1ae0cc1c67cfffa3a35bc527072443c60f5fea380569032b2a8891091e8d50c113430f20d1f9cf3a4a668d49f2ef095fe47fc4d143b01b55b5dbd2c44ce413c99872851ff6bc68c80d6e4f14bd793cac8112a103295ee9edac6ea30264ec19c9ccc55828d49bb0a04bc229b90638087367c91f4463493492a5adebd5608ec57e39c71c409d9f540f6996b392951e768c42a0529075cf5d588189b70362e348291ee30e6dee84197d9b53ee0313cd2826a05402b1b1308caad1f0c9a0195da12e035ee72eb915977f2c3a093806a245291dbe1a75f22945b34adc7d56138d8e7297543a3bf6ff662fc1b2c4c6dd876d7273dca18e7b8555f10feb191e3f665e5f66d33b1219b2816b1f532312a727775cc68be3f3f73f95fa2a3474a89343f7966165f663d2e913e7400c4392a9682c51e0ff43e7410d8a5cef78be4c9afcdae835826606da5691eea101d9146b70cef79a3ab52588d9d23110df8f4e279a1aab262dfaa48b63d47f882f618b665264bbefb0139ab61e6e654b41f5f5c7e3485339fedfe2e42251ec663426dede4aad032017d07c60ab4d0cb15947a6eee1020eaca010b8955d9903be8df871e720cf213e8251b8fcccd59f7a82f67f3e8c33bcfdbab3de9d4e76f776a3de15a0b957d13c666eadaacf36a1137a964a2f00feffd352bb7639a1d8fb86db6aa36669ef23bf1f120d7aa0ccf42899abbb475d2d71501c088299c9997d0a26053c44823618f777cae8dce8b335e0fea3fad5c3d604d7dc83d37a724cee649b7126e8d1ea00b35ef771224941f9865646892aa7abf748e0c0327f42e8ff1da183d989068756d4025005b435874fed4a52d1617a8f56ecd42dd863db02fee879302b8d457230c25f3ee7a38ecf7b1c11578666bb613ed08a72026c08d9967cefb91d065ffd8554e17a9f8d5ce27dfd1d0246b9368fbf158380b6e1e4e60e630afe1d6d5079d19c8adfe6bbd9bcd9969a48d6bb281b3a332c1373f34ddb32f71785ea1f19941b1e6b72f2f7ad497cf2ceaf1eeb382df2330a6e7f5040be3738234bde94ddda736eb572fad3c0b13e192ace200d336a78a2db8fbe97fe590297345eb1d05d862bab1624c91a618c67f324be99aa23efd1dad91e133511ee46bcec45762d97d43f47828390820b1e6ca2c62ce85af33afd3a47d71552cfc05459bf37f3436df570c1918c32af35fcabc4ba218c4e48aad11aed3ba92014a80307c32e5d6b15842656f53769990e58866bc01bec6144eea23359c8947451b453558e2edfec3615f77bb12e93d5986fe36c4b7b8462a04bd95327568c3973dec81fe6c2ab5a1e7b6c9dcc86faafc7034840dc0655a5735af1f3fc0e82a663b72aa35820576b5a32d7b39371d07b0dbbee42cfee8a1ccf909a4ba05806061177be4d0bab74b36a48c52c547820d5a583efdf45b1866301f0b9737a455b61236810189b7e537fd7b98ccd9d7ee3f2338c5c514ee883962fc269df1548a405d636c1129444d4b29581374c93b056e16488cd6ca8123b7cc83848c0cf67950957c7bbe3b9fd56167d597f8b7463fa56dd17a70353499a7d564626b3491b959daa20134e1d111b7a50a9e85a7b2d2e037ded32018c8c8b5efe946f31d7bea3ece0bf41fa6319e48b0b736138e6f6881d2b6543c940d751e23e7dbcc48d0822f051dae8600f0aed85d59ad2b0bafdd4449aff964ec41706c1b2023155eca3e23379ae400d97c31cd8e69c5fcb5e46439eb384ca067759ef04bc01ee5e58854cc337f80c4a949154376e183e808cacb1846a804170da37b8adce9d872d8dc37128c004e732e95f5730b81833ae91a99ea72e594c777a1ee8a137c66bc7b2e3948af69e12426428f321e77c6a9feebc561eb60981e088e6bd16bda168d8301859fca759d401a183cc63a4dbc5efc72f9e1064b8850db5abc55b0fed5af08a253cb71d69043b3614b4c59056abb7ba6bee8251f1845fce6c073b5d5b48b62c4259acd59321dd0139f15ba1e87768505e59626121a31cd9326f8c81358c13ea1384c06250d16932011d000fefc9be9d80faaa66c5ad5c537123b45ae22db7e023dd3a07f24ad4ec198fcacb7642ea59f72a2a123a324357309c27a66cbaace0d31ba157842441f06bc10cacea3f48eb0585fe6ddde0b33be6b4d46a8a5b98f84dd110260e92decc263a23235c75a0265478aa8ed33042ff0eb8c2489e875df82601a51db995371404e390a9b0169ad25e94b8f93b0d2fe38f97a75cbebbc4738210c8388b52882858588138f52b8086074d37adfb39345918d409e1cf8a7d696890811c1044cd7226f913e538c788317d5322156201cf1aa8def76139fc029d59d5119873e5321abebf4fe40dd1afb4221f8274c34cd8a15f6b5ef9546e9c689ac694add25c409ec968261452a1e095277a6426b851ed0dcbbb08eca12fd0971eb8d2e4812ae800e0ce6d0233914a009b9b5d92ef64994c590392e881a22798421af1121150111a1c3b45084e29d4b3566bd4533a78261dccb0c76c713a713f8dc507da17f614e42e3ab223492fda219a3371ca14841cb5f16353b3df19a2724deeb9f7d6354c6eba2dfbb50d7a802fbdd9321f0509a140ae1cc3b61355d2c01f4a9dbacf319c0ee0992d619b31c40c37fc96ab195a9d80d32d60e8ce474f4bed05755f323ea39416c2e57c3038ade6507f3876c706f4e17635928cc58f0bd9c4f696d0b12543f7bbce63356aef6164dcf8cac9d3e40c2bff7489507f8c2dee8166429bd17b726766710a454aded2718fe435c6f7b01f96ebf1ed8da017a10d0b2e3ee7a1802d9ab6bb8341614b6902e8dd76fe731a6a73445afacd5693b029a745c330dbf48202782064913a55ec5968ad972d6456bdbb8bc9e6044dc99613fc069c271492fec6113eb4a6221c4d9da82ae868d44518888d0fbeb51cbfdf5a4c0b8441a2fad468e116b81e74c6873974fa9bae467fe29734dab571e749575976fa73a06e40fd7c2aac734bf4573d5553904de22b4e583bef264aaf981702d30196be9bdf8ad0abf1ebdbc643d9ad1afd7f7f0658b2a514389e00099565aaa0b1ac39349417c6b70cecb05e0f4695f1b06f1b9e8ec323405895e01cc3efb872732b469b53f3546f7a587f7af01379575a7f93560bc8ca55b0b463efa5678b1cca8ab7a3dfc7f95f289b92fde2b23370e63c38a6da9f0fd6232db3731f99fa9ab22135a02ef222d0a8f8703c3f8eb788355e85015d206a4b5121bec2fe11f2a8b765a82b1244120c48593e15c6eefdf9c42a82f76bb50881779eedbe76061ae186a13887a5bc9ed7b361b49f7d21d1b891eef722816ae622ce3a146ee11df50b7133fc23c8a184216d13a2d2de985e061ab9da98bb908c5617044b34b5460b76c9429cec4139da0d70a22cc64c0a925bb6add1e94001b071de905cb76c4d16250f5dcc28822f73f85cd1551b75bf2588fad4d155d579ec9302895a63dae3b6aead9a5196cadcc8f01451a33239352febd53e705466baf2dd076ce6def9fc654cc57b779c3a8dd892132b7912dd31cffde19942b1e45e1de31dea49634f4650961029b23deb320436a82b05799cf26b0d4be32f5e4b8f72c14443c89e6c672102f53371108376a0124e15b67d099165e2ebf7dc8e3bcbfd65e334233f9214c933fcb32f532cfe97c870941e5043d331bb1e420b963aea69683a84c2e091c4453b40e14ebf5a50c7eb4f17f19f76ee656899a6e28ce84e5a6970d86f33e641e7ab3f8e2462e4d3c4760276e25e198d4495a77a9a6878c3f238c513c6914779487331d1fe2421a62bbfc9a2b615b87c70f6e8374b94f603e5f39c980724cf99acd9001c70941c015b327d035a392233bbac0a88f107258ee05fc2e3c6e0aac8d06c6e025a9ed015df025e0bc87d493a40e9d6edc74ae8e9ba599ec40b6dae8929db3187f68d4cf64e4f53d2389d068c4d2d8fa5b6eec5adb3ff49a19a3e5d092db7c0be0b25136d9e29dc77afefe2ebd82c264fd39cf3ffbdfeee03b196dcce23fd38318e1dad718807eaa93453f9132568374a63f44665c557b09c1481d8f28ba8266951a4da0650f96535bf8a2f05ab097024a0070240ea04e9255c55d53ee5155bf8bca5fdcef187a20eb2ea73d10fa5b3013c17521b4e62663f5e53c809d31d6875709ea7a35e4749d4621e27bf6d63219f951bf087f4d195939ffaaaeb2663ad65e843c98a0f527405504e6576e8e89ebef5501cfb00497e4a426b3997206fea481d51d3e2dc3d69a5d7926498a6c4cb8fbe60593bff4b451040b89e975ad1814d83fd8342aee2c4acbc4a4905d86bd0e20743a3634fa3b08042dac56ea1dd81e82e8558331ff8972031fd60e3fc1e8590e9536498d8ae6a92d6fc7ee3326faf8dd5bee508f3a156ec76d5e49e57b9f6c2b1c2e3ae1219459ea6eb2f77d21aa2b74d35da6523a65d31a8aff84f9fc88ae24a3ccb4385057bec3d1d48f506b479365c252c1a6ee3cf3509ab57e54ad9b1497a0d2e09b7c11ae67ecf3e5ede6ca7dbcf9b522ba63b0f12fd0e717718bcf2768d0d8981c394afcbfa326a804b705448d40d87b89e7f8e443485523eadf40197640ef8f286be4d64a9a5bef11ee371f75e9d1ff104bbe697b763a73f9d1f44bffd56eaf1bdfb997963ce976e2819b74804a05e52505ad1c93d1fc21c68e041dc5e12fd57d22d6bb2afbb088ae57af84a7c6e6f72fc9d1b44ca30d3628145eaae6cbdd27597b8c53a0ec09d478aae59e92ad815b4f02f4b6c77abf13dd8aaed811ad639298ab29d6ef4d608b332dc61d26b26a0a1901057592a6d10df55f215c99d2f471a55861902fdcabde4cc8e46a4bf362b54daedb419d5289a406b4ac61e2fd73a54ac0d5186918107a4b1a60c19f9cdef622b296cf864cf495ffa8e6184c177dbd07d32b90b3e31082116b0817c41ce2bdf792345c29ad3302f5ba0d26b56589da350f5545e6868261aeffb58bf3c561a1602d574e8de30c0a851cc3d4b0dc6d4cd097ad7bbeee8401d94300f3ef9d211042892137681192e0db1c75b45b0dcd6b471e3d7f686dc3aa0cbc6a10748f3d2eb61c11e37c8cb4afb34caa24a28a859396f0672fdc52835d28ad54ed67b766c489c4f12a784a6449abb75f426cd44cb698804338192dbb18571e41226a5a7cc419f82e93dff6c6150e569def0f6dd55a4ccc33ead358aa4de9baedcc849abf6ab0cc9575ecae282001d18061d244b57c6f0cf978fa8d1b71f1e1aa58a27d284ae2b950e1ac541c36b3f89adc21738696114c4cd186ae88885b68bfe6d7e765c6a828d82962559c8f2b0e323938ff01c3272821a7fd7e7e9ceaa2a24f583d9498b1850a33aa76d6765cf13c9cc99033ed07d75d82c6b3c92c0d658a643c6ff97002b35ceda122126493aa757a6f08eddcc71ec3db93c3562e6ec1a7838d4e97d3d910b76e0aad2f6e1e74dcfe9618cc0c8afe2a29419531c298e5f0a6f42cea9e1f4d1ed637e625b2cd98d3f5ed6629bbf79d412314244ea9e79bfaa4e2ad418554d5d0d2607ca597acfb19b2f59c6518d731ef38df6ca6c26397fee0c37d418444d45b996d9cc4a9cd8a33dabccc67053276a591fee9bbf28b1ef3ef1b0b5dd22b9ccebfa8d055ee76b79e13163f589459fb109d343c4bcd38107515f70b3b9f8540e7bafc18f5ca69833946c512d817e0b95f6a397a6bc1b5cfe248b3bb2c6d5eca129e629646dcb108480831722f441d5ed48a81c5eb67b515f53b778d4ecd7c847eb74cf64dce13734fafabae0aada497339b6fc43bf316d5778b11472f59c9d3ecbfaf79951ee1acd6c3f1ec66eceebd2c6e67eba1dbe57b023a8059c3870463ff2753a73a2f79edbb2e1732d39682eece6d70928d706d7bca6a07637a8ffcefd3e587fa770b936fe9fdbc3622a15a8d39f95a000ef5256c3b0ab9b415b3a6a7c6f11e2f759987693626d86e2a0ca17005bdf1e24b2607d588af769c21448147db0c44cc7441d1ce171ac4452260001f39ffe82c68140b6d43367bbcd3ddbef9910202c3b609378e8dc1d0e8e1a9a198264f1fecc13d53948634d1d925ccd7eb21212e72ac17247f2d750458f70968768cf52df9fcd17d7febff0b304e9d4386eb723aac3b068b4516e93bd64057b7e8f58339b41a2f51d6e7067024abc6882ea00748fb4054307120a3c4e218db2e31b0435a73fa302ae8cba37c48dc38a0c1134f61f6f4f59b0f72d1409938eeb73e1f294f30b3fd4fc2a31cb08f14a22d626a83bc3c9139d599d9f7313914e71463e229452dfb40fea8af51da1c4b0e31e0203a7eb75293573962a189e791c60c31e053519d1660fa920ebc166bdf11e0e9db077adcc1571934eb11dcdd3ad193df16b990487ce1fd2c310450dc97ca58561cc816d635b50a704f8d18474334f3300a350f54797d017317a883998b0b1b812f188a064aee1f5a7769e1a27ecd04e4dc439f939582f5dae4157d23386b644760bacff3b8816763553a4ffd4ddcc40fcd4a40129a9b7267ddaef2f9a72ed0ed84acc366303fcd260d05a922de0e01e1cc9dea32d5366b3b258031254abdd14cc41cc2a2f526686a2d3751bf4f9288c157ef8a938c63fbe822f73c57a1e0dee104b1e9b9975b8b13febe3d816b715d713f60e7a77f2576ed3250d3b7387c61a66ccc482d278a91fd24f7b48131cb8a2afde7e6b54aa99b8295fc5a76ead19269ab5f715fe9ffc67815c4e74487b2067407c6fd971a6c05531b6c956601d61e253e0858d801ebff3477efd3d6cbc9741844ded79676dfbcac3a41199e6fa9353d680c3f8e949eaffb0729c4ab01562efe3568c339a578bd8059e8a0d9e7ec6416541328ad46938b5f3cdfcf25d6bdd9991e203f40e1b133e43314fa828170eccf8edfad60959ba1c8a7589b2d45b34be935204a0ff7d49a5b8c503fc4ef816c1d018e5eb40865507ae908d8b869cd20cb873682638e51c42956faed46312677e66117f78389fbd2d55160b47606b683fb13b1fccf73b6c544cb1461de76e2c96dd25455290bf40f17ba6eae4a60968f1cb2e50c7b1dbd085db10599ec7aae6236e87c57355b17a03bdabeae34dca7d4c5fd667bf4b05a3c9e0b14f9bb3f7d9318bff7bc840e0f037fdf2a328458df8440fa98deacb7f797101c019af5e8bce7aabb904ecd321651cc4556ea59ec1cd5a3b36757bdac92c3386dec0db663d120cfece206a783f7b09dc58528d4dce106380f6d127db2a2d9e0250feaee77626470aa68842f4238e850e363175289edd766b6376d5280874048ca4bac02d23a4884ac14c09cb6a8fe8c010fccd9437c20149900cb557a7c7228b5d4db6e5da3f816500c666dd384228725d2912a4540e08ce20fa91c66296318dc057aa20431b33eab1200f367e9a0705caac9cd7ddc4d67f569dc4090aa901e6bc1d91218d45a64ef14da5c1f4e7733e5f861e05b807160acccb82e17ee66ed5171fd686cf08f2f852c5bd162d25a4c073bee01ae10c7181ff5cf8fed58d75d75d2137a248258d91d2cba9b669c6c18d001f54bdbde4372b3ed049d2817be95cce4afd78bef537cf3a1ee6dfa9a7083b76318d5202c32a9283f8a2efc7268d7d14919e394eae007310b58d33c45b81c9d676fc0b4a55e045440b15f78b54effe5a70782c5b4e49e0a7d1f7f86ed748e86c2b024dfd1b57b9ad41d68d745d4c43dd9d03a96a98197f8bc55769b19a7af79af4ecefe7746950bbfdebd4d130759d677cd9172404b55a38a8bef0d6b096a922e3cc5b99e50c56aec74ab493754d18fb3ae5b1a04d67997e039efdb6ffd663d167f0a1a045c2d65fd1ec92ea4ea7b59dc93e4eb02215d3af524c8055355ca8de0d2e32641ac6246d9213e355d0dd31eb1d0a148cf182250d21bd34b813f17d0db2846e52138f1795387439fc20e3924f6ad4d461a7d8f4d7ac77e0497bd42bc33e898a9db654e5abdc8e13be45f4eb082721d2f1273e8c4a0733727e2c91482eab569ed0997809d3e59f3ea7d40e216336e1654c4ca3cc34b2a03ec09cb50a9fc89dbf5c7212f2f945a4933b2caebf80e82eb614d63212bc5a9c858fbc2feb8f90543676a8bf2055b21e83f548725e4a27b7506e9453ecea89ab78a16457747f3145382e0b1823d5ab4f8038c8770f11534f63fd9a9571690e9abab6508b59ca874db31c6f382a73507028b0912abea0028b880a64cbb9771dbd381bdd87626df1db3142d23ecea15058caf1ec71a8237b079c39cc775c3601c19a1c7e51fac05c9bdad4f37b398536b97556ed4785f021c8643f4e8cc19f9cef0e3755e39a30830ede0b6eaa5ab3f8bfc971d7cdd9d3d0caa1876a628cd0372b9e31974e735c25dcc1c57d49db5333f48b61a047fc994d85b5345ce5cd490c05b391f444b038acf277b3786686a3930ea499b3f224712afef74953410bda348d1cdf041226bd0ac6f42897cf2ed143e92352c6f4af8cfe8e1039a535c67fdc10bd9e7ea90e5f31e1acff706499f8009e636dae7ef7d6bc945a393c6e32df0ad5129bc978a381145fa01c5a3c0415468455507e9f61ec94a0dd1444a83e1ab39f0ba0edafddedcff7e6f5f2ed61d0937f3c20ca34c764f641512227e8f1145817b0cb9b46bf2f38468cb0e3f0fb6a601b1a41e3bfe6fbe280c2af1c11ec7e1eb571e637a16df02a098cacbc3ea100c54c9bea1024a9d1de7e3838433fe37037cf993a88ec5ddafafb0963d981d1cfc997cf1460a7d7873eb5b162847bddd7feac4010704d0a2d8afc8cd06148ce81827144c3f5c575eff3a50d333e6221db33454ed344f900800e1f139a794d47d41a59a5a03c2dc896532495385e9112cc4feee87e3c403dbce9c379345504200345f62e60ddfb80f6e3c1743d16cd42a4e5bd5b3972c2787c5ab447d3b6b13987edfd2214257126e8e831e79720f94d693a2fdfd5ba867b74f4fcf79d731d2cd072840ee13e63731a7153550671209a9eee3d631565532a69d384b1715cac37c518752434338bab153f71912fc557139cc69b385ad1bde8f07a5326e477b3d6a45ee7c20182d4d091b92c495db0eaa7a1d9f5a6ea0b59d0f3726b4ef5419c7c61546d40507f38b78df2546ef58a7a0c861832136731cee89e9c729c3d87145f7652358ffbc2b52bbd94447016a2230d71982e8cfea976702796eea3f42446233baa30a547e27c349794d7ff15e42c6e6b7e892b495a356ecd7ad334d2dee03604680e17a74d7461544257424d8eaf80cdbe53db215d2faa2f7c8ad49b73a53c06ee2321a67484a4b88c516b4ecd8a4dbfbf55affca232c5424239c1c112f3dfa363cb3e6e50759b4158ea10e1d335a4a0b2e8f53ff8d53a177badb16117196a651117c8c2b84b5cf31de5f2daf4667d48bb35e2bbe1ff09d4a84db0d44f4e62b193b7c3944684390b5332104d78d77f61ccfaad8c80b52958fa5210ab50b25bd43dc776c5a19cc4c05dd18369b268d74098621e4cef812eb6ee565e6a122da5bc9f9d63119e0757327ec1ff48fc0f0a63f816cb9b8f6fdad240e29254311d9a36dc7cc7d19b0f1648008e2e59fcba6b88d7e9f4a240b3ec98db47e512409688026b008f045b4c600f336c82e897c2ed3c36ef82adc1053cd6ed6de0847b15311ae312b81f2436cb93bf5f2a3642293381cbaf7169c79f8f60d76ccca97219c979fe9c3dfbf49c10392369f95655530396b9b7f360d06f4d3164d2f82457d14a9455bbebaaf7d0cd883a644068260ca5a2fcfc9fdda81165a0467376387906bc2093e71c51fda11169e86c8075edd753b72b30844f8dbd5bcd9ec755b704c2205fd770ade52c5962ed2dc27a75ed78ae22aa0ad736c62329e1af32fdb387e9edf5f9fa89337ebafa908d72254a751e7355b954f1766a8aaa823892b0bed8a2b96760487c91e8186c30e192ff49dc7a9ba41a0a15954df2b5da3a75ca87b6438f47fe26927ab55b6e4c49a57f54e63d87556a26f9c824f630b80f12e05ecc95146889ce74fd594890e5817e076543d2a2da03b16ba9179f317bc7440ca73aebf6613b9064cc72b7f2b787a4f6d8ea9841d94cf0d2f715a1c15f64ba55ede8eac726c11aeec417ac750d3b43d53cf690fc2c3ff8be9918f57cbf33b0488e21472749940bf6cf6372c1eab6cbd45cd6f5fcc761969678cbb31a417235d43e7d0ba18a32b436133ca770f55559d17c8227599214cacc9364a168269fadfe3601129852f6fc06de8d3694821cfe31b9ab1cf3197d667ea2a262c7b8072819324f609fa574325cc5ea3995f58b0884ce83ba49fc4be667bbf4ce30fc63582fde322cbf7e24fba89aa5b3a06541c518781123d432a27f76ef9661869876b75f48540d136aaca5106eee6cedd2559c99a3b2b8535cfce1f9a07b5adf0bee97412d03c5b311a26f7b1e857f9e7263eaa349a049f5a209fc179266d022f89ceca9d6a5d00923fa25b887d30e6dec48e793f48fcb92df9de6e3632c4cb602aefce3ee1ec6804a242c8e6cfa3458586dbcb4b665ce87f687f0bc5f8ff8ebc7745d442e08b94aacd22bf53ee2378cf8670bab72c2f0e2cd4f1966c80acc9a063011850f94f57a8652ccf0496e3b9d5b41893750cfb558770acaa0508fd91f796bcf999b9ff39ad679843122e2c8b2fa6e1bebe85162384696f801f9e09e0611d86cdcc9e05aefeea0bc5f304a3cba97986c884e6b6c872f5007162afaa1b0f35e6263a0fba8d962618a2d3da61d1bc3a1c213b1aa90fce6c68ff76812fb854b331bc0d687d309fdbb4fc11a41316370cbf206c80d4474ff6af885b3ff2a06f4c926fb9a71622d4891677de66bcdd46c176471ec517f0cfb13d2d36808df2859905398717ab6598cbaf5e4d37183b0ac691f0de2411de59d4b980e05a5ad2bf797cb4e88661eef8cc6e845c7e00824322caf8588639bac7f19711251f62996101fcc79d2a92fb93a2d1d9370a19953e4e9d684e6c1602ae72e44e1bebce5e6f1201719ed1998eabc73b8454be932f790a61026b482777d1db981a4cc44837fdd07e0612b7d008e51100f0e11f8621900fd00f34056c6f5525a6f6526905af48e16be4280a9ab723d438b29b8f7f89515b7d911eae58aadcd04eaaa344051205c8c2347b84510fae9e5d5b97bece32132a1c7ef9afd74fdbda1d68336d1e9b8f8c0cec17e53535f7c8271003dbb7205f5b6612c79b93d7eae014696e7cd8d01eb0dcb2b604c69913c7ed5b820662af0f537471ad001ac93a11fb08a14ce3e7256e888e2a0f314561a779f43dfe1ffac304372ae35918c784e66c4d31f602954dda4bc0e4a076a9288a9925b977abd8af3dc8617538e3d57b541e5b37f62dbbf581bd5955c8bbd911a4c8be3d0e989620ad910bedf219b0e5bd732e1ee87463e8b041d4c914136255b5cc80ccc04a5ea1cee14cb884793d88a0f3228bace4a53cfa4e4447de1de63815a668b7f38ed3cb007e002ce2b5dd3165e4108334fd3b4e6fed8cc396c7bc872a25053a0ac68914b9994e17d2af3ed0fa3087b12a4ca51d70b2fcc85079a84336a66e37f2f3ca43c8cf66ee15c8208b7653f7992d35577b9975a3aabde72cb35ec3252dd3ade61720e99ffbf7c83313aa702789de0aec0cc1acf4c1330db88481e0c357128e65cf9c9ce17794f497ed93735ea79f2881fd57f674edd192a8e8e060762eed071d8136cb48e0a3a15df000e5ab92bcb27dd8852ddc7570ed3ae465e5708b7b5e15cb22ce7d9f52ada8a48554e350961e94663a1e3024b18645c7403fbcb5939af5127e0ee34b129168cfe0509c24d2a8155fd285fa5d956572a4570885598ce9386cef46f4de0b720e97672a1548df09b736e8ce6718f1c9881efe68e8c9c6a19b7d43c93167d50b44e33e40d678082ea6495be260e9f745535f1bd9ca01f847b757822b1c8c2cec13db6c0e952f2f1b8ba5e452b7223f50aa49edc7b2248d3a3cbedf78f7e83db0172d75a64a63142712f09bca9ffa80fcd3bdffa1a0af1880ea1fc1912bfb42fb90eb798cf0f3dbad04d569db9b6fd3806d178e2ddeb204ce8c23d448c7c92f1ea0d80d50e0f7ed7e17c6c4002523c87c4c8f1b8e3456ab08d9abe4f9e128d16eff52150291a04401d8c9b396e1bd6fc6ff8d2429bac63639d4c92658730b759660d9a0cd74767226dd955145d6cf325f6561d0b4c869bc70dcc84d337f54ada7380fca05b786e9daa2f65f7f8a70733bda565e365eb8710ccdee5484d70f166de58352d74736d46a4b0bd64297820c07159eaa157d4fd19dd60d0c57b24dabd1a3a36d259a42ddda70b53b71ffeaec2101572738058df76a388f517a1615766924b6f7da26fc0dff813b6030fd85c5904109cb91f29217de0b124d25e46da97fd139a5f7a2d38d5846ad66e071e074a26b37b5c0d033c2a233d7a49d21300f1567c0734fa39f6d6c7ce7082d895ade64e762c9f61f57725a58680953cf26c43adfdbdbe178d29efee49ef7c5b280281011f89d13f3fc97482f376f22db2db803db88b99b89e3999032d41c30ad6f7d1be26f7c9a9a919e2143198ece1a0e58d5388bf7303e315497c37e9e5698bec56fa4eac8382cebcc7be5e0e7110cabc605d310f4f2aac9e2a320b1e3818242480de3b13206b60ec824ac8b0f796f563a5f63f0ab0c338d1bb88f762331ba5a4ea2ecb6cca8ea30e4939446ee850311790d292c4a5fa1c5e77b63387dc0fefffe32cadce7a153a57d20c5be972154b03ef40acedb4d8c7a5f57e6eb03f57c072ed4e8da142583dfd3b7668c21f411d179c4459cc1b4f0590d7e98c55d5760c12a9566caf043462c376edd2df0c1b07ad70e83a10e1eca0308a3ddc51038924330b2030fd46b2e026b0422d0823cc7d65aef9834e1fdb2fd16ebd99e3cc16dd3591b588dba8cfbd0965ed47d9bfa7b9083ef973cdebced1dfa1847f639928ed77aca9757bef84a4b7ce04e818d85a45545e39efc991a9e21b1c3cc2493d416aac3d838844d0bd72d966547916a09619fa5825b08c21a38093179556a243f70333f353b3d079681e14d9b4536ed87d16aeeaa218554618daa98f79c0451cdb2e7dcdaee0914086402bba74cf7cdf724f29730c4154b83f86e7081d140bbcf3bd9b15978bb2e7eaea33fe50b61f72077f032898cf43e2438e41d32f858d846302f83d1c2dca547d668d0bec27a24fba3f50d34d1b0f3dee577251e94f849d36014d15c1bcbbc3bd54fce9b9384048ad04bd787d143ebd27fb156aa78b2299a2b35ad7dcc14e69d8c8d9fe47403816858cf7dc3c85ebe751b2e785f489d3158aed210c081f1a31546f39107e672bc91c6451f8b245be622bf3f23cb325cfb70124cfba0102699a6d5fcede0fb376d738e42bcc033ef80eecff0bef45722c5855c4a6ee835d3cad1ba1e9d8ab2f4c58eb545af866402867eb9da4e9dfb4c268811af40b062def142a861f5db3b5736fc81e0b6ead52c00448c0db3b53683e722d78873abfe714f67bd3be6919c4ca06964a468e2c767be746096e0131f55657e0d832ef3f4bab2c61c32d04ebff9b673252ea4b49fc4074ed803cd3d393cabb0a58aad5a424217e6e61e85391f0c18c2ab79e857bb87ef4094c5d714dae26349a19cb3abcf9b4b55cca3985a2c79e3ceac5601240179b193d211f8f0f9279d19779d53f176ba62771a20643f97c92f6b04a66b38dfae0feef2aeae90600c0b7b6057079baa766933cb76604d90592c8809fafa79b16b34f7acea68d824113aec5cc99d7a3aceaf8e139ebc206751ffcbd12f1ce97eed9d34436349f26a0616f0ebc4f0de5b7a85c97f463607ef0875c72242dd943746fe67b99e86f530dfb7bbca2424abcaae64725f1b7a2b4fd736f6c8f2631505c2f731d5319db4a5903504a3fc740f8e66df41dc1cf327a37b3dd3475c3f7b3464198c164f182c62ea2be40202988ca2b742559d9ea5c01d8f8f44600cf37fef71959db7409921c84dd69539bacdfc7cc21fef69eb6315ae9145b0f250abe2e035bd2f74a56e34e5d6749cb8ac71c03bbd79156086b12da907e74c6757ba7998bb61802a8978db3cde5679542b25578447285552ca70594dcb047720b7895bc6561e2e8ba7f6b2a8784141215b3c13b9992c6fb51fe0b6c92ec9c6b12db2de2c52032184879a0c323ca24c7494138cebc72b46db2e0204e9ceaefa9d15e8573b0fffa783739a7108d1a22812b67cfda3828892419c20873efbbd7ec9e715e0bc7ba691a97ca1c551bb044e22f8de2158a56909ee2c02028d5ea04c84a91708873a804e38d633e05eb3f643811abbff5c556ed9b3154df6889cb5aee9e2f424f33e60e4dc6a501d952816f254e196792f8b512c5c30037e42467872049e7a601f840d710fd5c2276bef07c1ba5fd717157ede5b972bc63011ecef48f9c062542d7713b21edec354d9ba161865f81c1657b91bb50943fc3c3167fd442f8b86d547a58ca13c06d300cb3dc6c3659006a2b93d124a1955cb38f61fff9986f16403702fde16fc10af488699f5c395d057303d789125411d7dacfe98d81922113d5c7de89f4791f50314db38b3de0665cf85b7f5ff3174ac77b8ab8197ccccdf54ac93330f5f31682d0aa5f369dddd90ffccf3c24f25bfdc140cc5cce0ab33c9849b760f8c13f8e92fb1fe7347dd879e960497e28b2fc149f136cf3f7603a6708e0dc794154939e29bb3b4d837425664e705d73072ce16491f83a3c31aa83ac49ea8fd79fda047e79f2fc7941bed7218a7c6cb481d97aa13674f7f89901e18399982ac21ad1501d1fef61406187582277fe70828d4cf5134e66316f415d1659ef47e1eb54e651e7fda4c7ab873280c163a1447900564447f1f73df8b9a0c9eb49bd33cb40acc825b565417f32436b9d6377e0b5898f561015cc1608a94c723982c3bba12a3844fbd93002737ff0666cdefefc9f540c6eca5c591783d2ed17eda68cd3922a98c141a87cb44a25145d394b8da9a5f4580364987bce341a28a5ef10ed257a8d9c601d771f7b1f475c492204c024515b2fed89a73794bb699540d9aa0cf0174971b18a28515307b6f29341d82ed7f76ed56316952a3be5f51d3e8ca6cc8c6b77bce1fda210ec79223367e00016f76150d7a52f3b3b96bb12f4be73f984d6587723a2b04003ee4b3da9cddc87b0e78c4ccf971d82ae9acfb1c3e4f82e98cf943f88b4a20785f09ab234d5b05798b8c6d2e8132b27b90c59aee5f5e2674a86ca4f0553a67de73c056e67e2ce80297ae4eeb3844718a28b30693d285ca25367f299a4a17ab24975e3aeab7a72a39c0ee259b9df0d5a26fa7ae748fb41823f70f241822c3bbda9d6a6926513061dc04f448f128aec28eb1137895fd0484829f84fc51245e57a895abf3a8ce9bb5f9f141701c21e4dc5c0c2cb55b8e4c85ac536944fc9179aedd20d4c6c263fc6eddb83a42c46f5b36d0d2b3bb72c3241821a5e6fbfdf2951e55b26dd58c37100685d92363b30f96496aae92bfb9c3090a0f4da087f46e2bfdbc870e5f3523f026b442c509fd14d8fdabe163e23602b01c83f94731a0b8f4377f9331ec2a1e77c6ef575b27d5f962a9ef16bf939a9a99a442ef96962734d0848e1b82234e41d3a0f9f5404d064d36370e3ec1051907f8962d02b2578bfc206ba6abc18cee00a4b538000ef4bbe552a6552e8a2f0206ee8b068be28fe568987c6e9bb9aaf86d1b02db019bfe531d86b16766fbd45480be42a95e1cb0fdbe9905c029425f7a22444212f86aba5dca5bab877bf9bb68082715be5856ca99e0dbbe62b30230a50e677e4803da1a80306a295c09d70c3dea26ea4c86892cf1bfe8e8019a532df8ec8b0b53eb37f95336dd192575252de07ea94840edad54a358176eb7baedf85c6ac3e13","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
