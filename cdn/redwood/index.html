<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cfafbe28f49c95004f2904024b2579e9b0135ad5add6aafe63d576624885927f19ae95c9cf1ef7c3a8cfff32e2ed93cc676cdd3f0735c7b1dde24a535133816f20bbc730b24285f8af5cd11823af733fa33d99e1f673fb21d05669e1754e2f45a253dedd585b0438bab71bd76af99b96467a3c566b31e03b7e64bde6372d68a612f008d5f71a967b84cafceeab376a5da7a131e702e7316b7e27e915fb66d4e7abbb1cdf45ccd5dca01eebfeb91410f8b7fb424eea97d36f8e98574614de83b3ef8499d69d5fcbdd56a5aa4763535f7aed6e25f6cc3dd7638656918705f8379e9f98d57001772820f9017ba78973b7cf2848883d7b0e318ba436ba03496f107cfe5575dc40b1cd98f4f437539d31df3ee393170b25a57d97dacae8b2f9df2f21486549c5d272bfe9b61ececef65c538c10e3efb573cca7712cfec068895885c3ac87f58f837b307421787c5f74127b439f3095b11ac6a8fe260d7f9039579e6bb8fb4c908139c4b8f853e2c8134f3cff6b9388dc4b00d3caacfe2f82ab29215ab3f322b8653e5f8ed718640584be16f93e6a6bb01de894154c0f44b479195250cf93388cad663ff124b2a14e45a40172db51bd38a77f92cf3d4085f7476c1e8fc25cc815975bfc37d832df1455ef0f0c5d5ec83288e0995f9aa4e169465ec823f799f61a6d9dc3313afa1f84e5083cbfe4776a06ce9beb31e81118c8f24b15c6791fdd2a57dc3d8d7d84be64019bb0152a8926d80b040b28f0a370f6cdc499798fb0fd436d4346b8f42d848b0a54f15f8ec7a5d987be029789a642167c75a6b57a75e3017b7ade7d2d8d6f12f115c81bb0639582c497114612780d7b96f1035a1bc69896e881063e9e54dbac2713334fd9a8d99c446c9a8acd85562a7c9701b5305125c926935a4554e237163a189adf377a7d8a56c3b6433acc9abbfb399a6478120cb62b4272ef31ee29fbf13bea4e2b0ffe954cc38d158d059b9cf6ca39d212fb27bb16a8a130b6d0df5c45e70f7b015d3a676dcf5c2236e8060c8afea9ce6d359fc8663bbfed9de0a93b0474b8953f09064dd9ed927bea2a27520ad2dfa2f2a66ac481ab25bf094e41a28a6ae5c05c8d469df36fccc639e46195161432d130ec34356081f73eaad78b2dda1fbd8ccbf04464c914c2d67fddec980687382f0ebcb197b9ec1a993ec25f002b1e3a7680b548c10eff5e5aa465de053539ed766f1cfe5dc47683fcbdf1c9b2af0288a2413eaae9766929301d802b708bd65ebe634cd26432f7ed8a612258c5897d8f4754408e818e84e75de4740d002ce900a1ed33b7e21dab9fd4a220ae632e8c26eee69da612935e2128b267b9729d92c18c2b13f5d6241e77a6d9c7e389266edd8e40e9ecc9e6492d45d50f1789b96ed8aee36134de6d21b864a9d4c3f9658d0e14405dc3d542682389e5d434f042529dfd0e61f90140603f65811ba126a5464103fc5735cbef37a7254eba6967618b10e15219b20801912c84fce7651a549280f309806656c966a0c767cb45f68b22ccbb67e1a246476cfe69bd1723b14be262201f5449cb7158f44ae90b0c80ff07b0acffe0c55df6d99bec17ccbea6cbb9cde70ec7cca53462da694373c63a5b5f922577a11010cc13bb46e660dff4a01ce6a225b4f11ce4aef3ac1bdb164384e6075cd0132d9ade6dfc6ae44510b5c6fd683d95d03afb44cbbb4ef94efef029e0da080d80d37050ca39964bac6144d9ce4e70440d012450180ba174091fbcfd3a078110d9fdd06430cd54db30b048a958cd80ebd6ae71d2beec1603af2b6933f77a68ce95226787847f1d2ad2bc9639a17e30f2428c297a1d8a4c45fb9e838af09b15bd4d7c7ec9b59c80a847d612cda27f5c37c34327b99e2a7b37974359ba875ac40982ffc1e3493e4a80dbfaa9016f71db2bd3bc22a9c20248d60076b9045db7fb57e7b138683b3ca3773d4813fadb9b62df3972bbbd01fe559e902535e274c6613aec0f2ef323936ba87606cb636339c328eb2c9118c668aba32aa9e353cd87d0915b7525ea66d58b6a44b8fb638a640af8f9332c8c08a2b5fb8255f08e7423c8cb98ca27276777d6cc7930d7dd0f76b9faf5a66205ac3d8e5c665c0945af18485a6ea1e00410802fc8bfb35b7e3b879b53977dcbc205e1d2648f7da3b575e8778c954b6d4978ce8e0381bbf01718e8ed03ec5ff43dd1afa48141109b5b2f600e801b70097cf5d961daed643225ea041bd67a85c6d415807a9ac3ca981727dd3501de3a8e657184f40552cd9299c32af6d5919444f94a6d46f69f76b104ff0bc6c8a3722891a06da160262b738e1f7a5dfe1e2df4bb902cc18eba23db4f5298fd46a7a35bd07ff8d6b79ef600b44f280701f315a35083f5e5455ac1cd89ca7bd26094312af01f05674ee29e456ceb040f51cc3dc1ae07cd3965b7df59549f9a5668cea794aa6205209aef4e10d7ef0a7c5065c13879f42d8c7f2d96f42b173ff25d93cc6b835d3771fb9664dd75fb3e623a74050358361b854df0f002aebd1f11c714dd7322a4b8d4f27897e08ade45b1b79f8617c4fd444870e19da9135fab9e61d2e6e2ebaa8c0302177048f49a3ae6b3edf3c3ed392027482bb0c77c8bcf4b4a73ce7c7813329f45655a3ce61feddc6ad5742e10af27aa306b29cacfa483db1830360c439cd92e806e2dcf5d495cdfd11789b995469daec87b548b8822add3aef5693505d64e5249049c8ddd330e387d0447a04042a8eb5ecd9db0dd4393d19a1315b55f9d2b15374ead3fe858014c2a42ee78f25d3d94ecea725dc7e110cf819e5366c8a2a868992a782928bcda1f323e0024a165667d0b06dd0dbec07aa4ae345eda57656c7f55993ddcdb1e16be9a76da7dd4ebc17a49041e37b37812db52dbfc6ebf1ddc6c463a00c9c25ef6c53f72f35dad359ebc05934b286ce494823eeaf42c6b82c649df4e921e8d28920c7153e95fb5959c9309ed83ad55b2f1d8004ccb22370f98e9acf82d5bea3a22bf0465a4bdae5ae1c49473bc55756b66aed95f02dceef68effb056563bf91e14fd0840750d707a7c2d9ff5c626ed59fe115b2509880272fb1ce095c31afae7ef5cc4ed43336a2973cccf6e385872cfb487ac92b7f97a2cee0f8c758e42f41176dd09b23dee88ba059f6d98a0ca5324b241ed619aedb550a2f1dfc87ad826802832f26a70570a05258fcc2c303815b1c6085d328252ae93ccc2ee50d558e9bb08612a7fff30f7cfa0f55835feecc844fc2d6c34368bf10db8aaf3c8eebbd4e755538a282ad2db60fd4d42a1ad8abfc13bb30950ef124669bae4fadd17379cfd954ccef5bfbc7170b4ce8358dac34cb393abce7f7a4a9fe5350ff7d549add56de915aeeee188cc88fa03b4efa2f3cb03bb938f6fe12225bea507e6e660e96657007012824ea1eb43a2cc093e4dd25762ad4049ecda93ab6fb761df2d0d03437db871570fe20fd35140af698d657d865c7de2807fe87dacda98fcae6e97ac6d0becad778a968e75f183b275613ccdad374c63745fa4990d0626bc62fe8e30c4f23296664ea43da301061274c1431a47d4f5eee4ccf6e9dc0e3ad06c4b6ee5093bd51da44560ec5540fcd0712667fb12466df7f01c0317ccf73a2da363b45bd7f5fb4b7c08e60928672ffb3a17c0614f64253ce776be80400573ffc6376101fccec177608d1e821a7b98872d226880975753a442c8974a5f4ab103422a04de206f2b16332219ade620c20158c67626e1eb3bb2325e314248b66ca52dfeafa51103fdbcb79c315688937f4bd9dbbb746c4e24fbbbd3d55ec94f6915c2e3f39b3a702cf0dff2f0a86626a2ae3262e2c985b8d4f152d8d2876fb1512489730a9aacf684f0d6e78cd86a74519d4af9d9d8cf05437311ee44751c9d712de7c04c9844e555ad2776f454c9f4c9d4dd342357b9562b280f67b81e3f5c35ed4fd38ad3c6a7a998e30b7d78a73f561efbd8e200b6eb0da4ea0bd7f5186420ed75e974a72c76a778ec12e474396cd2ad3bbae17cbf1abac1b5e6a2377ba6580c6663237d47e7ce2aeeb3ef3acfe14445a080d34543f6a916c206795371e47489c54253c05a9a24e49a9ca7ba032b641fdf3be58806b64a47dd36690fa9250b161bc9060ebf5b5eb0c8c676f1b4f0d8369dbeea82de7375973e383ea3dfff762ea8a76801e6837a2767a795af1e1c3572a6983b4edc52016bec27554fb9cb2814b8fde3e95778c777069d09bb92ab0737e920de3a1023677e071b56873768c9d8f0147b10268d0d0949af370f4bb2a6974d3aa2f67b52aa99faea302c8cc23b6bcc16dd97a6edadc199adce7149ca6b0462169f63bbf2745be0c20299d6438902de511f9d30f1eb973f665aa31d34a44bc82984e053835c0e62afdf58e1c272bc05dc1861c97d6f17bf2df054a67151585d951e7b627f71c572f0503543d76930ca6d58aa7bc5d52989ff7d91ab209f6d36bf6336a5e9c66fe2c00e148b1989865ab4096418cb30c2675b6b25e06b0bf33c46a4f0eaeff56e8f727bf82af3d8e3b67de6901212e41bc8f5967f0407c01f2751b878ef7b5cadc6a3b56c659a41e7ecea034bbd719c73f7d61030ef1a5e706c1b8ca04a3bac3478725b75367ecc366a3b01f914eb32a31a5889010a21b4ed468b5bc9a720c959a7a415650f0bd632b7435ae6a157d601176dfcdbbcdd6b318dc77f887f9b173ec4859d171f4e086a63b78b1169d6afac99743b9a9fe20bb5390d328379070c25d7319101c366e20142eb1af4788e02191ed02bab12744b2e4825f49ddf3efda983530acb4d80ad18d3b4acc7a4d9a1fe99304dc754645dcc4927db9b6660532b8a7cd4ffddd3106f4b7d7de338153aec7dbb222c40457e183acb7658fc672b3dc76255a2f1df952d7d0fb6909b9f1aa3d9b90e569d8806bf9d2b63ba7edccc45a2aea37aa058669c5330816258ce57451ccd634fda918b997b14cacb732d7f26da0a6e9ccf898e03a6d4c454b7c180029821c41fa1d8d03730aae269f5f3eb62d676c6ad9fbaf252245c08827e4fc79f572e4f433fcbcc58d831b04a5a469482f65f713b2ba790fcf98d568158cfd70bd704d0795d8404e2da6cfe679057bb8faadbda56d2a5547b8d10a8abb4ef28a6970582c7893f6ac44fee1b0337d8d8a212e26ce91be655e72641f610af075b5be4175361bc223ba1734fa7ff63f79bc520d67ffe940d9658dd12aa16e922234bef09a927faa8fcb2f79c739ca010aaa8873a7d6d3e993f9baade05d71736949776473aabda954d4bfb587d5a2a3c76403b17039f29f563391dc94d22f27fafb6cfb3b0f978f44753f75b62bb0687a104627d859b9022d58688af771746b4bfc35d32a7081e1da02e4ef32ebdfb5b259e732e51394e2004d37753877195e2d4158bdefe2bd0747014e68efb6121203bc211ea734f8ecc87c547d0915bb9fc2595b009fc24dfd058fce43180b05798f8f27b920c203aabf36ed86a2be7083100106a1956b156c608251681f7c1bb1c2a3faea90ab38844e21baec5b9708c7c01b415bdb0e352d874720ac77ccef582e4b985088ddbd7de33c5937bfcf69619a7ec76f071ac79a5e7f0585ba947eb6bacae05ef56279aa28f9d830cdca3a96d6d479746682783445144457b8cc10301c6701e6f13bd5978907900b3ff4cb831a5a7ef736eecfc98bb59ebe3d4c006e1530751019780453a6237e11edff81b87f14c7f6bb14f2475cb325578815655bfdfbe5d3e25333c69962bb4d0d098b5b11b4235365b5b58144333c04914c693a019a5d69a9db4af0909ca06225667d280451ea622bf4ebd6ca2ee692b96721822c41ceef58899b8887638df9af81dbaad7d023d122a0b4e50cbb98fff0fe6af6e43ad417c0fb35d3c72f21e4fb63725471ec68e2f3f1738a226028a2f8c7dc0968fddc2e1bfa814d883b99557713e18e44c07954038eca346ac4305ae3a6f2a60bda177023a7eebf96b7e53573847767525200f5552d3983ac89080813816d25714cd574fcdde5477a22fe24d386fd3e23175d89c0f9f16273c30a8b29561be1f675a7b35f3aa023ba023f817eeb4c70eaee59fbd7fc9a3030edec7f3382b887de4a9926cf012c4f0ed645bf8fa4aada14de36cacd4e8aeee23243114d1e43a9f3006a0f150ed625d7a752ccb7d09f1f618122890c8f5455d7b2c642800afccb1b9a58b660e4e766cc4526f795adfa145017470e73a936c81c8f5d36b58cd05644a3c9c1579d9cee91fadd043c7271c32336c8bbc353b56cdf5332c7d085568a490af2b7d4b7d200ba1d44c26f328e15194406be775304af40f46fad7111dfbfd33d717654b41813a4f3540308a68412fb0eb9676bb8a4cf397a792f77b52225b2b323748687ef93e37135e9d205dbb3b4a1469ddf028f3d480304e178d9db6af18cf41a4b985453fa11d97ee2bfd02d53d8f8b3094e3b7e6c18d0ab824077427161f9ec88b0f65ac18e7e86a2bed98c88ff4136c1fd0191b2cd198b0e6d146da71928bee78736cdd15b16cf5aa4eb072df7521adffef21ec169938c67c9a6e388d24369aca827910ce391ff9f1ae63aefade19454f5325d9fb7d9ea83ef1710023a4fcbe2d24c069c81bfcf16c897f43bb019793c5aaef5ec5ca3ced3dbbb5b5da781bfc00a6e6581031c3fd464a7b94253497a7e4fe2fc85e1800c519ee8b3a49540392a1c478d6c5ce502a034aaef4cc04cc658e6786fc9d1830375a178a6c3ba5006c9e388d3d254f47fe8d0873cb39576b0545497007ee93c5f550cc95120ea8ad8c4ea9e5e36699e9c5c4e33ca0d693391567a53dfd14e7de3a2e6135fa2e99b3afcf848efbb580652d554549db5456a446e119efb975b623afd919f212ddfe8fe8de48301fc081894b684642a3762f32266e6d721f155895d207991ea783ccbbf9d84acb46b78274dec329e9caa456fdedce4bb85b4ecd61a202e95e70e43e24fb76e41490eacf9027f2f6083271b4dd518c06a7521890f3548ae49a9c86b00a801c8121b8e75ce3ffc5d2e1d6d63a72483b2b568d037caf71decc8564cb42e38b1ac4453da1c1d5cf1b06c935c452a7c1072847e3e564ef38e5f35940104c9a4d15ad6e574299602f3b2455d0983141fe786187571d5786eb7cc68a7bf6a7a52dfd32a27abea0798bb4ca685f65cd05c6cf5612b98e06d197a7cbcaf90b518213b4ff5208588634848bd5d2499f2889a9c4b05000914527d23ff1ed804c34e64c618f628ede7126db76667d0e8f7cc8c1a89a52fd6acc8fa7b9d2d8a98839834732e03573c8f3992595bb154220c93c2ed0458e1c14e7bfe03b0b7b7945cedf1b9bf8350209e3573762cc2d591d8159170f91370f0907eb4d3de3c83771ce098f906a8dd229314f0749eddf7044ffe3a15a25b98f871f836e2b89e1b36bde94d2037384f3697b2916fbd04d6a678fd7aa3b27d95fbd8cc4760581e1c29f3e5455e23809a775920aa592a0e1a050be55af30e708b3620856c2fb0f9e0b6f4574a1b439a551e96d90e4e2673c32f618615784eca26ee4b261f9461487200618d707c1b0f07a506fd169d0c3ede4d574eb7794099a626d45316a47d4fa76cee4f740f676dc9115abc12e7f4b93f3e8591268c12e58effe60d88efbf180705eb580943fb4f48d401d23e287513b96b2f65ca84d98abcf9dfec7134af626fa554a063e6c060a5212ca7917caa44d1ec20af089a707d8d4d98d85a474a361d92470578bd9f4d962793bbdb324e246fc7e02b4ecba57b604059895980cedd83e766cc96c1997403732c60c4f214b6d8279f127c58806557e795234bb46fbe0734692e2edb39816146c0a3311dd91920e2c9570d76f5a33aa9ccf22a352e4a503d65d7618ccf32dfbc2e4202f0447d23d3805c8383fb3a95656bafb60390c02fcf98a7090a4dde9a21b54df0a72c47a05145fcd160703f5f94a1db9a495810c8e3290ff95b255a8e22d5ea39470b74b30e6a972e138cf0f3e4d8502cf3d80471b29fdf0f8884d7f9aedbbc60014e0408ffb43c4dbf49fbd672b12544c03f2a7ed4aa937ce80792b374e3c41886551d732dcfbc1cb6b041b1ef6f61a959fc71ef34c6c2798728f70e89e7be2a02093d318e0a1b3d2c997a6b3caf388ea1bcd2d720e16973eb428f8fddcdad8b27187009b6fde332570f76157eec5ff7f4b8b2c704e32d7f6c98fc7ca22822b2264bc12056272c1cc3cec6605514cd6320d30a0ca6af08645fa212f061aa83271b1cc7d9194abcb1b969de0c08c9e23c6125db39ee87a8e3a880266bda0d82591d7d0fb28580942e84b6e91000daccb2c0a2f6b2fea826494e42b5910374edf6a50ad3c326bdec504d24204b48c52a6bc7301d2c4b2f9f5b738e0ea9458d4ab37a5f55dc7fd550ea20a93f012c2e0c20fc83dfc41b92bc24973c3338b6d490bb86b3ab70d0adb792713a12999eb5642d3ae4d3a7124b82982c6d214f7777e05c83cbc63558f61e6fa719a689d6070bf3f745e8f2cf3262ceef4d7981d121285c9ce5132cc5839167903a8226ddab4a0c1a1a88ff941d3f10b502bfe747c397ccbe2aac143e121ebb7c39723a533dd9ad24e685d3e9ceef9657ddb41b455000d577dc54abea731ed547240bb3478b192427b5ce70d8a89423dcca782ce64c0049bc4ddf33b39e594dcd141b2df66b7e7d365c19a1475ba4b2a82a2f96410e22f579e9d47f71882d8183ff552f8ece2cc2a7e16743ae9f894c0eb547350e6d5a316e9c25213681facaaeadeb50fb2c456143503f4d8fc7bed00530fb9c44d4a17be2603a554a88179a7f4e16afa99cf949be5ec48df2c1e28525df6debaf181ef5eff25ee600d0a7bb7e0e13e1529de5d876ea9a5f7f77597563c6249d900c9bb284169b98325126f45a4062094f5c53075cd3c32ef8a108911e19205d3033bcf0207f4e3cdb275d563ea47dffaf1e7f621cf4571d0354467a60bbcabd60fcd19f529a17970391cf74757905e8f33a4b104f830c5801c6aff3c42b83bf485482d50da4b84c3934e6d605254c295e053f24e276cca3a8be9df1cbda5ab7df0aca9f59d39f537649ac408f1ce79b5bec22dc76e34b52229b67b654859dd864adbefa7a765def5c0824bbd1fb6b044f51a02d96b8ee3e9e2d0ec4711a149b5e8ea8fabbde8e516b8c616476f74e4d36866f74b5c1fefbb8138105115232234e9bf617f9d7174af5a8a9349ba77c3f5e48706db22d7e36cf3884311c5d21ddfcc2575d75fd21b913774740c9edf632ce4b4d07476d4e747e2d5090d5b2f1d63e52137c0f9382d34a40a96dcbba6d722d5f174662c4fd9735de6147772953ecb0d6614dab4792ceb34ab6c33f7a5214b4cd09f5b2b4971cc4da8be49c9ab17647fd0ac54c785a510fd64fcbdffa7a0bd035f13a0f49c0732e4dbcba2cf9c48683b3cd735f1d05ea6109a068c86272bb3338c4d14e99101c7247060337b08571332235313b3ada5568619eef61607a4bec3f5cfeccd6a01b527b43c91035b00f635d403853da8615a59d1a52bc0a28aff9cbf90e8894dc9317439b51b876a4f58325d27b37a9b2c07fd79d40820e65e3becbf838f1a34e0e5d491cde984331de6acb38d894ff35bffb6270e420b781f4a38454c15bf0dc9418b2b3f83d718a98664f1d424a114bfac2480c0af7127f700727f95fba29fa93ee29299790f394603bcd8e076c171056ccb49ef3fd36156d8d481a455cce9ba4495d74e7348d9fc9b0892a480e6b215458d2d1b514ceacbf16a1954820b79ed2aa3a626860d66670ca45a5a66b0bf7711b06cef454401b92ed26f17ed809211a638c9e1c7d8a231f382170f5281b37c9b559d2ba4819d96e83413f610d70cb5740223483ece4393dea089afe4a2ad2f76c0a07d3892126c3dcdb5746a8394e0b4085f303dbea2759c1bc816a4b92a070b793d06803b7a15062dcd5ceab7ee79106ae1930ebd75eebbc1df6a559adcacbabdcbf3900709f7729b91c6e671ce2390eb624156fc6ea8a44c0f04056fa2d94b7b69112f16f75e31c4109d4cdf5587a13410a8aa20024dd6ac6b3b73a7c81a8769afd2419aa61f3ae3a0e31272f5b2964667c3b813e0bb478f1cf8258992923b4f68b06f7843d65652ec1d50aec1aab7a45951df8ad0c97cc47f042b00cd7437879bb2bd7b9d1770f5ed64d7404cd80a7b79f94b2b6399bcddf2f9990bc7b281e3236dd48a3ddee7cce41ccf03aaccc334094ba167206315663c0a1105b627f1487fdbad56ac900ab909801409a711e1a5de413247fe5e83ab4bf482c065ff037dd6af866c12ec06e8f4d3f989f0c91051b5b1bafd922d19b1727db9d51a3745ab440b0a88ffda6b1eab875aa87b2ef32782a012d83fffcd550f392564b8a869353450dcbb770b5cb18676a526ce929920c3f513a3a10ba5ba63518109a058d49fe7a9c2db551a6270672ae5b37431f8262911d728f8818db8ef9a635cebb7e7da4d21a724bf0b7def1d787be124e53059f08e9f4aff3693097228522ff1b1411d0f920dc18641b26bf0aedda801b17ab2e46305f6484603011bb78d35ea2277c0c87dc67df2ffc97a1a0477f1a8cc0c4e7e7c8fe5a0167471cb11161f91177b6cda3d4ea012e370cc1a70cc3db496d243d364c8de30fea18c2800ced413dc035b50b5963ff839516d255bc749cb3a18b3d79f3fd1fcebbc1f7017c800fd6e76861c08793e7439bfac051ed66f2c83b11828a13d11cea337329d4d8684a4e3cc8e3394b1a7925e32071af1cf611a4073dda55f0041f5c83e713c0d03c86f03a8d9011d084f852358524f47a1f171a0c9cc790c06d92580c1b2300b14106cdbad067156307c740797dadae0c946f7fe886882c6d072dbb88c36647f0af606fac196d6359acb3d3415f59bca1e00e77deae8086580141ef35fba2499e641fe8d90c9b58f8366b9518408c918ff4e26bfc27c910fd5ee61371ce15c2a39c29cb3c0e6d5b541b396e5a5aab9447091a221e8f54f09541465ffb4450ead005aaf6e96be726d2a0044e3206f883d8cd8205017cb1addafd2f5a5bde1b325c2739902cb9537144c744cc4ca9a3e71c8a908bf217dc8aac9473261aefe27cae967446a196161eaf951bb0ed229fd1d46c09dd97c4793b6a9c43098cb04c99d8593633248e6451bcde700731d6b606c5eedd059d918f436738f255778e365d78d33a4697fb7afbb0ceaf7416293c93b5125cbfd5bf8782513bac357597ec48b7d91c19cd8b59eb74490f56026c709fbb6dff977ab1ed5b186e1fde50e48eb9bcfe540c6cab75b2cc7abb5ba328053ce2691dafdee333287c29492518208a514d1d88b2a536f71380dcfe7dfccaea8e4d1448e361e0f58ce07aa1b1a27d82f7ca33880aa8dce971ea3f1b3ac9aee43339372f6c5b6745e46e52ccf644c9d93fc4a18ed457b2691da003ada96d2c2a40a7dd73046aa0c71973f888717004098ab2326fc947738724b2911dd95cdd006de0a1ac2e455acba4f68bed3f71dd9d298517e4ad803c1b1c863e06b123a6570f1d1d0325c21ccea720a0d7ac31a74747daa18ffe7c9ef769d1708e3e0c8e1d4bf21b266299b4944718b6a4d376759fbe0bb26b6f03ac85fc96be0c09aad265d9b82f2344ca5c6c0d0dfce4f96b867f9a629e6a5815348de813d86a010c4ef564adb95ef4cdc6de4df95e23ae1d8cd0739102e377ab8e32ad6018e54383efcebea012d8fc4c70eb70b91f7ebee7c2aaf086f58b27e084bc3023a70b4744dd4feafd08805881474ca5880f575fca709c7c10d04e54626999787f880cddd4d1b1fd527dba7cb4dda5261dc01ebeddfe401bcbad448c486c0ff894c997b018215960f266d59e69d9a57275d7931249f48d185dae84fe103b02a369bd4e2d3ed9ad15fd96e22b39d2282596004a6b42504acbbdd80cd8d2f3bbadfed4749452642a16489a039752eb08d013819677388660efa7adf1c76202dae07b516a29ce09aae8068c83d8dd902b09599cf28466364a82b77794e4666041a9abf2d8edf5f0632a01688ce6b7f5eed6cc45be43558358cfed6e6bed37bafd22ce62ecb9383c2183655a6627a34a5cd974957254a90c8b96c2bbefcd40d95a98f39194444b046fa3baf31540279d06e99171018ab7d7974e19db6c2d48daf11ecd13ecbb6d6b245b11ce1298f090fe422b13f369e57bc48fc03f79e5940e977a9db4a7156dc620c861b2c6cea6c890d03e67e3c87a621762094b4f475665174085bb15dd86604e09718f4fd9159a7e99ddb5df39238c891527cf31ac8a2f4726394d53a38fcbc80ea005eb351bcdb241a12c5e322277e32dd6f7f81355da6f2abb0b09037ed8df4ff43ec808794d9231d14abf2b6bc010fd252dddecc57e623fc55e7f4a3faf29e40a5aa366d92d7633f29747240e29f3bf16da54f683b1f135069ff08d5eefcc1346c096559c339159559cd90c91c3bfea83644a6efcf4b90421c004bebf4b0121119496917c4ff05fa4d288b6931e30e8ae7c701c7af8ca42378e3ff35aadddc109cb4c5fcbc965a29a16d11ec06cbf1e8146cc0a9a592ef4387f2a004115995ce290a4ab171260f3dd4b443173c0ad4c1146986bea056f81b4167e0131d73ef0b7c48bf081be21e34ce8a92e2303d680f01f6f454bfd23db520a07dc175bde6a3fa5556cefb68cfc52c34e13922cc1ea47917a1f9b5a404a3613810ca89cafb2b5ca8974292ec5f07086d5b7cdc7596cceba22901e94d3e4c0f9be3fee82f9e9ba44160bce5d1ee67982efe11100d44d7cd372e0a33361af40ce8c0272cb02b388a9debd627660a4bbeb86e8839fd7cf38a546c5812452654d70ff861f0e7ec85a062e36f6b194f866b79a51734d8287832330ddccd039254a31fb29486969ad80d45d36172b68ae83c748f5760e7817d54da6463c4d4f93cd4ed04ba0209c343328b7c965b502cfb22d9959fcf922210c00093f13b30533299add33ba4ee2ddda6df8ee7c3b010a9da2faf2dd7e3d1694317b198adf1deecaadf4370f86c03cde551d39be69fd224c1fa0a1adf9a9cfd369c47f22755ea74335335fa0e823f53c7e4368a2b6f6328fd1d7d4080c1913a42b3bd72d1a5626f8ce47436c6225190de2f71a6491013142eb75bdf327bf1626424a62aaef995900ba936a2d8a24033a89a3697b25c93cac82e1abc43fcf33ebcfc8f2a94cbff4558cb657de4a1fa69fa33f9e50834e9848be24d1cce472d2e62e675a9548cc397ebae70ea1c6d5236e8b2668f587146e1dd3cd9fe78f6a1613967d7f3ce307a1fdf6c86a54e2762b938a301e72cbce774a25551683835bb0b0fd3c7e3ecb8bc5baaa981dc94ef90e6625186c403d77d676d1e516aea587d8b242f8a0dbf05e7e50809bc8bb0ab816d2c7d391749bf2da721faef9a5cb3b55cf361a948e913a646a84ab95e683938eeb0e03f74ebffe7b417a66777570034600feaead47a034a635a02c7326e1ac8a82c5cf206d340fb120ec01cc1ba0cbc7bc24439a209c42082029010525e50eb004e6e391ab45510684f1330abafd5485722b012e39eecad51581f266362ca85a69e0dcab01bddd7af19f138f5f577c76894ba4c8afc25cc295adca19a889354a3f09d5b8fbb4d6f2617017ffa021d7d2af011a2d13cafe23dacacf384fd273f07cd336affe6b41878718ba99c10bcb6708bbfcaff28c0a2bb9a207c09e00edb2e937f39c8e5b1974ec452cf9556370c7d54768b872ae65f246218948dccacbe395a4d99b52dfe5810b4c2f915761500deda8ced66ca6dbeaab9433340546cee0baf59947fa6953136994981a6e02f1f2c4fc9e28dca9cad9c79884d4acccaef7b1e8ae3b7a02abd9857557faf708ce8f3068b46e991b4991de2278dbee8f866844f2aa260658a36ddb6b44309db51f662f1de527acd4f2ffa6fd3879da790f4f4b8fffb85ed73290a0d7cbd2747d4d532cf935b5fdd74ffd30169228e9e4cd3491d17b49af50b7dea5558689b43c7e63aa0b18c3728ade040ebac80d89892753fa1893bad34a41c3bd6f1ac9373459dd7ae92bf177d0c11a45d63f6123de3eed01458283ee5fb4e50d2e6f66544cbdf3c5f945fe79e0a57dcc935e2ee91c30661bde4bda38d4cdf5922d2fcdbf94b32f35111c96b9da874905d81d6287e43d265959cb2e3a93854edb2621aedb993041a01fc88ff514f4a6efb21a2a36a86bab1b546fb5a724e2a52e268fb97d15191f9071f182f29e5d3b11bfc2430716bc245c468dbd218362f931a55bd3d06e5397cf73e0f5a668f268e0882d30cc554fbf6d1db5e04b8079c1c0d27985a04e09976d3396dfa899ab63b0201e415623df75027eaf3723734c70e1473b5b0eb9914b4adc537ff03f5550ec9c9c55d0ddcda11595cd3fe6487fe4fd52fc3f4f50d0b45b31584897c80ceb93a300be7a2dccd8868cd5f940ad3bc1ee6a3b563419162b75b91e2f7c3ec80de2982736fa322720b066b8fc9f203231ff8ff0ee30ab591497f9bee240f57b98a466f069b070cda40b5084de48c09bada4361fffbced2e9e0845fd5a8b815f834c15fcd28a9d70c3b9fdb73ed9809fc85771e1b025a231055874cd96c736bc7319d2cbf07a50dfac4f8cfd7e5bb8963249ca6af629249fa9a75b70aa840bdabdbfb58c20b43210c8df6d384953f485405a7d153111c80677bb707fe4c1f422053c6b2aab11660ccd0a3aa3197b4ab1efabb7618063fb76d3f5c23794fa08309cb35a687a5655fe8248b45ddfd68451abd7d5c29849950bd1bd33600ebff503d844a9461e63bf2df005db26a6d119a3c3817844b5c8d071402efb74b05e42db6f5a31bb645879d3d0cd56bdea6ca323830a542e9a4c607f2312b70627f15ab9f1f853edcb03ddb40bbf5fa22ab51e7d1dea2ff9b6b6cfdca8b021b84a8587feb21e6842e34ee6b4c2d6fb48102aa6b9fa6a1a50e0f269184ae28e00524e36eb0a90fff0fe1733f0574c317c66150790bd17d96e9c94c2bbd6050e524e515ecc009457f12df6b7a880ebf09f80844edb12e012b6f1bb0f0732edb7746b0481db07623adffa585b1fb8a340c4604e4b119cb6dece2815ac73671eb245bdfd778abfee1f70196e40e1a236d6c6e13c681dff447a4e34810b31dd20effa177ec6847d63c9dad78d88e809c765204ae2d60eac70bd8778b5b7d5616dd7b8c20ce654ecfcc7cfce88c638544f697eca2ef627508b2aaece8188487b36b4c792ad5215056d13e22e813a3e2236b6facb35cd1f937ffbaf711c4155be5f09e15809d3dca931a0ec7518db7f555fd3725562151fd2629701629c80b81b4b3217408d5f05004aa678e3e2fdab7bf851ddc408dacef20d698c48a8017bc2b12de83b96e5c3c665036a3b81cd807d3f53adea97240a51d1df1a3ef930ec59c111889ad64164f662722eca0adf9aac097dd4e149491c281222568abe0be931dece9426f3cd6ba9d230a1c0547cc8eda685d7e57cabee3e3dc246d99992bff817436d61f734f3e6f265e02834011669b5a2a16075366b1d54bee4085d490a235a2db25cb498c5c49452f827aab23c558d698dc6ab3ae7638e1c1cefe22ba401f3fba3a0d9dbfa40c62ae1733ebcc1980cd8b4cfbdef8a09f9f72c56b47cae2e5dad2655a734a9fc2c71899385cffb607fcd1ffa4b841ed94d2d2bb5580bbb5de5d50d937e61af83e8b987c73db901f874b2884577022406e8c50de47a210d4ea163f58aebf4899e2c677e1893aed9c7608dc4ca872375e536cd770539c332ca8f762db7fe2ad3c5ff5331e92414a00407c788f9b1b866e8d9c8c3e9d1908a1e0ea247e2276ce32c0b0ac5e73521aa8f0f540ea659452b56fcc1538c6aeabc4866666b3b257742819c177d1f60e623933ec3e7b13ed00fb5d07b4c63adb69235a8a879d7f126ab86b1428ad9bf8bb2264dc3daa1a4880ba81390e5f81669a3cd4835051800a713d020c4fa36986f4b45fc5d589a97e68accedaf0e2061c761640d614a52cbe858fb1d4927f2b8ab487b44fbc1bcd72a7ee6b1adac941a7d3bdbacdb496f4e025d22a5eb4c42e29133e855a229d686a90bac740c568e24a268627cca0f72b5760ff02ee964b3794a14af9d7be3e05a548aac1cf0a17dfcad16a8fb0fd331a95cc639fe6c6103bd64e4ef85e4b9ac61b92eac25b4892e74f2a68c35a808406e875853a35bb1dcad6c676d393645a52543baddeb6369a0887d761c19ddec1244da43af4c6b3df6464002dcdb9ac6fcf286a16e71c02df6731d925fb5b02402889676fef24f5b16f6f30d4314494840c9cee8c07e643b081e5c5494686f42715b702e3e621ba18cdf86fbafd94a0e74f01bd99b6e0321a7db85a90f708a30bd494100051809e4a5bd409de942204378603170ed21e606c40b6c9d929b0645fecfda7a3fe5e064cf571ac3e00847d06ffc55ba965cc1bb1c1657d57d942ace946372d98fc7163ae6410c63985153b02b6605b57d521465b6d8777d27265bea31f85957bf4d0879748e4eb4ec988403397b77104196969ae7bbe6c09ccfa876480489fe4626bc1af21569f2aa31815b414d1bd8dde282630bf90b488b712357e543e4d0079b7ac645cd4b4680a232a976146b4f5279bb35f7656668ccd04ecae38fed55300037dc6fb6281f80d6d6c7c0849a3d0f137eb7018a175ef69cd2daea6953e66cea363caf3561d8d57b040141a1d3852134004f1ed49bf69b5bd524c002737a058d2a16eebf555c02a8224cbe3ca46a4c1891af253b7fd69f20ca866e3b29d5ed88348ecfc60a18f5e28789ccd69bac4aa18c164b9887b89193f73cf12eaaeb14890774f7f4f7b1dd1a3578b649aa11ffa81280dbd37c252c5df6f05ab1f45d4e59921153b790ac0a9a3b9730dbb26e5ffa75a65179b850563f80f1b35e7a3a3eac262163e4f74a00932f013e0bbd98e53f5cf64c683ffe1197376f4ec7ec9d03b86f6325fbbd1562100b935c416faa2f0bbcab28e7d90f53dc52585511d8b561df0033fadfbc2295de92e064381f9de1c92b3e672562dce765e55bdcfe95f8429d98bd1d50e2d616c427306a9a72b712eb20750984d2778cb309054547b5b5827ea7e9a89b48e04b3e73cded8112f415b79a7378ddaeebc13c6cce3cb1ca9587d6b119038aa73600d5867697fa89338f5c91ad4d403724b8ebf7e59aefd3bdd4d44fa3c1a9945bcf3b86422b29f72b3c4a41d0417a594e230a7c5519d896f5b008b85a7bc8513b93d2a8408864353a469406290e629e6d565e6dc642d2b5ab44f073443543384adca31e33d6488ac0dec4950aa09d2bb482063189f864947d65992c98febe4da7538f23348ffa9c1b711d1b5a04a67845d3a50688184c257e77e895d4393e2176589be9bbf22ff8fa372314cb86cf421e6ac01aca1ec8e336d01bc89e83057c3bba50faec026f696e874ec7d213d4c843773a0eecfe77749e38051b751ba02bb4e5e525e3d7657364787f327328b096c3638c16a4e292f466fc70ba404b6ad8a3e605c9abd200ca07136e3ff99e7ed804955984eeae0e9979cfc8d43a88d92864b0bca724f3b4c953d80f9a8afa1ec2cccbfb0fac8127b04c9fb0744135eae66e9cbbd2ed0f1b6802ecbda051aecd0f0efb05776b9f17d7f3072f4dbc7eae3f54ee793134c0ac075869982955287f6290d2df50117893fd67238522cab5ad39e78caad231f9fdc98b4a3271e468ca0d61d9a211033fe0ce6869d79509611323bf4e148daed5c5ea0f5084c7aab06ea7a3869c9bf45e9bec9e3495a2ecf2c4761e7aefab0f4b8324cf96e24a07ea4720533bd89716f044d67efad80ea16095b1c8cba1e36ab282381bf79bd9af779e97e9e282bf352fd7613e09a6e66fe75ebfdac804d4e392c177f4625006e0806d4452c541805ee115b23ce1f4a63c4002783141756ec71ce0688aa0ce569062b788ba317ac7a48800b863f92886d58d3a1f7a80898a55a156fd418752b5e166b62c3df7a30fa89cf7e7f275c0e4fbd12f12485b8cc436e167e910","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
