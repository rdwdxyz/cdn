<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7146b4230450e23e565639427be38e5e8b0aeb7094961afacef340b64f0a46bbc2a4cdda9cd81ef0a522acc96b7a3818a73406054d62688a02096d2235aaaa29d88f4fd1d188f1bf3c40a43089e7fbc7e5ee9bd778c2baf71e7d89770b1e1cb528fc08236f7acacf89b496eea12c308072472080a0453c26e41dba39a246e0a995cc9abd197b7c8d126c1d9c8be720cf21c637c976a0df9f147b06a3c6207cd3164418d88ea077c238ff8cdc63d68730a2c5d16b67212295b9dbd866c46103b2673a387d4260879e13e5284e2ad12ad5177eddb50c27a8168c91f6779d046093d9a0f841d376ac9d350acb9ac8e58cfab328f89d80a7c593415a081302c9475fb57af0844e07c34a7bdbc20d6310b1c3e6eb764021e4ca674e2a285ee1831994a9cb60ed0fb64a334df00a081f471d9c4d446d117688c3cf03d386f23873ed3eef18327d5fbd14969bc1662e3ebd4b1a8b5c9c25bf24f13b88d5482785037d10d306bac02273bf092de0acbcec2c32bd97c5e5bf1232d2f97afedef1eb3074397580a3f482057d9f3c104c3047865ef6f50720d3c054dbe97b4411e8278f6945dd75be37660f69e6985ea6ce54560d8988dd139648020e5bd06c9da51ff7c8398cfd946097c5e1601cc7105fc1a08b2245034a65cadec4c49c96b7b4b1c498d37cace3c8222a4e99e6c1a55564561462fafa0a00ae70047f192debd4bd3412675b62e34102074a10426f1a72b57ac3458cff41ec71672fdfc89da9b5641c6ca7a9c8fb7b2488c897232046a386baf79db30fb9520889b57c2a10472178acb3f95080ec11fb9bfbcfdc6e9222c66f8e826a1b97d9234a3a10850ffcd97a54df41dd4f1211c3f9253cb09f27613f4589b773bddb767a81d1029595c5df9810b2cb30f7fc1287485b44bd46c3635ea8f191632beb8a5d24a0b973b82a30f752055c34b161702f5447e0fcf9f2c7c426bade1c296cb67409ad23e112f5e52a872f2616dc8892f28a86d3bf79c15e98d5fe0a16b3313b365087ff952485018e6c33bd4a7ca5091092a80ccd499fa28cca436f001441a85a4e87592c655ce7d4a9b49a66ecb99923b8a6df8bd56a7123400b07aca6ec1a7db0186e299d1ead073c2bee5bc5b24db73688f905c03bb57919438b75d18e1c3d40f4b7fc65f7aa313393a1c389a18a2b134a840d4a226741f14bab78d2a188c7fe0a3e3b9b5da9c0a48f9f9c971e79cae987633f411da0267d2b40d87d2608faf90a622d48a4d81ecbe8675ac4a3677fd897f59db95888330df8102815eb7764b0635dc479dbf15ec7ed555a62115e1776a673e17e57493d7062a4af0750ff7d2aa75d28aa58eaff4516093e02165ff134c8075b4941142576ae620ddeb214d11d18c183f7af25368d63112494b2a32bc92aac3888e00f6cd28fd4e3ec1ab2adf4853b8f3681e874de74b9a42aa4e07d7d21359b125aaa9120264873e4244d90e9bdcae7a35e0b06c965f0262b18cd720b73021974b8387475a03b59b5b582cb50f19be8e56b1fbfee43853ebff09a59dd15cc39f85cb978f9471574969cc88c48e0f83637501e66fec10adfc004351fdbb107e2244df75e355d2d19fe423ffd2fbd6c3988154987c13364665375e919ee941c7a2faa06403b75417655c0da2f415fa8343e919238181b83a3fe3894ff6e4cf041b56cb4f700518f737a63b04d14d3de05d290e655274002ad0c5402288c5abc864b61766254c7003f4a7c2a5a808002a5113f0c7a35c3272b0d8cb324629148e4172d9b00cf059892eb26b991797e2c377c3d3c0674e26dc93781927b4333c972ae91dec119d050a88fad21e954eda519e64420839a0293483c381753c97ccd338b54353ab7c69f3ed9ae12658fcce4f4cdea49b668196bd537c910d6236943a032c8337f95bbd02e72454a137dde0d28ddbd9b3fa86521c24becf704f5a63555b00535f632d2a1524e32d27de1992de055c12a0f67a6314f7a0f3158aaf818423f70b93af1585d2bc67219648172594a4ca131669b44eb141fc23806facd3cadb856445195625d902c0dd1b20f319c7a1e6c05cee2f5226054dc9bb3f6dcfa3a98bdcae52922cde70ff30466c9010b66c573f55a0187a95bb853220e44b480a43c89435296e9e2bdfe0c01cb0018e11b4182ffca6cfa31ed037457ca0989703f560bdbb9aa602a853f5c45745f789ecda4cfc6a77503f11a7cdac26356f450ac89e8eb299c6fccf57dec85eef0ed5b559cd32bf19f9b67cb89d6ff79cf5c6b95d096110a4e2f8266f2b0c362f6fa541e7bbfdfbec096df32f0962ec18f35c3dcf7d9dc7e126b39797b1df59ed82e72252e1ecf0a7b434230471ae7fbc5de61942a5818c9d2c149670202b2098e9410ccc3b0c768fc6d5f8b6b00e570e817274d40ad7e892a2ec2a0fcd47da5346c3300aa046acbe087df7bbc0100a19001b4c49e5aee2af395b4f42ed110c836086b41b98f874171c5d4b3a8a527fbb22270e566c73f5755c5770a71bfe1b4fba3a2fb8efdd23961c558a2724e9d7c167f169e216aa8c34224b31f89619eff610cba212f2fd3591d67db4f8ce04efd540f5fe00328b5cc8b19574195c4f3e863d3f8c8de8bc3be1563d8b2a571a80db330ba50fc9c348763ee897eb949a68a617661ecab53c54bb99e004829cbd65bdc0aa15509e12c93eb0072439a4ba93a2b0d07763fd8a60f0aeb886eec7e4a328bd642c0126fc5f83b96cecd1961f93a677b0ec9c64d5e82799a67fcb3aa46d4ff0d8af889a3b57be40d7309ed2bea44b78e8f38b87ba69c59629f410240637cf55647fab7c832f2368f5d029d5fdc4b652a611e777916fcd8bfb9510400020aa2dc6b3a0636c863be926d182a1734c1dbe3fd0ec18630a6032e90e1aea51750807cfaabee877e9689bff4d4495a2ad3dfb69e31d9e7b704a4e7c3cf528fd22e7d1e10c68137481a5a44aecdd7247f5572117224233c8ae6ad6a76d784bd4562991f094263ff61db2ae72992f02a327c81cfe81ad12be784db109aa81f8209ff062fff2f4ffba8ba9d3f336e0baec9f0d45a9526bbf80bd2b704440964085f33f24de165748bf94b331236842e0d1a40874d079e120ca0deab4362b7ff5abdb6ab0ca22363c5718ada650e272e456dcfcede6624845420f1fe2db769e3e33d3e9be2107c80c0396c331271d01a1c8f733700390f0500cb4779477fcaf0844a27b784d5b20f5373bcd7a274aa188bbbd3fdd1c292bccf83f22494342e614ec3c188f4dd48a4e41412982e045a51711c7a5c171115d992219d65b742abfa09d840d4e79eebe92dbf929b4374b7f782c8351d52807fef0f9545262f210ac6c0fd7ef13a61142015713cbdcdc387b04bd4627636e12a6ef44f9956942dc98c46e97927d92e76ce0ad7d256082a66a0eb98ccee3f09eb5fbe657d67d0c83c5e9501cc96d3cec00cb05274012fd335e8fe4d58d66478796616fc5c2b838051236e803c77fec4bec350c7783356b45fa02fb94df9334340f24269efab5511b4d19cbd10a060312549f352158f15fd9b8f9df42c0a6fb7b38cdc592ec5867e4c56d7b1b822555d2dd34963ea3dccf3dc5c07a630719775a225c4c71f4594336269415c0c82b26582179ed52ce92b0f83c43deb4f33ae302ba29dbe6cbb1070826ca3af4b8fcf273b7b87688d71955730a49c6339c09db4f5f05d1dbc3e3f082bc48a489fd3c96137ce5c0deb08973223f951aca65ee77d4b437b4b2b9df3c686cd2a4729e358bb87ca334021db0a3376d9e003a383953baaf242be992bb4e6abf6aab04b12a408b9d7351923bd745c51e78ee8f0496130fbf264ff6397906d8ac6b5fd01e9f71c431a6e1412ea28a69820c4d6042cecf1c32464e993766144326e6abf187524513917115ccf0e07044cc20048cbe538d2d54f5cffabc0acaa04e94ca41812a3a5d80365d154e33cfed6f09de844ecf5b30e2859ccb869207ba7cf92198a3f010ffed801fb07e16b663b167fd4e7306d2d05b745a2e752abe99f5d7320f8bfdf1a7118d62e7f2f76e0e6bfb791f69e909df4d408ff54a4ae5ad860ff530c22761ebe4cf7effb3679d718dba0da4ef9915ba0059dbbf7eddb0cd5f7d564747a4305312a31b2a3de11307a1b91abf610fd4a8be0870b774e4607aec48edd32ae9787c39a1757811e3503d309eb305a3cfc1f6377bf59282bd87a4c3577f11bf84d0c4aaea4bc022eaf3ea590d17d301878383ba83c49accd5494f9325ff0a0045e78e5affa46291ff3e6172534471cb726d0f3e50fc80c373e7781c85092bebb74b25e05133632b341447b7c58f0595b1a92c6550bfb9b1a09fe6ef4fc00b44149bd3ac23104183516b1d3924aaa4b66a0af623d0b92a91c908316fa6c41950e60406ca43cb100b9087c2ef4340c24e634a193607d32264c9c48a30b893be7b603b77d8ccb3841a3644cc02ccf4f2442bcf611223d0e6a2e38c491ae861317a26d213c8d9cad0cfa4d42e6f7abdab87e623ae1d5742d400fadc08cfd21dd874ed2e6a24440a369071630004c3c1e6756ba58fe2b8df55aff4c711793992fc3030e7889b99123a540707fbdcb5a3d3dc4f80a12ef78784ad8e5e33f2024636321c738363a1527bc150c359af4ce04cc1ba43283c13e4a99e999bc8acf8ed5ca150e1009eeeefd84939110463e84bcef3781131305ce9cdaf23900bb8a469ce5fd591373cf662cfe73ce19cbea3611bc92c5cae9f6f56a5988205ac80944c544b54e6045beff2357529df151e290489c6dd8db4cc4bc251f8833ef8a6b9235bcfa24677e91c93ec44a71e1d69020b2f890010fe056056cae6cd28597f3a05061a771e8a85dd11e15c648abb759e8b819c50b4f7021b92a27dc1cc27086147549f9261ebd3a039906c1a44796399e5c88f3700a9336143e8c7659bff6afaf261d65ced1c4d5a85507dd73fa392fc58bdfae293b62a7b0dd4be7c6242796ccb0a87421464f7ff5b16dba568a4966266707c086fdad79a0960467a73dbfa1765f2c2ae41fe66bb926c34cef6ff7abad5249cb71e9b3d0ad798a3ca469c5cc78b171a44abc3e34eaabd86799de6b154ac24e4143d829803963358ae26b4be833d5917fa878cb283596e380c7eb0ed18e9d85470b41641b0177711c221237ea018f46918e29ae9335d606806403419a6ee9a6529f13fe1baf42e4497d67894b06d85cbaf07a8c72e57b30774854412587db15b576e0a803c63694af2f3cf57bdd184cccf3b0a23809f59ea7468d0ca3c5912e6a625182d7e6d8f17e50371892f95ef0d47f93daf771615e802985b1618fb9b57b19cf8658be5a76c1771cad3ece23ffef9344f8b3e3be130b87c530cfe41957a5b24284599bbf7ff76f7915c2becbe0aaa653c32622ff675184bdaf1a864a177a8d30b15b163da7e26a00b0d14cd2490556df36bcece6b1536a75c86c2e648a4c7ca15193aa8f1a5746c95e1942fdf8b9334c7d285b32f486e15bdea17c42a2832c43edaf736fa8156c7aef563123de6674547ca6743d44578f502c2d7282147a98541156242e9a5cc115f7db5b418aca2eb95b7f0e07f3d718863390a5122bd3639bde71f912ac303eebb46bb97d4f80f65bef15a68fa72e9056fbd3a0fe1117b2f1fe7fc27d96cf7a18fea3c5eabdb8240558dbacadaaeaafac26bd39436b33a6e8fda7b76bdb58fa588729c4f839fc53340309ed3bca85831596a459cf7ad87a3e745e649d7fcb6066367c4d5cf2bf95070316e2ad50e086db1b50cba058b709e583d3479b05986c6912e8b4836557bc1b1735065538eb125e444aabcdba948ddfa16b82174aed2c94ff05dfe3e549f6b6e2340548981e9f1ca8a8643e6250972a56b245c3a6d0e0e95325b5ab5b2fa23f1702faae248c22bbc2ebbed5cb08904e627d6209ec5da810c6fafb3875f6ef3f23052f28b8c54570d09fc922adcfc167a97703b7631fa8953d78eda996238abc64b3bfabd11ba87bfd3974dfa51fcc7cc1da285fdbe69b0cf461cfe3b754531cc5bfc749e50ee2fce04fce8233d8716a77c8c194363c6300aec1a5727430671264a8633aafa2b4cb37779dba944e9bb253510b1db398b91273db6516472979328877d38cec6b13ecd3274fc9c6ecef5d6afefd6b09c7a71ba13fc844a1f3f8dbd6e01eee6802913c1fb4f7946c3ea68f16f24d6af1ba5bbb1c921afa3f3ea875dab8038d8de9b0e80b932f2fea959bdb416016f09a6215b714952b714a309a877ca9b277ebf77944afbfbf5100715c3de642eb3e2479c112c7ca7e33d4abe10c31f7108a4de268751dfa293944d4064c023f47508d3dbbbf8395909ba2df64090cac0bbdb882836173c60d29ad08d57fbd1363c6bfd550cfc0aa436fd7aa451103784fc07120e53619381ee11dda5750be058f783f1c52bdf8f614f36c9db1c880d26407643ee3afcbe2612f254f2ab8ffbf4ec9cfb5cebc9dc3fafe23af6d9c2b754288133abf53bc87883445ed3de0848a39da5500c7aed2d930f0cb7faf1ac62f53c35bb0394f30e20f91d7cd425f23e53320b72633ef3a012500ed44f97d125029bf267703cebe174c9594e06f5e68b020faf5bd82722ff98663c9e354b3f1ea194b70156cf4f34c994798fed4a0b3975bc07bd034e33861a99accdaaf28f2f0d54bda4ac573435eadaf595492098c41beb6d349e06348950a5ab19003dbe0ab7ee48c45c200a2f3eb66b7bc8b8f7619fc97e665b6d4378870a5d11ca0868224ef4b447a25c65cb5bf2367f016974318807fead555459d1b6003cd5ef256d3fec8c2ea60e6b9323d27b0556788d6c541104062442798c96cdda17d0ed0aa0135f3dd92c80882bf0732715f383ecc1d908f012f2051b63357a4852e4f8f006606dca7817b3616053b2e7c4700eac74518afde26fdb3115f981e8dcdfa9154f6332adc7d9419496b77a33b3f50fd395e0bf484c3f0d4e8c6ed8f6e98d60375b0477e5aae7eb598875a0613be1a63031cf7d08aa551cff5069341fb425a670202898063ecc1fb0e37e6f8f6ac05d80c19add7be0cff50f2d81351c5ebda31852d6dc61ec7b73a6d49d210714b556310bfa6a7c7fe9b3f6cba873cdc04bc4e674a982882ab2a671c6f52b783276a0c8c56cb3a55ae3bd63c8db51b313775616044cf68ec32426b3c380eaddfecabddb73b8604f91c71371d05e3b27b038ffcb77674e276db756f3565c39557d52c5223f301a9e353a396ace822d0693c69c18e98720d35ecb9901080c193b3ce2f60affbbe35ea9c3035c41f582fd5b1c6919d27a504b1f32e9271efd6cca76a8040eb146075e895078bd47487f2c861fa4333940891cd8c4e42a8ece1a4a7d49b216d13b766fb0c731bd34611d7240571c7618acf3335a58fcbddc8eaf548427edb3997cb5d2d420b18fc5ced8bcbc1aaae1a4ee6b68d11a39d1b744b870a6f4ee39bc842799f116a2517fb4420c7c3b7a1ef71e18d4fb05c0e8ce410094ae3cd5cc074299a69a2ce21b2bacedbdbf816ca23f62b4e007977b34715e9ef48fd56874719b7f153e69a053c9e0da22f34a09bd47f630eb49acfd02400364dd33bba5ed5da8d914619126138a09f86dd9d8f61de1edd1c657e7490d4c2faef0aaba21d5d7bcb1652d1cbf07a347a4c520e5600aebfe8986d26aa294c2caff804d15ce190695684d44b41169a5eb3e9e53e50052115d047baf7215a33cdc784b02b558e9f81963c8ffc3320d03fe4f76448e3ee81f51482b5e2ddc4a2b7e5eedbbf9d1f6b68e131ea357497cee95a2ed8451c315e989898c16ead6027fb1b5c1c8b3037f5a9d628c4eab1a75c353a438ce2b27850f3375a9c74a71ba1e5da1e0653fa65a7ef6e6b962736c1d74f36356f40a2fe2b17a79bdf3bb03c1574e6082c8f1c664edfc46afbb8952c0c266a4faa08e1ef787f32b9fe64c58b5b6d914d4b2b9fbde9a8b228dada6be464501b57adaea7367475b8f126cb9d92fcb6631c0e03505f169110250f3c919704dded5f0c94d156fbdcda8bc000b91585485bd59408d9fd9e2448b3352f1bbcbbad1b4e80eafda8f4c31c96071b83023ec2cb3343d5d6ee7c4b1309772936ba95ddcf1cc9457a9e3061c98476afaa3a35b1a0d5da312190f23443e003201e7a8b124960f5b9a17b3702771f85c0bea4f2671803559bcd4b189d6b21b97a1590fb10fca296f1dd27908b17845755d6c665421fab21e02d94815bd8db83162bc167af198eb1b3f6c69998c3093f36faffb13c9ec67d03d316005b1afe491ca58da23433388dcd8769f299acca5ceed58e55f9b068aa57b2c44470ffe7752f6dd7a461e6a168150d7de474d50e0a421d4d5894115656b46ff1d153c9244a4a70d603b0680d20576b76cead0045b12b9a07395b83c187eb4a1978aa42c18cc83c11f314aa7b56ae23c2b5687fd46f28dda4f0f9e7220e4bfcb75f8db33096e73293c08efed9cb686d0c1864e706be003fc03a998a7d89b541252b765e5ed857751a948b852762e607ec156ad3fd365f1a50b8c5ff028feb437ef13c8f7856a6d56b44256d993d9bd94ac2aae5ee8a0cbe832abe2e64cd7065c159caaed3d6944faa7f375b50e4a211d70bd66f9f0b98429c86ef193ceeee7b795838a4c1615c429de99324df77a746c18719ef618f9775f5492e7b8ca46379716af84215fee14656ea73400268badce1116e29beae10c4fbd86dc1af82ac3f06bc4db125d96242b1e75ddbaf527e09316cffb4ffe61807107eb9bd20f17db5ec7376ba0bd664c676ac2c813f3a9e9e59c2127e4956c30e358b9088955911bb37061ad4f63e9e60dc9267a7a4a875ce3dcb9bec0407e593d9982732d133d506fa50085163a2d0e58158564a9204a573446bcbb226563c02ce77e9d107b6c6aadca8e3725cfb506f1161c079a115db5c4bd130c36e1c684620b1b289e39ecaf2f26b8f2b8e41a22b4a457a472c759a4fed221208f35137a484963e3bfdd59500e70cccff529318ba81291aa604b12fa5933dc3a6cb66b386a3e8c58ac149163ce2ae7184d8f37249d0f30e0a9e9dc572715ea4209994f219a7b77d73fcc25f13708e1da26a83faac60e977ed5040ffccf917af28cd56b24be1195dbfb5ba56f41731a6e97cd811688b520317865e2c466a08045b57b3332b0e6a39de4e9a7eaefa35c3be36c3576a9474081300dc963ef7429fcfaf19ce6675e9856bb75cb5e41c59e6646823dc728ec6add7cfb18344b54633cb77b4689f602859af55ccdb64ff8f7fd215a73d63901e1697e74f24bc5690732cf3c13e8c9c3df4007e3ce1680a752eb2b85dcd6f3d2831419ab572756c4e7c220481d270967a815f445f57336bf2d10e54258648babb54a62bd779e0341d698e4f5073a562910c14f15885a1cb3cb3840f90548f564dca1274d7e42626293ac2746febe9b7d5cf4efed6bad8054dc7bac8384cb3561499a99401bf262d3ce7db1ee471b98e3aa4ae6556fd97b0b4868b52fcf3191cea0b715814d1faa2c8562f022ee64ac2e0e9da849731546bc1bfe706cbc21313ffae58fc2bd954b0fb0e2f2e1b15baa1dfc02fb6af55932697993f35f78d68031ff55a5882fac06cd1f13564b1ac8af68ead2a8812aebd70ddb74bceeccb3440b20b6a619afe732ce4e1a564f726c585a2e3d8d80e454d7a6571b50364d229548818366a2bc3639729db3c829a833c0645e4d446ea08ba337caf1514db9f2e503f27e4f959955e0c9ce6ed485a997da7b18deaf9e9c2527e6425d15350b01db1c161bd16996769a534c7225b7753bfd27712755da90da4b980b89e167848dc255f48f3d127f5ec3badc437f06a6f95b969493bb9500773566c34375cd0545e543ce6a1b2fd05b8da76d9d6aeb8e929a849ba0b280202b77141279e2a6bb7576f24309e0ea8add96887aff592330c5a48920842d1886121f988b3376c05ad0eecdd9349b82db5e9527f1b16fecb363b9884b4c30d696e708dc611067c92d41838380356f98975e39d99d14782e43466ee0d2d6f37c430486f83c9ca166040f75d97a834ccb6c92622d7effe98634573251edb4dd541abfd2ee9b656b4a42c88f6dcd0a9f655f405b2135a6d705272c102357fa5f583c4f2a0cf441fbd2c2b161a8a54a62227068b866c78b696681f4441c582e1e124d024d199ae6bb8d1703ec39390dffe414b701d2c07737286ecff5bcfe2ee01688aa762e2848f3e700afff3717b5acb521acf10fd1fab25ab041c2c9ef1e56b4e6e4809fc919a3d277c297412f2621961ca5010996032dede010d9f2ef8278d43d57a53706b64e3c411ccbf61cd3a75d9d7f3601fa89dbc99990e704a47e75967867c9b8a428159894b882ededd008579610d34ce4b4e64160dab725d1ea72e8332ad93b0ab63714497fa28a167f59c4c9f3beaf5a3f9d5a39dae45c22237c57770609c60f2b49c912f46c74d1a337f704f6bb40cd633df4c01c9c8f29a8650cc440d8a344286888d34ed6064528cacbf9654cc7261b79cd165d1b3660e432a5920491012438c7be43ca6c1d17c475b5a04f3e54a771af7cd8ac31abda43b6fb295a19dd0733fa166b74f7c46c71832674d4bb719263f709d3fe64133d62d09749f9c1120391fea0e234f116ef5438b3ac3dd3e0d1cf1696e824c81bbb1105367d32beade445866ed641dc1d2ec9218f95f7fa1d24bd6d6fcfd401e6f6355ed24a5f066880f695dafbeb1b0ea6583633e48ababb878eb70d31d64b2667049f54a5e4497c5d3a808beea7f361c8106140e7b9d9cf3158cd4d6aaa9f2d375c953a5a23c14ce5a692ca6405dbf42aee0c06612bf710a4ba5a24aa0dedfff3a3767de7b5361766685b6b827d7f7b86ecde6959d827a70451be88d81c69b77f75d4a4a8cca0800ba96791720b8066868656af14e925fbff1830654bdaa5615fd9de9adaa1741c76dc2e5eabebc02371864170a9826156b25e1ea3fa01cc97a3dc19f9f7537f24df54badc573ebef7e5bae07f0fa3e28a68de8fdc7594c57f59881c83a81141b8809033e9e17fa40265db60e0c5f046b285341eb1698fc5c4ee4dd8c30e8da7b078dcf6cc7977107b485ed5e81f551968f59cf6c81e07d7efd048b641e93f3a914d9b1146f2dfc120e15cd0f0db610fbb0662a4995dd9db265e1f9a6da3678b2b2a30a74354f802e0d9f39eaa9917a4c9f7d53b5ec902688356d7439959df5239ac5215917bcd2dc5ef0b7d5b788c6d7f6e99a43ebaf3b931913469017af8476d9e8ca66b1b5409d18aac73cb76833d5c1d99102c289cd95bc9bf2bd10a06042c331567d8f16951d5aeff4179a257b53765ec8cb75f0f3f470a5cf226bb67e2dbbe10becb8c9d0de68a6df477bab9e4969187c3e4723a2080321ae7fb1bab8f544eb1031578302560afb5602f72966eabeacf7a61a69879dc55bb20d31e3e5e4c33786b62916b81338750d877077586d7875149dde551e9b0c28c8a736308a02b6b24b1e7841d04ab2b89578479c222022a2af47afc94412b85ded4a733320122b99d311cae0e544c9771b1f15dc612d4dde37d1b6f245ca1b2553676f9ec0062a23508841cea06213b702ad42276ab457d700de635e58721e7ea392a8cb8d7b7341b99a23cfb3d6961f6d961c59b08e47e5e6d00b08343057ead6727e5fb98d86adf69fe9037e37b686c1754b988909c62f21c777da3e5b3bb44468de1f6bae665030af548a7080581d5356d3051bddc9f324f6be02a0751abad45458ef14899a4fd629de5374e9dfa8a9343e7468098a8464d9e7dcddd3c7dd0e2d3d9d8cded8bd66025f9fc3fe0527c6967444f3f26fde9055f80b0828df01ae188b79889a2201a1cac99df40447a51c9f95442c491b779d9aec25a393988f078a782560c61990f0b7712562a9f78440ed968574a1aae74eb08b03df07a47dcacc397bf20c5b5c8579a601d4ceef2d9be6fd88ea46d37efb4ce9c08855d4e52152982abae8c6746da661b2f3bb5c22f4ea9c676eb9154721073c41b4e5965a658069248330b478f4ea0d87d48f4524a5d84890c104204853cfabd6fc3e7f26882652f063dc1e10af4251849e67fc3f1fe80f57eb57f5e0d8e5d84a2facb22d88e0126253f37ccf0d99dae1c54240f5d6df32ea4ba8a9f055579a17ff6f3b19be7a4692a3f4455225f2c9f07c207d1e648970436ab4e1d51664f46b025297d214e73ce6a181211c808b577fd2b262db66d9da5b014b9904e99d9cd70b165c0821d5e7129ee6a66590016d623d981f784af233f4bb7e5d17715bbcf0ef673aedcc410279c96e1fac3cab8522fcf2aa6a09f725c56ae3ef4a9f24c8d508ea1b8fafc9a1db2a8f5df71850a6d6c4d73a7f25ce11e83f6d8d501bbdf0c2cc519fcda0db87e6de354203e590f95b9ea8324017ff26ce54bafefcc141d616acc24819c94605e691aa3349050792d08c8b8d635c0f98f8262cf3204d02bc284f88c6c805138a897020225f9e63cdb46793f6b0331464370da7dc22f7758ffbca122e70b2aa9726701e2df7af4eb02bf7181702c82511657a8bc29aa905b6465da0a41dcf789268900bf86d5d2058bf32df775358df8ba071defb4e5af8c3512b9db46ab13cc0d8c1c5e9b65ce4e25e81c2df9d41cd4834305df3453b48d13cca93ee0fbf76e751a2f6075fbb3de3ab7aeab99023f632a23cb99465e2d2e67672bc7eac6b3dda755cf86730d4e569ade5d9dee3e36cd3d89ce3b70a3430759936dde37524e50ae75e819cf8338bc4a2bd78d63eb105a20bb97f8333b53d5f0122113028cdd7a0edbe1ab0782d1b674474380fd5a96e8fdec4c886570172e4cadd3773bfdb4b2ed603751a0786cf61266b58548fc1ebc474a86f3fbe874d3b0f9c18908027d91e8c485f79fd156f523837d04915444ed4e92061e2cea01f7a9e4f11fc5d0ee03d4a12112e27279db992bcb6e164665653bd2556bda027c549054ad96715ddf2c65f55b17a72df55e62fcab9369334b121d893f36ba8f3f70830d5d3674457ff9f172a1e7a116d0749066c9def4db4fed295a80ea6651b5394c72c9d8386382a605fdc8282215a324918035203c10b62f3de7f698d52e063d344bbe24515536d8f9cb66161a5b32041215cf66a288592807868911ff47e406533be065365e84d7709478f54aa1c1562a17652bd887de1c70ba28448a7c0f59e53dc5b40f2a73942a1a278e93464c644481806e447ae57bd4969cbd0625bcf80ff2cffa87aa28ec56e1b3d552ea06569fc5e2dc500ecd26f159fb3c0b2a9a449964b8a6990aec97aed08e5cbdce1e731bcf4a49bf12b1d8f0a1747a1dc4000d7208e963c4bce27434c18738d64d0e9b2fbf8dde6f007a4cd93b5fb17825a42ba32c7bb766a5bd2bd0e3c9aea25d98ed4af2ea8aae132a1f70b99c5180b48654c345aa658ab5121ecd20983f792fe2047f2d0192e94189e6ab82c6f8a5dfbf8714586d5e086139267f6ae0eabb149d3a61d24023a431beb5ec71f5be01db6f458c529e3ead032486ac1b56ee40ee99562240634d779a1fcd94b0ec2036bf83d8c6c92b9e05c171196e29837161aa9b406a10f71604528ecfd2e617d3960ba1a236abc3f355617cbec448ead45ac5011d2ebed239394d34105661609e2020c4dbceb0236ffedf3fb5963e2d0942696e33c265c68aec32b538c6b5d4dbc0ecf089d8e3ec1c02e4ff42b318be2453d36842c65702fbb1ab873ac196d1c47d8f8159dcdcb02e374ed4a0b576e6a15151cd2c52d7ac5b77230c3d43a8dd483b87b2b3ab1c42ce28990ebd690516ac6296ca1c2352b9c92dccc137c0eb9ad7bc4de4d5ee46f1fb7d68e70316e0ffc4d78a3b04d51ec0cb4cd8be10f3f0a78dd2e1e04ea23da61373713ff0d646f73c698c8e98af128151ce3c26afde5448e0da91ddaae25e1212311c15c9a1a301f4e0e43d6e4404f95e833c8de21b0947856eeb7f665e715b25b33d1aa1ef3eb0d3b408ec40d1a6e6f3f0fffebbd4666e1fdec67dcdde0b464db988a7921e345213e2ecc2f6634e6d3ad430454c10810155d0d8e1f5a21aee93d04e9bb870f5146af7e6365789a5414a28345769392e84dd393dab59fa03f89aeb1757f318ed107f62e86c5e528cb3f43f82b8eae1ac4eceb340b960c80cd480bd904056997817a22994717ccf48e70724b6a397f73fc815015041850d654fc2576ace0039b1ff5072c0b3b8f1a6c1227898db34be718db788837bf0515be714101203de02fa8c610465b48b1324231b003cdb62ce43dc9844799700e4a9ccda9092c835a7f030375981cc9080a3339b5e33325a85f964bd38d6c93212dd36b38c0cb12d4674fa881c9cf7f62ebda2194a3d866009203091fc21baf69cd6b1bf43c6bd7307fda9bf0c9b81da0198f10ebd5524eafd153d7c9a74dda9dba178d831842ea8f9e29456ae60e4a248e7405135a5c43528f226fb3927b2b9c9f28e17ced0bcee3c075f7fb67ae32b08d9ca118e4657a207b039d90e17dcbe5630f37c0f75afa63402af3da1c46fcb97d7769b84bc80c7378ba1009e0c69ac8f3166070d180354402d12e4ffc4f8d4eafe473157d99306a340fbbfe0e1a0a7f46a6f13598021c634d1adaaddd45b974650196e5898c65dd221dbc1eeafe6867bff98aa47fb9951de195708176957b41dc72dbe66a8b69da5355f7fcce517a6b8c8f359da61c7466c24404e856362e69946d8eeac45a275f37eaaca2c566969d5ad77a1e17f30ceb7dec8a1e9c5561b6dd4a88158dbe95d7931dfca7770f25213cd5ad052b48ae9ac25ff8585cb2c8057002ec805605c72f8c09c08dfb5820abb3ac4b3d38804055e11c33a3904a0b242ad3a0e17be97b342ae1c4ce204392c99057f445c71cd989195aa200153c04b3c9b643193aa21c1f21266db0513f6cfb8981aedafa7f996a38ccecfcf83309201cf89c3ef1dd004b540f95a023f3bef7500d373d589845fb57d468b3899d777aca81396dd72f76e7debb9a0a694d26c29a844908c5ac85aea9eff66b04251fbb88e5f0a9deb8647549e7fe5276420a4b0e1ba34180c6ba77123c09292c545ff2b6fbb61597925aa58822af8ad96b66c628f84e2ee6c7281e9b226da0f8b706d26e85c0fc14b371ca3070bcb1fae2d8c23be3cebb2438c26d9520e138e65723011a41e273bb1d4b9e8e407ca9507f72ef3708951c97822bd9e853621e1370ba1d58806fa17772942b33400ae6138db0d256b50b689df0b5b4718d32bf39a1f0f44ac64882c987a8487d7d7ffafad4250401294a49fe1c5f4bb12b18547e8ea7016f845749827e6132894a394452152a0dad3f0ef7b0c0d67309e74ca14ab373be155f9d81a2768ffd176c4fcfa5391cb5ed3e95781e42944a98378f2fac8161c2c41c05212583ef717f851024ae7570a5938c586d79450d1508a90d097835ca606e07974fa1bff562955c82c5d19e8684e104e49016f3461e7d0e73894aff421e00675c50a40a99c54c81853546b69e25f2615ee843cf5e6bfd8c6c7608af56928c7780df8c88e4b26b4b8f2a8fe7afe5e08d476ca677b2f3cc1f93c565b8199ea1b7816b01c5444b199013958cd5cc8b73fed9acf1aac0bf502bcd4f6fa88a0776de28a6c925ffb37de19745f100b7545abc5fa60854dc60ba3f54f54fdd8311067f2b56cc3ea6444b4d3cec689dbde7e2372f45dcea85e4f9cb83126b37fe1034b92f6dca9a7902f05b83c4ead70d4d54ec3ea421cab235c21e5efec019b65f99d0eead318549d0f14eba08f95884eb295fe30bdb19be1f9c954ae18252accceaf4001ec2e01eda91e7b860cd718de3bbca399d93946a86e495366c0fcee7540b7fa4b310b36c974871b59833cb17d5dbf226c65226007d23bb4bade37c7ce8ada89dce9773c8a5c6802ec1a51b8cc81f91c4be78c02acbc69ee9ee94bdc4ff62304bb732c480a501393e8413011a8576f5d0ba4bc537e31300e4994728f0dfd8f9cae8cef278277eb7d9d95205ac6b5eeecac6dbd12476566d756697361f02a01b40eda9bb669fb5092db6eb181e0ec2577784efb149d458356d7620da7ded479f856840a6824e67ed2115262ad5a896a87087e6ab04aad626042eb488c06f36eacef8b595c57c7019b2c2a361b29c6d5e0c8b98982f48f28b7a3ed62bc0e9677c1c37ab04fe4fb2d5a1a488acc14266fa7b0f4c068fd2bf21ea766e15444f16f06d448935828dd54f4ba725813b60693dccfc7e1694d27b9567d68710743bf38dcbca45a42082784095dce63d75f82e36e84cb06a13ac29d2423fc3ba9622f44cece5fddf09c56374f6cc378a5db6331f68482dc297c06285f6c805776947bf1f9e0399920d67a5a516772b614275b46ce73ad55d72a592c4491dfeee01078c9a8df357f38d807111962afdcc9f995e1521d062712205fa2d2aecf96e2cbf36213535512f5a97601a3fbe8c3db3830445ed394d5ac9e231ad6c20c206c26cd7450cc5d4650de81402ded79f1a1f32b30cc3a51b4a150e9def8f908f5c639e83c691a5256a8fd4db0e695998855e786052c5657ec7c677df2c3ddb0adafcefa493fc1c0577116e558ff810b788453e51acfd1728a08b3576851dbbdcdf12f438e4da57b2ac557d1d283a2529ef7443207a1de3db88be38cafc70c3556d08b631d87b7edbe222cce43ca16c1a076d4f7ea7450c312237105c456999d6b2b1a62e348887d8df1700f7bb1cd934954b79aab0ccd614c2a8e9dc01812604e22857d64842cd64c5bec3a7fb37236cf4222d2da2f3de71ba97ce71254a85ec63760666d5f2c9f0856b7747c381783d952108a5f8062d496f3924305d6c5e0d6f456a3977aa9aa10d4c4bfc971a292dc17d636a4df4d7e3274702fbec79ba3896c88af30551c311f5595ffefc38a4f208ea33b856dfbb2f8a7ccd0dde921b6794a76aaa41d60db0819420d50f14ceefd02ae4920a132c9428069838990500b5dbf6f99248465149a918c5a79dfe96c7325708383559b424f36899246b57bb3c21e62f85121241243e5738c3ded15d295337cb473d0b2e7dadd032b0e0dd896ddd6ffc863bc9f8861104b952edd709a22009d0ed595bff6d7133b94bbac5adcd19a3d464f131764f653a036d99005761461cfedacb0f3228abb2bb7372e4702f150bd8ecc933c117d0933364b665389bb72de0d0010223611d4c282fbfa76279ae6d684bfabcb79958a991e60e86ce26ca9d90fc4b7f93b779a7bc6abeff051051e10395b0a2d3fec98ed657ff4b3244c9b56ecedd76594e7144cc1af4bbd77619af4ab67eb780dd8785b8e575bd29f0eae68560a0ace1b7e36d0fae7d27285df4b83acc27329fea0317af9c7795f2b8e120b0ed815bf8002e2e5b9ba7f2f05984b3504b13cbb540cf76d9b35efe771ee60d12a2d506ad8dcd4b0def0776a78cfe98f90fb53607e226e786958249d8ea5c13698d916ad282e4e0f2e7668c8ea1c142342db82f026ddb4033fd0d85909d881e2d323ca5568dcbe60a421a5e0cfbe85bae7ec49e13a691bd44a64444ca54f4e46542cbf7763f9ae8e345b78a3c2b913cb87289a0647e5cd8db9e012cc0df049b9b33356b26cea9dd1c3de18265f475369ffacaefa6aca2fd46cb1b46d31f136c7c3fbb412d23b33e5b310df2dd64f3e16fbc5b9542410d4427ac8f70269f10221bb6da8118007d41c9115af27ec1fe77c784713d62b3c1be7cf0339f6551e5697df622062171279fa80c45049565406fb193acfc4cf8b0733db16b5996d3a47ce7d74809a546eb018d5efb975febbedcec8f184ab61723d32805b8c7d8ee35ed5e0e7f0b93ea36780f8f940e3cb7f542f4dc9bad773b299f7a42f495d5aa5cb245c3a0a26c5cf6eb21c3e0f41b6b24b3462b897189c0e5b72c571697db6e71aa885c1a5d765c4a042979747663e0199b0770ec771162a31adcc28ec8e506aad9bb784db874194ddc085ab52c560def0fc28a3c10cecc0f1570cda1a45b6e8587a6b778b9ab48fd939c2791aa20a8eee920185b6801","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
