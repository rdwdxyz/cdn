<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7acfdc3e7fdab9e95d63fe6e3c5682f4a4284b0b7c94abd53194120170a75111ccb4363238f4cdd1ef4802698e4e76b90c5072cb889b3e531a3ca847b486057906d21972a7dc6bec3abc82b2377e8db0ae8882886e857370679d129e82e285b7251ae771bf547d3a08ce89446f21ee04c43c472de113dd702ef1588cad7820cbd6bdfe23af469887b357ace09ce6b5dea1a80f8e33af113c95c39b96f79d8d0be3817bef29a5670974d52bf30c1813df5b8f2e3c20bd03312d1e48ca6527e4d81cbbf0aac224319ad7c932b44daa9e32716836a80d27acc92fe3ddcd3a626b7c42413fa68291a3f05661881a23a55b03bd70a67a6bd8a96b8217ac035b4f433d55f0704b0cd971a98fe307ac0c7382f16a0cc7c6ae84d210f42e0ab53a76d51e82680be12836ef86c350229f0cef52fe6ddf0eca7190c8655173344bb0465281b7c2a716fd8ad3c8ce3d21955966a07d3ddd538f3e856e31f2f227639adc2851525668acdd7fead3bcea1be915c133b9decd5116b8d7b1c020b190c8e4f2d74950f2babd8a7d8a85c40c49f55c7f6e0f522484d59cf8c881439bcf33d638df5ee54e74c7636cea02920ee1807ce4b508ce32d1444ba452f44823549fd32212854abb3e2b792b1b03039640591141166f81ae4e68879217abf5739f80c394db96ed6728bf335c8fd4955c40256cf976b2672ee02cc11dc06341106ef8ab25a09bdf180dd8c593d3d63acea34051057c2521df5e7dcef494cd8b345c8c5a5178eb38f576f3b6818153e7ee3f355f4965eaa169f6bdeabcecc63d91c5e4ee13a852700841beec12985876ab9381319dd94aa3417d44d212a46df08c0edb72e3b47b90d12ef9bb3cf37c2ee4a06a9f87cb2430850411edf81f1d81f8462b15b018543a821063b94f3bacf046d159003314161299b673f7e083f33d2c33ad2554b1ef07eee0e10b40a91e14a362fbd1524cdce79c30d9518a8316609f1155157b2b33697453c5c1448827da27b2230737be58b999a1d897b5f1cf9ff2effaa56b1be0c54f09989a248730dd5763a03511a933b5a76e047167cc1a2d56b4aded59351e0ad76d6136738d52b7aab5bb01811d114ebcab03ee64f3ef3b880edb9ce9d959603fea9bc10e12d29fe95689c8fb1cb86b1dddfc63d9e186f0d86dda875976024b1fdbf0c21cf2118a505266393070162d2d7405ee01c9292b9aef610da4d2f04f3da4010bc2ac83f650c574258745d687b05dca379620b3af13dbe4d2e603b02d69b0fddd7e57f58f76b7c2d2c50d926635bd6777d0e162ed1e38f3131b5425c85c6075745ca554e02781ae52df08c87b1a95f189e689c6b05de75ba7d3b0577b4b53d31f7aa5b5fb96bc1292558eba33ad89118105e351323cef4254e6918a69ebd25e047cd3062a8e1f97166b05fd86a2696bc976330b0586121d5f86c29e034bbca30b01990e5723a73fd28c8481f688c65f359f09d5596d59293e7713ddadabec48b4aec635d9eb4a1710f249261da3a8c070084315e12b5d802b4b4cf83c94638e120ceb220927a1d3ebbc526854423e763278077ed24b325755fc905ce53e0db943e9d8f073be28f4f98501697d536520a9cd58ba94945ec5834992fc1c57a299f775fe75a27592a1b318ca6d8e8f948d4bab74e68420093c9609e9870504fc7e2361272ef55fa560efdb36edc0cf603f23a84d7f8bfd068250173c5170efb50174a919c6e1d19625c9b4b9ec6dc4eeb4dc477d05b1c039107c07f8f90f6a1e3c72d7991a36701853e195c694350d0f7688e3ea19de5fd1cbe2ed8f35096cc781734e408fe79d52ab7605fb59eb79fcda497fded165194fdf527be63a6dc6584097abbae33a3031bc3e45ba17069fe22b4b8fd7fd0d34cd68dc0f752a6695ae49094b34e5f553b518657717d304afbeef32a815512055ed1cf48e797612ab286922008dde905ba59daf32e2a8c9daa43f2efd286322f9eccdf2f578e6a0c16d01f87f7085231b82a6f3278469ac3c8e5ba2b33ffc307eb4db18696bfbc1031c1d31645f7d951c04de889ae3ffcb9ca14a304883fd5703aa190bab6b611cd45612dd44c60bfdae68601c71383745433cb6c191a2b63e487c274f3020f79eaf726bbb4c7bc2a92a83e7a7cf42843eaaf5bf3ed38381596064872ba4454d4e8f4c7c7c678bca2b1f5fab20dc8b418d6501766769fc46b0cf3b7848ae67153716fc6dd8eccf5d06026d717c216fa7657a99d730371207216bf4a118863ca7af266a3fcf45e01591874fe8545b16af7a0c2b6a3d72816530b62ed35a2a3fa398da6d06271d1ae8fecf662575434e974cefdf69cb90c57cd5aa39f113b29b37caedabb896bb1ff5e3b624bc63d185c60d83ae65e1b9a3783e92d25a35c97c06b7cfa286d0d0291b61f4a790f46bced9ebd8598818e5d7dcd4fed989c128f7d51b1a4b45cee2229d1312db2000f57a985830e56ad9deab3692bfce35336b35441d1b8f1ae663ef52fe862af0c934337f968d185a2d39e404ac3e3980534c10b99391d47d2db3a51fdb3876d4d7877f88896c68e0d17a66ea55b36a8bcff70cbee376e813e1c19e2566dfd568dc9c38c3138178cfca2d5c393bda82279af1297fe313aa8a9e71ac2ac67df24e6548d8507767bfaf93081fbcfe68c8e4034faa6c4fe9066bb51465aec1ca4cdc98301164b0a8d548c67313cc08ec4152789aa5baa11807ce583ed064a001e14922164f8f77f82d500d63b8c26728434db0f9910de6ccb5a254fa65123ec42e21bb46a8dd10870c74d098801b7950b141825a328f7abc229be3e1f4ea5edb75e3acd8d3e42e045195b11dd4b83e257d77394175c046d49ac45154337ac8ec01285b75d16468aa61872b4843749e3ae81210fe2762afdb56ea43614a6fd5262e91a602e32ce1d3b1cf950182b6705d0b1a8d1c5eb3a6fa81f80e8005fc709f45883bc9e05bec0160983dbd4c019f8ee248f544974a618cb2b9eb9842515287aa06248b827513298796d9be4c7e7d3cf51bed02f70baf951c19823756039a162a25a20cff311a1555bcd8e4a9ced308008855803945541ac2f422723ec04ea1ca8d59e75050aa504941c62eb0e442f2685048d99cf674f3bba0931e31181bcc2c87330190786405252bf1fe9e71f309ca78a5489f3dfa87bc86a4e441773cad6a2ab652e975234499e2b2f74606934b4570040e9b5cbe09b96b6a9d9e32225cb3dcbaa94dcaefa78e458ddfbc961512c877321b252f952695729a0daa1bf38ca114d4f3b5fea6dbba5a7482bedf4784a096ca89c5cac6823d9360e31547b00e430d2a016ce867bc928f926a53451bd591c25d946ad0ca455c0c2706ef87b0fe57c0996b835a078e6ae84dcc486f8c5b91dfca1deb875ac6b901b03aad35990411643f748000f807d206fed19551995048f437a5a1e460d68a37f4b31a988784a4a3ea6fcb27026aa13d7ed605504ee0bd5e7208cc24ff8dcbd46ee406f246fb8d1a322a1033ead11c3993eb55d820e6b6911ca642f33a93b2aa8819cb103ab850d4c70e60620b65689e801fa5d00ca64a59ddc0e95a568995844c0df08ab34d67258fbea1fc4980b560d3678af8591ca16fcbdff268f5cdf2c019d4f605403ce6a4d1329c431a487795569a44f7b5a77969b73a0ab540b01067fc6b7a95b0c41ebd0df0ede5977596632e6a59de48c9e6ad8006cc5cd6782c8bd7ca3f929c8b451270a32a7235085b96f68ff262ff474d34661e1b515d2dc28c495dc77b0efcb5f17db6b691639b7a8d6e5d6b2aade3b3919914e8858c95448640cc2977f8f2a3f0d4c743fcce531d7c3f90e733ef0355b7bad8f7354a4c34be5d4bac4fc929d40e9f426497defaca7d456528a7a69085538f64629a43986839448ea2a5bce268e2f6ef14f8c8c91c6d8a424934a2cc261453f411b85ff5cfb84c1a5a4f9bce8fcf49644ce3f8e4f7833999b759f3591ef68f3c3044de53e3467cbd9da27db0e7ffce5cdc12759abe93db92142c255e74295f7e24c177f2b600c40699180d98a0714d4d899a3b7774059856d815d2ef0d60662475eedc99bdf86308d50651a9e0a433d4311bd04a404566b0f2850c094a94906e8d5c2c493040e0e36f2d16642e09c7901b5e9db6cf5488d43950798a1dfabf4919d2eca3cb2bf5ca2dd6f6a62d087e6b07ec1fbe919f517322103bf2c7d311d3fed29889a2b3275ce48ccfb2b0fd69cfe25cae2fac9c5818a80a6526cd71a92341c5cfc7e02128e51707d14231f8cad06d1cc04e1d4a1b69d987ef50ba0b6a22dd6971b36a9e2afb2e9adaa49ca08e554d6ec1f9dfb92c573ded075540fad5c76c45ace788305c1ced279ec55fd46affd114adc4ee0d3079be75712fcb685ea06f2b459aeb5f92a0a743dbb80aaa241739827220a6b8c35cb2dfcedee14c044daf0faa7426dcbdfc2264b418038ed45222a4eddf4cda6c3f0a3b66b1e6af6760e8cd3479b0909a64a43b0b4b3609fa82192e3b83a141a318be9452246ab760088adf2c74bdcb0078a5e8398088e0ae147268c8a3a89ab91a915a3233ac8fda8c9704f178a3a104a9a1d5ca82133eda66e8b15333e8424583a36dc9e96a9ffd9e6a2a9d72c4a46243cac9e665f23a3130bc510f7d3b0857ebc648e39861fe2e1150a9f3ea936f57d9155af38b5ccfe3edd1e955ff1dd17db7cf01ef8bffab4e18df4ee99f2f682b4af30c3405ba6e36014f517e18a7ca28004337ef103bf07b8ca917aa1f8b89cbf157feb5e0315595b04d3e1bef57817c7a109179bc64a6a99a8d9ee71760ef61d5c447a09521c044e5399c29392134f4cd2c110b634ec9dc90f42c3f754ee9dd5b637841550465f1ddb2b0fd872628b53982cccee6987de3d1f8abce2117a6e34a650882b05fd871e3397f0dc749a7e36e2add5446713487a279d7069882078679d32dc5125aeca3e8d4633a4c0f64b4c88d734564cf25ae036ed30f4a5ba79831082ecce7634a8c3f6292a8f72159db0e071b2754b15b8452ed0d7db3d2e09fa54936419559968fd1c03aefc32e6612df0838b7026a59e1f3e6a1bfb3dcf51772d4de1bfe864a0b51cab9295e6a839bd36249d5179be14ff848561e64016b51f5789edef1cf6e2ad04e8387d12e2511bd72c836408a67d8a0d1cebf0272e8aa75783d3af9fb49d716b91fec3a76054dfd8ca66e9661d1e0c20150ae26c22c0bb9a0cde878e25d4d9803bf28b6d261bff911547ecf2e617abc3242216af88327540f7d0e9c2d672175bf72112a4a7bd991eb7c356fc54ca240129bc0ea36b85241a7cfa515145da97ee576d940f91219941bd460ce6e42354c88d6b7fd22f1627aceb4042f0be41ca0ad3d3bc96e0d6f701f34d908db9c837fa16e941e783370595aeb2e6f0cbafa61b0a9b6eee638b11986e95eeab531f4e895b7dd7da553a618cd9f041accca2949ec9446c5a41c4f7e89986a92b8f941abfe96f78959b1bcbfe697e752aa9a57f0a779ee01a02b097c27e563b76c2767bff4223b9380b0a14bdb23e768a1778093313af218af9cfd90ae56849ccaec381c452f45f3d764781e03fab97674775464b4c63b5db576c3240e3427ae3ada63d109130a5f19e79893521f95167c97b309cd10a183ab931103c3afc68dc6f86762445c22bf1ac7e717577d4367c5c7a8a2593641c4c28122a829455a23603081545c3950e2318d4748bf6317dbe8b5a76d51d9a8504552e582167c2989728acf213fd5e800820ba98a1bd818c2335a504b0dcd443eb2bbdb2dc0891799667cdd032433bc10c86ccb7d697a2b082aeef3015aed2c8015b272c520a3546cfb97657f15e878c57a917d43e885e61df05da39b9909350457d2d4437c48d181b04d4d03a9f546a26fc649dc824a58d9ff325b6273617a6998943b8a116126299260d17bf10d2004befd0597221a5ffdb09c4990af9716c6b5b033c4829318aa7f2c6f11126489a21a98830a54cf7b9ff2a3b1a4e86ecabf685e5ec02ff4fe80d5f8648a87e994908397dbaba9a8eda049aa11452f5649a85ec33570b933336e18e54b57eb77770247e634bc8248196c3bfc446cf8bb97c0e249b84fdfa53bae51f8a90250e9b31726eca1e7f2142f58f665d4af03b0be90e3f0c2dd54390ef7ba5d48f93c1b8f595954fa342a9bc933f1d47a7c9cbeae40d7e450ef13c993bb078bac382583418a1807684c6443b8bfc3645566f02cc451e510def92008cc8617f6077a1bbb901f96543f675316508ce93dba0572e3d02c5652bbd1214b0d78b751686b154367cdd3bfe1ff4af1af9f0249d9124e6e697e9f5987b2e1f26ebc1357a13c2e74ed7836cc6fcdb43f5fe6e3145bb10dbb3da9a3022f764a7d97edf42c6bddbe9c3f3f20ecf7581e00afebb0476c3e63e0b57ea4ef76a80ace264b3e2325423a985c14c7b7b1bcf2ccc00185d7c44da5fdfb4711e5ff3c4cc374c935ae93d1ffa053b8eb71282169f1c7f6add74bca8f99cd239b4200cbad6248a61d3f114b922fa5290de8f7bc5f4dafe823f25da555cccb9a4b0905727d7562086ab7a19f30d09794fff0961d0556e70f5c76c0d4f5758c2835195f812703db30c249dbb33971dbc8460e2cf4efbc14cbbb53ba2fb4e0640ae5718123a956ade73e7bff8ccfc9f1ebd4a21e77f9f20f5a6c68df38510bc423605ffee8b3c6f2cb1d2d704692d370fbfb785b91874cdb1865e9e7bd0e3c80a17955594077532356bd596b621b9bc9848b35af69781f0c4a0a50cd9298ad8e3ac1ef24f6ee7dc870018339b2750686df96b3ba428fe64a11f81fa8f365572aa5cd2d9c977d6dcce30d8701637ac3163972f30c34ecdf8ebec02d64de73ccf9c8b68e2c67ec6bd528fe184a01ad6f9d7f671cd692539d4be47473481d6b9791d85b39ba941efe57aaa5bd1292ca14acafb15eb105f73e5685183210f20ea60f39171e5aee0d5e46c18601ec3b264a8988ac1588b4a297e9c7e1c14146f7a71f3b3e87bd8c4bc636db1cd8421c5ae8ab984847e481c64dc42a74bf48293281261663810b9656a2089841fad2eb9c58536a6c5be3e9ae2225261b7444cd8e3f74b128285409a52de18435b03b163f1d0262145cd50d829fef555e9395985cae535b474712553589b2c4180b78dcb6bbe89c4429760824b6a1dbfda09937b673f6b16b1aba80a9da9f1d76ae8fbada4a1124b9189f9d53724d3f17322a6ce4a10c697deaf5e489fc0b36ed8444817f6c3e5e0bf5208c697914a344155cc7c432ee7ceb17ee66533a20bcb8ea9e301e92bce12020f80797493d33e37647fd89661bdb5b608f2f8d87be8aa583055589587f884fcbc4ffc12221a95ebf9de8a0c0eb79e00d5d23e68a5f08681aa1ab1a8ecc57d096f89d7cda48812bf4a7d4d6aaa3c58d513e220b837ef489b6034d5efb56a064a443e5b90971f6e7ddafdc78fb250982cb0d77b5ae5a395df31ed8073a66446f3633488cc1b51a4703e14f22913b10393fdf126cde29e3d83038886d6bcc952943f604f3e7550ac097fec8f75698277e65a49009857798b24e2a237339bd67e25c85296c0bf5d92f2c0fa60ff553db3c2f943f1031dc473da004a34fc27f3294ff970bedf198e82967ddfaf39bb05aa84e256e2049f4f1ec22bdff9e5577b4d996506d718230c0fcc053231424404febc4d246cb2e3365c5b7160f4ccf01a2e54ea55eb6bd8f2cdff7a01f49905a8e9e99980c4dd04febf64de72a0097d19e7940f5ee5182677fa01502c152a91fe9d5e4150d2f7e90fc4a11c3c7258db9e8978aee51505445c63c82b2838abfea98639873b99d3290418ceb7d613590d7d9d5817e99cba558d6d7f37f79738b1d699bfd6e86ca8124cfa6117ca379f0309b6b0dd83e7ceb2d4980b21d482dbda0f4b1745f907aa691d045b1769d1ec4ec544aa502d19fd68f9eef4b0395750c839dc298a37482ad3454e148693ce4f6d83b902be016f47fa32cfa7f0f88f6e2a44d90de7f5032ecb70f10d38d0de440347a41d1a5909c20b67a0e20e3054e22eeef3c1ca963abd93ce8c2af9208bb76c278dd56cc46e6cc3d7af931137024355cfaecb639d468940fcb85123eeb165da775b047ea90b225548342b7501b726eb415fbaa73d746e8f24a38ab4cf23b1ef4faed4de83720c83bcfb0fe2d4517cf0ece377626d22cf943034ab6f55432b3d4aca7e356fea344e6fa22876084a1f2891eeee90b5b6ad2be68c65b5adda54046b66d17f00da8cd5920050372d59ebc0cfff896d7e3e00b8e2b931e427182a1dff82d694839b5d0344895f7e2f57b14e5f9d060feb63cfbe946a846bd6ac60a17e57a8d5564077748e231b2f4c8fc2edc124885943e70fa410057c1bdf7f183df1ff9b9d5082d58f9326cb345eeb67d26fedd7b9f7814e869488d965a53afa43515b5b572694590e19f99c89c347b1189eb0ec372929e928c740c0af8b59a2f14c533f571d6ee3d709d83ee9a84a909da0bc290e36b60f28e37b86a82270e1d6d3489bd53314fcd237f24c6797521a010c6e98c202d87e46514518f5f23494993850634157a67a1367282dc17fd6ffb83a5988909606768fb2070cddc58c041309fd2f32bf59299cd45e7f281adf1a82223fa4904789d85b1e3d64516e101922a9de0a29cdaad7cdd61f711dacc122d8453f2089cf2a0fd7d1532b239f9fe34faee43c0876e7dcf08d5f8f2e0042a2118450f9f2c4dbf9f935727178853c6ddcb92b1a3f12f3540e33d90fe2e48ecda6c7f5ef1f617adeb4765d11a1df13e4cdbdc05d288473376b710c95578a99c4e00c14a29a5bcf8b13be071ac50f2ff10c7f680b45121f496300f5f75e77d35ccab449dab4070cc9fd475e14e2cc27f196412ad6f06609bcdb1a691a88f951059731a335e081c3ef593da40a4646533c66a9f24406a2d21da24a6e061151a781548d3f929f232e7d2d6f1e9e51ca9e6ba3db3ef2f7850574ba1f0b1d64554a93f98ebf3885df1dfcc604d2cd4cf86c1f65520f7729d0c67b3343bc67d5ebcabffd223039cde0ab8fbd714c2107613305d49215be210bd37870ff00eb2967d2c5f697ff50e4cc020ecfa452b4c245d812b27e4722d5b3b60aa2e7531741cad238fcbce8594e03deecc943ce1b3bae9ec0f5c32be30381931fe5986d8dd56ea1bdcfccff9f87b4b656ba7ec270b06fdc46aa02f4752dbf448eb3bb03c982c53787f36974dc4c1e82dc0ca2bdd79b8c634463a5a13018f72a0aed44214833d6732a15dc79dfe6a6b38a37dc5318bc2f3825dcd380d2be4b49fe974b526039a73b88405245de48866b459f4a3ded78c041c0601a6199d7d5c5f5d3ae2beb0c229fa7320e90d22d3710eba88bb27ca421b6986086ab4c30f1409a35ddf773f704d897323f7f47c680538300e0342f89ad05fb81fac8f809d121935dc18d122c96396697a183af0cd258257888ec5614195baced3fbbb363ad6cbf383077233ff049ef39e0b5c2fc8f9222747e696e941b2c46bc959af49f673f8c12a0dbc159a10a41b06237616650724cae734ec08f0617dcc0e83242aa70b000ac12bf3f7e21fc0f3a2d0f052b8618425a6db780e20d0ac3df64979bdc41225782a456bf1e8e036244916be38e27a02904e5ca2748354c8c90574e4fc9389bbc6d5da1f3016e6a129174394495c16b216a2573b1a2fe2d16842f61dbca248ce114f34425fcec47d1d3973b90e3d2e2b02f78ecd609321d1908ab0f942b8d55b01aff53662133d7d8a60b9fc52afd9389e896314ebf7a01e39e90d1858e976482697858cd16ac6132896d340257e45399bc0f4ddc00b6f4aa16e80d80dec7861e92c2d71beb398a983febd47b27103544e0fb76ac3c3cfbaab5320fda0fbde74d496f2484b8cc8078d281482a3a32e16916e71295bf99df588734c5786a275e88d41879a8351e66d7d1fcb87f6a9defd44ba96e02743adbe9bf214778cf516d3f80b4e6787666a0f82cbc89ebf2ac168490d835b0f39c46444732c6e50fde5b9db7f4158c33bcc8b7030df09f7f8e508d6c69b0df1bfb86240f213390cc4f628be598693848ab0527adfbf0927560a5da8f53cc0ddce115258af55fb0b938434a5e52c93caa003a6fe8e622c4ecaf18e47f1cb661cb40450cea72e8ad0a1d13f182cbb95be0b6d333b2bb053faf0ecb02b40ad940a0a8d333b53144ef07e139a3e49b55d47b6e322fe696892f42512660425d434ff466d887e3e701b9dc53e0ae2c3b8fe9a7699e441be8df87ef3975a34f0f117da0911fbcd7963419f5c3e85d58133d0eb7d0dea72a59f559cbfe58cd07ef69575b0e45b3900dcfe69e11b86d91f7cf7fed80045f926109f57745d769e01683ce5d368129a44908132a37649036b5437e4c90abc96a59bfb434fb4f59628b7bb0c5a4170abb8db4f36fee181ef3591e5267398c531a1eead2b6aa34c8c356c47fd1be180226185fa5b50c3cb71d8b4b6794ec1f7ac582c65f673ce1a84b48103a46ea31c02aeea3253728b29e996c2376e74724d1c44b9424dfc27a50ef62f567b027fefb4a571012d34d59b1d7b4d477f13bd7d2c3c354be2f8a0195587a2ccda9fd60a1611c98a79d8920d9142eb571638f068033d2b0648f64251232b4d5c70edac8c2db3a45b965e643da92a943f0841423fc99e3caffe71423cd4c40cb4b6728dd4f0350323b1aee1f2318192561255bfa0b720a766fc19c8c52f383b84ad69b0772fea129e6c22ca8805e00aa08db85fcff505d70e8448f0b9f130a66761c2d48193364004c14cfae74e49fbd03d40f542e4598d3ab90b73355a00b7f4b1103961409a4a7084f52a3c0d7f95b348d8d8055c86b70eefadc09daba012291dae850a4c21aee5603924b8f59974f5babd4d830969afb1046d1b2218a43b8cbf073670718ea80e5361c8c1d810c746b7a971b0632189af37daaa211ed4a4bd99cfa6b66465d5d4e0d0a29c8d8ad4ba796dcb6eeb654dce14f1c9754a233c1f61b0653970362032e17cbf7140f942fcb7c165aac294d3dcb51cf1c586252fabe053a9778e5125243da817be1dc34932262144f1c8d349f520682cb2bf1f30ad13fba166e0671dafff8926e2f25751827853605c66c916f285378b862d5e67749c26f18f840830690903d4069a2ee03a4e8cb2dab3c2620d58a0963fff5ea667937823c470619a48d2bc170d88570570e8d78b6854de684be136d16aa7a54d7203d3e1be7b016ebba10bd559851fe3468ba063acce642ee6cf1c58c4670c5d0d5c253a99a47e6cc6256786ba6c0f97fd25b55de1c27b23edc2afc390d319e05eb5e7b2bcc932afb5707b4c7c039e10b5a1be09307c53dc1512309b1a17763d574ccd36e67a98fdba5020a7774848af18aab2bba5208e3f147a243b9a3ef65ed1fc5d0b9eaadeb4e6f13dfb6ed8c042e930491f1c431e085e9877a38db1deb69be876ff185733a30482abb8c3cd182c33966d337140c9f0653c967862b7b09877badaa4e0e9e1576666d614c8bc68b560d1a1adc8cc505e6a33f069078029576aa1db98ebca69b6abe3b1bcb755c11b5fcf648739fda946a5bcdd4d2876d47e2c4491764ad8495b01699061da9fa4a0fc05077de59cb806492d30afcbc4d78c59a87a2ca7cf1202006760a3baaaf7e76fae488c578827f85523a6e1d5201e92742963d8cd15534104b3862a2415baf824844c470a143729637321233f5e47953b4521eb8d768c3887ce97f872c4bf83194477f77a4f9f05a5872c68ef8c54c64a26bb10a678d035967f5909481740ab1742ae74e392f5a928d7a355cc8357eb6e076b00f8ca951c46fb71ec5e64aad1e8b851bf15f97cf564f0396c0be063399bfa2d5242ad363654d7257db36dbf4fbd58f4a84d0ee4cc96af892ad2d74338a55ba9c0f54c8ee82b2321d21030c42b079a9fd0dda5fceceb3bf955bf08e3e4e24830ee8e4fb9f0aa667309784684021b19dca0ef24f05348f41b259c8359bfb8019ffa5ca2b7a8c1f91a4d8b832326b43f942f79d1b6999b4ff9173b246f7332c8cd98826f39a35e946304e8090e0281ff3703dd7f9f223e5db109d866b00e3cf6825ffeefd11a1354239bbf525f407d9ffe2f6c0062645798cb2f10b25697bc8704e92cdce764d59903b5650f5d775cf87d38f55bfbe428c28a42075fb465aeb663b100e913aea76d79bddcda5a29242d2164f46464704a1ce4eed8918a0b1ca27ebc2bba2c500c049fcd13f25eef4ef452be4a8985dd01c6062b18ba13d63154ce4e128e72ca9ff4c564067fa38289fa69095125c4d607657b2cfee467483c94500f164333fb096bfdf214faaf813fb30faf8689900066572e430525495eb9437ba2e15f3d6bfecd434fdf08abd169d1fd59720c4f3d5f178407d0c2ed6df68c9581e073520d200df36a5b3196cc33b1a6d1c00e494e7865ad17d6359b0d23135e0f7b03ec94f921daf1d7f50e828f3e592ec202b905c15e5888098c83b7d6ec9ba0f5a4a81cd578cb3043991f848271389d64a1d65bf4b3c11dbb3f523d7e6269073a07d529f7bc0a0e9c38b6f9d5bd2e1ff9abed3d0ada993344e496f4f6fc5eb54dea3634319872abe7e43ece8a6f5f8fe49627b771ec8c09a96774d39f1486edd353514e230b38ae40217c44ea6a41072d47828943dad63a2bbc19dcf63eb1445a362a08406c97585cb2b3f934dfd7bd652aca7ab4901f36bfc570f8f1d08e6c2c1713d65b2bb42a934801f3c2d29cf9c1d08a676a613aaa48a3daf4cba6840addf52cdac2566c4f04da925621ddedfaf8fa2b6d6b27e9eb5542c353f2608468172ec71120516697f8f8b5e5ee11f7ec57bea1bc4ed3e32e453f2d8e2cf82c0ef80b1570c11d6bcb3715ab5a2a530989478d920430bccdd5335313884c5d2834b7c59fbd74fe6a607dae279e5a7c695eef3ab57f18e03c8909218585207379c45e7ca1596ba9ace22199b430f77b2c4064db7b488fd558744803cd4d6ce95bdd4e3c4cda748ce5e7c05bc42048b845a1a061266ac56e5fae71c54d49560de8c833a73b1001b797aacdea557d04e52de1887d9df4d28289a6ef332a066a0575ce367477c4b08db67e37bf7a380cccee41a526997efb84ef58ff18f8eb52e0b064973d1cbe721dbeee225b97255203d777b3800571a43d1cf8c668569818a9481ad7f84a9e5f32bf0086b83cc7fbf082382fc8409a8993e5375c159f7c1d3024806cfac22b92d89548d701e937d21dcc6f369c95e879386d968a6a5d5e59c05fb2ec16e04cdbbd74d732a229c6a5df78fb2aa38fbaa35a961027550191a99a19321bbbba5000fcc2e1c2f9f19dae0de7ea2d06f889122e651f0991b82a04212413c907928918a768e5e1f2d8755178141fa9dedddcdbb4e9c5e408021138cbb6907180e43ff5dcb99b134c599993aec8461c8263f9d5bd043076f9413254cbc0b6c3f41215e08d30d7f821114d340c843c1b8c8c8e8a3a6efcf39f972ea1e148b178c10301478f6c06672e524d8f4405c70bfe903befdc66c8d76427a60a3fae4501bcf4da805852815cf373539f409530157360e399a03b78b65776d973eecb21aec408bc2dbde41930a0e06929d89a491eea74abb47a9fb523ef52dfa2bd33b16b81c9a8d725d3d8b531ecef6d9443dedf1035ce001b6386fc10134bb012d9c00ae2d8975a15ab06708cb59a2973a17dc68b0692b81b51fbb0b2ec44168a1a9057d0db08545c0a300877903402d72c20cf79e93ee84ff054593c6c7817bc1e9a5c2113f82a664995d7c426e118b8a5631149b7b828b3d105db3b734db5b9e8e9b2580a60abd2c4c24cfd9036aa66b885ea49a2d3d8a3699f05152828d724b36b197009c6dbfcae9f1b4898b33ada47f765a6b59ded635545b799baa063eabb1002b99f088aabe715ccd2aef6d4f962b31bbf637f8a943aa3caa9b212b7af249ca05ef237a6b03e82054cfb86cb4cd23aa3c10ada313cca727a8a911ea8ed27b1683aa49911479983c13edafac07651714535b7b5bb2af79b402ee200b15f5089db66307d4db472cd740bc9ede74cdf00975987a3d8a62a2399bc768836b04c0c94dd86283cc358b7a120d067f35e033d435cb1b18e1a69a0097ada806570567a24d7568ef9c312e2815ad9842465a950c1f325cf21b91ffb314e95bf2fb038837d37d3ac87fcfee4fbe73d7002eee5d7952bc3ce03a7067c7db505acc9ffeed4d17c910585606199ba8c26da5943c5504f45b3be530387df25be7ea3c64a5abd9d9a45974da28a91bbc9ecfa64e38e549287e102139b1a32c95a1231a6a314297ff841781d019be256ba30da73d9a38510660658d1aad6d0e70b7f0df80c76db67702553529a768d8221213ad44e95bec29b92b63ef22afa02863b7a5d3799a742c157bd6c4f988bdb9c17f4633c2ab1bd37e0a2fd61e465b0f344f8ea4f6bf52d34efc234af297bd426c7a1c0289b0c39d437a5cd31695ba374bdc5c9c21e53e2c7727980436c1a95e53c805403a730f1ebb1b55b3fcaff67052d76efd29fa20da2e77fd211266c009305b85fe0ffd744d1d8a2e60f3c22ff76a9b01551ba57023194029a5128787ff6a29fde92f518aef8e8ea10a3fee558afc5210d9c1a11f0950b5c698d498c37ef9f1ff5819e59f133ead0071d5d87169625c1db027c9d0cef36493d4fbce8b97adb1df27be68d33ed43bdb897f39b7fda3e033e65c9fb42b47be62848a817ae2bf064c8fe40bb6d1834e2fbe8061c608632729f7322f29b2a275d2c629e0c36d1b65b43fd3d00702a272ae61ce32a1b67f0be1502aa79bccefc57526f887969be93c41ced82d495809c9f3f71167ff32fb1cb0b8b1a40109c92a10504b4cf00a1496ec872ac49ca035bb41831959a1b058cb31b3e0dd70510efbacbe03a8141e932dd677fb069c369fe50d1a7d62235a959fb5149bdfee7f5dea3c468b9201f6c1d37ed67c4d0c7a9c6f41c151ad3dbb2eaa40f18a5665002de4cb74458880ca509ec3272e0728e687466983348723c85257e2ced711ec268fd830ea7c94cda6950e3217efc680dfda613718ff8a6617e00bfc0a46a40d4732648a0d729bae20100582001e8d5a8481d9329b8e52b7ebbdcd23b37133fdc5f512bac3e31ede2dc548dd6ad526355e0db52336fff2bedbb2f5b7e0e1a1bfe5cd024a49d261b68b7cf0e3b350a3dd6595d0a99cf8c191e5f62ad93676434440c45fe67196538d853a38ef0ed8070c4561d74c2d4159c16c76cd333b8b0d7bdb20423d18f4db1a8fd04ab00c2864e99a5acb53979eea92cf6f48f297383d7b7009e723c26ac47fea09097225bd636210325d85b8373d85c53ab24a7458564189c7a21cc4c9eaf39d4cf73667844724f9f87a8ebcdc0bd16dfd03c91c8a7538c0d1befba770c32a044a5b1792fd6d162387376b9768139c9b3a2810352a80f2374f3e64dbabded6bd3c675799bcc34f2b62a0018d55c9574547f8e7829fba0c6bbf9dbb786e88fe764dce42d8ebbd375d24447f74e7926b842aa871d7a539e853eed0f878d8fb74214c2c8068bc6ac5755f0f5cee2964c608ac85cd7c4323cd4e332ec9711ae798c1e13eab1b6ef364423ed53865a34d0ecf997c658dc136adfcf6c9972fcacbae0c05292503cd5dfbbf65c89c5549b20d17c356a8beb84a7fe404746c0d47f52eb257fcc6426f30d6382619b63b4bf8370f14b9e1fa1d2a1686912b4621c43cb4a50696eb9f0183aeea4519273307e97d70091a53f6670a80e69ddf0be9e3e46e03aa2214821810124d8c1823b04fdc042f4ee5e16e43525513676b8ab32849fc06d922703315ad27512e8739d71a7dae42eb3028e2237ce6381eb7124139cf850a577d12d41a1937cbd3c946d7afe7aeeaa90d6ec457c734728f1249b0dc51e7708f2b4f7bc8608a73e86be19ffdf61ebed966c2813f4f0a57781e2fb4651fdca41ba615c8ebee2513e9eb11810b8b72f562ed90294c8f4a199714251558ba8bfa53c77e6b88ed072f4f227521e0a1571ed875f3a418ea66ab97f62c163f396c836677edf46cd442d09d5125fcbb9dcf5229f7d8c0571cf27446a6b2bf86e5dc0dc9956ab52ab721c302ebeccf9c8b9a022369828ccd09e2cac70d54d169399ff0ff1397d7ecd48b5681a0338b2b731c3ad2c549c8c726188f540af5a9bb6f6f5fd040cc5e1870bd78aa740406153ea59c06bb4b8d22729d78cfed394465080330ca67271addf3190136cd5241478d2872d5caa24794ae1e0211f3fa8b8d901e8a1ef570163046251e284d1b88bdc4d48dede5626953e110ea4fd6b1105847cd359cc1ffd04d4fbe872802414c964ce09413692d8099613cbad7efab09570f8243c4ad55e208b30796d0fbd6b5b354d097a8121c4799c0bfeb8f25cddcefb24458318581699a17d65208566bc75613cd52bfe53adb88ff3b63846e140c36617e47a38eb2d5f1ce54d7590d302508fba34514cadb410bff0007f1b7859016c1a22183efde2e51cc5c69bec16edd729a692b401b69b801b62ba6268f92577c73d918d8e3223405fa8712ad0e2ed2b23f29d78f6346a01b3c874ebbe91f21eaa46a2205bb320e7e8eadb284b958e8e59eff5499d850083002171120e32b9d43b9ed3cd842233f1a1c1d8782cecdec4ecb7dad91d8805a20a26ff289925077062f09fb7cedb766896295a47dd2c31f79741a18514d8a4b2d53490c157ba38c4fd64c6599c4a4e405124fd323fd6a7516022a58f813be5c65038d23cb003e590e58a147ceb53648c7335c012a2f3f36673cef76f95dd1725e5635d50096ff36cf531ddf90e6a1f4c70ea7426f33c0fd913390281b7a40c99de59756d971feb69690d525ff9f56c748539247e9be4becb77a47362c6215b72e1abf592e7fa882ac560d172ef866ed31bd24061c48896cb38a46af4b8460f56b58c17087f6e6463912c2195a0a9add6252f405a0ca8fc5f1bc1e077497e80e6b1dfa8881ab3388f6db8758b88e1add6e304fb7a2d8196ab229e720322fc96a19fe3cc43953ba2fd68c97f29c2f9e8b51f053fb4e2831d913ef74ed59891f07e5c7833d5220376249de3660042dbfd058d2b0eb9bd6c58da42104ab8465e7a2656a503ed4e366f6f21d726b4ec96fcf03467639ff503b6278207365f745d0c92d808acf0d0456d3e958328121c021fd917bac6e34da86107f8cd325c70493cdc1562d4afb53d0a9b33b8f44e21e5d3d4bf17253a06fea43aff0b62ebf494f8a19e674e1fc2a02ea7b6635e4236c6a08dcb6962029a0a53e2dd7734d88327e3a7b2d282011818f5791bb735b2547c975f60475e28335c0a872f56eba0423db8f89ae64775e5a5aa680d849124181067918dfa79fb51d290fc3d7cfd4aa3e36fc3e8bb02ff2f58324e2c0123013b4fd0533c88825215f9cde261d450d067d816fbce8394796fff3e67ea3c769750992f575e9486a755e10c9b5836bc32c830374f1409142a32fb018fce79f970957f9f33fe4f6ecc76d06276a52fc57bcfd0362fe4f6740002d79c724d9c7bc1cf967e9723ab7512ca145c9f3ae674bba5f0d7505a4dd5cbd1da5cec5855cacfc23243fcf1afcd9bda4da2968dfd857d6079374c4277324bbbdf03ca9d2e261c74f00ad0a12e9b16879be179111e1d31fdf56d354703e5e38c10935b5a00deb0abe5f802c63e796e43576db9fb055860cfbc11a25d8b563370e9ad4e4580b4de56d98429778accb0cdd998eb8e09229dc8e6f5f738f42902f89dc6861de6d2a6647fb529c70dcbea6c24b8e9c7ceee2a69164f9fbdfb298d85eab3f8d9e830c612b744f5301a2fb13450ff9a4ba0c04c08f36d8778f7e51d89f09feb5440e58561161fd9ce0381352e0fcb610320e1ed365b0a5480b4caa73a5f4a280ed3b99569b013b621e6bb1be7bc8a0aa89127ffd866509d9846aa17066aae4a973ad9450e661b341ba4854b45d1e68584f272925f86f4e1f01b585db0b43f548bb3cdcb0a5f7b93a8442f537d776071e51d4a5c4494e901b34a47ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
