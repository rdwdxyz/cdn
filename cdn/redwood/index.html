<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c2de8675b412eae53aa1aeaade63a7223ad23b985464329d2f6c63521450e625a2318c638ee4426b294a056d6eba7e46f929eefe651653533a181ec48f9b8096e8bb33c22e39e66883db3963d65a42448afa462692c0e73227ed507d6dd2291d39cf02feefd654740e40df0af0b1cfe60b91e42da436d5dbf843ad7936589d19bc07a227f88306c82af7fb4547b945ff3bbe91564e06f546910b7d8d774306ca22b763d945d2e5c9cd3061c4ffd8c6c0b5be2018cdc66a1f2adeb8f6ef686f04698ba8523347e353b2e5cac48a1301601e41403f3954b286d0dd9ee78ca5284fc5c2e45dc517a3060ca5ba3bc1b23a5c40e31624a509a1be0b1a788ae85f3ac83009d4d96d34603c7c2e8d5e807994fb531216229048d6dd6ae12b7572667f0cbc65cfc2fdfd60c3bf4536ccf4bcef74647dd2c29e9e9090f6a8e1bb617a10e68061e54a3d9e03e0046dcf95d275739fcd711f29ddfe910b34c5b164d3e79d488af69d4ace38fbf753f1b073e44ba9ea4e350433b039f1571b2e253bf988f29aa6db57d240d8aee29b3c5dd79c1a6a71aaaac16a4ba13c6eeca031598879c0a5ccb7430497e7be772bbb8df32e2ec791cfe204973ef329dc5cf515ebdce014370ebbd94984993283426227251f53a4d380bfc65fb95832e6d1efaa89059a031a6151f90299d324ce646f205f5b6aeca5d335993b64826186af65a0786728fd6dba94b8fe1062bd67b8b5eac8ef048586b171c3a53ba23d65dff8de602a7e587161bf5b0563aa5c1077a9f25b70a5c1bb9c13e229f859c311176813bd35e3bd51837c22a38862a43787a178532c6b3b052fd9b2653046a59fd1bbcd72232152636e71b419d359b3d4ce74af6d5769e18082b4d030c8de0f6ef640b1c2bbd805d95060d582db139bf567063c04e046444895b29af0c6c1541e3232d1de76a8b7756926e17379b222ddb2b29b0755301c8c10614e162df8589ab962fc8d83046104c0d3d64da9851fa660a31cf1f4c00febfd6c8f43a8d60f5fbe3dc4608a24ba05ccf4baff4f7e05160d76e43cf639bb3a5e6a68d7707e611d7ac276373acc5a2f0cc7049036ee48af4e23af6cac57e2286bda6cbb6489a820ef736f8511976552959be895b492e9fc1ad341ab82f3714bda55b89e780d2ed01c9f7922e0499fb8f1093784e8d3a293e0c32684cac337f25b9895a217d2cda2de7c7c354a00f57fe664f2ae3b3174d8f18802cd1959ce188fe000a0f470e03915a788070e6f7effcd27f43152eb73435274855cdfcba4d7aee8cc8fcb7d63e38f7d9de18d63da9cb2fa3fad4e3e5bf84c472cfa7e24f8d57bd71404abf1e0ff78ca0d1979bfebfd10ccaba7ceed474e978688cc383eb3f0756594dd396719483a639704f31e9f188c5500f5fe5301643f7493eba6911d052980e60e3a679b301ead97676a4bb4d9bde3274ec2564d0d01007c4e1315e6f60dc97449057cd23a538f9d1dc3e40cb0b27b89e86d6c482d50af1bcad2e48dcb3b0619af9853ee497580a0151552a2cb09a4100b5512527225335bb0324f2619680f69dfdef163019888991e10350d517f920287c694239953bed7be380d46e8c400ffc77c90c31e49bdab38bb068cfcbb9675d83c86b8c99c208a35a274e6a9c1b94ff2ce7ba09b9528c327d0d7e9e8b1e0def7e9ddfc30f7d691df81242f9b23b1b979dc6aa230ca53e69022b9ade9f3ce705e3314740b43fc7d87814b13a89f44b283716478b39cafb54a449b5f0f46fe63be301ec4bf2904c814c786e3b1010268c3c9f222f02f0d2ef84da58965b1f9dfd0956a6e34bc2d56a07cf7fec3317c839491dcdcf8ac9bedc140b799bb793878221a671339bd75da14c7c15f1dec0800349c158e6165712f15758e539bb00b9fd0d820fbd97d99eb66f43c00a7be56cd36bd8e833bd2e2899f8a8d0851c6c15cdb1533fba7070774f50097440ffa6321421aeb710914c589a3fd7f0059c588d49317c431db8f5f30c441bc3f1661e43a571b77bb99cc725727427e67b07cb68e1b5621656782b326c97d4eb8c140926c90c99b865b4854845abb0176ad8b461cde2946faaba36842956691a95c3394cd98baff0b256a96933b643d3f0f09b2a077d46eb9216f8c9838b5270a44d900da4781ce0632ddbfcf04e9d80bf3421f28cbf44cbed87410a63b43321151852e0b5fb47d455be758df54a15278a1c06b8f5026d497d9827d4cc2a9e7eff177cc0401e12b58f3ffef00733e9e5d97a6ec50dd989d8a51aa5f9db82a2aba5b9ebb6eec0fa27b2b598efb0dbc66dbc7250f50657aec69b5f1d06c70b0395b825b74aabbf1c63f9a7b3bdd0e42aeea5dd099e256e68761a59f2f42ec3f7b219563f9301fb4da7e3872b503ba31c8cee16b17fe981577f060aae155e7edb5b4cf53114f981edd29899dd34386d0a7f2c977fa275fcda436019628ede19d6597a818420e88a8604e06e237b79dc81501a87351b29a22aade3b05decf5da1749d2619ff3536c93d1b311b1777819638b38e2a7b447c66f654c67ecb46310d96050ad6ccb37ed0f37b2876658dedce078b03f26d87c274d380bd183cda03ecd4d66248943d894669ffcf700609121513497547a2a4a20f3af8a90a2ac763b4fa4d2e78eabd560ce8377cc4d7e9f2b2e92a79eb738116ee5f97613ac2bd5890a90a0ad6a5391e1d5d64780331ddc6d41b7c87fba4cdd97d5c8f79394576f2aeec8484416407f032a2e3634459bd7585313e21643a72079bdff2dd9acee28c6c2e44f322a91db129cf85576b66780e0fe7d9e55b77e765bd879999a00d0261076d7513f7bb0bfda6963b34417c25d45d562ad3681ad607e19a5fb2d0273e88ccc1d95c06dad9c3cd4c4bce21209dbe8739cad5daa2cf0c7ae6816132d00153f97a45cfb2a87582678c24b91073fc164fcb1bc8733d442ae31e4aad7a83cbcad9f229d02d80a8cefc2a6e5f53139e397d8c7c9e2c22d3a1a9e27ed6d14d366aa8d206d619f401da04bf49067a68f2827e55408f2b884595c52e507fbd75aacecdb4ed69b354e0b9dd5243be790d1e2cfcdfa93c14ec9859c77fdad1dc43751d98e2fb9737b32ab22f121c69d65b906a083ea9c361eebb02bc13ec547cd510ca522a8e26ae94b94a881cc05c1bf9b5e82a276591496b56fc45b822117cbb1e4845dab4ea06d1c2a3a63ce38b49669282a7df84882e21be107229ba72b92f2255042d576012e7abbfafe56c2280e7c544a971803ea35d9dc8c57c8defb6a3b7fc25fb0168f2a235773005d2eb1037451666021005873673bc35f91c7a98260048af3b263c269780348b7faa1db52df675a1ae187941da3e98cceccd98104c136b8e878de9646ffe3087528cde1f7504059da7930452e405642bcd0e95e2e1271289950372f15acd22705dc942c85cd7f2a878a67abd3568a96d583a2d96c70d5be138004541a0759894d30697bc27b1197b7d4762c4ce7893e0c1f8ba7c6bd24e4c4bd1278381ae2e43e9d4dc7fbf782da04bcdd1f225cef685cbd0c1ba0834ed9abd3d166b8fc01ab68ac5679170e86d8c9a0ff605c16816dbb23acbb1bb906a707301be72dc51de89b63c97cbe59cc73f354fc5eba0499155f2d469f614fff8ae73adf10ae5b8bda340d603c4681a6b36ad56151f46872c1c80cbc1ade2504ae76b37295d889b8c092455e59d53e54769e354c7a543d9f65a31ee8b6eb87c76f1e7c6df06894a0c11e527888e6e36ddf05183c12820c467276b1a0e53af363667b21e74302a3dee9c5c56bb6ecd9e76d513ba18c8d74b3321170cbd64d2a95b35ad0cffec358d42be45797102a903a882c38d6bf7e1764ce0876260fe8fc268dfd8adc06f772c019454a3898e8fff3b1733983df76d6a687a046a612a3fffa6a72f155206d6dd803d4e24f4627507c58dfae902b3ebca542d56beb399d76162d800218270532d1f4f3b9af669c1d0f77a32dbea3f578ed4acbc433bfa2ab6a0d7e03f5131bd39c6073afee885edf0e59f13623b1b94ee09cb29e8d1eb3373d1a4ec60001a70e8356fbc43fc5c1147de20e0547fbfc63d2943ac4cda8bd96da24b978fb7bf48f0e8a055666448111a4cb3c741d3372b4b07c282a1686274099aa985501bccfba3c1a8c4c21a17dd6bc9299cb3b8ab7c92d998dcc803c67f47a1cbb9637e9a484dded77704de89dc42752d8ae1d18faa0565ee75b43c507210e55838f6fa386a41275064b988fd08f17c4f609eb820c8da2bf70b064f43855ce7c86149bdd611f14786f2ed9baffec87a20d0ec43ece40c8248f03b0602c7ea30819eb0ddedd9ef5115af2b4cf9b8dc639cd4eda7e9c614dc675d952844501b1757716a3455d50dcc525f7ebdaa3613496df4c1e70b5282b5e29a739ecfdd287c36f95a47dd3b781d99ce6ed98a37fbcda25d407214bb9d070b84226869bdad2a15637903fae757d7250f5ac199f54cd216f5d23379e388189f9eeab7688156208e2f3303910bccd4cdf09700ff0f4c8e743b6662ceda272354ae5babb9f6dddef031b1a6b6a9d2bfed2ee57995b4dc94bf1541074ff388e9fba816c1abd789e8f1ba0b34018bc5aa49864d714ff06585a42b7c83e30cde42215150fe4e17cab6f6b24d20b621b35f89e61cde3cfee490df393653d745a546df1d750f9a48a66f58dc066617d00967d9d168233126d674a8fe38b1fa2d13112e636a700849cecffedd52f50e57a35fc3ffc40b814bd4503cc1934c986b67af4caf7874ec9b9750c06bde5b47bef003c466d1bab7eaafa9e899cc25286f1fe2c7118dd21e2823aedf5d726bc264dc54c284525cd48a7c52d079691fa07370f413d8f548a0fe667c901ed966372fca3a93c6cfa4eeb6bf6b388849e0f6edfefcee12453f635580d8505f3ad6b20c1ba88036cd1ab9b17f2d7acceb04c5f35f1a8cbbece87db0980e02cc0d1525614bbf170ad76649d6d34225643735841b25afd42e162962da9790803a7fedb7ff45bbe31b3bd61b1f6e31dbc598a10b35d88cc4fcc2fd0aa659f0e377d839b4f19702b749f1f6eea09a17ac6a7dec7a5aedf3fc029aab47fc9c1dcf44f2b463085973e37e89658abdbe59ee2b449472178d821bd2d8cb1f46f00b8f2b6da4a511d9654128164a26b69b85e55e27dc81980506f995bc1038dc3abd51b836e879e4202814b73ec5badfcd82db1735c1498b54f4bf2ed179c4a16c55e6271bfb15a5f5d589ec9e014f74bb5a7331b935bfceb911b583996293d7b7fd4e27b3e9e44258a4cbb563815df58b671cb7c698f79f5724456643c66dba37f7195972851523e41883b6ea2ceb3d4a938ffb48cf0f80e9a0cd60323c29637cf6923296853c405130a6f0faafa5dab62e6125fbbbbd1b7934e801c56e55c014965849cf133fe958e965ef533960ff92b716cf0ed10080bf841fb5857f031c6c10d3bbd61ec784f5b32fea373d230e83b024ea0f1939a90cbd278ea419668a70c7e239ad78c5d4905d80412e102f7efb35f88da9648354f8a9886074514a96ea3317d10c6e4b11330d24f7bb0dd3318326a34aae4a0517a19bbd0e8d68f1d2b3ba5f12ca3ff3589ed8664e253ab229d918bdea3a450d2e74bbd9d6fa2d08a14d6ae6c764966c95b948a912790bd402659c5a976c8ec0f6a16786193760b6b02e6e8bce8b28486bd7ba9872c6f58f2e41122a42e0f2f78c8fead22fa6e51dbafe6312553e98472a135d9cd831d6e5c7b6238d999b195f776edb2c32dee0d787e944d4bbbb313ddd6d1e8143d290b91721d9e3bc64f3f597f429acd6f313dd6af1cfad24085b4430dc768886af06918d494b970a27248eb1e708f471917cb752eef47e880eee2fc2ea7c2fc97c11716be05d55ff29a328c5661160bd7427376f09870b24f22059deffcc4db8d73358b9ee64b1e159048649845904c6aa0132592d0803cb980639e63a456a9a6925957eecefd18a6f3f246156555c130714bcb659c98e2b2b9fa84a0eb232469b4c3033fde558539ec6428ccf82e1ad6102380b975b4bca402b0b64874a289f97c5f9f32bc0e8b7e6646dd034a27d210eafd7ac454b9ec6c0d7430e102f0a0f960d583ea318053f9c1ad192a2a9a767eb6304ac41e553d2cc3a1504fd9bcff5d49cece886a1f4f73f18a9dfa5aa6e11f13f4b8ccf113d65847edbefc43272e7cf1d49ce1602397a8ca6a3cb0a479464b831569f6f408a08d4c3c6cf6468e3f1e41a625d33544deab0a401aacad0701df9627582554758e1128d751bba37aeac8edf2ecdb2d1dcca335d75b8e254d7a2aa6412a843c78172f8554be9b5e0dc1e68dc1770575f4fe63a9ba0b3d8d6190c64a2edebfb2bafe5374dc4af84d048e2d4ed7994486347f863945c9d1b5903fb5db4c9716e61f6d305f64f7145d3c59efe964fbabe8edd568e319a474df8a7dbedfd4c76455e1d63d25f00fc8bc200766d266fd42161489ee58998717d434633cdc4234542bfa72177b5d24dc4d92376b3790b8bc0d6c808622b0b367cda7ce1cce7d5b3e22e27ed0e1001e2eb6cb5e7afc56b93549d0c0a301fcd717ca1b7f91e3e4d87d423800228b9d72881adac147098d4c5b6f594ad3de2515a61c9332c330c2aabbf32ff88dc778cef7abbbe9f2ff631fd757cd5b3100e8d35e3afc0020622cfd98d9f13cd8f34e2f3c369fc053385afa56970cc305affbd1d37c2704e50aa0613d6043a828bfc285631ac4a0ae472e05ac59105732262264174bedab4c17f75e3d8e8be2d03dfdfe6d321db88e0f0192a1f21fc7d356192735e10b7c4ee1eff45e89ed8fd165efe13b7b2de0dd514464aae64cbe06cb534a10194c6febc2f42ddd358dcc0733473f10d5911e45ecec003a67c20cc48159951ecef7e30ade4b135a145295cadfd4a2a1c880e38683887373220db3b4909a36e662672b8db898e3632335c1cea016b64824eb22ca338861be260d98919409e083f3fb0b424a196bdae79c660e4a5bd143866dd8ea2f7e6331d5b6a95618a18be792e931065d75d8477f0fe07bd4d09fb7824144b0d81a8197217c03e763571df9d02ee6ab8f6ad384af9ce20ddc9b7190c574fd3964399c57a3a184ca6fdcd467cdfd3363a34a4b1ff4875ab27bd548b4bd9e305091e8880b0ad3ff0ae6ef8b9c377d012118c0c5caa0dee811d9cf8cd26a2f373266e983d6b166ae980045ee0f7f2178c77f6d68ad94c041edc23caa50156c2cca586f982d43a45634ce0ad8ad0fad5b1f3c70c201c40bf6b488f2cff5d2f4193b2616bbfeef5babf7247b87e15e4ef7337e09c1a1a9b11e23f3abf0ea9ae5164da64de026681fefbf1a95d84f55066fe91cb78f58515b91b2b850566c76ac0e4b8f480f427dda0c0c4bacfaba6c105ba89759fbbaf8385fd564099276b9866375a84d25ffe73ec88222f0e16099b74d0fa5aa9ec0c94381b3d16b0108200b0a9b7568c10f60fdbcda4658745ffefe2a41f33127e8a0e3bf2a68c0d878b17dcfe17a6724e570377383c0f4625140223373b6fd976692476731dd7f389ccc6dc73686735e09ca59e719bf78ecd128a81a0ea13cbe2839c84ab72750f380ff0319f8db40d3548542af05e67a6621df63b99f1a65d61b5df9decb797eae041d0e196020f9ea6e28f8c34e693128f925bfbb556f1bc3778580bac47fa08c37af573f322c21457c84150ec69a95c8764f498db1430d8f8549e0fd39d1f3f6ee763add825f1ec277a52489e6b35d32dbedb57709bb8d17f4f718c472d9c68bc1a3072e46bfef25e106a559a0d3b1a00efd274ae3982c9b44f61b6f51c279f637c5eb59ce3d6ace41b889b6de1191cea066c966a3192769cf7e7a9114c3331b61ae8bf9e7a6a21cbbedb6fe449b7aace28c353fffe696e6d6aa388a26e4ce395c829e402fe1fe4aa4ecdbc639288f31e52eac3e86252fdc4f51dccb142c29eb5e13ad3e9a9cb92d95488ba87f6666409e1b99b80f78564caac02a80b5ab7eded2b5a45c0aa343113f532e0afb85cb1e437af682911f0d321e8fa77a589398fb95a54a633d7d3d6086ba4f15dc6eafc80664f38aa5f672f9744f19901975a5d0bad7e834ef1e2c7fdabe37d1e781c797119931ec25a9feccc92d5f1e50041504cca01abaa3d840f4296d7c0bcc18ca18014c9b29a16f1e9c06725e0aa3e5034f19a25528db5d7903aa3d8c3e748ec87c60d39aad9ab9e6d792bb0c2835d1b28fede33e11e5373696c5262acb7535cae8c51ff72e33c5f464f836a370ffa8bf12f190e185ec858c41f843a01a5b03febc0a14731dfdf4be4a582f93f823827f568f646ccdcdba0d029681c5817eec156c80aa3a13ea4fa8922b4d995852aca297eed813ca8963ffe78e03ec09d93e009c75e4e22ab6261d11b5117317c9332822e6980188930ed886eec5c9c8dc75c19206b4e88173ebbce60748bf5a087d11d6c7ab167707dd93eafc1f91bbbbeecde921170e98727227fce70248931c159e2f2434d8c697db0a71fcd2db693b474cb6f9b0c4e32191e49be530dbef3e1c04c5a2049274175ce387d1c03cf8fff79ff3ca32b15c55046c8b4f413b58e78eb59c21f58b1eb955e21f6e0aa5a577eb08287d91296dec6de54af285549f229ba8a9df1edb6108f271eb92b87ff02edfa667e9e8dfb640683798d54333124aae63d44980ed8fef97e852c2a801cedbaee0eeb36a434049b2037a45f99efe8ef411f5bc129653f68f404dfc3d9236f2b1c715fc9c1262664f81f018c9b9c25b74b34f2da76ed3f72701fc101b95daf4f710d44071df725e0c0e3304244e7540b1a0d6854c77c0cf2f03669ec9ad761f864cb67654c64f3aa2d4d5e90925c4fe830a7dd6d9fc3e0e20449a2121959f829a0fc7cbe9e79cbc7d770225be21ca0237cf1ba419249dda5ff1e5ac8b04f826d7d78ad3a25ffbfc9d9a412c6c75196d600697bdf9d27b52be1ee1e70d3fceaf34f99fbd724a998b76a98ebed900984767e87cc3c932872ec311433b7db24ede77568d1ab3a78fac7886ad5124592751a7961ebf1500bf514455035d8051e60bbf5646af588fc77c18f39b2c19152b6d8ee08de9491028d4102c2e2ba839a78200e354ef669d724dd45b9cd3c8364f148e48bd6ebe77069b41d8e1371a8bee4b8ed39a40ea0731cd86ba7159a4358e3e94d2962d4c8ca05ee37842bb0b79af84b7b057292baab5e9af296826d0c7dc15bc27aa791a0c069bd92ba5318751a89c2365d221c706c78dfd118caf9653e86bc3cfee500c8f0240da8752cce328ef12fa009b8fd3092a07ae7841b8af2919b53c1797a1fe726ec7c606aee8df79f901145698fcac7e50af47c25746561167c8306648efea248999a7c365a3e502e28de5bb997e1e09542b6a99a81c05ab8b7aa1bf0b4eaf254bbe4e2c2d93e41a84685a6c27b16b7a9b48b8c2b021e43ef0b625fb940ce67aaed352c6533eb1bfde0913668d8a2c0e7c590f7091c6e11d9903fecd630a94565145b965cd48f656428e76d207851429c608889115d6a38f320c1a2ad43c01a457d4e0d6eaff4f35535220a9c07cdeca82680b264db41516dda08bb20b8718f1f15df18f86a731a003eb6f4e226906633b7810ad0136d8e1a1c7ded597992a5f4cc51c35be97ddbf985c9d1d5dc9e271cebdfff51e49353ecebd0561cee264e981460aae91b246480dd42a67cad011bc151c8cd901b663b2667302a7e7a258fd5a3968de944efbe03f4c5276dee91531c26b2da40f3ff55fab4fe5ef092fb81f4e9fea6a41fa5728775e83971ee6495d9e593ed1b3f1a87a8d9935b18cf1e42f55cf7a5d7ec5d59684f7ec13fb253bc820b647751aa35947b87c615e7eab99adebea5018c97ce4fc258d00ddbc1d70190dde0def30f8d66daf65ce05f465e0bcf9237df000752f564353656a7619f5e27cca9776a276959eec95bafc478ba21ce494a588f60de71376d33695bb673305e7ac1b5ae8df47c02dd85548c55ce2d3e1e4a8ba1be4ef61e38929a173d830cb6e267d9029b2dc487a1ce368a7ca21a84798d5c78ca0098b835456413cab3aaad620b142af823d6683fcdd2a042887e9f984d76b2b3e38a0366463717b10f6e84967afb85575f174fa6bf6ff39105e21ce7af230c71a2eeb3828325bc9ab4395f8fb80577463415be5d60c2926d0fa20f90bea404875e2acc52fa26a16dd9045bcc0a9c002ede202536bbd4324fd0adb10d2da81c0410ce74780595f886d5cdfb0dfabd74e34c54e26d4c356d7b05bac271e3e619fde37a998ebfc0cc1710d4e152f0821b249da15e4aed7f44af5a6fe4f02738b1eeccd21eecbe78f0450e9ac9d2c7bcd6bcadd6d7b62d26f0166d2780eece8b70a9ac12aec6d4d2b1b51e36e0602cd992b87c4f8db2a00300c2a6529371a810d882002ee8136e04f0c4090bc9ef35ba2d9f489fa07b8e8a6e6cb04cc241b288e9d40dd0a8706dde8e1f853b291c8cdb978cdd2951f7e640e6181fd807d2b6c533a8b7c67234d5632a6879d62af7bb2ef6f4475cb87f693abe2b459ff26182ef8c1a03b049d4484f912dcdfa7e3cdb88907e0658b4f92b39d2cc1308e74b11cc87b7e4c1ebe454c0916c238d242db31679593540cf683f857231d37d96583e0f0588897ddb76b6bdc12b9f482c73bc6d05ec70e93260e04216c6a525d1abc2f67d57ee06fc93c6a3ba99769f5f8f83e1bee4e8addba690699a6c6c607fc18ee90cda875205d24b8a9f4d116226eacbe3bd1ccf071cfbd4d4f24c5a4c3c12198786b486f2c55d721b4f5300e2531c4db97ce905584f97c97b442b6280db72f983aebba135867e5116c85e515ebbfbf63eafd525d80dd269fb9b03b02abccb89660d66aad8e9207d84d10fc8d1be8e8e9d606d03369227ddd9baf52bb6095c02898878a7ab3968ad4a4bf9591812438c1b6fb1695f253c0233852aa52106e156c3a17bf45f0dc7a9d26f53f35897bb56453562ebbb0b1033f3ce9306e9dd1c18c1e39460ddd94fb528b04d4cdd4a808ddae2f1af38b10f87363c5a1996a7eae8e4b0e15899d144690766bd5284b527229b58c310ab50ebfaaddad687a6a3abedaf9406d8988e347e2c679d0fecf57cc0c46c6aa0e3f0ca47659c9791c94daf65485e1c249c51335ad48099b27c3ac37d33807367de6cf48ebd330b2095e809cca8715f231249f29e00c58c713f46edb4e8970129cc86bb2101f921a2f2fe7a13eb015ffd685becaaa9e551595ef9f171c10056235b55e67e8fccaa16e8d3541d6df40465b068ae7d243a619273494978709c67eb041e770954bda0c3f5ae51ef31ca257722f080d2f32159f13827c85088542430b4829ea13d2b3f9ebda02448dcefa1160154745d35291ce3299e9b6fd4950beb19fca305f960f85589a53e2c692021d9300233042411d4da4f013b3e04b522855931b8015297e7db57a955681aba08da0253ba0bf09930299846600aefd897fa09a9d743414c7b4f35db6f845e480f3044fc4122717d6955eda960d3ea2f68a2bab97f35d1989ad05658615311b67b3d9d2b2be98b3bf09b899c1308f0048c87fc1e1b502e669ddd55240b53fbeea08acbebdd18e6476baab67e752cff118b7d6fe26120dddbe91e6a16b1008552c68608aa663077ef78822c946b0605ffd1f5f8f764bbb333215278db680a7cee11cdd42ac529daf495e3c12984ef268be59591fbaff011ed2b22956a499f19dcbfbca88187c1de378fe43a9001aaf35b83e2618e345c1b5bbf47905a1ebc667671b7a105e778872cee7c7a731135f3515ae3662a7369bd25afb8ca4496b35a8b2acf54d35dda74f927eedbab186d91fd5183843f0666b528481c8a7193a972ae756e8f1ceb4f7ea61178cd789babe7f98f34eb7c2b7e4f1a335cd4a55d367b82816fccd63d6ccf35d55bc2670da84ad5378ddfa79e755f763629ce92ba6c504f6b3940f156bd6823bf204d6aedd560c2d1183fe2487838bb46ee67a082868601fe774937a159bd4e9880a40c3aac76e932856e5c4b9871d42024ef9e9d9011bc4b1681b693ff329ff6b3c3b898fb7290ea31a66dfd07882da128458ac787d0b9ae9187ba077f7708be7a055044913faebc608c3bc1edcdf14241bb453b972b42526b91929dbfba50bcf29d47757997de0b21ea9d09c12c0d60d8866a9d1a5532f23f674449c77e0ac48924b7dd877c9dc92a5292cc049566fcdb2eadad8ff96440cd74e0ac5f297f8092904deaaacf57dbd19500396b7aac25e5b83eafbf37a62415af97a62dbe2f3b126a24cabe9944ea2a57b861a646ad0f1cd4cc86afbc6232582b95e9c1940b59b43678f13750a2ad0d2bfc844f43f79b616f04cd9ee85daaecff43eef867bcb5cfdc1a4ef1babfe9ebcfde4c4237836e800edce216464396fcf2097190ff12f89aa240d74c719537f5c78342d99e8b51902fb2c067dec9b56294c5de21f9c07c69ecbf12a680d28b6e3cb65923274319a3991fd81ce1f7781e83522fa428209aa1ef6162b7ab28a16a120bac27f1baf5899c73dc2d1d68a42131b762b304d887bc92f6ae70ee2d6b4d87ba26e101c7708aa7ef5b3a81078dd918d5c247e82be9bfe03f9df1f9781c825b06753269fb2440180bf0143bdf9522c095ca758d9b583592ec46778c5197e9cb766e9e8560af9c100785a6fd51323dfe121e9eed0e280ce4e9a58d21328b4bad7260ba082d49a736496d7e043bacee411c244b2b226bc62f4b078088d44827afbe1887a11765b9cfa60fc3b4b4396d603eb5b3e135e6c0b09b1cf40cd3b6ea46197b784e21361a7508625fc6f67189b981584f4230610125b28199539df9cc0ff21ad61980d6aaeda5721a3f03eaf3737ae181282fc6151f3dc32e0728729d2d793527993c6a82d1259f99b42666bef0b8e0c1c3dd465e18b61d289fded342b9979bc6449cfbec5a9df5ed4a90d405ef2c9ff35bae3133941c5c492635b35877c5043247c83925d239ccf2bd8cf87df5f53f1e686f927e0ec2038469265d27efe7ef16b25e9e95f7b0f8a632db97a1302fbd49715aa9a2985466b76c3983d1189cd6ef1879fb3426d0ff965a29879b2fc8b1623fd1731dcae6d4357606c8c8145bb21a4a56002713d46f5d611fa40789c71c3c3d3866cee579ec28d9e84ce946bc370eb2b870b26e630fc3797af4adeda2c3ba127eb11fa02dbaac53ecb27035c296d2195370fa1fc7040c071d8e04c4c51ab82e23843130aa723c0d1956704d5341bf128a02b60953edb963fd088dcca3001cc05b779a808b6dfc8283250703989609898c8a962aa739cff9c6c1838879f4bb2a379e650efdfb27a25ab54f88ffc8e5c035c353fc166f52561f55e738288460cc2ed29e8e82069d986b55e7d3b769b90cfeb38caeebc9073e3ef9521597eafa97f23a5bc6b53b79d96ac672580f09644daef0e108a9f9fba0ce32b9decef30e7312ba8c6f673ab20c47902ed40ce975d0f9f52bb655123f3211857d237e62427755b7d757a2a3501172a6347036a27111f4492a42db51e911d7641d27aa6b431c45832d695d6de9a8c9e71573ce793161b7599e92aa73212db086aadb0c123c067f05536222660ac79ed05f7d1003ce4bdafc9e4f9fd5447630b3424859f57c1c26eedd2a5f0fc66e35d1acbc2356e3aeff8301267dce5eaf9e9f1654f026412abeca91d08208832df71ebbbfd5a85d88a37f362940d9b7aeab1b8567b973452403606f6ad31219e33e812b104587aecfa842bee58c61bc182e31c762435ca854b1be0a9f0e826927546a15ab5c3f338cf707c36a99df7a4ec510e675a8d596bb8d91c00e52a6ef096d735a135906efc780f256b59a256527e52318374469647bfc0bbcd688573f1e5e3a94b9ea22d3957a4403b3b4bbf114901af85f583630f9f4c847d87cd44ea5984f56cc959808a02f2dccf06ca7a38ccf8f52c8c53108117017bac22a39a99cadfdee99f063c858c0e232f0340e3f6d4980d5e9a83d78b5a453b4eed57bc229189b6195e5bf11180462b96064c997f057e050a92d10e0a6e069eaaced81fd90d750275174cd0699dfc92403d648e24077f189083c7e384f711aa0bb203fd7a583726f55cfbdc89fb312605be443be2cb153aa3e86059a84b57ca889fdbf340d568dd63df3874c63ecb61fa0d00094e10ae06210e60fe5dae7823d25330c28087a2b2643789e211a6dc47225f9303263f254dcbc1b836455fac2ba192602784a9a0835826dbfbfa83f5421b8a9def214e42e8a5ac16e399a585af57eba848be38e3f5f4bb1b8614067b92aef3b944e07be83b4ae1321c24bb200fd27ea9736c7894da4c83674d2f0b0eb229e764cdb477c4ad5d85f762f2f4e0b8a7700be50276acf1da090265bd4ea5237de6d06d0b031ea1bfea2fa6b1f43a41356dbe0d43416e2ae33814f99f8b711e3e0ea1201d0cd6cb1b41d2431070551e5079f8d3dea804c5f72bacbfe20bb3d03ca0f40aa0bb55a4a57de123e8aef346ff4ead32071028ca848fd8e0144bfe9b11b9bb5af2d7c9a52a96913fd7a3b4d88d4d26247121c54b432939f9b928c0a9418694cd0a989fb5ff1db843655d9a53445f64289f806127fc17a9afc2d05c9027682194a4a14c10a9c13849663ceb9db509e52e3a73e522eb416c154ea45972a2bd2382d9ecdcb10bde0bf3d43927298f31056e351836e0bb2982162a38a7d632bb0041ad211758a624e6437f2d249b0046ffba12ba5136782322302e5494bf35a8bc30ff78974444ae75ef0d817510b3bf3a83abadc3c7bceb8de52963e537e156603043304bb87899e97c68302efc31a47e5a69dbdc2166f394cf250eeb2b67e4159d8b4e672b67e3498457a86b06af3fb4f3b6fa9590ce9f43599c51d2d0eb3d04f13dd9526a7391eea559685f28458e1b1b245e457f60391a4a20c1e334549cdc66d939f6add57a4a254ef71329afd385b166193b11c714e280d2398d0bb6a82da022cc2233e14ff17171b75f808577695058a22e884634e9d66cc4165221a5c1167242de17ee7e0b8e5e107d0f69f15e6888b14555579b62bd854059708216c776d38d3129de837e6abe0cbdbd32c3f6510f2619eacf2fa46b27f9420bdb57620e76e0979d83667bd7341e8338c36415f5d515133ce68ceb263558162e6003554a244e02164f0f56be002be57720f0ce0f93179b03a16645e7ace104b6c47117af62dc5417230eba495082ebc7aa2ad27712b150460f4f6fa7d754b960a501d52ee9ccb21f5ba2dc781eb557279df72e48c40d98435a3b0aa3401a01f2a07637505335346b07c028da62e3a62a0e745a86ac67b49b927fbfbfa38bb8d8413c0e97e629e3f93289e8434cc2708f2a68fea52c0efd2e002dffe746c5acff2ee277ee88563c4f27cecc9bfbf7450a7e673577c7d445bbd3db3557b0228032e43d87cfc59823234fd973b6e4a69502240fbe3ae74dfcc20e2ba8086031f61622c7dc073f0d8d052f6bad0bd2446d41652fc3e4e6a2b7c9ecf433405bc5a4f9df7d4f45dbfc15f47ed3714a73493b8a9c0c8c0c62be797f76697a8d639cd932453df48b81ffd4e77c327040120aeed9a8962cf16d712aff677772aaa06a699f9bfd4ad856b678840b8b845db88a26c3967520bbede4bb30538300fffa533a71187fbe5d6153f0721169f08ac74a08970e26ae24db4832330bf48db6e17298cb7d75bcab0a2b0e2122e95f7bdf9dc2ea2931e524b08dd04c8cfe3f03364963c4ae99aeab253c5d3b0bba64765b8da652a88c9008e31541a593cb0226f06b8eb00fb55ed3775208d84a1bd488586cf74f1c495da9e8e2064a2faf4b9459299a7c6065958998a97cfe97d8a67c2422a5d240d337e2f7609c94a85d3388d6345882bc6cce70a3611e3dd4bfc81f2c2133463ae6a9fcf24b729ddf620a8bc4228b9a58eeee8c30bec7be133fd7c6bf3d451227cfa945b16c13b09a7390aa55b74b8175c9e9a36bfcb96140244a0107eff817c84e6144aa92d2c80e3d409dc4b9221507549d1cbdc76090eeec7151ae4ea0a25eff7c1866c305cb7ac3544d1f147dc6b0ab82f39ce3bc9d498201807f3819ba39bd18ab5a0d9965150b12164a30b3d573bd00faa82921bd44c80b70dec39c993a9a5406e9c9a325111ac9ade94623c8e315bd8a08ca4822863ec6b20e77f75be64bf9079f7de468a524e5113940ba2b4e305a11c373d7d4ce460d388f4750b893cd50e0a99a9e4724fbed8a2eb86786512937af990fc089fdac8eb4b4409ae5b19925400478df36bb7f8a7eb789bb2165e83fed2587d58945b9bf9387865d3b6fbda980e324f405db3236231be2a940c9463e7129be6bbf4ddf7046b3966cb1a73ee800049b6c1c82b9139020eb245f3623bae172559b1f6b2d27f2d3af0830ef4c1edf7cfa727f69a1b7ffea21a9b11b81cf7610e656ffec4a95460280f47611d177cd94bd860282064239663bac8789d84b54a346691018c182d9f981e00e687b8d936ae4acbc5d80310af3f43e3783393dd479050605e6c25313b0249ccf77530895a6ec91030cadce577a0cbde71a7278e2c87098ea1b30abb3cf0cf80e7ebf1dce801dd474cb258f3800a1367afd0ee8837e16c982465ec7a251ce8329c88591266fc70b3addd73a6f5a970f32b756e9ba1da80cdb163c7fe1bde44a3326bbfc01f84d62f793d00a8918b93a5ad3cb935ea3f82ffcf63ac123e20974f2bdddb61872a742f962541a74a754294155d7de30f7b0461f3d5c7be8d0e508cf0c5acf89e0c34fcf1da6ecbfc2e46bbb8ae64dbd89719811f603859606456c6f68e1296a8786aa1f6fd158fcfc97e73bb3730d04bd30cced20fe97ceb6209628d1b95d365979b4b6767422d0e9859e796cc63e5f36c549b799440701b5330f5e0ab97691404f0ff868f51050e61d1142f409f222bf0347829928e0b7cfb2c730af42a32bf703e19d9102fd37712e131ea4e008ea1f338a48559fd6a78fa9d7cddd35455343cffc71257a6ecf0d8533b632aea5697a58b8729513a949f9e1c6bfb968156a914dd8a32453f4500ac8ef17cf78684827d09fca6cd82117b1ca9ddd031ad7374ffcf5c7609385b27e6035dbd61df7c5cecaa4e7ccc3bc1e36a7f5c5e11dc6e639a316fa4850ffff90804f870fd067767f0610f83443a419f202bf548619cb07e3712688ebce7c0ab49c1d3357f636c6b50236c0be4598e04d8a6d1c6a7fb2469706d95c97668fbe53975d75774d41259113e7a28b212978dab2e6d27f33275c7394c789c9e701353b05e743adcced9a4ae565ccefeafe952eb2b43deeb8b70d30230cdf183e721f688338fdf1dbc049056a68d613594bcb5239cdc93ba31d8195f937afc98b08ee3045f93fb85b0f8b5193fe88073ea60946ae82e646e94834c0a1dd85d4f321cd5b8d6c2f1db969cb2c2f42c56aad65e2a1df0f73d2c3722cea91843e32cfba8e21a3acd68d553f26b2a33a04c1029c33906879b280e2aa4581ea3707e55d6444c97b51592d249f7ff46e897024459efe7d717a5b6939aeae7c0b56b709e111d40a213e13c7933eb1d7bfafc2e464480675e829d45dbb5c94817d4a68cfcb2d3fd810c913c997534edb5ca4caa09692067d00a5d65efa0dcfc5eeef4e11830269e5053b5c716eb8396ea540b6b375d5cd0d63e185f7cd2801b81ad91841394974892208111ebed6cfe828698c0f2c8195778a04e59940e91825489473f59734c3df114f4a2414d566c0718c4b2472a9165d6128753b774f675f2099fd90e5d8654f1341ade1164435bd1925caeda399e06a4f4b0b23a292f06ae3a8c1551d99e834137d77411afc28fd6445479859d21da974b249f7d60bd1ef6f548748b9a5fec561c2b9b887060339971739980ae97fb4df73936cf4e3f257a3e6e5d139ac7a757c9a79536a415609353f2093a6186f2d2ee536025ed665784d88dee75239bb7ae4e89373a608ada1477c3e8f1618414578de1de2647f23b43a4733337f26bf54c51ee28d57375082f7d354dad9e0a805","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
