<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c364c98aa94af40af914d1e670e83864b60c1cdb0a14fafb96291efa27811668b343d541108e9c60f61c245458ffa9e65877834c2d135bd950628fc9a63974e6bd9f8fb91754a3898f27e5d15a276607392ed988d9161ea4d2f8c360916f182dd09b7ba538468e06be6a962d46741340b3258125173d75ca28a8f62cb2d064901552410e6ad9e2449b015e38c399acb0a1f67f301c93bba3ca18fdfa7bba048a406478fe12f1e1668777fefe42f6c1f8eb91644ab927f1e79f5f12dd2ec5f21ebfda377f93f537c8d6d6ab5053612bbf0f72804208b5b2118da22dafd3821dddfc5ef758106b700e085c1509a4c2b5aec72467ac461e4f216aaf4006fa9ff205e2e1243dc2191c38fa9014983182d2d95dcdb1a4f6651db302137e802b6b68439840eb006c9f592ededa23824ec0633d088e5660767bee7bde4f5841547761a6f754536e072b947157b56e1bad21a92adea049226722919ac878da03b0fc1cbd3727521c3dbf27bbe1a0fff8c144e6fbf6b4a342091b80209d8fd5a672ef44b85d7105ec123456dacae402d24d69ffb83eee1bc8f6175729d32bda5ec58e65dfba926a0ab278a0297caa084a8e04ae21f03d0193dda40e4e8cdc38a8c974d58b53e2d7cf22b5a5384bcb57c64f70b8d99d78027c5a8c966f89e396a30fd3e763e9ac1d730fe028dbd663de95f418855cbd32ed0f0bdf041fa72b230cdc975430b892d34104d0d2f1552b95927a907ceedfcd1ffecf18b6df234fc0bebf9b67c8f098b76b249efbd14a79d964595ff439bee9ed1aa32dd8ab7acd5b439aae29dc8d3568bc62f103603487d8ed13b9d7e897d4cb00fdaba822ac1a47528cb02ee3dc06809d74a3c6659ec1b69a4c893d0e7f7b0de4d5df5c52b88b95aa74e49880139e762b0ec85deb272e6676afec44e4106944091519ff33ed7ad0c24e1822b80d66d63f502c0ba6d8910c1708785c8a6ce0f79a6c86173a81216fb1df354b137d05ec0a4a012c5b7b150467f15ea1ad5f83ad7137d5a00e8eb78b1dd300b000fb43a6616d9422a20698107637d4762a5cfe4383c5930896fc91e410921e68b2694ce732608c102b90b4f1a790ce5e73f399af6f8d93744ed1f43982b3a441a0b8fc4aec0e3ce7a6d146b708ef6d9b836469f8c66315774607dc4d6380a037437d140feefa20f3d5e33a84950d5660c34bf7550bed965e389317be947d4cf52d1025011b6d1892bb77f328d6488cab3ddf2fece7ad171428e9e1008b0f425246c27d2748d845a24eb71a3e28ced2007a3c62a4254d8cfc93bb07e43d9d1d234182bf221fa70e7508a9327a211f0088b032abb59b487eb6298c30df136933a6f69f85f7adfbcf68b05c0f2d2175d414bf64624936761ab9b39f442cdba03452751a9155671f78f7c825bfd7b5d3149338c8535c04245839b0ef07cdb1776ed5aa18f8c68900e696ef6e618b8c53d79085558c1884e36c9c9312e8b622c2481df4a6fbfa07c3a0ea2dcf2bc72654ac7000589a743b2cc8108cc4c51d9e1dae200f1a8a143d18c48b7ebc57f3fa01c9c6e1a968e77bb45e0aa26c3c31e69cd66bbafbc0f6cca7eaffb0bd6a4a69ef1dac8dc46040209b347bd6e8ce4e87c39107aa2dc5091fdc33fb9bbb5abc624d633637e1b5fddee5df5bc0b34c7ac0d7ac22a8c5381fb239bfff55a2f887139bbacd05be89a2a1d7e39f171633af73eb26cfe8d423a417aff03ff9c1ae5e1598fc6ec5e461fcdd0762e1106406b1ec2822570f5d3a504095f1f9410e059282f1cf474d99fda018b8821e923663ac0b6f4b5e6a7bce508ec08e4c3f365983a62583642bc8d7958f79062db42830681a2fb579da710a2cfd102017f21b9f8f2431d212ef93c42944c7a96d03a38e827c8800fc3c5e4320c00701d3fc598e5d0b2f0788eaad0d7f5c5475a288b4523736b3ce80c46c7e221e634118a8048b787f1d962d5fc911357155882de8b1f5ebd6f990596edd631f2ac97cf4f4076208a8c03c2e836c3d007751c70e841383393f969ca5e74d4dccb9af5bef7cead5f931b867786aa30c50f678531adaa14df0dcdaa14080d3b222a55988ccedb630d5ec38d0e645a9f5588c6c36cd670fd67b4c907835a0f3a3015438f1e598f1123cbf8a965b990703a81229dcbf80b83351213a5c6b9930dd97884a6992ef2bc9bd3b13e2e6f5231e7097fab08e0102b2ac9a3dca31c13ed440de7a5b34a6fc1720e78909d092bc6a0e0549eadd3d98684d8457f2cfeeeaae7470846a5a1ea4a8e94cebc7926c9fdeabd62c08f5a74716c242c81ef88d519c6ccd8f944743d8fbd1f131738af2d25c14d60330d9cae25599f5b69da2de2adf7a596815b17c04b768dbc7d833edddabd0921b4c21a1af48b4134747bdc91d5526ca7b428af6fd98ac2643f76fbb5ff40b53e1a759e6972d8a7062fa8bf03aeafd6a0b04a2f860a58ef7567e583517244c68a350735432b095be4ab0af8d1e32ea1abbf599ebb74a8a0dc17001455e0d9cc41a6bd156b164f1fa78ec4796e139bd9929579541f22a63dfcb9afb04fd4b7f5cec9ed9c262275645459545a69a88f95fe9c02ac5ee6e48ede1f73683776fc0207ad34447355fdce6285283894489d699f41d20bad8164133c2e1b44cdca709780656fc27492b7f0bdd90135aeb051bc699296bf494895994bee213d30f031fcb9acd9371c278120c0be21669e36a20012a1b902e2be333b4290cea0d6e4e23cee5c18accd9e99feb659b76aa8215aec49c3038e0f2225ca896617b850cdb626780ece7fcd452ae8bbb1543519f7d91b2f8b65c571ed363f1d4f7a764dbd9753f3f82167152713a129fb9091527b3380f03419033f593f1456516a283f12c41989ab251a4d5d706e85932bbbab5e9242587dd3d27933fe1e22efa2c63660d68128e42d617cf595bb17619d6e77ee803195f766c9242ac7cf683d9dbe82e452cd67b7cfcce846e02bd9644e035e6dfd9939c55d8de2135d08409be25877f07be52e873ca526d83ad58651e8109a7ce47f531ecdcee3855e1f37f3675ccfa03b96e8945f88433efb2e43cc7987ae0f70584e8c489bdf55750744d57d5522ca8a33e58fbefa3ecb4a18cc33ca476852b22eea1aeae2ad1cc2a9935010738a6edc594511a94042f35f51217232f7787b0b0a195514ecfb4abe161ee80ad077f1de31ebc04e32c9d221674d633ff382eddceadacbc7200b358782fdd82e76fd380739dfb22f660229134003a2f8350699ac765fcc09c15d6db91826e8170b82ddad5c9af22da5c192d164d17894d485804cd90822194bb7c160526068c1c09b9b255a9aeae62bcfb83c2140a0b524b8f35112feace597a7d55a9ba63da7252df3bff8d875c31ff0ea4441c148a0629486f65cf07e32d54eee709ca99530ac8e745b1ac7f3925335b0c9905dc08cd70db687872b666ac7d64644bb7904531e61d56ae91869cc6b39d4b6c2079c927811fafaed549899e84a75d5baadc46cfbe4e7ca8d33bb8154fc8b0222cedff7f709e1a4f988aef73a0a6044c2a2daca9cf10ca0c4db02509493c93033f55842fb00dab95b74b13430a28bda407ccf7b8657a0eea78c608529567bc09864aaf8fd3b11dcc7d0ba9fdbfb4fc579bdab3c34ed056b3541984a2bee8f46ad67b77a5fbf950bcae91692f90e9ff27e9cf9f0cb3f201e7c79aa7bdb74a153f532d548a0f18c4d12075e597b7fb4f3038d06e074202bc0bb7e0b0beb9124aada4fd770bdc944163c3ef96bc1a7af295fd6bf50bd8d07462e7c570cd77d491c0c60ba35821f4d5bb1f2ebb98921e669e1d4b003853ba99bff98b33f600d7410371582f4707c10c6762d3441267c77d53ef1f974135938c6a0f0387853f8b557aaaff96103a78ec9e102dd312ad1e3d060d01d0eb212537ca38a1e21e2f53f3f958dc2417745298b54031e99368d799a67fc1e3e83684493a434c083308e0de4417897e95bf9f905a0124f851353c656dc1bbb6b73cc3f77a08d292057af9d5b6f8ca53e4194d399301630a7a6a17e9b45055bafa3c1c8731ee787b4289505a62501f49ad588ca65bf38e78bb5e9e7f070283256da0dbe6149a3125683d793e2b580169a47d6607da787c2f8dc5f4b661c2d1e78745306bd03b4ac574f9c7ace34c22454fa6e1839de7aa0cd4ca7fa95f1f34310897ac383e103cfdcc8da4af5b7f234b7a064bcefb6938910428ea62cd4c647ffef4994824aa30cb6c9b1a75ba8332ff708ae132f328bc17fe79eba412a6a381cd243efa3360286be483f0faa1b21879df2d7918aaab1e0ffab6a497f3d67773dfaaf8048eebe18bb4919c822cb319d9632b17e906b818fdf981fbdbef09cd5728035bfe2bb8bc43a55a0fc54fe9547db4b21f0c018ac18f6bfd4969e72ea36172a05bc32fc8ea8d515ea2053c13ab091aa681a9bebc50fcf65d2edbbcb2d9601ae4912af2d50d3cfc1ea742647131f31d74b4cb4b707157697703d4ce9d18462f5e3d56f8385fe3abcdea2cd4daa1f2521c29b916b6ae98378c159d3c1af4d772886207e4bedac0d8fe5e5bb08d2699e9f2bc731fe7d2deaafc27c2b078b08076b5597bc8a7989e337b1dd1bd3fa651f0d5d6ba7783203ec459153649f4258c6094fea2dbb5d415bf2e25dc843b7f40e110e0e62a2d5fb05beb4e9f48bd65d9d6c17df31037ed6c84f10e818984a3ffd0414101ba3eb4ebf1607fb405e6887339f54c07e6c38fe7bf22cc82d4cd0df724ac4675fa665a439f6b2e4f799e7aff84c2ffeff950847e117d1a2c11e952abdad4b6fdb95898bdf1c1a70966df068e1ad661b5bb2b2b48b86cbda023f1657db2aed726492eb63c2a45cafd45f9a5a175a64bef8e3e894e31e237f6ca63434a915293951b6c53704c6ecfe9ee69becfe6a5f952ff43d43134230a7d5a386a0065431f71e1fbafebc3d2d4839e1b59c582c42a4e431748028201282f190ad4de46c9c1e6bc41ed1f18e696fb2af8a8768370e1412cc88cf0e31718000b5727667ba80e3a5e28c055e86ed8120adc4cc62eb1a15420463e78c61676a02800082de4a08940736c4efaefc4f7e14c1a55ac4cb39637b69fa39dcdc8fbe5e4b1c18984331aaa0f9da0eeceed9a2ea6c02a133cba99551892f0d2a44f6daa4257d2ecad20bbe46523ba345430819dd2b211c3897acff7c2ba59802229b53bac88544cb70bcf57f9069794b07f5c81789f414f07b498aa1eaa786db74ae21a1e649f678e9c12e3678678bbcafb5c14517002436c2a812d93aa88a48d8936d9384cc20124512d9f047941b860f79b3fd1b83279aba2e463c42f6a7c3ebc0d69d33d044a8dda63f80778ea820a7e235ec4328a7a32ad7732388bb07f9a9bc7bf7775621e109fb2670a7aef09c987e8602ee2eeefe4e9ba6c5b1dd53d6a8a741d2b5d65ff2fa2efdb49143b30ce3789b6123389859f857e09a53a0b8a23af899d0adcf5ebe66ce67fc0353c20c9c884c548788bd336d106416bea18fb909fd377136edf812309ec28be716fe1fdb9c175d13ac82750913f7181f383e99d9cf6bd326f7d07702a93d9f208fbcccd87de310bd6f6b2e22b672bbaa48e4c85269e7859792379d95df50498fb853e5e4e15665d1836ceb14c4be2e0d22afe9b0b643a11fd0fd94f4e7a22fa14811f7890c871222373bc5727cc09badec259ec94296e2b1ed1c437bbdae04ed9ee47a2fd21a988e0eea270fc10a56a2681e89a24ddb6ba77cb018eb0570e3c7b29573d182d735e2f64c9bd38466b5a98963d9ff406c210db93be072e73aad673fc1bfd68a98f85ff9ad0e3217408a0fa5986cd9ed56a9a4ef890a047667aad43d98d47f09896c40bbec0cc8f16bb12f8c7113a4be8be7a1670a38c1557719c9c118b6ceaf0aabb3a405bf0762a42ccaa9c9022803fe82f3c50c6e74918d8c47f789af1720ac2e5dd846a808a5770381ac8aee1283667f9f357ff7b91d8fe47c0ee68dfce4de623500b8e2b5d4901fc09e1dedc5e93acdc364f3fce2078c3f1cae1d9349f5e5ebca47e5fdb1853d3f4efe48de488d217b91add3a4bad3e4d7302c04e1a38699c5415a7eb2ceab9c5bb9f1907becc49475193345b49e0d471b05b59368bfc4e728269e04b7afdb1617efa6863d916c7ef94c975b253ada8385bb8f9f23979095a5324c08f3f2ed1e8588ca9cda58ebc65d08b603632bd6b08611450875a21aaecae5fe13faf913657bd9c32c3a9abb3dcaef7622cedf811462132eba0e9e28082e841f25412b7ea1b8ee09d930f3d7ec33b884a62e9cdea8f62268b003fb5ee23d1efe7fe1f2edbc006876a3615a9fc4db748b73c8c111e892304e6dc2a9c8d8d89292ad75cf3f03f32c4e90a2ec2e27d39c3ed52627f6bd2d2b9a79d536433d49668a754d9772207bf6c8f945fe3c96f9a3313f20b83eff38981b6088abd3be28503a94005c57b080a35aed1914b2e2d50d48b1e922fa646fca97ca0b52f568ea60c3d8031586f492b1f093bfbb722629a8cd5234947a671d4925c54e8ed1cbfbec43d37112a01edcb584cec5bf96e5b3695b8526873cff5c43bfd0ef7ccf4437a8632b34ade9ef7d758deffcdc3f9436a8ed004088272df052873f9891acf01f0984dacec31f488b394a0561f1e3043568c619dba85e4722974bac631f23c8bb7558c294fbdcfcf1ff1266e0dee29ce2d951434cccf378efbb94189996edc785742ea1bd9d7099e6993e11b8352cb1228ed98ed285f94d2b5da8708ddc3dc8fb9d5f21d3c53df6445080e3859b6ecb8d334aad1df6c2d348fde26824a121c3c3039754761850fccb80899111fe97fa064a0a91fa2a5858981cc12759d21e8d61f3c9a24f41493c6c04ec7a0882415d7ee5be842f8cfbd30679f5fc7bb80b065752b5e1a3cf13c35b2f6febbff06f7f86fd706954502263ffa10b5d4d6222083d6a45b4c08c41c479babe59bbc4e705cfb1dd6fcf588124255e3744354da7d54aef60e5c4d5cf1358836e2264522f6667afe5afa10ea6697da92bd7e44c819b75d7d1a414a4f482e9463128273e425eaeae4bdc04879fe2fb5f98335d056dc5d97519649ca0da64da8efdc2051c27bfbf5f976a05e55ef33f554af475d3c307e2852b3ef15ac27015d14054cb0aa69ad6a459d3a57fd5bd0f5e04de304ae06e65d2011ea66bfa0bd38613ca4653bc296af9c38779f6b3fc8d093d1328b7bdb157ba2ed63ae4ec3237020f9ea2928c94a14e00ffa4f236fada463a9cbbacbe5cfebf57e46082dd3f481e5d6bfc59521cd0076919a210288326ed798db2b81cd7749ba87c0ee9dbcaff8e518999a7e7a03b69f4ce1fd85d1d3325cafdf962242cbc41a50f5693bc8cc5b9cb8b517f1509ca45d0b803be7115dc9cd1f99c5c09932d491a8a1f94a625684b044fe199a64d80a9552c143353678b37175b87ace430e3da12d17be1f1b9938d79ab604567b524a3153942dca05542f5c3abfe67d5e662ee37ddd1397a62b45058a58d4189456060298c31843d6d62975b8836f19aaf4c31df520773f7a6cd23bfbce2af5e1f8651a060c44b4350b4a1348979c094a92b130d099ffdf9f91d1198ab784554ed33617f6a9909acd511f886d0d5ad2227ce0f270491b1eed2e0d0dac34f509e694eb32ddcfbe2ee39413ba34dcdcd6b85df74b0d2b8474804cae83481968e1aa8fc9d5006e3e3b8e48ce1b97ff5a7ef1a9e03c145da582ed18b613b8c4149dd9440a3f5d83bee2f301767d78bf4583bdc4dd806ba92a3438e07d13d2c575146ef1a8247e9299b187cbd3ba64049e600aac2b7239ae52d17f30b8485d87ef7e902c28c3c9f42d43dadf369c9b387d29c6a3f43a513a752082bc03eaf07f49d53b7dd718cc516b15c0a83e58178210398b6efd18cfc9138c4e94acc2f720cd30b593201486446737a5beb730f228594892f67c7085770481734663e5f5c034019444ea32e33883bf75432b3297d3b0b887900b7b8893dfae1d93fa6dec6cf41270fc8ebbeaee13ce73621cd2da5d4067fdfa56c4a83336435c73897fef8638966a8bbd6c753f37e0c0f6ab16cb0f88f975ffa5625d6e3535440935f877b593868bbd0660c2a000d7587eb67158cd3683da2b3d089e2e1d2ac920459b0462f876fbf9f6141f82602757538aed47f314e159d9e06503d01bbb0e489c789e891f84b9b5ad4a545f5868651863d70ce3eba81699ac80e8ad356bf259a14ed8a88ce16ebebe69b91c2e853fe09806f6aa9c30084970f7ac2ea81768e330ff6bf593f4aa59bdc200f99c86bba37174bce460c4359e12e836cabf2ff0f38daf8d6d37d7edd13b471a8c218a5726530570ff0684bb797bb6fe60f3a45d7fa6b90c4f184a85c40882d2426c0a1ec39abc57067f425fd411718bfb005b4abdc28bdc164f0de31cdcdcce8a1d05819060970cc05d69831e91fbd34ce51c497671b579451dbbc193c1a1030a2e13b8bab16368d1c5740616fe85925b02f0745de486d6c4f743d05333a737af033c9f048d4574d1fd6e3b87484920004ea7ca504d05f485e455461411c00ce5908176f39ec66d37efe0731109052689f4fbecf983fa82b615b8fcad50cae91e99fa7fd65dcaaf64c251aa2d0f8420c18e4ae4870643b90fc649413fa03a0f85d7672f6db52c76bb868653356007b86ee74a4f87e9569246d235fab835cb08c5e5e7e26a446beebdaefb5a09e417f234083d225265bd0c3d2312d27b075a157e2943112b5406ae84f01836da3131c3bd65cc5daffee1bb92eade8eb9321489b1034303d705a14469feca1922fc424bc2fad6208f272d96cad6084fb06ffb496f0213bab48faefc25ba89a865e75fac80085105f92cf35f5f245ce91fbddf1397a464073b21306b064b0df7bda8c4f08446d5511925004aa43ebc33518ba3826e79090b74500d3ea5d480e29690a79b871a2e3b123ce00833d91d79b92973ae36719a17e833e951f7555a3345b4f7af8a8554ad8b2a6e19ec58d8736af6af0ac856ee6461a967f08bae5f3a329a8be3683fdb766464ff79ad24fa9806cb2874977ffec1fc3e7328d338b96de541295d9d1dca1a5ec544f66ee2b91851e36a8685d865234653e20efa6d404353d34ac1a050098416dbca6ff83366761aa7206a541091501ce46efc65844a3c05fd54573880265853b2c16831bd3a13641dcf0654b99ccf8062e199673ec4684226a19e5a727ddc6915f4417aa6d236b6f13b7a05ff6841953b3779eaa21fdfe70a5d8f7417d90112efe6ba74a21b5af4a06bce94c3a5a12bd978e1cebd205d0ef43b70cd00c292235dcba1e0b674426caeb9e8a061334ccc2139c973d0c0ec95391002326ffc0323122ec5fa8c42e13ce8ae5af38b8091951b4c28b2dc6ceca5134c9bfd95fab57030b7c8b01493be34c39265bb26fc5b197a92b6afac70a27ee9e7f38e50172fac13bd1d9d755fe75a0e6ef139affd112230cdce000e8b59bfa751b7ef8a834de3ed7781a177f81d3c77e3ef0c38d099077b6c6c60c8231e011b4b492005d2561bdfff3e8f4437c49c8496779fcb5bf296e99aaf0b5933810ce1e6891607faae3a8fa6c7fc08fad38b5f23943d70ba8610add612da9ceed7568a3e84415c0b67f8dbeb71b3fc0fb89576077079b85f5cf7d4f3a3e762f6b816d1e92d6f62ac78a468541b7946c9f1fd785f6ce3db985c7ede3188c65e6f0f76b331b1cea1ea4a5657fa7d393f2d15f66bcd336930a77cb7cb56dc0e42d6a6069c6ba53679b175f63cd89fbee15646b2143c06ce216f0303df63b053826bc26fd5499956dcfad3c90bcf07f2608ab54b4ea0e1a999d8d2bb194a9634e7bd42cbd652c11494ae91536a679f00918548610078d06e2189111090946a8f3ddc5592cbfe84f4e0f7677be1adda38e070322837a91fb218a6b28b73c0190c679685dc916473ff5e0e0db200d5e504e7a278eb871fee4b78b99dfe3bc74e6d2bd0e590ca5012e17cb85748089fa3d50c655e844d64f7575cdeaf52f09f71db280b48369bdf1a1e7e48ad07dd174975f31ff99267e930b4ef924b5d94223c09b5a34a24ec35c5491ad01138e73bb899790a72fca3682c674a0ddb5734ce77504af50ed40b87e5f0ef55c0508a8fa53a61566d6ae8baabe3967228327164f960dfc763e9658469e021467188038d8411dbc0a3c7e0130ed385830b3dca12eb2b277cecf441737ef4348ccd0ee720fa7ee3e9fac5d5dcdb6deb3f187290cd1e79991c0d8ac73c07de461e78a4c898ee5ee6dc10296d9a470514d89315a06666ed97ab0585398679e5523bfee1e48b975c428162fc2f1ca6168a37918c25e57e75c2d5aa011c42d5f2a417b460772b35d25ea3d905d5b50c30527d5bf1ffb65ec3eab051abb078f973bd565ab28d4f8979ee6fd5eba6000ecd48e1dd3adc56519c273ab282b1b74642ee021a1b1a22a630f6b21513243b7334f6767dfaad5655656d0aa88a540afbb5325f40dc4f0156a8cb0875bd2acc3b45827011db50eae8cc28f2b7385cae1f04d35380a396f737ff2806b7dc366c604997ca752085127d205eec140f174402828ef31dba5d3ad316e2d24fc1455e6f242c027da8050a840053d965ccb1d528e78c87b1c76ea715940352cb017b93f8488db1d6b82042eaa1fbe461a56505c21782a4083e1e21fa994e272e889834d54b66cac5ae98478511163e5839906f3dd9e0368a45c11b94cc733223a91716fb55161279440c22b12bace170d966249fa3a9f1687aff27513881928297bbff98bccbf680b90400a5c01e956d54c5e6718346f696d684349f73e68743d0daa14c68444f5f64dc15cf4396f91f1e708e2e3b3c6db854883c122c3031ff5262ff65277be7672ccd52ed34f24b557dd877b2029980968e2ab185cbdba01735211f0624ff974be2a7b213d6fc8619351f4b502ddc1a153796392e4deb5ccb6c42d80c9bedd5f530597546073ca2700ce5b88837948128f0fbabb7b6d024a5db0edf26941494c6290fae040273832d58fd14be07841f2ac30e921474adf48ef7dc3a3c63c05030a8d2ea08ffadf2e88d46f20abdfbae36ca2e2e3286774204d5fea2738daa4b63066f4ac56b43c3c5bfd90c789d44388e6e96164175cff1669db32ef82612e6acffde0d7f67a873c2879bb5201331c61c601c02b3187d83a5c70b191bd711293905380d4242088b05c0b788949e3ed03b3cd2e09e683b0b46ee56e88a360fc40ec4a4bf94908e746cb477d6e3da577f17d51eb19b0bddc5f0fab6819403ed24497d41b1b49b3e8bab24340229c1bc055eefc7238a9ef8d64fef2c51a94c0298f0bf85cc3d90d35ed29ef8015409596f8f3e60bf4da04bef76bbbd5bc5cfe9a0d223317fea70be3af286e211172cb1ed00c81d368fd56aa577dc9f246f38a463134d7cf3dd3ca9427211953ae35eead32d77135545153f0918b91010a5756682bda86afd696a9d2eeb0a6cb642c0ba2e25b3cae4f68273615ae7c8d114f096576101168a03d080c15ad2afaf8c8523a2a4f69a7571d83b21cb0a91884a3e6a29bdffaf62ad438bbbb00d4596e53cbe5a20810b0baeed1c0d67b098a79528970225fd054bb6c340d3f0834a853f50fa09025ac6c2708cba2eb6d6b374c8deb7d7216c2540d0525ed1abbb28a21a48b47fc5617fa68fdc7d833b714d45aed44112e90f8e5f926386474573de0f54271b103652ed65005be3c8822c14e1a7b400a1227dda70629e4f930ba4eedef5ff7223236630cec30c8f42a41141dc4d9e047ea151aa38625f43812f796b250d1f7e85f0fb8e30b7c7fde6bf89054934e2ccd63365fdab3f6be6ce9ce8f9aaa9596acf7a5980061f0f84d198ace22a8a8d9857b0594f617ba02727e1140717731760d71c27af3fc2f3d4d98e8e8a4da1bd5d4b26a1046c2523656a0740203d067e9c2698b2a66e6bffd367ca6d6c8ac2b070b587a29bd566d9be73a8699d5c27cf3dcbd4340e140a48652c77afd9a7e0646412901046891013af60bc5ecde634c1acaf1d1b9f8c5b6ee76c381ed40660b895661456f363c62d743a4551e464df36501b977cc27def1b526bb7148b68461e73f8074ee293cad2a9f13370999f45a057dc54085cebfb822409cbc848f47675c4565084bbc31ce68410ec0e341cfe4241913fc0761f129f498dd5143d98d5a3dce788b7e8380ad7563be6a2b86ae39178fed5d0eb8f7634e604996d7fd09d3c38f2c1b755ebe1f3a6b128ff6613d571a4746d57af4bf898697080445c75899ee8304c245de846db1fd35cc0eb15019ce3e64877f02be9eeab297b3dfea6421fdb8b56dff08fff2b4e4a7a4a80ed6e3b8397cb0347eefce2d05c3055748b8b12baccb89dd23f10ec59fadaa790c02be25679fc59e86584c68e9f8fc0526b00a9298ec6c94b03f2380ee9471d9e32600294299bfcdfe5d75dffcf7dc922fd512e540d4a22a77d5af56e817cb68e4e9975786c90a3d61c75cdb194039fe563d816815c67c327ecf62ab366d88d7ae31be6de0c530ef963efc0781ff5ec6121e4ab33c046a9c02db67061d53fa5293951f2188120a8fe083ffbfa86d3ced9e04765bceb441472d2a0f2e9227ebc413ffec887dc87cb5b1c92ca10b7a6d4e3dc18aa1ca9230be7b64a45facb03a57e368dd1577c548e07ffbc30930bda8636a825e0eee32558fded79ccaa371f96fcaeede05c59d387c15ed366abe57834410f6587d940ae4c9f2ff908ce37914484f2f5b8c5dfc6f9f6b9ab881524290b4317a614fdee8f295fa7318dffb44b59a8127271819dab4553d8d331f1bdde111bd95d76d2e9c6f85e8ba2ad2b107acdd1781510afbf7b6cd52dea5f6c0b1ea24273537df8c0da93e9b9a23cfe53934f43f40a45a9a08bc911b6e897a0adcb07a8c9498e960b35551cd70c1c2ba2bcd4e0db989ab6b3e4ed8100230c373b7f06b9639ec1002c2d435e170edec1608a788af673c6c800a4394fe34f3f9a1fafbf154736241a0c24e44d246005013fa26a91baf32ebe45fc6258b70a6cc55fdcf45f24d9fd68d0f614bc7105d9f1958d6ea4154518875a206f78a4c7ce9c8725b39f4f22f5fba866c5bf8a6dc490cf9ce7ddea3bcd6124e25eaa8a4ae0f84878c31936974664bc7ed5c6e81c7b2af586b19c7fa8ee6c2c31a6e283c3702e902c685920d57a83f200dcb7a55ccff02d9cd7fcc5026b1c476b398501b7947929ddbfc904285f0b001ff80b0c19221fb453e480a56917a2e94443e9404453e44bfe37e02e88814d733dc91930cbfb4abb9e3a80537bd9847a621023beca1c69a5509135713103020d69df214e5975223a4ec353e78765ba093084d52041f1212d0aa12a548cc032704d856455822bfa5b6c4a3ce885b09de03270c9f9e85d833f25bec00a0f515d8911930316e027e62d721e6d35c259760d364436abbd1882d6f9d106205b87ac9e9fde37596aadd196ef955a6eee22d9370a6f03f7b751731edb9032978b153b2a82850219553d837b30211247d5c162590243229fc17b9b3fc54b1d31a2291931b35b847eef328e8ba2acd9d850bd35783971b96e1311c47e31f1dd41db6abd4a947c1b700daa87027ac44d75a803c0c9d63047c5e269715b3ecb0f161035dab767599e16ea96572905d71a99b2481aed7d971a31f0c97c04e21f3fda7c7f283930f14008b1e457342585c04cb1685d9b93b8b14cd8fad953135d57422b4daaa6f7a1e2ed5c2ed6a924690f8f68f5adc29392767864445e7643ba320a4bb12d461e833a1545b6705766c84ee731afc309b184db728edfbfc2bd03c2d69ce67355207799e22f3854af17944db377847ab2c8bbbe5eee032323367639c80f2b0feae3964c2a159d605be90314aebe9bbaa27a69fa787a3fb62bad719668ccb06a1a661eb0968fe991ff4b6461b95fe82c00436ffeed9ecc48f1d8b00442fa0ef4ba87f600a5eb316b9bcb63e20df39c2c397eb2ef0a712f8279c7ee71e297f5ef93fc22382e2e1bfd67efa89927dbd22bed22db38d32c59882977a8a625e58826d8726f89ec4ecb053c631073cb6605fcd5ab5d7082ca9186447fb7638e2148fc3aa93db4a4019a2c305eecac77ff99fa0e8fb0860fcc157e4d8ac3b5ea552bc5f16e3d96409c5f2f5d294af27db0004fe7b49f0341a655856c88b7ac7f38791ba19ed4e51e2bc053a76f2a15e1ab37b11106f0bedfee365d1cf725ca3e53f8738dee8efc7e68e9fcf4f7bb0dd12d465ff405671641755b41446c13e858f7584ad9656efa0d2726be59e810d24d279e7f3837758f08d0ed2a61620d48421a1ef2f326c53e9c96c1b604ddefe9662bbb0bc844ab0702e606b9f48af8173cd85a7a8248b282245ce7c842ae2dea1b5b058002a64ba151adb5780c563d9de4331e43ca292efffccdbd7afb529ab1824eeed357b0739fa6b70a708d880fa6d1f24edb96ffbc4eef0c6aac495fb8067f236a82d02eb6c66e35ec215cb62094b37277a8e819e2b4e3094a212867ae968a593ee3e0253d2569d62d377f94a128a0c3e7ab647c04c3660f75455fa99b0f4787ae2a5e0bacebb76a54589a326b0f7420d10c5209ff6d2bcb818947b968e08f6ce54e603254baee0125a6741d4d622774d572e224fd2fe993173437a0062bb06c8db62bc0c7908007886d3a6ece29a3b9ccff74f2b328a8e38c6fb909bfd8574ee1663757a7dc9e7ae3d4a6fff7a0d964a4aa15f87b9a9397a3ec1b7498c1932f5da55a93975f055e1c4f2a7b65ffe03dbf4d8a175afbb0b50abb08a8a7597db0c95c38f112997ff59dc9f9fc2dcfb24f0b70d2ea12e028b84a32e43593f95b9352bdee144bc63a1feaa561ce86c9d7c2590737a6df23b8e83bfc009359393f368b00b06529121d5911143f4595a9896099c9f0daeee9af32d0ea61f273964cb8d43354199799ff97be59da84b33db091178c0f82542103397b4495848946306d51b100b005f6c8db1dba4baab080d322619aa8e40783224822f7b2fb2230c1550c4ff68ba0b08f8f96017cfeeb406b0228c88b99fc1e41c6949695db84c80bd6be658f877b00deb8adfee70e7e094ea0f9b45ce332f6d47efbc7da7b989b4ed4f20d83613d18131272ca2609b509b5ab4089aeda49300e8ca43d8c40018d86102c5a2a000b777653e0e03392c991d3210c1184ef629f1e10ccafcda388142e11e862ff49e93915c4071132e99a951a2d3b5da6f59513d7be81ca705cc6018a9ded86baee8c0c7908ae165436ff424402a8fe0879bced37e85de9e9303d6f437fd90b52bcc968e89b11aba0f099446cdf3d29b955bfebbe27c40e6ded977f9b8e585b7eccb45dc5286eb4c44a8b21b60887cf46c7cc85bfef4d20b449553d842e57d62eb5b9354c8da05dc7f085496a2561f111f2c63898e89c4ba1d880ec7adadff4c90ff958ddb64f087aa970beb69a49149b2b29e59b8a7bb6a3e3efd4283a54fd236eaf9f42e9e043b767545c7cd12c50f665e19460ad71fec33ae6b6b217fddf0604679ec5adf145b6c5fb909a454691d850fb5f35716e8f5cc178128fe35ec47453b478da88cac9e0a419bc823574c4143ab360408f77ca9c9eadacd08efe9b6ff82793ff4b780ec5c0701e19175b75b30775d1f792cbfd1d55994a4c5b85cc3046f395c929fb933bb65b3672b9c71c4887b1bfcc1dc9ecb8a2d595b1978dd3a0eb183411990a25473ae9be0f98fe57163546645f5564798bc87c0b39c1e8ce38cf441c30d64be797c1e9c1ece7b5a97c7ce2281c187d77aad0a854f2e5d80ff8f1058ca4672f215d58b16f1593a1551d56e74cb98d8ba93fb514147fc7ba3e10f5ff4ed292f57ce8fb409980eb2a95ac5404ad7d789a10a78563b2ce1fb8fefe5af060d6114f5f6bece379d011aa0230c6aabbfbae275be1dfd29f2daafc75c280bae85e7dc73ca07a54f9a34ec9565126dc02f322d1687a57feba6ae9a5a5c6645f07e61b77acbdaa901b5a5c6b779d8fe342e12a6e4187bc008ce9e5079597975ffb940319e5a4f19a7c97f2b55608d610e68f34e1367a44182b60d480c1380eb37d0ad427dddf343d1d60b6ab91f1b9adf52abacaa371e157f9d672420cfdc81144f3fe9bbe030aeb692bac974d3d72a572549009ef05ff0541a565afb2c9abe241d54c4d1ab0a983ca247b71183a518898e2edf0a0e679baff0394d8e037953ba49facaf8aebb7189f32821280d46a89f6abba4002979ec9a410cf187857410985f38c6240e68d87bbd8aee8a61b43493d91daba2f665123f7fb2c1cf796f3fb88d72abb8ccf3101282a961347e9680cdc3181e212ff360761f1ab9e6638b4919002143725ae643164e0024138d67c0d1cd3fa445b93feb8d4e5c7cba8f1245889c4463ad61705349fb5d3571a88ec96918126119537867ffaa0c70597d5e0eb7f450602c0332d3b6057f16d51410e4ba8f2bafb78340973c7c8bab735d9eebfd92fe7b1b90b1a43d30c60c38c24aa6bf36090754e79a2b97fe6bc8d6a6cff90f9c7cd44557ad00b394ff68f5957be81968e9637e7b34be25ded2461403eb607107decd1ec1abebfc03b70c5f6f8df390bcb83f67e2a92316c00a08c15056d587dcf6d73d347f80e7ee341db5215e2820e64dd30b17693f9145d7113df9b72b039e89b780da08ef7a77afc6c0be1e2fbd189162f5fdbac4043c78fc1ec0e943b8d1473d74f9a8e344140bd63558ffcc8b5f8db9f20db2bbf65595c6be38b9e9ed9d888ebe1aabc00bed0b2d45760d186743c2967588ae4423b7349ab7df6d010ee30a9998b8a87cc49bc126545c1fed1d79c1991fcfef8a872499cf3dcba3f4d23a14f52c4261b50f268d29881ec775cf145bc85fbcd48bb29196720f456bba4e7ee639a083f5e415b9f070264d9ba579d01a0fc272391c0cfbc7075d0eeafc4a28bbf40e3710fce4d7e05d842f4ceec26f5a32c2d96a35f58fc01820917297692ab892819cffb847a93f02795b75a5041285f52a8ef4be91ceedabe0978116d90a77ff9132792b4d76e8319a09371139895a3376c6b95d29c4f92207af7055bce2bfe325bafcdc3719a0bfd900be315e751d0578f146b98771e838e548c5dd3489eb5923396fbc32d1a01443f67a34af4ad06af403646268889d406051f0a9ab391b4680ef83b856193588e4b343253adec028819a48df2e11801f430b4033e9e9315ec409ab3a813069c7c8fe92b27da8081c2161e231c3f6e644125a2ff08ac758a610c96c9bbf91f78ab31b7ca4401d83c551cbf28eecf3914fbcb899fb225aa7d14946364568f018fef539402f3159f29d2f4ef4c2da048c9941a8399e125634c68deb2149fe2e8ea92f94fb95ce8838a8c3ee8cd2c004b4e72e4caf9f1c3a602a49508201eca84ce5dadde1a1283b1a73b500fc73581b6f6a7424e7aaa987084976094994cdbd48eea1565f36d35341a213b0ae25ab727a378e643fc786fda4557f85145349318f370380e90f0394c1003e1577440fd0ff9e4707fc949126f10637350111d9404cd70bc0567ef7fff59b409e318ede6241a83ffeceb324b71c2c0cf53f9a1e17bdf0a04c93b0e757750f7b78969f14b1068515fa99952fa6c2a187845caf15510fda622dadb0aa669373742253628fe1444bb820ece7666e0bacbb3bc5a9a423286559efeeca2f93d78694c5639290ac40741905d1ad7aa7e6ca15d9299c69ea6cb756d97c1e85468227d3a41218c296ea4984444dd4b916cf213428f83910d82bbd06367af918428df679f074436a7fbdb833aca4161e27dfd165739ec07aed3b60ca4da80b875e5b8a333cde57faa64ef36f0a2d81f1ebf0c87d1a2525023319d8206fcfa9f50e9c330b9fb17ec6c6320f4e5b7ff3cf14f63215fec361703499ee783ab8f0372c8064022418d2095928c0b032d9323eebafbf0eaba2e611f0bf9a332a9f9c76d0936037105d3af5268faf55722db1c33ff67f592f3b54fa13620f5042dfb4804eda0f0915abf47536f2b2ffc90d020185d885539532568fe0ca0889f35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
