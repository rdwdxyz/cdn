<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4b813eb66a2f8b0c563fc86f5165ca5664e6bc9098afe6d1d0b2856cef0967c1048a68c31f254cb3986b64384ba2562578736bc3aa30a2dfe30180f06eb1bbab121b9b7682f24d36fca2273e5fe776fa21412f24c110041ad456725aa33dd9ccda7335203f8f3956b1e10576a462080fe01f7e6465ef617642850720663b46f9cfcd81b2b6add0c779869074d184b1af49c98ccfe39d8812b5eca4ad93e886a1323a40eef547463c6d20984407eaec80b69cdf5dc4a4257a67fe4f47cb351932ea62e601b6b25412ccfbc819b8e79ca68ad6842221a74ae8ed1ef991c8f9a6b24d1afc1e37c4507339e42ca7149d9d62c6b0d00bdf78d3c744af6aa82b9e2a67026e6ce6d9b7ab2eeafff29b0940c383f8b3404595b8c9cd7eff258655f16c8c1a66ff2ce3e7a513d69bdc626c172adf0d3c852d817d22e4778255982c5c79015957f67850fb2147c2e4737674df3da981840ba59bbdd54af41da62614fd212af6eadd0788e90dbfc7ab5461e9fcde1a39829ada7e248bea9559822ff8221b1790697e54ea296065cece75d67e068f6431014b446bb124258960048d67ae7a56460144642d7f2deac5bec71a708cb6830d698dd8596c108f8b04d1f3551a3f73a1219e4c72e54beb9931643c69871ee151e60b4e775337647d18c46f8a6afd54f7dd381e609edf84bd429a9bb7c3e78bbbce5df0fb0f06719917bcb9c411dc5a4419cdb6bb2defff74033a992e23181b3735adc7cc3af27ac1938f6255dd7e7b635b6177cb014cfe7e5b41e33257a13350ef5c3009a624155baf974dee8c88f66746a7f1a7a43a30d04783e62c8a9bfced84f3ebdf34aa3240cd798bb6cdedbd62f65b6cf275a6e52b6a15a7da6a8b490fb5f0067abbb5c9ed9a78f69c29f8bca558ffd1612c4597a6cd3fc514ccd6ab1cd6e4c7485d528d82ff4f912b771f028a0b35e6a7a3c27d7235cc0d0dd6e80d4d3817ef4c9c7abe4a1bc6fe0cea82447f8f8490911e575959ca68d0c4e1d32e9268eba69945858f3a87a6c3b28cbb7776d003f7bb6b6d265d54e791a91bc8beea914c59dc9c756a96efd3ea617cc5ba9ab340b0478421b668024e0600a7c4ceb1188fa9a0062abbf17ddb5ff0837add8f0e1d2cdec43e3d0cd57f0dbf05e721739eadf9829fc141eb412e306231649f5a2eb3836159255867e265166750f869d27389980346b1d5893bc6545da205c04401df7086604050329b3cf8df851165b1a8751aedebdc7ae2c839bcc2dcbcbc5fc92a66e2a65f58d625e680287675f3b130bf5bc7a1b695f41ee6825e091644ba20c91108d86aa7c507a14fc534c03641a1ca9d198f3c8d3c536099c20463f23de1b042ca37034fc553d17db50adf89ff2215b04cfeb659a55ce68b2cb036b2764d6c24b2a9084aa3b70849ad50f2f055d38665a26d11f48a75ffbdc1a69495d0a0c62eb0543e74202ccbd81c2c51eb70cc5483c505221b55afeb4e7c1700788f44c6ab1a875e01881e5defb0b62387801426356d3b1cb8e5b2f5aeb862f63aa09db4a6262e6a3f6bae034483db32874290d848d37fce33bd7cdc83193fb71eb862fc479d8703dc6c73ffcfc81f766e24463321341054a5b904af4636df488d8491930a1d02e4033491d450f734dbcc4fb75b8fb4ec7606dac935630ad6e4f92efccfd525438cbdeb2461e3910c291dd2888afcf8a029a0d20241cebb9ffdcbd78cbe9f1ff6c54fd28a290bea17ac1e9c1a6918200f8f94ef1b76050e0c0465dff8085903d4cea56c25fefb634a02787b0e6681191beb8fb782975bfc0c8ead2eb833cb9787b9dd0cf07adc4d5520f97b5b488b2b3e2727e8d987e2f754a338a380d6b2ed36346439772f720443c306dc914aafabd25387ad1ff223cc502cb4a434ca1e2c88ff0bf9033d3d4117c3c6aeea79b88b22b88753802124f29a284b3e86825bd299844cae5959e230318a4678022739edbb81fbd4e85c588765d307d98e2879b8dafcf5bb31e2b63136ac55d5fe5aabe96041a35e6d8ee7df12036c9ea4430c17390b36e50dc9c64e430339f0e24cdede767af5ca385caf8d83ffafbbb0e3cfda5a60db987c9c8c8e310490b9b4d659b8f7e99b0c68e0fd7e0899417cf73469a1299333b258d6c439bceb83b8186c9a79c002a1bde12fcebc4bd069ba2f7b3abe781069c503ab8f43d3ff4153266615b912587e46d4d93339dcbcc227adee786932a24d438f69be3fc8922ac836358b2ba3a3427d35851cd727a12c46534e7976c75d10b6eb2d9cc6d7cc27743f9f693a7370223b33ea4ca268a26701d05ceaec44779074a7fe14bdada82c7f28db2e53f7304528ad37ad646941f5d6066a121415fcb9ab66f9d2bb8ead50887788b2d3261197c43973c25faced57f28cfebd5468dd95c11455c8eb7c565b06b89e16a14dd74c31d4f54a4c55fd38083566f709cdd17f53b630be2b5cd8dd925956847544ca2cc6709dd686328846942caa38594c07ef30e69b4edda9bed54b67efae259ce4a73828d19d2b2924d71017fb83fa6cefd0ae9116d6e9982201e374a4bfa52f9adf0b62dcdf68525d21dd862f93fbe267b36b62b37f9d4ccecc8c59b396fe0b1111ac0457e37e5790383ca516be87c490227f92446bff278193ba2e943df8d36c4eb20faecba9ab6b067c8d906bbc958b96f88c2f49fcac12a42afdfac6c25c4c84826e01079162d22908e362581b69b490dddb7e2fb86888a93fab146192e148ee9fea353984b0c67fadec791bf6157352f4b7cd2f7852dbbbcb71978f1c4abd085b4e800f76e2a72959f9e660f3d0caab6cb984bfa99842038905eb0638cc83092008cd72120391077aadb8c927122b569f5cbbe0f96805ee8e7a85088da6bb36fce7de38972cfe7425b16a53c0e2bf88807568db25f731c6b18749b578c1a5a9230cb5ed79973e700f7b558eac5f10bc214dfc57af48791c40e046581ae5fab02c3b4947fd037dc9d04afc4c48357db1f75ba452b6bc519fa79a9c09bcb58a4f7bb12dfb4bf5a6590098812c9245999f406524c1be86773e12381dc880ec2ecf5db0669040682397871472efa3bc523400eee1aa45ca6872b9d195fa5ac008760120ae5bd1430b249e62e26a605817d8b9bebe49169977c328abc8b851f9f46a561a4e64d466c9abc033c02e579952c37ed70f83a5282c0837e5fa3122c7b7953df4e8d04c82d685989ef513d74976bcb732230914234a3a4f3a6405cba793d38531a61187720e7b7ecfc732dcf37cc919bc42b4d8ccd77fe75425b72693ed516ba19910a5f2d37966e65760e6c0911ea2044f9d0c175839390b1e42ea0144d14c14588549c682b0c39b9533d49842eaf5126938ad0afaadaff98cae7b3a5daa23532a031010e2f05fd4694eb2b262810f622adb0562d1f8680a505a274cd179a583f87914bc806e7f26e67e90ecbbbe25f7fafe8d7b8f1186587945837fa47436ff983d2a215ed584922ae721c8c96113da2a296fc34baab07dd652cdee51bc31c9c0b8a09d4575020af8c165d4b94351fdec910227b07604a758c887fd5d807401a96e65bf972d7fd2a7a0ec6f0bd68b1ec5fce0df3bb7adf32a89ab41441a8bd61f8f37b9166fae93131be8f0aed670c949c25e59d955b25cc81f1967cb9a72c81784632f0c5c52a5721704a00655f258a42434002cde43f2bd6f27321d4c5a7c3f6b89a1c20178a927a82e819a9d7647693f54aa253555c25c3fb5fd91da3260cb5c0229e3c45a9c810dae5f13026ef07f05fd49c49a1d16d71d8983b372df6ad62e5c2a3959c32a312bb24e24f66678fc3095970b2e563f43d986c849665dbe7bb833ac4fb374d76fd6b7726ba4940bf6027bf1a19c469a518ca33e4fd585c03490041cfdd63b272615bfd06f37d96c5f9657b26fcdac15bef2a41044338548ebb965005b26a0aa4999ce5aa1c381a7cd73a9806b49686ff6ca168505d0c88e8b56cf7e42845254d84488427ad8ca54ec52b3c7b85b9de4e163d81fb6acb66721f9429f03034f64462206cdf6c2f57bb88fea3a722f350d345e645d24a2be5d7a57fb818e1a129b0bd14ddfdb028d120e19acbd537376b9a95b6d2a70cfad61e82352c51eb6c4709002e9a71d72fa31fd4dd84c268a5f459b6c827b67d6a2f735cf7fbd53df4e5a9900ecf0b7b905ad395e14c9ec419a24e5e29a1bc45c3a1b5856e63c0b184e28f4fac4654df5f5f21bd87faf1c6e851f24bae9a723cd7134735426b0f9ef7332925b402955d1618f2bcc8eaad1a1261303c79294875ef214469fd93c29163566dff6b7173a675435ca34d64fabdee0a9a50af10b374ae1ca733bea6c926da04c8adc8a39642a2c4e35ae1b553f070186a3cce3d4d19b791594e76976cbf0bddba895fdd52b2ec1b623aa113eb60504ee0067e26a54ddc93dd6aecc311ebbd2b4541d83b719416c8675356f747bb7d2192cc1b6b27668c22ef93d86bffd6ff386c08a41d7899cf76c4ce029c18eea815ee68c756801393d0bf60cfe265b1d3c8159789d85be4e11dc6589dbd693b444e8a2e5dd59b91bf14c351178b61afde91bb167227472dae8cd84652142df6fbd575945e884c19e0c3f1b0a9d5560554c13a6f4b270247cfda183e8050c91e2f524ea5f9e270e83fcedb4cb5d15d2e3eb11e45b25322aac2266719f7cfd737d055aed2a67e51f2f87519fd9647f76ea0b94fcbefbd19ad139cdab0db53065b7ed87ebe9841cf19759456c90952d429898a881690edb3259727f0d128ad8c0a360961175ee0cdeed2f5db204ef1fe6fea73d2b2ba34cf05500dac1ec9bed8068d785ad6ad5f166f5fcec2713f8fd80c248d620f3373c0b254b1ab0d20b17990590913fc117338b08d52522453a48ed847976316dae3f634481b8a2a4b071943c19a4f8a70f609d74f452458ccc11238894820c4cbc96b37f5a83604936317408cfa8b34585cf98024bb97d936c28607d89eed55e2585530d5d62538087a34341d846b8fdc0fd0b0683657e985d770946946f23af555c4c94ea0f7c8c3151c029be6ca1af282a8ac696e42e111868fc012c5d2eef3ab2f1f9a0c69e2e46a66482341d97d53588292a2886f0f874106e7bac782fdb8b227309e2efe58690f9621904a411039c8136a74e6f270746c3aeb0f34d53e886d592f155095ec7f1c8fa479a5145525e298e26ba39b82a7e305635c0516179e2fd12a5bc57e7822d5228cfba6e4ff18b74ba396197dfb3c0557570bb78904fa43f6c2a8c575741a0b0297c56446a70afbc533e44033ed10ccdbe34e39f382431e0a6e61bf2ead41aebd06e5cf9697591d88b4431f75c2014122e0ffbd2f32144e2b90f8f63ce5ecacf896033147c27e88349e3dd662a37e3a237c01ffb00c3b8c0aef585947f9e492f168dbb271608d021ec28e3f2935434cf15fc8aa90a281ee7c660a23727658ef51d8e8446b30547d7eee15335188ad708184cacb5b9a9d419a01880b172c6f41b41215ed3fb6f3f1605a6fca2ac01211a614e275a1e24a46086cb901dfbe07ac60f83e4e57c52be12eda5cc508ba3956f63c5a252e91fcf08aa56a7e88c9110eb904a8f76f503ea6cedf5f34b9b02ab91383d395da83c46cdfc98b7896fba4f06e71c49aac01286933ed3e3a098f092596221a146cba0e19a9fb75f791d686647a9463c818a962578a70db7ba1ab78365b2990120f5604c034ad7c5cf70c148c37dc9a68e62a0e68ae3b6a146f0502a7b99340afd435e242d5c99ea5a7ef4b3a7db756ebcd6040c26ae0478349f49068b5e438129a05a1ced97ecae70002645b47a411ae5acec533375f8359e5dc1c2cb26f9d166d5fb3539769befc99e5d5d7fd49a87ef13e899da56d8f84ad3980693b13b3076331f729fcc6e988338b381f9abbc4ea648cf9bbfd9f01bc8b7062b130856228062d92a2437cbd226b82b651cfa064c1d88eae8a7f1ea81c7f60ae1717b908672a42ce59b91ec2a91a419526a11a54b2ead3b891ac3fc174c4ddc5405c7c40c4f25a0af36f435e98ef468e3edc319887296c1d81091c73c4d61e447313a42ef23865a1762749761e0ebb28115ec6c8d215c1a7b696ff39097d8b2ec777b9c4db4c850c6b446d0ed21401640057cf2ea0f461c383c9bbbb9a2f6255e45d2ac3841e2c1d6194178462c766f94d35ccf41ce2f2aaa5165e47fd8929a1b5e66ad9daac8b943f84962def477ee90966a0df8d550a053bedc86d01f30e808ee6a4d41f4cea668c0bf017f09f8f55afd58e30df8a10eff23b82cfa93946a149991c00e16fe1c4883d8bc9b2ef1cd4cedbabb3ab3598aaa700f87cec0bcfb204d1a739cc20bb7de37b4d179e3f51c0bbecea9dd9e76940dafa3ccacad23f145d63600f0420f1f2ab3e86c77602c047dd6cb5c090900f3ad46583ae1f16165f3c8afb437d72f20faed65557b792a2eeef8c52e5e74145d446648d1344b0ef76e0f89ad4f16a175475c2218d79bf027caa0743c4150f214f59fce8f916235e45db79da7207c25ec3fe7d0647e3eb233ff65d9c511f24be57e89a3647b8b7c1936bfdceb945490d86add4dfb8354e992ffb545cbca0190cd2098c69b88ed4c3662ef621a4b63c96bc7d0ac787ddb6361bf7d6ed410e4880c34186fed54adbd03226617d4265f68f3f70a30d5e55d0e9e1071e7193b78ed63374d399c84b3290760b63181c6be780a9f9019aae0c1e992f726e4aae4691060ac0e4120e9dea25c523534142e651de7e4f1dd8e093d0b2d0d52eed824d3089749b3a267bfeec791aabb1089254d84663b82e4e9efff5ff78a75f062eae316cd74f0db68e013bf650b10699bb782e8a1e3ce3e578b70e585ca668cb301c4103b09f7cc446b5c22dd07d405a45d79c9a7267b2d4074071f7f4283a226e2971cd445d81850fd0b1af1344e9bd12f47f3b2a395d9160b3e52c8f517a143ea266c5c075801fe0beee0d54a6ef647d5ef29090b86592a4ee03fe913b270cfca2d461cdad1c956d27d594b4cbd8b043b01176398586b68c5e734d8e563625f7541dd18e40d49ce5621dc398fb53006c880f85868390f121c9250682c3bb5b2d67173374206eef58923d2843753904ffa55cdc09bae2e4b5ecbeface79e5f0c004fbd198bea3a5d04153cb13d529bfdb09d669f88cb05eee7765408e00f4c4079660e8392ee91af882b2ebddc3ca17cd3aef67ea448521707c824c28712b17d888cda663f9982f4a67cc4b639e64fd7d971065e5c3caaedd563064341f49cda6abf0f5220638ed8ba7d1512dfa93a0230b459f87e238ff92904e1ea4e70df3fef813350d5bd3042e4bd36f6628a64372ca575e5c70d0c76135a4cd46576b93c321dcb6bfffd998fa2d909a5e96b552af1a261e75a03720d4aeb217967495504cc132f82081c57c5834f2937eb4ba854c857e00bc68f29e74f12637e29ef85ef5b9bfda74d9dc9b9ebf5fd82e0873db093373cbb61f80b7f5a404bdf8c760c9ee64328c7e10739457d812ae1399c7f1660e8c3cffb379432812b76d60617c59bc4de42eded43ace84f0f975225f7d79a35b8ec0279b49374bbf96cb3edbfe53a7c3054b761a1e0f42f5f215e63ba90d5733c68d2a3a0bf5e5454a7023c0552552935b4158161081869ac32e84b864d1f4ab4bde531009607d4b00ff308d910d9c963999664cef797f5428e15568617920836e0f9d19779eb536d32da3cc7a764faefca4be2dcf6d83185f488c63468ae93f87c67f7ee401d9a682f8fa052fda0f6ede7cea1b6694026b5a264c8444c3ad1068c2b0a391d053698438a8d8853a1470947252f9ea73d1f9ce1b44730d12b32580d3dcc9501b6f1fbf26f1775aaacd3d16a1ab12dddd10b0fb4f923f589f530e508f6a8db11bf0fe6017cf6750650f53a5500cc16ba050a517e7a8438486a64df8a512ca8d3e8c495539525e393f1b8462f6e28e6a8d39dcbf9d4f57d45420e343c4faed195f57bcea0fc5bdcda4f06d7519a05d8c5bc96d66283d1ae38af6cd598901f28a31cc05efebc627228a0e0e3a43e1d7e2f365f94f6675b3822269c14f7209fffb67957d4e9c534e2675c6f6425f51c13f1986d6bde180d10e51072f6e70d8cd1c51332d4385b841962a9fe220ba1d4d3d90f2e20a11e91b99e21f057beba016cbbf9bf89887e8ac1638200acca9ed29cccb277c4348f8cf6f8090f0322de9a34bcca6f750b8c1b421218d69aff54beb3b74ce2fc51effa5c546d325d370a00485ad2f4f9e3aed5e38b5df4dab609f7e2e41d5fbdee4bb3757beae91777c60704a2a7280bc857629082bf5642e9d9aee3a15fc0b397c864ec78e69410ca4b9592e424ac99e14a0742fa490f1228198670ee00123408bae584f888f994ae41de8617327b1543b6873f51644ce485c2669b3e010a3e91428bf002b7f055d15a3eba225035b5c7dcee5dab078c0cd0c790b8dc0299f85596183e6f1997689c01a5ca2753a50a86acc137ddf533491bd4681d9910c7f9640545612b129f36d150709a7b7d238ecf28d8403919fc1c36fef370d32cf765b09f5db7b183881171e8c62924e973bb650afb99f90310c7a3f621641b4257204044f5213c7c8f237db73b012bda0989d3f0168c2498018801398780509f5bce91b0977017dbe5d9b7b09791fa4559fc6f1ff0d5a41559a79253c05d267eb5ce406385591bd5fae003762d1bf3fb0bd92de3614bc6deda2e01e5e4671ea10d96b16d2ffbd7f81f3110be651b62bd1470172f9b5647b46d985d418e9f180c594fc48565a15d17a82af4d22c69c5731520b7878a5d6416d77bb5d39884af4e0f2125f4b4315b6d6bc798fbbed197b520608ec3af3845bf3508647723276d6b584e2dba5bd6f387fe948234bf4f21b43fa56f2f0b0c335f6d42cbd8eb4b5cf3acf80f19718350752c2848a7e92548f01fc657b7c729be4cf19c2c5730a915eeffdd69fb4057568690d7417d53a1978b3fd3e30c92f880f6485c587093dd3330c13b58df7baa6fafc9462ab26a4c5c93f2bb0564f2915d9aa65e408829b1952b8ac23e81809750397bcd6ad9e6bdaa784566f7678c43978fd52b1cf9887e597e29482743071cf1a2a9788427e3f8d941579bb0fe387c494e542f2e2f35c248e5b4ef349882214182fedc5aaffad4d8e675323285ad142ea36fcd0db1849a04266aca9d9e45d40aa07f78eb8076cb639e5658d8fdfcd651ea814d3f51373c44a151f5bd372f15f68b27cbc542e0ed148a05cf6c82b8c6f1e8e6cc6f54c9aa2b286e229d3cab7d0b897001e5fadd11a7e3616e8e35effc9b0acc5a20acc979707b144463344e17037723ec102cc973c1fc3209a3f521c1b6cc8fb68a3a13407f7f591c76880d62f5ef0fed630ca76f9073bf4c6a11f5694496416e662a009efbb50355d183d03482880339f95045c9743cad65627c69d20f99316a8761ac0cbff5057af7c7902c6598fa456071924fdc9115476426fd95ea8da3c8b6d2d8bee8f1669614eaab18d1ecb50a3918c5e8a97e9e66bb4571aabfd0af1cbb4a7b3701573848c1a31f0b2722207dd20c1bb9d09b7fa8816787c394bd45773436cf9d753efadc0dc47e5e562093765828c90da1fc158d92ac782455b34e3591d9a985378038c8397ea4a242747c5713e51aa889348d7cc8349a3b65f4685a82c59a361e587aab5e3989b8e0d79f0b76415331f0ad802fdd9f731e26cc25a911e3f480847a4fbc330e946815bad5dd7f2e68a8b66932c87dac1f6521d7cf04aa4c104bdbe72254ba926efd884b857566428cb1079d7dbc5568af03ffb3eda496ba797e15546891bf711417c825870cd5ccce5bd0b7583ee09b68c971436e492e7a0a78163c16f1bcf3b541a00974fa9c637c8eb21ea63a8d186a570a19172d204848470db77aa60c624663a9868ccc465d3c2d78cbae8506a42609b1e4d12e559db6b91522e37f79708e1ddc80525fd5c96205bba00cd92054ff1af636f54724f72a2eba9a1564166f4fb208e965f01532782428a1af985b63ee1cf527b569aa2efea76dbe770be5fae8ae10552f652bf949e42a78193c16496d1ba8dc9cd6722eca1e9fd70212ca61dba58a257dfb1a904453fa13e179b2ef7a1c7920b99a2527fe42c2068235e17d5e555f4555e3addfde514eef777ebec4f1589365f68aaf8fab63937e3c7001b08091c5a5e34ce5f77c4e8ccad1d486de497cb485e86c4642887365e35c456a8e0c024b9bab20f5b55996dd852a2c5c46f837926293a96e38b9ea49f75232eb3db2243ef7cbcbfd42ea100c8eb124c14330a96ed48cee92605bc1b5dfb65ddf37eccb49778473efc265c841afe7f713e34b1e76de1b345b1bb33f35df0008b15b34dda381ecfbc87ed5fffa29fd68cc19bb094a8733fa835b63bc56d09117ff88b75dcbf280a642b2f9d2653c3cf91dfaaa2ab9d23f175eadebb6fc8394ead2e05a8cd7682953e493aa52f86e854c995e8ae35e2a6fd6a8d0ad166385725f36d0449ed6812258dadf212781bf00ed1aef0760659daf5d965d5535bd500d71c55940a07dec69ca61c49b4f47afa06b3fcffd2abdcf375a7160c6a9fb2a3384c20fc36c1774da8ba282f0bb799285ed825952125a272fc0a9c2f3514013e9c5272af1d424de836229aa8f9202276373fd2932f2f94da4a62bd2c6068dd575be95849e1ee76e643a774fd40f02f6c2bbf842fec3ee5dc60c7c3d947c84c0211e3a5d7163f5306901c087e2f7278465248f211ebb37b3fdc3b55d239d2cd24a485cc048f8ed5ddeed159894f7134c1bf58a8e953018d06199de99d810eb1bc1e0057b9efe5204f7e4946dd0f6d40c58199d8202d9773793439deb25bc3b3e367c44e5bb11cd9f349d1a4305cd8457e9bd1a125fe76e69197974180f1efda8efbadca2a7ea29fef8e7d279d984720807fde4c935a293435800380fce81df6196a1d916521e92616a74a4ee8f58d2f3f08509751e6851aafdbd1e61f0bbec4286865169ff382f0bdf9dd0458d2f08cad26a14239aa188ce46edf044c7091e6119aa9f65694da5730e18e96c7b96859a6a7ee0fd6619581edc6361da2fe97ebaf99ed25baaf80d93e9abc2070d50cf0453368958983da2dc91be1481bf791b169cf4fc79786bb3c9552ae0ae598aa7b15334192d0d43be25e75c4b4438cda6c76bbe692ae384f6b606519d7401cd83a0bdfad5f19770152a9768cd078ad1d7e60c29e95839c814327b623d1aa8cbf0adb82ac773c9cb09cea3112d3ffe6a8c6ade89374f6b0fc3323e41773455849d222aa257a26bf88cb04f93470108b2b837c7908e13c9fa43fc6b64135f7d6987a7a28c5b9c7c604279ae0a0566b95e2c4a4959d6c3213261b2c2d190a5e71112f9bf60a8a2ff176d036498e396ac5f781cde23ecd4883882769cb864bb0f374fa4f21702917d5b59ac3dc863ee65a1b3edf02cf786d070c006119c4582167fde6da6324514c61ff523b8f8bb579e7308619208cc4567dc915d066d4259cbe529b3037d8e20e0e239defeda520fd219102b466af669e7d89f39dc8a7c6be2c5204adf39bd31a758fa8bfddba28a7841d90b41ea66f00b0603c3f199429776022912e39123c7b656e6b4c722fbc5dbcdf0cee5441c98f0bc4ca068d0717e119dd46ad279966577015587d8b89639cb48c895ef2122104462d4455fc8256a73b49a2cee640aa1b9a4d92b06363fd6187d73b176c4657d74987d3d4e4e0d02fdf03c4ed1fed9bc3486de9c9114791ba577ce433f3a7d5056f0b2b51ba9160362b14cd6c952a6821d17ab9856a87edd150ecb836802ba46a87e5af6989a699a341cb03bd741153a2663c9642f4e4ae1000f9684a0a97876fe38d8b816196e4491a933c641a326596af588af0c0ec303e8bb788d668e782974f10f5220eddb4bff357e740fbe994475f03b5f6e23e1547f97e487f5b2d9b5fdf2986c247dece76f18b0770f9fa96004cd0a10254c5f231901e3bb2915e1f1fd4030c077945673e4db81dcc0f764e039e688c4b9bf1ee4a14d0ff1678a7cf564c4d48616736d5d7fd9d7817f11316ef95aa41c51e2a29d7b5641bffa421765bfa7dda49a5a441f6b401c84d9fae19b1a555848d38c851a341fc093b07c121bcf846ef16a7a487770e03fe3c5843c17b77813b76bd398a208c2d9e9f958dda61eb4d3f9dac3068648b1c269730e531d3f3c0a1179243f9bad39c03d9632913c40887f983fadb6fb2f7f1f8bc50fef816f7c429bbaeb560a2d87cb1ab727b2eedf9b61ea4d818a8c92e7c250f36af2abd9e9b4dddd52c010892a1f7b517d55b33aa537e8ddb2b815b3baf5d02ae8e9a2348f1d8278999c8f65dc9f0b43f84f53e1998557823093af4e3c6011becd23dea0923468f58cfaa9512c11b9d3ba0ddeefb974655055fb2331cd056cb7717363a9b4512d5c47627fc5b745709aa39a0130d6e0b12ffafb2df2ccfafd7c24be815c00435c7da7b3b1458a3b8b87978053d3f99e67295c6daadc6813aac84333b2e06c8e260c43608033444c89fce5d9f60ca5391cc2d13e6b96780ca4c964845116b119279a11b65375b6582a53a89db7ab78ba62a59636c1721a9900bd369f269f19649f331bca2abdd7f4f9bb514670b81b420cc5ef7421182a29a97473e3cdd8dd10f64f07e4ead34f5ad9c35ff6b0b7cc15ff570f741dcfb5dc99e7ba6397dc06a201e4df17f7f555da496cefbf4f2bd01ca06d3238b8c01abff6787d8164f0e8dd810a6b9aea93693a330ca85d1e006552da9b350a4d516fb8e0a9ba43ff579036f6b3fd8fe3b7cc8f791dacc87da86552def8a2192336c45b304a551a20a9cb635d907799fbbb3f4eb2835564da5df0db401f84043cd2ba89fe71a5547658440f47c64d4ca4a4248634cbc2e4f3a7011e6097625492e24441b3ce6f206344e6379dda4e821dfe3eb7921a4b1fbb4fe8e80c76cce98a1ce0c352bd5d67949a314bcf31f690bbfb195877d0af426998bf74748b11934ea11e4942b3db02056e575d668d467ea42005fd9816b0a4af8be8b95e875ad1f281231516c00a0caadbb80e673bc8f9a03bcef64c57bcf936c4f68527058528424270727f172f8e11a4185e015c4b250a8619d7a323d2b12298e0750d5feba977648a2f110616427f318eb2cf0e057f6c102d5b55d1552fca6d2bddde0d75d4888a1b37d035367b5f19e043b918a9b5cd5c4de4dbc734d85a4121fb643f5211abb08cc11f78fc00d166a93e9ea92f2b87fa65bbbef43936397fd563617bd86ff6b4a7f37078bf144dbff987be6c3701dba487938fab2bef1e71bae18c849ee9b7675e423867d060568448b3fed42ac5d07313241048c2cfc795f977bcdc67fc887af360ccf4e599479803b76674483670b39b1626c41896f9f1562db7fc64110990ebc61283c1b6b188369c13dc7595b47c2f67c09fc741ab7e7b39acb8d7644bc52b1e4355aeb4deeca05dbd4ecc3b266b00c62b75a4434bd440addecdcdaf6a8821c632f911f3a883bef1be55cfc9b7d8c9aad7fa3f6deba5fae71abc2d2837edb5139e14338f537e7e2d05832ae4dcaf95c1f2145f471f79e86dce7dae6f8193db8ae364f9118bdb64ac9e6133ef7b74f1110d04404e2a517131ab2d7d41d79a15e5896466234dcee9b94a6e558e5e5572f86d83acb5c01cdd91d76bf489da082384d09daa1b8bcac86e2c92fd1ce1d5af4d70d446897df00b3cde3875ced73d39d818a974fecd243b6007e9251c33380119f3f2e7bcb7eb0b9087c6fc3f9efb04e4da0d8da8bfbc297b4157347b51955c36477546a06688e7adc2c820de3906a1b723bde9d5be2470be944814337f0ecaae2e3ac538183a70b74d1e0d74f3f3058d52344614cfbbcb152acfe35c38a2b104706bd265914c09566b1caaa5a1db8b652d1d930f3f0682c59638bebee52d7e905645a60a7c7a63240de0d8b3647302efd5a05685ea0bfe7f064120177fe985190488d0c41487ea8d1b6fba914633753ab9066b624b0bc60e2f29960ad0f342f26bfc178f18a167106edf0d67c387b375394afed31e54a0805b7291174bb7f81a1db1ec2368dc9dfdeecf068d4ee69a5c7e95fa78915604c2fc5997c622b37403c3c7735a4de31de5986a7dde812e3afa7fd1c82e72b27e2d0243f01cf32cbe3b0319daaf793182f31a9540a313deb997d2ea3b10e5f41db7b5fa1b268a7c08f2d9d1ff61c37180a55c7a00f0775486e185920f1103fbc4b88ebc88c7dbb07a01611bd3ef2c32dae857d8cc6505423e7450adde8078b2b1569b8f4d82cf5fccce419cd5bd44f6091445ec854623f7dc4f4ca129d707b67a95ae8b3629ad1e927dc7aa7ff13ab5f5c0e58993424d5e3757655b260d186d3c3077c34b1f01f4c448dd8ffe0228c476bddf9dd14605ce12472b3eab964da4aa14cd15d02ee500fb66d494046b7e65c50a72b7ffd9f9a9f7a9a31c5e4b6a2a4da6fca06940f4a20fba24233bcb1ffa2d321efc08a34ba5673907fa1b6eb8b386ea5627af5dc993b376fc0f771d7f6b539985f1089c372777b17b923e6bfc0fef09d65f079e4316d7d676e73d3c3b19e076419beeb0127a131935efc36fa9265a98a7b964ad490df3232b0bb525034002cb50b5c3dfa7695f4c0affb592e89bc77a7281ffef2519face9317e92f9dffdf3cf656746aebe9ceb9a2015fb4457d7b6facaabf608b187e36bc3a10fbd52e8f5ba09645e66a6a9c6491718df885576988e81ec73b8b9f42d223c1d3ecd2ed1072c89b8b92f464b07b757cf6fa9ccabac2a3c0628a6b39d722490b1f71a4c5823e2102c7f6c991578d58b97c4bf49e6cba6e3fbdcc360fd519197fb77421528360a2f678890e60dc231b0802c4e92e7ba099042762edd465e59ae26d436ef73f1ba6709ea1610a2c600992701eded486ae5ad447d73c9702724f1724feb59dcd8f1fa80f2c6b3e3b00cbc012e4cfaf47149689af6275a6ed66fbb3cc65a2b3b47ef0539c53faf0060033ac8d52f2dce8971b58861195e726d4586719c4914245e2f8afa70c5ac98a565d219c4d65d789196383f115866588408b9f82d7c8a7c8c2ae85d673dcd9b603d8adcf038e8bbdd308ca0c9d9126d6f8e6dd6f15f070f20e391d506c0c2f57cde30c4532d07998413fa123223a869693c7ad701f860af31a52133439998832c172df0ba56d5b1508a317adba97d717eded2682ea5dedfb191398dfcb599992e04c7330d0f246419d84514d6e0f2f6bdff7a35e90009e89b349c7034ff74a9a0e54ae67eb4d2c94a7e6d01c531d1d9ea9dd2ef4b43fb0448b80be5c526ea832c7a5101235bf9b07c5cb89f9c328cdff2c88d7fb4432e9d63216b6e26784b84fb484d7f15bfc5b43a86f589a26be638cf82692d7b5d197e2b90f062fcc0962158a9979bd0c9622bf3f151adc2429bb82edf3ee58a185e4914cb87d750b257803a7ed3b31fcdc6a8c2b2ba1cf50267217471dbc8c7e942a8c149fac0660c3693cb8732ad4782e64d77498d84fcc154e5335dc235845862470b3244d5d29bd40e2b2d25aaf0638fda7ee6cf73d5f786a2701cba35fca51ffdb6a3171864d961cdeae3a63b209241d364bab92a15dfef0701c912d7940c275c13a34f7c6824076c0531fa3ca3f15815ac7a6d812b77065c7acada195e096f7e9453452e07b0b7885966eb8ba7baf44c35b263a6a097a1312d70720b37c397878c458f2f3156a40616da2bcae94ea9689b20c62ed01bf31a610873ee50861cbb1ff2c3c38b9eb578105fd251c3c93d3f792e37efd30dc1d039160cf41726f7e9c82530d2ccc34c2a413d258ca9b8fce1510c21b12e32fad18982ffb7dd5cdf9027ccdd5d9a698fd8b46763bee8b93aa4ab0bb24e49be61396f1eba2c043ea9a8c3e06bddcffa28d7c2561a32695e7c949f01929d5ee3c68caf7531fa52d1fc6f367ac2c93c9543e956f7bda23e2a3eb5f29a05bd6a8acec324ce6c0a401acb060da4908c8472e48a52ce82a7e7983d56156ec738e758ec76327c2ada5adb62a42e2f490bcc2635e791e1484c15701a3f614ac473f3b52de2f7d0fd1de1cc1571b921eab93010ecd5f9be50b5da78b1782214c6180886f364ca0b7b2ad2a599f5ad644bddd332864ac8cca70e50f57615a0b15db2f46c8bc29953b0952f2f03f0e33af3a2b077abdb0882545ba19d62428dc876a7f92671805694585bb1e3c4ebc42d6649d7487acbaf82db72eb1f6db4a315478ceee159a1c5ea8380a9b91b7f6167a38161887b57d2b1a2158b72d1dd7e4853f47da7805c62cafcf3d0693faa573d9ddf3fb05c2e1ffc11dfad97f29d5391d0f512125ab76d9bd2be1a7782125c61ace01f103bb6bca40eca2aa29a425ede290d2a617f19c1b12aa531e3ff1c165d8762ce5a490e9bf2baed0b59546a70d7bfc7c4664c52dcf83fa4d0b300d08eab8d4961427800ee2c67d7e29a605017460504967906ee56cdbb1a658f5b402384927908b8ef86a12b36e9b29b3739d9e7a2e9b067b414773ef6a04729fb95248a0d231e86762781c5688e23fe0770d02dd42a64a34e1543163bfaaf0da15cff0dd21abe1f93a3b52ac9b9432a9015f1144b4c773b14a44a939ea91e2a9e80fbe69e1f9d6142ee9c7a711f33dedd86d9a0a1cdfabfb365e3e56de30add7e2e41b879831162293424280509fbecdc5b105a0fbcd49b87565d75acd1f18799ebd23ff0fb8f3698a9701f63aaef60f5183f8216cb7ea7a5a6e28199ebc8e5a5feb2e1bf56d2eb19fad0473cef0c8baf86f52d7391d460f35f8cc44a806f68d685ed9ffb04b83c7f08736b15ac8cc5f9a3aee1f8a128f7e2769f0f1d62a0712164f427463fd3f2322b96d6b7fecffabf7671af29c5479a1f93f6ff73f108a87b380531e909d4584a6fc06d2e632d27a08c33d951b339df45fa782208d2f020b0ccdc48c8b71b1bc8901e6499c999246e58bbb6a49d81153f048ded10ea9fcafdfcf5fb7474e9d6fbe5f7039b1c6be4acd3c92ea4c3171a4d2a85798bcd243b1db559248e9e39bdbe2df1310a0922e61204b8b8bda89a0cb313d5f565b9fbbe7493783fdb7ca9fa7e72bbda3b2fd41010e585053287df1bc198189d2b0fe3b9f93dd17a30e8aa0fe2514c9d145374d96f61358221bcdd73b0bfa2d0ff5200736953645584453ee45ac65c34cba5adebb0c793202fee004352db38ec03ba83af316e86852b23e2d827cbc432a7662751875d92dc09f7fc2e20ac1877c71f66f28bb7d3dae4983467145551bc7f20fa244d9f42611c53dd890c5c9fd370ddb4f16aa5342199fdeed9f40595d7b011e2477ee0c6b5f4ade058c1240c495069001c2acf587fad61c5191c68d4676b2b7fb26070efe7789768fddd4a8d65206536f35cc3c7752de521477bd08d0fa86a31e316386de1b7dc2e51372fdbdec8a571a371c5d56d69c52c3e9b327fba40869204d48a470bdc9c61045685cfecc1b9bbd02234eb829d212b4059b7d4ea06f2acee0479b921d39f9e16c62601f0a093360944fc078c5625e01bbd6b14e0be3d4ecb9ff90fb3e4a324a287085293942fc530f372cd711ef3914ec1acd61189d8b546056818a9221acad38e4b4fe29978067f3c8d7fa1c080c2e431ae004cb399d1fb5d2a21bdcf7df09074de4d042d1b73fdc5075c17e37912a881905131af30f4c5bb986c5d261fe00f0a0d9f25310e41d2e65358b3a4f3504a9bee0a07b063297161380e547a3bc332b77fa401f6ac234b5d242ed67f9166aa83a2fc952fea61438471f22baf6e8a093045a60ef88087545772d1f2547fbf8589be21a86141d744dcad79d52ee10a4caa219afdb406fcf6da4faa2e82d0f726d85d4234d899b6271704fc37d3037b71d0c75231410930e7db8fbfc4012fed2e1e93591476ac2a8e04421009bdb355e8572a9080cbf618c0e1304d12f6bac95bc542f6ab7ea13609c0b3fdd791790771e0f1420d469abbd6a8808b89888fa7e655cf8bbd69cc7c2125aa944b4abf30b59ed49f19d7ace02faed0de86","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
