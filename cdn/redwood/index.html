<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6bcc0e27dde1ba4bb701d66f045404c4bd5b350d3493b17980f0e0615ad9a22c98f7841228dd278c7ad18ea85e3aaaf337cf9cd291d49c26f131037b6ce274fa214918f70abea5ca143ffd61e941e220c32958be36c1dbe085f988bdf910e95508406ccfce5bcd02fd1d9560a1b23a771905ee3e61da0c67ace27c08c348e35f0a36822aac8809f183c1c62e09631c7939851e908cbf27c7872461d54387cacb2c41a1832e6a05fc8a9de20dba4e7dad5e4d6fa1fbcb342a01894d53592914540cba600ce1294fa260128f6fb26430e1860acda533048b2e912bb4ed96b20071bfeb17e3eef52261e1739fb70e40035a297d915947c5a0aa8621dc8c2a438854ccd5f041e5660fd65c1ebd7211e15da4bd44963735135ae8353b0fefd5060fd7860c5550d3dcec620da6ea3340bc5a649dfbdbb18336199b0b5d9ed783acfffa1060604251a8224d7c48bc69ec5251d158af50df3fc6d52cbfeb9fffc7b2f63d31b35ef2195166f722315a805de18e511aa718f9705cccea3e228a3060ac3b2d324cacc38c31261dba722e61e80e5eef10e1258dd2e41711085ab8227690658f21ce5c5ce3faee86c0dcb8ee896d058168f8228bb0cb3fb5793adc8e541b90472b6d987d89147b4fb87b1567e67305e72179f88d4b9a04276c2b0ac6c40349aaf71a62d002a822225d2dad94c6d18532a1862e4eff25a7b955c277554eed1fc7953e9ce04d82abc7c9b23ecbea17ec426b605767ea27c9a1907c7cdefb325ccd7db22f765f870ddfdb91313f51456a487ae0455159af1c09ddfb85bcbfc6d90a8b545551f9b330c6a294d724722b29c37f8edbca59997755f36457f086f506f5a39a7db2bbd64ab9c487062dda667dfb73dde2474a2d1cf5538923ffb9bc6a9c2d54f4fa284374977946fc23ba224f2bdfa94a2df8f608c0d9657da22f1cdfbb05bfd2d1230ebcd8eafdb96c99f2a94aad09acc4929165b5cfa836e2351ed8206d6f82c43fb33480c16e7d01c9738f1282ab0bb4a2288cb901471b7748228032eb5f6c376f8faabb6ba60614878a1239f2ffb95b1fa2b63cc107c692ba97868917935b7222a067f7345fe759326c33d5d81393d9b97e62a7b844abf59522458020015d18e1a37a077b586d7d66c393029dd5869e76d71e95ac3b694d79ee5a74ccbb5025b3d66b6418c34f409ce47da1ddedf2600c24008c4ac1e0abd0d92e5510fc0c89107e3ac90fb94bb7b73fc9911e6c2ab37061020022f31c02a4ef5cb91c45b52e1e6f79fa983a26efeea718ea35578d8627dca18cd67da4bd342c259db01447416a7f0d307a7c5ce998c0412d88a5e19ac27325f7eb3623f2e854ba8f6a47a08d667496d9d04f754769fe4a871f76bc0c03fd0860f785ad171eb85a9c402b862e97260be9c6fda0eb23f2dd697a8938ed83e52e54a6f504646fda71a215e924944a149fef4ea020985c08f0628f54f50e754780d328119d5b215a137299d53b993ff645b17666a24823ebd166a399d3cc20a8d03afdbc12a0ca403ab13ad0632f456a07e536ca8f1ee340ad79f0392556989c3042bbd951f56b0ef4e5349db7ea783b9df35f021b64ad4daa0d03418d54e1c457c10788129723aebdca4391a0ec1b052b4090e6689c25b0bb30fa284e521eaf1fb35681d5e342657977c16b01a826544488bfc8a6f8fff50d0addff2af8f02e53dd4e449759c3dabd9d08078c6fa7a1637ecb9edaafadf89e360d12bb2aea777d4e9ec3a83b3de925f9079707f7063f547b0a7a3f59a98e8299af0635a0a4fbd2fae20c35b410338f2fa44aa5b5aaf8ed1b770ed3c12e3e856108264327e34d622a03a42270bc5bf4306835b6a43f6f62f58f5452a499d57589e8cfeaf814d0d15a61bac4b969c1b9c477d521b7291d7836a4fd54cd88d5755c51b8eb76709883a5257f2ffba318a7c37dbd5d9042bc2eb6d1ad418045da24d84046dfaf2629a3492fa25ad0f8ab50f0248520adb2bfba48acf546c5c709de8378699e27e7484d663c8021b7c5cba2a7981dd2246c084a6c85ef69b574d7886b8ebb42deeac219a494172b1a7efe55ed33e5d832006dd03d0dd07de732cc19dcc7f1759af27c47fe8a34ce89a2c139673340578ba4eac472130866812a545afb34cd7e49bfa0da5814e9a146d16274801d61d75c5de470a767abf1f34d84ee17e67043ce53f475b0459d885710165d06f364f7e98de9e2f0c802cbd61b9007eedfdbddc94160ab0a8076b8612c1eff37d77099d7283fc76453d80487aef392ec82cf29231bb94568a7b20fc33b9c77961723f25f59e1ee71cb0d2a6206e229131329a6b8b0cd4c822c5b6a5fee109156bcdb351111a8b07d680956781a2006c1863f30017e676e4c8b8df9bc8adb67a98bde8922381479b5d56d2c5671b570c8b8c69c1214483e07b9620362e6b7c1a0b6a60ddfea5be1f25af6c42b0ad49769524a466a774b4a926a8d1f5cb44329194edaa67df35cf9ba6bd5a6cc5312cca7014de5a91d0999d131d174bf7c705ca86f743ae409109163b36d7ced9f33447f9f0aa0d6f0f1449d99fe61234e0034b901ec038f5b57d9817261d8c3fbcbd87c40603e58d0dd528c3387afb17d10183707529a3ff935688759bc0dc11f7204f275401c761c6eb1a1f3b95fe5d2c6b2d5daad65400fc9e5b0e003e282075aea2b55faf5ff84ee91ca7537564e189ac3a479eaa76576988b004bc3366c6c5b96245770b4539d74f14e8622fac3e9b29979a79f50183446f747c0dcf3fcd8cb3ee83d3b9cd9c8c7f4226d09bb3cf231a14eaee81ccf19bd646739734dfec5be3c5c920964340f650f9def8bb8ba2a8ac0cbc5f85c4b38338f4d94d2ee76bbd7bff02ccf077c5804bc7e8a246c8a2465ee7db89e362df5f18b0524a89efcc1182e6f053bf243f3b1068241bd033f1da5cecfa68b1b72deb11661772727d64ee59653fed9ee0ff4ed51a6f69d30326be77766c0c4f096d549b38c76d5756ad271f47b48999a5a2342917a268387c6a087859d83582d42c6a5bb61a873ffda56c469c796954380a7ca6752c9b45a28988b700ff3bd57c0906008142a103c1524fe9684b054d4d0dd13ec1773746500db9b65673b26c481e699ea26f82f9f6945eeaa84b003de9405b6f55e9476341ae65604e92664ac70aede98377b1214967c3afda4e02399f6c07e22619a087b57a80a6f1ba0d229832cb6aa9b08562e18e12587256f7c1ef12376bbfa16813d767e2292e8d4ebb61b76b8a0b0ded3af52aaa63c364cbda8337df265b6c38053ccc33fa43210f3bff04ab6461fcaff13c8eca1e54735a52701a09ea4bea17ec89961b43ec7a26c2605ff61339e1a9fa3adbb4cc3ea2dfcca3dc7cb974b072f3b60a9ecc0e8033dbba0de89f4c199c410a1691b1be962038e3e2e3fe2f808809fcdfe80907f773cfa16154d53fb2210db33283499a290e1a88403be84e66bbe3e05c7333afae61c24b45a4f034cc68e54cf828ccb787f973af8a7cf328bf023466b3ea70fe4333ef077506b4a41461d443e6fca8ddcf661e9b28fba6bfbec3f128b4ed33ff8b91fdc681542d6ded9be1048a716a6c6dc65369ba431a86f0d7050dbb2682e4327fbcd66944e546beb2e666f73d029618a20ec011cfb4ee440eafc6441068fef10373ea7ebdb20040d674881fb68597c2103dea1e489c85b48c4de284796754a1ed552ab029a15c1c52baa03dcca8a9fdaae6d24b8e2f6b40715ff787a5ece65722a91fec7efa3bf43f646d8f38e4dcef2cd82947219bab86f8eb9a2ed835cda15e4f6d9854284350b96feba6ef768e1b64d0f5f93794ec412978a8ab1f1c6d422cbc19cd9aab023c53d094c2cca732ab2524d7e995515dd6cb1b3805eeea39a448b25e008b0732e026ce2fe82cc21d9164295738148c09b71a2916d69cecee621231e9c5c1f48e9ed4d772dcbb5a4b2c8139f830ebaa1f9ec02b22ee2ee9c51766105210a90bdc7f226081550e15d8ad50b77a1531012fd2dd9c1375a01fda68e9316d56e01327c3a3ccccb57af01c91cabbb59168a31724611589e486078cda88c310960e062edf3482ab343946676d060c2fcd151cb4bdbf3f71efb645adfb0d754b1bfeb47ced8f543330613a07a1dfc0378ad83158a5e0fa82a8cc1931e98caa1221f4c21e745bd787fb02bbfa63c0432f12d5f3d26971c048eb8c10e156fca1d85846eca988a7681e608867cc0d054d2c80d496c9e053a0a8fc75c87df6ddc1827824ccf372a520a0ec189fa28db0a92cb5ccc013e3f231e749110753b919115516fc254cab09d839d0e560e0b777b0adf1fe34d0e8441fba56068aa54eb1c25a03d669e077ba863e9f29d456c13725df76482b92d80e97e6f6c223a7bd7372ffeebcfe482d14b487cb521ffc5d7e0cd23b27e778ea4dd1b13fbbed3ad32d12d0380c0c194ccdb4bf0fe0e785ce690d189b066a03bc3c7ca31aebd63465c636ef508a9f6995621ed8331f1eb3095a07ea2dc6809652cc4e21801eb373661b339de9fd03fc9229aa9cff56ff70b1a6a6733caaea6edd667ef08afd25abbc195d51bfa600749d5d9f3ddf65d1c3ee34b39e620db9fa8b7e7fb642b9eed6d2f5dfd1633839a2ce57e8487fcc9d42e5fd251e7039124bfba79770a3da01d8c21131502a0a9273044784e27ee53c92b4a1cc9744346c50919cae379611e1683ef2c2663adfddf6d107c8c818c5af5cc39a00f97e150c43b9273b0aa1c57971d8d806d13e193aae0b2eac9f654dc7c5d3fd8e32d14c042bc19152fe87435342ff3a71b592ed8709fa95b23eb9be916ed9d88e43cde2210a18f7d7274202d8d96496645a66a6e8e74665d15e3d89a68656e6aafca8a869e825be6b1a1843fc13afea44ab4929998e3fd12816a41b678ed9b774eaafb5bb1ad3800ada7d061c051ad24329c2b639c7fe1571e253e83ff604a08c140a095ce2a9597bc3aa4ae1a350e0bafe7d51afe90ef60b45d8dcb041d793f58230402f7a992f0d56bf6e94526c0323828a31f59e98f1a59aa988e1012f1afe4585bd42752609bd18b4d391f16d65d97bad94c53c040da69058c4b0c64f2cb1ab6b86ed6fb807b4865b176caea93f68c810b33782c59929a669395dcbe73985e05e2e3baa1a4a8cffa3658a12e427ef377404abd367ec2ada039ab9967d272429add58b537aa8e4ab0b6362dbbdf8ba6d273d24c27d13cfb83e746424e2c206dba84d8ca17bd8b0d77dfe0968f8a00de766771663be7bbd49ec879a40d66e806f669cc19d2f1076956719ed5ede5b888ac21434c9efd60d34b3dcdf457b5fda37f1cea4e5c54d81aea2996ad273e42045e739d8b76f13a25d399f11e12eabd68993077ed1a98d92be5d578a96d3fcf5e042388b46797a1522f3df87b98b1df3931a8c741a421067e82a9e96352db067f3edd27aebb5c4c654c3413785c1a07527e40c7bb1a7da089b4909451101f51a4ecd3edc8db319313a37ed0434f8cf341b6aab88af945734a268b4f69691633cc65505cd2ea9a99c66e726791b472515fcd4f5290f727faa5aed8f608de56720f808c46f44665c0609232b091fc9715c769dee41357ce75cc62c8d601e554d38830b0e1fceeec5cc544631b146cd4f2c955eb47d26ae97234401d654190a924d7869dce59bd35f0d2c9034352911321e99efe673a951c41b592901b42877a34687ed1d2f15ef3b2feb2698a8aeda30626d5ac4f025e8f2168e1c3ea46a9177620602c4e2c722c38dceab744063f85d4a2db3727652eee0a6cd9932db23849321ed6d3894f4ae8e447233c73abc919cdd096d1f5a161d40271d8a7812a57849e134b24b902021e10783332d1b542a9d7250a4a016d1d711388218e192f7f2ec24c62296d0b85b553839d7d8c33a40b044bd7cd9ff293bfa91c3531480ac21de949c69ef1c8617498a1ae2b3f0ceef7c55d17a4e976c49450556faa09b71d910df8f5edf61a19ee7983e94e1a938355bbf6bc6f07bb99449b66ae084016bf87e859c1caa105ab926717d4171d15e714b69274eaa99de3179a185de52aace5d73f396affa3f8a9c0003c6cc2396c869344f3461783b0c3858fd0c4de34f23eb7e2667ff04365bbe0dea1a9d0e150a7873555766c9143db2b4253708ec3b4719cda1ffa2f0ecbdc3440bed8f709b2958ede470f5a3ce87fd292e7f7502ddd13d5cad237e3568f68ccd7afd4ca84ebc9bb8c1c880f96e7ded98f4526aacd942db9c9e9379ba59b2650dc0e41ec83f4d823ce2acfda47c52383d3f0d169972fcd2efef98b514043101d46bf1f0d07afe3082344c3b374fe343773e5f1c522d1ba2de4dd7347407a5302b59fcbe1ce2fc303b05ca70b411dc8b0c5d1cf2b70409c1df769f7ed467e54c8511adbf9541bca2534eb84edbaa01f6a3b7c9141b2708656f37f849106c6442efe4942daf0e4a4e0845d6e44d95bd8ca2e599c3ba16b3b081d279321b32ae71e1da16b266be3d0d5e5c7aa70ccd3f92a954d75b5a428a902d4063b0f4d3e4a5824f9705393bbadca5606c2bb307e406fa9eb70869f69653383e405687822181e89e64616fb5b8afc93a1fa9f8d71e8a3343fcf08d5cb1169847be4b733215e25bfe2ced29cea2eb4152ee143666a42c9e85e5837ea259f2fc44810693b4367a762f2780d3f240a2d812fae77ae1cf4964f3e7233b12c9f91a971c4bcdf500eb8669a4f0cf9806c620a463b275358e6a61371456e5448638bf27ee44335380bc3a3b8120c48ca7a24ec62b74a5dd4ed368c1374fae0a29861ab763b7ca7996f74f2defebfe3b554d6083196e4bc0ad4035e44c1d4117bdc5646f31118dbb3d944aab606958051f74099c1822249bb98be41a69ce03c423638ad7c7d68134aceff3eafd15a2f074b8db51146f8690e3f38bcdb30c02b711b854077fe7be14055c151878feb540782962c66147154d930ae6f3ebd79e11c22a0804d1acf7df56c793bb3be8904b3a20c840fa69e4e6fc46da72c3863ee092bc7949476b465450599171e45ffa9c40b310ee4d719c33c6d8dec59a72e1944a2905033518501f65f62f2bdb6d9f0d57285d058a1cb8b2c78fac9dfc4a2942ba05e43ffcaee1c1935ce6676ec436ce8617e40f3c24f49632eca93419259ae54da05559c57ef7c4ff95e7dd64a17c8fbf26b5c7ba7a4737abf2f911e0e0890076d42a725a2eb116811f9675b2fca5288a36ff8e0dd85fee6f4dc5f312feaf260296af8290fae5a6d19b5b53934523678112c0fd7d4052176dd4ef05f5bcac5ed98ffd80277c96eb80a22c661a38ae7b1ad3afd74fe2ce45a674407277b4414723ab75268951cc7fca223af4b63871d475ae6c112876a75f366b2d2540cc7c71214e19ae5c2f7d11789713326c8c66059a1bb9e6222623ee88efaa78ed2a4ef69e84d890f6fc21f68c9671683b7ac0bdf63de3c93b2dad1bdeb38af7c886f9d25f7b78143cbfcc4856a3935434123b1ae8bd95a15389778fb01bd8f7127daad5250460353c86f6f212548122cae49f1aba847306c7ff4e653ac31fc13461c4e1e7c64e0c599747c0a3601df7fd02134ae7fc571f31f7fa303f6d61fea265ebe0bcbc7dcddcad53cfddb87257c12d10aac150359778446a75450cff1b210d49553b99e57634ce211d14b30525ee97a0912f2fb48192da067ce6f149b967cfd840261cfde12f43337922127c08436cb024cd9146a27852b4bca83f03e7409872e74d16bc4e0f051a846564d1226d9509e86b1a8d595e4975c5f92a9eb10e3f8e8554308529a597ece97573749c3ed5034ddbf784cd8be2dfc18e27fb859e3bf1a54f6ac6d48b2c9b43859a7ea45abdaa7caaea6f2d977873f31213fdb84116d426e7a80d8f0c812153ef62891535972543accc0cd05b7d1d38305383bacaf6f2f91519dc87cce1a44a623333a0f0c278563dbcd7fb41d111317571ba71b59610cb067701fedde464560790cf4ce9856d5e677e630d0065042c69eaa62e230bee5d38095d86f762c039c4d736daf8c62b079c8d044af66a30688421a788a6911bbfb10a7ab288cda6757d8d8efa37f6ca7a385bf2e3bd0dc6dafde24e7ddf7e2f15ec99b417d7c30bfe5d312ab62ccd559b1142ae0ce4c5d2956834a4209ed93482ee805841b75731f03668032f1879229aa5c4a5bad4cd1cba7be6a83d60f6ec4280131a300ad3932f685bbef5569dcdc7f31d0ee75395c6084e093d734a43925cddd410d0cf9364f4729ecb0e2e72ce8dcff46626115ec780c68492cac6c38894349d2c75d3a9ee5bd70a6ec8398680c439ac1637100312fa828c1357f47fef2c92c1e51d1a5f39604d9735431494d88970683fe998d5c897a30de691d7a90aa4e2d43a0a6b9dcb4609ebcdef4d13ad541e9363b51b7ca6b0de5897e25735d1cccb707385451fd630b947cfe4a59fb730e4c72f10f1b2f5ad373465bfa1f834d6b841a3c0d073b8db2c17d0c6d262b426f5598994fd1bb84912410e9875386abc68bf77ae02d3e9e59bf32316a703efd42cbe718af1a2a93d1aceed6701a0978ae7d9af8f31888d28346c8325b80193424db9e4c3573fb3e1398b606eaf1f41142114b75a1044f2bf8fb97ab55b502f17cdd0a1655f87c8039c9c4986c749ce78d36dabb45361cce6a6eca8b9423e4f0880269470d5b0bfa4d2d4e7fa4b3b0ace27927f67bf4efcf9f70a235b4a4da159934a90526e1c4411939b569f12dcfd0c4fd26f620284f839e86d903db7d32dbdc7f2b3d3a991f4a7ac006853cb4dd3d15f0772d12af6a03bb16481f3ecb8f9a13d6375153d232decd4620d67a73363561a6ce474bf394826069ee3209a001e830ee072a25c5f64bf6aff6855128f519be2b3bc4eb8c468e0de1bed3d631b8ead916644abb702ab62422275cb71a3984d9ca8f72df84bf39a2bd9ce2de59d4166547788334f8751f479660c189c2b2b1a3c5ef2232bf52449afc22b37d29160f6ec44228032a28a2dfb2d7d910c6b9cf914e63ad3190ec3e8b58dc5240ba7c602decae4ce6290403225a3996bb33f248ea374aa8587fdf023e7acfbf84badc958382f61ba71abbd77484c240095318819e6cb93f4a54c90f0763e2d7f6cb6b63b36d2aadf09529cf6e31c835091d9c12e3271d31c12a146b42b8ac6f6f2b23ea0efc75434af180afeae2ae482f010f8ddd4edf10c47a4e26c2967d5f18d8951d8209dba51cdf5864b560bdd45ecf10a2057bfa9c6ed827c0cae3bd990cf546b46475fec2e5f63c401914493e5f0d57da929a739ce3703429010581550ec5aee5e8354b13e5db2043553a8acab55f08d982551dd1d206096660531de60e95f2ad210c3ad6706791791afa412483e98519c8a024dd21c0d59efa84b9bf53818d562d065b832eeca29a6f01262c75cb7c18cae900a23d5916bb739a45732c2b31dd3eb1a1f2ba082a3ae82ecf271b7261ce148d0f7b3f4f3db85399cce20e2babbeaf3ba1133acb75c3baa94e7a948418c7668ca15cac86caf746102bfd30119fba3ad6a0200d76b18b7441230940f02f564ace11699bcd2eb78a45c95aaf44ea6d1de4593079225914299a2101ebf8fe3fd4f53510d1adcb0ba246825420a13170aa86a6c747d90625ae694c457302dd8c5a612d01f6072ca41de268decfb99d85c272272521a0fdd3c26e066859cb3c4e85ab09dbd2db79e388749a9e7e79414a530da14ca7fc6fd7fdd6252792d61acf8437459baa757f05147f60709023e1dd2b5b446734acbd021841e2fdce223603371c41dc6f51d84e1b955bb7f2dc91e8271e095d5d433ca79a1964d380b9a08f46be4476a50668239ad2b71f05958e24fb2b4314b1d34d179e59b8358408816aec8c8fba0bf6aadbe232d756f4faac5e170f5aae786de3ed3ab74b81de044c306fa0b8f4285474c703bc48754add5657a07456615ae3efb85286d7fba0562607110f0b75cffcbdd8bcb4d0c7881afd903311dd6fda4dce52f0e5ef544fca53411f75a4cd17ce8c8ae5ed5e2b7ddcb0b486f20c177c512a5300a583b021bcae4248d0bb9e6d21c70221cd32903cd7bc729e8d8bdbc5db7b76f25b2d6a19b12ea8322f7d957fe071b61149ef0f416592d67400399b8fa9a9431b69c8dcadedb4807131ba4a2ce0d9dac80af53971b00a8daee6851239b21902b2edad63ac7838c48d3be4561e2d9b8208ac91264c6936a867a89e78fbea842faa41127b6b7dd0f7eb7ef2e23ff6b89b5d95b10529d7cb5e710ae119a21072711eb038ed90b8ab4dd63e6a2b80736d2a70731ab86e1b5cb1ef1673bee9bb655eb42ac562354654f68177b673a1309c3e458c79a0a8fe82aaea637e87336a81e03004c2a21dfbdf2f9348035d3d2b5b5ebfff41f6a60439b5cba2c47d5b3969f80b649085bd8e7f3e854586cb522e33e78687d112ae8cfcb0fe6a9b15eea6450783f8ebc3c354d273c433520c8559ecda05288b80b1ff928f4b6aa0eb829b94f42c57e7da61c817d9015c866368daa1174c70f4479bd4ce45f9b82bcb4b88b0877c984a21ec816bbafd959e2388c1eb1560078988b1dc6999c72260dd7db55c8b68dfb20d7d6603ca86174f8f39b24b2055844e2626f7018ebb5f2fd628698dfc64b5b270127011b1e1e27d974738cafc4f32d4b14e6f540ff7cbc44d5dfccb83f1f883119dfdb585fb0ccf0750097402581e3e01e4ac64f319f038c4cc1a001ff3932e47990905dfcf3fc15fdd0ac9c9f4ead5b63b2f4ce33649152604f71cb7ba453eb40c8d5cdf5e329f26fec3b8072c934b12ac8a94cc902684761845f538caafa73ddddeaa381a88be15541a54c290c65470e40fdea9942c6a44cc08f3c7dc2037a790b5ef98d50f43863f694d9f34916a9e6369e2f754e840e65e6d940eb1af3f3d7e51111bb20cef965f5149ae7109cf37eb5ef8d10d5c27595e151fcb33d089a02fef3d92abdba16290e361758bed5f28979cae867882309d429daf857f9d137fa0eb5205835ffdc257007a40fa498210affbb684961b24d9229966b899556997a0bd0b2389ad09c1264480e9b346981c4e9766ac0ec2328c12815c101d3fbb08e76289f80921f864f697ba9b9bfd58c104f245ada10145d583314bb20dacb61719c6ca6678fef09ddcb65523331725b0e118d2e270650e153f0e46fe29ea100e4f6d543f5e6634811b6912d57f461696748c4957397b7158d59b0d449d520bc925ac38c564ed15155443963b420597bc08052dc6cddeed1de1bf87a91bfbca45eb79ef875062fa435e7a1e34746edc47afbb75625e5d9ad900219baf85983c7c63db5d2c74527b94684cf5f1bf2d1b16fd40143983c5d5207028efc216841b1f721a9796d695c4f564a1d889a52ee1c5a216d83d0676a63070af53bc5b4480d2af8d31caea2676545aaedae5c95803d9bf3799d372aa0b41c2b994155e9da921aff1d83bbf3dbd9abbd0d59b5ca8f3c29d23f0316813c831ce19c2e7b01fdf66b3b0b4cdb7fa3141f2280bca7f2544fca8963553375bea94ce520890ac670277cea2dc255d62eb6282beee999305d3f7f005a6bd6ed65cebfb2c8dd1af2f64e07351c7a22063c4b19be0865b774ae2d8f2ac84ebaadf7325d84f88de1409faf8c4d6e309d570237a57d581ccfaad6b4fdacb79388a19a49066f88a2ad8a5db268e2328fa9f84a6cc1e2089f5bba482e0cb2f87e961d6d1bb721db9be1efa90cff910f90d9b62b7465c918a6e203139403bc683e8aa757e7cd7e50a0d129ed7549af31c75ca052deb16cd2934bb005becea60e105123a43aba296010acd674b7e44508063c48d3fce6d4aef7113f2e0e813617afcc82e35be3991a40e712e63a5fe12953b3515563156c1bc0d8c69007090644be746a50525ffb2c20f3f3e9ed35165a5866576f0d7ea2086d240ac6a032170b99eb22584f21c2b9af29d736f7ed8414a4844a552e4f937cd79b0c4dedcb164e9a7e10577b116fe7e85299ce3e5313a71ca1894749362d2c9d8f557e74f3540745255a78538d5219df09e0ba9596dea9f5ab1c8ee7b78472b7616275ebd01b0f48c7ec5ea5d109667bb0f87032eb56ffa5f7fdf7f93d4b14e900f291b43038f06401736ee6569dfa045cd14cc1b77322a42254399857d682430ce6ba25b5249c90605661f2f43c11ef95ac4e54d1fc41a48be2702db461f58b19b4e96d85fc121cf29e0a12041634867d8a9866369aff8a890c8bb58b2aec26178fc7a080a8ef16c7b9a4c7c652fe40afada0b8d6c2dbbf5f979f76f4f70b1f43e6bb960051cb02f504caf2c6c3c48f9dfaedcb1ecaf6554aa552044bd1667ea64e5bcd5fbfc538a0ab8706a52f3fc802741d541f59a47fbe66cd388d972a60b15722215c4546803f4cba634dbc42631d5af03e45f5a4f75493a4f06d2e5e0a8d5da319e9ba12a7d32e2ff331c0389471124613cf00f36b061c172d3bf5ff1f103cee299b1d49cb91ea7a00db55f38850bd3ba7b008b7411faf6c645d67f586d43df48fdc4a7d0aaf7414df19c8d6c9d992eb0923d5bf596823d7683b46b7934c9b36d3e64902e84a093613749d57a15221d26916258174525071a43cc234e9b68b8c1e910aa0c9784b1677d850fc991874aa64add59aae560f760a9a24eebb3bce1002afb621bdea89b6a28014b49311ac05d13d4f224943d16afc417ac9c1f6607c3dd4bb00644e7efde7c48a9cf5a94328b3b5e089fcea6c240b5dc8aa793f5f83d8db969afde91a77db09c348dfa5866aa624bf6a2590544ed67ff8f0bace3ef58f90e740f40ae4b23924674f58f11b224072d82fbff5a60b4183837ee66cb96d2aba3c629352f03d15a2572caaf3ff2cc0188eb32d9024c804e4dd17cb9daa18cc9f47820628547ba0bfceaa33d95b2a30bd3c1b122b0595beec77bc2be21f6a8d4e4b4a434c5a8d8455885cf04489176cc4cae658922e2941db600bc3d915fb2942e24e0f2ce7ef9ab227a952e5361649f5b542f61e2cdcf1b3ac3ae442ccb91b2d2b783a5e417a1f635e61e511cfac1cb80638fc8b2b9ef4d77a78654cafb74831c052a8597fc819439ca58c12321ee602d41066ccb3e60d83d655ce66673823ac0c69e7171319392e04e5596f23210efbe3576f6fa484970a76af52a7ec8435760d0ad8669ec82d7e4b44161c18542dc77a4629524ea605a4f254453862a13134278ab426fea8279a81a1a7f6def75644ec8637980f5bea308a83c581bb658de86f6c621a70d304cc7e68db62297f64d0d78fc33d0ecf50a307e09bf234e174fa5f9a62d100265e0b5be9d127e90de97cd1a1bd98effdfbca4399200c44e94fcb397383b125bd72c03c9de2bad2b45624c581141e726956bbf14629f1d52d362ad03662a25a148625283c72102d18e24a52453a3eb95443f379928599dcbccce808b6cf8d95197b3130b3f42e52d58515ce4aa2e9597fd0525cef3751420d2295ebc85f089e2109b46134e4898265ed33c7c8a6c1a152d564deeeb3783d2ed46d5877bfc792b0e8b222cb18ca890a4eb9ca574e4cea14a4b2bb10929809fb3105ffd6cc6a49d47c4bb952b3bf4fa4f265094a4061bc349d591c19cc48ce2f93a778fa220be57aa95b9735350ea91403bd9d73aaa70809a263b2ea3af0869e05eb9619ecf55b82bb0d3fe2446c0a3b28dbb432a8981818bc4e90b2d878666f4e92bf0cd5a8e904e04089b538224130228a4707fc9c2326645241877568f55866499d36eeaa799320f8321f35fa3cd24b9d69044dca7334eaa531e984001745c501567b1234123d5841ef16c7f4f152281fc60c449286abda3ba03f7a1ac09e04d0cded878b087af5884984aeb534a5a723b50b7877b6e8525d2040a1a4c695744c12e5d22958900f84aa88972879fae5b7656a169b34d59d7794c6992753660737ada235c3f12e426c4a736bf05f237507e41c17ac49f56d47b7f7a5fd8056e54ea8e9e63f6dc967a636f1d22992e40801f2db9ffe813bf84f925b1070f94a54bfb84ceaac498d002bc9e7cc46d746223085dc2af7b2bb0d08acebbe6e91dcd9971b44a4855f41323a487c04afc7143dc4e728f82e6d7f71d5c01378d0b61756336016ae97632a502a93e28ddc84fede9ba04f8379f55bbe5ebe6cbeaf9cef274f2ceb533f1effa8eb20e0857361dde5af40a46315d44f55ecaa24862c97c53e4e5598025d506664d4417fd07e1ae9f358ae0315906cd74018c80e5931afc0b2c8ae66ee80fa253700ee93395a90f2428cc6291ba6b0a62ae4e1acbaf5264f41290a70e06634b51676e205105fc03b0b6fb494859a1f3cf003042f6b96fdcd56e040edc15d5723c2f87fc50b10b7dd80a705d7450a4a39d4895fc8ab15d85448f9bd3790faaad350917cde6d07775523401b94b96aef5f45da6edfd5f4765690092667e192087d55c1b58fd9169e5bb3656b8daa5920f0d970749be2861cec710920222932d12932a346cab05be567db3edfa9cb69c032f5914b0fa016ff7e664f1b9e3b2a7030f6bbb3968c35e2b70f99b7c0aa7e6e080cac25e66fe230db3495aa4b244bf5267ae137b4f55aea812197c57dc7fe249f4efa27a7ad23dac9703ac06608a18414496b90439dab047f5da5303d5e0ab63fe42dfde163546d97b9325ae1c80c0455257220762c23129896333bef125b2f162b61c509cf32b6f8f61b5ecef9df0ca1302cac72c968d3397ead79b419b2704c654ae77cec3fff5c3338080db5caad1ddab2778af73994d264655cd700bdf996007a176c3941d757d83a4b452a2cbbf4ed2413bf7c1b1b815c4ab37cfa82ad57de1a75c883ebefda3a8910822395b82b559a651a897513564e92b14fb43036867ef6990a1a343bd8fc976ff61c0633a56c5c326d8e5820fa82cb7bd2f534ce6b3a1977b9659c00e67b09afcf25b4d95524bfb52fb41e0787da4461d1020b1a84842b4990bb8c06c07cb541487bd2e1c4ecf2ff644ec6670c81be57d50e3024b7f9160b16cfa15cecf43373d7082582d3197f9bc94fc85c22ac11c85ab54b3b1a5b0a7acfd7b6d36cab76cf1fa656b86afc9018eb3a234feb541dac77bb7bc9f38d43f617a8f6de7cfeb710afc501e1cfaad2cd26d90971c583caaabd914cf6a1da8f68c21c447ab3733efcde08df2755de3799c87bf60a926b442ea588554121979d0fbd488c77baf248fa6b11c83c578388418f1aa7e7cff2da94ae9bbfd95dedb28130c1567fbb29814fc0a9decbfa8ac46c07e6d58061cceb29fd5857d225e071aac323e4b5004f8865de28b8acaed0d1473b5a200080eed0bf510f0696c736a58386f6508939b3d3ebb9f118b878862fe9df94598198b7eb2b9e08931669862a2dfe1aea0de0c89602fe22aa50581129ac3ce438cb3627574c3336653781e337168a678ecf50f2545d969b928a4976b5f1a6834bd5bdc5a4305ca3de41784a1b5e2e695fecef08baed5795cd27df4f1ca6fa3f5632513f0d6df089912da106a5f85060c1408c96f00bfb88685cc2e126206128fca0646124df165762c79eede4b69f70ac55613d7e950cc7ed3b541e4f33c5066a527b257336403af9da49e62a9dad22c2f4a3389143db7187a14d0053b625234423db3dd2b26fcc34a7c04c62108ed262a83cda71ecaacc4edf1469cbe85a411eeee03a89e188f6b6052ab9f7ff21aab052261765b4f6a3f50f0bf0385472efafa1f377bb155781460ca94a37f32e9b2de1241c63eec1ed2a4f33eec2739559cbcc503d61b4ba80633c51dfc5115c3c2cca7b96eb9ca0b7e70f3f199f0085e7b82edd31852ea07a60dfc82cf619a9f1f2ab70a3a4c440ea76621bee56b6c006de1f34757d14a44f71ca2333c5ac4b3e2261ad1995260a73d0b8706a2fb8359bf0670dccbc197a485afe78718f30659f4ce5f61c7851826d0a280ff97660622e42d3d34ab13f342a5d094649fac947f490248ac785cc4a5a045034fe691e039cdf0cc5db93f541897295b671edf8bdb62d63cdd668da579e7fb16ab86cc616dba2d3f9d280555144c1f3d77f6a814504a2f1580521012882f382e92acf267a631a42c05590e0e2a397cd65168ef441421e87d0fd6f7de3cb8cc1b690e0428759d8dcf386fb58abec6ff532656f3baa3d3db9e4d883c7d7288885357601d3fd23400d1b3baefa3f1d0d2b38a46535c2e59a5079973c55a543bf339358131e7023eeecaccf49da102654f73b321f1ff7b980a72d6fbaa41352e8690a5520bb63171fce9d5b181ecb9eca225d1e2ae0fc318ff59b4fab8b7c86bcd119e3618982556aa338abab368c95abf3bd9990dd7cdfe16d67c82375b6da47d22b2128cdb2c1748b094d3e5f23092a609016a0fe574895fb23c4ff498da3222399f861e1eab73be148dddba35b76a87545abc8bb35216e96b2a1d4cb449df11e490389d8cb714b352fd9a337927e73e4e38cf7e9e77afb43c7b1f3657666dab0b7b0dc4b24c019e0b0da70d8f946314c11d5e9a93dd129ae8edf28e615489ff5bbd0c43eddbfefa1d282ba6a723067b5c0637749c49446d3bec8d1a5c12322dc4715cf3e56ad0669584970d9e22a8a7afe0414a3158fd93048b7b545a237f46c1d8f733cee87786f68d1294659c39b9b3de93cfa1963522998739c814569e30a9179ed0250a5227651705c8cc2f1ea5c4202c05fa655adb8f2d82141da2d905cf5d075c46f4856d8944b4440d1f1a3594c2500858b3723431c8392f3c4247fccac43a65c4cd469279e20f224cf991a988979e90735900a42344df36c828a32f62a44c9fd4cacab7993befad3844aadf7311ba1e94616e16b9faabfbea4644308fd90411ff3ad52e97fdc9de8b8154482d69e9f9e9abb185055923dcac7bd2bb5708f31c312dc148a047457863e2b373241f5b2c9405e80a7ef0ea1d1ab42e9e36eb297ca3d613ffdd1669c46fe1c263638d61d0c3dad0ab43650f68f341203b74f0a3a2781d3b45f6f433dc02bcdf25a1abef678dde0177003ae697d55fe17b9bdb0cf20ad2e0b6dd85ed20a99c3e55e363d7d1bb82c963f68fad3ed9a807c1fa474065093bc0663243f88723ed43af84c769846b2ef4aabd5a7dee024d2c1c8f63cb86e796af6847746c281197076a5d1adc83ea68c9c6764f54a303fddcb1ea894a63df45d16187c07e277506588638e9d2bf2fc421984569f130011b1b58c5ad47129a4b4b8cce53725b2aa21ba9be3466ca0e5f63db016952b054be2980111d7d0c744efc37921cce34738884deee145f67a238d50a924324f5fdf01788ae8cb98cd1a07bd32468406de9dae04ce40b569e0c28fdbba70c8789e5aed52038e3148c1f30acb566ef0378ebfa61bbcbcc774dbdcc07df06922dc522ef75d010d18213a10a9d85a81417ab289c6ffe7c147152164047faab38c98497aedd0c7c8d3bbd65da884ccf6c08bfb3375fefdd8b1b2c51be8ef0899bcef5ecd638cc43be34cedde102babaf72dd0453f1bef1e0c222e5f8fcb853f7c912de161e66a9768bdd16fd7b94fee9ce901beed41d05da11c2b8a222eab895444ef2340c9bbdf7a70677380740fe4c4503065fb32ffa9a3f7dfb99d809aef8944cdfa4514d0eec08ebc8b95f92ee5ba97db0da15275d61ac1ed813ea49721634ad467e1e730c5650eee8be4e0c9586abeb3a9ae24c939677a02f8e8cbe18912bfb3988cfc527e40a00fe9dcb579a2a4e0587819bdaa84311c5110ca1d90f4ef2f9dc41c69114bedc0814e29cb6514ac0200ba918709f2ffd9824c9919533c7177b947bf8bf9bc7bc220cae23d69facfd25b62d1c5f2ac633554f4f2985bc15f1ae0a2f60cde7fffd1342828c1b1081fcd3d33aa8b60736676477bc799d275fc546015b3db5faad141f0bc74a7096bc8908bc123b4244824a3cae9c9f32f376e8bd0fb035dc924c0b6d7d15a2a318a1925d5313b562eb119892f7ca8ebc5a919c8dcfe9a81c88773cdd55e6fc19b576bd69c231e21bffcb989d6061299d3969ada8ae783dad40cb2548545d5b5bd921793aadc9d9aa31","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
