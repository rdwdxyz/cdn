<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90c53b1b7cb8e5df66435d4b262cfa04353371bd59882919752aa6ea69e3fb4e6883a3ca12dbe6f21056729f77c29326b99f5ce411d1a657f19e24d06d7199342d82b0b372fc5081bcf300ced1492ecf5801830dcc2106922477087839d802c538fe03fd381f28feaa69418f6ea2656afdfc49b7f65dd69ea685b76731612ef05caf2de577cccafe0775037f13febb4ba3d1801f8a6ea090d395c2629e0d36b5f1342b4b25da6f07345696851addf9b1eab33cecd4ff1ed872ed13ce6f931790f52b21d489abca119e7696b3cec0c5988939acfe01a73dfc9f3612658ab6ad6f79b905af6c4a85ec14c4a9a4ddc79e0e32c770bbe6ef8aa2d65fa3e32f29c6889b3c4f62b69540db8c3f39b0dca9d3dad58f2a05b095b6e6e607d6f3d1ecca618600343e4551d2bffa977bc13ed49765b27e6dd81ee7d8cfb9f9e3a66f914f594a510c4c10019fcb866081f8050d9b688f19621dfc0e0ca74af67771c20b0a39d06b55053a5bb788316ac377540da3b7a4f40cc34427e87d8376e4ad250f5a7b5f6a9436a1aa5567a0957db56d8f45481c45d3c58a659a9a6567d7edbc529a4faeacbe724894b7d7318d0c3cb861a01323eb108af38ed2ff5ec1b6db65b5adb0cb8497b971c920b86b0fde1016e65db6f31002c98dc4bb1f9dfc941cf3593a10a40a7d459e0cdcf385bcdbd394e2dc81744bd209a3affaf7ba4a63c206d5133c342fe94a5cca87033bf5c7da82b085d3775de46f20d2ea5ef44d7c79bfd4578338cb7bab24097e78bbdd554ca286fba5433d6a5ce71d380da0f218377d14be569d2cd3a7622e0b0327781ffa08dce21be13b42fa7d4614212e519984ef25dcf46b07d0bce9fe48960c80c9b8d9de7e4db3d5ab0f14d5c09ddeeaa201044a0cc97571e1dff1438a6bef14a197c6e244adf62eb5eaea7bdc7ff78fcda1a3ac517f36025b9566f4b02abde49af218c71211e38d02e0b59fc3f819d7e826ff508b952f6729b63e10d6ed731acc42fab82703c86a50226793367d4e2e7d6cb9b1cad8d169ccf5ba7cbb7429a155a98b832933c5d1b2c1a9c402d6ea6e6dd71e9b8d5df185cfa8a22af06218bdec0fa7bb9d5352a51094b978320867ea4e75f1196d168ddcdeadea7ef37f668831c2f5a91b73b61390d0607ad4963d7f5d82a8a131180a7e96ce273cc373496a80873393680422d9a4d913d53387b3a89e5f36280b3f14cc7bf3b6a342f9c6d28b9e5f7f43d01c31e394d57761975df324d8c273a1fdb5c3daa74f8027cdd23d24ce275ab31ff199ee62c110a3a4c1b3e2b4dc9fe38c69fb80ebd08fae0f499c19287c017f9a10e36bb5af7a87ec7ed43e9f1af08c81ffc42d210c9224143567562d2ece21c9212268ef95a77fa1139cb5bff12e0721f75f1a15673039feaf42b8f2c2571daf6434bb1c7f2856b3ae75669df4eb443eb87a183cde528586ae554d8acd0ea3b4e6fd8d7a35ed7ea458b2f49124fe2ebf2ca1050092a2e29afc02424835586b82602f02f2bf4150d025953d28178a180d3e1464b584c472c1c4dd7ffb6597037204f890573c502bf77a993e3b6054a9b2e6dfd845d072e7f4e0400d83cd274bf5bfae39cf86ee479f9dd57a4b544ba9d5367400492e931de7e7799d20935416321e09632a716dd772c654e9ed9d12de6a8559e90199a8fddc5a3991bfdfc0694e6f9e193c4149a9058320e0296b22cec895ddae761854c41e463245a213efc7f08acc02ec97f878c9f13097980d7161c01a2f64ca7839602deee1977a744c5df6c2423dc6d04de39a84ddb5dbe44f98e6a4edb05e8e1a93784e6bf2b86e3f1b15e138a3d340005519721614eef04acb410107c2479518c220439dd260c6ddd1ed71f5429d8c29d8977179cda40049328553ce5bab14f5b62e6134dbb0d78a343911ddf09280d4f9ccca263b94eab029b2890d64f8dda5fcd02df51fd2a2d63a51bbed5c7aa2799f50cf0467a1028f97e4c3a58d0ad1c82ef8169e798928056584c706c41e422ecdfae7b5b7793c17aebf68ae2d7463975fdcaf2370acc9e16e18d86174f8a1ee846bf076378502788e1da29b1a10608b25c1b6e45fff8937c9269789a1fa9a2681e83d1bcfe9502dc8568d0598c5c3cfae2c4e06f2432ba2db2b6d301f419320062e41ab1768d4fb203f75ad7de5c6462cec5fac580e47e09e20b927bc75489f79f74f69a6b7271767fb431827eb6aefe747879a1d16ae99c1dbdbdc61257aeae050472caf1455ad80df81b39b23e94724745957bb4dc1f4728c84a2dc8cc7a92c9c824fbec686c5c022f030dd0a3e93124c01315f8990bdb3b61627501b1af69d1f1d1c78285e910a70b3257a4e7242c186e2fc1bd9437aa20ba3c6d4bcb43005dcc91bf43b47da7c19681067cbc138aee62bfe4494c528d6912ed57be801fa09c227835f0cab0b3001ae2a56aed99599d300fb86d674d9cb0840aeb63e1b87a6bcdba2b73dc9b6a15464433ca8477cfdf162fb8c281cb841398e232d646a807b6ed42ad6c69869bafc0c8be28c47db5a42a7cd6b3c371e7277f1e2bdf35070508db2da1bfef408ecbe3fa8cd1fc379993bdd109cab1dbf93be51ba2f83f675df5421e1e01c26ba3b4f6e007489882c2d41e55f9ed4323536e227cbdca0379e548c087bfdb84756847c73f5ec6cd17d14018d156fe8d446a2b6bf0cc03c783e64324ade2714fb36164bd82f9caa76672bd9cbbac87da0e55b6c1b58430bd039ee57c538701e5d64cc45ef9d34a1b534ad95d918784cd7f5a24d9657febcc965c25f51a835135174d44aa9f1c5a71d4c9abc2a85435d01a9e46964f89ed04856e187f0bc35ff853bf6527d56a7f453f9fbc902c74619ada5a581504d41c82a4d4fa5aea6045277092ee85bfafce12139a459608ee0982fbfa1f8c0463b68b467bd0001f86364b752bd5d12a3686fd5ac8033ffb991217f7d6137d27f983f6b28c5b038320e6946496a5811859aaf0f86602e92e94afca991891b0e09517dc263bf89cb76f9007c13032a7a580987ee3b98d47d15f184934ebbedcf0d3da17cf8469359aa1867e311cac24c86f5ce0763505cdf3984b96f1f39a347a31fea24ad047d70c479719e674bcf7eacca9d0cc54a18c4a529f646c01468e41c4f2e446f23cb1537e3ab92e689ce78c244510f1bda8df8ef47810fcb98c6fd2ea69d4defaae1dbab2ab0a3c090fa8972d9b978d382572e327dd000bede0882f6943ba638fafeb69f6b1558580804eb889f8ce6d147b2d76f7361f4b98cc0efcf70af4886320b46f13051bdbe2fb049dfc7f9027fa3898ea683770c5b66a2d8b05be26e89e7ac94252b69865e0847ebc1c8a4b27854a1c10d5f70eac2e5ba4c38fcf570983d85e5ed254cba970aeb472fbe907e4b9ccdccf3c062006d97ba2babdd76614b460880dea6aaa07c525e02bdfa5245141a12eb30bbb5dfa8781ee754d7bb89d7ed484c64dccc51c716f59574d49605b925d7120184e83e46163816b520e7b6d25426d031591b805bbb6d3a77ad2a8b314052b9f4b8aac2dfd9fff3426e39ed44bcde17fec1140efaeaff8d538ed011cc1fd0150b22c85fa2fdb9ff1d8730bc9a2b1b0645085fe098268d7433e5bfd1ee4df12bb32250a85cb3ead70d9cbe2ad89077739da1b5a7ba9691022c5663183229ea6d9d8224dfd6c951db9c74f2b3f38076f0df1f05c0493f6a3bb998b5df2cb2c0a1f0bb9d8e12e8078ca2a688da03b3092253515a440e5f421e53d39c09746507b7dcc900e13b36578694a9dde71037afcbbb5d94e1952c01b01ca0fb558569d905f9d65f2f03cad6dc799f35a522d0746bf4b2dd7ced7de1554fbbfef6f3bf633ea9fe5da5492def340acdf449e85ba7e5dc54e625262e86c6eb505480fd002655a9016e6092b4f24b33bbd0fe8afb4403463a1336e92d3638305be9b248212a1ac5661ee16d5498852890f1c184f96446098c9883dbc30362a4202a1cf7bf9520e4b26f46920c2543b4fb72dc19e657c7deb10d281928e437dfdeed05333a92173449586cd4830348a3c180c9e55f7524584a89e385124bb5d254b633e3d238099ae964e34843379afbc10377f9c1b7fdfe36a3055a4ec0658b2015df8ceb112448ae52c1840ab78c599a853c9c42b2c6029abbe843f30b6043661645bc645de6f3c078d77f33ae6923592c3125d1a8a6239d44315411934b757a034c3880126a712e4822b2a70ca70b28ae32601487a52d7bd23f305bc7977390bdac7a40b2c197e21a762ae79c729f69f3773ac7c653d10b266d778683848f57ee9f84c83d372e23859f2106024e2368aeeda112790365167ed7bc223c2dd9d27b7629a9f087a4f7b7d37a0b2ce0c7bec7f2fdcee457c5281ceb7837072c829b09d3467a81a199406d61ddaa28d5ce83cf2eb17bc9a1c52cc12e11c161cfd6fe57a0ec25c71f92326a20084dac6851248bcbe6a42238469b815b403dc718422948a208aeb088d42f35e4b1dfffd3e97c16855d2fcd2fb729cef1f3e27ecba726bf5c22aa0f8726e414c69ee2085565e71c68f8437f645f92f6d7694dd4ecc00f49ca2579dddde0b2ef21ee3808fecd033b6a2550a8b60e4eaad2f4cb4802f547d43b11d116a777dfd168c7f205e1eb1b07b9f84f5cb53de110645c2049f80d820f04df84e1a09710dfd72d4e0122b48d34e547ffb831b95825437b09a3be3adb97c6192416265203d015235d70faf23c6456d9877a3bc8711c793f0ca877978a6235a24db05a35d1da4a48d9c229f4cbc8600f15b3943b9ae887b725c72a118644876d8b32772bafc663f941fc9bed2ca56e424c16d430ebcf877e6f4537449d148ac7c58807cdd69e329769091f513c330223b0d7d0cb5537539f00e84ff6c430b00fac1b02fd474281794fb67474b9aa534a8476b9d775e6118dc2dc92ed2fae54afd3586a4961f1c6dac287e8a6fc7184ed0883e0f93da156d949c9cba00b8468fe98e9744493527459b6c2f66efa0182ed6da98e8221bccc7300ee19ebcd71aa6a1c4dc8320d78f4389063ed4d998503daaedebfb52f9d9e5e5b623862f501d47050619fcb56dfd036635749fa8335dafe371a85c5bd2168b03e4284e1fef3e2ef814d63c58758e46ef9dd10191e8d6c2fa0ca29ae54d81208acc2fae732838418baf9774ed2b190e71408f1c7536c8d850810d41ff44cdf597d9c73bcd8f0b26c2610adaf482f5b415b9ea48a61b696ecb0f905a526a25aa32f5f62fc79081371d994c26632afe8a22f7fb069f262642a0f8f0e31872252389d3c26fe1e426cf9ca58ebf859653a77168ae39c2805b021f009cbae7ee82186cb0bc9f5248f5d21dd77fb2bfc95c64926489bf17e54839012a2be23e355572e6a4e565e835154a904b7e1c66a1e79229a6b1c297a00b89d366290f067ca45dd1dce2ca6a461d0b8c61ab8af6f033d3ce62dd95dcb631fee71c40836bfbc44756b0209b69fd732bc95e985769829f1ce0bd56aaef9294b887c095b6e016d0678c0c74cab27ee6aa6680050585a0abd22ff2fba7013a01830a8324f7f62c3b58624476fb9973ae1f251fa89c10055341e7c109be62480aa6c308ab3f956e59742a0787b0d8108c92b1df9ab383fb3c306c08fab436294fc5daf9413a3a965ba16d662cc7d79e62560ee75a4ca7581bbfdaa66c6f4a365b79cd825c7d3e55b6fca84b278c5031a89963d320d729ae1140d8859a4ff188bc1aee13f262a6f4f819754681f2f6c9ea685523eb7a9214db5907bf15a1303796a245a42ae6f569b579db66a833203cf67d93a591b68c17fa5005394be55228f70c525988a3f544eeb1f8888da553d833e9db62d45ecfb369141128cd0c52be9048f9d9c4f0af7c0b11cf839b8edf91cbaa9d922cc18ecef58692c2daaf0f20bb6bd3f189df09a6c1bbc033a000216d1658916b19c83c391b4affa125152ab71f9cdc6d1dd9d1740435a05d16f2304b6c2fcc6273b55fdab2826e5e9b1d806e5a64e1d1a995858a62b517db6ed1b4e995082e032b644368e806ce342af028f784344fe06d3aeb1bcdca7da0e799637d09cccc8a57e334dc83924dce89e230dd51c6d5ab1d599a598e4cab1c253abd1060ba1f2f769b0fabb14d5df9bde51d62fbbc9868263604aae6b48d12dd089f9910e74ae705e4ca3b7c4adaded49b9316b96c0d7c75262a3e49f88fd846c23cc40fd33094213def7950765db34d7946c22b8acb5a5e3400dd7b5c3048b99d22ebf222b61cd8b24bec6fa3a26d29edfc84bac82793dc15ad2fc6c06f5973e92061f6c7b3a5cfee94b4ca9e68ecc11fef6eae1faa0a638e15c3f2f24b3d2310b182b98c0dcba3905cfe7d7a8e7c5954c3606059ba30617bcac16e201853332a2c61f007dc79e29c844f18decb11ea47b2098c9f57d09b9ecfcd155bfc75889c308c7557f815d29df2272fddbf34bd0b77d5cc9bfe24c20ee9582f794cc089099e86e120cb410a1eaecfa37adf99a6accad1b96f60c29965ba474186e7e51ebfc57d4550998b2ebbc390325166cb123ab810d0c452d5cf9b31734a4675fcaf64f6a816f53662fd225d3001a8c76fed0fcebedaccab57573bb81e98ec8201df90c4df4bff8039fb2f653a740f79da4549c30ae1c2afa63e19bf19f39cf188e2d328076ed566626953eba8ae69f489d12b7f50e6c2debf7fc6c816bf3a572b6850d5427f88f6683f240faa0dc81e1c924dcc772fe1b768f9e9efb4863959a08575f6e451d5fdb1e85a11224a93414420138d83e4913dc3fddd46d351da629a14eb5ee20438ef52f34ddb7d31ff2db68376ea8a9640632e58ddf83122191f0362b89aefae22cb8ea8a7c783e252c18321cd407e40a34401072cd034ddae6b5417b20e6f3d56bab3c12b6e669a45a67d800a87125871d4634e3de582912d5cec22a530485fe9d3a22ac1c660b024d7ad95d9e017877998fe4a20ebb4ff890efe9dd047c7548cb2f598306c0a185c09f6d9866a4e1a1ad508e96e04e741d56de7d988f4bfe943814a547b96cee515b218bf19419d482803b3a6ffa167bb7ff3f275ae95b81b67fbc2ce322fd92d55944490e0f86924b6e392e5e716095d750831b987f6379717e612805ba4ea429bad09e12764d9d034fb4bcd4b3d8498f6d2ee2199f81a6bf0b88d0ebcb0ee0bebd88a135be7c26d4663470246d0b2f4cfc383ba9730cb6431bb52f4ba3aa64efae1d66ca88983a72ed9c85f6ddcbbe8620068e7f9657c8816cfa38647117571fdc38e9ef9e7a9ca6abb1667447b9b7091fe0ece60f3b0438b4fa488502da15280e89c90e2efb9cf4afaf0e72c2237f29149c4eb37daeb0a7dd0e19a6011d45ea5259d761ae8d4f0d921666ac5e5b7cd01d92f2eed5ffc5a66c0287598492a9ba6d643f592c791a213f6672f8352aa899fce19d98f570c0ddb9473ea8bc03ec817b00e9508dfd10f92cdf1819e65a5fef79f1fdb7b15121456b4393ec26f573f26747d8c9d4a045a15d16efe225be55100f3a0e72125d7e81d49303bb429fe895bf4c32fe8abdda8d9018835f530146af47af3967d20b4349a9bb3d84665bc76d49f2799132ea0ab692fd26c5462bf6f37e206b08603b9d1a96d6141be12137aeea5d60d6fb65b12c1ea29b7b566d26cf73bae01fe3cc9349c4a3e3c66a3f4c74ea4420558bc6ff8ff461ee14704735366e71d9cc66c3365a4aaf11a0e92e2346908b91ac93bffbc9ff98486b7db4ce1a283326e88fa8ab045b42f2e9e4f3f2c35924b3614cd4e2657ba4ff484c3bf2acc7bc55d937931271acaca206da380b061a16a97eb51a880be140ac1b819f69af0fa75e3f112cafca9eb5924f5a57aa6c725155fab4db4e6b07057b4f0bf6933771a235269d342d1de8dc691741714b204dfa6d8da066d1d21513931b11ddd266ce1c992c82718f80bf9ad3ea320b656199d66d308508c91ca276a6a2fed11d95bb7018918add12581f8f1bf613bc794372021a766135dc6f671f5b0bed49f81d559297ff6909eb3dc86f62e08ac8465c4a07aabae63719dd74c3d11f4cd8b78ad36bf3b34126773104492f2b628b13011c508aa674bd76a8836d3cb55ca6b498551b58cd9e73c71c004590444d923645f2b6c292eb1f56ec88bd6039d8d4dcb1c5b4997eedecceaf259b2ec61f391791d9280664c3908779237db4d982b16f84e162702c83490d743da0124e2dc16fb3e6569d7ecde872982def90bd4d25522c7659050c2d715950a1eef0889bbe69234f62328995804212ab78a4bb220cddf4dae5894022d622a5dce63b51251cd0d6d6a54b60ed7bccbbe9f6e6fa9a749e93cb1e4dc3c3493f9804fda77ea713cc09b4778fb686b48d91b43d72636a140eb31260f73412d391946fbbf6e726b000d67f26bbe46c0d86cab62ec4910e96fb47df21f3fb6c0cd4092dd6a4c4fab7f6b6dea4ffac1eaea4213ad8c8c07095d97f187db9b239da5ad71337f0d1dec657adbbea2d0ff5745a3e242e51c21a343989af6ff8062db3b2cece0e3a0f10cb681fd42e13a9c065b125a17a08ca4ac7bff48aaa1abd4f39d5911b3eb4c4db1945b4d13228ed3ccf8ec493f1ed8114f276b362514018ad867f3db61bd9507b7cd0c22b3a3195a2f9f1700a66aaeb8b02d354d8ddc43121bfef7e038f789337b4d05d8afaf53eaa6a0d3885303e761b2940c07e7e1eacb5c95ca32eca7007eed5ba9672a767f1a45556a00f8fb86a23aad04582819cb7af1dfc7267d0069baf0ad992570e63ba0bd4e9daa8882b55b25102a75e82564091fb2be67253ff41b5b4b45f83b670cee3694dfc0ccfd83fdace568e9ee41f384a1e3e172d202bb04789b0becbda9a35831edb2bc7be98f782b07913d77e347690cddbf419c498480bea0021415c1f2144cce0f6d52851375e67046f861fd7e5500d808e920dd030fba0da0fcb5bee3aeb3358f61aec4b78cf4e16d7f19688d14ec2070c072f301c3bd67de9c4515ac909186e3b161e5e13767e1adb3b545c4bb53095f6d4037b18aca87c0b4c72f6e118b0207289646e167c6fbbaba2b54a0cbd9c3b7c07da5ebaff7122459ed23f67a37f88b8afe113e98cf13f1e85121de60ecb753ff2741a7aa5e72f08945db478e2b36cff03dbe3f76ff2a6c8dad3f741df96745f2da59e4c6864c5241171e4f3e0c44cc2a4851b25f9ede665157c15b21230e18db2fe6c335dd0e95ac495c2a8644f94748bc32b16ab322e2ea8d18be5253fc2c000ccfc9945cc3e8391e161e0d4f7a638ac3d1d3817a297b7c41915478d21bf9303e3a127cd590625bec08508e93cca93061f438c644beeca72e979792fe7cdaad835e3192f02fa6baaaaa4e1d860218126e96009f556b22c5b33a93b56b1003bed171ca14df0a475ab443b33d1f8a5964becb2c977e6ee9a7204bed1e897aa47ae5eb449cd62f51650c396ef17d3357155f7eb83ee87f99a56761bb7afff0d418fef7e40a797b0d7c669034b6a64d5e5c335ac0d55d5522c3bdcd91ee0931915c345f4a993ba325fa68055dfbe5f2b210980b9f4e31966e72436f38cd7f62feba806dfab0130dfd8202dd3778b3031796807dc07a8bb60eb2c94f5e3885e7e9c211fbe3edd76cee806389c94fff84e1f106427374ef3a95f2062f496d7f316de4c8bde28fa2e66d97f531582f84ae2406f8e884e5d3c4dc32c8d300246b78148b9c7643330d45ff4cba0d7ed6c5f6f3f2df2f34f5e39949dfbef0288160a02e7e00ed6940849f7249d29b8a37c3f72e3593130ada06f90cd755a4a15e0d9c6a637af7c959f1dab00ff74a65b79652430f34dd300d3b14f969491a82fc037ebe830e18909feb68775adbc6dfe85a2143d9c4aab6aff82d819a71536d80a15c7dc87615debc8b57b0e337aa6b742847094936a88475d8cac807768675e515f535b7881bf633a0f269b02297e8d8ae3d99291ba747f1461462e8a08b29bd59fc3f91b9e1d44d493efeda101665e94fc9f0be418d6485a029a2ec7441576c477f5726dbda2b3458670852074a7e4247c4740677ab07810885a5b6bc19261a1961efcd660f6ce30f2e4f5a5e8d41db843d2a1cdff28d9e439b3c75be6d20e44bdb0627a4cdfdd3262be700b829e45263c77f0d1366cd12d8e7c3012a50270202673444da42b1d1fe2269a64a0fe35d89ae4002f5cfe8e6ea5009d2ea991e294b2a3236fc5e369cfd261523965302760b631d7543e52430b090c4b80c03ed65879b7d8e613bf3776e389475f7d1b1df58df5c83e6d100cb310169fc99127a0d8effd0d5db5ede1a65d16816c9e122ca8456254ddf2df30b8977b3dd9ac8f20a259324d581125e242e0e2db524fe1aa29c47038d4b6cd12400b2b128f059fb2c3d21725fc00afb97e80c985f58eb7a563c04b67ff587aeef9defafe4a7802cd5e2a80bcfba5b84c83b31ed8216a9d1818cda68ae66541b955e60a6352c215b9c6541655b4e26109c7b54801b4f7f07d52f185b368996d43ba63885c0532cf8e38582a1999b9b6e2b84bab642dcbfbaccf5c03805d8b939f200bc83331d33b74da472b2cca9bdbc5815b42467fa3cd179cddbab02919589d4863b31333db7c48929520c125c615ae48b65c1cfad469f163689675f3bbafb17e9697220890193904ad8300f2c5912ddc53f4c5020b0ee89a0b78653ef4b1a8cbb2313f849fa0737011792fb4977d15f4f5ae648f9193bd9a31b070e0431a6f9fd48a475b08270ce8a6e2f8568bbcf9b71c464e1f2f7129953a97d025435e4a3978c59e82c7b56e862dfa028973dbaccfb78ae23c9650b7f14a727fcffde5e29443757896c811860edd09c2c763bc7d48e7c93ab069daf06e122c841297bf1b513b3ddb90cb146cfa6bf766686c7800912747e03bb8354748ff8e4c2a4ac2f7cdbf9f3c0f169eb508d9d93cf7dcb3c4297bcd2d712d141ae6cb43cf25731e5f43b5a1f383e29e8ebcb92fea12d5f7de6930b1cca3a202d454b27272c5e004f82960876229f94e781a4d1236ce90603d0606f89c265b9d20df988a156e61ac2334848a9756efda94e82b132d9e0e6ee5d6319bc14e529b56f00a4649561076570621c04e98b794932b0fa20c61f61b4222401a37c9fcea86f16c22a268861beb93925ec1b8adea5342abd4773f596ff13708f2b10a4122c68b3cf1ab630dbb11ad6ea0091ddc1e8eea253105f8c96d3863445730f667105b925d5ca83549bf19661f9cbb731fc2ecb6429e2e629715422a439d75eb7059ea5a56b4dae53de1c37bd59d29b16e34948f134826efdd655f60a6f6ee87bcddd32f9a5da449389551508beb6be26108b99a35c4bf4d897c33fe13be53a9a3761add3ddd04164eea9b3c7313da1568a7aeee9aecb5beb05ec1bb4fa1924a82deaad410f4de715ee901e2b3307d57c233cc4ce5f4b97e23be72afb47ed5642dcd5c8cf8e78fc44c87e3261e86e196f3e96c1917f97a1d5841b327574f46ee7192a2b1463804ee1352e8a1bdd0e0811c35e90444c5766f57bc7bd75fcfc0a6994845928048d886a65004e2d040d16acbeac2b368bf739bfdef4612dc4872d4a756f891179848144089d7fcb07d34dbbd94c6dd7dd54efb3f37003fdfbcb8116f22c7c3f69b655dbcc6cba6ff26dfa8aa4f2a6ad7a0826708aa7a57f595e783a9bc549e1a5cd57c6127ec4d06ba242c26cc13621745a28e932480e3802e12b045af0bff0b56b95004855b310b2cdd86c049679a494a712baaed184fb964bccd73c34fb966ad19cfd16f5b07c0ca5847418d453055c48954c3d72e0ad18ca9ebc13d03255c9b0b882bf233934ae9e649867f80de68a36ceeb23c9bebe5d1eee8429b528c5522ea15ec92ca5603d927619373bf3d2610d4db226adff38e71ce1973b6a85d592d35a42e060293539cbd68b62a61ca2bff7ba62aba79c0af0c227ce40903383bc1038b113823714d6aebdb2eee7daf70d98f1a04152bfe16f57fa394eef2eb530b075f0e548b351b472478be69c70e2b29ccb4a901ca68927498646ed1175f07cc1a05a7d6c2729b885cfc706f6910a833fa2d763448b42525b33c1fea8bd5448e30f8e47c9e803850ce9d7ee9c618b32c7a32597bb8aa80168ebae127710fa558255ac7c561ef31aa463eb970c6d75bbf057fd05188881af3c5f0f763bd49680ed1ba59788bbb5fcae3b814ca6a5455bcaafba30ae00d10463509929497008c78c541191655f6434bec67cbb5e784b3259db959f16ff2a5b742f8d3c5748ac65621c2768c90921dd90329de8cc0a54a734473b0d5ddf4cb9420525ae2bd39d54c98daa5d2d8d426b5ff251751ba89d37443a30a13aabd5d88193828614531408abe706b2f7bd408e6818acceabed0bba60dda6d1b6e7cc9edbf263313f820e5fcc9386cf00f54243587e0c46567abb9073bd21bc2474bd6f22e8ca808c72bb656009c8456dc52b8a46c1d3e5509118da785170ca89b08be4c52214349d3b47580a3c5f75031ec803d484b5d65f24324ab805b4dae86d1b1ba8cb24d10963319050f24c154373ed43900be55c0f6c6f4a7cf8be7f9fefa95e24aaed5741203dd0a16059275b9baee73feee86e48025e1c9ffeb42cf2265f8cc7eead7b775a74ebc921fba686bc5c99007eda63ae41d315ab15f4002b856f25323de2c11652648b19c532147335e1caaf1f6f173a7d89b7a5320cf8f43811b058f2384fae32b85e9e3614e349ba53000e08821dfd0d04207f4c1a5e9b1f96a97c80746ef8022c1675ee148521ff09c16bd18670c5ad8c1e3aab77b0e97fccd2795e71f12030ab527c869bd02e2b0281f173949116336087949abba0d978b99cb14984d5cc00c2f63105a452f903ae1e4080e0b7247eee9e8691e966fe66e8fadf9316fba80058af840d8c260cf1129dfb9b0809fc06303f2bff0d99b69996d1905f8227a4b936724bcf4e14a67b57b130c7f5d9dc30090d540d55387cb2e2bfcb8d7b6c13667d08a3b95f165c6bdf25bb20dd95430a4bf64424494811849e33b0f90fcae00e5b77eabb43cd4020f1dd5f8774458e559eafa0db9bf5934f088d31ab4dece1ae46f7f9ab2fc89b20611729630c63933ecdc678fa28fef73405f548c22beb3c0067396a7a12e9225974e281489d7607296b959d1e7681e26ad4b6fb8a4304df77993aff5ba9b127fdfeee779b162c0cdf9e78402755a45020eaea7e21e2b76ac3dca2dcbd095a7044fd63d489fcdb7777d6e70b766eece6c620f7ba5de8193ee2c14e3e6963e369f58cf5ce50f3fa142acabc2e7f2b6c087aab063bfee425ded68f7263be0cf19b13e19f35a44a16a0e8cb2087c0262dc99f225a4b6b7ea773ec225f3c9e47901c441ac01f096aac7a2c22d1017d5687011e8c7efcd863194414d0d28a532ed4b4f6279677087662563679964263ac32d161e588d5fa72c6dbfc82e130a35154b1343d555044c4ba188145abffa60c14a5f39f4ec194bf84a7041f63d44ee64051d7a762d224e5a2efb783b8bf0148d77aac01b34958ae4d69127e27819885804068ee166f5155ec9c83845c60f821369b928a635179881ded1dfcfd8032b4a2ff40bbb29aa41a6540ce03b56a65aa3dd7fcf02b3ec084774eafbd2e3be3c0529cc92838a6a80096cdd04d30e527cfe10921575de55c308ed3a8f9320ad39dfaff4b3921069c96f03ea6225931fdba752a92311bbe233bcfc8c76e7a77375bf98797d5b950cae70d84185d5da7a0c97f859c839aeb8b10607df5848380d1b8fdd828aa4aa09da09a8543d76e512347896ce194e7e93e327ef6f0c9bdf424605d5d4e61539006bce064c8d2167a6dc2c01e4703dd3891ddfe7369240cfe22f09466f5862c00f227063a1a832eaffd07ad3a59cbc89536bb036ca1ff0d4cd40e6caab3e4f33b5546b233999ba5565cfc267d39c1aef58674147fe3abf4ec4c2dd03237f885a9b4fe7dadb5bc8911ccb7390c348e2cda05143f27995c4f080f66a491d1e737a99271738f8cced2f083d1b711d1f10c6e2479d75b7540318a0e8dab0d4a02a5170869ddbc89b61aa9337f71f65fde13e3cf33b137b0b86b75d820ecc93ed04c283b337f403df6397e146cce9cd5fc565b2f554632d20f04f990a96b3f81443c661c6f6410262caeeeb1e0e50ffe3c8060bcb0c3ce4afac2ddd5039392d214fc1b8ac4d4e70080a34de0fcfd934b88da43ab28124fc653e303346a596cc0c52490808c604e2f39efa03770aee1772c72e40416e69142f9a276864064769b6cb8faaed8e1883f2c81aff56a77b6b19329d953f78d1f7fc5f97ac6d290556ffb0299bd11a989cfe9639e27047835c2e2ac393d59465e07770af3207ae819b569495e2dfdb22056c17b71f841fea2cb4f56bf272430743f90ad5bd937fef1c82221dc252e7a666130079c72ae8ed654ea5b3d5d93b212c2334642c42ff41f89fbcc6403d827c5fcf52fbfaefbbe4a5ebed34ed4b85582cdee29e991c9f9105ed066470a91515c3b6dd86d1e88c3759195131356b047cdbf312086544d33388334405e5e676f2c123214e8718c5f900f415e6ac0cabd824ab6c09285a7792e15deaafe0f0c1d7abb92a9deb09e769c4725c2b0432cc717a4b9ef59267f6e7d966fb7bef6d57a8a86b0f287839a85066c49154e8b4f1e166b5f1ddfc005beb11943dd9fda4b25e04db7c134795dbf4893d15dcedaa4534ef5387c37a65f33838c43f215b5a10751fe77f561edd586b40d28625ab8d508bfb3dd29200e31098bcbb007785b9f3900a386a7ae293f87ea1f4a5e56cf489b17113a22d47750a0b82c7eb75fd0fad01b13d95f0efc71121dba91ed421e24aad15ac1d7a8741c845e940a560fd2be2df677bd8e370e14b83a0b09d0a4ab06dce11dda616aa55b137376324aefe5f1dd105b6c86f58a6f6a47013a369adb168f5de75c16e368ce6dcf20c0dfc5c4fe9c25995ee2317dba37ac55b40224e201739bdccc6c0774e602cb487b677aa3c120373405d30c383edf16f783f7eec5d4923e5e083122e83a75d0fbcd8c81db3cd01f94524c39c5ae85277ea6f680d924ad08731430d65451c2e9dc154111d2c0f02a5f20e5af80b4c97516ba49dbe6cac530395dbb5873c7a1c6baba2196cdc94cb045575c7e89578eed77b5661f2dabbecbcbb559ba4c453619304eeb5dbc0751afc14a1dd38532c1e092d8cac0c790db0372f663563793a3b460c3dd8a8462cef6e3228684c37eb9b492289ea564e5de1c237eb7319ad65af066bec720d4617fb298f18ce1904f5aa548e07472a9707bbf117a1868d89eb5e2b973f54d6fdce97a624fbbc0b58d596ac947214af41e24a9b0aa2624b098419e5a9b5c9705f883f19321c198a9eab6bc4f7c2a3d884c1dc27905b04fa67a5bd86687c63416f00bfb73e233d004056e254cf816af476d9592d559a6a2ad133f9743e5e3e6528ed4197b87e49236d2b425ff8dc96088952e5da2a1ea4582e1e14ddee283f42911df3018bef6ab7f3ca99b457cde3b7ede0290a2ca448cf21e2a7d1b293465e674e6610dd4c89770e2eafa6046c00db04a74f9ee6a9c02cf20cf4b308253a9743447c2fe9e02780b42ba52937d84fc8b79e0e8b30c1c66074dac99290f0f5da4984980c821ab048036ba9a35f6dabad43efbd5c4273a6c9284e63c6eac3a24873dac8229689cc0e083078b2835f8e6fb16c42ac74f75d35a8140fa62c2771f38c81b6b095836a72767a2e04cf2227fd549f3fd45da79d8828feac7170d6c02ec569364fc6d690317c6e304e39bc68d1c7c0a7a17c071afeb16e8c41b88c5790d46da8f194b962131851e58d649f8c4fcea8c569b21b6df50e853b4e258fdec66f60c18dfd59b5e25ea12b0f977e745b2e9040e2a551015eb87460cd0d635fccb3edf730c5a6c3ad334df155e8965713edae7fbc782376850a0f397fe7b05309b7b95da0ce76c3c821ac4474484a7362b97bb9ca237d2096f234fa8ea50ac45cd3db52bad30baa5889372d829438f48f06425d8485f69447c3f470fc0825626f0240ed600d0fd4ffb0d1d949d7093b4c3d1fc3b607c33d1ef57832720a85da93a10910fa758be5dc127deb83f27a35e0e22768e3bb50254b0ca7872f9d02655e3406640387a8cf759a46656d4a4d90baadad13d9dc32d273d7a86d38ecf132177e32b4958f96092be2fe29c2ff856ee13f4fef29280402b24b7373b156b4d60a415f2d10bee49f7fcfe3670de4566f3803f2d540920fe89bd60acd9f2e7fe14a7a45b6555594366d505290a16289ca22653b17dfbfb9751dbf61897363ede4922f27dbc214946ee540d74426325f0542152574d1dd3159c0fd1e342748374885d996d07f0a94b46418b55be7e6d8e08c9cd2213382b471ae63f2855d231b112c45c4b80d3d84b2143d9d50d2d695d76f3123f72ded9db68ac07b85345fb230d680326923021e33ca627afac3dc321fd22388d551b38913a6e4e85fa65d8f89291dc2b14ff06a5125f33816cfce39e8b10c4e2861dcadd54a326758c1ce74f13359d097270faa8c1ac951ca427031ff446bcafdf404a855302816bf26ed731914f33c037a4928efa34a83c75ad38f9fdcf891e278804d8b0eeb617c3440065294b4d500cf10a77b78c93cc1785bf14acbe6e788708d2f5f1d99932defd460688043534e4946b8d2d6fc80c2fd9e722b4157ac0079ad03771f1606fc53c8aae08b70f352137d4fb216147f6787cdbf7917b6bb1cca20a3feb8584d533687b393ba47e28499c24ee214a71b00f8af50d5930ef793c1be997367d517f6e552c24d08a4c9fdbe0a2ba350ec6e1da8ed300678ca107def66d0cb5d42703be95c95398125bb7cb9040face145bac9978e83c6194ae2f23c03aa764a32830f2a7198aebfa36b88220e0a652b8bff30cba93b05d1be1d7c3ae6b6dac51cae82be87d1fb9622f782ea480c8866d89b6f5f0a8e975adedf5b80576e2f06bb99453318e6643b74f2274185e7d1396f7eb6f147d36156ae948aeb5c04978d85593dcfd5681d00def5067d416b0be89322920e462a7863b79a80e4c47b8638f48cb2e83b25891c8de00c75ae437c044dbd7b7592b3f48f16aa93cdeaa6b5931fe4f392f32d1ac076beeada5293bdd3b8fc7f643c031f84b08b5dbd672c4851f233c7a727c70012270585471278874bde3b7d2cb5832bfd436457d7f3c0ca5640bc52e4d3ef30eed0f1cf4cec0cdcc44de78ef4475e8f73f8aaaebc3c022cc6d2bd1af2446a4407e99a93e45782aff0eef9ba7ff1a5aec31dfed7343d2f806bea4b2c78dc24433c70258ca6598241b0351e88395975b9be33fde9d41f1974d8bfcada453a86c3fe018d295ca421f732fbeae561285564f304c551ab446d5f05538c2c20684a16a8f2a874844f36c0f0f19c8811aaa9341c49918011582032472311057ca18d8d8bc9f805c3ca2c63b951cd1575dd3e8b9ffe427e3570e50eac693c53272e6deb2129381cd73e18e19c40d540d3cba4cd77e99f81b694a81849238c5b342bd8418e65be18568107de7e43685fae4dbfbcac10285b918e44d644f8d48557268665750343ffccef62e160fe56a3c78447346d60f99faa459658258e3939f11a13c7776c2752469e2e441ed8d00e4bd519db6c3ac9f28a2c979e0a722b8e6fe769008ee598a0370e2edab293dbb605f86d30ff05f5ef04489404d2cbbddf795e593f55c9aeaa57b86c4e2a9b73a8ad7f3dd20ae0193846c217907c574565e65a417c724c95b5bd824b4c98c4eafdeb70961f6dd5ff48f2ef0a71b70ed9fba1d4830581e0999fc1ee8776356365aeee27be7a6f3432ddd26f020816bb69d504d9f064f20579742d3b12cb15ddd4fa47e87cd0b696dc3006655b622c859cd31688c6bfe7032b3ef55ba01ac543a3b602e805d1a9c8ae1181337f0e63e91577fe421e32ca9a216b64ec02af2df7a7ee136e09418769fffd398c096b17744ac6ae169eac1ac61d25e27d46cae30e411ca5f9616fb44496708c301691c5e79fd8c37a18f5365ee9b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
