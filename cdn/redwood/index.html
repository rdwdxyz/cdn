<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c725e4c81beab2d17400920d292fbcebcb8fac11e8109485c9a8bbc0c40c1414573d20ef794c93ad12dd0fe03dd47895be89fb8a540f2eff07744baefc22895005feb058254427a031e231ae2be3c9cbfe109079eed354e989641342a3caa2e248613c9564fc9efd86bc9dc7dcd22758b8ab4358dd30ed581ed621932ddaaa1cf341c4e7318bb1a42dbc7841d60dd3da24b7a4ec70e8c0306133af53d18f061d3d5864d2afc8da2fd0de7793f91c58965dde2f7c12bd7c7f26e2783f420137da6d5b3f12d4f6128906d4f3fd7bddf2e839241cd10aed98266f72d01a63b755753ca6a6b1a4d6baa40a8fd334067c069e549cab2cdc288114fe51b673aa7687e1156ef30f53aac59ad75697357ffe4be55704c5d9a339e97b77b9ee5caed50aa557e524e076825080454dc7d32bbb33ff0541f5631e56897e9e6fa021fb78ee9b4b990a9154c506654f9d12d68fdeff50a2e5aba1667539b3f5c5bf84486efa53fcd825613105e138a680e10e0267146f57779fcb1c1fd986b5ecbeb93a47c880171e699cc17debb6dd50d986dce17c9807681819dc537777ee311863dba79552d0a4d2f8340abeb766ee1a9a467c3fc3b79456344337ef655dbdc095208db774f9920c8bae5cf50cb7b39c03e86e32ab87e437fc8d11c2e04befcb08879b1cc2e0a5f6fb3d3e628af95f96689fae7c8c64b0848c3185c6c5c8a0fc5428c0d3701bcce1a74e19baa14973437af004c8f513e94a60e2d75ee5dacccfc10324fc82c25c8afc3b71f679d453e834477b634969c8fcd64b3118abb7d7e9c0b9e10d2891d9a2bba721beda316e3667ef0cf1995ff7aebf5e839a4ca7e4e73e1b1b781fb5e308b3202df2f3215cb7df0ccb47b8dd109c8b917a0cb09a3cd45a8b56b8aa7e28251ab9547c2371cb03c4c9f6caddeea953e28d343c2848298af4546cbae0909ec0958a497e01f20b0ff008abaf133571d9da629d4b290d23f5b3bb014dae7678c6b0cd4cdbeb170497bd183f62a0523bcd80d44405276ed3752551aa8712e2fd131d9758203f8b5d77304d8baa5daa8a8cbd0e8e3e9589623588e671cd0e41f4d314d2a630b1442af3c61ae2d4e69f19479c61dfd69d4dd881eaa2d9ebf1b92a9ef230d0dadd60f3b22ab66783515c0bbf84b122880782b3ff1a4ab0ec76f39967c63124917fe563a0fa7c85dee30d7de22ae8f38cd79c6a4418778733d801057db63f70eb8168dddd2931250fd67a28add2b73ee30592e3b1d9d07d309b5e3a90ba4c64feddb55ce9916394d0fa0ee169cad463fc0b62d86f034e2178756b5ca94d4b2b8a4f1f2c90d6d1d2b109be014f9d342ca81c7fe38e1133232d60ce531e851913970d0b27c820b2a51cc9a0a2f74b5f0dbf555b3bda5ad116e92611f76ad9eb3d2ac361310d0f3b86447a30f176a1e1a489c50ebeab237f363c0f22d27522b5c2490b7d3f577594bdfdfa86b75380f776ce42a73c5980a1a2cbe96b5acc224f3f6474a3ba590417403d0f624af8f112f972e493a3a462cd43dc84be94902eaae0ff5e6b2abd67d4de8f6366b2c1aee877db6040270e0dbca9ea4b5f77a5d087943422ec8a0a37128d4d90cbfcd0b027b6954e9a5266c7b7aad1f5c783ec3a6ba9d33611337225eac8f3ae486cb9a80d76024bc0b028bec8cece1426fda51bd71ec09dc6c8af1ee64dcdbada2dbac770e1a676a6a6a5e7581e1cb352903c1bdecd82834dd506f60661690324d6317730955a739dceec52e3bd18ef24a8bce6fd77c4b4f05d91f0d774f74cdc8e8192d2793ef5ab6235e76d86ec1da036b57799a9fd560a698563ac1d19592e4ab1cb1380108e1df9397c51bbeceeb45c0f96d6a5c227f290dc59054f1e71abb061eeb5b0bc8037854bbebe3fd98c9e9bd331c1094ff85aeaf84578644fc948d7f4b059651800f3e7bc02f93c65aca8cd9cf8fb799a5f9a28c8cd87fc86219fb6c8e65cacc9c2e1fe362a46ee345d03fd2332f75328327005410df945702ad2720b35a354614dd5e279b2661cd6c6a877fe83c33eb2f7302f24d7160deb82319aaef797e6810c7ef971ab9739e7888f97a6277842901ce8e9ca700dd05c33042795172556d316d579688aad89fadea3c5d01ca52dc7d4b7a384cef7cd51b877022fa9ff65a4832c852f7a09bb809baa0d5123220c87f7f2c6c82f037dd83eb07b8d9f103fceb394b1f42232641b48cd201f76ecb5b660043241da7d420c1565b6f56e654e2b7ad2d108692420b672dee0df03370007f3b1ae23103418dd9acf1fa2cceba102f9c943cce36904f5f98b9c4e070a03b9050014ce713fc799ddca0bd76015543069579ceb4ea1c30220a60e96ee76946175e296f1dbf519e348203ec3df7f1da380a421d2f5a504ce4d941c29978100ee0ca48341661fbe140daa87ad96118cb763c790e4fcc73fb83eef02529e27a8adc63cf99ce5ff3e787632295c8364a4760f28bcafa4d6e3e46228e34fbde0dc947ff708c7e928b493a6375a9846a7fa637c4c829eac5d08b4c96beca27a796cfd04fe38cd837dfc24cc872471c2ce058b4795ce4f6ba4d58f1da05dffd1306befbfbb76b5fc330ea42559704e087a0d77e7a5b20c44786cc8df973ef74746d13b08d25de69c9cb493b83513e745b32914adcf3105b103779dcd9de3a776f640be3fa85079bad650c4444ae5ea30dffa9b57c3352131b91b3120ad0d9190ed46de4d24ab75d2fa25f7e6303dd932708884f037b30ef95596b36d4eb66fd4fc240abebaa7699f375767fe8e5f6deef4c275bbe6754c02dfa56d03160bff2dc4d91a898453ac4a305cb9f889138b54341858fadbadfcfb558e1f1a33e1c71ce855c54b2b5d9aa669141ddf3f3a39118b7709ae500149654f320ed1713158db0dc4fc73ce808a708710a18e720176d761ad2a7f0a6dc098d35528d34fccc197e5f33546e0eb30fdb443c3786d65e29403290e8e8b17761c4478e6c07d6a0b7fc590e46fd515fe20dbd277171542b0c561edcbfa3e6285b44b6dfe7cfd9b94515c647d7d3ff8adc3c978362adf5bc3bb0aa0ba8b64b95c5294525313e2f29fdf5cf5cf8b7398a23be3cef61b1bb14455cf73026f6cde5120fb40f97580378124cd81d7bcf67bee27f611fc7f1b51c31d753028004cf30ff0fc79810f26dee8040d210fb59cf83d6cffb007716eabc9eb13f73c233f3fc786f2b3efc8633ca50ac28f31a23b8293e70d6fe38e4b73f258e4d8c467e8684b45355c466c7d71c2eadb039cd1dd04ac530de5454775a0f70b5db13616993bd325a920ed4a531aba3afbb47436b1d293045bb095e87b9c062267caebb60fc0091a4fbd0529afea6e2a7e19302b3f2dbc90e53e7967d3f908f959d0a42dc9efd0a55d10a3e4078d5b1fbbdd37ac39d3f8b94a3c8826897bbb450f3d06975e4eb8d114874d97dac454fd1caa03141b6b99230a8c7d0dd9174e19b90eeac969e39d320f3d47251c09c441a1d69412a42a44c8417d007ad243cdeb8136313e3b06cb4de98e173229e5e1c6b7c29166528d9881620cc1b101e76c2aabbf0ab55f3798144bce5dbbd1b06526549057144783829193a438dfc0e21da7014c12aba512b892c1dd49498e23ffcdd9309bc3fb4437a58232ea12b81dede8f4b199454ed7a42a087f1210016625d3f7f723e04aac8e387a25e6159cf084aeb668e41b248d99a60e79a377ecd3772d4efb12c0f0b8d1bf6112548e828701040b7a1a68d69ae87239c960b370a4224142e4ec440fd82ab7bf4bc19d476501adc17cde9157395543308b0472c32c94f487b4a39a36a04f34d9ede8874e124b0eb235989c2b973f7f5e61c68a4842b36c183eaaea4e6308d23ae553ffe244405121b8ad5d4344e090d908fe32aa2bc6bff79700c5a08891a61f666451b537d8112ea8d9f81de78decb3108a577b3244d9d9eea5606080e8855ae30e976a0e7644736a50fb24843a79b8adcb8d363a4053e3962ab1c8ae270383687dbf71a0643ec96027d03e6411c217d124312bdeec4806b2379999967d7fc952c6afba6d6e8f0e655c48a2fe0822524fd442d763a0914075b3b59791781e62d0fde4607fb8cebcd0e9549e0be3a9204d26759492f63c7999953db6d4bdbc5716a791e3c8c4a0abb8ace551e9b23367740353385e661029f1efa3ec78ebf0f621eafd9a05c910487aa8780e67510933944cef429c8bc08c4384372bdb50d569f372cdab0ed9f3773502fba409ac214e4219d016fed3896634048cd03de9b8b7628b607c40fd50fd0cf67a72b162ec5a7e28697212be96fdc002bf2de9236a71caaf0b6f8c153183879895913248acbfb28223b7128ff683b5d9b16c2137ceb5119bc35d498d7ce1701f0e77653888ec7c231bcc0b634f9641224c452d8d1baec2a51f834172ca8e82fa63798d5ab353c64d234b762fe55169104feb819a9f884c7afac95bdb260f38ebaf3c4cb89558a836389db8b0f76547afdccffca93dabe2137ce5921c84dfcea23ee89e5905d030dab56d3a8b5e9a39c0765123ad17f8e714577dfdeda2b60d809ee9448cdb0f6dad00cb63661aa0482a5c9e780418571f384cc26d83f7c044743b4fcf807bcf8ab4bd54dbe349ffc168b6f5a4a230ce52fa8ee36c326be3896b35d629cc20efc46cdeb4b16d2f29059dc8d21da453fbd3032fe713b4e745fc3132d0190a8c4d12e3f5b9c5733b32afdd562ca574e1ef86e899b6f126c6be6d8c710d242959fa92dbaefbb6dad154d333dda2f7605515d34c6a8d1a7bcc6302cd7f219cf5c2229cab2c57702ac58aba89035b1adac9247932101c77195a3b43ee57c6866bd557064b525c2318d5e76af9a46c6400ebbde787dbf1cfc3e940d3c999c3e4bcde27637fe99bed16ad23729d0e8acbd329ef6e04ae95a23fd86c2a9f51e8154792b7669481e7a78d74c9185d1d2d3a2877c524eff7eb9af2ae74cc2434dbe197551c82fdc84a02d4038e04e554918580c3e5fad26ec2e773f45f8188fac0bc5405091f79b0804131471719e3d69a249ddf311a4ca3667981b56434c0ec51bd67be4aeb3b0c61e05639752c46dbcc45c759d4380bc0c47ea84700ad853afa9f7f71c1e1b2186319ae7a3a6fc74d2784186c10e086bd43c2899f9579c2efc8892d197f099f77a131dd7693f2b30e158ff0d1b53bbeab89ec3b7ad0ebe41f8d722b2d020bc8cdf6d24a19bc93ccc54a488929f5200acc76d732beff834eb5042f0f8c2ff420373fcc8a9b04bc0d112da5ea9b54f68d0ea1ed9029e91bf718e6157c8e35b0a6bd8085aed6593a48e62f9bea5b94b141bc2025c238a3d4ebcb76f6cc2d15edf83bc263f1d5ca9f97a9c651248a091cbd41ca6f4735b92c1ed27139e63c5d7b1d5f1bf4c20f5305597f390d21643ba2d321fc70a3ae23459c419fe69bc81147a28853ce3326f62383f2f876f2a07d0309506ab05fd1bf2d26f98cd1a005891c7638d50e5127738a0a3ec08f6d3806f1af601e852e449d668e024bcc4ae2bab888dbf0a1a9af875ab7f00a46e6766524a0d43da7f34a6c52ca9e317e7fe1675c379a4acf5e2f7322b61d0fb8ce94cdbb7485cd19454151a0c2c7f7f7aa6193360aa5748313454ce24de9175f51c59d21851c03ef6dce2026d775842883993b8da0dea2a053a8f0ad0478003b254bb816e5606f82cf321a597b7b6a9a344feb5ea2f760ae456a5372d95e27bc23009b4ea9af3c53ef42acb2ec5ccafd2eb39d7988dd48fe525a34700fddb824a850b2b5211fc1bf7b671e42dca99eab450389792a7862e2f0e73553ac1c4e3a9e5a435fbbecc86ae75a3625c3e77839d7f59ae25af649cb3447bd3f835fbfada42dcb287555f17cd58f5f6a4d2955be6a176f1b9a64e5116fa38bcfc8daf82267ea586c7b31d86e12e2499d2a7d7edec4e7876d9b529350f1ac4faba02e5ab750bdd0763455a5be10ff45c8df5f9edcf1cd27ac4307b179fcc920b2a65d492960a0fef783ad69ad1cf61721a96ef24d8ea5f67e46a34ccc19522bef3f8ffb12bd58aaa11c5c236648b96771180ab5f78d93feee0a0edea758627e8f2c0e0e5dfc0371dc7a51d8fd79553415d34301835d36debce11614e6bbed4af4184e6ae376a69cc0b2e323e6d348d2b52d4a1c459334e548490e86e359b3e4e4e2a0123e591ff15722fb46061f395c78e47316c6649a4bed02b790a729b1cd0fe70aab4f4bd8925568ac4539d1949965f522e92258b83fda3e7476fe1a254b7442f28e8bfff9a871e5ba6c386f5b5a0726e4fb41c6983fe4c132d425366fb2c8733ab5b4a3dc9471de2d4e54230ba5f7103c21dd4b0b7f9b0d8a660af379a1e3bdfd5e545e936a86e0cb5d67b93137e058758310969ba71cccf5760a76d78569216c1210f65f98ab4d622b3a83fdf57a22973f26b43d9b3c4db10f56c5f82d12f1dfdda05ffa5a66c55b41aca1532a573c1e1b5d1d890da6cac1b15b6062fe0cfbade4c87f15fbb7bc521e2e999e1affb4b8a85e7456fa01a8691bd46b04fc48b0d57229b638255fa7353ba3abd7c4e4a7a5f3e874dffaeebe0bb4107a794a59dc4ca29f743bf47168a7752a1f1e95c59492dc122fdfbd56b6865cb28628482471bef03e72dbf70cce126a3196611bb127435191c730229a22143c7d29014a49dea12de2bff4fd6b31a8b54d0506030772f700f8dd2709bac894e02f11d4f7d57c0514384b6450557d63817f2dfdbd3dd1feb04517fc9d41e1d1c0c268c845da07b937b8f40339369d1e7989a6a7c7e160c177644d95023015ea438df0f7ba8b49893881e95a651369c2403d58771f3a1a13550ab643718cea2368bc1200da35ae45b095c738bb0799c1c8fe0cf8bff11b8b003f3e408daae4cbcee70149127547e5484bdfff8e8ef451fcde30184e931b2116d1dece49734398b61b95236d30d414c516ddc149e93e5333ff2c8b8606393f1730fcedffee35f93a156e72d80960cbe75585431b9b70cd1819786988242dbde87b16578d7bb7d4ec69634fcc568a8abb14fadc27044fa2146b1276c7e10243748421fb379f58a346c2a64d2ae85d5636678b32c017afd0aa13650e2a7939dcf7558cf0a6e9bc86fb5f726223420e64e3eff55652be34a590c54656969c279f00e62ce101e65368419ffd3a3158a70a2f2d27b6419ca05d94bb3c20cfa878f9036a7e3dede1f95860c574fdc78bb9e27620d37565300fd9fe8b5ec8ae6d5a370af3772787e349042946e76120b0534ffa0537eccb7ce8587bd48b518f8d1877294f4d73d843d170682a762f85ff1bb73a20535845068afdd112d9ecf2069631b077d61378a136d1feb13f814fcfc7fb1882c3e1c1caf0b08c52f741ff8cc7f50c6d6b4beceacd8ea5f5677fedbf9e8d8a6e6790629c5e683640b1194f1873dfa864d637d9d4a8dacf89638c649ea580f24b55423a4c3cf7793d227670f42b89cde87451c9ceab5f55c08b0349a7fd806e6b6fab6f3ee74f0970a756b20b0494d2fdce010419c5705381c0737c88e2fb339f2be16ac2cc6a683619289f0fa194e36ccff129a424454b3d565450b1e12609c78d7a700c233be377d1afcd82df99913db6588242b540c1c0f4aef3f6ad8960161525fde4b785273b8f27d43943a1614450df7ba100bfc7bf2913c5bb558ffa24d84431cb81bb36e9a5e86be2cb6248e97550d7085d994ff71c84b8b99a891570d3b40ed28f599ac1d8f0cca0247def26bb7dd419352ea3ee538b14e8d9c58943031f643a88e3ac8a5b43c955fca65666de50f5547ff93ddf520df40f224033529f18c0bd6f679f86a90203209cbc7fd9404cb9edb412a56317157fe121d284b334519f486cf3edf2382d135a6948e552ad61c15949d82f55450b721db0f294cb0a92b22de5d40b7be37a18ef36e7bd5177638b4705bc4b6bc8c34ff90152c9345188b46683e99bab17255a1d7765d8d7d873fb9490f2a714ff06e2bf694232e4c73cce9fd68dd0951e8c6164b7758a8565741b65500f18f3fa0758d4fe0ee71936d69d81c2e12f4c955a07fcbb4b64e6ceaf8006f41b65005829d52e222f38e01cbac59e575c3f38dd583c3f228f02532ae0b2d5fa203892d7ac527462e8306599a78647fd092aeeed2b0e894119ae9d89ed3991cdc718ed90b7002f292fbd75bd189c01815d10a3831fb4501cb3410dbe463a98f18a8d11730a897820ee0adb4831cd029121ae8c4cbb4250abac2d52d7e7ff1971c4929012938b8efb2669a18a24655c34fbef1667df1f12ebe384ee4a6d1e1b4499dc947aec703bc9ef23801645260d24bcfd1b1b0b470b2c7c1c022805e28bc5f96f4772a893108ea8c6c2d0479f26276a79ab5e857444aeed17337a48411c333bc11e2cfc28f9d1b93f6c3ab4971c7f3e504d91cff210590a1164ac940e45527648040534de428c4de08adbc492225a4587c24ab34150c6aaa18fa9432a738832ac15a23c37689c6d56e4e26cac0ba5c6ea5f24080a598672335f42b560e882ed7266f4294b1d304959f658f5e42150b9b406e5fc94ba41a21ba7588c418f3014ca41cc2758ec84069cd416ebb26c5ba7c0d346c195561507e992e8c9412928fe69b5fde9210f561fffac0d880a4f44e273461c59c31d8107c1f04f921719a3889a4dae883af7d35b7c0f33a472acb26e6d6859953aced9becb1ebfe6fdd7cdf1e04431fef39198cd8acf46e7020ef8511358c393937b7eae945f8bd28fadc454395d8d7afff821b1c4011460c6003ea9914e28436d46855d9749bff00235a052024aa8dfd02679c0bc121c2971451aa1c3a2cf30e23c6b2629377f482e381316ee9c86e2871ef554e76d3643ebcd8f393298a631a3ff13d8f559d69d4d45a56c309bafe821a660fae2f8e35fc0074832d92adf2a330b0c515d65568ffcad0eb5326f9028a7f047422d3dbe39ec38b7c3dadce832c00a4de6a56ea14478a7eca8eb4a249256e960413be665af1bd63b7ee5da432416aa7e81e21dae34d926f7f1a24a1866c47de73a395f4610a3160d95c48ca109d24a1c6477c382f260fe451d13c8781e9980cc906681e10b86063d2d9ab79d4ba904884ea4e9dcfc3c53b6d1b20232d6c70fa530bcf42b7617a8f43377c02ad22d750da27a3d5d23eb27518e60d7343273b978f8fffb4bcd4718c0c288847c472998421c3add3a6cb98708a63d7ff3be051d2f401a42f1616bf13f2b859eb0a9fcc027ffa434f2098051da22a1688180c3aa045b630a006350d8e8883f79e699f128e7bc548a7458ebd9c14a686beabe0b74ff4c16c42d89c000b96b862fad21fd385e935f2667222bd0abf89c8088331bcdbc1d162888c0c40ec0733fb11d8ebeaa4f5b63d12bbb7b002c3edbbbd6ba58854733b85c0202318ea53f8b1b69082254de97f6ad936a5d3305b263d2adc7ad1382f544f4bb30730bb0a2d7e98f351050874bd0981fce8838a595da77583154933b28591f1a529e99f7adf05e675c223fc0243391954ebf2777e43ec33161e53b88edfc8b8cc40b0df9fbab0f99a2d98e4830fe885a0872e34780b608c3ae0d52fc13dbbcf75e1cb465c3802f163405e8e48e27b1c157666ec5bea9c296a050349f8719c5723589a53ca649798200b676f539f2f67f12351f6d4c08ef2507bd8625c896358d16c4c7a56d7538921db55d650e9e44fbce0f4d840b33f5062ca67ef50fffd299fad32a547d0371ade9f3074e7acdfc4be49d7bcedffd859a58662d55e4cfa148ccc20e0087dd0d2c5ec6ddfbeb2e7241eb0a403f509c8405a6ecc3daba503c26d13e72ae22f31d6a8d6f4f63fbaa3da3bab815eb203bed816f0187299a410bd21c8a5096b99021b987bd49c94e9ec835189fb4746586ecec910ce8f89fc6a7831f8bc1b5e6b6a41efe5ba785c0360771a8d48bad73feb6fe7652c2a6e159bce04e278372bd50f5a65827b734fddc94e281855930b5c4f4bf80ba37c07824e0bd4667c59edaefc15eae5a2303766e4f3b1ecc13c337672b0dbad8b05e71d75d639919825a5ad96b69567b4d3ab7a660206b566a5473cfe5dd31a76df923006d94202e5f8c1ba25f706b96c0afb9d7255e43b4df64589ceca1969bbf6b959f8006a9e87e006ea548dd1bdc0b5b1fc8a4c6a8a4ca81204bb011998d1cc0074ca07a87330c55627dc2ce73a0203851b9d8cab7a96a61bc0c3c558d38e884b259e68d8926c9195188aad029528167f18b50f7a97839198792c4c67d7d50e4661b9d44685ab2c4d1e1895013defbe4299d4d81f98b97ef1e18d609f020d29242dc55417f26c1a637da431c2c493c1fc00fe46a03e5d7c4694f91458eae1c9899fdbbeaf35d1f15804cfd751572ba04c7bf22811849766d79865676852c3e6d93918d3f9881e9a68bf15ce5317aaeffde9fe871e56a8aea7c75db7e6914e1f895fb439a8d5630607ccd23873f495ac45a76e253d4d8fbc5711aed43e90f0bd1404f54083a8d94d6e312a3af4b9607bf1302b81edcf91bcbd5575b86b92202538a1ba47580fb0c088a8a6c2e0b3798cbe8f053ec6b566ed0b3e60267edbae63a7794c54dac2a377b902e677b099696577c4091d8f79b800b46e339f2874501dbf9e26c8c19eb887579ee204e3b38ef36bfd26944fb627996595bd2f843f6854ddb4c8089c565511441548eaa8b176c22533908ef264f84d43d45fba16fe93dd53999a7c2bb057ad13994c49e05e76b5f687172e6a19f0590f4539b08c8d2bc53ec6ed7613b681403c3e1934fad231431a03a0a1ccce4b23c655559b4152b2b0b81e71007439e4120e56744d175c9f28875b676e2b48ad2ff62d414cd6e3de1333cf40096e3304b1fba53a68336140e366e3ff63ed034a599175c1cdc0f789c9bed50f291d086de593dfe91c5718536f47dfbcfff53bcf40d1e84358609546d5a06fce0ead521a2ec571916c2195514b488c128e860faf2639ff9c06a289dc595b6c6d66893960ec19a0292707f4a19abf48a1bad16206623dda257f2847bd1efe7df5ff12f108dc60f0c1413861076f9d464d4df61c2d9d8a39b4df57eb49122dbfb6bbc6bbe8bfb5dd65bdc2ebb8b88184c282e3b2af8ccaaba44836f94de399f9ef554bb0762ea603d2289252541dc3c85497da21e7c8979a8e0ba2547e8cd7564bc6d3407a3ad8363e9521c56b4c694136536f3ac1e6ef59c0736013844183fe72c5240d9608a54c218bcea3c7530853cb5a25144ead9c0e0ebbf992ecbdea68c4af5903cd5a8e47fe25de15662a27a2c342ce2d9d294f49d9dabcd9f55df9fe800b5436db52640a272aa9be019ca060169b2eadb05f40f52374c311eaed60acb9a2071f6899328187e528199c459a486921deffc347ca79d8709185562c6d67ded77f323d25ea10e61ada3e16fd0cf608c0ca5e0118174587e9cf096312ccdeba1092ba8d0e4f44a7916d31a45084b74183cd8730f6eae674f898003e98f87d197c2ca5823fa6e8a97fcf542152fe2940250afe30841d77b1051c11b5ca5f8bd94665dc093371b13bcf33d99cee532c45582448d108a4239802fe083640c6bbe597d417b913500fab924fdbb04b3a06ee9a92e84462842e30da66301f75f5fe023fb0c136081815ccdc7fad6248a5fa81cc08af420f2a98aab8d13f3965d9f08675971c9b00b659937cdf8b616bc4c75bb36995617a4ded88356fd00ec5b327ca587f1816762bf51dd5b72b3ed9db115cab61fc63d0020bb79fb3917828c46a7aec788c8e4bad7be2052358664895947d4940e361a2fafd1ef107500927e1e46bc9bee43f5c11445f5ca528a9b236c45e6d03563e1b7a727d568b00b9eab5a26eb88246d0faef53d362230fa50417b03a302601da7f7e94f787b9ffead330e820784f1a3590bd80f529f8f67e4b25ec21d3fca5d9b2d07e7e0977b2cfdc7ed52733341b53970ccc15ba5098d615221e4ef77871cb0a563d041da95ed9474e94bd72400f45d206dada1b9261307f3298cf752a136586d6901983ed96d9ed1981fbf417231895ef689e38a6e493d956508dfd854a7dae4f6f390e3e18fad516a90577c483ca211a89e1cf68bc57cad77403169b5c39825e34c05656f0f302c718468e4046e5c0b18f363b1c26ab7ec28b10b9ce1b60c5ea600b4f116bed2963d74321f0af80b380d7a69b3416bd47f852cd785043ef2c2bc81aa51de9c05738e31e02bbd857fc510cba05b92855d447f8a68eb78819230ba1b1b7af56a6be5d14cbd61c82c20ef8b4623a0da3f2fd363e8a585b5d3113fa2759b887cd96d8d8aaef4d04a012db524b169a7250a923fbf0509d1f39840be8d99fc00a2770ab44a618e0e9308ff1a65eff6c6dc30888dc927d44b8e205495ad4f66205d1c974051f3192fd345819b94fb86e3a1afa4006c1087085bd6fa4caf7a40ce25973f2ef2972a916523cb4351ce6a5cc1772c4fc7bfb0f35952e3cc1ed4c82149aec0aebd380a6d56a71493c9b0ee88dd73ab276215d5938edb65422439f61f71fc49ab6d493d1fb9cffdfff8766a54211714371a45b09efdf9198c25664ca3919ffb5d74473b0c1748975a642617e6c7997428d28138c11473bf50b3e48e4792a6555bbdb4df7bfc9269a9f0e7cea7e758fb6f6184b9c37ae8b410f73a6cc891794b3c398883a14cc0c3f3f994a0f267666c23321295c3e68e8925982bdfdf47b785d0896b38aec1047b5c4af4397c6d5da521d4dd57a2cde6bd676ad5e3edbfd0c7dfcb62548ab3c20898543b32f8128f4dde6bf6f1805db0119728a7e679ba9d6301ea08c14ff1b1e119e0f741dc50b89db99ad6141b330d98c1a0a299aa4d5e2114230a603563bc2d6dd3ac37f1a4fe5bef56dd2d2745bcbc055715f0c6fe37d468bda1fada32128aded7628905ad0b0defa9b1030a9774fb90531162754e8cd03d562b40f1c05b63d0e3298c8c09c3e14201801fcac09a1e08082424698b56c587f0b6267b0797222d1c1d7d019d4bd376eb03a1b766d35863dd2b5aa54ce3c051d335aa6d754865a5e6393051a0e93c882dddf8b87d92649ded71962e21f586bf8c867f38c3476ae1674b2b9a2dcbbf71da80de03d31df4bca562c594582fdfdc3572942284af4362bf46d31a0c12fc7a607718932a4ebf94f299e4926850124208179ecfc83e7155931f2f679e66b03355f225320e93c9886e546fceca453223d53a04fec7a2eee1631ec524c97eb550b6477ba88319e1e0d1942f6abf2dd54e26a61bb8adcb2ee11c4d5c2b5096666331e57cb3c9c225ea0f7e01766ba7ad8813dd59f96e71e04bd756efa39feb5f2821f5aa02fec0340a82867359091a78554eb98adf717a7c7c69fa4d5af73013a218c19c9d754bf57c92d0cd236f716adb51d880b76ea7cdce3aae5cf06467249047ad9f8de67f0ab2eb155332a3ae22229d35e95e634774c0f7c911e17d6d1739a3a6641cb6837e737458893b66be209df1208681ae2ac04c2f306687d1b3fa2304c7166cd080e5470ab197ecbab7365caaf501b9da79417ec7e888752e7418c7299a19163c0b01947ef473cb373f344bf330432acca7bde8919b586f2c09e5901295705af4d912e1aa8c6eff322eb9cd999df54987e4834f499124d8c30dd3204a49961c4f672e8335b7fd7891cee7f758f72701f55157468835efeb3bd781183c2c76d807ff0f6f0781f42222699d8b95713e1887b55674adcdf24256ec2270496bedee1952460cc4d198ad48e9c78792b0cb7048e484a2c0ec630661798e29caac4ae6280dd5ca7d4a97662e4dd3c319646fce3405d64cfc17e52575dd77e2feb99e06951b01aa6b9a540bbadc836fc34c34706689a4679c4ddf3dff14ee4bfc298ee36e91bbfde66c99e140a2f55e0af2abad8c576a052485e16f5545006e80f4994e90e72d6a17573a847266ac6ddd14c42cbdf09a63871a46095d3546971184fa8daa38e50bb14e9c9b1e9907e971e4993a29484bf5fbfbc20aa3acda2dcc72c815c66e253c4cc3f292cf08bbd031d331075062fac61d49e33efdebf660461d1e1e5dfecbbfeb6d834d9ed70518187b78b3159e06906e66ba44713ca2e9af4ec901a1de07bc07759c79bda4bff32024e9ccdc2e3376612039321a88432eb10b21bd9316bd09f4d8957e16aa99ffc20cb62fd0db4d387b08d5cce5444ce0ab6431747b9ed156174cf871c523a845e6bc20bf5a56d473dc082ae68f2a07f621eeba61c03b63d1f50c722eadfd4febad0a52a58af81662291728b2ed2bea036e2fbd7535f22aa2b2b0ab26b5be997fdd6451fa2d88a74941943d321b6a4c65fb056a14df28b6c0e11417987ba1079d43f1a961d8ba209abf011c9a302c90a5c950b23aacac345bcf5477a506e22a991967e2a4a79b51af059a741b6c72479107d986df4b523f913c053dc32a7d9353397bc146cd487dee6c642867494b0e1902852cfda0a0d2ad72712ace0586b45d96945c7ce55537f08342e837ef173800695df2f9303c171dc2fe6de6ab7a587485026228884d33540857c760e7156f565dee8a4e6d7994aaa1612efa1d9255ae1616bacdae59bbd7d929a04a518a1b05ffb4fe585f860a04ce5bc312e126b196e5bb9faa100c0c974619c1d3de340c83691ea597e45b62264466f4e3f8fcc1088f5f7b95d30643187fe7f05a51af82ad6983cafec38844d85b0407b49ebd095793e8e6077e6a374ce3f667174f4f7d0199f3eff708f58617f9e77f7f74dcd61e2a7e899f8edaebd6738c90cb5c5aec3ab0bb5aa9316b1ab0c1259ac25d37dc84756aa2bf16d23badad0954bc992273467c6f86b4f17602cb3fc2b286a701af5064b0904f272116b05786bda093bf808709f8b4197142837197b5051ed0a999e96b27398d32cae60b4b391cc585d67f9055417bd24f50c03bff18cfd31e147f86f86d0db7df86272816bda1912a4b423cc154bacf1ab8332885a7b45d90568d225450b210c1d377fd82ae74b534c32c99f6b84bd44b5017989e5bba84adfb84b41c5415617f247cf48c11cb8bed951769e0d96048c2bedfa3a3a774e6c4c0e9e23c40d625fb7caeacc9361dce88e42b9680f0a1a97d48941dec2f746823763872916670276eb09e1095521bcd072f25fe524e357b664e321a6d4b9c49ee5672407e51c3b5cb960eb8a64985a7c489f7d69cf0cbd72beae3864896314708e18742742e7194bb9242a28cbd5f0638148b0dd93367414fbbd62a7eb83b00268557be203c67ba74711000728a44dfa0f4326a313869ff93bace3541ab5de8a8a67fe55e0f08e929341eaecfcb3c92f24abde35c0c01157f3921852782abaaaa289aa4e37477a4335db0393ceb1117322ed3e2cd66dea266cb74d5f0f29eb8c7c5927a1b9db7a90a5c874ad33735dec793587a5a9ba1b12d9d2fd338b0ca43d89190f134afaf14c3c2291eb748ce397afa1aff8208537701322ae1706afefc732399d281d0f6f5c39309db84cb74bb709dc137ce0be5fb632da7bff435d643890fe2c5bcda03fe5c90edec5fa15e3eb92a187e41fe18a3bcc09c1c05924132c2c2742bafead8019accb657ccdcb6058285a796961f922cc9b247cd3a8a2990a28718336d4ea05ef3eb33b6d8e91575b9e099f93bc47ff74fe2595c5399e50551987b28de5d4087ec3692fd82dbbf2da9c4abcc790b62f25c357661e871139850500248f5645d8be353487ec527977705e06ac97c7b1d0bbbf7eb1e25617c7265581f06c6e18f774cfdba02315b7c49a0fbc260c7188786300a873a5f8e2789aaf58fd2d08f042027404162b12e55e19b68f40f2835f866007763e5a7d212c22412089b057e5f04c31ef82f93113406e72408c1627e3b4e53c5b6783b1c7be7a7678796f2b0b1200530d00eaccb9b0ebac072df2facbb048e038f6f4d34f1ca57710361fb116ab568713538be6e99e9d04d95425c2987980ddb6daa225751f975c1824914fe06614c3410aa74bd3e8c3f9671e5c106e7cb7ed4d18cea2d5a90e6aeb48a29967a2b05bb5c443f4ea7669cd632648fcbcd302325c243013da854a1d3b24ca0fe89043555398078b9d92afd829cd9309cbb2f4a0ddb32de842376e0f5909056f24c6ea2a2080dafc89dd29dc608efcc4c421a2a0d9e21b3932ef910287abd8f71e97244686cf3a05b6d2b986eab9d23f0aa1c6b41b3fc67ba6f29f26e60462c03a814621ee474d171f98e8c8936006e8ea3971291652978dca0a719e15ae72221207a5b1dc89586a7d933316667e920c7e560db9bc27b1af71e79419d85aa7d8d15884d197d688965d2c5e658257c3672d4d1de4f95231b3597d132bc0291c79ab65829295796106fbd1297086ebb565d186aba99327ab6dffdc3754c6e286e25d6510672c160e8607b2eecc943fa0d1c8090071b942e9cc2e2107607cb94077ee23ad96460a2aaae247c623a11008e00dc38e5a67619fff43045e496b41ece7113463c36dcc2aa57c5754cbaeabc610415c8b2615c8d5956a76a858bdc0aae1dbd4c7c171c2ae2229adf8daf66933238c1cff0efd760b4bb6ea38c7c5eb552f38200ee18e47b78150a83af0c1d79a1fbf5789c1a18476f794a4879fcd3911f568f2808a657f8dbac76941e8116417072e8fa812be1a83212b98c80c134ee8ef7db55d5bbb2a32de835c54291abf4b2ad946393bc3a51d0ad6d4a8171eee182e441184089a9c5e3e98613c29da8d72e7c038086d15febc552b0dde249061761113f76ef7497cf34206f56406c7931dce7b22abce6eeaee927390c9ca5cd2ed73b67634c401471b22f80a32d3db1168dc6a7695165e403b4e3406da0139487a0f0338066a2ecb1e22cdbd86e6755647dbbbf77f71ea1e6c9f01499482d015db36a12bd197445b6ac648bf2f701fc5656b6ac5f88b1ddbb047a9ff5dc60afbefebff32997d1ae8e5f512f2e4259ed51149974fce23ea67b292a85da6474380102d344d6c3d167cf8851a745b132edcfb3fc914737404d76c472c72d12e2f1bd559e57105a186f46cf2a29057514da5ab6c078f2bec85bcb2dd85f76e3df0b86ac903509bff15e2c53a902128c40a76c4bf20f77a0c56885914f5e2b58cbfcfcf8d0f153df2f62ef3139f68ab5926512e851ad698a2938079ff0307839396abde519638c6150636f852ac7eb9c90611e27522f613e4bbe6573bb5f651dd1e5b6e72a3356d8d61433adaf735d339a89097dca0a614831db0a4fd62412d3ce4a7278705b928e201459561aa83efe6f1a1c3456927b45ea12cfb511224f8c3a30a77f4166b9abc7c42a19fdaf2c59525ec714763d1eff239911016ae54de9c6d13dbbc3d28e63452cefe0cca5c0ea3e5d849e30993873eb5a3a13d25797e77c537d6d6a42591b6c5be302827f343b967d17a595737ab904d7a8eebbe5286b6ef7003b6e49fcbf5182e3c7aabca03c98f1f9b78c2388001ecb4f083f48563d7ee8cab32330da884cc2e1d72cafec0383072ef1319bed80267a32a81182ab5b77ba37b9bf5c90c4666ca068b4b979a4e5fa08addd87201355cb2e6d648b9ac19dbb15a02c1ff0fe013247d843b52d15dfc88fa13578dfc4ff294af9a0b6ca7f02e57663a14afdcecd2fa9e1bdfe89997bb355f55005ea6565ddb84d8057a12a6bd88fb4481055f0cb0f43c4820bb2a4c6aa0f0e68f391c946da5aae331bca3ba707d4c5db063b213b5213128ce75f377d736f644a4b1584532f19235ee52333b32150c064d2e90cbc66d0a69dc4cdf745dcf66bb84d0c72156fe6c024b4047929f478a4088db783189d310b1e840035fe7109b2ddd7ced84707de10b09305a05b251f0589edb48ad6057ac0b6c49292073cd555ef4fb899fa0e997534b78368848a29c56335993afb4673051e5f010ff8de50962c78e456403b029f5e41ac030422315bf22cfa3a8ed440760184fee135d63841480b683d96df5dec547227e02f71772159fd9c5de771b40b0494ed0b8278153f0e0f4f62911817aa27ca63a5acfa552c408e52aacc6a432e1c7294ae04316186e9f9e800a7c96efd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
