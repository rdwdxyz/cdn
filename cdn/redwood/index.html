<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9cded6c0e67f3f34e41fdd066e5a03dde8e405fd06c5c4ee060e55a38964def2525ed9548650ea7c5c85cd532cf67976b7ba3558d6ba7d4184a91117a90722fd557cdea85816f228975dc77cfd916123c8cb57318d88fa452903b412b24f30bb9c710f12a292f2aea2fa99e79e5624eebb41d812a24e97557cf0dcdc276ffe7ebe0571dc180675720289bea90998cb9c096c37921a141ddc3baba62597980a1cb9f372667d9f7ad136faaee386dfd1c3ad5c2c4a25a3e2909d22b5b35f9280c9c21601e71200a6623b6119360a6c59b06c78a349cc13121a294a6fc51c098369edcbb44db5f01a4720e44c45c39798cf639b9b8a1332ed383766bf0c107e21c1456fdb1814cdb0b7283529775d0336ae30864d2cb8d9e62540f4f768dbec62d7bcc47d92a60b85a88bc27935c447ce5cacb375d96369d0c16993ddd3994808dd4739a31d8d03897d6ed30f218119de21a1d8f3d35412243091a05cb326ace9221efda87da096d6fc3083bc6308b98f815b417c8a271bc657cb154f07ba5ae943cd4996e61c06a1f6383ca6b94e0540011e1fe606bfb9f3ac877ab5dacfd6816e90c7a877436403bfe7d11341eccf4a806296332903a6e5d856d534880f530bfc10e53e23661aaffed86d71a35d6b441d6e9f2e835a4547eb9b8c3be458345f5c16976b36cd5119767b009119a89c907660f8234b3ed6b0062e2632b47446f9a0d266dae7c54040523a41b19f39e6bc2cdbb07dd1a1d85606440d719edb8f70d7fab074fd78d582dc44e06507e236612bc1a02d6966ef6280a93ced0ba31efd80afc39ba2218d105d55fe87054e3321fad6f39628cc3dd140eda3ea3586830bcdd15447e8bbe0f7bcefee38d57340d098cdb022e57cfc8d7258b24c3ee86dfe9c27e997973152cc23e6fce6ad2b35e71ee5f020e18d616bcdac53a73809231d7097f80d9064413af481be07b876e98d05dbe1066a938f5adfa403b0200a9ae83372b9ecc07bf6c3b76c131ef936b46b61c25b1758c6a409becc6190ae0796bc55c69952d21cb0e678f41cd78403a39149e3c817ff4e515afe15ece43b9d64dc7d8dc2ef9a898fd4821159af548f5553218160a1e9f809b1cff246c4cc70c97fcf3bae64e21ead883449560008287ec363be54d003dc8c3458cec20c904d1c891cd1f44badfb01f15ec333a60658f0d4d998054bef73b923c694a6c3def196bae45e2abb9cff030c12137f164139a3a54b780424b4533aafc844b47c20bb4ce38b370fe7d2bc162f71e55576985fc76d0f4f5315ab16611befec233d7206b9c19ca8b09404023ae40df3a799728eaa3b83e5ea72ddee450b5589302115c2f0c2c1b94bcce1b752de08a65bffa0a70064048dc0ee172376837046039da82eee24c57331ba86a46ff8d9b9cf3afedfd5e0249fb61dd5f8f19b8ed473012f9aa657e544a25139cbb1b1cd2626fdccd4f09e5a757134df069ee4513a898a2d1e16e4bcff8b6c4dba36f05eeb28e8e39aa54f2ba537e9b3568a73aab8b57ca5ef4ad95053db619aab8e47298f7ead1e3ec2e63a3fc0d32ee7495387269253b04e14a4727c13aa5ca65b999b074c5ddb15cfcaae30c8866a7145523f4f6bcf3681f57d11f1470782677466720e0570aec23309d8eaaf37608ea55d891cbd084545d16b3ae8056512ee6c62a8af3bee26d010121a0554ccd8dc14df09996bfd39c6412aca3224ad4e74d27fa60d5dec594e764cc02cdba3b5f4433484c23c8cfcbe2f5be6c8462fa5280226f22660a606f557387c18a1d8f709e4111f945e47e9761861e37d74210031f91f8fb6800a89024520d8122f35ef044581e1b2b59fa41f6c8de08dd6393cc307cac375306a58d55adabc793d5630fcfbecdeb82bce3549543ad93c649aea178c7cb22b644799ed16bbdf1654d0fbcfe573491a4dadd6d5d598225a2564d7314bc7c492d5b19ed592a83c0bf0b202327c4be4386ba9860ea58fbe5158bf8af1a42727b8ddd1cec66181187703462a3658886b36616cecdc1d13991ffcfa7ecb6c80973acbcb22ec64ec9e4bb153f1490fc87375e23d9c46a74e43feb5282828212e592f61c1226236f53547aabdd88d794dbb1019746282e902350631dd83999d19405c1ea831ee7c4db5d81304ed838a830b63ae1219ae60af312feae3210ae278961aec633c85062323a4f347c7e87c3dbd2d8eb9aaf89e768c3b8e88813ae5ea641925e2d7826c1cdaffc0b1a8a6f466dfa21198b161fcd3536b6a7a47536d16853b6a1500da3e9b84df097d3feb3d5142913f0167468ddd01f817d48d4df6e7f8a465f4d1246ce574d19560da2c517b4fc4dd0906c5a59e538d37391d1a14c1d801115bab0e75a8591b92ae090aedf1c916e580d5705aefc95d081b154de930e704026684758386a275f99961ea76691f2b4f1dabad715d4cf04a2d86a7d8970289036a84918d63e1b24641bfb4e3ba1d045702aeb096d401419fa78d889f52c5284c39fae40b95cdf6f7edfb88b22a296a6b0238b71f392862f90cd7b721454febff536e44fd41a12e2939251ad86a2a3acb09a9b0e8f1d2285aa6e49527e3c55125d1d220dab801bd86eed57841e374b76baad0c0c721bd4308396abdbf68b3e442600cdebec04f9265151ea8f437527692df1f7467490e1d2bc381664a85ed069137811485c7650f1ae14ee0d27835f5b9f3e9316cf251cd9ae63af957233453a51915e8434a352487afd5747103a95a4acb58ca544c3296cc60dc909c52f4b7bb637222bae62ad7c611abc6c53dda333e84b658da5b11d9b11faa0d06193bd15418d5290f52240cd1fd0b135c16275d1b6da715a979febc8b67f9788456d801909821ba5e1c2396d62994a7da9cda05a8edfcfdc02842ea7d4c8f4b23fcff73ee968d166201f228f4be35a28e728007bc4e49ab7111f3007b4d46389a45951b99a28fa2d040c5354c79bfe5808f36bc9e29ba8187883ad7d8bc586a71c642846a0c0581af1c076fe942567ceb19fc4e4fbd1d4a4a711d53fbe942379f31f988a5aa9ae3195f7cae7dab7e44db7489f840589b8c054d719c14b204a7765cf396003d5dfa54fbd47fec293d51851a1045fb00fcc3441cf3138deff9ac91c066aabd3cbf725ef184c2d42c3144d088ab80e209347bfa481288596c5227e40b2c9a3ff8530c4fefb90f03f278286e39cef0754748e31c2ce278ded9277591e1a5db8c06955920dbace634c7d8106e8f87ed2846e4e19a5c27e1e8d56af45d9a1ea3f738ef1817bd378b0a17fe668ddbc0bf69980f6bc48aa3364e330139ebe821f53829197d578505b53e8ea93f2ef30fced9561a6ed4df0f1b2afa318de30a7303a6360696ec34d44b3c4d68e6ad90b3e89cc904156d37cd84483cdbdc88b89fa13e4566dfa3f2c024ac38077034beda45c1000c56ef79654e342a9c8c752ff403163ce319af577ca8b98f51c25b717b12292e906f1b729fb39c47e8b8fb6070d9a4bd8d5454115f476d9c30544d440ee69369b22ed4ea06bf7298894253ec6132951cc931488591e8384ec1258d4d3fde33eff03b3506337eb0e348904c0ea98d5da6df026dea1b38db7f11ebf0b128416936b6cff703d9b72091f77e865ee61afaed72c05b6c64bfc6dacb1a9a74c535d598b9c2c7a901ed9651456ed4d81c36b9c9c5e93edbd186ad5c20e3dd22dead2b85bab45da273a50ab43075f1a2f7d2c197f9e8b600f8be1f1b81f65d6648859f4f2d4146f106362b14ddbc5a9f83559cdd7eae0f12553c582eea1979c02bc1370093621499de0526c808a2265ed7f2b35f1d773a184d48e4abc24371a5324dcbd02cd7594211e753df52f629ee9b5414ef257c87b09bbac98f6fe61ad0ea6614a0790ecd9a4f2587e1880140e405deab15ff0052a017d8d52ec478527a69ea361bcba1c2b5a48d2b02ceecc42d75401d5213a2ba8d3ff7f4afa7686d4c63a689fd84db7de9cbb2f6e37891efd1327725be8719bd30f6223639a6e6ff03f2f8dded5b58ce5616f5e092c3c4375c22fc9d07bcfa8752ac9da4083599876ba3b37bae7b4c82c2e9c73452c260db35707f547ad05335c482c03f57f06d6474ebf5680f058464dc3e345fe8332a0eff71b92725e645b942e2f40026ff2eb46b10e6f61fae017c841a5774fbc5ee980b84589ebe65ce250b4d545ccb8bb8015b6c2e8b0ed4bbd1f9e5070d113427703fa74e5925085ced8b213f43e084f561e9c4a4c56015eba9880bb77b7919e0bb2db1ef62278108e94f2c9f2b9443bc13f7fcd97af0b8aba8c69100ce0e142fccf687949fb6080e85c2fecae3519abd111bf75e8cd6f55f38e8060bc5c1f80fac6a9262d3453f43981b7c3a5aaac0d239569913d17866866aaeb423219a052543bb3ff55fe27617c96b88a4cffa11b7aaef0b040f9d4d12b3bdeab50cce924ec7ae89028aa0f7b841ae96c6d7c650b6fe8f435c45fb13f3d2d6c0b81eb7597bc7970a795c08514cda8041fc82ea67ab96add95f79dceb0d84e7a37a72cf892c53d219a4abb0f7ec2b9199dd6332988a6d194c20c7e3dc24e0341875ddf7c407d0b0974b0edcf412392a665b6f319c69509e87e03c0a28e054dd5b9dd23716c137006b19cdfe68d86d0faf3bae329af8d619f1803324c5c07b960b9253028766f750954909292f6173be032745f4d59043ba7ec1b48d314e2261e627c88d202d699b47bc0517cac53d746c0feaad815d154fcd28828ddd42e7f0969ccd487c147763c617a26d30a1b8caa2f8772173712f0e4469c908028d070318a5116d5466526f1a586e2b3f3543f56162d8af63f5e9a702ce48d0074e81f7447fe56a9e0419cd2e99b00bcd5ac1929b9ce2266b15521040d5ac9836652fbb1f487ca5dc0050009cd434b3f079d225b6321bf74d78c9169fdba6d2620889e58f9df62f18e8928429c6dcb21e6365326b89b020de10f0881a2129b9e7f38a56aeb25e13ad5a595b42b6febee44a273ece11c03c993c47ff405ed8aab83ae1425f40a38084f4bdd7912b8971fb02596e3a9ca5c4bb0ae930094c8eab460db6f8e85596ee267f4d401e13ddffedddf09311b01e53256e50d7a29e505ec5ec8ff6161e26914e07aa0fe021a8a0dbee9349057e4345703bbd1b859ecca05bcd64bb405cd32b06529892f4d555d3e6ca8e935c4125905d07ba5536d7dfb98fb47a58ba42e7d49b59024bb96bc16eaa8d470aae00acebfde3e8febef4c13ef242a11ec6982f62f828735e807132e46e8f501078993871df1a4d030b74611d2cd6bc2bf8e2b0da73bfcb8a0226543d76be4a68fd848dcbf16cec7ba92dcc4a98352d73e52f894f3823014b54608c16f2751a6b257f9ddd2585e81542cb547c73d28546edaf7991a5609256389edf0566cfc377397eb23d4a35f1ea150b80f7800f64334c0784231104d2a05a23f24975531666087eabbeee9a55adf91b8445090120aecff9c83d822f67cc6be9b0a96f54e736bc47adb7067dc11004eca75b8ec04c4a56b5bb7be940838fc30431ba3c07246599f6475b3c030b1ecb76a3f49d83e7e11f2c2de74dec87f05ef65a05aac56379a96cc156c9c3dc1016b2780c3939620aa7e0b6e698256bafc5553a2fa1ddd514a7b2bc259d56a4c81727ac8fd86c11c5ef0040bd8ec04b33bd82154984cab016fca0a97c6497462a62edd27a807fa19be20461102d5d93e631fa5ceade014530b17603e6fa8c7fc124853529816b6b2caf84d6a5ce085639b09cc5255fcb00b56975fdee91ab1271dbe6a9588f1ed85ff6a442c6cc1879cb1ca8f382359b51be8b5bf15794c7416ba9f3acb2dc443dcacac101f0244119e11d973d24352a6281724b12faf804588c8317935060a7ca39173786eba6c3a5b72a8c9c376c504b1828143b4d0792dfbdf47012f4c679d653d6ef73119fb25a6be58ab23d94461de2552a67ea515f534a6d966f3cc5f5c9136a82f8194f0ac6ac1b651133e0885ac785db182ce91d6a18896367a4346b134223c05f4204077d7503c8209d48944c75e6d8c6b6d1bbfd89371089eb4eea1c5a8864602682a974438754b93e911fc5f40cf110bb5158c0fa7825bda028e6722e10e5667ee0178f53155a868c74d52972d479ffecb6366cd56319ca4ba526ab0eab059021225ec58b8af9a6fbf3533227b6cb40b3cbe4b1da9f9017f8efcf32cbd6e7b21b5be262f0aa7a0c728d117d150f532cbb6578480ca407363837d5c5f5868d55a4f486946f0182ab9540778de0592b1884416d95536dcb47ce770bfcd6f0f4df4b536be95e479e7b28ff5e2b83c777ede0dc6309e1f45c4c7a32bf68d2067a943a4bf3dac0209324db9f7081fb6b5ff0957d3fa7f45d63fe2a4a24570c2c0f5a3c9eb0b032743ee144ab7f4b20ed1941242203000d43ef739c4dfb9ac2b28f0b3252479afc9479eb8f41c8182d63e124f0f9ca69edd67e578b7aa0b9cba2c4e8088ae3bac77f39363b02151a1fd4bfc5561a484347c9b1cbb59a3c0c112a798d055f9344e14d42c571137ea3db1eca7069aca3c4bd2dbf802efa75ca365191419a0f79842920b274fed413c3e3a02f89d542a4feb553bd3a9b9770e59118a5bfd6595d52bc70fc6957a3df7b75592a1127f1fbb6d5adaf270377721776fae8fdf2d138b8d92af319c671cc0b10d792b95d186e4e63bd7f95dbc82593706a2e344cceed233cd174c22578b3c1ddde6526fe91979401fb4a0e9e978038c32de64317547657720e26579719dd6e1612e2182c0d529a729e292015959c73d398675150df58d35fb5e0b34408337b8845575fa2627314f9f53a012e756fc8528b900a500a0dd9e7be3cf93fc1a298323ad419a764d31c862e07ceba07486b38cceb9382d4fc3283993a858740668d1cb8013058a21e58820a40bffe1afb0557395db7c023015c8cdd9a7815e5bbb916b0c8b4b646e6db93a8d1fb25f1a337bfdbc8e4a2e729f4fe3fd644957863303c3425ff5857cd9e666577dd1b3323d6ab4c566cb23024640457c40ee524baa2628edaf212d2f868821cf4a4698ed0769b4ee58bf9da66a9e0eefb600a14e88155cbb55ecbff6d59ad1f268e0dca1f87ef154bd35a6233bbc7789b0396c5d87359699624544634919fa8296a2959985bb2be9713c07319dced8920d3dc7aa11aab0623cb7d2c52a9bde308b55b191f53181bd90b19856aff81469ea8924e98cebbe87acc8520fba501d0126bd4f8082b43c701c579fa222333c28441aa5b83a728e493a92a3ce434d70ea8827f4cfc9397f5ce1a53e6e5c483259e760ac5f08806267b704506d6a9e758a478398e8a45a90b89ae9247a482f723f51731ceebfa835eebe772135d5dd3d01d717134f6950bb5aef0b33cca3ed12a475a2d6cc8db8926c59af2b813029bec443fa5f694a05f649d7769ac42061716e1d45dffbf8990e2a3bda21b278ffffbbdbed0686a6dd6fe91ec29d3fa9003311eca8dc75be373b5451f52b26deb28fde4204450c4a7fb43fa00613fc1075434c6b07d779bd3e413074c0b362ced5c10613c90f9fb9656a7dffbccf4af4991b7dca3082b052a4feaa353be208f7b0d7340e46127f566dfeb9ec31d290a2d793f84dd65ba4b6abc0aa6e075ba3fde5dbbab281c6c9fcc971fdcddc8de63c8004091bdbeb23c1967c0db03f2342970a766f0fb098edea8bae6a84eb5bd5ea16b5ce5ad64fbeb63b06d8836659c8988ea885463cf611742f1a6680fc1f73b569db90c4a1a210f7beee7b187d0e882d4a63f0bab2460f909992e7cafa25949b593d84bac2aaba3256a54513968ac9e7dbf624f8118fb862ad5800958d84eab4e929db8bc586eadc7a065ae59acf7642026654018b43d1a7de026994b70d6bd7c42332ed4bbc1f132716e96cc9fd58f4c476a8aa997b9a926399a5658d987da0ed53399ec766ad75179c72a2e94088e94c6894e26fad658aaaa98835efc81a61f00567117f880f5ada498b0b17348400b7cf3ce16a4f652285b9c96e1699285286446c60d98898b7701aa0984410d9f5844e17c6d4522630dced2fcf93a031b076a3d3d1012d491938772b5b23a8751bf548f590dcb91a682f40d2f6b1905ab6085bad221b3419b6685106b7cd122f4aeb2377aef194ed131eb1d232173a30863fe07ee9a3253ead208b2b056f1f0cf4c3846b9a3d90946576f9eee8fb3183acec723ffd5884eb5a8dd26d5b084cd1bc6697adb2e22b83bd52f3db72417a14be133f3b3b27ed074275f166612e85d02b1d8750108f6309efeaaea6bab7fde43df6761bf8e0166aefa825cc13e75bf95338b5bea984a03b9f890af4a106e4235a0cc5576064cb2f22be3bd35c65ed89f916bde00b5a8760e8bacba2fa4143329263c4586c57f5a859434ef781fb0f73c126775f3c935b04174567a1b6810b6c303a4c0f04f9786a2350f8bc5e005545f22172a0769bb9d883c9803c8d2fd8b1f03de37518dbf9e7e079c2dadc5c4a3128f2881762c0eedbdf99cdfeacba538d2df99e8c6133fb7dfff6bd09f8cbb3d1283657b64deebfccd33f557f4482ac873ac600649de9add67e57cac20eac14d7325efc68b35ca044631123bcbfaae84856c96e7a70f4cb5b776db7515d79958462ae07dc987618d33dfc842e8bc8a05c513d4fb7b67a44b56bb12e0390f092288e0d371f6a7dbdd74b8e88b9b2327f4f5ff0db12761070bb17fc34646b55f7e33dc9791d01cc34e8aa4f3a56a2163ed68bb072346b83e2b9d7806c37b44290071134da53263340dad01e9dc7996e76d6915416ea862319faae258fd71119523f962cc54aaa552f7e84f068666896806d7f700e3eae60a70b1d876c7721ae0ae6ef183fb5e60d45559e97fcb70aa720f99180c042980b6ed74cc3c0ed9ba5598d35f18546a6b87e8288768206462416fa7f94e914ad08b091d21ff1683d10d1d2da809c87a271a20dacb9e07bf8b79fc465d284dd1db0bd2286e74d93c440a431129920e014e0ac3ced291f90cb752b7c47cff48ca116458b23b1702f282ac800281713e1ca717bf49e36bc0a3eed24fdcf7b922b3962af285b8df123b592fd7886193f9664b6386a1b9d7b402715b96bce94f683454cda3459e7d41352f6b1ab30a4f7ae7b1757f508c0978d8bea72fb101703d1c4c517c86d552e82dae569ca5a06d846157832e2d7385ae7e82bc46d4104a56d30df2646a8a7882e046780fbba1a5714fcab4ab995581b740b94d3e6b6b6494a26bd7428ba21f411aa74b1d6df59b68b8885407e67a10b4fd54ba3c58f4110499097bf0106ab27b4271c063a265853659ba41ef29b09b75a61b4c10e80d656d4d8598a8cb6b2cabfbf543edea52f00d385eefe692c3528586a589fd4847ce407104839a5509b2dfc47f69a7ff8f13f03a28777b0f0738b4e218b4364ac267e6992407564785ce7974b11e7b1b9440ea1b41c091708eaa0f6d094b89f276732c5a0d849a21c1a7fe95f2d63554ea4f6d22d96b4a3039e5efd4f22b6c34cbc0afb5c7be8cee6d0288b9160df1508330927cfe2e431f81a0b1c83e902a3e7551fbe3ba24a0c166acf04c6eab9fcd46e0f6daa2d0e880c4a180b67e3ec380e34592216273d3f3b95763e061d7bbcfd1100fdad3c12a477a999e4d62d9a5b6ef8558607074c97751919f6aad3aed0af968e84f87efce84d451eea7f35a2e71c4f1c7ef527e93e6747b7df0259a3696dc56f39de79c8644a3322608ef95e30fae0a5fd0bf7a96b1e6fb234f262f382efaf3925020257261c37e5653ba3312fd83f45aadb005257afe8016c6c885e6dd645edc91c6fad162f1b4f83b622ab79d9325d474887560ec68ee9527758e604f189f7c8eadf219af0bae60b7254aa00aaa5e17680551b73e04e29ac1d78f7c1e34edb2f5a278b373c6316f35b6352d8087b5d05c9e0412644505bfa5e6cab56d6fdfb06d3dda5418d3dfe5b1469e8338dd313d1d40853f3b7969821717888861e81e2872f8a3dc300d4d64e922a2b40e468290c58068c38b20d623133ea9a0bf31b53ca76cc53e82c8ab12e1c6e6235835b70d60d16b9023b8afe83aeb82aad0243f190cd2f3ad9804e9988c49f2b04f3d4be138303789b709be069b977d90afb069dd3f0f5e328a7eb46f27cce385360db2bfd97d3443d5110823d42e970ff534eca219ddb433bd3e35575efcbe366b48ee9ab3bd54ec976ff9d0e094514aed511f21f8578930cf780e5514bbfc5a4b50a00d34922b03a6b70429038b16399a1c113bb41a79abb93bb57a772ce837adee9cdcdb055c202ad358258e9072b5d2ef9de3ed4f4b8bb63acc48954c23d0dceb042022fd84e54df8188b491152b817ab078054259ed24fb52ceb85a1ddb5e75eba2684a628a89007692ffbc3124a9fb5a025c86f7a8df798a1aead9417e446a693389fc6719e3fc68d53cc050057edc662f18efd275c3268bd76482a513f7e4ecadb814003c0138bad1fc1baa78ebbd4e38e75763ade54e6389e2f93c80628c33c84cdb21a0c750b06a57f5e5ed1d623a6c6bacd8cf2c021b66a3ec14ed77e78e541c38ce7a3b37abd0463da183e784d00ec12ae2cff5c4e589700d25961ddf0a71796852541c547b28afdcf69c16e7e76433116c5083ddda6b16e083496a538fc42410c1c3e3f34b583c432d7f17f8e9a12238899032a7de57d29f4b2fd5a4211dd0c1779447bcab8f3e2243502c4372ba1ff76321b992163a7c9022e94138b1296e1012e76ce63acbac1da66dd935f39294259c9d7012371450e0f6b120f969f69aa49b71a635cfc03b29c80cda6d0e42913ee6c32c76fb241873dbb082beb8f99de5637409f3cbc8ccc6214b218d048a7cfc216477373ef23d0afb26f45e9bbab8137bd69bcf3b35843b16df17076e90f55164d2c4c3664c5734352f4dc4969e38eb35a7710cb48b9e05f57cfa55db82fa28fcc8871c069f479b63173c5a85bcacece7ca51b08e0192d6b2a21f1ecf709e569ebe4bb148066a4467f9d7707c95a9e6740ca98533a568ae143813bbf369cbeabc989551df8e1fb20895a65c5ad038fba84fd16d30b3818a220fba8e15211adff6f06b71f4d9da55a276ce69706147e82c6adf011def164169aabb5a5790a5b32fd2ab2dbe54969102704bb3f6e648438f41b20d70bc3bdf1b2fe08de61a750577103214140c5253a5ab2df3b7fdafcb16c600d43df657c2d908e1a16a2b8dfdcdcdaf98c58b5c1f25cf2dbc3e9f7267fd2c37e3e43330b2500419448092a6919ae602ad173f57566094ee94f5b2f97da67b7de33500dbfef7f0ad032a8229c19d7420ff79ed4f72eb2bb0713a48e19c0b484d854ee38b426a0dad4f6fa9b3d4777aa241f18fcf8802193ea499332fb0dc883b4bcf57c97d15f60c69b8e45d310f36b43221356d3d405a5b6411c992ad1c4057d12ba890467f5ee144c7f73d16554cfff39b9d904c7bba9f86cea51694e89891d6b29290d0204b87d3c366a04c90fc3e273f29bed8048227596ddd8964e4166a2272f5d3a4519d35e4c6ad4b3585707ad4ebcd52485024b730ccad99aee54b7d1e45d1a60a4cef7b9e243b70f7a80b86470ad843056f9dbe1fd13682561b6aaee6c0ab89d37a4c04df932469d52a9a2c5be0d02622288c049856191ed6391115bce894bbee940c6464c5d3b79fc0ca01e778252c7bde126f2cf7e01dbee8980cf4e3457a249c7f82d759428cb2d475b14c79fcd1da545400b59a53096ee5c480189c8844396b64e67e3900790550e6259742134797c695b7baa1344563118924e02cddddb129d1b71585e57840c9c74579c2567ed7b499918f16df9a5ff06190765af9f57e3fabf76646d98e6bb6b0bfe88b2988f0ae3d6008bfff4afa45e4cd43db447d72dce01f2c4452e291567bef688603306ece3bc0913a4d3b3634946d6c46b532313fe16c953334323d38edb9e35e39ec955be50ae678778bcc42c47d192e61d64d3a40ae82c5b169e2df378dc6abf8eb7c6097eef7fc8f8ff7274201687cbe3c877a6dc91a87cb706467a60462fc53be9d7c50e50f5b74155474f425865b0ca10c1b2a50d70335b1bb59163b2b05bc0aa9889b3ed2918dd01bb15a01cf37ada87bc04218ac8d58fe63085d77bf5122fffa96bb4bfc844fd5181e4becf8e74b3ec4df36c25d01022b125c617a25c8a75235495c4ba4902d74d780af084bc06ad28d20dbe5cc73b1c503e428cfbccdf56860732d5d3975336da85473f2d0b371740a099ddc1749d8dbf16a23eb4a507e8c3fb6433c1ebcbbfc2e7af0e9e6fd7c28dc84bd248ee2f595b4e964486c2918aed381bb36bc9f036a1868b1ea2df4c9362a0721fa67534df3fb14ec87bec40258cfbc0be47f09f18651195ea6c12341f2461631b4dd010180a3aca94dac181d3c68b3fda2d8141345388329392e16efa87e88cc87db98b480fc7a17d4b815ae60db7c5279e45384ccd4cc27ef9ca86f9fd0c10b7008fa4f58a1bfa3303c502a3e11f3fbb57177f23d2bb2ca8eed0ac124e466a189422a5c2ce39b619be3bc1b9b5c086e766d1c4e6584eb54c4090a2ec02d13beeb2e0498d85849cbd6a43a923ab4e1837b6c3e19c5ab47718ddeb77b4ba2e13792d006132d101d3f210bd15a6cb18edcc75edc34306c63b25c11adaeeee3d82c4967522f25569146c5e92f9c5199030b588ddc87756a5304743683de744331d8ee8ce9cec68a603e9b25422ae446a3e9f464ce2ff42881f511b373596b9ba792b4b9c40d2b164ffc68faa1337566838fbef26e3005382a6f89662cd2725be30e0a5812135f55725eea512af6f194704f3c1a93ac333d5e84b9b307760f72691f354990c3d1be2a35e928d32a96b383c5a803581048ebf218f1c2ed449fc69750c20f613737bdcf60eb9ed2f698aa62ae627eb00f0247122f4321e10e51ebb83c11451b63c2db3ff8cdd737e8c2abdd77dde8aa6444cb5a4c634203648243083152c87f8736af67113744c0fbf1c2d58b1d0409d40fdf114ff7802009477ea59e6ece41907b11a64ff9ffd5f0ab8d25a6da178371200c213021e5476b70368053a6b858ce9a9321782ce5f0ce080b8e0e655d29160da8fa093acd4cfbd63b9eedc7da5cdc9bffa38dda9cc1ef66eeac8f13258c65840e703ed5f5cef9f8c5c79f7b62f3a24f8a86a356fae67bca435c6f8168189a842895b5d49fafcac67838b4c226f551ed2e64016898bf3207e23d080e6d1f88d0d55257a1031bbd55bd415f35494e01696be39c60831582fffc81b646d5d8e064236f7fc1e9bc3113a364afa00296ed50c0abba2dac5853c105dcadef98802f313bdcf25246e485954b76fcd0029d2731cb554f6582fc2a9d1288cde27717e4bdf9831f54b8aa4dbba4baa11cfec886ac06b732c07a8dad480a84f384aceb83faf07d0b9c51ce990822e54ab7d95a74ba4adfb842ced2a16b4d20ec2cef58451f3dac5481aaf20e3bdc31a342e0d549dc4a440199581d6c624446fa388ff64ef7f9408292aea8cb211cda20e01a1443a18f159bbcc6425a0d6d5dfbb6448e58c6e51e70efc1a375dfe761e5dc0851de4b33a5bad82a8a5a178c55f1c3cc300dd085e3ccf030a3c5463e11e37b619ac8cfa05b1e66addade134a89192359563031e4fe57c96302a5355b2f15fd2ce5baf2efd208c7623e83011d978778adb4f9cb75d0e13d94f6ba4a30b0326b7b266c4c9cf12e0d43ecf1691a999ead249ca6b9b4c58bea4525428fd56a7ba48385149e3ffd632ab5ddb402cf3d2220015b929ae87e250ce6cdde2f489c0e7d6913f23ab2fa20af764c55b32a04ff62e014102322c4151ee2f0f67af17491ae4132010a746ed68cc4e6f004d423fa7e10bcc310dfe26c79dc8a12bc0d75f561750acdb4755b0ae08319c4fb8b493787b43b2ea799b27c195b85fdf161d9b8c8f4582a9a0c09c195519e0ee167e48738e2b4dad66001d661d23d3d63827043ed82098446051f63b1fbd04f9912053d34efccb287eea6a7e8b730d1e1e2b6c3857d9fcad1afa6a066855c03e2cc67099d06f4d934ca71eb48905d354c9d15a3a4995fa5d56656d1d5172cbd7494b995dc1991bc89277fe9b7c859dcfcd0c6e49e4ad16a94ba5fc057154b2e058946064c6327d7fa4f92fead37899da89bea9fee5f4d99624de9322ff24458382e53dceeec722a74a507d81530dc2ce4948e584813d3e82af150482b2408d8d8d1f958680ecce843c66a91eaa5da7f65e24b89540a7ab0d6c740f18ef74794901f27db2599dda57bcecbfee65cec955e47b2aa48170803895af105a977df523c577d93bace645d74feca308d2e6b32983c0181833d8de9c69f9641be21cf573590a43d156151887d14323dac0756d8f71582be74d8843f80dd6c2d91929f2a8c1df978ba6b0c1c6021c1828146bf64df11585aa82cceafe579bf57a2e92b1acac9101f01166fa90aeb884b7b16ceba6861f689aa81e91ab0e5208f301357268980ea7ddbf26391edddf8682a7403689d2f24c32ade7ae63f553388943766e87e1eae29ccc2b2ab94151f8cd4ae700d8f8e723e4b3bd160682c1f8a63e2fa6dad7a2cb5496ca7308fb9cf39231eb0cdd26ba1028b3ed635bc652a163f75630935ef4ed9ff492ddabf780801cfb086bab42d60c6f11d4a660803b778ce4cda79133bf02141e5d319939acff5755d8606154582e81f2c019eb9662febb49d24c87ef58682431c951b040cb10626f874ed8ec89ad7ae13949bd31ea4753f278636c5d8af8278906291a42f424248b116ae23960ef44d6b864a3c73ed61f71d54311a499429a7fe25a99617c92e485721a8e1fb207b419c5ebe822f39fe2d3ab46e617be3576cd250e2fda243da6955b620362a048f900c8a5896d292e0395614c61900ed98488142a224b1dc8fb05e6d09e333e07134711f49c06e46b5df41314821e6b7c02b67d10e1b422661a1e26ca52fbb4d24c93c3a10f73f44288a47cc5ea2c51968c8560aee9c683a61aff628ce3bfb70e3e9dd4835d2fc4f387f7cafedd67c13733ee88139c9f7982bd780f493abc787becfd325feebe5dd9d1955bd135b9cb227eec20f8adafcde589b609de861e02a62f23a76ab6dd393c25554ed83f14702667f494bcb2315acca87ff3f14afbb527c0304ecb9a87054a0ae9c4141aea5dd478e5ea97ad799c1c8b67744f7dfaa38cd147e5c71e4fa4f314b67c35bb1c9e95e5b45276f12d7ae549dbfeffe4e216aae064c2e8578084d1dc636778716d615da35ea55e148883f4244521a84706ab50382a89cbd873471ea4071f569db0d0f84e0d52a1300f76375e2a753baf642ed4dffbc1bc872aeb297d55a5eadd98098f6beb969739d16c52b245cf64bd88a5bdcff54808f3b901b27494f3dcc4127a5f20ff598f61c6bfab1c276693b2e81d5721686ca42143c87ab77a85bf16bd3ada48b8ceabab9c5dff5650437274f84711765c275cf013c741537c7052fe9124df563b5b790ed9e370d81afe704c9a27caef358d9ba72d2634c1636c59aa1329b66418812a43ebe5eda1a84654c9674e7ad81b63a2ee79a89bf82bfbb63e82a2fc390359e43d00219dd86a13ce052bb2210bba8c11084fbec3ea58ceb42e1e9478bfc6d7a7b3ae13d74077fd9ce9e6e836287b6446900c8bc85ac8c7aa409208d3b22612e40411cb991bdade0ed8e3d1d9b43867455bec47695b61d2d4778087cfc0e6daac6c6840921077d989c7d46c44e6b98c02f5e8ed29e3b73391b3699c4bac77ecb92f966c2a3067abd0c9b7b377da69fa2e7d2e1e30e172ce06058c50d97f2089187f7183242629fefe4a6a6e43fe98255c0538c592156fc8459a0705d38ebbff8eaca458b4aed37fa919dbcb878b5382ae5b95f588295aabaf1b12f2b1dca59b1e7a930da7941b4641207bff8550d71c86a055e28684766996d3d0c20a4a785b40e9a31050146534b7c2ce7dcf96e1efa0818ab309b4d3839f9d2c501b84e3a4450ce75070c0247db98c2874f5156d75970512ed6b0bd73417f2b4816d3293f3ca169d91d7d706f6005d16e6c647b4b32b738a31bea8ed24f71aa30f11600ac3d03c105cd4d69e19302a921f6291c246f2b9a8810a9bb9d656b269f9fb35f9981a2f2520a385386f1ff9ffeeb0b70d0de61478e525097787c4c01bd98fe9b46c04dc8c7a1afe255bfe4a3d3dda16a6c51ab8daa31e3c67cca630190e510a494f61f98f2934f4005d7b74c1bf61354ec3ebc13880c426929068d3dd2432894ab022bfe8a37bc1dce51701ea6b692a4c74b1bc425e1479f592cdaaecb5e9f0fffb3e1629a76e8fee3a165831671bc143fef1e8b9e896ab026cfb71e505c113009192775d07eafb6f1c4c3bf564e8a7a1a81ced7ac501200b9fbf92c687210444fefb255f37705425b09fbe3b753bfa8e5bb56c0212ee419faac0d4c2cf7489e2d007af3b55669ecca5e5be8b26eae0739b4d647555b1943ee35632328276d2c46ab3dc8b77b7b8bebab619fd02e994365c07eb70d9a7b7d89cebbe26526f249e254d6688ccc0d68acd4b5399833d27c0e91d83d1278ea7c772f79b2e3c13358c866af8a72f5514bced1cebc1e89ac63ff8ea2383bf0ecf4b495f363cf0b6a949ff0b9dfc6575621f70138bded57eeda3b0985356f954aaca45d6a98d663b0dadea7f89c1740abfee59828b12a2c4786644aa34f108985bc5942ffef244e4df421105f7786cd51b64496f5a10e16521186b83b59f240236bdaa385b53a3902eb386b678505e9040593c27627f59f0a33bf3a582178d5928c33dceb72a7a43075e3fccdaaaa82b21cebed26cdbdc49b590f0e5324f61f13fb3b0a5fbaeed7037a78ff93d9853cf9f29b8e84b16ff222325e737d9149ec9014059ff6f6dc4f50f9958e4e8dfb692c2d30e27eeb1267543f8c0401c69c1e4c497521b60f429bc4703a529b2b4f9d03db3b148da95315790f5091ea6775a615b9f032ab7768614e029bf81dfb50c093e2aae73bbe3293987e5a54ac8f653cbf6869ee02c09291b308ae3eb17a5149bc81760b5859103e393f46bd902a9579134ed8e503ffad505b6a9e492b9ff51de34876f61e66195431c77fc51f0add520db3747c729787bb262ee5c53dfc677691cce84acccc04e28833eb2cb3b24612ae77a1089a9ae0b5f909a8723b2773e87f9bd244ff1f8c36790b7a88d40518c10e3c55527df909f6904b6a8b0a132660adacda4ed5e574a5aa988c2ce699414e79442f40c2b4ea2dac72dbe721abe277d8f34f45c45183412bf914366867d782b607c80e85c0863b275877d0bb5a65d73762f4c1a109762cb72b5991b555ebd89d089e1963e745f6b95d1a7a76ce482a6b5aaf560d0fa681aa79e587179b4a659657bb79e9001aa655eab2f38337a99adbe9a734ae329e24744c8e7e994ad2a36b2aed11aad811a8f9d757a754c57aee6a7d48213d03d964ffd46fd7e6c1995642b8845cd79e6f59f5992c6dbc0b30a49a9d0b7d40481172270774da602b5c00dba929ead1a1f1ebe9b509d133d30a2af563ae4a24d12aed565bb5ffb7f86f6792cc8b79aa19eabb90f1f3644db5fdfeab08db3c18b89b51894a5f4b3d188956fb006e08811c9dd467c714820b56ed1137f3dbc7459049048874b7f29e3e830803d08e53574bd27810bebcc6b5ca7b9929b3ea9d4fe0f3457cfb30c64d1f1cb378f7cdc6206d638fe0a013048ae88629d8636930eb25ae59270377c2c72f8ca0dba90f69e83acc55388e748f981f6f5ef9f36bc0c12c82e415cdaf9690fe0537645283bb2efb4b2bd67bbcbb8fcd355bfa116422ded48dc866afd36b24dbe545736967e572e964951ffb1650f05f7575feebede9c3842e0692fd9cfc8cf78e8be1fb61244e15ede8fa012363339c44192206b3ff7be1f11522a0093ff13798e6d0b02979f6d828410d7d9e5fcb12c07fb00551a0f9de539f69bca469beb6a74355ea54a83270c577df9c5113c32abc45e8567a41333446564a88947c784611d0779d464081d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
