<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ba644bf0ce795cc46796544a911044aececb14a9c3a64ad8a3dc4c89cb4c79512e80d884eada741e99d0e7146cba57e180ba9279307e7c3d2172aef7087bb7a4e5a8cb7ae42b6c063dbb2d46e77fda0ac5ee64bcad3d9c1514c1381ff72c792b299c9351112e19d105aedc9f30e33327c17f509547fcac7e36d7b4cda4004ed289eee68eda887ae622768bc78294b57d5b9811ac9d0ec0cd16b87072d9a38da9abb4492e91cd132ebb690742cceee8e31295cca9e9eb75083960b2de7f72306ee955eb3f383e3599d5a31c774f8df98968814f9521aa9a58210e53c461a0d315cfa15b106a46971a47805849dba99ae7d103911859def923654579e1d56202c9d4094f77040ae53637ae84b055f1bc91d5aaf05ec943faa3297cf285fb72494f1261988012c8f0a13e135d3ebf3017fbb36ac5bce53a59b0633b2c472e3b5cc5ba83b2e78e26d398cfda3714c16f766be5a8169744c80ae7470328ecba68087caed7042faa389b5a89858ec36eea0ecc7e2e2df30b534dc99cb47bc942ef5c238c5f903856cf1c53db282d352948f80c6e0710572b1a4ef790f07323a5ba0986e5331efbb74c3bacac071dab21055afdf681873496e5e08f490f4efe88cea132bbe955dd762640d4e253f06f009517e76bc76cf28ef84131a4f76f89ef4e3a1ba89277b49a30f9513a99be1cf75937a2907ce102d10df6925b50551bee238d9961d813382dec47e5cbe69752fbfbf26542eb3feb015ece568947ad4474dc3f636b7f1f10a2e2eb4103b96ae56d4e880344b4f77620fb74c785288bcf747debe983ae14cf6e0ca2409bcb1645f27a250ac6eead9fcdb55921ab6b9bcecdddd7472534168e44402346279e9e328d64e464f99649a6eae174652b8832d702854509f534674ddd6c30dcbaedf326e0e75774febaa73a04f10cb1ecbe1db9d10a552c82a8d634b2b59a1fae875727c6e2e0c9fc236ea8e4a01e6a450869f46299550e975fcc312793110022baf6b214eb0aed51564c2a1ef1a899eb19217721c2d00515f2a112403e53ceefae8f81e458c39f6110dadd43b3288a2b05c0bb63bfb7452f55985653c643809d9799c25cb03951b8516c4cc7e046d16ae976a8cb9d98e2695a0c39b3cb44470d5b45a689a940aae80d55d816fb0d738e4e5dcaa2e797c21d81b2574e5f4ed1dbb1d3bf2e7ea44dbde9998b28dbd34d33cfbcf0539c7ff3a13cd8a19aaff061a6cda948c3d39daad7010c708fcb5d9bd808cc6d7036f8c4f8f9543e9dae5add3c7d5dc0085ac3e4c02a388ce2b6325db21d555be53ff9bfa9e3bb2541419345ec52fbeef9c49c9c24ee47ca647dfa7857e8614be392e3b038d9128fe826a71e40331694ccf41ce24dc25b4cc81ca80413ee307f88745d5296c6f7f3b978fcd0fafb829be09640f381dc11f54700d206c160190fcca27b9add75f52001bba39d5b2eb8e1c1f55a5f8162e98f532a67fafa2b7b41f5c708eb06b43b59b3bd7a38f8ab1ada9a433b81fc8bb6652abb18783020add3a003962cf1e5d59db23aef5a396c17a8c9fa1eaacaba5ad290d4ab584d06f93566b08f34ae0fbab15e0bad0bcbb123b1059afa49f60072a557539ac732ec065d6e62e391d6b7f0fa325f8de7fe5ffb03f2e9efd83b06f5a8a85a0097b85f6cd022c303cfb80e9c1fbc655405c90ec234093707ee9732063216ae40e377e825f4a5561dbded4145ead7bdfeb8a4e7162d23d07c9df8a5873b6ee1201331b5fd74613285ceaf38e80c13185678155b667f32b94b6259939a1b17ccbc1074f2b0493923f0d46fefc6285a08832bd578eeaf1a2e2c445e15d0675869ba759a2c7feb09a51faad0bc8c14d0793de946f984e6507388b1f1bb7ac8bfd6fd1a4501c68f6ec218f2ff43779e8c75f953fefdb00a08bea23a84a2b9f5389198b38a7139c2053e8ecd2448d413e91b2b4e2181e701f489cd2f5d1834bc4efeaea406ee299a2e842858604bcbcf259b2701a5956ceb932f78d2423ee8f3adf06086f6969cac0e34be4c07380fb1b12ea4532e6e98c2bdadb5f7447479c2468c5fbfd96207c860eb6068a7de2c72c603afa601f232488e10577c32783b278353d31af0b65c57af9d7cdbd2a756d2de338ed1aea8649a32754f22b9268bb80d597acc241ef9c226ee82c55f5fd119bcc9220b8f5c36f21ebe274b9e6f139a25b6108b2af8fb280407bd3400c519848b21d8861c819e7e7e142548b86e475e063c6af04b9a248a39021e01956e6573377d10cae1987cd6c615ffbec4338fbad5c45f74b7627b81b9a7e21010b64a9cfa49f82ac07faa5851f3971a4b94a674c432544533a069f66711cc84cf22dd96b3cb0213d8e18e224ff614adae970913dd96507cc51778e7bc060e6dd29221c9b5683adfa6c48de33fb0b68f2321a2cddd902e083bc27ef15c118c61fe563b5e522cf9f38171e4d8878cb336ce7345f90a938121a94343175ff66f7aa7b743dde6e19565597a5cb10563997de98249a60aaac6a7e1ba05f21ee637b5197d97061ea154e04a072815d1c2bc09ebc7b85ce83430545513f0089fb2a116d2a6da50b1965deb8893d2bbe4090fc3ca8d62da27a7309258286f6c3070ca6d94cdfffb3fae1fda3ced70e388ce4f7a3dc0561f1e55dfc3daa0f64b672cfd0c253dff12bc1112d78ff0504e8a5dc82a3fea61b65d5d00cb1a00f5ef1993038345eba848ed37c4678aae371aefc1bceebea068c7e7f791b665d09e28ade653978a8694c1ec1a1f45eab661cec81f718031077b9b5a67fe34a6d1c751d78154a7bab1a88f011c2c6ec212c53811f0a2639b402f3bafefd5cba19f4a4f9a05cf362f24e4c0600b1a657d73015cecad9e44269b043f5eff4e4560e3f8383bdde98097c51baf25d668b9145c1b970b86e97f39feefd38027dcde5745decd6deaddb2e769d4ddd5f103f5fdcb4ea91930cc091495129d452801f1f6a0d995067e09d22b944009a410d0a8a32144b1d73d4e2d248966030ad9a4968305cfa763d4ed49395997c9764dccb9b828b7ec658e2dd2bceae1bc2346238c8107710973b6a1a70232894af2b80227d3492e093da13847cdbcceba244bc04486478d05043983e98585b22349e13e684b26287cc54296c359527ba4b0661c6ddce439d7bef516bac477f205e140ee2dab4b194963e32953fbf4c200043b402daccd8dbd34801d5440d34bb57d6743372128da5299ef1dc4df1c7abb2f350247b7df7352ece15684a2c9dbc16d8f5d7a4f09bfa7b2126af23c728a059eeba1031f737a31dfbe1dcb0b488099f9c92d8c4879cfe88ba41275590674a20431a26be9b629f1e03731a85e5682e248184c1247dddc633ffd0ea41262fd58068da0f32eb41bd433f4ce2d455a4f8184bb356462b68dabf70c9568c89f8794c43a4a8c1f3c2a725050e20ba5f62aedca070de705dab5cf600ee619ccf216311899e1bedfa87a0caa5d31daa3a260871084f02c5ec2d34abd58b0e01d72b645980cec49b592063cda642062c4d4b2264eaf3a307eedbef959146bfce6764b38ff5f7c4a92ce230e47ebe8276384b048006b4affea49347013edc6aabe0c92a1a080dcd8765937a95552b133164c80b771fc24712ef79395b248a2d898b8ab070e7644d60b8b0142a94b6df5cff79e5aa275cfd7541acb228751fd66966a707fe17c76e48f0e41ffda82de3b6e605f82b5a9b5f5058cbb06ce74b58626fa846cc8bbe0ee3a7ce2ff69baf8d323af21b90030c811b8e4a21427c4a9eb80095b604a5aa36b72664cd66cf3469dc493530648d105ae0f2732d68a1f6adb74fac862ba3985f4ae427b2190fa36f995ed9dee5371cd73b109ac275a0ba3dc554baa0c25f8a5c0b68e740d6422d9804b81f875a47ceaf0184e9cdd9f024e8ebd27b8817a255dd5edc462741957b7d03774ef655e6068fedf1fcd44591802d18498dbc461d273f2bb3c3b6c8d56bea29d1ecfd8baf5339b0ad7dacfc97896e9af09f253ce5d012cdb3516ee876ce1109dcc7af432dedc46b7658b0ed0b18d7f9753aebf3898fab7b1c3cb444dda43c81ce07e6bf3af636a6bd2ca9c3335b69c7868a32d22be5c8697436c6687923409fdca3d5c6062131fcc70a0d80f8ea9306ccacc0195058b37e22f5096fed470f215232535f8a11e7ca5bd97dde2d8400112ddff73fee6f21377295e4a22416042239f79599457589ee918fd2470ea28aa828d58962b62245c9fc2ab2c73549e8031868fd2351d1454c8954a7a97ecb335337218af98bc12fcd73a32ab11c286db2da6e3768a1a24ad2553ff2dbe3aeb6208384ac8d9539b50144e837c758d2e48b5bc3f85be1207812d53981c652231ba7b5ac298ddb0932a3f54fe3c0813e190708ac9b35b5bc58650050421d37a828e35c01ef16bf5727c2b3fbc5f2ea95ac10fd2b559ede5aad976529e4bd1249d89c7a4e8402ca848bd63af276ec50d8c432cb0ad51ca7396444ea85c557e0042885057110b3a69e174e04d6a94b26dfbf2b695691877dac5a75793a573dc59739f463c6bd5f2557d6e00ce2e198962a5c6abed94aea24f00b75f4f2283e22220f5b9ce1ef5011d446e009fd64a51fc855b0b2f24717c78eeebd0d5bfc5b6bc0eec91466a08fb62b60d13418dbfb9fdaee4ceb5698407e58b68b2e02b232895cb1d00e523d2def0404261f38c1178dc612f7d04896e7de23bb5104eee16cd5fc00b509b95002ca2dd1cd65ed2af8251f07c1e05b70c18efb3d9703b0c71651493140ab3daa1853fa40f67dd06db6c3da6213fd5a672f2cec3465d3f31b443fa09935ce54a30d6da4188433f54805d6d3c9ad91ee7f3045facbba4a1975de93469d08167635266819102b9fc6c0cec6462554af03bedb37acd8c5bf361ab3f1aeb55639f5f048d30c165070057c2987fc88a680df0a487030726c3b3697c5974831d547831820506fb2e78901c48525c0a1b50c378e1782c10aaad572258bf6f4920614eb9ca104e1a5774bc64f2c9fc26d4298b6c66a3edffb13234760d0e8096a792f439b496591ef57708c2f7470da91332581f9780a7b8ee9f11895535904b0a02bce884d1dd57ca8ac8f6e9c86c827a0f381e60da26fcab792a0e79374aa38a1536c18c2a526c50807eee369fa7843b740969c0c20325f38f3e43468afe9ff58db027de16cf9091ad74058aaa353ac7b85dd8a38346c4b91fd0d2b2f63f9bceda0419ac0c41492ab9ce4cc3246a8848e316c54fa9a9188c754d00d4e58499cebcf41589257c9fcbfc68472c3d4d7e3204a2d10c8a7d65775b22089fe48858352903765d488e419077b979d30fcd48363c8750f8af3e3e10fb8df472ccdf347eb074a6c8631b11ffd1950c6e65d7635e919e4b5aa06d0ca77b89d131255549ab8f51a07d2816eb960a56dde41c286d107cc478f7db3275cd689be23c4472c3f00bde35dd350f043952758892b2bd2fd1a899120311b455b784c60a587d1f120f639be1824682f3cd05041a87438fe45b701bdd38555344a7d59bb121ca9cdb0a4617c5fc5b8ef2137fbe768cff3c2678a706aead7c71eadf3044f8696d157d806dc7cccc490acb9f38def9991005f7734885c88759bbde371b20349ff962b9cc2aa74b25819f7af0e57dfc92f25b92a1f23b77e8520c8067391402e3a8e6bae1472c19efdbf748961bac3c341b86377067db1d72f1c7c8a8b9e3617ced2cbcdb15172f68dbe22154175d50d6d82816e9d505cdf34104d8b192a6a885c0ec2fce785e0647faae5bcda21cced52e1ef45eb55d4a1bc56de2bf7e831f7bcdac9fbcae246202e55fa27b8ffc1345ab7b5a580ccb8be00b625de9442aa13e4afaefba916747ccd75ec99c1e3bbab89a248a7a1e6794c89868f8df1763a21b9776643b18f978dd00dc0f7d7a0b24a391abc10460ebe84d9131869656fd814f07e16ea70a6f29706a460ea4f6bd0275a6b2cdbf788cfca15bf87d4cfcac501b1582ad3e738ca4923d28683713edd23ed43e04114a55195550a7d4fcf773f51bf6673a0fc62f4aa8cdc7116ca53f2246261f01129a2b6253bd1b4d7dde39b658c5f63f3bda1e04a34da4afb264b4d5a5e90c0bacb9692cdf528942780986813b2f2cb733928ce60d6af028fc2032cf918aa10efa131e8dc58869cbdd895731a60ace5b9dd9c6580e59c02d6ae09282c21fd9e5e20f911ea5cfeb5073037a490004c0ccc0bcc4890176f12c3caf8e7b010b5707e23d2b4e39d3dc8bd661799bf29b19368123b8bef9b5b823e9c96fdd8c09dff3a848e6645a5904022f3a08d487d57d646ec1ac7f9378d0a0e211608502c3b3f9c20908abc4fa40f9e30c1720ae5efe0d63a9128a64b7e62ee32117cfc250636714fb56ac37108312f67bc594f4256ba4c40bfe40ed5fc9017b1e1ff770bfa66140daa6502b2c1695e20caa3c573980ea6c1ffe3312ba9990feb28db3879d5e2ec7309aa73fb33d0af62cf61ff215e3480df475a86a5f9eae5bdf1ff46cf076959cd1873011f78e2f0b2e68a0cc56af2246aab1594f15a8ed9735ac2cd4f928986cadb15811cf0adce09511a80467d3b72ad109837be4d820a4722d6b19ae9439c4a6d11eb131a8511c764941d4fb1834352866f9baf98d866ea6fda8d83905e58731ab8c6baa85c580fe68163213bd681f2a3fa7dd502a0deaba1cd91aa5127af2d24da125119aad56ded8a0d0b55a79d73d976227dbf60b809555c47b8a73895848401b701eb1d9d669baaca194eaf9bb7822e7eaf9e512a8828ad54190c688a2a70eb34e2e4f66285030cd2bb2e0f649b5f196a44bc4bba3517e4f25a0b9955116c6d038e375e59845966db8988fe55607abb1a6abfbdc483fded20274faaede4e4e148583a3ac8e3018a586e87b43019dbbbfdaa4c78568b39142eee6173dd0d4ad7bdb0aa65598d970883be2b04b61d5c5eb6793b7929bb8ff16eb56532aa0d539f806f112e5af1fb81fa6e997fb7f7fa80f65a02bbf95ef9b6d23b84db51dd79c20c7f11e146b903a4e4f82f28c97548743b4f070cec6ff934c41f2419f86263f940ac0c0b76febfbce6ecdba98ede73d3c2267440015a2761a20f35c9f93fb1e499c42b35e351fc1583bbdf571703c7c3359d45d5e69ff19e435d8644731ce8cd61b14fe82eb7bfc8d3d6153a2433ada158de6cd2d286e74c4291356fa1d660b5b982f6611f97f6769f33e6d2644a11e56ed060022039df253db23691aaa12cab496144df27a300e4bdcf6a4e6a17d4c8c5519d9e19ea27899405f43a758a887d01206e04c2de044b9dc724d68a659c63a4a0a99c1b6bc5503a5a247211bb6aea2e469e1c9a0f5a7fd5f3764ac12037cceddf8c0bb29555ee327470171d35d5ed43e1b38059eb0301ce2047cc1ea2f59ec1d42c43db5d54391a8c10fe369652f489aa9c7808f8a71e5c635bef19b20412fc61f17616d292a182eac3363e99377d2aa6f957ae231819657ca572c72717e2a23c316f806d76e8adef02670e1a3c29faa12fb97069ee0668e23fd6e961098b00eececf4bb4e5b387c7a7e0956d4d1e20b9fa3bf43a93a0560381fa58a14dae6549cb1111210cd40d61b6c51bc2309f81f35997586e832996f07ae29555d4a7bf346692a2e5be937b7759eca3341b0bfdc11993e4daa9d0622ad3ba139b70dfd5cfdd91a7fa0a1759c7765aed9d2f4418ba1a62cbaa027d3424c88cf8a3880d3c1499c4ac4aa7a395cbd31d873ee6cd35992ff21fbeeaa1c8ffa576cf208cd50ccecaabac4853f25c1de82b00d23ce65dc519a730989f3ecda98a9d4e01e51ad90b49a1a32261d6ba9d33276b928d69e7cacb165baf4f02c1b1610f221e45baa829b3d129d3e7320da8e88d137b9a77a2f63156cb8dc4af10fa1e3b940c07648df23e14f2fbc072725076014be8bc626a9ac93c853b27d855cf34b5aa06a38db2ffa8613d84c0093595065e0ae8c9abb2d1f24cfcabb32b40c6bf5e857f397dda9e628d5eb233658d142903e14cd1ffed3df5800362a007d130497ec6712354c19620fe2373fa3b4f2da022504be0b0ab0dfb5e52b5d8ae38393bc10638147c4572a03ef919c1a9366232fd493aa8e4fa3d52948a18b8e943d53acd1ea8a7fa6de25a3d11ee48cc40d01862bc7051eecfabdcb5e832661bc96921cdf88f9c31325f25daa5507f461d6e7e69c218e6aba76288376765735db229d62848ad7a29ced3722d0daba3bdca32426b72e3cd6f8ec3cfc8770c8139155a2b4a138f7706be7fcf50d8b13287ee54d3d09437ced53c2c5b8eedce60f8549b0de89143cf70f554026a819df0c293ea39507f3797b3a376eaf0da89272ca3aa76e9df6debd1310be64330747770fac69a050278a12d150e6bc48b1235bc06c015ceb8e0bddc39b3af4bbff81ea5624c70b50db5afd166aeb6d2d031fa6d9b8a9f1a0fa059bf22fb4c0e855ef5f61b888c472528e6e2516e85a1339038d5909c75b923e2bff12cb0d12d412150e28c27964b96792790c2c3dacc7a89fb35f7c18f1f93d26551ae518ff9d939fe6f34727418105f511dc58b1eb8a0d0f1ab1357ddade7df152b570a10709f721e711a30ae04238ffa6d49f45cabb4689822500ade8117ac2661494642736d4f6799e25389d3fa1ff93b8dae3d1973ce534b8fcc4f885ad36d34728e8f34dfa994d9e15ca5918d90c9919cfe59ee6e12a76a3120ccb1c12cdbd5a2e0be4c5d9dffa722adcb32b4cf13ef83bc27687368985beb8c5ac30b61ef6a0facd6280d09558b48fa5cf976c5311751d6ccfad8b2a1f10c69397a7ad5c505432995b13faac554b92021cbea22f21cda41f94bb6a825a2c1203371b2c549bcbb4b2784dd9391e83bc5c1a3cdf7620d59e102cff7e81d431448200c347f07cd6c3a61053e60d62cad8d72f0d6ebdcd8389f489626e7c019aa57170cef20fecfa03e99eeb9b4791ba7593b115702bffcf339e3558888dd2c9b2d6d9d5654ffd3da7bb62c207e30151686295c05b7ee5f869104efa3bdfc854a6b2e47fb22ce154ba09ed139ed11a2a5a29a17a84277bc89cb29636ed0a60ad3bfc06f556d0762fabc6a6a8782534bb388822ceedc9038006e1bf266e220f44c09109c52d71e2f661a1a3c65ad62cef2d5d135dc39f66213a955df640faa32fd1e7dd8352bdb46be6045272d33c61f1a77962b477c56042f82d0045b798354c5996a484b061993902249fa5af83fb9557f6140c663712879970b4ee4ec490fad140ea5cf06fb97f27f96491b088f88de2919c9727e1ced5b2528f757f896cd490741c823a2153af0fd4ba8520644d68c6d97c506a2a2971b9fab9548855c85c87968239d54e1f8a62f1ece12654ccac82da021bf14000e9fb0bfaff36382961f2470d839cdce2b0b7d8b4dbede875b0ddbc0bcd0f91409fed79379fd5dcb08f6702c150085384ece2b2e16be6e6d1f059d06f352a8b8bfcd9e9f44e1aff3f07ee7ef4b463a1024445238f4ba514af7d5dbfef555f6ed9dfe80a0f12af9368128924228d04a3606dd91635dac516e27d6a1eb9057eedf031404241b303844fc31bd943e04755ac63308b0be1cde58110301d508f22b6584a8c90d8ecb2bd3fd7e388bdf4193131f6334915ec3340bb451611ed89314f02450c5a0f52517dfbf97c0af4dbf0f020a949c5edf53c3ead6a0937382c8544bfb7f18361a95601aed9b003aa71d76b5637fb343391014fb05768b32b22b6cf4bffdbc8eb0716a939affde2c6573d4de06e602f1f6b8e4d847f85bac4c46086feeb0c04310cdc5d0cf001f65b7c16b199f14911fd85185aa3c5b43774af6ea84119940066cf903d876c38a483a27a97c31905124490b4d839ebfd6d77e2b61f1ea593c0c1319b4827f203143275a2b93bb4d86e91b6b2d22c8d240abefd900ff5d0db75fddccadcdd016ff16de2f428e6d16753b6fc460dd78a721b0652d24cd378990f2fa724014b1bfe8fc37e9fff3c2e6bc6ee066e7d3d558d6a9031cc46c914cd8a842486253a12a51d240509bc19f4ba2e83bfec88acbb4e0d3183a33ed4aead482f27e5a7dbf79d2a4bb2433a2fcc3e0fcbdf43ad957abf345db10100e0bb1e44476f1c8640b9cb784cd7330f7d0cba56149110f603a2ec3204a25736dceb2fa0c997a259be86407b0c4345e0af3d6ba4aba01cca9b9d3ac50ace503f41da85cf8c525015cc44f6ff79272b4abc41e4bb1d30def14baa07f8d2858b75b399de3b0067bac00c99be58d1bc70f51ed19fad40adc502a811d46e06474c9218863c83b6a03c92dbf52073663911981b4f6706d3c2cf8154ff490854909bb3ee658a0f46172df1440dafa72e5fb88a65e1fe282d8df3662332ce947280676b51d82bbdefe6c5552d6cd179cd9869eee7ccb69930c352915f712d7cfd381b0e271e61261a1fd6871b1ca07b90a321a03882497e74d994b83e353e73d59f3c2f21ae017c55a7802bd1dd747e419bf5920ec0395833da88b4a577bf6a341c88b383c33edec62c2f892595c483831432426fd0af2d7ae783e2db8105fd3d4a233693285a6e746d78b5a245e8f8c79fff767372cb9607c9bb75729660d1c579db1d1906f95a511f1ab352ba4a27594c9485ac799566ac4bb22edd53228759670bc271de2d057d19605cac07f3c0050a0e1a50b033efcd0a8f51366942c7ee4aff364b5694026fc4a2265bc21f5c2e472555e7903ca7c66f813b9a2ed7ef1e9afbb31e7e79f607342cfe487f27f94dd81926290335c83f8fb84a633b3059d46b8d75ad7d0c990b55032abe5b75cbd004e4b72b36736d20ca3c8eb8b2b13b01c2673c71516c8c9f67d2c61d7cc977302a340f81e0614cbde9355cb83a8a639d15ebd7b18131dd6ab757f0b110d8ad06007ce2037075398154cab086bb6b1a509cbe53e59922f008d711675f5c97366d706fbb2d6bf8ab4d0fe50bfb4697c101444f4cfe99b8be2c70daf6c4fc867a08e6521e86aea8f5c39beffbacc783498ff6815962efdbcfc59c95ded352fa8a7efa9c63720b9906e2c1fd735c49c39eeb26df4cb1205013f2e43beea8fe5fe38cb54d56d279611e37ee2b8000c388f0276b2bc75526d2534e346d2ce8ee7679e77f04fb9b28795dc8180051de9699faf812fbe231170b9b4b25facc87070864a45b354591df6b64371887098fba0d8b3e6860c8e2c2d4f9e9cf308fbf1a1767eab829bffe9019d0a8d49be1438ce9f283a9947f32983778f19fbb1f3b93e27796742a1d3b3c491501ff135f42bdb65ca2182287871bb96027e2d60c323c4659b6635ebcf7272ca47399b32ce7acbe7456868f8356cd8070ed3ba2469b7404a8c6405e293b5658df2837942c534158324d19cd7f19fce0a27d889f3aa953b077fb38923001c077b0b9379ce56d1a187dc8f0fe39e1d4e8597d0f2aa97734df6c0447b8403db72140a876ca3f0940918ae80ee4f87e6baad9b419ae6d5cb20c610dd63f25445674023e60182c15c35f4bbe6051a5dde1ecbfce4f18c954fd7d0127080cbb3abdcdf90210c3e693c8702028fe26e16762ec2be63f162e5b02f50ae035318f147b7506a69e931af8ce5ba11fc66c709a90ce4906135094f6a149cda4b8de030f38357aca3c664888c8feeb933a2185e32f4f5c10fe30eb0baa3bbac28b78123d11b4ae6baab133d204bdcb30072f27334ee253f5299d5fd597b1cc30b207e31189cb61a5a0e911aa0fb29621bd13c9c07142a35c3ae9d5dafa035a306bc9f7d833933e2241309190e7c7fdf5102aa6af9fd7c4e3ad4cfc6aafc2af5d25896603f8e4477830314507cee8122ec6047cf51f1767d85f6b1dc1828f729ea0563b77ba6636f98c8e7084a20027e1d57bd42d814c5a8b7408a7c631c85a55332ed6ee6626e768dd3dc660ec94d32cb6a41beacaa28561974d999bdaa0f9558d596d5c981195da2a23b83ea82249c66136fa580acb677ed6df98abf811b9197ef807e1a38f823f2984a823e45b92373e62a3fbefc3ecfe8a77500c84ad5874a98796f629399800acc80ee81206756ad03c8d2b9fedf0b086b4c37619775954012706a2d74016722b0970f50a74995639dfda949bcb514e7ba45c35da106240362ef0040c669ea752e7a9153bcafa676b86fe35884a7e920035a97abd18f48f0e8bedb0b4b565467781b466a8cf914c1ea08479e6058447d5a42ce50c4015030d72236f1d5145c66092d7e1017ed9c276c603da5c259e5755a14b7d15276d8b616fcc4d4b6b053faef7d391e7759da411af274cbe1368405a79fb5aafe66801e34e8f2e648cc47a2a9367bafffe0800230508f081564f1bffe703980a438766119b39128d6d16e036c1e44e71d7a9801124d91b7a2d64dd5492c622dcb66538c2443ae3fd714dbd60d1ce6fe1e5d97734b7b5aa1e4e12252534f13271b7ea1184ebe92fa1b0ed283cb9a4d3bc129f25730efcd6f7c37fcc2180e53feffbd43873ce69fc3a7dd1aadfc34226b5c9f3937ef0e676934287371d39327f4aeb9a0f716e668317e9b3dcf5d87c76b46607acf55baf274397f05ee5e4329f6d4d56ea6d87fdd3b366cf1ec9bb5723453145b411692b9e910558c09aa927864d958a9e2d7d7797d454eabf0f72935a733590d8b48c8baeef5472b9c9faf85b8bd618c8443110d74b71b4d6e338d34b20911f6134cbb842487aaf11e0c183da92194ccaa6ad873facfe34c1b3f531957574f22d40bdde20da2359c3ae346f70f1cb6d0a88d4b42a19ce2c26b5a1b95774f63e5cef5ce57f01870c249954c71a9420794877afa35e4cf343672a20b292fef715cd5948fd043e3e5015a72a320abe4e426ac117abf272c400752e7c9a600e31111e07f7bd028149b5a15eeb269d5df6a3818189074512b00e9a70d9dc0524ee415ccd12307e41657321addcfbbacae81210a5524bcbc29d6e20dc360b844e0dc782d5c887fe82922fd4e0e872b68ed247549cd7e47f27e988ae33edc9367ed682548b70e25b435d9c3fcbfdace80234f200daf34b217a7cb83ac75d3e6ff370af2c2ad7b6b408ee48e50c90d944deafccc9a70e290a9db5cb95fe689e52889e0f0bd7d5a40ef2cdde5cdcc09a6a3fa31a899d2b941926a71346a34d5a4b41d2fdd1d8fb4792c60497e274866ddba09fb8831c05706931f5815d95b49bd81d72fa580d186b3f53f46e055ddd60a8634d8e1d57bdf4d08fbff81eba26652bf9e3224c546cbbe285450f981960ae045db70448a7f18e68197faf795cfb797ad67207840ac3521d098b52e089f5eb4e732927e831fd0ec62700c8d71a2e16fabfed7a34a7e5709a3102481d25685604efbf7e0abcac02ff4d17583e215919d76a85c042165deb24e775fc29600134164a8174817787334ffaba5ce759dd22442cb92b086d0ec80b493fda9a57f8862149fdb9cab718c04cfad9e216063f15a6573279ebae96cfb13ac2f40835e9887c8fbffd789415ccb032bf9e63b6c4ab4eb8f5f36e772a374d75d4253a44661b64791902c83c9916e1e55d72d361bc587ab340c0ed0dc905db1384752d955631432bc511f58a6fd989fdd7b0f74283405d8cbfb1ed7c51447bddcdfba7f849865bd53f34831e3253e17ae2acc2a749dc5df6021e2526464225cf5080dc67ddc9d31c0eeec4a50b8bf3e84dc7f93a25002befa0ba2cc24b1657bea3c7515bf161129f4de5b0f835ace25b080f7c74457328ba70372e865392fe260f948469958fac457384e62abbc9e6902badf0c2e9a890a8d236543e9218898b375ba252600d333b7c7f46a79db1b3d84e29aebf23ae17d54ce6e6b4959ff0fec2bc03f25c90fccf03d7a604a9183a112de5f4f1dbeac588074fb3be10b6b1c12d64f6138150ae2e559f174f971a846b068b323a180010f8b28e25edd5393f57bdefbbfe51f059014c0f2b1ef463ac2a634c63a327b42a768599a2a2b73e67e1c34e578b8adeaebaf7a5b0629af3eeb3e8042f5911b4de21df07b4ce231ee915beaa39cd453efc1d7809cdfe6c9281cb9971a3b06c6a7c4e16fcf718fd31470be0839d801b039ee36fe5d779350ff1b8edcbd5f4a248e516c3f1fb8ee0794204394b3da5f052f01fac79d5aaca16dd91c538df16c5e9aff68c691fe9232fce7ddd8129794f3951805501edd8d8915be3998df286b6fe27064046c75ec872093ed565b626bc0b0f5fc672c540cb8a96db96b2017fff557a1034abd73264a9bdac8e8cd0f73c3d40360de1ac7e735d609ee9cb929e1815f5d5a3105af296eba4cd14de9aadd0fad24ff6645707550d6b890a4aa462972799e270b151956557ec7f53bed31f5d46f1676d7aea00a0c26bf5c7dbe96e0dc821b1f9aacafcad5b82e528bd2c767fad85666c1e7f8252ae4b7f5e5fdff4960307a8315ff279bfc2907123a69bd9d3545e7adf3fc12ee328bf9bb995e0f68d2efacc1b758936bd9cfad40594154d6226bf58b30d4a3fd11032c300ad4545a8718221c81607a77344095b84e550143fbeafe33aa1e5bc94013d5ff156a58e9979b3000652bd6fb2605a942336e41394b7846ca22dd9396513c2bfab371a9b41221a66b212966f92ae15dae4b3cbb78c28f7a7609620bcba5852c43ee8217cadb4ed2821f1cbb6e2a27c34e3bc05e62c195053601c81fc7240511280c759ac9c3b484b41aff9886a3006fb97fc7778fdf21f154a0edef3eb8c90914651a134e7a1766a5cb265af90c29418da827a3384fbf650093d9219a61d4d17432f3edbe85b22aedc5aff7fbb6d06ddb3c9560bb9475ac7bbb4709972ab62779bbf98b72fc4ff096aabefd12467111cc0c25b1218ec48077418801a85016eeaee77061d9e47ee5c92ca893ac91587a66e57221f7b48f8785e57aeee4bd07be54d29eb7af758a1a00fbaf61d323ae53c65507cbec5e5cfc2c65dbe413f949c1413461017c7d429d7e9ea8567e62a3ae30f9e574989a3ff6e2d2bbe1fc4ed2202e960c58f9ef4c6cd13119db747470facf17f2d0eda504996bb717b7fc2d96454edc8825cc470ed71eb64fe0e243aa102c4f0eef8e20202f425b92889ae5e11757de73bd92814d03ea16cc28016325f6107a2f4deb8dbd31bcbd1c1c36392251243bfba0a8eceab09c6b86435508718262fbd6f9f07f0075996c7684d19cf1f9ca22ac57d17d05e00b164c9245e31010ca4e73ccc1a1138f9720ab75f0c02057b0dd12f72937703400538e60d3ed8e84d12d200844742251c29c3b4dac73eb275fe95bff15537d6f65d156f684599aeecc7d12a18a53c281c063a5409ab6eea43eb0985bb63a64b72025a57cf74637eca79f194bbff34f09957c20ccc97defb8238a623376ecdc294220ef769655761fb1c811907097995c6ecd67e8fe295137d8a83d236f9956a98bcb7292edd950d925e08b688998399d3cec73635169d3b42d85f56d02615782011ec83ab2193bf85e9403baf2b870923aec204732ba2bf27b26d1e7191dcf24b4a31ebe4e353d5f1d3841c1d505982eae76d9f527f72827a2764d9a316b3864bafe638bce951a9369c733e144487331c0686e720bbfd493e1574670d49948da3bdf775d13e0130a318f058183a92c477571479a5558a69c8a6089caab8214bc3e36e86bdd43923e8216d9c85ca5ead3d381657ade0daaa7cb754995cbb4a4729d20fa9b23ef0f790b1087566d8889b05c495422a7ad974124c8d0e2ef10cc43b363890509fb70f4cfdb926d11142ac5932f1fbac8b844bf335825afc0e2574766c3fb5c94549d246af8b91e1b87a3f7562ab394200a16a980b90cfd7105a983e09966b8c6478e1f91b222a0aa4c50a2f5154630b5f79cdc607762652b7226483a67130c570fb60c47e48c49fb7071c11d9366aa41cb0f5d6c2b0bee1a46fc3eb445ef89ed77db487e14230eb82ee073fda698f2a444324fd869c8a7df0169c6e45592bb65865aa8c4130673cf24a41fbe99cecd4f45ee298bbf0e430291185ff155b13586fdb7235751f3a4dcb7445c7f4682a991d442e170a522dd9331011c04b727e8c143af62c937904db1a1e07eb52323cd6e5fcb8d8be65c81891a82026e6fd377c232c01ebd7b0cda3138e5c1136bc5a0feb77b34868d932f9ed3b897b479017592afd776013a165c5dd57ac98187b5a1d9e772d9bb15395b610615b46b49c5b9af43bb4f5aa86e1c2c33fc434b240a97a30d4d139bace731b8fa776a02b714d0675d00ebd6670ceec36b957ed1fe1a35ccf171f7efefa02ad26af9298548dcaaaeb12482d0f63cf0a5d69f776d6ddeae98ac3205bfb191cbbee9206073c4ca5486ff3592a71cbfe611aebdc3e84d2a2f4b5cecfd80c48b8af15be7262e3c5d21a576a2b26336ab52f5bb048a6132d8349999af8ca83dee6e869888cb34396abb55eb024840c19b7cccbe7810fe29d07569c3d8bfd4d33f091eeca47c916870f8b04aba7ca4cc080a90f0b6316a61f82a799562ba4af779fcbd4373e286d1a9d98724e4bce6f30aeb14722938506df3d93fa04b14227f969ddb6829d79bbdfa8d8fb9ba07c3f3910b0783acecd105b297aca9a92a9f1c64e1055731a472989875c33c2f1addf388b9289f0dc8410fa7326142e800b39182a01761c397bc8211d989709cd2198b7a2434a2bc14e34a7e343b67f7d26d62f67ded324e324ac5b63719cdd9a4784c24607ab4ef31f7cd9e72397f2808a9218f1d379a401cd6b3cb7eef7281170b4f83c471f6068165ee2d635c449f065707b1770c019ec16dbe4fbeeec11110d374a13fbba79cca4349f1b2e1fe840ccf12703e06e7a89b916c261894f8f6364bbcb8c9b9dba044ae83c07a64aec9e37fff325b56894ed28fda1d7aea0e0ed54f5ad47641d9f40da4847357e551eb1c4cd57971d255d074f68f50cdd5745cb613af855cdae712e0106c07e9e459312c05c68a5df9e4b64e3555c20f4451bca89b02004b1b3569c85a4d2484c17bcebb6a2057a78521016bcf92ec7dfb9f11c01d8d7ded7457c1134a9e36765085fe4ace36a8c83ce697d3f898208ab8ef6bf7a9aa28fc3786997088f3e7b4582657b9c56417729a675081dd39d2d2a3b9d22ee2bcba8b5df0e4c1a1f440cf2955ec69d353530264619144032ff27e1c8c0186a9ce886155892ec8c0f3795e315ee927d0dad2f3ca90029a666468ef5be9bf57107a87d9b666f86b57f2dcaae43267e097b89741d1ed82f8de8ac0e77b14b77114716897af156ffdb0534cf9aaa729f16e394246ec562150854a99ffaca466119ab87fa4975d2f3a6c6045d497db3f8499735cfd8a6931ccd2237f7ef90446a69c6bdaf041d0f24283bb748d86fcc275ab744185d83c7ecb9bb3bab8363031f331a2ebd644d9220fb2e0f20a153696df2a4817612d18ad3c7d3b94318603495a66e54d70b495cd2253936beb15cbe7455269424401f2f99dd9d1635410372b78ae7558c3b82f134ac5f72d1f49afe80a21353062f05cc0ad10a794ec191692112a13f3e68a68ee8426a6c401165324b6bc11d5e349ce32cf8b8315d905f4958d523a654048ad7617a75f17410f737facbf5bb5883108c17fe474bb4ff52a70f5e7be53c811013b128100d330377fd5145dfcac4ed2064ccc344f9329c0d502b491b63c6f477b64e398c16b14e60bbee32b6a77c7e03b70f2908b7cc44432ac4f30facb5139c115b70482ee8d271caf631326b66abc25e9f7bb9928e52abff13436da40dbe9f2a47e2ba4bdcebbdbec097a740b9e0f307efc41988f228be165fb492ecbea202e8a00daedd063ec7a9642cccafaa208a119a79fe70f6ea9470a1cb079994ca9777a47503c1c91e55f9aa7caf935e004a2f21b7bab954327e3bed71dff304579a64de3e8c8295cce58317e39b762c9905617e01d59aea968be93df6f441a6f145c563bd0b8174949419d1c8cf6e882200df4268483eea1c404949d917e72a1562545faf8c29f296f21077e9969df59fdabcd929bf380cc3d7f70d7a3312aad4832daab7ad6779c0f0d8160d73b2e7045e9fceb737e22c3f2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
