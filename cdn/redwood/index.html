<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dd9a7ddc908550634258d4b6f306644beb69ee0fcf8295508456d2b506f1a3f7151b69e0b66329cac8fe1b1bc1971c117604becc8750c4c20e0987095cf0e35bbc55ff3a48a2fa571fd787793219dd96b7f1d3fbc2ba82d955a8c07ec8f0eee42a61c4f62abac2fa579f57cccd40259637f785d8866b8b96a32dd5d1b23bfb82ba5fe0d96168f24fbc93a9b741640260aa169ba5754b013e97c289c71a57d6be511dc54ce79717897aab1bc7d09f0a99825d4d2852da8b439156fe9b945799d87875d29a324236e53ba62f1487d67cbcb290719cda49c3c45c6fe05b168b32f20d70f6ef0653407a13dc04fb144d1487ec6d9885ff2350e98b7f9c04357fa95eea30f9208fc12ae697cff2a30f08a9ecade4ea9fe9641d8f91d962599138ffcce81c1a6001877817a20fd6f33e4574c80096fa74941da46f9cafb54f7f335879b7b7dcb4b3c9632d7bc557ba225f256ae5edf0fe012c2e6bafdf74ea3b91c025806f98793f5e3137d313033d25dfc5d58ea17d128fc8353f73c447a59a821eb94ac86b6ad289ed1392c02f2624e73fbf3449043f8547bfa4913db6437a99a3ede961cf755414740d5f113030d7c56effc9eba2dea1ea9569e52fac2909dc0d47c55bcb6ebc7f6b76d913c32102885f11cc862c154a86fe9fae349f8f3bd0e7327c6411873f6fbe6dc3a83dbcb19f7e99c20598cd8d264a41b2f8fbe0094a3e35e2a61748f1fc5144a964964069fa1fb6f452e994f97529700139a6d3701598318ecd2340672da7f0376c4f9b6313027d99ff23683c5ef1eade430eaac47ad7a5fdce7578e28e272dc5f0536e5fa72d2620bb2cf4c6f9d127f9bbb3f4179128e8a8413d87ec98ac4ea48fad945a7522e38f9f1f3f8dde35962a84fda517ec9ed5984ae1fa11a9f35a2618b2d439d31fe1ef6e6096edbf525b0f0a73e5b86fba27c3ee26cda63db29ad35573f5f65f96e3133b5b1b2894b23b97a2fca58236a3510621fbf5c00d8d615eeb9485f00d8be12fed80357329f9b0be0aeb082585740879f39c669823674afa79a213160add900d221cb341c5f41a79e157ed26e8fbdfe18e43ec5006e403bcc6b0e8d49de38dd9b246e78592e7c8cf2d47ae735d138f0a6c6ae79e1dd5767f2dbc8e0d113f2d3c4743327f2c7c78308a2aae0754b1cbe4e4fa314a4b7a94885a7c4fa1c481ec36f9a70cdeba8571420cedd64513d3278163f60dc5b4e58796135b9cdfc235860e25225eead0f7d0c362a8cb12d64ab8be63e693c576e73d31926a5a56e3ebe368ccec156eab8f4c79b2bc8ba3559fdd89e2aa4ab5b9d47650606bb15560eb90a3570ef66fd992ec313a6d2bd19fc3b106befd2393c05387da69b84d33d282673e7a2f130d95453e3b29680493546f928abce682321b7a79d116ee43acec1945f71d607d7c8f96fc52eb4a7cabf17706f34470a7d9827ee642ae6ce365c25eb59a7c392c2881e840afb81b734a6d9c2b656c993d7924226d1fcbbc7fee47bc7dc48f64b7752c9ef03186f84a0aa62f954045a169cd7a625cf38790d0f1adc863a10c36ef268c38d0cbd57e0487577cbf9c45412745cc9e12587c9eb5bb494e2bda57406d422b7a4eefe113742cf2f41696722d2652b74cd5a8cc7a1b61d222059be3a2a688b71b4fc5c58108e44f81e6dbc021a352e30b13f0ea5a3c0f93e1b6cfe640bda9cb61a5b354d82d95e71c9a45097de4aaa648b7c60962c08e962600c702797426933b9c4786b27022b04399baa245f8e91c255c8cb4fcb09764e167db02fa2f69dadec74bb18d7cd9eeb74e0c2b99e1738ad42619db4e8ed2bdcf4ebd4fc85ae09b5c08f0dbf200705e57b1b992602f2bec5edc56fd6bcea18ed1e9b65d11b1d947122ea997aca9b80db7c90860bd5dbcdc7a5b096dce941020689b84889400bf75977ef3222e4d3a1d5d543aa991e0875fb1d3890186a0d15038c49e9689dbbab69e2a4b3249d08a76584a21b4b34eb46d2db7ba7215f9545afd5bb29586f1b0680ef761c0f6a36774f7c1156e84d5d2f2760f4717a3e0034f8931b59918f6b7df807e815e9ad7796b07a528c1b5046ee05465f01850762b33f31a166ee8bd0343dc8788bb6f17adaac23bc44a97bf2c89fe8b739eb21fac2ac437e927f7cebe8b41ef1339108a5263c0c78da366c275a1a00a1bd8f939af3b546db83eb04a7c4b8b019abf47f1a76e8f76b39eac11876e54e1cd8de8d0ba56ac9af3dfa28085b7636e66e9ac5340566f9fbb3eaad740ad54581811e3034b9e36e1960778e268678566bd7dc5c12fec3a5c18130e828e0e4b12a567a8b8a6011cc29cd1e1f3d982e7d5b19ed919b0dcc0cc0ea4fc975e75ab6135ec49d198ee8fad38b9845353f7a74d0f8b2c2ce2b8bd3ba1e6ba72223db140b579e00f7e08ad21e6ca016d18c595bfc35a63a4c886ad3a1430513fa0291ef8f4dedaec0579d3c9db786118e56520c3fa45566110aa00895720dfb55460e1e90aa9306f926854104456ff41c54f5f0c55db532d8c2c9255c82790c6ca50ecaeca9b925b1053f892ef9f4ce9a9569c248d7102815c0ac7646a02328908f886b86386e62c12e39e2a1d8821c7fd1bfd42397ab40d24ee05b5d6a54f2ce1a63d7e62f7ac1935e9c8f194d6acef814f70d2e2b32ba0ce0292cd4c906a2768727f4ef3d1c83ca97091f92c61b81cf87bc0b8fa0cf3e593f932ce22f913c3ff8fe4765d155a7534edb3dcd9e149bdddb9ef314a415b4e06de3e4648eee7e88b05d1569049ca804a30a4e607a7614e2537c2ca7b691a4dfb221df6d326031885f46cd89119ef8edc41197783a28655761b1fd2fa1c33c39356c7e10746a697783b09fa6644b5955ea60d4c1df4f24c9f614995a96350fa301d04398025fdf167bb4fb5758d83ac10b670bca02ec3e2be4e5ec8caf849fc98b3fa66881d5fa03ab4ce7675f9344ab4e339c37a472a958c513566bc792d933538a750701848d1cb2b4231e9e76b4d5c4b5958f6c376cce07bfd229a8b8d5d1a22d1858b8ecd45ea4404d6e3d001195f064f057466448f7c987b3576dfb807bfa4b355ade0d98846a23ef7b4b7a725711beb36c41a0e0a20bab8299e8a23bbae338ab216724236b4d86e9146e3c6eba195c2dea6b2f484abb1a153623dc16f503d915a14020c49c40fcb87338323e21f2e9b9ddd234b3c856518e982e6e2b5966d5f7a25903273daed74b488c12c6196644e2c743fda2556c3a9bc2f8fbdc82d2007c9d382cd248cc9b705423dafd0a86323022ad6440618ff8c3d5454c17218913248ced11f34b0f0d07a5c8012b4bdea5230cf3821c69402a5df77cc803af3575aa1de9bada3b0669ea8a4115cf9c8d2718bfbae55199a06fe0d1d1641cdaddff5a97f78c540694d5685748d50b941c3d387931c3f7d52dc88bc772b5d0e1dc3ad28462563849f6e17c0ca563080c3f69ff6db2d6ef3a3f5489b10a090579436807fe4175374546be6d8240f6f9218f54b49fe48041053d6ee8bb8f4849589933684faa5a54cd319791f135543a48654d0dd097b4c591889c91d96efdcabbf19b17fb1082ce5597926ea8dc088e1255f7d174a9469f3ff9ec5f51cb8afa97a3b25d7d12654e000c9eb66762e8f54806526a8b3090fafb1885d144b3802b7dd46b560a7672b4215b062d985c2d2908e8c1f0b7145cdceca7174a39fa769d4fa72a8bdf1b79b599a56b3a8abaeb0d7732f4bc7831a228972bb644ea2f8b99c6a567c1a12db655a2488fc8cdbe3e0146c05f9465482e2bccc1640850339eaafc3f91af86fffb6c1a7abd19f6aae2f9741ffdffc51ebc3d051128b2fb734166babd45012303596f95205aaa4efe718c3bde8f27a9bb22c42c7b6661c3dffcd431640f3043275ee5635eddac86d2489bb4f46f45f2bf0d8162f3c34279eebe0f386d3e954ff4a14f192074491d9cf999eb274efd593f06b8916f803a8f52619d51dffcecf53ffb4b43d61dba9ca9e88a235e74975755402780e0467703a63764a0657d5f26a8f68e703b23d1268f6149c7d11dd3fb3e83484d2e488d6c34693f8d741cbdd157217bd2dfda53ff83189e8c6210524923bc3ad67d63bc22f1e274b6fe32efc9b098bf5a44d4c78395e21b53c1843a092f377df36149e0949776c14f61424f93061885152dcbad1aeeee6500dbbaeab407458630d036ac75fdeb0c111338086cc9264e4b33f48220d517a15254a1573c91e6e5cd8a7dbf58a28145d94589fc1ea64d7f46e5e41e4d7bd0725098afbbfb25fb71d5472afaaf0772eb51c2edc1e7dbdbc6dd751c0ecfe17cad35529da59f14fa6fc79891fd278a208fd73978a39bb87d0975281b019e3725c80ff03157880a3f229939455fb767dbb05eb5dfc3b47e7700297be9cb92a3f9dcc74f0f6bb4ef8754ac420babe29a1a19ed7413fccb84438b04e522ef34b4cb218ad19ce724f25f0d8939ee8359fa28b819510ddb8e31dcdbf7bbbad907b9ba673d33bd6b86210d737e4bed7a6243eb8563efceb5acb37b7ca7c0d6414bfdfd215541db5350b241851c6468cd2d7c4929d60f61449240a65d45e14a5e39aa70f54850aa88951b7e036399a60f759e308a63db86598a3e58dd4c62900245069a680a86326b015f2b1e519f68b0498a6387ed7b9ae7ac4a6758d2044973edc2d326f9fca5b8921eb9f1bf3fe8a1a32ed7b4c688015770121bb0bfc1ff0511935f6e28eef341103cef929af9e5396d02839c6dbc636958bedca77a8753c7c9f20bb67999b218d5417377244f8ca61cde1eca3bd04001bc42e1a79672bce705ec1f3582200ae0c0b922a1dd91ce5c765871498407d31b0a2ce4994dade1494a12700079622cc451ca589fbbcf62c4e3d6c77e6f6282e04f7d40a64b78cb750edf1c1efeeba224b2f9b6a33a11b3212d1f0379fd063fae7866c52ac24d52e9659b987cb950580ec801972f5e0add6005f13f6becb701e4b943ddb8d79f22def5e93ffcb8d07180129623d571391967b6bccdfdf3916e7599d21b37089d2e91e340206c2e94ac407a48988105434a7bb4bcbf709cc5fdc412d615c9e3c1d54856fa84237c7be3ab63dd2ab64f632e6d533f967a6df6f62f694d898bd4a92677cd3a0b63c87353ed65576c88a2c158d3c80fcd282969b9878696fd6eeea0d76b9955a61d3a804a568bd165469530ae242f698e563236be23662191f9286c60be663bf86c38370ddf45058c7f6b7b1bf62b713174f7cbd884c8d62a8e97c04cc1ae68f12fb4b7a0beaa104ad6c7b674388d237976fa15f0e1c9fb00f3f94fafc4ca7594143cd11ee7d57e731ac58177729240286cf019db82343cbcbbcaa93d882d57b581fb305c8debed7f1cab70410a15f5ba08435b62a425261a78dd9ddc8aee08dae0b9ead96091a2490a7a11c76dcbe9cce53fd25b5ec7ef5feb5e90507207fc6db9cbd75e50ab73050bc0421eb3e3eff916482e77b2ca0c3a9334cd250eb36426182b5b311762bc641f1b7e67573b4c5bc4eded4a1f7bba6659074dc71fd9d513ec42020a4a4e4950cc204b7bdb9c8d00b5a3122dea5f2ff5c5c260d90c1ac3a26345c56fef972a0a35b56ca403445ed790567b5d22cee47d01769f8ed36d68e26d799ce1ab33f3a668e929d6f12e14969c356442481a8819234173e5b3bb8aa94676c942458435f4d83211f09da52d03a484d75224b6fbcf42ed1a4009c3e1ef081fa90bf7ec440dd3918106b4a808bf125eca9009125a5f2467dbe7a68d88e6610f217bfc2f440fa762ef5b035f5535881015a8a0b9fefc3f40c374ca691c4995f2affc1374e3eb1b6948376f655f0175a7342cf5fc2fcd44471e47f0e8736245e4d245a1bcc1207f2453c9e558d5e93c1c47fe8781979018a378bc523ddefb2bf37c92d4361f554d2c45883a83c8e2c7b8032b93559e15797edaa4dc35d088a08508a8354dcb33e89b3ccdc904b0a745ad0a317e9698eb5374b86d27bf354c44545616046ac454457fd4c4d1938622bd9f6cf0ccc344db13e6ddce56b417b2d4427a16bd6aabec9903a2f2ef49f6a0ac8af4269384e71972eb90eb22b742af6c4e673bc7bd4fce952f5d56307d82d4b2adf401a1f31843644e414ffa3d5de43843d9bbbd70dbd3d5332c19c18871f8557e549f81e3791c9fef4b1f1e88ff2b50a4258ff8737dc8e3655aa9e9a58c0e30229fced3b11eead022803398a7604e0ce69e5810f3414070c4dd3221adc5e5980ceb68250413330cd7adfd46a954b2e052b5d4649ebfa4f8e587f5537bd04d6e5a823833387485bd86dde4758171bda09116036cca6b8c4258bbc82ec4049ebe395105225ea37e7b686ca08a0fdd777f51135ff1369869615199b8c157413181f660561c7579ebfd85ee11ba36f565e86d45e41f0fc50aa068f2df745fb2a8b34a4dd5a3a7f33810da3da01d34377e044adb44b8c5867b0412c29b828cf0aac872f0cd98df718b017e2cfd898d56d33deedfe78d6a451ad7b612534ccb13099ed5ec5c0c83d087d9cdcaf064c2720b4fc227d6e9b3731aacd17d110fec820844d1f5ef06c3f0be6bc98de536d586b62ddd066d035c8856f6af0d52d7cfa0eb96717a45998f36bee1b1e76afcabe1fc4382aa5c06173a93c15ed4c14392cd80cb713e118747c7d4b3ccd932a10f6ded30b8bf5c5c72b839ce520a2f9ec3b118cf001ed1e5d0204925d1a7503042c30d679fd77c42f7273ecb813083123bbf5d87465f4fc83ce71bbd1a47c655a78e269f7c41b053c63794531df7b2b2549f0e32993d836a54325b2b66e4663ec41efd74d786ddfc382d4825c00d2f2670b7a796097825dd518ef49e70b8c6441ca9251dff4efc22ad4ccce6abf850feffaa8119cc801ac4684afb7c70d5b1d6558406bd132375efa189afdd94d6c7612a8c4b494913369ffd34478672e79d5671cf2c137272a9acdd44ef7e7fa71f7fc0bf1cec2078b81811d47eb7da5851a623f5672f91a66f61fe1051e00f18d596b4d82803267bd300da4dc5bf586458e9c7050572ef4d882974a2d27b126952e8ef98112fc586c4dcf9b059fc1c8d5b264976e87dc69a8f106a43a74623fc339a6fb6fd9971bb05ac23ae7d0e0bfa6b585fecab5e119cb5985de976069ae2f97538f34130dbca82f0690e5cd3112adc8020d44df70b9281b95a6f31a585c8eb3a11fc38f66c77b2853b86065063bf838354ebaabecf6607109b4a9c8b53e5cd591f8d19ab7a3ecf1892f743e5df9cc4ef282eec696bf3e22b7edd7d480eec08073e8d686e633fb5f593adcb5d5aa0a283ab4b8d7ae67c47530c035d036740b7f1d99baac5234601e5d19da299f2e19198134bf3a1a55d1c4658beb541da6c3f34ce823efe5bdaae939d767f6a040da31c66c77b53f36dfb2985ad4889e23f6ae833350077ce11a13d0d6c002ffb92ee1b642ffa97a0206ec16a5eaf01b04d93e5adc5a2f5fb4da04d24c5b35d04d6c1cbaca5c9fb9705f499016a163d3bbc22d44bc4a88b5516b30d728834f91adf981087dae5aa6deb3af95f86183307c9c38a06932a3f4573186c475f141159c1ca07eb8f9e5ff7adf0d51dcc1baf12e92e090bee4b2c9b0d4bb261341ae342d2f5d570dbc383dbb139574ffae645d6f6042c6de32643a2c76e17abb1f3cd866560ac5ceaa2cbb6b55cb9592ce121e0bfe33661bb57f3c11bdfcb8b0d352324a290fc638f7b35fd89b1da132b0f56f6f45e67d157c3bcad786ec4624486cd61b4b14d1333e9f54a57de1ecdd072350ea677783574574fbd4f7847bfef03b1f2c5c3bcd66782fb76a9c2059e55c3caf495bfaf751b509186b88a7831d59cf6aaf398304d28f3ec75d80ffa59abe979d4dc47d82f66bb6d5718245bacd858374ffab6761d210085d66234cd4945899024ec535492db8ab389a6ed75bf15f5d94b7e2bb05e6f2295bb5d88d7647e7d1185888bc1fdf0b9d4e85b51a06abf45fcf698e407b8e5ad1a5ccfa3f675c945327a71cc91e1e74192aa466967a6def82e86220ef838053bd7fa14a72f323c6fb5171b74654a54acce41ab19673cec719bfd3f616b094c7b61537741164ad92590990fff026f95f59dd712a937becaea3093df8846caede4cd31461c6ac27f6823d4d71fa687baea9484049c03f0441780919fc18d39422c18f7f89eb09f657516221a5713ee2b33c68f06602d74329e8639a39170ba076cf1c0c5c782c77cf9291b081a7890df2892cb5ab2ebeb43585db6d72cd88f42f09547b3d38d68b2692d1b9e9b4acfdd72600ed5dad27d2295267d3e5f50d72ff7f87d2ccf1c43577f71eefec8bbe0a3412e3aa5c7e74adc0e55f08b961c1a5a508fbdb305b58c04f4076f94904ec09ec99b4a43431a2feee40a092fa9330d3fbd8c73aba5b79359582f42488f90e0827d0a414fd0b949a91d8485b3290e391b4bd62eec39d94fe0213f63c9d169b76bdaad4546c9f1bf876d7baad7e34997b6857c462fee6e1618bbe6fc3023d48d0e3c510d64bac0e85155de1e22c3b1863a4a7849f8ab580d92b2c3a13d64a33bc2f51d1b80b17666a9bf6ef816da7d37ecdda55a6eff281827a61c82bb75ee6b3684098c6548e2de00e72a1901d581e11597357408f29758514351f7d14c53403fe01925843257d485872a3c80e106c63ce5a852adff389ac73f5bea39220b82acd6535993aa60d7efa67de33c0de0e03891da78d8220215dd18a7ec804414d24d5b89878604353becc3c4ddb42c7d058545ad4b9450d2652f7b1fc0c774e99a77791ed80c0927dc83cd2e267e22961f0e1df3d395b3a45b1db19e1fe80e4a5978f25761426557b54d7220e6d9881e2e6c4e9cf46116da9815e10fe787f26c824b41f07d94c6319986686addda5093aae6233f75fb41bdd795f02a06cba04d52d5e242e1351c13797ffa200eb0b121edd763a42cb98e00116abf90ae154bae9681eef98825c9094e6fab865db970ccea0c5621c11f0e2677bc860dd20396722ed138cea53084ac02e6d43f9a2e4df50f4cda61029b490d3c5ee63679933ce75b94da4add4e0a8445e38375f6a460b5ea5c4cbcf003d0e3b35d92c6785d7af93cd1594575b4a287fccafd270975b33c1f34694940c093de7d75bd84ed4907e167e30d022ca326982a156c04eb7116967ebca17a15fe5e7077cabb0608c0d45a8329a1890cc12b3dbdffdcb5100ac581cf364507bca4274dc220feff9a76cbb5b3255919f565f6ee12448281fe4584ba65c1cc2870947b4bd8a19c96eb5a2e1c422df37f4cff0f2e056e81e98daea91aa3c8183f37813086cc1562720318c3fc4006677b6e591100b60b8b7518668297cbf873cf727c21b257eccce39c1c34dbcafac8a89f49f8f102cb9041594aed3de5a7acefb8da7d363e2410910fadca2a1aa990e7ae9082ba619b0cae299cb8903ee7555dc22f14427932e7f11bb91de72a22645f4949fddf11ef9ec768f9023f550ed18a7eea54ceb898ce9b2d11aaaefbdfdd9bb38a6e4642a7e0b674a9ff90a54de7c49203ec633836d9f52bceb7e7e2b9ee2b89592de64ccd148475e446cc67e15db2e8d03e24171119ab1718fe8a424697d600f26b269564afa02fcbcebf67cdbfb117d35371594a4bb46eba8a600a784169709cebc14491dc55ae1926d8995bebb065c87809baddbfc246a5bd53852629f04141c077dc1eaa66e306b38f4a7a0be996cd8ae22061102f5a81e29a5c89f1ea435b4a118570e8a3c22079b565e3148f2d9e19b79db32c47e8cca6fee3c1742ad9e124e8aa5eda3e96ccf0f062d5e850a05c1c911ca82b10db8e19fd8e0990ab333c33e82c5497c6cf7dd19f3765a69fa97e5b1315b641efa5fb259a07e3c64084fe3c262a16b2d01965b53bad4a008f6ec35c6fefaf4ed9fea02abf30a58628a441ed916450d8fc13300e9c5682863544c71734502cddfea826b279c74ec11e41ae7d1be1ea752944256ecd389977680b892a83e6536e3c8d12cecb0bbb4bc07614f9d00663cadef870132598a1a4fb045dc5898ae5b2309bb65ed00f91516ffa6e2cf48bf88ac39a9ddec2d52d577da771d3f968be44d14ebdbcefeecda6eb387b79623b1b5be6effc1bd0e61567af0553c770d1287475e810397660c1c486cd898769577497b6ba3d5d40d0c1c4e969ee4bdc126065da286ab544811d49b916c22a66e689a0215db82ffad9bf094e558d3a8acafd4227409119e57b0cb8c1fb03276b1ea37013bd9a9ba80b68e86241f4197dc49c861ce4863cbc386eba6ef1099836836471baab89b5859f464073dad336d1276678e05501d23a3380d137d1c4854c90d13da0a3afba9e86fabfbcf3479b3633c0abc702aab76e6eec490a8b2f0cfdbc0857219f1104ed791a252746b36033d8fff86fd709e0eadb20ce9da1680c5f346b9c170acd37e086a20658eb56817d181a143fd575a1d53533a9a26513005385ebfe87e393797c316dca065baa578bacf63bc5fd94f798d5149e7c55234668c0dc706f5d7a9461c88e1b1b8353262df4622f16b0f6c5da9e45f5a572049008baf4addd9285fcd8ec296159c469ba4a43b8efb46a728b6977c18761683dcb5be0f19fe0ed9a63417cc8d3212dddd8828974cd6cae3681255464d2267daf09855f7e66d29ee3dc15f584c3ffef1c4563b057483a0b5b895618d010ab726da2b3cc6aac93026319b2deda53484895a64cb07d812dc68bb5a297391655c7ff1e73d1e6a1a9ca50b5aa5c9cdecfbc70c454703edbe59cd4d914c55b6a0c1ecec746ede46dbaff4948c39f8eede4ae051b423f40c2307a39aaf620f24001e6c1659ce73e03eb3d1cfbb49c3e65af292168c6851a02b2e8fbf95443c243dad062c9db111e52838412d6393a97f896857545f723c8d27eb888a763f82d96fbbb3bdebf534135d84486e3577cdfdcba643c744bc03fd490481a0ec036901d4c49ce7965fcaa54a73c5637897de391e6db7c6cce33fe82de83d475497d5a5cb0785a22d6c8205c1145531cf192b29c27590b06e00ea2e4dcf3be0438e77a34bf2d33eacda8b3c40e55c2dc592f1369f5b328177321ff66a86e753feed99ffb6eb8dbc6aa1e2c879b045c9a205b3d53650962dec41364eed8fe7576bb089e7ca456ac46c7489a1bd793dd5ab63972ea61919662ca08250ea218e1f03e3da8376a3d8fb1df32d964e5f88e56eb213469411c9637883e5d989738891e828af87f7c274633920d7995edab2f0a9848a80bb01af76b1e57320d1db1f9ba4e7552e897bdfb433a86d68ac92705238d394ef30a466ab86c8b8f7dea08ae033e5d2686b2a0388ddb9e22898de8581e175407b5d06e7f6cbfc53f4e0ee3cae2b77285c1d287fc26c600f95698cd33ca3e6f803300fe365b2582ca44da413661f1ea6da1b241380acde59c954f0b97de36434f36c54aa99bf53a057425af68c43f200b07fae03f19859c3c1358c97887372b0d870166a1a462fb13783cc5a97f79d32c706a56b3a4f9e6ccbb0e6ef74b5544b92913fe9b90b9b210a524bb9235200b0a1b7a58c1b88afe949452fce1444c6f14574aca8e1c04fe93e2492c5fbdfac9c78f96f99f665cb71b16625984755491c5b69ceeff2df655ccfdbbad5e869a63221784fbeea5f140122c86c6ce48674605892efa56e6d2396456cb3dec3c7c6ff2faa175a352db47e1b362b60acd0125574c5f56355b9f396c1b2a1dbefcda719f4a564df1e3d745c138ef2b1f2220000c6d5eb7141192cea0eb43d52a86760e629597eae8c0dc3c036b0e65376dd2c80d6f64c899b7469fa18637b651592bf9a6c40c17394327a60b13fa0f1ee3b507c1f2d1a43d16ec36121eeb5a9fb4ef2b9d6bf1ab86dbab7353214843d7956d3198daec5eae93fe358252706675b7af9040642ceedeb8f96a39df1656ac2335a6020bf2f80bba6e44acad7f4a40782e0f8aac6eb1a4b3c9c5eb277323eb1b574380183dc7dd92c3bb1afcb7c3f60ec261889ebd8a6b734c53cd19cab8a79ee2f703486c6aef28bc0bcfbcb1f9931222351dd4a9229c2ea1d0c4f54d4c7c45c52049342539634cda16f9733d7b33d381a4216cf612fa3c948074b6ebdc9a1db5402964eac2a3030cb35de5389fe339754c33ba5cd47956daa704d1ed81b1e521e18b3b63bd103e4f5d271ac5d7f5fdb3aed1bfc65b5d7e498789986c1cff4cc66fa0b7e9a018ac157880bc31c4482744ca5bcfd8f39ca919f67900510692f1a217c697737c8d21b05989b02b01d10d4d248e0002a9763011346aeab7c195c2cd98f4e180fb524f4435fd0c8bfc71bab39fbd53d81c8e208e7b24a9fcd4a278f9e815e3afb1eb5ce6a645f33f843f7f507122b4266f5c178cb477f6d7c43648ef032283a17beb2a27b7dbfa2379a7654e9d8c995f6dbba332c7326e1c846668c2d3d93e650bc75f00f32ffa3649cb6258c3a392e7b31842b603da89939102606e0cceffd24318da96c25f84fb930503d633810e71e52a0867288ac151a1b11e8cb5c4753a620d628663d2f4845febde0a1ade906074c8fcb6ec96c08a8c87f4103cea1962cb139d68646a6757fab1058ac724c38f64303400ef984117fc711fdc5958e8951c7b48d771a4cd71ccce655032c141c757e1a5e979fd56ec8f2edb658a54591637cb1e7d0573f78aa7f571258eb76dc5b9e7fab6c3d92260e0526a46f2cc172c68a1e581dacc4622150accf9e393c0e6b2788277937f07a7c7529a2eccf4d3855216f0220063d2a954b736161909d97c69387d05ea194b9acebed1ab606d8b49943ffa85be9034dec2cf665911ad68cdca6082815300f3c41c572dba9a3385de8942e93ee14ffe07aeb66fce88409ea77f190dda71fe2659d777e1150743995349a06cc6b81f380c864d5e3a8034c6aba641544f3867236249490b1a2bd28cba4c07b5bb0fa5268c3483dfd96909a4b2054d7c7278899127929fd35aa93741cd3598353e8a3eabf3706fec54170cdb593037d8caa46bff0bb43cf2fa8af13201a55b3e7293cc0a9e584c5692fbb8fd7fa0ba488e6ae1cf5b08bc9d16c2560a236aec9d0842c5711e756436c99f2d88459d3ede314f50fe7d2a8884ee92a2416787ad16a5dafd3a4cd33f86a7ab75b4068c7fd164910a152c353b74fd1ad9955f0d4832e207af988a5964286e2bef470083ccddbcf8df4b32a54222a60826f3074da84a8a012a41c0389bc111f4cff5e6a34d70bccf2e15f624365f7643ba3494e14b112f76cca4e18418349d48cdab1ae1852a3868de147e0cc6bcede1a0141225b2cc596c350d731b74d99bdde6d5d88f46b4b8fd6d7570cb64d5726bf283386335db5dceb5fea142d6d36282af92b6a70438f2c8ee2ee4789c0946f0fe4b10fd66c3b7ae78edc512effd2fa4d78f43d3358d78fc87c8eb27b4c626be8db33763988406228a8ea3aa4daba6073dd5bf486bef952f89221362c42cfa07fb3afb71e256d32e729444c6d66ad8d1655bca42a91ff9335e7a5dd081b5ea2bde565d856107226c78f271f862ea0de626fb838b8dae73263238db7e741b5314a1a049466705d4f26829b0c408357b4d123d6b18924ae691ce28fcee17e21fdada91a741ead37bf4957f72c9b96db9e0d8526421bdf557536ee03a9eacb73e7c184babdeef6371eb1418ce4e7dba8758ab217a3b5c9f307dde79e81b5176196a673323be79d58152d96d6f84d81e99cce243c0b4feda75dc472e1097aadced8c977b911f6f37ec9e04b45b99a6ded1c266cfe1390f2c3b3e885ae481534e69423f6d2220579b43975900577b884dc4af67c70c2dfffeb2270dd996955af6df41454c3735d0bedb57ffbedebe1dfc948afa6f69990f6f36987c7424abf0d87fcfb19ab4ddcd108df95aa59e237b93d30e0836be746f471054a311eadf6cbccb1a5c6c5c9e551114f042d23f9dba4701e4f9b951054a1137e9fca792990cd22984782ad0f2b4697adabefd264de6e353ea192b6b417b18dc7efbcffcb5dd4e6b975fcd8d0e7c84f036651f948fa95e6820ddd6722a5b068f771558909444e1a5d0ead9de06425e8a3d9c042f11bb004baa1db168a1b021e3229a2d3142ed1c47b32e39d6f9d94827ae8a5a042ddfc07d822d1847a3ea8d7eabd27f2e4f8b8c22645873be01108a08cbddfd2eb79368778a630ce7a419a211726db225ffe49a1945ff9f296f00c390dbc5debd8c56348db26b59445b3532b972088a5f5f947e034545dd94e618663cce0af91aa5635fd6da4f2c9a9aa74eba0c9415d8d232ae1b09c6f17892e7c6a859098bd767d7e14b8f741075f8dd90fee6ddcf78199f04691831164716425a8c2c4ea36d5ba4bcfc093cef159209871b340e95e4673799156a4845703fd392ba211fc7731541f3a8358c1ac2aa65fb51de8ed0a4172e39cbfb47b92870e9c50b33a442aaaceea494225b5d45fb50476795ddfc5a1114bf0dd725c2ed5a27065264a325cf944ebc95417d2559565c5b6e2a93ecf5bd667df8bb62ef59b2753069aa32e527147cba90ed7f41ede170dab6e2a1a96e06fb0573ef13e451de2f1fc410e0ba175530e213cb2b4560df7c3ac28769ce49185ff3b6daab576fc57dec3f7af748d1c460de378c96439119524d2e6a8818380b374da4b132081f02cd49df43aae017eea1e9963cb10f105bbf24ebe853f5f2297c66b84f34373d88e2d1c9182eb0c065f38b8c26eb18fee6e268f923ea9067023c71b2a637c6b7e8c7eb2120e8087025a34b59b4f74156753986037762879b7147b409eba3d32635326e1bb6439cd2b405531d998ba6ca1c6cbe27ff7940b60f1b33713f205aacabd20e88144f07928fe56a7b1a6bfa362fd7d19f86d381380941ae9fd66ed9288fd563b465df30552bf7805ceed14fea4f707209c5066d958f04466f0e32e99216e5ddb9c23bec4c2a656f890bc6b5e2643e4cb265700d9cf84db5217138bf05d18687ce57221fca132ca45f967c7d5d7fdefe36dcb29f3fc5e5bf7c857c531a69a7f78fd244fac802fdaf2b572b9db7038db203e075577a476b22ce497ae20e71b9623cb236854e2c6e4cf431f428776d6bc15065cf2bf280ae6b5ea4bf84e5285fe04881b1c7c8bdf6c2c4682294b484f9bb6d19cb6d9ecc08064c136722f1e3690fc9a9a1476e1475c5cd7fa6ef3b442e55bf0581c94328eec6a08c263bf44c5dc070415deada26aa46311a20ad0ee03f52b7e9e69a9efe5399a16ab41189eec9b283e095ef7b02786af3cb8c81168f47d85c75737f4535aeff078afee1168ea1a417c8d06cfba1e3ed160573b3bc7f992d3767479720b0486847132f6b1289d9f2ff9120d97520a9ecc15fd6aad6ee306f6f0b7967324bc485d5dc1b39833ba048177b969c1ae6a07dda137b90a505ff2113e0c654da8be604af21a04693df1ef4251dc28e5bee7c7b357477d5a262642536e326c91338e29ee02289038816489c7ed233ce9ffcd877890ee52428661860ebe69f99e4af67787b5be57db4d3b016c86e0ad4491e53571f89b5811df11920ac3e513138f73cdb673c7183130bafc0799943d3411e24b9c0ab4b2a710465601b2baba6b3edb9d9c1aed4f1dd44bec6ebe127f30514e6e809752b0cec134f43623c9bef22b7fe52006ae6270ea7c2fbb96044a842a483a23dfb4ed20c06989516e1c682fe16b227f50ab5181d43bc0b97494e51006687a1a4699296af3096a35c0d044bb47bf77332c089f374691f19a09b03cbe9a8529219e4a9909e4355ca4a6973ee5b9d4189ecb40c3e3bdeeceb9112c17acce50661fefcff47cfe0764e87cafbb895e156168eefe225355a4cdfae5a9af3f1c70e4d9c7822548b88d343c40f38dcfa071b5ccc05c4fbf8f5080d173e309552e031a0d11f7698ae2b13a15c0fd6757c0b4e7e1f71e742c0374b663f0428fbdea1c8294690c97f4f0d0b50437e50d85551a391cc81422bd343ecab90b9a362a9db2501cbd827f275fc415a25a980aa8d1988604edc8b1fc9a4c80ba0326c11d65eacb633fce93f4dd52c3f6f3956cff26167b0358ceed257fee873569d9c2c410faab7b48a5a900c117305760c3c163c7acc57e51044039075ea478b5d44867561e37f537c788f97934524d0a2b4a81a6d281f58886362f18a3ab5cd3b01d8b89d1ce1a8f9f224fa763bfe14677c9ba4959ade0b3b66573aa91e040f767876fdd426a7387daf9db57febd2f2e2f895939df7e3e05dca7fb55315f28a34496869dc215f16d5cee39a3fba01dd553a16863ffcb49e8ada3ed013499c2f5c482bcda69627d85e058b1ec851aa2bae1492bbb8a33eb7c14907b6a7aaa9fecc698eeba3665d40f3b06f3e4d7099959858add7ca31e727b40c26fee2358d763542f0ccddec59a8df9e4173a046ae9c7def9d8436bce66b0a6b6c1fd6924c72358800d060baf539145cc90ffd2000fabe5e757e07a32baf2ea21a6bebcb0aa7927753e15bd7defa5c6c4c6566e36769993d38c7f08493edac39040e5a8fe544a158bcf140cca4b5ad6f1fc7c8b396d55278be82de14ad2dc1f21a5f5c6556baab8d7feb63a02fd1087c6454267e328366a2c58d267011e0d17c4acfff4a2563a6c6ea70109bb3454a8fb800794743b920d7112847a4e6a8e8955834cea0f27324e8d8476b55ce748b2cf020b6fe0255642ae64a81b2bb9f10354124473baa0d2412fdc3dd25fd1a99ad6b892c3b761b409f096e2e4e7efc76f0280ae830c4a604bf963382cc0b555ea941c81f8ce5fd2cea681904ae5917381dcb9bfe76d18c4faa2dfed35174ddfab612f0f869a8dd86cd74f14891a9b64a00d6e3a09a57e8a8cfa5a0303717800216e849ca1994a4c8ece7e208e606879b131cf37bf67630f4ae4e020cdac0588996538d70f0448d57462ae3c3e094f41fc222200d6cd53d60045fa4ef22d16d34b2a7a888ecbc1d6e7ebcb3cd1be578ceecd561ee0031cf9a8f78c59fff115eebe4fc7ccc959fb3a640372388803c9245c829082e8ce8dd08b3e29b13f49bc1379eb15723973365d92c143bd722aaa252d7c9261364d9f9192c8127482720c9a0e5bcb2201d77f7115bb0c726e34c60f8610d77bf42b67152b10dce44b9e8fb95613d29c8c118a2d62cad901e606d6f331b6baefec8f9aef0c925b820e1a46286f9ed208c37cb185803e7810d9892ce082326379eef0495797cd8c54d82987a9cdfd26d17529058afd1875ac0ce79fae5f13bd51b2fcedf83c85a179c7d416a323b9e51c746e512588af49b25f44695fa24c8d3cdda20951a88c6f97505408feaf842b550b9d7cdeb8d06ef31656d180d713bc1c5ddfe1384ffe19e2e00e554dc76b3c8a56957103d0156cfa62c16bc90d0f1aa3f64df4aaf820121dc2f5fc6e83adf816242b45f81b708a5cc3ab76959cfbd3e8a9b2c0cb184ee431aadea132c948ef3e793d0bb05f4ad3190ea045e50dd7450527bb3d4366e47a66bf52b04564394a0a9587e39d5087129d4d123e65875f204210df159d147a6fabbfae2ede742bbedf65bfb23a9bfe2f7a9e0409815d29c43fb20bd3ba7129a4d2781bb220b8a00015629b7a53541002fa12d97a69c84f1cc19daefe4325773e7d59a32ae31a4a983b80cee1254878ad34c9307fedd74de335dc6b3922568415ade0a52039cbbabc68f4023bc0baae104c439edcdfa56905324d906a539ae66ab252a15bb4e84e577cfea2231be35453af1d9adabf4af4f3509ea93ef2c9f7231b0540cbb264e08326bccd115b188c91b6b4c8fbac4bd05d2780947d2ee5f6ba82ace41b3019694eeb90fbd2ff99bb985004fae2707c8fcebc8a85ea4a05f8a0f82ec44fe74bf24ad0ccd8dcd246072a766fdd56187685aff3c7a4d83c03072168ab9475eb8fd5e0e1ed0afd6b21839e92c45839fa434c2d4da77ea7662af49db419cb620ba9be5d05f7199d0ace1ae76c4a626bb60227c3ad154c690a04f94189a61e5cd7a8296ea489b3bbe4b694e63cfcf20cbd19c83efb3dc042801959fc56c4c9cebe0a642d34e6eba989","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
