<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2e1a8b677e11ad29d4f48c9ef58b87f9638b6ba80b79d54770a1c39145cdd180ed9d10d42c94c381f812d9c2c9ae471821bd3529efd03cae6f37f069181258f89d16e04e30e05a060867ebfbaddfe5bef57c8c6954c1f8bc445cf905327a93f7a4e4ac6202354986f4d352a22c1db3ba6b599f6f66204bdd2fceb3969946602d8efff4a5bf6db2ea348b82bf5a31ebd528a860ebedc63e6b7e733cde35f5a844bf6cc93db3cdbefb5fafc8277cffb54883c570dfa5ad2832bec33ff3881d9cfe39efaba0731521b97c322693986da9877e8ad20cbc4ee8f7e8bc880c91f976933ad6d4baabfd06b8d7cd98946070f5ab5deb1ccb006c45a6d188bc9d028a421b25b2183c37657045e51912ff87291e90e9fef034384aad97c4895d48cc6e2255f677817c279490c7d27302d15b0e24ae05537a0ab786a489cbb95e6588239f447f765fa39b16008b54cd68279f082bfdb6f6e7bb06b6d4d3c948bc03b022cd2b697555abb26a1b1506de7f3a0ed86b7c72444426c64173edc4e961076418c0a9963b2822aacc261a707bd308123259020f9edece5976fb8b2d5b7591a9e6f91d76026e3f5e3c0e86a053d79788b161902653a36749642badf393cabd95d3592252a8e6111dfbeadd3910968f91911ac2dd3ba178403ebede8f6e8f14811b093a8c51e7e3144db77144bbcd39dfda22e49b5c8a5e518de29caf1428821290023bd3c41032c8f5604f2b7d72d2bdf398059d88ab9f71ee0abc1cd8b9cf6f582143705fc31ca36cef75076ab6d28c30167de7d1b684e9fd3a3da70053e1ac420da67270b6e767034c7279673c353b6da7cb5eadf606902fc5935fa3eb69e8d2261945a99d245c9e5e2c6b608ae7c9ace8580d33d5cded1a1db73f6969443d82109b55b139ffc925f7943ae02a06edd715970756202b056651c6d89b03657aa51a6e598f49ebf943fde5ec70814a87f5e376888a5598cba83c80936ee32ae5d85b6f22825e7f32a26d05fb9e556c1dfd0ba99a055a1518b85530ddbbbb747d5e29cdfc7ebf5e56f7ac81bbba66462fd7b3c81b8e5086d59d0604a7d2ed4753882bf168a0fd98273f9adfb142013b50aacf3be3be6ce7458cbf066ea7609eb4d4c638a723eb56100ea447aa8e6e124cd95c4940d61c1c98f60136d1592d147e080d8baf19fd28ebbbb4d4a5bc1c928b5360f3804a2ed424272ce2dc85a022d87888ba7cb186eb81bccb7b8b0fd7bc345482575b69b022419af434cd2a62cc8e041a32e43ba08f00e4c179c9fa1c05878239c1107e185d0669f803640b53f02a107fc4626f3ae6c6aa4707e67823b2fe24dead92e59f0ffd1b55918dab9d3f1971b44815cd2db70e30f54f33c2b42b39ea2b05fe1158e2074f3142f00b1a39c836501f7baf81367ee46b4deccf523d06e7b8a84a51ebd513186c51f9c09b97fff0d78a5bfaa444336462514f6555c4bc852bd33a19d94c9a9a7d4d0798718cd94e7675e0e3dc3a0775dd8f939e4de44f6900b089e0a8f94839797e4f9255987eb9112b8caef46b456317a5ebf4fec05f4fd4d7e65742dae8d15c52a16f004c02b0b3d41ddd28cf50d90d19a669e2d6aa707defd8fcf3ac8920582652595cd36199f8d32ef3f6b74714815a12a10454210e1a49862087b92311b01981f2a3dfa26a8f668e78f9ba456d6bca7edecaf02b1992898799e783164a300d161f3efaf41d54ddeb8fa31e4f9bc7f5d616f78f040eb565752c2812858508675e935ff8547af38352fcee46dd8406bdfba4f7b0485a55c83a4139d65506bc3d233867df978c96ab9f48f3761ec438901a96035b8e4725d2e53d66760a8bc6d80e6e49cacfd2c58dad5f0cb8fba19c67e9fb9d104ca98ab729374717fac8c397414791a4434420c3ce4542e016aed6ff5c847403c8d1c5a3f63b60c8c67be2cc038fbf51325ddd6ff30402cf6d13c9613f2bb2fff0af020369d7e7a562fc59d31965c0683dd67e3126d7b8e7c515c640a5e4772f387f5ba7d577dad3792793b6b3aa44b667347af449f37db03c830ab82da99f74a2e6f7530287975ff9fbf55da6738460f65c898c7c3c1ca98f7978f0e3b9fc2c7b68353c196002c9ae25cd50335bb89a27e3a0b71417b8da544272530532d22a7c7213ca878418cbcfae25fa67989525d9c3b399de957596051ad112864d3d4074f38fec6fb6bee01edfc14b47401ecf0df9d9b29f79b729428a9a4010b2d81d814c662e6e2135b2342af668cdbc6ebef304ce2e7c7d9a8ae1e81d31b1e10e7ba4c9c5b9baba1b2a30c984bef9b6307bd0be31d12480c2c48b9fc3e0e3b246dd080f2ce484cc950a55168a25869bc86f031a799598a5d97a451916eab9481166432ab7309f0fa6c6d92e1b0bc31063520d5b297c319e04316e38fd72fdd859f9d5e9467cb23889115b7b10a71f06cb5e42e1e8d700dfd88dd312e3e9acf3c927000627d8477ea50a5d2a67b05e1d710e77233adc42ad8f3a15d4a69e01be6aeb5ccda76b667058c020572a5b0b572c71b0e24a2c8b994a2e57b4f1b2765465be44aae2173283d668a8e44d9b61e7107fec6c6831bd50bc6ba812ffa240f7597faefecdc77a767420eaae03818f37ca2bc4dbe4b4f1d545702a9b16a5e16b5762c6ffd1fc44b9556279b28c1bf5a52fb3d7d62667751a08fab8ce9c7c05f9fac7ad254152109b9c8b80c743c83b923bde08b808e648c2873ab3cdd316808a818f878d660e0f766de92bee44b0eed4ab1df344855912ae82963b916041ac53e5feba736234e434372a87a08d7709066d539f943b8253df48fc0df180a24cc130e530b201adbcd9c224a44ba1f91a00afda8903c4699ed263e127964dd402173f79842a1815f10720c5d9d66affcc53d8361677fa164d1279c0068279437d3d06722492c241279e578cb27bfbcac98b4771970c865a7a9d9c5b5b5cdadbe89f37b0f907dc2da171f9a87fba112344c8cb140098872c28148b54ca2fbba656b4ac1995d9817a9854b0537afc8e9ceacce9a30205bd32718fdfa1be6834f485c5680c9acea8518b92fe1c53a56fbd6312d75c6332b15f980fba4461096c88a824b5f81006a70bb240978a786759fec420274264ca26e1fa287d84c5bb922badff3adabc212bcd6f6ba259f976b813f247a7f76c502e431c496aaae498ec35da0af9b552531cba2c748755b15f1ae7271f2171c83e9e38fa310d41d9904979b0618ca35f8433bec647904b8bfcab3ef59f67aa2e4c928b885e83fcaa5290b8defd6a233f65b5431d724891fa625363de959b703cebcdb3d4414f6ffc52a3619f41d7fa12ec328db990504de8f72aa612bea7a08f9a4f43d86dcc705d11f00e7dfb216ad3f563eeee00f0c76ea4fb83893de29b1ebdb88f6b104da688e239b08655708523535d07ab84309096a099d1c893bf7f519425feb7c6708b8649a6febd65d584f9594f9f602748b691f7fc4a2c02c40c55d3c02caf1b850feded5b0382d46e923a3e0fec23cd14b5a6c8335a8a57f5e2ae7cbffbfa4f98a4a4e339aed6aef9d7138d8df06ffe280d5e3947d055e9f5992d11c3793c510adc49efa594419f05b6e5a6c54fbaac2bf4c7999f839dade6a84e341bc17ab749df13e3bff9e9f5f68d62d185b46c52a3931c0564bd4e6305cd60dd7de55014d12128e83d3580cfbaf9aca399b36e394fe986a6af15ef1c15eca7e5e274f24da6ee05a6de0889daa06eb1410c282bd030bea854c82653f2e97094b6e2d53ac2ed2b8db288caf6e996416ece580678672e72655ad422afd25cbaa36e22b13e4a9cc36e23fb48de5ebb1cecc7fdf5bb21a81c3ae0c1e8ad7e0bdde523beb94f8c736827aaceee2a27180cff27d736096d264de21801a9a3fed6ad3c8bc1197e98dfc58b084a411005badefb492b733bc200196d764e6fc5bd31230292be1d0522462b4bf95fbe1ea3c375980b68488480540928a1dbd25aec989597179fc1114b9aa20841f6ee450ee8d2d6c1983013128281857551374e70a1fa436d51cf2fa0c4cd7ed787e0c9f8b9f0dc9428b87ab80e3db64b5b3f193c5f47a3a6aa19f31d1675f7f183928d029f7d202c4f2f2d938b934bff682a0684ec3ba4bb5c293b5fb1442919f6f1a7a0cc814b945d9d4658bf0c2c910bf00be33bf739c2030efd7a0fc307a904e01f35eee919ed9d9dfd61894e396a7b6b676e7075ed915186aef3593ff8e979b61a1f92649d4a10cd6fef75f72ef2f33237478ba9c161c8736ae22796e8ec72195a98f7ddfea93412b5fc7ccded95aac30a21c599c592d4180c3d9c08ff19e1272e2a228e315deb1412660c50c2a79773cf841519fe3fd7da07180fe43a0c4c43cb1b28841060a21eb705521bf548cd3ed27c90b7fc60db3f3bb89946875dd68b24c393ffd9bf3a01ca05077eeca09d87e178d6435b2abb59ac65c967abea05a904a1f0420fb37f45a4b017a41bc96db7c42d1e5f40066a277f198280a406a04841aa79fcc5d025ee65ad13d9b7aa0972119c22f476141b8919148ff5ac146f2dacbd7d9b03d926dca097ab2395a1b20ebcf4cceeab71bf41f81f23ae934bac59867b4ec2d06cefb3e08188adb55b250b3dc888e5026e037a395fcede70c4cd52047e258f587efdccb14f6d8de69785c5c2724c1cabbb6de7284a38920e7e9ab34c544ba5b4ae22f51857b8c42867cdd9660c74d5638adfd5b014b2a14f0b089af7178159d52d5e828c76ffa1f005b1fd1ed18c82f9a6211a3cd8872d2c977ec12842b69c1edd2caf3e8e1d2df331f9e0483bac5e53b88159ff36016a04c5f1287ca470646e03d7e997268653c22ed69daab7d6be8f1f92a8e78c0f89f458e01634ea3b9f6b180bb13ff9b40b0faedb2ddf126589a8be8a65a0b6413db5e87d8da41cd3bc9d43e6195f9e969137adc8c1dcf9ad2c7aa68b17138a62a06e2d6aaa749084834a255c129645c4df7e710f1c0672dddf2ac5797e397cd049fc5a1a048e9e5745c28bf83516a4e9c8285224a13107efc78bd4f5c8569a3d0293239167990b3da6cb9e00331ea8725d5549a0dc9a357dd314843a60ce8ac4fac860b71653c81da4117feeaf65bccaae4c2ab116043aea505387d1cc4c868029cd56f8180c08863ea097fcc75598ab732622beb3e840500b811119428ef1538b8933a6bc7f5e12abde4a3ac4290293f9aedbbddc997706828667fca558b266452c16047aab070674588b9df718c53667479718313e8bd70f36ded47b35f4acc0d16763cedadd19ecd60849d8d46877e0160ac54db6f5a697d951cd77941e8041203992d8b18c8b1735c8f27e6503ce6c9ef779ae33ed32c04d1981e128ec99ebcaa41c5c0e0c9d39c79d2e624610940e5a2ab13b1521f82bf0c072ed83c235088b48ac45c3e3bad4667027a0bacd5031cc70ce1e6112b21dadcddb33a844da59fbb629c5b9040560c323b4cd631b3470001ea4f568f035571681b822c5f62ff9d6aadf7ba59da7b3225ec11e4fcd96e6591421bd6b7af096dab0c398f80061bfea7927c31c464775871ea9f095d8b54fa516c8f064ce15224ae7f152e57c00032cf3127ae1096644aa655bedd1e78d3185be1687872fb31315c8884388ea1f889d7fe94739b3eb7bf863219d40d3fce5219382be8b85ef6a875f4f648ab3a07d90a9d9995d7cf30959e4f0f88ee8b5ba9ca538a60fdf69a145dc7ba7fd29df79bda12324e09bfe7cef2bcdeb100e844bc9dfbebe2acf35f0d1003a901f34a2a4f19463d79d39210ce65f5b98427396d7c1dfb793b6be50d02b94081a1dccbb87aec6e503c97448410d2643a8fafa30c43c51dff1c3f8e177884bb6897ce6b8b75f1dfd6f01586c9a18327390f49a3ece3a2569085beb63d668a5435ee8af3968cd1c98ca5d594220483ac5f38f164cea7193ee95e4aa24a9c2488a879615d54666ca06a532f9f4f3b3f32516ae0cd37edf02c37b0072a0e51168df9916afc6515bf7041958d1ef9092e486b130f4174eb5ea692b96dfd8a1436184780b226e029314794f8fb5bd47540277bfcb54e02e2a74b158cc8af6ca8d2cd274dcbd0fe8f29d710dfed71ef367079ff0fa81e023c7f770186bc31f38cca832c25cb867bf09cbaca36e7e7b949ce3696cdc9708d6ee26b9c8d7da4f81b3b64bcb7f64b6c3db79b7b3b6cbfdc1035a508638f9e579121d0237612e085a9207eac592f2a797b3be8b975d3a5157d80b03148428b551989f7773d267f6f8b29c4c462871b36d9a2e68c402a0fe853df23df1805fd9ec28044634fe32f3102f3645c7e3321b46d858652a5bcb2e2f51e6438a1b46c72f151386869aa6adbb48e249a57d7761620eaeb8cb26f9a96a0ee1b2a7caeddd17e4b2ec5bdea27bad5d1e557773224021fab612959590b475b105a67f78de770d0337631cde6b97e66b7402ae8436d9b3b52dedc1b100c2b75fd175d337eeeabd9712ff7496f9863354c459d1296312e04ca998b4fdebc44fc368ce6235938cca1ebdcba13a907b71d3fdfbb6f50c735bf16cf9e34e1a62f3bae782aaad683929a5a1bd3a5f17547920d21003c155ac73fc0028542de307bfad640e11a56d7ed2f15e260f1882234e4356cf6ed0eae263144c7f45c26c78d9f40286b1865c52807dcc2edc3bdab90215796a7c37e28705f104fcefaa4e43225b569de0462207074f66f65b36b50c4514f3172f64c1c97a4293953db5568241bc3fe8d5e3b67bb3c67069edcaebf7d504b5e74c83beacd7fabcd43b7eab984252ef78b14a2b385e9859f2ad8d97988ca7f1778556324d9ca4e820b5d115976d9a11bdaf68ff67269cfc932aa77a5bb34603595de5c08a419711a130151c2cb3d704fe12ba0900c07ad70ec1eb2f05d3f049290f68deb0fb2981d98e9bf31fab00921b1d5b48746a4b5181064eeafd616f2c9bb4409d7def3c83ce61c863be19148b10cd92f12e143724de90e78d61dc21395ec7e713168f641cb53b905091068d340c0081e5818d888f12d9e7a6e5d6855111138c37ffc0192ea567bac226ed728ada35fb658119cf5e5787ade0aef3bd4923a73542c39bf3dbc62586a660f4cc87c958e43400a9c47ab5bc536ae31444822d4004eb3091a81e4afeea19627f2da0d406d16ee5c30cc2ba2153dbcb413c3a69e8a1f5a9e5e4229656957f7c54fb89b910f1acf4e7198e5b2b27df8655612d6bab93af42e52bc87bce7bf9b22819897dc9b4329bdc760aa3e5d92dfc671bf34841788f94c53d898726e0a97a13f4ddbdacd5a58d654889480db85859c29c43d59507a12933f42f67d0fb864c578dc46b66c23e646cc55c5e36a5afbea25409cb000c29e6d907255b4ac09db3696e75d475f64aaa800fdb39b747580a467de322ab89a6c0913196ec8d7f32b7e1ef979b04fd66273d4ffba97edacd9452f01a532d56f248a73e004c5411215307e79d074f3845361f12474850dda5da52036a08f1f2f4b00c0595b57c81d7630d4ec10d55455ce0083b49dc913a14919f7342ebed0e23bd88549887a45dd49800565fcb3ba230175190a7126c7c71b1d6c1987816d12cdf07fb2519ff8330e4941b64343352bdcf43d7d6cc1cd7b8de0bb8428b767a14ebec4fa8360ab98136bdb3f2ce23a13306cfe98abc30553bd511acd8a5b32ca965015b2b1d0beb8b765ca69ee65ab2ed417c157caaa83f12d22ab004c154e9ddb276c2b37edf2bd9046ac917b3e45fa06dec278cec7dc79cc8443ec5348abd2c748afb8688142ab12164faea4a6a94a83909590c40269e05baddeaaeecbc928b7c7f1e3745061cc31c17d3f0469289241941821ecd6af9c69930d13aafbfba47e1efa3a261359b65aafe6807462081422bb560e37cf218f3e980208e1e4ef1b4c547903416fd601eae341f8fc3a798cf05f048dd2b8bcbdcdab0e33c25a6c5db67bff1682552ff3d653b6671c981920febd2f81efcdec2bf0f0dcad16647dcd10841b828d2c96e3384a149da87787c2d7adf175e0260be8e94ad6350230b56b30e1652ad371b5b9be402982829b75ee41ff6ae529ed880b33228f928e7ff748e499d24a02571e52dcd09437a8f67414c9a6f6f9e82b83066834de88dabe102b41818c0f8f3296bbccfe9952c3fb543d6d5b9af36b04a38dd2a872ed3f30f28f632923053a19c4c2659e916bfc8c8ef1cc43b5156416227e39f504dfffc582579c9b811c22dd4b8c69011c84ecade94ed088887c19fc97b7004a575ae50b645b00338c0020f001a62b45d59caff2708eb848af95c096f8b9407e8ccc73fbfe507384f9b42c65473160696d582841432fdc666cd70bb70d33de30d260e023d291bee38c3d6a87d4be837a190ea68b09d512c2a13c6564b565cd32181f1f17ec3dc17d38c6b455e62594556f7bfb210078a4595289bc70bd8ddc1c49ca68642ae0fc5d1656461680b00265a3299a8884c89bf79df5cffc5333f61f26dd3bd9802849bcaedfbab184136ae507ca491b80c860499fb0897c0499b03fa9f8bf84fb4e8a611b167eae42e0797c2456784dc49139352ba8bac1e882617e80e0fdcb2001d4cb4449740fb8503646074f5f05ed5cd2f0fc732b19786167069c2b9278a213e14506c61d8bc5c6bad7c53b0e9e4a479f1e464b5191ed7cb8c81fa8cf020d271b0e079a5b1b1612956c3ab8e8aeb4196e44b44b8be7b0ba4d709c2f61d1fc0919967f8eb8686f166dea3f3af36a281b2495018f925761d772cbc3473affefe1b00d43d0ba780ff95cb40b2ed3ae11a811523124ccfa015fc4e24bba740b6c8ab56b986189c1303fc1d327db0e01cd9d184a33f13db5802dbfaa383a6288e503cf08c01a4cf3aa6fbca0cff298460fb16428fe3581417eeee76c053abd2f51587ff92c275d0d046cb0aed7d5bbdb285dbe55756d7d7496e073dc259f45a259f88651a594178a8c8887f5be57e7f3ac61e85904746dce5fd7174006d6002367c47a95304ded84bb89b8d315e4c7f320bae070b73f964be321190406e3b1ee86693aeacc67dae5fdae8e9b912817fcb09222e0ef0d4e8be8b02e7322e1b26d836b2168d484c09e86a079c7cda16c3849b16a4465526be6fffa49d08e1a11e96a07ac5c8c28d61404ea9809f3dd3ccb2b2d6628f5783f254549c114d2c610317e7f292c1158e9a0b8da492df4670d2bdcd0ccf13fd506039d8dba35dc1a6db74d25fae76ab598aadc0fb95b12030ae645751ffc67c196fb5de03681e2af4fbf791e0aec1d59f5b923b1d4c916bc35c2d85c782679da63b9e63fafa3c611ed137336eff18617db8b4256d197ca828a8980c767759d763d45e1c296aed07f18ee892f5fc4a178f1a54c1b62ba7c2d90ac10ba3973a623ae7b9195a4121c7ee96673e320a829628dcd15ff18659fa6516032c5449edebdc1ed7203e054b5133af5807a405706095b325ad0ec6030eb4b17dff52a313c779c31e1fd63eee9a4d7c45a063fc397d5ebb46f84897113da8864df80bb88cad94f728efdd43c49003c61a15e51b33ffee576cff1f0b0de71c9f8b4090839b707711c0a425d088b8072b6393c683dbbaf52f0cc8d1652df0e67604977c7baff13d8dda65b511bedf367048988b25aead34295cb986190c437ed550e2c6c4200fea737a85f331fea19c2c085126ade7312914e691b40b5fcc11901cde2b02740077314dec5259f9d2d05ca9b72f7204d18b61858198cb28a6cab614f8d50f82048619184bb83c3307cb6530f56e3a15922ddf13047b6a399f0faca83afbd39af91dd5c4936978192720179f4d5ae87588d2b657fac6d18c50d1701fd9fbd961f0032b70c917604746e9f8995a99dcef44111c59ca555f6389d008238a15555bbb3e427f1a20e9dc9c9c4790b676eaee31dd9a196cc172d0f942c39c3117b7d8558d81315fa9bad6b4a64a9798543c7fda4975995bb575f2202b14c960e03648830bea60f230a0e5d1045180b4b34ebeec1fa6c283955ddf2b7706e7742ed197c24d4eed61d47a16bdbed12265750781a68683665a2edf77d4c927b0da4033c560a3f587c94cfc22bb437473def103a28a6bab723cc65c1050205ba2a55e89fb7b37e88382aa89c6b318d23e676172f503d92464c1f9a0fc254f73b156739f901e98abe7a35e79077aa5aff9b5a097e4d44269caffe7b05e939968985873af7410ad4dedeaa34100e36754048f0c347f90bf32a335fc3e615eb4b08ce6f2460da8fec2189e931b48101fa7d2a4b3ee509153b4ebfdf7308c7b09e54f1f599a6f1bdb00d5023d0c403fb25479cc7a45da848f7597a9f67d78b08096a2a03525b407d142cb32ca6c637e40612428d15623db99e72898c6ef49ab38a6b84dcb8b4fca3ad26c026fe94ff2594df8d839727178d461f99d508b1c5f264e28ddf96dccea673df60b199a43ce7d1864c169d7ddb3114badc1f55e543b02a0aeacd508db23d24fc4e76306e1d46512993e4ce9339d3c6ce8ebb2dd161512931bca50ad3c43498e5c168132fa47d66daad3de24deaf4c532b435274915a4fdaae7c0f7211637c51659f8c5389ee8cd4ef1d12e3fd4f5987960d60b01f2391bf68f29981778254e4c7f78b12ea76f0816bfc013fe11ebf2a23eb4b0e42a5bf7b452ee3bdf3538bd26c48a3bcdc1ca91490c001618fa2631588596f286ea0f5abf2536e08b9e0b57c2bd60b2c5cf39e34edae61b83501d3651224867f42510b3f08cca608ea34a3ae0a7d3a048835f6ba3a83bd16a9b7c7d774213505482e028661f0710ae9bbcbb54542baf925fb3881c905e557ee1cc0f0855812cf9cdeced2d4bc70c45a68e935848485e426e174d00f353db79aa256fad829f7cb8f1579fe25866d3b6a8cf2a29a70919401f53cf3064df30bd1a9941b8bc90cb330ae778d52434203082ccabcc09f687c2f5fcb9b8f4d7380270117cb86661c5e933e432356e17f3630733b0dad9c274c594da1b9ed5954b3bb157bdf3919a3325eba9277e4cd9974cf118650490dc3c4aa46909fe83175ea49e67b5fb22dd038dfcf975fea31e5f3ddb1a1090c3404bd9f2262222aceba5225b61e2b0949f6e9e899f3c905615849cd277a2ebd04a10a90b1a30459695fbd4607a292a4a6326327adccb29ca4b386c3913c97ea716bbc1994dd40bbfca1487e99a6d9e7c31cd474c9dfa13e6bdf364dbc2be5712f0c9ea3bd751d8d654084899b041409317698bffac310f35270089f78a287dcd53c943be9d6971a83048be67d04955ab6dc5b324a8eb4b2f0fe68693e8f6dda9132e1ed0c5adfd273da267fd380304f90cda64b4ce55417b9d5b2836830a0c0805e022c60d0e2fdcf11265babdf68a653695220dc60e20fe1433e6976a81efc65d1c28f613785bb36349ec23da18d1fcd69e6992af7bc2ac71993367cfd3b5f748f7db2af09dc33496538f499b34aa3ac8894309a8a838dbed3f7a4cadc1de3ca1599a4d7703a6756aa7af78269257505b97dacf117e6d20ae32b17fd97b1c2562e2847b1b57b347f399fc7e5c37a86004d608a57a714b106bafb9cdde7c5f4da786f68c69d58d508933098ac947a98340762fff10aae3336b27d8adaaa99a974f6cd24242373ed4bc09afa52c7fc20576c8c0ec439936d3d34b4e148377d545e8644423f0e0916f9e5ace68d1b8b782b6b22c18c89b28ae34ed4868dac44de2e6d27f2708d4cca7ba419a573b5d59c0cbeb54fa15d9fd97a92776b6243e0efc7f3bb18f42cc1f3173cc485cdfea7e6485af60165deb1ef4ee2b398d1e16c641fb234a1cd72580d18a5862023b180c9b9cd1f7cf49d987207754b9e81be3120d8dab1ebd178e76c0c1968ba456e85f2f414d71da842590a8bc101ad81d10aa013ae9865f5cf3cb54ca54c713a44b640c388b558358f299314f252ba3555fa0a009bf92dc3b97b734121d34e8c9bfcdddffa5926ef44b209fb5e87d25da568e2ecbd9fa959c92c77996e101d37333b0ec0df60428cdfb98ed14a42351df1565f6cbbc9f8689a962701d3fa33d63ddcd697d3cb11d0222d86a0100a2e45518e1d9132c3ffd59c9359d100f86056db8c4a00bf54ea30d8624667a2f7eb90029efcefc166ffcbbdd86b80a6e011f715d5ebb1418604a96255ef1421d3392498eb0ba309384f2f29492047dfe53b90fbacbe5ac55fba56ba0831e768c472207cbc6d3a18172699d1da8511bb7701fe6373e0b7ef8dfef5f439fe7b3eca74192bc00ad44f73c563ecd6e4417cae457cd4b7423fea2650f4e4c5e778b49a4e0a880306a4a25def0c661da7d8b124844a834a7fbea23062263eb3a69518bb97f827161bc2193b8a9da97142ed6b318aa98af63ab1872cc23f381f45f4730d2ba39cdaa085bc54b2e490162966e23ccb6960bd305e6129347f715bca2530b5bc52d8ae86fba934e5e6ca9cb89695db974c43764f6f45d1b0e9ead2b7ba7d350a06a682ed05ff1d1cb615c6a8244cdf99caf199fe33ae36f390b76b822e73aa2408ab2c1edab72b0f6923463db01c706305d1799c83edc92dfc2154869ac8ef649779262b240aeb8fd337da77b70f98c67964c6c638eb338d254ae4201cd455f14c3c0f4f9527b6209790ed54d6c51d33f0a3909acd6f8e30a567ee49e2c1ab8f444e222aa785c6d9a86838433b01ff3dcd7487c914ab49c89a0f8ca250079041f985c7bf0b2e5667e667f6bfff306602fd385a8787305cccb27cdc7b4f7a5b4e8ea71e96f633bf4dbc3dbb0ae94aa09a707e71ca355c114198a7118f789eed7eee528a22f47b3d10eaf6ed40beab1acb7a415a3737bd536bf206c0f4c743396d1decf20c313e444b22df12e1ad7e70692b37166c3f0ac27c46e28b228bbd5327e3814c34efaf0355ac8ca6c3c18ad90505138e7eb6b4f465255e05cb9e393015ae7dbe1637f424a9110f70333d0995b82cd953865693bb201c1e74c4857a9c37d7ef274579d9b0e5ee1e61f5aa6f0210872c83112a9594d1a5a59684eaf74f0e8583ebd457e623d6429e43f9cff631e55accae47a58b4715c244019e4f5a99163164b165f9d536dded1d8886ada9cd5ef9fb515229ea8cfc639b366c281e4c9f5c47c62b9207c2986fb6435cc441c4e1f652a0ff7e51d00072481f49d8906c392a0959622f4dc99c5e88ef24c9385d74e0a0ec9ea53bd1e6fe1b665fc688452dcb1f10e9cf911719fcb121bfb78941666bcb530e36e654e5c307a1b14e2aebb63648e5d2461f0ea29b6ccd018f166fcf82112b1f05b61370ad3cab52d3e5ba6a7e9c9ac07bd6234ad23a1a7dcad9b9004786af75a64212d439172acde54ca7d204c4c0e3d477822755f03f519ca177ed0c1848fa22f6ef6a6f5d6861c649b2b5223320f02dfc9b327bfcd557ed5c6d078bf58226c620d2a4a603591d89552dd3a51b077e40d5b256561b64c2a5ef7cbb9e4cbbc4cc3b3a1b8a11f5c0df7d87377072a1c9201065cb3e6d679bc8bda0998b11658220a8b2256bf1004957ebbcf0d70b299a1db8a198b165f0c00b30a2477ed9137ac08ec64e1a082005291183f2e09b10054bb435696da96bf80dc0012fc01e5060efaeb99742a45c34678fde96cdb9f89970442057563158296abd6f81df02e00337755daeb1991459e9b06006b75e523ff55cf42e2b84a5dc766221b5e496b128e19a0f11b58ff198124d1a0fda9b4de32eac7879da66ae454feaa2d7e793805c7badde8f7de0b89d958e59b6f9f36642f6fc197564cd69f5ecd0587885cc34dd41b5c2976a2b3e8a4c9d48c91843be538246b0e078a4081158538f3dac4e0eb37ac94e3a3c665c83f2f67db4c59737141dc86654b11c8f3dc87bfad1ce52934065e3910b7feb0ba60b331d20b91872bbbd5ea6d4fa54ea3e5c169eb5414bab55cd90e53c46c5d9ce1b44ab14b4e19f6fdac4e367bff9701270344bd844a68b1542f018448f1b78d00d287e7e95b85df93c22866928921fbe9f4846f0d5a6210eea74ed91cafde43397301d2f2048c56d61d1479a0ac8a6d0800e4b876cbcd92d17f13bf494d3518c365dfc149102c5cf4da5d6f2a2e0c86beb151de7c549161360fe14f349a959522bfbc570f80507f78855237c7db9d883aa4b2bec46c221e6f286ac8a05342df91d92f2686f12da5ba57556ff7849bfd0b2ee76ad82f83f0b41c725f8b7d9ed773071881725a1683518689450f3ca5a3a71f3cb25885037023167ea0605d290e453adcca0056b85edf594c796a281ad611e84f000de65a48cb9781a5ba93b2964efc510ae5447284a91b28f0db839560b7f98cadcd56f530a4ea861fba3fbf68a0f18b5cb8533fc9a1fbb04e995c39bc1ff9f57bb2038a818463e397e4602801aa96e4e3ee7df4c9b501b24d9c74e8f95f6100f68ec6f8fb19b639c63e0d6ab80813306ff593eaa73dbf173df807a4b14c87eeaf4a37194c9c83d06a1f8b32772b7b24dde802a00bcca5d3dd4aa3b76608c1d1e8a5b2d9219c529f227f27c5a51f007018064c6b4881565a9f08ee9e6c4140a3e37393366bdb10a6dc3772d2372f92dd75eb03d1c34650c62f67902170b5df326c9e203b01458e57468030b8638c0c13953cd8abccc2d1b0e95a7444e5a1e0b7068901ab49c008cd3997cbcc6a58cfee19958aa4b1e0a9f915f53f1be8610247bfca7268c3586f8697adfa13b1beadf5e76379f971c7db1ed47cc81202142376fdc29da4244f67e56e04d1e522c208b2e5500fcfa2383000e5ebbfc892306f1ae8ac1bc56896db52fbbdcb5eafa985a6867469cd4e5aae070af06cf933f912dc8754783ab3eeb2739361ec80ad8d03c3ccc0d458771fc8704d675c5f7faff7930dfab4027a733b7225f31c0ce75583c0d4cb7e3771898bcb8da0f78a25a28e8ba11bcc91cfc68e7bc7a813d3f5433bb8e510c869933bda042efe317a6cf980ef5b1ca0fe5282f6ff53cb331f392c2880e912429d63f9b7c4bc72b2883373626c48d7e2add1787516be5be2cfa736506c42b07b80beab7ce09d982c4efcb39cfd6005a9833f20a4653dc3ca891857ed50498d73a1257e39402b1b3a8d0837c6dfc019e41a8e6362dd08762ee7aa910a24300e9d601d4969b1fe9716375f29f82ea49d04b9a85d9a713b8f1c642b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
