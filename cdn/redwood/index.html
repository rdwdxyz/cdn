<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d2e99c6844bad05a1268b74d734841630a34c43567dd1103dc62d4defcc55002c57e4c7f22ebc1ce4cddc377e580185507ed51665861c3547b134f125eea2067f93f60706e7f678c493ddf17d600b2cd04ba011dfff80eca05d83e33fca7b03dfd0564301ea8770f34926e079fbef5813475501c4517aadf441dac3f3a7959d4fa8015cfa790e4770e98699ba001f789289adb1d8469af8cc293a9eff8b011df910a591671807a6d1e4925cdf12e7718076c7cb670c937aa01ca0fb97b514e6aec2fdee7189c1e1949f8aaa4bbf81bb8b9361fef6270f31a1c42a1ffb87ade196918feeb22509c5eaaadca1ee86c843c42038d00ac5ff614734a36285fff8641553ee44c9736278db3b48ff154e6fc37dc095c0c056fe1d829bec6a87513b3b9b089623909a264b87c804c357cb45f1b83a001ad56f05a509367fb84f6dba6a3ae003bf59e624fdd103885a474af78752524c5a3bcd1fd81fbb435c24d442b877bd78543704bd4af898fdcd35f1f06bf3ab20722478f0b96305c2498c3c77bf160fcbc54bc45cfd53cc3926bccb0ce6a16a63b8c98d2a19ffd8c78e11f6ac1289996b8b3682f172eee45a39f56c9d3ed34c606806df0a5c8864cdcd8475ed6593ca916263da826a2095434724f461ce8c134acfd5b11db8ed8a43d5f013e51f1ec79077d231e9f5805a1fc519eb8748ab486b298a11bcd1188f6261ca4cf48cbaf0b680e0039640adff545b8f67d41cb4acc8b45c2fc4021bb3f0e275acf09d8e7224f96c0575c159a189df14261f7fedfad99f259a8fd69b280886e534f53d82c9b8403d5e4483d2263a006fc05506c68ce16c78fdcf709c540ee73c0b1a25e5f50c3c7f94c3d66bb76af0bfdaeba3be3b18e31830d3dfcccf0746c1819ed76c5663036d46a2f1a57fe5b71eaf40f2cdcad1c24a7ce0d704a670fef87524fe6832d874d16d7eae7fef768b17bee6cb76ceb02abe42137b022d0640fd215528a0ea8d330218060ea677bdf2be41e074dbfc07e80b65b6abf5ee5c50171f43ed1206a011215cf80356fd85d422b98d149bc79f9694911af761bb82966c9353b6f31d4ed952958a4d8dde4a4bbdebeed6643719d3b954a6dee197bd38cd36d2ef05e1e35b177664012293e3bfd091d6e8b053554aa5ff0a7689fd64d54ee60a287f4cb310821e4454d3fb1dce8d4bc57420d2d5ad505a7f55f3219c986013ba9c045f92c38d0c8883325950ffc673826ed135417a08bdfc83583efab4ee603630e4968a336fb92bf402b4f2590e10bd851be9b4027eb86ca9d3b6fe2b5014a9154e25cd414b37ac54a0ff4cfce9c64bf3d335eda55ecc6ee454802fd7240e262f3ff8e979dfa20fa72a8f8e3da53cb85e32003279e4cfa3b4a62c4f00dde774f847b47e458ae09cb5c0b31805b1c014e75895230eb674addcd325ccf15d584003073ff5dbe173ebe1bdbf634e2ed135bb03f68774c650d585ea1f6bb175d37ad2ddd3548c79cea83ad1fcf7755d1426ee5e4d0e55b1d379e5fcf4b6dd6f6588c5434574fc9ebc90426a83a71b08fad40d160f7f9936a04fc54bf7ab17c929f91fa447f300429addc163d46a94163704cd8d51aca2be3ba82909e815ec1dd8d412b091ed0f41d353ad91ad4442b2ff23381bdaa05cb76d6fa856d9b72954a7d0c2ad378fc87dd5e7c0bcaebfe57ef1515aa693d14c3281762248bdb03b5a3e0830b7bd8603c10155827eeb9a2bdd60341ce0fdda74cc47f1a2b7c012b164ef7c16f3c2fb5d42c48dbe3cfcceafd29b61c29529e658eff3bed3fdd2094e36c7791905fefde7b2dd9cb7dd75dcf667d941456bf32d5c909aee0195e5548a34e90883be97730db967de100e7c727cfb1e3d51a364727937d752df021e640288b34135006dc05155fb7639f1c0ffe997a94c7beb864a86042c1ba4f04644927a68d16fa671f5078e62a9043d7d54a4ff09f144d813504ced66ad34f96b89b630fd86cf4d5e3492155af7b935ba99c0ecac29d14c9b4ecb3b55fe9cc663f1af9cd11f0c2f96728609ab472f050fede68352a8dc81695096b1a9d19916247732e2f35ed5148f724cb41f44444766ee242d4669ce9c7ed0632f0b2271c78e67f06ab41abaed08cb04591075656435b7bd9b60120dfbbe9f10c711d4084e0d694be7d2586334b4d07e6ef5dc11fc1ffed03420397fe9a1f12306135c62d16c3ff11521c3d2edf624757b7373eb934bbb959c8f0e5e864b1f9f4cacf918d5d537c1f0fb05c13bfb83f50a7de2965209af04548fd047289341953c178418a72ff3399cf966f6ee40510b3c608ffe62425ff1c0ca3f8b04a5447d213a31dc216ca5f33b606a5fb70dac0f2088e8e4f61575b8d20769720b487320dc46d871c45493d51be0b195ed1d3a180bd7a5f091a6a48f819e616383cf4021c89775029681ea7562935f899920ef22b327d8fe7d16ebccf241e38334686555354340225f3c422a41ea2a4d95c580da11ab14226c571c511210ecd4278db39b419173bfec2c7671f66a4f335831e496cfc7c5d900b71f574aee8a017b6dc769d0459a8aa1fe7fa564d94a19e14e376043c60643b14bb9e76c8ab24f24e3ab83f0a11553ed58047fb8529963c0ff5b4ddccdac8b2114a79096663a4a722de8383b847cc6d7ed02ade658a7e26b94ba52bdc7e643933c6e53004931474f7a1ea1bc026c62b000cc96c7377610ad61b7df9dac08c6dcb5d5520a8d873814066cf37cf37770d8be58eab90094e2abcb655cc626bceb76d5a0efccea76e0d9d9dd32607ec26e5b7255124df0c9665371717e932e3553589cfb5e7983563efc986fa20926f47875f89f57d135b1c92eef003ee32828f50a8f47e4050cbee47d2fbaa7efd82c3677bfa691e5b03144380d4164b9c30a21edf5429e0d65f83d3c601137028c50fd0a365199cf74726b12c8d13bca760b9a5bd06917bf70f900d9ebeba1a0387729a7ed941b3d747d40eed2461a7d79c7be819c53a7b1c06fef0c46ef8e4933bcdc2cc87a46c9dd6e6b9632190066ed92fd0cc7db5d93a9ecc5b544986500c744da849703d9d49389d28a19b463e4291fa1bcf87911b2dec9a5b87637687b1fcbc709ec6ee33bbedeeb295e77270c5f86c2fcc1d3806bbee3add4ff8c7c2c2014dc243b7eb874c8cf655f99eaa2d42efb470133ee8da26847b6ae69656584ae4ca6bebf41ce8355304ced8cf15d64e2e79109ca93e0179527c51ff62b230f034d3c11236fb00f04f7baad082814a5b650a4815b54215820cfb40b6ad1f042718facaff90c6cfb81ffc2f48d7452e386c74395a16acfc6a6c1c0dc307935372ce03b421a9dd507dbd1a20ae27a7eaf179341b019c6283fe2ea1d45f4698e28052f1325e3cd652e1686baca05b16725c6b6a269c3c5d1de9e7c1e1fef496efe4afd7e09e5a0643fcbc482593593632053917bd98a80cc5907991c68d1c870af5d9dbcf0712ddbd088c04975bd15ab988141f6a5196096ec1ebb1dc5d50ee606007e9cc9b96042c6064b69388e47e78b2ccb39559fda6e831ce0e4f5f9007116d64413d7f2c120177274e84484b1f6031b1e2fb7ebbcbd46e0a65743a494c14e9a4d051175fe321edecf764c8ae5c7acf5c6f3ada4b37ba1a3ecc2f5ee27e84f470574fc4a525e12bd754c4c278a66378242018a7ff189b5fdf62eb843b213b21703b8578f57076a2b1feffe944efdd3948a8004d15606987d5d7ce510bcbe292eda548e4f00bffb050cb4f74a2405cd555a2721db03cf795ceaab984a7e7166ebfab969716d5f470a05b802d8ef2d5d5b193f637a23f04dc62aa2a3ff0b4b0e55e62a2a38584487f10b299bb9f2965cb366ea8833eb81d65585155ce10704612b3a0e75c4fc9f416ea172dde0e97826ebd61a877dc8245638f25436dcd93c5a6f6dac676a3efcf263f882c693a7c8f4aa7085340b08375b17654c0c96e4339a63d30e63d4e3507385f5b3360fa4d3b8a7e04f06701ec2f3be1b155613849ba154c10ef5a0c943e14fc6c2fb8e91842ccfd73d59b5bcd78a7b97e3de73c6bb5cc0de8dc9f20043ef03e4545703a91ea649abf86e1bc61ba571ddb89a2252191f86784087ef7be10d51fad2e5142ae7b7b8dd805f573789a36abeff8dcb79e89a509b3a8349126abd3e047ba41164731cc9dd60f7d5864687899e623d92f6b87014dd4f176ddcc20b7ada601b57603cfa21726e6ea8f767eba9c00c060be4713b2feea4cf3c2508df13c80792e428101e117105d2fc715327685f3f38132b978b476e8c945fa8abbdf467b4d8a8877b5173df0cc50564e9c9398bade70c3f9334121b062f6fa6caf410cb9d0b137df7c72b4442fa117ab8efcb427ed76c1c7c97105926983162db806a009d27d117f3efc2035553b0085961b4aceb8ea5ad307bf101eab82e4e9f7f0e11df4cb10ab1f1fbdf7e420951662d2ce844f3f6e6264e50f02fa02549f6306c2bcf9023772b4c2e8eae45fe59295672b55a03f74a9ee28b4dd23f8ed4b31c4707aa0a37f4de88d3df3a00ee43a2c8749abc196a4b0d139f9366d2c6a37a93f70f8b8bd7421d981355cea409fa3218cf939a8d3ddb85176bc7433b010b895222beb0f0133bd14da476f5ba3ff86b6e2b45f152d217d24ed03dda6e1d6d9a4f00a45b7374558acc69839d7771c56f6ceb13e1cf0c9034b0f272424fd35ef2619eea0deabf296f37fc3fd9634a3dd70eeb576788ee5f994a451be139d941433c960f1bbdb5d5fe408f21575f789539a0790642f82fa39b6e719f7a6b336e992494e8e976c60332b4c491e09d0a9f16255169a1af940b1616fc4bfb6848d7582f9b8cb9ee82beaf5c0e246ad92f62e05865436545056e12bdf16f8c098b3b2fd7d3ba8b208c22b5bb49b1309a05b9ae3eb2f2b71337d6dd6ecb11703a2574b9ddbdf5cae001f50d1dc777ad528e62f89031093e757e19c389bc5749dddcc6207f1b4d534ae4dad4e5710b217733bf9314a7512c2b09ab8204487e7740cee9b61495f2bf919c1eb597cf605cf949dcb9bf2094cc937c5e027ab791dfefc233986e9acc2cb13c713fb703af4c4dde9eee1640e6217b82c7042d0f218dd5505358c94740f7a688659b7cc5833c0118ba82acad46797177c51aa21b8d7e267e2edc35af9d877c3cb035238a86b2371cefe7fee9a5bd190cbafec065f4d99f6638ba217301a25e5d2189bd72007c11b5ca5f81250e4fc915519416cb9c96ff830e31699b294784b05215e090afd32f7e53776ed5823e6949503ff8d426addecedd01f7e4935881c5def62ae4431f2752d44d1462ad34c9ceacf3715f9cde30d2b5853ad89963e232fd933964f4b9f2b283ed646e0727c224910e0ac91e8929c8e613a45a04bee8e1b2ab68bdbe035029982e269b39da358b32d446f9c4f381c40f5f63f94fe80e37e1631f0dc16741c18011c17bec3c7da079450f79cd8b740b22ef17cc4e1ccfa35bf7bc0088dadd48232763654fc18abca5a69c63e0327f85aea876ccc07f0347b1f97a982404ef8f5ec170196643375cc90eca171e02dd34124c8ebcf648288324adae58c2ce73f8f29917efc571b83fc9fb49ca5c1f6aa4a9740d8ced751df909bdc6d72a7dbd36e57d97c9ba44d9b34f2f263629f9c1612dc3bb3f4fbe9b0e1524673f940f059bf7c578ef0f6959027026380342fa73bb0ef92c11ce1614ea649c9d66acc88ce0c9734e7d1f8922ee6a161ae6b94d67d1c480da865b05dc88a507a82c19f3fe585cfae2c1d61d395e5713f2b01ededcb66347e23d2e646be6b9f43f901f5ba7b3469af65a27b36234ed407f721acd4fd1988debf12727a339cdb3046d0f15527d5e202e047a077d9ce461ca673d46ebc3877c97afca7ceb09c3ff1f36627c9143e8e3fe02eb57ab0b615da7123b247f42661d56a2cd8da9fdca6294adb7183b33a8ea02775db4426838eab8322ca83bea21f04fa7ad81719670367931cc680f59209df076537298192cc810dc220d2d63d0f20da153360a667ab0b9ce02760f3dc1e2356311f35561c821c807798b092f2aeff2485d972c8936b791f21bf8aa7415cfaec5f05452c13d40c9a4080f880fc96f430758ec404316c158e62a858568c9b541986d54936da0d47099ffe4b11a50732aee0d65eaf2866ed848b9552f885ee95563b59e573eff0170ee6e8b6e3a1a4e30ef9f40f07cf1f70aba2197f1d47cf5cd0fb54279e8f693a2d558b0cfcb726b34a14e488349f43d244a5305d9ed3147b59a2dc8d0b03f5af18821e08d2e34799bf2d345b62a9ba6fe88550550f680d67628e55e1dfa4325626454d089460bc2ca4d6d1ef8d78c8a2b97d2a6d69c10934b54790a4c42dd991e3348d721e69152e51af0f671ad370f30c480520da8d392542b3b698dd9b26201366eb4f74e8c4e5440f5245048a121dc4b4c7361cdc27287d6d68a2bb480a21663864e7223128a9f6d411c1d4e6b3052ae4e0fc395e30e56edaeb2fc503a4ff5f20aa9dafcc9801fb541a330d55c57dc93aeda0215adf3231ad4da91771675864261aecac4e0562ac7a5e6c97dd04858dcc84e7ca97be40cc3569d542cf7fcf59046fb9903e344f5fddfe834af2e06827349d9a43d5900f114c4062fba878d78704fdde99ef85e27cdb09b95ca83330465814681125ac44a6cd939c05a52b6cc898140596bcf958ea39e0dee7840696cc6e2037f9fe77052924a654f93062219fca4421e056c1d848274db99b0ddd82ee7702f4a24feafb67e92ed8d2ae3a20eadf044a8c7fd748c374900caca14c805bd6d85d773a67dddeaec179b07a62002356b0f19a9bec1e3df18231833351cf01d5c89f006cf5432edb820137270eb689677e8f19248939dc1a141ef4fc7a1525b6efc55b8ed59e317a339e1440edcae99b45b93d46093e90f7c511a9a05b99cd882ee6824c9572d1f6b286b6334512f8f40a3fcc8f22f16ca9cca777d03fcc188f8d88e08002af12d4fac6d0615fcfc3c77522a1d5dc8d2c0e0409da5eb17489eeb4c34cbb266730a29dd534b8e9a7f813ec5bdb6726c5296b1f50835721486f961d63642266ad8ce93073c10fd8d1ab59a181ff68e09e9b2d1b13451653887c9d66b28e694d5e0eb4358211ea1d7ec74ea0fb11e2a62559346af6875c34ae00e7adf0985b885ccd690752315ad62f94a397405209cec3b99226d8daa1640df26a503e2583d4edc99118d1d964cb66f0f64850bc97dc7c82f7ada38fc3e630f2abf9f9296e51a9e73898e208c329b853765e683e276610fe4998b482495833e527279d4c82d0d2ecf29367a9a271e9e683067c5bc419672f7df4e999d35d687707d8a0d336620fc74638aa4ba69cb9dd6b836f99e90a844dee86e04b0546a2a37324864542c4e206c7d1eb1b65ca1028a9b0803a2f37a8bb748325f40da79ea394cad97819f9036c6ad68a14dd5c7f038d3e37ba205b5097c1730e56f1d49d8586e2fd4a1a01d51b77ec2b8cb24b284d2898ea336d3e806e178049068ce46bf21b406d053f8a4498ca22fb087a5c39c5e22240039b2b861c4cad3ba4561b665c9c35048e62226843b06d0169bfc258ddcb454fa6b57defb9ff1b72e035fa7011ee442cb8b22cd3101dac5b7597be42528a55abd35959a783c9831e81cddfdca0565a7b313aa6e490d18d7bee243d3d494fafe7f16cd037ccf143ef5f344a5c2b7def2b11a5e512f9f3b537fe24a3dfee28448dba3f9486b5af2ac7c719b0e5a51c4c3cb2c5fe42db5a8c01f05e83d1d4791e6a69181b8eb744e85b637fe735f8269b8e8a1b868c865c2243cf6a9294f09922c885c0e582e24ef8357bd9c8e5bf7b12104a649638cabdcfbeb590eb49428e897ad8a39779cc446feee95ad351d2c53192881935829decd842a8818e06dcbcc3459d1311ea960590f2a1b3f6fca2fc06168b5ed4c7b5bd4c7a1ed986c308d682c139cb6db0f4afa65f08910df96b3e8c677688de0c538122df279be599bf8303ae78cf87cb10aab8a8ffa6d1a52a5f29b69dd9aa031cec4518def704caaf4223ba70aee486738e6ae2875a86805ad475029546b5fb02b217621506d6c1d7efc6c0ffa1376b39fc38eea47c40fa9fec6fd5e87c9964cb571e064c31cafdf1dc40d9f57a33310823295e85dd9a5b121408509d8b1f43f1720a509cea83683ca7925b04f1f40478a4c850ffb7cc453fdf7315006aabbb533592b569a03bfb10034b6fc47672be2a2ffcd68451a40fb3de6d3446b421200b602383584a5356b033ce835824c0d2f5ef8080659c3a65e6997139294bf78b9088f029c501896c6f4632c589e1be44c37e299331a920c7c49aa7d21095e978956ccdc437560ebd667739513adbe1f46fa1f3f9717ce94645f9e0fa5554316b9dbd7407bb648678e0ce2e4b351300ab8e21441962ef4c354251ca421b88a313ab999cb64bee557b329d2d48964da663f7d04859f8cf3592834c2b64733259153d254e7f873dab24262519043621fa6642e40847ee4e76559d375ea6af1282d3b313ad7821a50157e06a12858f9179e1ac9ebdd1962418dff127d58e7b8115c987cf9af1fce4210013b272eadf2246b422f868b84e30773e53a882708bfe642b1ad006077ebe006af7fb1231c9bbf84b2734632208cde735a30fbe8879d5726bfde340b7820f6d2cef1b8cc35bd953074a989e447a9dea81cb8b7eed68fcc26bdc5731723a3034e2c6532f28fee663ecbbc590616073030d4e47a96b08cb98fb71eeb8a2c446a57fa00e4643e4d97c70f60b25815bd7c8248c3a11bd0d2673f7e11457183fc4f5b714e2d0ff893c7e9ce6121ee3a1f11c2146988b28d303549857ef8fc5d24dcc7452fdc82bebaab4abbed02d1d09d7920dfef72c4f6e398ac2260b60be0b95cc912b41b254512ed796fa6b26611592869f3e35f5c703b0063d93f22b6438aae75c5586a1fa9b567ac78b0787fe7c36c59d0bc70a7c77cd050b237e75868ad0c2bb455668e9862944e13d53ec29d7a4a98ff1e0716d45b890d5993591feccc448a0a3296e86f821b3bb33e10400a0ae52c013909eff3bd96f8beb10c2566b7ebe0b63d4e8454db688f8dd679bdafeeb9c079e575ce604607651276962da6206c8a48637ca0708af60f27d2242b3c8774b70722798773d3285989bd5d86a44dbddfe2a7f1f34afa7e3f5f857341e35fb0db8f2053e4d3cce075018fcde4e1c47e825fc662f4dcad574aafd12ef7bcac1af4f39537d0c509e2bd2cfc60753b520ee81c4554fc0ecc032e1a7cb54a5bffcbbef825123d46f6894d9db1e1cf261bafaa65a783cb4459e206f0c662790cae39c7d3548617a2d4d34e770228f311d327f55307ac36f465d35875ed35c5bb6ad0f249d6b0e1b74b8fb8d18b0bc41579bc8ab7be692435aeb30dbd213188f63193f950d995020036e34e8a2d8ba23205d5a10c8ff12a7a91468e70133e3fe76a56639d11f54656d480ba89be267f1d10d365c02070c7664229c08a733af8adf27cca4cb8895e7648cddc78f1d9b554f7d52f71cfb61e8145cfb84a056ebf21fc67cc458f47324d1f00df40f376b513224c34e3a40999b6d86bd89b21a1e33a6a9a1e016a5541d92f9a3d339b3b0b1d249ee536c512e92c2cabaf68eefaff2db92c5c56c7ad519e1e3232b95eb98c94dc1c561a946e2842cfa879a564470efc66abf11fcf38524cf68d3a81544b785e3e1272ceeb77d939e0206ced857a62973a8e907248cac25417559427a5ae0579944c5395ff11054f030902e1e893952fa7a8b18d7eaad7620cb6b8cdf0f238e57522253ba065d95ef8033b0dca33540716e9616fe7aca4e4e38acf07f425bd5eaaa1b3b913b5bb9510585261db0185ab76d0ec6a3abd7b469688489da515bd0fa6164115d48a41a2989e4e4582f69d177c88e1e0bab5746dc42b68353aa7b9e8e4d691d46d8f33910edcaf3d0242e7eee27d71b5ae25d96f6bfb4f06483a9e175686dbd3372633ac3c0c40f120e3e0bdb4ca2e1953f53a2d1e0158de884bd95c1b25c75c572e3eb8841af0c2cf6756457f3e60f4dca278ad1244e5e0f81859fecad1a04888136615f1e152a24d0ef8049d2ebb4d7be031763ec1f824c24012065f9caa43f36919bf7e04538f246ba913ea98d87023eb95ee68e13d8282cbd7def2cab536df9ecdb0bd533ba4ad0f74633a14e683cbc1d686813a3db09be7ecc75edd50329c5fb91d372df40a38ebc0ed4f04cbc6778b3824872466056b1d196cdb688386abc3ab18637ace07095812c41c40e4c9cfe50005a66e8fe9a64671f1b469e6dc40d31325b935621383963ed6ae66748bd2b5a0faf9322997a3d489f6cd69144544825a10beac7f4113867519182756627c4e8abbedcf06ccc9d7d07730e7bd34de9fa27836d2baff87d9b074d9b008dd9ed63fd7bf388ba7f7a3b58f1e94c030db449a9bae255015f90ec2fbb6206ec85d32f703c7c26bccdd4cd8c9e870ec1d11139bf1a0cacc23474f8ca2b1df16f0cd58bf01aaf34df6a48e84226142d7c07df8716d4052eb018cc476c21f98514e31d43dd9e76f5b75ecd563965ee24be0adeec05b8d16ee171eaec3d43a087a27639459791464ff0959df3041026373b3c4fc3dbbe6286dcda50f81091d42f588756b4f67fb50aeeffc258068635d65a501f455666593d639acd9b6952a0f4e1fb98a2da8ad4e9b6795d0c2d77124c2fbb2a83bb5c85c72473a73cfc5f43c3dc05eba3208421ee2298294919a8a39239abe87dbce5b3c922eb4a2cbc007a3769c8408b9c473328f3f8da32b13033867154d2c14184b37393cf890e8476645ba157337d221f5e00db832d091c536a70a3deafaa8bad54eea4d246183b0260c5a705321bece61a72d2cf1fef7bedfe8ad59eb5ad587aafb2afc331738f27e0a708a065c5522948b1d4cdfc499652e1795e5ba405bc1ead638fcedfee54a0604d0f2b772c2a2d2dcfb060e0077769ee88ed395a68e9986a3e4171d77867053a4d8e1690124572ae3951398791c48972e0a66efe70e62a06ff53ba38f3f8ee91e8b091e7dbdd1306d507e538f60471f8e58aa7844de3532f0eef7e03c405f97b98ed2dd73deab4c429e584da4d966df59d1df58b3c5ac3f9b5f232e3790c74400f3cb77be16a392beebf3ef8b0ef99ac49b76e933cf1e64b0b3e7fa67913154c4c99494d6399442aa969a845254f7a42cd313e5e590b58d5956ee85268c92938476bdcb43a11c0cfa5b0c6da77dd0122e87745f27445d0d55c8e3d008d254accd5e16c611a1d2204b4c752cdd2947f0403da917ee476bc5e8b8bada3c5bd0dc845a8882edfac8d7bd19a576ab46cc4214b80810d8a47dd303040baf58653af02f939e7ea8ea595a9cc06a7d29b47d898b212f308d377830c834ea5585369485fbc605e2ae7492929fc62e271c5bc4bc6a131ee7a7d9dd864c20eff0d3eeedd686d1435e5c8e871cfc1c4d172f451ab2f7233a83c18b66f52d9d5ec1423801b69a5042fc49edcd62d19b6a1cef298d0ccbe28bbf6ee03bb27ff12c717c28582dad01f718861744231cf3760f27f6f8caccc90ad10f5dd6c2e6e92aa4745efc0a39f96dd2cc18316f46b93f3ab9802b593638a8607980fa900b705c491510dd78dafa7b7e3a1b56997de52c0d6c09ef698c9179a802bf70e628cf87b7b0ce586eac9b1d8a7f2ecfeb2422047ed93c9cda39d6c4b81804edb905abc0233b8746e504a211e6ed5329b8df62d6c45db0364e430be30cfb596d47dfa8dcbf78beb4e2a0face3117f544e31c2d3f9b6ecfaaebc122feb9b3714f83f7f947d9ece944a5fdb3a4a4a697e29a3159c3cb5364ed69ec15ff298e296edc84d33d4d8a849ece125cb5d904bada8c2b7369adb91d6affc3d6372d1ec83d2f84a2d91dd3cad2ca84560d3617eda8ff4e63571d446c19fb36c6702ca78111b50ad8a15feb52dcc78fb11e7ccc32b5cc227ce8c55ddf1914546eadcd746d5e5d59d5c84a794c1c50e57fddb087c4b6b6828ff25eda90c985201be494639eca91785697ee19a1bd6c1ba34749b92094543856a1c85a4256fca620f439d4db9b0f811fe8af32acc70fd7da4ed1faea8e511e26c9c3f5950ecac4a945d70d3bea3c33cf39cdee21e2cc7eab67f751780f161b5f8efcebf74ad397b1eeb0520265c9a16cd725f4a7d89921d1d770982f347d09c70bc38d13c3d41f0d59ea28bdd4cbeaa63f969e3f4e85ef2972fd32184a758e110ef86373d0337581c72f432f6f11d3631ae730496192fd90b4c481ebcc76b6e2d942ba56f88be3312ea59354b67b36a064d2debe781ea44c298638a34ea04c3dcacf4324a051062c5f56d250da4aa64e19a49b2802f699629b10210587435a8d4441b34177bab70ea381bef98a900fc9bf94f652b879902cce2a3ecccac5dc392a44354b548cd5152a64607f41a853af7e27838286c6ba3ca459c24971c00ff5b9d2785635a0b2d0a1327f203f34b456619cbe4ccf07b130048e16982bac467c56d65e1b507d459d3b1b523474f55bfc7535d4303fe2c17019c63a47c300d21b21340d4592ea3776a855f2cb13a4f39dcf632d684873f784b000b1916c5135c36723c0c3670a907f5010c6b604f02c7ae8b89cd31a3f3e4216cb82e6a39648f133b6c9cb1c5a8caa07ecb2c79c5b3fb4fb4606e57596b991d7b0d21035348e544a9866861ee5b626630cac025fc8ba132633fa47c7ec249bd48651b3f377e2544dae81b053130c60a8fab97acd4e0e9ca671b66b4be874cbe4a6e99c923b39bb9a2ac08f496ba217bd36e17261b71db20a0413d9f9a13f0e129bf93650db4998b10ac495a4879823829bafd3d791f6b319daed7205db2e5476f99ce84e6592d330855ff9d6f5df666251683969c2516917da64b0f2eef46351967b21ab229449e37e1fcdfead78729d75db2a2a7717cfd087de8cca1f8844083a7612efaa7c40239d853e48281dbb91ea8e392c69df2f6b833eadbf011f3c667d99062cf0de81b82de026a751c2a12debd361d0cbce94efafd067a83ccb1a822e1969ad2268c86bf33e76d336970d1f9bd6b1a3e7b97cbf51e27f5cd025ac511828f75f70f0b3f6cc8453c2dcb6f28daeab3f6d026afe4cda6c195131a91df54d756b8269cf7843a34fe8f2664b8ffff7d1561c07536d55f6d0e04c62326cf17f11a690a5dc65dd4ed7361ce4706a52d364101ec765b25f680c469b28f5567c0b41ae73156fbb3b213dc3533bc96552b250a20f2c89b93bc738302f1b059c30c85d5c7438d90523efdc13dc44776b4f1c4ceee7f1aaecfd18ca6b52c257b743034fc7361d4fc324456dbf9b85d81063bec04271d8a7279ebeadd7e42e20b0dcc72476a26064a70abff48abf97269b6308de457f5f2f067491b732e39527f2a67ded58c91b623d35e644fc3efaf9fb33fb4db546d4368aca7db311dc698e195fed17ecd1b4df33f1c67fc66df118c692848d928af72cfe0b4d046781ede29489a873e8adb97ed65e29b1d95239dced5fb68f89d15561a932c03d72ba96d7e9576a9a368c2ecb6dd2e9062f65a449d645d3f505082043b3a9403921c5c03c4aa345c2ed2c08975bb1c3043ae0d32c933490c5954f5538401f1af124922329846269444c509cabb3e9de422fb43708140b26747630e050f332df622b437802c2845c3f967a80be502d07bc9cce277b6348b653530c8ca94c66ff0fa948edd55508f0bc0b31b5f2efc579ac524aa5a07673dcde321b80639cfefc981b7bdc64c2152561846cd3b4889c72346de0dd9b5a9d15fbcd7fbd95361c951469f503750f7a53c56f591a5cf11a1ce654ef6f9036f97f5d43bc6a58fd8917aa2b2f4871df0026e23ad9c668472a631726368b4a1d4dc43b34c069d088b70828aabb7976045dfabfd117c143b3d0f3001de4db959fd632c3745270bd85eea7122f11ccdb404185fd8eb2c83f08b636c02b3e4eff3bf3235745bdd4da590211294b6bd70755c2395d1102e53778c035b503374e99ac0d0b3bf158029835075f2ed88a45a43293ce282e0ba04f7833630b2ea366ebd1d54c406f1ba227fecc3b3aae535aa1acda842db3ef7117b80f37e6b9bdc556970ed7df04a7f765f83a516646ef8404e2bbb0721416ba2710d1804b3ffa8297ce76f4147439926c08161126b6ed1c16b6f90726ce6af743b6eb33564b841eeff2c60d4d293a2b2fe5198545cf47c5338f16e8e7b88fb236d327801784c36734f104c93a57f2d3e7ac8d29ca8e941da50066be6f8184e0400dd3b360abd4663ceab273a7e4d0a216d020dc1aebd520658cb73700df1d2399c4de56b22b566c501b8d4e1c3c88aa1c1e2c416688b5b724a444b780e977b60989b8106f55c6505eb39efa6d98c77742ac864102b55b139d97e02c81988799571c6fe78e9248336746553d2865309c16fe7b64d96782e9a4131b49a066060d727e31b9e2ea5b5479a95550d6eba174826ae5b6e5d2accdd903e48cbe0399184152b51d489de26fb5f2db0bb94f51c58b6f786d0cf3e03c662e22a6a9e284919596fd8ce0a8395c6a82e76ba6ba73c87e6b8095a320154b7004c5307d85276bec46f48d19ca6248f90dbb809048352ca47962b7b35d66dc5eac7c164be72a1e446380e4bbbb5fd697209eb4c2454babec27c24fbe2238392254fb92a4c9580a67be06f65206c2146c32f6b83d182c015c48249c900860b18964990f54fedf88cc20636782dfe604215b9709562f32c31265bc90329b275a2c546071c00111c08ea95ad0858f36ee8958390f597dfe807e340af6e78b3b58ed7d50a516b8ff5b1dfd55ccd89f15c5200efc86ea378213508a95f80dfe33211c3579a436c596f7f7011d6506a2d4eec75d653b49edca3a9685da1e19ba7e5efae0c7cd79b6ba88bde29cdf49b67e3b259b0e5998b4b02326eee2a5cfac71b2080eb7facb3e55af0754ff2cf58cc10a5c117da2c6f0f66d80960d0506c0707c9d64984a82a30d03dc65d6eabca98b3e31427687ea8505deadda4e12dbdbb3ae5be7f3ee5f66f90bb023afe6e1429e28d0facc023185f67665763b5ed98a37da81d01a3830ed04bc2c3eaa25bbc2f23f07dc892d7bbe9bff473d89f04f9a88cd221000442853fb214105dee2545073a8f71c3b483416bf8e49365281e7d815e237b8cb4921dfbdf0d174fdb710a3477b60ae73fe5d5913fd226f6a62e89db10ba961173b7ece38be13e18fd2a0df81ece6caa2f9e9cb3e6e2f8671afdd099d1703ad82540a3f85656c87f5a6517fef32476187ac5f3cfbcb4842e76a66e1146145b43a441e0e7093105c5773647273c92b37a42d14d4a05404a4e60bdfd4344bb3d2e4f4c2526b2ada419ef6198644da47002a8a3caabc1e79731a8b8b06e9196dcc12f9701cd0d00f758485cea7c979dbde714f450ff82bbe1292b23377187c29db419ec6cbed031d87e5312e4483288e005d4f94c09321e9fae83f483c9e9652fbfd64027c34d29ead4fd942bec1ab6ad665c4f6c404f1db2bf6b763f18bd97cdc2b534868f1a3753a7105c4aa4fa65e7f048781d750f43f40090613436b8b18a7e4291b2d65656f338499ee641258f504e4358a5260f8298ee4a2550d4e50817512ac19fadeca6be434bb0ceedcce1424525eb20c835e828e6bc158ebceebd168c18ca27d4ac127d1f38d1cef5577b63a5fc76d088faaf403352323c8b0fa15509f529f91b7633d70fc02367be3bcea737babe1f15483a534a0e806e28f27f0a3f0b502c34e253f0685bedff9910d91d17e8cbd4beb4bad71fb1ea39138c8d164dec18eff73fe4398a2a777434ba54e07fe199ca2e285551daa04fed147b7f5829ecee8b1c8c9ad2ee8882c41c1b9ec492fb2e8058508beba151c5047bce1e27faf9a01ddc2e5fc5addb50edaceba33a00722d28e2074e8a8824e5606b4917e8a38650e4a01ac4c189e4f6f171f945d3a78eefdadaae92b73d214b27e93322d908dcf81afb69c36da51d9877623eb47fcffc903ce68d8e56ea203a15b22b31795a2676e2a310ac19dd4242587d91c3308b0592d16d4a06cffe0d2b54b04510795d22a41c3ab4c9de75cfaaed3c61f2d3665b480099b79e1a9ff2af63afa3ceee5da4847a30a33d07d305cf0000bee0c5b39f53f2af50c8f02a839cbfe490cf42bfa04124848f28c35056bcc7494f06f7f32ec5bd0b3283f678b55299d6ca2ef40deac7a8219bd352e3d7ff55e10b977a2d16feafe8400b3ebd6bdba21604c8519f2377bb5104433f204328c144fba508ddfee83d7924019eec6f6eac684b72733bb473cbf56f102140ea426774d7033ddb147b0f386c7efbdf1bd7047aab204d705754cbcb4fdcbb900ba2b91e5c6773bcf575d63f09f5a2d021c6c9aeb956115a676afe158b6c885283cb748a85f102b74b1dc51e5c7688229bb14860c62bb44b019ddbaa4ee6be15a81903bd568ad8f3aa7f14ed60431eab846a90a90b3720e896be2d9d902169141dde6f35c343a182f071a68a877a6e2c0b1731ef57bf60570f18176528353d4bdef32b2de381a53912e04a1955925eb7eaa63968f320a78b025c3b939fb0598c8e26ba8b58982162be283fc77e74545f9c28cd396c29ea2a7af6f3d2ce4cd7320a00da4153a4bda4998b72aae40cc0b763086cbb3f2a91eeab8755492629a8be8fab24cd5d59f7694d13fb284ced68a86822a638758994d7dbdeb36be2ab33f77d46cb3a6e7ffe4672f2a5e56f04fa34cf863f12b348957e10ec00a5c4619faccddeb7b2f80a64f5f83fd9268744262bc578df1401e301ff9f48c72cd7db3ff00d22bbf94b167c441c519e23fb2f83f8ff563478862d05f282cc17bc89ab5773664be3140af353923051b6b3bf80f89a8d3eb3b2bf75a3f11f55c85c1831849ecfb8c6c23b21e882b5a9f751777093f6d097984f094d23d29441932119ec8a3b44d200087116a12501470b09560452a27a4c2221734aeae784d6852f190e6cccb15aba8e6c69f6b40e603e5cf308931be31a7bde81b9cc8be13c7bf81270d20df2ddba88bc8552b96a1a168c83104a13f5a9b48a04ce7b80b53a18dd45d0c40e4b93da6652b0d119789593707b4f6e8c4945f1b573ce89bfad37e69c0eee99ff767e3620ab8e95305c070df5fb016ae574a1ded54c17a8d73725291125a438ba087e0dc3b41ec63fa3e21d7419d0680e0e5b3e4e67fa89e4d1a4485d7704a5ca9d070fd05c4b61e160a9e9cb3c7ddaad1a393ad73f7c330b6b337473568057d48b28397798883a00dd15b1825360ebe4871d1e66ca1b098dd0a9e401a557891b0d8d554a6c221b343fdd189aac3322a3890a327936b24573e83c40c21d026c5c418cefd63222ba2c07b71393d37cb30d2bd0a140f312fff329de49bc7c1bb193f447fbfc51289d8d41adb1dc1d287535027c9b3eb5962b970559288ff7dec17774332d2ba58cdd9a6d77e31e408bd9288177d12db962b07f5a916a62d72d182209a3b1b182cd78d8676ca12ffd6dce2256c858374435608b4f6e2ef907dcde8b7509ca5c727a26ab290257158c946516093392726097ea68420465dc5ae0e0fe51bc85014b7eff6aba0cce740828aaf2af35f7e643d670e5bdd35b5d878974aefa871b246e54d83269d2b62ad076c51cbbfc999bc976536404b77ddcc9a76ca9554d1499fd278305c0aa58f3d5eac9da317a7dcc8e59057844eb15cfab11a5e1c7f73651b901893efab8151409327e4b3a6a6e12b837045b5c8e164c10c4d06b95afe51b6fc72b8669c41eedd133885473d53ac4c86a5d64a30bf52c9f0b7ba348268b09157e457f679ca97e8e5217984e4cd7613f1be9fb38150e907c78162a76ad191244b4c8cb38ec64b4dcef98ca57d665fd1b0e3163cbab7f9ba501117b31549d9856bafcc6f381cca841e5a39a31f0f64a55b57a7ae86e0f2f284b1b1082a3f546cfbfb0198a740832b9c56a1520b8b5e6351c978ce6a074e319d911b7eb3944ab1ce915519de0387a70b702e9f2533877","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
