<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09a10bcdc2b6521742a51059026461e4a0228002323c7c48a6769180f8a05b8fcd3c47949f3a891c626112424b78aa99f51a4e695378434c3e96ba2841ae875e93b02c0a0e7c07f5ef07bb8d07780d7d9f8cb992747958f4f870c234db8a379148ebe06d5fc5ec57abfae8667e23bc1547f486f0a578cf62f4a43a8d4161da7340989f1fb2326447d7c212de48253f4528c60c847aa57698c0d0f2db115b4908c5823e25b8c032411d420a5b9bce5746db580d1bcde0538c92575092e9ffe5e5e7e69f69fc30640607591ee654772aa88b8c88f25894840a3c2428760147d8ae2dbf90aa2161e96245b09f81d09c539e5a360692bbff10e8927903f5543f871ed5d37f71397145aa8e2e96c5e34e676d14de27945c2f754f66ccc56d770ed5f90e8bc01ec1c53819108163d7aa9c9a8130c40d2c39933aed702398e1389fcfb7a3b2169d7bab2e295847534c11b1d08841f5dac0fa07442095809dba51e3b779b590bf8a20baa0a84961bb240f4732364ecc61568b656a449eae5c6683b1221df782e28ea1ebb5e10e37f6aa336aa0831d1d075ccf84c46d886163d5a03b81c2cda7458a3d76f89544a1cc3fc9892f6b5fc211d9efc1b842bc10a1b4ebdebb11b011572f2b4b9cc785e8b50be07c15b8bf66450ebb8c2caa4370514fb66362ad1b58e69d2c9f00c0a3b0965ca480726ee74b6bdc2d42bfc9831d8d7db7e9b417e3ecb63c9d7793871fece1c64d79826fb1e2087ee7561e8d23d734f040c09e5104923cf325493b7c862229450eea1c614c14db1d2c5fda658b4a603da92fc16195124938ef0ec808f59440f3677b32263f09034f80b50edb7f93ab03432282d9a32413cb2f2fa41ffabe8cc50b331f3cdcaea249375561d7c3f11f0db4605d9983aa0fb3d7b9ddc677223a4a5584a458a4f753edd7117e8e58e9e1cd168500bfc2663e421c82171e54ca8363805f389d984a8830ac699b79955190e388e7870d390c9054d7f25b8f9b917004cae89116bab65263674e9451679290fdfbb7adaa4af7a4504b359f2f96c3efea7be4b437f26a17b63667a3f08896fcc9c6c15d3718854a4bb64453ca70f779e3eb8086793f7f887bb8430096c2e8e3258049b297aaf34ef9f4c04d590d728fedad81d4a9c6ffa7122c88eb90dd193215ce1a37fb8f9f6a9ece69e2b126aab5fd5dfe71098aecc55a2318fa3582b13fc763103ca98b46eba87463ddb676ba5c67572e432e08731a3e69459e7ca39a88a7e0e111f07956071871c944113afbb677a2894cc83236fb1ef81a677283221760d7682ef1cf642b13c90403fc6c743291971ece75680bd370f301fddcba1bf32bbd733ca43d98c16ce8619903fc7cded845f8483be8e8fa6c9cdee33d55163e9308699d7a29f03e5d410897ab9233f4d68240f6e04286c699e36c7df2ecd304d51a1a3d1d2aaa0bf0748eecf6bffbc9f8bc173e354cb058e1ec0cc0339eb5f11e43ff68f2d3c8de8db69e2573012d947f01714d4b7a8d668719bfd3f88337d1a50e949b55726d1bb00202e698883a24dbfd14aa342bc9b308f9708539d3f2205c51a2d8482c490a0a13a31f7c143d1eb7a0a02770d6800a66637a0ac9daca24b9bf0c807fdc810d8279e9363783ce55dd3f66c2846e4a9b68c02f3b1351d54ffa4a17dce23a2da39dcd157e2d77f4d8e0e9f74777624ca626655f4de68fbdaea43fa25b0b5907ed6b0251ba3adff9efac3de1f842f5f270ce2b79884e24fa2cf90240dcda7788da57f731fb19627561700da2514dea37ebeb4d219231e3c7c5bc228445a0becce42b7c32b294ab1cbdad957995ded4ad4b21c667fbe0a1632b31802ad0bf2e0c11bc4761cc5b0368e9a79126b657ba1f914e91de96c76ebe1a2227158628c029f2740ef66f94c7d74bc87877ff6b9945fe1a078f38ce8be5a4ca51fe8e2f212db9c1c670116acce4a70924d3b5a9fc2294195fdd21aa77fe124a9f451c628ef1a869b3b3b6b2c0633e0bf707572fcea0cda9bb09df223984a558ca7029376d07176783279fa7cd30fbbe902db258fa5c23ba3a8b5a48b29f0f99a09206debaaf3bfd0ed88bffcbf84c3f5f1915aabe35b6df3f660b4e5ba70dcea6c7740aa740bc5e194b4490a0952f32065e8add631677802bb0e2dd4e54b8e952c0d524ae72d88f429250c506f103e6080409607a9804aac5a981929f4f88d9750862229d16fd9c6e738e5bcdeaf24232420bdae208936ea27b12bcb1893173153088354908e0414994a8a6be6b8351d64abd9c5838d977095d02ce4c541ccc67b61e072f35c43dbb5920b0f510b013581e89abd29935dfc8b6fed2314166defd7c9bad14707dabd8932f348085bd886c9ffdce2d57e800f58cccf9c421b76f18358eb4d13fd9e13298b5bdd41d2e8a71add9a7df9aa5ddd3b539273f202e64195e4c315e2d3daa793431d2710492c2279578fab3b03d25f989b391ff25e79f0c466e19e9f72bd590f2f4042f0ebe52a0c6d2762d4396bd77b020c46a0a3b20cdea46f8f13ee9eed7937c19361b308edb48538531e9d0753d967122fbec3d84fb1ec7daee43f9c8a270873cdb166d834ebea2dd8cc9f874e80fdf20de4217b2353d0d3673ea7343f7f38485c318b118d237a30ea0f2d78091729c7aaa3afa78e768026aa3ba5489144b9775aee5a136a646fcef3731b3754775af66c786cd0262e4df97ee9be5673e99849ba07add27142fdcee6ce5606048ca9d67e68107649a841fbfc4e5758df32ca701101870478a689a8d9ef7aad73d15d6f3a4f81bb0b4b36ff1055fccd5d61c0d4f6bcd6607a1a18e1c69a24c5d5659f70e1cd3717dfc4a6f4b177e025414f3a1d98e09568f42ed26bb74635ae60553b14d6c54f5818ad4ce83bc5b86076b5a3b08b7a641f644b7ac475356a59c32ffb40702bfeee264de67985586655ba219459a6ff19eabe2c4692d63d7da7b33a2824a4183727abc1de421fa469191ba80f529d215f7305a35e7c31360df45d9efbfafcd0455a77cdfe82582f20152b8d2ec4216b4f9c825ee395b7f80b5bd648a6561af39c64fa52d9efd648813afd7e471e8dbe93c402ea29388154d76d3b7e237e1ac0f7cdea1df965348f92c975a494bad08de7fdff6ac17a02fe68724c7cb4103f64ff30f78fe0783c582e3a3c9134c22ae8dfee98d86ff7d0fcf894a3b911e9b3cf6c7ae9a8710d15b87751a48919fccc2ff3a5170bace2fa59cabaf6b2c35249e13f697d6dfe59f872736eece59fac85f776bd349a2d9b84e22666600f9c267dd53d3b6ec5b775e9c3d614f53e042576d690eec2cc582f99f3a261591c6603b2ad166d769237eff93cfcc72c1fedb53cc873e86b38ecbd497403ee32e617474aa65f54dfd7c84131b80a896b2be1ef17104b60758b6713c5ebd8f767c26b683253717a1a2178fe4b3f2f8002b8907b69ed77c7dc94540670b51e88f2c8d1bb582779d5fb9c155c35c0e71d3dbc5dc3931094ea4f2d461d6830e00979217b90c504094d9efba2741f981e3a681d4d24a41b199707e0de36ebf5903d2c32528eea467455544f8d71be678e37e5958e0aacb0fb482cdf58a74435b5c3bad9ee91a2acaa4ddd9357145fe0e83cb5a485e4e0485f44b3d382e8dbfd31194e4e591eee2f5dc42fa07b3ff344a7732f13ffa933546fd8938fad36fb0abd289ed0b466c8fa163810b8b4187fdd60394db88e4e8032f770b8ecc4c467b7000a656996d66e2cae2e17331177476f861013ad559130009a09a70292b01534399092f382ebda8ba0d242ac10f3a58f71ef3c428994f71c85b3a214daaecf855522c472b91f7a0e244efb690f154db186d0153a0495921cf8715846ae672ca7a29051f55237adb1b75238f6bd9ad8995ade251777c93e167e7f314c913c5cf0c11e4b27ada085d1f9341cc5f56f87aac804f3c711a4a31f1af37978e8640d5b48b3261a14f07419c2e2a628412781f17f40c713dbe40086b966b89dddb37490dec0f65e5bc5f440be4f10bb98e93be6b3c67d55a396309bfa6b087b3427d32f8ccdbb934a754ce712eaf7d92fc3d3b590bd4e6df0be8aedc06880f2ca0aaf61d273e88a258a7f1907225050ac7c2faf65154a2ec5d0f0d7e7b9f42b4021aefc9e053f7558548b11d8ecd5d17cf0db333cd32869beeffec47938d83a5dd353c6cda5649593a387bfc0002c3a6f9f9890c68e626fbdf927fa7b305755f69f539d705a9a041e2167e47c4a82d548a5c60360162a3d5d5c5cf238f02e123b3664c72a5ae3e000f17c2a74091edecd9243433ef3613660bc0d7060e6821a8d8a3660bd59ee2d067477950ca7756d826d27901740a6a284bac77bf517564e8442706c1bfb36acdbd048ea2a59d9170e810774bdf882e9a056caeee6d566ff8bea565ccfff541d2baff0ff0078101d5e658a81f07ee41db86c5afead57ef1628b996b9c2f638b3ae3529071bcc4892ee3daa2a95692437bbd92b2840fa3381ab0aa2f0629fbc5ffb3be5b6baf094186e25c07a5350ea9e75e8c9a8d0ba150a4b1f3db919a0d1bbe7a0bc14c9537fced568b3ecf8717b1da14e6b67e98a224ed731de5aa41cfe84f48c67c7c1512d2dffcbeb01f67acaf7354196eb64f0c903abdffb33e3ea82cb3a75e718fe3cc9daaeaf802fbe176f102eaa86881f335314571811b57caf11cc40d6ed926f3a6e9c3300fdbef8dc9ebe0a5b1df3f6c41001c6d39a4a86fb776b5885f4d5f6b02379da0103784c3dda5b2cc1a80826ee9ac5337d208a95ed2a74e68e0c194dbdf87039d4bf800edc7bafbcfd17c89217f6735f63926a8fd039fd4530823cb39d0ca9600caa48269a90825f05231fc2ca6731fdc5c72e3da86fe6d23a5bd568591b46dbef2cc8fceaa867e264255edaca2a5f9b3d8e306af3052e8b254ba45b6d98e0ef765482d0e08fe4ef3c50efb0d71c17bbe113c8239446966e29c5365d161d2414d6d568089f955c17c463c207efdd1301a88a6a73050e95fd2bc05f51a041be9a123fadbf5895f25340a88b712f1ada9dbbad8e0b1fd64421852f8495487a787650bcea0acdfbe702ce2fe59d0a8184fdd43c29d8a8dafceaad5ba19d9a983df11190be373b97ecf11972bddbefd063c7a1aa034d88fd0893a19eff585b1fa05a0069f30ffaf70ce9119318f8e14acbafdc75d5e804533833996404905b87ba5002cdf898776b37259b7ca017dc53a317a57401610e0f17dc5429009b15fef662f45212716e8e785a8df3acf67ebcc676dc9a5d025820920e44825916adef2f24fdb7fa993662366f9c2db1569de3cc33d3836d2d84972ae8a59cda3dfdfb054b0d08dc1f2f0d6d49081cfa74bdcca6bcb63c4d710d77346086b8a4c7ae1740b15f56b471fee192f45d294a0ee76ba27c9b29d3a31e61aa70c92e8fc6748dcad75002fdea42d39b333eee4a78a3ce13acd4dd004ac3b5acc242c4a8c96fd14ee92c3079d7ffc6b32e067fce757f695c046e2c17c3c6a0e7b4996ed4080fcdd3a06c10111a4f80f2086603c54ee2304c008513e35804c210ed121fcbd7842639f5f671e004cbfff78e751c94a8045bd83816e372a4873d83e64d16ecb870a6570132da5bba6f5bef6fafab6ef17ad292992e3aea3abea981890cc4b3ba2804def6dff05b7429c926b8a6a8dd1f04efc7b2568d593500871571adfe46c2a9e5807db2b0426c21970b6b2e0503004ad277e3db75241ff04502142df1c9821a26f6fc816c623e78101a9f3efd324ac806dc2f6d4854b8713eefc6ebcdd8c15da9474b5bf48e3f5d58ab4a7ba8cb2b038b3f36c9ce5db76c20904277edde1cbba2471b0ece98362010e8030dc35496e177715eabd221c213ef714c15ddc62fb577115c386cca09fcb701ed0fcd139b80d2dd84183d7c98c42cb3ea7ade00f64092b254085045a5395f83dece034877173fb36b192af6b68d8466f375a05cfccd313c56270a4274d8ef759f0d6690a5aedbf590c82a833f87fa40d435fcb5ffcecd3974f75bf523944bd40f83a3a3b508c8d98ad913fc4d0a3814f1e10efc8398712a33fc1384000d8af7675afcb25ee13aea9f6a9c09260df06d699d3a4352ceadbca97496cf7cd55100fc5f455c92ba7a2a69268b25575560876d7b0a9b109b5fcc5f2b1317f1ed7103803cdf1b3be1e98ebc2fe3d49ab5b68e45a999793cde6786917f995fe640e0d05c23a9011d003388ec458708a33097e26c56119da1de8347932a1c375575fd684dcb07cfc62a383a06e4018244b9f49c68fe2c6ea75f992910a1c1df2fc9218fb2c877ca3ab646c6d6846943b3f3ea4c908bd49059e1ebe340b178c682e2147f9ffea84c4ce507a521875342c3364d5e0670ccf8eba186b5c814864455e8ed649fc661ef213ab3a8463efc210f5de44e20284c3774b0bf2e104079358b15ca112a79f3fca4117a7eec0d3d36ba9ddae714890753613be2dec1d0eb216ec827d1f6fd3be21f2f802e69c8e63dfc763a7b4d5a4468e9fe1a25cf3f3ed83785ad04a6cfee3153c986c93c2133217ee72a4c719b339b27a97c6cef7a671345758abc9b88bc2b6780c86ee6e8bd92250565be58e5af803b4bbe66c1968598e3e409cb64a141f62b4c63072ad77d296e817c7405ab7b065a879aa8becc3544f93b5b7a97cd01277eaa76f0d2af8fe728c59d89e5b7925c73aaf4aafec8c3bdea5708bb063f184694b4cd2eb9122a5103c4ec7ab17149f10c23be7df46ac1c94eff070089a135d74b075100142d4a72701095e410569102c56d653db2d940f20e2ffd66b5fb8b4062f4c5505c2065fef92e1d12d8cb4c3ddf8b0e7a02f17b3074a860cf357f71ef82c3d23b70bb0e3b6242230687f029e39ba107497a1eef4134a566d649ad55612889e2fc726166acc27f85582ac8b242a14f93d7194df7175e6cb7a7b7e7571d382684b4a01d8b51c73e453677349b03bb43801371d39267c254f27fa92f0842b3cc77a1e5781748d770dcdd7cc5e66f443ccc396cf70ad82e0c96b18e50f0f116ee5e57d639365eacd321a7a7d503423a2065f62311ff5a89462f904c532f4eb5427d7785d4b653d02f78014e2f89404645f7e2b6d9f1daa2e87293d4f84458207a6d558462c25241f472228ebf7b52c2400a5d88d9431e1d0d3185ca7e3f0681b214f6037796e72e4b9d2f4cee2e86baf1ccd925fdb844ff8ee3c27adb320f56e4d8083aa9abcdf26bd167e98ae11638415f631aff0082a4eee5f9b0ed16433509d3e14d3d7f9677913bc3051c2a609a297c1b03b1128ad1e5c15df4bdbf61aae19b070a5e318425013a6238c537fd7d1f369ac5872fc7fffb8f9cc0b4a3340f442c35f562ef408143a0a3a77fce9cd93e5b8134498fd70aaefe4a14c0e82552c5d2d3c51098319a7752e74cf6e5a950488d2e7a76b1da87e4fc95f6d805fea2e444fd655bd1f816f2991817227b6498d394398772f38269a9d83e3b6c9829277427c17f6f2fb41d551bb12fe443433b30e0c42872212854d21699aa01d7ba94a58de30b40b89365bf9ab3dd4723233c8b686f9b8384ba676eb56a2173d76f9d5c04bc91d82af8445ad3b7c57f425a20025ed16822b9b16630f4bef87e56ef92c0c545243ca801b592425c972d89325472d5a327ed3cfa440515b4e80f3637571d4bbc66ce75f757d6a7816bf4509b28c9bf1da4930b41785783bb8e18189dca9c1019aa89d6026f5d9deac881c865d06095023196fa7850468aac9d52c8163a53669db2ab0684a9546c661a0c8d7b7bb4aff8633f35a0c72214dab160abfac1465bcfc9614adf8208841df18728ba71c51e43f3056aee7454a6f2d6aaaf72c383e124d0c9d66aadfca4cd7841e5af285b3058f88f54e3368c54f2370e285f0eecb1c5baf848c3be336c16e64f2c0e6d31b90fb14b43f74b21fdd3efa82717d5c527ddfc3b2dd84d91e4f471ced989fe7f7babac2fc5cdc2fccba0ba4ca719aea882c35f7d5647c0d64f14d5bacfe115a355304132f5c118b112cf8a62a95e7048c7d3d716ac60f1b1440c226a17b97aeff86d5ff37f8d77be81a84bd0dc5ca4462c5fdb7c7a53e2e4a1064fce75da3554a37b2c7a302c25b554c1fb5234a2f3ad2946ff39448e236e5de736918939797de2b8903fb54fcbe53a1a76160e5be29038b99a1f6b6e43b062dcfa61a577cf50bb6023f8d4c3aef8a44b6c2c37f08ed0a0c3c0aa31c3b884b49d6f2b1e48c10228e14d0d15a213813897f92bf022564fb700c9032f47629a45d7fcc6ed6f898e565023c13b55d64c607ec4a85c5239a02f0d4713a0377f4572ca7be84a90f81a850a7181373819d67a3ef2d92518c7e6c771c2cc46c7dae913c6d4cdb40d62920103fe287bed1d79c3a71edda110eb320374d01ef70d9c55bedda73ef8c720f51a20c73b79c70cab3370ddd40454f107786c787f7caa2390b11f9e9e6aa9440eca44fc6916658daf6663361507d5b7bb8449d6ac3ee09dcc162c5da4ec0e992d4edd28d7ad6caf7d1591bc61aca5e6c0e3d8a4335e21fc2d2e5515e87ef0eb136550a59675f84705c7e4eecb038725424b8bb8709b49155cb82f8628f83c3bf139713c7d7e733af21377c4472688baffad746e65a5b88ea4423497e19d625a1ebc3a186f29e92dae27ee475f90007a8621b7ece9c2124ffa63456371a466dba449a07c72a9d4d69f21c367204ad5235bf85b6230bd560ab438a0fbf6872b9a341150380eedc98bf86e8887ad979affc0dc9d68a7cbdb88bda8628037d1bc3a2cfc9c7b6e3c296a2aae96f292764ac216ca13e192f4a2c40b643d9299b01ff69e2410417388075484895e2f2e728dc328173d64ff54ea371a8f0556524509103f1844134ee5e257c96e78aa3559e8f2de40fc02e7f5ab193a65a56343a0eae9ab7cc198528bf8ae396f397cea5c1f7fbc211d54bed76dbb3713e002cf5469f0fba66b8ba048990f49d2da3e15b4d55e76417c971c891136856d3363c50e4e75eba3121fd32a5d5fecd2fa5e2f82158f8dd27112655b6435a097c837999d7775a39ac13496d6027707be106a32b6b1346ce9e0df2b362b3d7787190c31521f88f957b505e2802fbb5c143d077d54a4155067698b620b016aec55eb9a0f491ddabd798d3148028f195e7b57d8f689263aed6e746d648e32064e8f66a133242211c2b837fad2648bce3edd1e7eaf44c714be8162d07e55eb0040d08e671e081f205a34b88163e0c61b1b1afc4ff418a5421f45a35afda8dc012487fd39be3902b11765116f5b8ca04d182f472ace8edaecc21470c34a6d4a5fbbbbfb23defe177e198d0a7fb5ba15acb80477d5ff95ad513a13387b097ff59da04cb94be275d33064f072401b17bef1f9428f16716ddd8783d9cbc224f409c509a6495c85f3ebbd3f9debb1220f27b38e3968100d9ded96b41b5b52227fa6e6a10c0db79b1a6b8e0eac7a5552f4230690efa3ae687cc4ea9e0f83832fa2bb84c9d6b2adc39fb0da5b535046b4da5b800fcf96e12e9312189981a46b576b4c9ffcf24ae96d3962d0c8da7709286e2d9e24b122ff0d42eeb3e68b99450e6a2108ef82e0019a37a89be36e90fd93b97e6fc41e016a08e2b0c5c4f589b35190229931d82df24893d942f6fad5755894669b53fdfbed381682b1a51fc6984bcfa00013e7a9ef3e6c461e4acd69db944c4770ed6753bc66548f4453d3e252ca2eac069d588085e554838d952d64c503bd8323c228e3cde2f16a9663ed437b48774b79b119882de4625be9696dfecee9cd5f8a097a7c45622451f5510e11f62fae4e2f934f8da963e69e247d13de6de0f13a1c15dd19682a51aa7dc0b5791032c7a701e1db7f46944b79fccba69913a349b29a03befff55014ea793c86d323221a19df3756e671948698e5fb0afce4aec4d35418589a10c81296f177e9ea8e4065fc7a4407b0a9a039b2ae0cb4ca9d62a29422ec6656bf7358006325c45cc454136de0329c22e90a3c669cc5a77533b495103b2abd40ab167641c738294b0bf926b06d8c29b9c730de7ea383aa287bfd101d714e81100154ab887578fae5483370335160643e91be32554f1383dcd8faae2e6087897abb37cc36f32d37572c3b2580df767a636083b157a7ce2d3c77c49c3f74159885406385190f4add7b01a5e6b345cd1f1f6cd88e1b7bda2e77691b0b3a0b6ef7f8f35b9e9a8e64997f6d3dda8af6a3f0729dcc264ea82af355121e282baf5660806c77bb6b6c4c2eca78e6fb122f3b929fd8eb82391e09ad03bfb10a4d2b2d3bcdd25c1ec26e98742a4844e58bc94ba1d65568985770e07b588b83fc8915d49d050af5f856704456896fda07acb379c4632f81f0293ad1c1a9c69b2b8c1bc0493122deea61a7fc6e1d0efc88e23a5d8297948123b040df4bb04883bd89713f21f84649f81c7799ac458b2691b113dc05f6140b25ca3cc51cd5f0702d86dcab26d45c4ea6ca84fc688687385295a0c046948be0487cd2b31973ce88f4a96d7085250276c6f6dbaa9afd9432e7a01f1090a9ebfadb9c4d0e9a3c441d72b5705ca3478d443be0142c54f25fd8afd7f20b77ef343df14c671689b5718d923539b30609702674cf46e8ab1ffb3d61ac995c9fa166cb44fa75a5ecdb3cbb08e53a22f25626601ffe39261169df7221cb7ad70d6206181b196947ce1a0988be6f07c1808d413241d27689767d92898fe28fb9e0762038fc3a3c67acddd32cd3ab8c2f2d08023cd3cfdf5a0c436ffb0a5b31e5ea02a49e55d0469fd6d6a691e5259f7d4f34428017a516d4311756b60ee9b0babe2ccb23d8de1f03516d8723651df89ed8161cb62c994b065be89229d2e74c2a601f827c507642fa2c44c584d32d241755707208394a1e86029b8663869504c3b9125b8fac50e4a1a995a0fbdae0b63e0c72983b177db26286c8056700af1d0adf2ef962b33539970249482c855cbe1a98f3bc8c7e1e6b7f7d803bfacf6b7c41d0632f425df4a9d397f1894b05dfa0ccc3a8f280b01924b0d5809401cdef7a4d98e65d56440155710ae3934746933695a03f94c8248dec6b80cb8017ee22a319b4022ab855f9fc27d3c7ff28e74d195db665dae08cc986d9cfa89d05c8bf5b75bee2724be41fdaad9db9c2f1830bb1ecf376ef79616a09cd8eeff622ff386bcd7a09845eb076b057ea1bfa000317bb70617a2cc8a86813e82b21a38835f73dff3bba0874e437c68eb01e5b98844727e82b3c172842a5457823f96516863d5fb604b54242491246b3ecfb40fde5988a549d7c811df3955627167dd0d6f9a4e63af0bb93789b35b1924024657dba1a0c0e49e00eb41d1b3db9446712bb993a6fccfcaf833a5f7c687a0b2f40c496356eef1b9ccb99786a263dd0a575f4e076759e1deda8c774d1d15946afd0ba89170972799c881cf51d1540e2b8c83959c6b4f257e2f1d330a9ddce1a485d45258aa5e00f2424c235454a660066c3514e84de33b8a507f3380f1d63c20b56e6915ab840f8d56b3ff75f11ead14112bb3e1473771202d306e94ab2f4cf55c146b9d5404c2fe01afe02d8779398c32867e8e9c576a07c9b9e899b75fd21dd448173db2db2b19bc863b02ddaf3b3e51006213731f2c7da81e2f39c51b575cf43807cc98112aa7818274ba566b0f8a2b628ff510402b4a10b683d84a06b9c0b97e9ffbf7022da8b36724cd750e695705b51da656f76294b29f1e84b56e33656cae363845c60f265575f0d243318440f1b6583b31d3df87ee9b3bbcebe232b8ba8686780f3380d03451ab719e88b5b8452b0f3ef5da5d18b23e25fe51cf81e709ee0226c4b554e694c45b1b22a4fe976f05af5af4714d104bb0436df5432e110f00aa81e5832da66f78b81ed9361f3ad82cf0e050a99fef2ca0f6d343ce6e201025517efc962982d7d76864c9a7be2770db81eba65742854995b81c08a1fb52926bbcb3791571a6f9768b9e37b4294211b3cec0004f230f2c3873398d61423d6b940ff7a8cbad76403ffc1bcd6f0fa4f0f5987fc0d494c91acd80b9204c517c0b1d870355a03f9ddbbb45ef16fc882e4445e67b46d929c08200f305ef2d8cbe869559843fa4ac8113ad1a52946a7217a7ce877e96efd26b4578a935300442f88eeb2907c8b30eb9863f6654de5aae44f8d4d5751675ea84e127e04c89cb11b2d0ec0a4d1bf06bcb468a8f3189cc7eb6be276dca38e802595e6270cdc0ab36fa8b14b49b5f2a339cf9d89221ba29d82b296d0155e18729c0a82edf3b48e042704b9b4e66b3a660628aef40263f6003bd4e3734e10051ed99cb1db1faf92d6f122a98610024aa98ea3f75f48af79c786d78ff4ee08764f22cbae58a3e5eb9b0d88d00d97b93cf9c39c54b39e55d572c531b0a54712abdbf12b61ee584be0f76a8c18e1b7334fd9588fac3312746d9a59b974131b42e389a5c9ed2d6c8adf709d858938791a97431492a6e955e7e992adf5c0a4279687f18cf70e2f0be1df613f70dab19eac2356f248b7aedcf9f304d2241b823b16cdfb4110c139c2e953a223807a3cc3654fa9d0ff17014cfcc0ea55b20ff7045af5a9a9d102343c97080c36de2361a3ce451c628b4a9455b5cb090ae4575d9c89a088bc12f6133b7dc787929cef97983604be0e41fdc1377ce2a61040ada9179b459ff5a922602c8025e3d97f0f5c13f76a1143e2fb62714ecb98717b551fe2516f8774e20e2841fafe12092d2d4be8d1a3371696c8523167c6340b20bdef73f55acfd0d1ba344cf8bac0c7d6abacef1052b9fb79aaeb0211edee9945f6e0250a3555e94ac68b93bba85b80bcc095adb6645bd2f8350c8f8ff03a53d59af71c73577bad176c484b7d269fcc55df300ad0f7bf4dfdcd93ae0d7a2d03fcc1293bb560f749b8c9c899587c4533a0e13ede41dfcdc32ddcffc07c3d79c459b5024c80344f852f372a06fd562c44ef9c53e888e5c3e891a6775dadb2bfdead3390589878e7fc4ff2e4d638c3b4a69b1f8263a3fe91e76a97086fd2311bd59df41c6562eea65af1ea6339a2c93f160938213fb065831397d35c74ee9a331abf1b0e187fe0fbe1c52d8eb1ac6c91d1eba6bb1e5261b4f1a897c6baab9fabbf87b692e186c3757b1f13c3c3b2fd12a3a736ebb35ace69a6401508217e596f3e48862dc819a113d6335b4a63a1c63869ca25bc79e506b291ba7f9bd40131abfa554be8444cd3a458dd1c457b4a4d94b33198d9503cfbf30de59a449bd4133fba8cf3ae45ac769a317221c31a26861523d29655ee799bc6ac8a38ec9dbc057c6297219137ee39f87f26685bf202bafc5d99804084bb5a5241ad42a4d72986948b6372d8489ad38342d9773b979819ec2045dce772e04f53e90c45da65682ad6102b7fe1753c2b5cb89a81f702e0a946096967b369f34247847078ebceed6ab7bf85364166152d5eb5c7810933fffe40fa8ee2c421e472570f762f5b114ba166dcc5629b3639ff662f6392a47e117e389d33164bee0b89642e3e9c34fbe077418b647e2e0156824e7405af205c40aeeaad700bebf86db1b45e1d34af322726bcfedaa87372442beb74f112bad981156492005cd865c343a87b772339f260cf82eb60238ff7427acd3707b3afd4ffc82e187a4addd8d45f5075eaa6ba4f06212bcbb5521cb773fc6f50759ae092529aa33e3f738a4b5cab098fbcdc4a7803e9b76aa5e3d09cf42f8fae3d6f413cb716f5f84191e079bdc4fd5d49fb79d6a94d5dcbd49c41b6b375ff5ed9bfdba7cfcc36f83eb029a025087f7df64df6f23b86cd89c3f7fcef0ab3b83051c7066ec97767304756989a68825b3c1857b5ef80c99bbda7f4bcbf5d618f8af114541ace85ff099f4a8ee09a5d6b9adf50bf2d9a68f52e7fba8a3480cd8ca3ee1bc68e9efc4cef2099997e4acba42bec9f1c3f2370eab167456bff7340975d33ab4709b0fa979cfcb44d402b023bf49fd90ba3bd2b57fa792719f4ef13c66eb78cb22750e162515e0c53f91b0238afc7d7e2833f9ddbf366d234a5eaad90f5eb5f663c5fdbd993daf3c09d4448c6d6077462b2db183db072291ab43a9211ea87f2a1ff97b2173d45099a21c55f7a3489849698937e18424931cdcf8f70800659c3f5001e9ab40a3700c85138e7382dd46b68516b7910da37225a3e71fcec09f57d03d0cece00950231fe69d0ef94147cfd401558ac3268f9b962281a12ea88f53deb52cb09476ad4cbf49e160f924c4847f991254eae75538f8b3c6d40faf67a586f5d062371aad98cfb155942529b661654da9618156e0d923c14049e7bf8fa40d01805fc60cdabc48cf3fde1b2638b9d4de2ef789c2299cbaf81739ac51ccded6ec6c955ff85135ecad2d7d088c1cd46931f5764e0bc884f7f2e5f44d5552ec3e0cbe0d08b965a00704cf2a65ff4d0371a3529f683e795781e653627f09ca93e6c353c565f9943516dddaed84935b094d6233d35bf9005e304bd219a7e7c368a3b0a09ec5f03700fac0fcb089d87ee35929219ad8fa906c79531cc68ea80fca81a9bd95c526baff51bb6a81293f66293fc64e78f3ad5e43bbd783c541a25a3ffdee4ca30be5e121846646a142687b832d52c6d614fb4bdc8c5dee4b18859f6da267b21605ce2b665e36f77f65ce7d2c7e0883a1660c318eed44b47561b47b90d0afb156be85943ab92534708117f41087a2d19f43b26be2c4f7302b0622b1b9de3d4d035fd5158585d61ccacafd7f1c051a9172544fd888d97a422ee77a02c716176dd1c661c416d8fc05ba7900baf880612bf18aa8d7273d134a0577c7df044b7fda3164a330331bd7f2cf3609f577a881e116c802f1b28c91e07adf2d23cb20e3ac6afb9ef0973f8db94377d1858b4c96fd16ddc52f6044b328b59febcab30d56dfba06ca1ba6cae1df68d022506516ad9c3287c363622dcb45731ad4e2044493fe39fe4a9acda1a01d0acb5b40115b5fa4b17ad73865a8267c11cd24cc8c62a6e0587e5ab9d1f74f074195c388a1f93e68a247ecc68661dbde6ab6b71cd3d3c55377171532452edf399f1d1212dd8aafd957f15324ad891325c2bc46ce954cfe8afd124632f5c88b92743bd2f3b84e0e943099813380294990fafa8837299d67a1c51030450bc1cb677f14856aa9528e7297bcf7c7ffb4a800dcae2f3fb3dbb085dee659d6a912631774e335584b5b940bcd42b01641f78ce7dcf9524a60312edf07b3d0780268642feda413ea5bd80e76da4dda319ee8af3269ce930003f4fd55024373f62549a0c8de50f812b949c96bacf3d10d11ff6fcbc50e08a6279e3c12150f2ebea8f01a47e19dbc61a797ee643fbeee87286a30ce197c8c787ca465c2bab7b20b6f52c5725331d52d7ce0aea4de0486feed7e67e408169fd6cf14de15ebb3c3382480d92e4e1edf7c199c685dad1806e31c2aec1cd56c10fe6095f9de0d27aa65d37a02b979c373d16694fd5e7a349b14ffde5573cc7bb391c730dc7c29c439754869bc1ed7ccc33bb596bab7906122a004b6eb977ac0efd66ca84cba7b83bfd7c44010604c78c6e2cc90e0851030d1d91322a2f238111f060d846e265ed4127d23f1bb1df781c8c0bb74ae19511dafc34d4b8ab019c85ab582d78550b295f89389cb5ff8f025cc438d99f1f21130f3d2ecdcc7a7d14f4b65d7499efa357e67d852f82800779cda69723662f9486fcbdb0ec9133507fd4513b39944fdf681bde896bd330f78a459d733f893c4f495f031ca5a0c88d3b53222785ee39ee1b26ee93abeb44f9b516003b5e9232a9607b94c3762b665f50b10a9b842a1452b8347943ad478d44702641ba87bd890ac9334fd973c29fd973e9331c597ea943eef885959d8c59ecc1944a06076f7b0fb6ab70c7e46d9360057d98e0b47c2af90d835cf047abef8ba695f4be113083bd4ad6b8f15158805b845d8336324ebc904dbe10c9fe569dcdf9a0f998b16e4811a6ae36f4c9b9d844ffb7f1bef68714ae9674da0c5665a8dfd52759e5d5d604185f0b3993f4c7df9deb293c1c48f9d28bfa4384361e29bc3cb073e8d5923ef973eff00bf672c778687bc9dfbc8e1416aa79a16984c75b912680f51375c389cc84974fb5ad2da9ade9fae4022e9a1de5c67963ae97f0a7534b8c6248e0ddc93595f0a981103a866804aa542f6105af98178fd527de3e262972f438edb764a98f80f70a4bb942a3ea5ec4fa4575d028b93105aa8bb931e7073292a6f863148e837bfa61527e6769821c13df7b8f237cde73453541a70b1a1ca4f46e257a074cd5990e6c2e4bff7f7f1b05c2304ea43482e1f81378d8658e21a93dc1a5e37fa25c3ec8d95f2bc06142aaabff72a9943d3b6837eab7000106e7ee571af7c47dcfba1ae294fe253673e4fca6b50e5f3d4a0a7dd89bc77d79640365ee91c0ff0a8e90c76f251b8be541b28da04b783f9e7a2403dac8e8cf124966e34fae7bbe80b883ae3fcb77a597501e9a01a671000b7c0b80a34f3d498b70717ecc5cbd8b22d9ab1f49ffa5c42b767c4c945ffb094a347dd4e85707391dcb89d2c066575380a4520294c5c4cd1ce60b92c9d78e3638ef96dbf6698754e06e2ff50e42dd6a1d76ecb85cdb392bde72d9221978291065bf1ddc5c7057e48805510dd1232527db77726e91a9e8950d1feade057d9733d589d4f1d2f2f5f07db56db940553422a6b43c9cd1d9cd5b3a5b60c0cf32ff666528721b5cc8c606643fad9b775f540f1a91c7c01c2d03e19d40573ab7e8afe596afedfd43a954a78cae059657f90ede652b68041ebe625a76028a8a45e8d30c930f3d9c16f0b345ccc7a5869634773d746b2739a8781b0945d2461c99294a52b2a49484a18156b565886a0706d6ba185ae2c8002af2cc0956f50b701be695e011c67742e0c065afc98e0ad96579d3f285e4521e9a332a482e34ecaef0be5dda938f23d640f728a7600ef22795e37358cf448a895462f113e4f5676459d79829a61a52fe50d0146dac368879ce50d6fd317f52a9a9f0374480cfa55fc22d26939622621ca41433805afc80b99e3992b86a832fa5bacd2d972baee7e2014a4fe3aac33a0b3ce767e3b29823cec963cd1f1adfbf43d3c6bde67cb9c54b1172a11d826a53f9fe196629cbdd93f349724049a8b6f9b690d5147d48ee9327b70d49ed0fdb9bb0190a7e0a9d6f5d153f2fcf86f235bfdf50dd13cd742eb7fb9feffd54c2c9c9c92dc49ad8b536cda358c0011746741009976f2205d1dfaf70b6816d2c31df1461164d64d781170f82df9f8103ad2982097717756b4408a50350a089d5ee248941a2c931aa49d1fad765f66d4917315ccc423dda8e1f7e5b37c3a1fddd2f3f940d49c6c334839d84680a6ae07a6309752b0d08caa2b26ca1a0ddf09fa8304b80bff531a45edb4db99d0b5092701c2568dd4a7703d1dee41e49b909f17f3d463ed55e570b1b9cea6cf787b9fd313c9e10e96aa54a9b2154844d1d28c9714677d68e1b84a4c69c2f51a67b20a23921dff06374a80f36d192976dccc7d5ca824d2abfb22aa1c7490e8269721b4908d442283f5997c0de5dd6b3cbec56828085c272f9156bb4c3365812554ca025f7d8612a0e00525643fc94e0411a2de5c980dcad80f168ae9ecb3c2e89546dbad2a1446b26f1bb4c92d605ea633cee3c3bc86e0f745a50b361130a0a39ecd92838a06d18adbf1cc1f9fae42c1cf5c07b0dcb8444a3433c002f69176dac66ccb5205ae0618cefa0f35e76dca3eda7bd28236a4058d7fcbe8466d75ed9c0953649302755eee3a3472369d073f007fd3dd5cda400f178fc61080cee57adb346bfc861f9413beacd8c7aabf58e56b72883c0775b12a3c0ecc881d10fe852f8ff149f3be7f4c593dc4028865710475e8b0e38620a2974084cd0c91ca2bb7a7c4e1409fed18534c3f70ea4480180896943de26bc21b0824a7a9917ca8cb84827041c1606d5be18f1a81b7199d8734316c2264649425600e24b13b7fd8bdcb097ce63668ac11753fc55dd542c39769141204ccc4af84850a12e2a6be7fff34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
