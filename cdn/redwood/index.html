<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec3639c157e305edd2a399dc8c286b061a1cf615eae1be0cbe30784e450d1bcf12b4199b3a927c5e3f4baa47c319d2b431867c8e57ab12c5c7fa7157c5d1f8309f756ea2141b316f6250e4993004fa5a285d48145fdc77071d0ac5ae212695a90333cf5f870a20085e73ec811cd4df5c78bd88836801c02cf2d1a9d312b6653a5a777976ac3fbe481882e5aa021c0ce358c23f1442fde922f05b003b1cc2756cae9ce9505d57e5d367f1a775053fae68c96b3497a90d30a89be3f94fdaaf6e102ec932b26ffea44ad7d87c3a0eebc1c01c1de0da19e6797b0b300165431166a2b90804325a6e144d25761c1c3ed1ca54c6e9ac9615995d9536628fa8c597d795e306271e053daa3f82e3145ebbd436c7687a5ed2d3e69476325b72aaf3e3706ea397d8acb1164697cba1f661092e919e6014bd41232157112d550ace97be056170c6547230f2bc068d0a97921179798d9f4aed3a0b28f43e325e603a5beea9745d2d2431b8b979ac2c9826b9aac9f63f638255b3cdba98937f3a1582a1eaa11a465a510ff8818e0c85e816fc68df2570c842e453d3066e71f6bdb97f7e7729b97e720fd07fec2078a303475e37122443a34ae668711782953aab402ad9e4659cd9822f5044c48996c31a99ac51365eb28bcf97de0c29a134170a6072a123fa81c184b19fe26d3008bf2b7d19e64a9249dd91525fdc94db907b9a88b500e119ab86ec11c513044d164d362e70e1cc8da139bf06a437066aab01be3ee67591c1d5ce8d890c1de98c5a907837dfec2c9a1318ed66c2a8ee8cd0369993ed731399000534888dfb3bcf40f4bbde3c1f77befaf0952060021c87bd9099f4db5e730c86084c4c0a5200b5e393945644179610cb540626068d9b4f97bd97d3ce70fd350255c7fe853a9e49f36259c9710323abcecd871d3a7a94feb28cfb6cb204486cebe2559a0b8289f06a7e54e485dd9b2bf2ed7bd1749e51a2cdc5e878258ea348b47c97ad6e0a420fbc72053e8ab874dbf179f717da9a48b97e7d33908685beab3c3ca63e01d20eaa64813ae921e963397256522e7b29006bdcd25b4a15de76ea16b23d3a5b12ae9910919c0cd94ba722552ed83723136640d6220554bfbc2edcb87a2fe7c72f4e8356871c5e4b01b251c0ad7054199ef265e8ae7c3ba1d724c1821f06f9bbeb71d341078d325cede2c7bdc2c93a7b391547f7a4603cc8d39b2604b9c8d33bde114f434ee236ea7f6aff6f408243b51f308e4897c91ed7604c1e752bdde9019a0d9e6060f253812f8f9abba0ab91ee2851bb611d24c1b54df5dcd4a8f6ab4c39658d19c3cb26a1a5482060d69681567e9c8b48e17161df0d131a3a468d6f9a05dfbcadac2fa87ca68b1284c5b786dbd364b070037a86544a2767ce953eecb8f0b6469b84d57f78e5f8df7b41c9f528b7087a5e2d4c6cb8cc5b0d78b9944ed17093582b22beeaf87cc93e456bce5845654939a54dd3547e5b4ca7541d86eda5489d8e1cfee09cb0c2107c562b9eb67b7dfa5967e4abf5557452fd00c8095d96dc7ccee99ed44513626fc1fea00b81d8f283ea4eb7251d9d91bb6d699821e84f167f3d31767061c0d9036b41d500a75cc099e8336552f5bfe25e171f8f40e0131a4a6cab0834fb0ff71d097633e8a94aa3884378027728f9313134bb91c9efbe6c48dbb9a66271fd2605ee299edf64b9bb094fa54506934ad13632827df493dde5e4b2be564c8dbaca2d81bda47af8661f224741a2c727049a30549093ea51d1718cfbef388052083dc20403c36eec8004892d4f44a0c6e8637c6c55d65fec0123b8d91faa757ae88d540201f59ec438f41f87ea1d27eefd5facdd57ff40a5cc25bdedf891ed6581541f0af14268bd9df0b09711ffc53fb8260579a42c75730d35be46b6f9d94bbf2c37316b6b60a867a559313894573e10590ae1e2e50a13ea27cc2a23afd4edbc2fc135261aa7ea3a64228b61826cb9d348e8f892d32f0c12d4c40dc6bea2d5082de48766b6dcd710c6008739ec4b83a9fc90f321a6ded730d80109d0625a6237f0f21985478a38b86fedce52b6dd67166ad86dbba5b36038ee515de5f838adb33e01efec0b1bffe0f435dd3b3815ed22449f8a98d3c3a4eb606d21938e9cc05b559741c947b6c0f3b1d90eee1ea1305d6afa5be5bcf889fac489093f375860d17d53254bafeafde91184ba9aa4f37502b64e0862b2a94233f113158de212397f3ad91a4fec2ff29653e3d9697ddc8bcc13f3ae1bb82ff4fbf27a9c9233cadd596eb26abfe10ed223a562e23bc5dae57a502c1edc6b2c33f4f61e0a82fc02d832cfaf019cd8aca87e9e10e7606c75b1e57df2b92acc1b693059601a31fe6815eaca06b0247abd7ee88a5ffc75ff2984d1b2a0cdbdfee3cf940f28b5b2197929a036456daf3fe8a1ad91a81d86ad4ba699260f131711f254276f89c6fe755edd489666a7db1e0a723605d49a989ce0b012a34ec3f0d66271b4f53ba9fefd64daf31f0ad7bdf74d7609009a08633b1024fe061e44c5e7abe43d453e33fdfa8bf13e3dd33bf79b57422c4bd713d9ff4cb980fabe4e2fb1af9be5a94dc21c984c804bd76600bc3f177191bd80bfa8ff3ee40e72d3793d229862c23b914f16828d839e9c1144b0db66f7c1d4206197862a6af1c894cb6e9786780e5eb766064075550ad8949efc1a98f4db318a75422066fac6b241636ff3fb3b706e519d646a509812d16a1864067653178a442eb4bed6318df28a6ad5ba7bca9e96509fe52302826bc2820e4bb53a510c2ce89c3674989820ac7ad8b6da4ac0cabbbd5e472af881227a35e758075d72f135c8c2738c1a2ffb01100f0894f41cf10b99c22ff8a4c8f636ae2948ccf06a933ca038cbf0b49aa1112f5dea7cf6aec960a0147fb6459159d06b625aa75cea495eb31ebbe1efde676b1595c7aa33613c8e6a9c7a80ea891fb8249b89dd2f55a45ae156be90a0fded4818a918264515247bad9e97b7485dc438efab423747c7bed72b211f1c11d086a7cf923f6d9f3d6cd4ee1c5cd71bd42671976328e538362bc8306659639e9896e081ca4cab77faf3ef1286fb7fc5a1465e74579b9dd1ad08daf9a9cdf62d13c7531680849a1be34a0c5691e62d6e65c5966a45df90ebff30f7f2f86846b0ebc91b050934fc7f01431cd3ceb7c23d66ca9f1b6add0e9d7f98bc90c9ba691dea09707b384af01cc2915a770d8c72770c4bf2296dddeaf6dd6c0e5b11efc7e028198f1fe7a473da4a0fea49ea1813112e7614c1ff1cba7e24853169ad40be408318525d826770bcdaa81f1406d0a11968f82f0b8985ebd300c6ed1da7b3dfc56cac4a38c1ef873d6134a846952d8f2f8288dc5b4ef728a0206f1462ee5fd5c2f6ab9eb693571bbbdfd73b52de7ea12aa04f146bd7adf97308210b81da530be9667b27299add06962a3430f366303ae0fd4bd2ce2ad209b6b60c201ae99b250a47d53c43bc380c38167280ae713b731555391c6eba4c594281752aa5dc31cad370d4cdcb1b44f4ff31ec1d71ddb73cdb3091eaeff1f8e5e8a97dbf540aa4da8219d8704989d8c842b1c452af01ff1afb91afed4b2169c1a7f98928d8e110bcad08f6e6b8e9be814e8eb3361d1cbd73a73a2a9f49c75fb45f79700a05b0474b1057d35fdfcfa87a853eb196ef746da5d0023f36413841ace8a0e976cd00e645c82d7d2f064820dfe4c5dc74713034cb5cb39de7bf5368453750822daf7a3c5117f6d0807da130f6557ea12376178e46743266316f6c36a3952732fdcaca16c37a3d97d08f8f04f10225c20a9f8841a7084b14ab8f4c716760d42eac936fea287b582e66902931eea525042ecff3572834942d6c6531942bca1aec7cd2b04443ef606a2dfab6469dd7b8cda3f2d3ef7c4659ce4e4f2c50926c3af83621ccf72033084dc19a62761f39fc8714d1e78a163b85b01b09bc4f1c37244da1a7e9e5e3743444e6667ccaebab187599ac245de1079bb33d280748f92c7703a4c70b46ee0e802f018e959a2a222a1258c64b0dac6f3650bc5585869c448bf4852d8224c67c451fbd44e40a25d1da3d43fd453bd9ca5066ab943e17950925570d44155aceaae443ef472bb1d542883efc8684540654f5640c2651b68e92c9dd52e03f65dee4a5f9da8f5cee9855ca50cc12c90c5825f2ec8809b26919396426a0d6b078f37aad2ca11afca8ad0812cd021ddef554daad9f81890ae78464bfe86635a068fb1192fdc21d364f8e3cae007cac7df81ea0aad3b03c35842976d624ed622fab561c5ed703036f2bcc8b46d0c96e0b947324fbb130b7d60233b9a8712ce5cb47459a3738e28700c17570700c861b587bafcc6782db62570f406d02e17b402f11a5c07cc6e6a818b0f100414bb3942baebd631a36d578ecbea30a3f6e368fe494865b0c44200c36d621e9e11b49d007414fd692300256833600787c6de4f33772d8b431341da100210c0f459038dc6163ce04756bbb466a1231d7d948560945a38474d238adfce27fb45384f17af5bb233fef3456b6ae44603121a57ed39741029b52e1483cf1592c147b6a0f4ed692b2a5bcf141c4fc0cbe81d43f313533a98fbacf8657bcc7daedfdddcc277034f98323d4b7298d27ef0f8e57adb7dc87751201355b670b9fbedb3d7a8dc0cc6446259ad8f7dcede318923a4329add82ff7a8f2d7616d5062ff03c0d6d1d01e53ece957ad44b907748f46af2aa2dc9bda5ddc569e04062ef3dda36d5912a881fe7dacd9763741732722ab4f795609d4baff0cd1c71d941bce5da28c573d5ac9d5e648900295c42b3916fc761e35cb14a3f2f030f713466af3a510bbf8ff0c897491e9b4185f0040fc31634b9791e07fd2945d690714c720fbd443d7e062628eaf1fde30654efb669ff6a75003994613f5d54426124e40204c49f90b4e725f10385367145412e204d60d922bce18407a2d8dbd50181d36d396a9b9800b0a571ccf15f73e44a54e8c07aba94a6687a65087e04382d70d647c0fc12eb6a40e8d825da78335c24976c6d5b85cf471c43545070c40495254fd9acbf4e920439b77b9d444281101df0e21879f189963253926d2f3ed5ba054a30c029375b89ef864d6a09866f1f2d423e67f620a5387c9b77b5fe318f538b5a1bd647882eba64fd2183ff9276a1b173e3653bd4bd1e3457308f90d7cf499a32e226c6ea5bb7c5c575376c921513392e7323c6f463d2a8d64dd33c20773c4117386eacf7edee39f774183f612621814b1660e373999dde98c8e35dedbee46ba4a01f6878805a78154c39ee856aa164bab07eae46e7da7383bac5360152af2974c06c9adbcf95a3ea817d08c5cb72f8c8b8430b46c33b2b38520d3cb88622671b22e169b2f4dfc9a861d3f2e84fd2cba13a17755232e5f4ba36e7ce0c2dcbc26323657539b23072f2ee2dabf52f1f41d4d7a1fe3b198dfa90b80f91086bb5afb6e43a055db090a8f4b0cdca40f94b46e0a679e0ffb9a6abbde5eeae3f3cce67cf979aa8253ef6d6506368b37cba64a10a6114ea2031c60a564789b146e96e45a99961fa3730aa18b06e83065435114aecc2ec4f1c16f6ad5b4b56b5d8e2b39379e36ced2acd0d192ad1740107c16da8add6539dd644a78bb2623d5469d1832ce0440361e0177df6b089ce313f5e0caf89da051f1b72440babfb2e4c819577152be50eed57fb59971d8d6574f41f0db1d497394d6c8101d7e0bc636372056bb98478913c520ef2d8113aee9b3cbd952467de18f4e6b73ccfa6304e15032773525bee658e4b3fdcf081a30de31357c3d1eed29714d1f1336d97b7a15492f8e0f668415c8a641c5218932959d713c545b5b33573095453e792b93e9b8f5265b4a02c4a1603f0e3ca1d5a82eb740306fadb95d73d042720bee0d22b36792148c4c396c00787334f2a1b7037167cfdef770031942f4af7636393cdee90079106cf55a93b114fbbeaf325865e8e5e7542bad9312ff7a4c25b1aa60fcfa4c0c74208679b2e202babae5d0c650948ab6246ebf4fb85c0c89b16a6f02529110a154e1a97c6c1eee7851871586b461fe6e4d8e255fb157f39a589983ac84e4bd55d7f595d9d879d3cf6583ba359f63bfa9708fc296ffb909774e20293eae239096c95a60d8a4eb9215de09f63ccc54ca7b4c6599586e482231af33c5953a5971bb8281a2f0d7a107109883dbc487fa7f5c86de7fa5f71d66a96e2e6f1f2038e40c1855c39c4e6cc83b9600e7c38499542a4ecb39e8e46662f7f24211068dad908dc1f22008a059e6de6b350bdf27a732b90ddfdd2f7a8e20f1ea008d5596633fa3ef1ec63cf8b45f3f9a76d2192d748d037c5d9b083995dd31741a073490a2a19d04d024db7259629022e621fb4dbcd7581913c76ee85da11f7b71f0b560865ef088cb0233dff5403a7bca9f584918979d1102f74eb02cf6801f56ae3f40a42ce4fd365eb786fff7e9c586a581fbf1da8b1a2230bb0e381c2a4cffa8498273de8ca99c254d076fc86b44c68b77b657cece64b0a3978354a5509ba1701168b1682358affc789a2276fbc04c9f67450366c0e7ab1c1bd22f5b3a93ae956430a5986a5728e39d7369691a0b5850a7ae25c8f449e3f91ddd4e2d0f90737a9c3f4bccb8dea893434c7d324f6413c38d09c85753852baa2d8134cf3ffdef94e5226af0206480b6c209027bcccf56912353ed97fd533062b83c9bc6d39ee453a4a52f865b1398026f9d290ad40ce630cd033974c84e662846310a35c4c2d075ccc37bc5675cd65e56a11a63a16af4751fbb118bd2cf3f0d40d8eb626c85375ff4db6ae3b22cc2775d4607ac043d042cc2af778d5bd85db641ca120226d1c8f385b1fb15829589b30e31b032692fe617cddd8dca96126980fdf1eca0fef038674bf6413316a421ea61b0e85956dd18be36bfc18f1b1c34de328053a1cd9bb8c67fc78dc67c21c188e4dc2b1d41749d5824fda153163a1ce915bdbe2764c787538cc121e1d5e746f8b3faea239736e4e8e819b60baa0b42a65a5c63eda50b9d9ecf4a83745afb865df65aa747a97860de4422948ca01345189974ed0ccd2f33b776f3a01fcf88ebb78dae7147dc1c2a97a6ebecdbe94273b1f607b2c2ffc4234f88f1a47e3ebc18e4274bf9a562faff3bbdee289c42955f85c3307da76b977c16412f1fa8a02589ed6ba03a27bf86e96a0ea38ad7d67954dbaf9dbc00f91984eca0c47d3203688fe38476fca9b3d45456b6eef82335f00adb5e6b85f2018b4259fcf7062d8e7b8efb47da9058b680c80431d4d3dfc2b8b95731535de6a81c4a43d4050f29f7165f61254c7d9a87d2d807d6f6db29c05b25de6a02e8509e65348969e061650e3a0a419b6a1d0ffa51a0548ff357fc2984307ef0b3e082555a034175beb79cf5d73234bc3d68f05e55d359583363550a931c41c94016c504ec1f321aab5a2c8e027082886f97b89d3882d70144e11f9e598aed66717351bde24a98af65b9b60303904ec3907cf37aacafb3b0d3433fa80765f394ef1c9f4616f24966ffbbc96431db4d3ae7e8d2104c06d865a89d8237a0db725e13d9a2c8bd6f7d1a3f207493fcbf3cc4f1310f4acc150dd32b10f8ad5828b54f9c7e804946b06fdc788a1fb2dfc31ac2074d0606dd5348796185420ccf1571b460ede86ba87204c3bf65793ca745bfd5418303622ed6af21263b56239d452521c8bc2a6e99300033724afa26436074d68a8fa4c7a8f11459a8f1968199192c29d886c147c77feff3b4698b5058f4e9e92722d41c41ba62255599fcff1d66ae91b74a2c6dc2e1f7fa21aa09dacc7c7f8d2cac9b7a06857e1c4410345d2ba9869db98da15e2e02d8787b89118a6f2b1407888c23a62c96f9ddcced425be1b40aafd6e6466ff6c7d78502bb224c8b2530edbf7d22b16d448529ada8eef020d0059a31b5c756c6cc0bc2d6032ab0696b40db23b3edec7b9667a9c5a772507db35c20dace192ff93cb7542d12737f86a486c9f60227eb0a9caa977cc4254d7361dfa36805e61d822c52e86d9f1fea8c30037f4e3bb6b2579d7e34b34b3d7cd1f846146ae272c8d74d7c5f527fa1fe2859f88eae3a348cb84ca2592909581db05705dd894cd2271e44c645dadce7895d07aea48619c904c3302f7053c11d2eb4c5446c7c42c8a8b768492e724c8b1e1186607a67595162ba40c437ba22fcd37052aca6179c8c2d24b33f958c68e18392898ebc8a485917ab01da8ad3a36ae9874fa07e772e982ead063dc00977c19797d4a3c42d18fd99cacac4b12a712cad94ab5f18bd96fe8eaaa81dd23cba5fdfe9cb7ef4412df9c237034e40d51eeed321ddb186471a85efc660e6a7fac332096a85365734da932a7abdeded379b89144aecd75b014320a88752f061c4d60476f2b1b91630f46140f864083512f2cad926722a44347d35fc6de9b10490117c080b83b9cb48bac0030bf815ca143698d047bfd1a3098256d477270381041472382e0787a98e6238ed56a6d9ccab380fada797a1399387c4796dc6ff603a0581a7e98f4ebdb9fdbd136551db314ed75382dda805b08dd81963f2edecc9a9ec460ac29cfe10d57c7dabe5936d49b7ada6bddc0f239f41dc084faaa328484ebed9493553620d0959ac9adeca654f9eafe59236ad77163f7c7bb4065db86f061e85330f4f8118fdb2079b2fe83f5fc476a2a449b83ab042a0dd1e54e7e10002fdcc2ae26dfa3609d071b6de3c3a4084a7d8a8a6cc4b98c9952368482a72496f1c6eb195d2bc752906a2a984116b582462ecfc255090e026c5807add2ef477852fcc153f0db494e237f242357882735975eeec3e1e2b18981bcfa042c668fc4bd81a417d7088eae4265d84287102e4a02807bac4483547a8880b447ec5dd33c023656201bc0367562c7cc5bf9e401c4ef4a0433f47fecbabed82afdcf44ed0ffbb8e6999a2fd1e47dc94345378895479c0210d598ad831202b1a93a0fdfd9209372a5ad12fc791e44d2e6735999446e61c2538f5a212209a9c4957de50ffac0f4886ab9cdbd9ecfbd5e92160cfcefd7cfac5c8cdcc7459622df41db90d21c5e9b5907b069aeca9d2148e8cd430329f9f08ef9357342774e443daa7c5f810f9d09ceb869ec1e465b3e3c35c270526b405b58216776486a5ae216292c7594551a3835e3d7d463017e415e423cc5bf22dc5ab10cc13d36fec100e80b1647d4047e07571df01f09da268475a886e33e0f5374abc2fd61893751568dd4f399decd6585492237f6bee89bbff0de564c8bfaefc10d0e3773c73ce7b103b57d2ed39972c704454f23b8aeff00bd942b08a9e9c2ebb04069a2d41e57064adc7927451f32822edca3e052e8d47e7cf48c9df9b4ba69466d0d45802b8218ce746ca1dfb3113893b9612146fbc2d7c5652cbce102cbe0d6793efaf06db308ee71e8a53d5eb1de92c16abd12d5d12e5fbc3794b2229ced7fd5ad7aa8938acfd197bf70508d9b16c35bb4c7ee57d34ee9d913c9a3d354097adaeef18e0dc990e32c1ea1ae3716ba22365230688fac1661860160f438dd7e7d5ca17447a3ad4943912b92964da74a210e69b751a074fccee5ff03f75ad212998497d93cb67a7a995e13f972c4d313d9dcb6149d42356afaa94a229eaa8ef2285dc1c067c55d805eccebfebcc76905208ea478aa5351f5a4bc05efacac23cdebe041e19f331b2f0d80a0d3858985e51f30e2546f9e2fdbd6d65d75da5ecdaf719c85753c3260fa4849874cefc55508a3a7a89c0c4b548d491069a0ff1b071b59b2a759c4ff592fdb1b1195d97e32ca01460ddba74fab8da8e50f360be46297a718b3653bde1eca534f77ab2bba492882c9f55c121d12d5e5e4e997576506151dbb4b23355e5df4480686e1e036416adacf689f6b25379140f2cb2299e16fa3ad46db220a4f2951a5cc2e9ae2dfe698ac23d8025f6068eb2f04548357535e7060e62060c3a6f2bcd0b6fccd7b8f31e8f06e2f7cbe411914e28fb63c533ff664b7213eff7b725f65ac44c892a6a904a2acdde45fde7ffc76934c9fdef1a09ec094cdc4d2beb2f621e841312ae85997f1954d9638fb593d0562b02518ff255e0ec47da873e5dd6b338df519c31210d6da033ef856b1ccd13a23dd92d414b29b30ed936f35f28e5ff7aaea86f80a6d8b95a5ddc8a658f408cc86d9751f89290d14c59a09d0005d73c3a5dfb4fa21bacad90d355626aa07a0637a277e058c90675d6a496e0cac2b724e34fda95f5f3d89f3c8ec6a0d083445213177816d51d4ec45517ac9f5e4addb42c7a00ccdcb0a3a5b376d2335c56fa24bd3939eaf5ec047f01b7f364519cd18c6673073100b5777e032294cb1628aaf91eec311f4d2e6e93d598981a2b6ef2c55eff8d3b7a703195c5e6abdcc906c506b0565847f5b65f5de22e7682ee3f91797cd22dad00c30a914c808dab9fd821382ff96871eacb7f38ee35ad093fe70bf1859ce6dda9e7b5b0b073cc3fbab1feb45a3400586eeab333921729081dd170165739e36221f28e6fb09742481497cc0b7b3ab107834832d80d261083b2906ecf895839cdb21dca24afaad4cda6ee9a0721da33346c884fb1143e8d80d994ae81348b3a65d568bed59aaad06eec7179c8367d7c3c8ffe3191663088aafe5af59b58a1e39e733266ed8f5deac0e5cb36316c0d4fa28dc4ba8a5969938573fec24452e00aca72f3de0460131a9a66c474813353473ec84c3818d9aabd556941ce263221fbf8c6a51aaccca5f5368a329b380ebff0d94161d69746fca6ef19129abee090d539b08abdc0916d268e0af3890deb5b129595cf2bd167c6bc798af5bdd99c51fd27f7ecdd5c5aab93c4229a8ec6a97e5a021ffbc90e21ff6f5ad8011a1798b04c573eeee384c70f96a35c54ec178dae464f52c34bff39b1fcf9d33f4fa6a7b314661a2842d44d7d450ae8e06674e4548ae804c8c33de5635487d6c694f76449edbcbba0dde514f9b13535e455b6e15f6fc886ea6682755722ab2ad244876dd714b576444c739f33bf671f6c2cd5ff4709a2ef6dc000b539a26ba2e0f097a0f3134e6f4b3cb476bb2b57512ccef55d5655538f465d2ac01c9b24be4d82ef570e9a3db3c5e8515c8ded3f3f47fce1a66fcbe36caeefaaf7a2daccc28801ecd1ef6bb12f3f14f39ef4299c8a31c55bc5f7643603652026819b274577d77c0fc51003a3b85ee76a2d3e12ed5699040b5ffb271e8f1d1fef27f23e5ea9ac683632429ee81a9f4ffaed8f8303de6ca2f4d7b671a22ff7202a91a2306dcead5bd59e61a8276d7abdb8e68f93bcc59da33e82ab860390399cd08e2ebd19a22773002c3f0a7774c074c0870ac1d35ca80dd24cc90db3ff2cfb9d8efcca1a803fc986ca26ea4f5753023d00db07145b8d69894478cd119d94e864450efef82d5bb22a8b92bfb891ec8476f6c6846e78021ecc06035745f40a11d73be9d8e40c9fb0965002fe412862ee5abebb7726cb71bb4b569855ef9632312a6af979cc0080faddab39b1e4be252a209c3ca441300f8b7af078a388c0765bc58f99ba6bcf8935827881e0dcdd135ae41bfb08a129afde9a86ee7740a646cba08a057adca831ef406515adc5fe584b5e0bf9b032bec3aef515a8b7c6554916c6f7feb91b8ef79baa8d3d91cb1ff185e30c26370ca9b6f161ea7ae050f7ad38395e58a1aaf89ccdc6dc8f9ddc7cbc0a5d4d2e41739c6206bc1b6c2a8166d60f95c36fefa9789dcfe05134885561e18a8354482066487cd142b40576d790979f091a56a8f973ee287bec8a1cb06b3b54c1701a1da20d176757841eb0ab76b955050c31741f4dd7db992393b933a47d57db0bd88370953c878f9f01f7251fabaddb02278fa47b7ef221e4169ea00feed590f109a4b8acf425598e280d15e7977c667032950bc620971e73433527d8c542851cf97c61115a7db6ba9c6e465f72f7ec3d5a51d934c4ef07062a48f7144f153b924ebe123f3cdaf31551d54555fb357cee114bf6b974fa9317c55a69d244a13dd92eb2ad08b0b6f50b324343faf02f602e3403a04da459936d8f135a23fe76c65325d4140c8ca6d17d6f79a231d870adb5f2e4f0bac86c7cec434691633b1886e157fd24058977846534a2ae2f3d5b8c04272d584cccb9eedab277621add546affeb0a35d422b66234ae6a25f4ce0ad9076b311332e3444c05ec241d267c7dc9d4ee1c0873671e98a28d83e3ad0d6a95aa9aa4709098e16a8301255996e07c78c9b0d416d2e6e48b7e5a27ca6c6011d46301136e06f83f2b92e32c157cbc2975dbd228501667ab655260b76e30c2155a9b970b840cc18a19b526ffa68de94c3c2c98be86b95cc6dfa09005c114a9b242694f8bc187a60972807c10fe12d906d13ee2f4939cd9a58a210a0fa63680ac5b85885498cd12de9fc505f10eebc851f94337ab5790ecbbece5bc8978d34f4eedc1c6de56992a511e77ffe342f1ff020d7aa8c00c79f4a1afdc581698ae3e3b37b439fc5f9656d85b956214a96ebcd16d1d65a5ecdd47ce43888f2bf332fa9e09f2e6f145b091de9697585a34f1560881105d35290aac209d8e86883d841d190ca60437451f974b62b9cc075369ad4ef962a26f86669891bff1c0f1c6a56d98803273ab4dddc85a10279a68fc0bfce6dad1e46a5b0f301d0f7919277b7a1437144bcfce31fb2b1d66e92ca293fc4492f42f199a6bec0e775aaf470abd9c7f9bff3bc313828a7bcb438640a9615eec8cbcc4078019bd06ce5d8d89522639d583052a90063183ab64c6629522e206894309dde9535cffe853713a123171200ef1ce05d073dfeeaa65bd237e6f44cf6a78305f1ee2151746aad0c10da85b57790fdf1100b875fb907c70079883e92cdc93e312106cd71b611b6866890efc560226a9c5f16ea4bc66650be49508b6793307c778ca197892c5aa608f5d1a391dc8881021328db9721a38d6a3685e19b8131fa55a3a72c1f9e9d509d9194e00780a949fbde13df414da8d280bcd00992ef3dd23840d154d32b2ae5cea03811eb54758f607de0715a3682e288d2c950233faa840a513da8de28562d02b051aed9b9d0636a8c2018ffb67699e83b6f81d5eca9a1f2540d8a37c37f042d6f1b80f1439010c48d4589202ff94f60b1f884273464c9129edfb8c6ebe6e5aed18015305c9e03ebb7e2b7ad627d462a3aabdd4d1a89ddebc250670b1d3073f193b1ff66fe189cd882c56d07fd1ab116150eeed9c4ab642cd0657f454101c1ac2618306869c3475eb740cdbb6e60d66f3434d7f0cc3d835d53243099e1a59abfc1205401cf3f12754cc88eb50a746f182ba94d622d0183da0d055f706170f35796dc7a13c2250031042e5114f31b1bd75c3f461de3252b35d3da94d7685a5717d4628690d969ba43df8a68ab0a6867e6e221c1fc0102ec880da30ab8b4b043f1caf11d4e4bed421986da200afef4a46e59c25e0a94f4cbae8a731dd32627fec99294fffda1679f6abc1a0b64ed6d8481805503acb369dbaea0d68f8a874f07d35fa3f09464c9df2dac4866870880595ade97a4a04ab95b8fb3f11a820bf911c8a59cba9d499d6c2787bce0d73752b8a14cdb71e71773bd01309470ad8de48692d6c66df8bbd92520b8ce184dd14fb7081f982a46d458407e0caad855fca3f8ca56edf40534127c102de26fe2c8ae50bf2a756eb3bba6e147666dd5f32e1caabebae1ca0456d1bec0231827b09eee2c8d54721961b9b9f995969f86c4ecc0b10430d31ca40da363c00a05e70f73b4689f0dedb2397a6a3a96b338f21785e77c0bd1e71189c4cf3d0a4ca19677d61d74daff46507d887ff1cd7afbbcb8656b81f8e3f57b5f0797781e4744e927591fd767c92a93ee9c5514213289b9ec3c11b8f161b3914139eb16252b3c562aa08215196b7b501d36abfa124d3e11207ab3d04893900a74e6acf19d766e6635f4cec9ed62628648b7f45f89bfb88bf4723119e3b7d466344e087a65b4f1697482124869bc8c71405a659df4782ce5adcea4cb4deddb394238eb9c8c234b9f2d1fd445184ca4175018c473fa06ef76afedcdac4e4084561a5eee0ea1e0456825dedb96c68001c5f69a99e72125d0eff8961e330a00d9607daee7f1fd7912c196a2a0fc3cc6876a5b2109550f4ce88f50093d277b8c0871d72f365697ba9d21bb55da581f81feca7ec26e0806551fc1edb31d8c505b0daf3e5331163be1d52d88a6fed6f03f08533a93ccdd4c06b182102abe6317bc6c970ed78288e23d0735a8730525f831a640920a70d3c6c168fffcd536765d5982b41740e810071a51fdd39f25b3a5b49f9af2d4bf880477b7f2ae547fdaefc9081bc423fd508c7e4e501bc191326b109914dedcb610ac4c7fec19aa0b42f012433c82aa7e3d4bd05f9ccd6f0707b0270188b773718460695f8ecde504baba0bb87dd92dece06eee1b98f80421c32ec620ffb71479504bc429f3f8835e8dc3292b0f4d8546211772933faf41f0ee0161b53eedb40c624962395543749e922077dbabeb8ac337962598105afc57921acf8e17be3a6ac811346d0a4c117c5a47e3d877f25d3552bab5bcf356c78dfaf0470ad8e58fb17a921b41ef6faae7cf028e01bc4cba73e24827c6f6622718b101789a2eb1b333667db080d2fec06dd348d7d907712e91a6a2138c3ad2c28f284528c494f6f4df7d20847af69232984f3886a0e790f684058ea774faab58f4f563a0dce9ebb7751787ca5f8be01ab99f7440889a9a862a869d090ca8bec51489a6d511047c3de97aadccd55cdc3a3ad8563b5233f22eaf3b095e50645f939c311cb75f557aa348bff4c89ecc7134b8ff43835c613428689fbf2fd2cb2a3d54cea60ca84b5d75522d6310bcb1ef41c863e0b06039a96f065358b51d274aa6529f8a49fbddc2661123dd4be3476a25a5214b0c6b6754102748d54b96412bb6896831462b58939f0088b5480a0f12873560ab833b2cc5aa50cc94ab8cab873092248c229152438917547b3f4948ccf0497ae1d07f822718f37c3cd9772e2336f8a12e46402f014617c49aec7749d0037cf23f999608c33b4f85eb5b0a107cd6ee12f9f62317d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
