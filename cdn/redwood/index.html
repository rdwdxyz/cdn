<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49294a48a39a086522676405cc0a08545370877aa2c5e844101cb5b3a7af109593365bda400797023b5333e6775e03fea89413490ac2d43d9f335079166ff06d6fb912092b894e30f71dd5f3199b52f1fa19db0737b5b683091dcc182190d92ac6806e4154bd8edc5e91dd64e87a992ccac17f32e7b470dcb2f39f2ef5df828758aca1ee9a6f9715ee969f158bdc5a62ed24751a597c3808b7dcf9551544014a3d39cfc181ff25326b43c9d19a8ebe104578b4d3a76b1a41cda1ba8bedba134082c853cca954cae047c1e9ad6df501079779da1f631716237a5151a23b6d9cf41db6e5f7cee0c372a4d32cfe474a1111ebb891b7eac31e246c4f6a73d178fbd6ddcafe6d14997be3e8ef2a5b66a37127574b016ca7b9ee95ca13eada7e5a3d7a7febe71447eee646ae66c6a962d6a8b48488af854203a66b9242d47cb99f4fbe9d7b5d3a61981e3e7d5bda1903af18807b50b9c7eada127f7f3fd6330e02b5819ed396a75904467350c8ebde71c0ca538cabf7de71c0b93708ce3674e62ea3646f59b473523daa79812371e2f7b4bd38e10c11ce544dafb6ec8aa8ea47c6fd9ae60a5b24a8bf494eeb37f3bf9dda63b392c5db54f56b6e7b80807a25312bd702a9a33cb6e1f67b16fbcab608a8f2378bf0b2a1fff52cc7bfd7d31a4bc3e306f207644168bf373e35214213ace8db670ee50f9bb21945cb1102af86d10019aff9ef2d414afd2e8203fe7a0d382cb1c1d4613ed4a7cedfb7fdb427cf996946de34ccd6fcaf5f98ed95370a66558cf9464ea3ee384e633a6fcf082a14d3186bf6161de6e3f56f6801a48e82ab45136a3ef7270ad485609787f86d4c258ea8414e228df215d7bdf4fc181b4574e58e33a63350f0c4fea2e144bb855b5974e279cb34cf291376a7d8791852e7ef85474bb5fb30103e8367f783e2def4a51f87bd160b4bddb0831ccbf1cdb250cff5f0af9c48611f302a37e5207182478937f2ea2c3d586c4cef17040c8b2f6e678091968fcbb2c6eb90a87c92f4c656e7d5fb15a17e5936a3a9041e5c66b7e27cf07d516b65c24f22a2e84b13919ba25246c272ebb1bf7c60e40d42f5ae2624ab77347339c41d60e279f392fa23d496a57f691686dc835a913c24ed2b21fa1d7e49c5ceeb17510b7ac92ee4ea220e3a28e72bbab9b25b87e866a93868cc36621137e857f115de87cae1426fed54f68e1a3b058cab535bdc7ee0813eb06dcf54f97164d7120ae7f409071c6e10bcdf1e16d2b96391d6a45bb915cf4f5c930f527fee983f01188e25e96a93d78e8be3faee0ac27417dbea2983c5520b7063ff5a72837828c62d3d650b0e99f5ff12fb45241c2a017f86ff7233b83ac58a4e57f7295bced3e8e0d0605360981d4ab83b1f3a13a57f650f583340d9f2f6a6f89ea9db62842712385061f8a66d85666774ce4e8fe9d9ee3428f658c99473e6913e0af4abeb63175cb02fe895048833d0f89f7b447d70113f95ee68ed410090bee52b166d9ff1fbe6dfaae2a74005fce6fb3a0b2684be76e9f6ee89702d984dc0ada2320cd3d9aad7c0076cb23a31f024b862a8f3b205bd6bc27bb6aad68af89564dd96cd3f0197c5b24d4d600718fc05fe05d23125706756445d25e394f812c90ac87fa2b86f8e9a90c1260eeff43e26de4d212a809c85985f782f1eb3f15ed56dfbb4093da6efd70bd74a5a3e61ef9b6755e1466846c7a6960b53fc7551611c974ed560d5459a00121a235442a44be1411dc37bde1176907cdf622a5610a8f4423de239ec0648c94f44a9451ea7da3bef9321e9054c75ee082ebbddb8257c9e900f5f61619adedfe1dbd856ca4f2a17de686e8ed9ec3078766fa46d913a735f2ec05874eb83fa85540bce747f9aa495c5e2a1834e8d61537691b4a653baa7f5cb191c1aa92ac86e9beb5785c0df21dd9c89936b729146253929dc7e7a1e769e7d072682bab28fd836f0b39d006c7d4c563db67aa58b44ca21406d7d6620e304f813b9fd01dd0dad6071a85663de88f8485d2f48e14648add628ea2a5dccb96490fc22221f4cb0df354aac63041d2e4eee525fcfad5174501bf1f87570a49820dade2cc26c18f8d7ddfca3d244da142133bb572601863d24598cc186124a0e0a37ed71f1a7889192975113924a87994c0a4c6b8b66c8fabd578a891edf33999c91357d749bf044ea518535e843ef3598f5d7e60eceee484572742b7ac1b19c8ef830fdb30b3aad22ca15f56836ebc0d942b0d7ac1bc34936e5402bd752e785b15257870590d05c59ae2b6f232088a775c31f49ae34e7600068f854cab7b50abcf74a13176da789ed32091f0495e0cb47d0ee3ed1ccab105ad5293bcf97a36684862f41fc939bf096b0cc6598501d482a109834e55d7cb0832fb4bcfc3550a40a30d449051b497355f48411ae00cae5873acc7fb5dc312441da3ca5494d58276a102f51bb4bc6052393afd465a94b2b8f1343bcc7e16bfa74031738d48a9109e5f0f971cdfafa53d43335a016051f734c74ff15085c01711ab0b0570528f0de5ca58451496d040b604014cc0336e9c112dc63e76036ba8abbec24b72a60dc41069cd6bb9411746131f4db5733f428e70b1d7546eb647b404382cab425c5546dedfbd1b503245ce8dc23cece047c9bc0749921cab6d7f266c7212b7533d02221485b472774ec2f8079c73aa28b8ce6769fbe6b6b807ea16fe6a57de7599976d1215ebe8edbca8fe2c1d94fb70ef152d619404262419e1c51bf74470f6a16d26d1c29ddeb5a3444dd6a2b4abff661bf376b09a9e967dfdf72600858d3a8d0b90576963e8dd0f13ac431a9ebd5a7ea66c1d9b5b213362598427c1cbe8da75f327a4c9a1091fdea3fcb5583285a7a5027e0e5d65007c5244b26bdaf70a2450966854f0f6e220cf24df4830c681457a16e825afa8a1959f9faced77f06e622e258c30047ff192ac5794e3f2b1b8bfc4f6607ea8e301978b5caa54ee7741700253b8ae3637110caf29545e2f3791d5542644b8d87643d120d9f6857c4525104ae4c7032486880a5963b11f07d4c2992c7ab5700a6d682ed9925d49b161a2aa046e2b43d228fb46d8b1577d9e64d8c3c41b8dca23c49dcb9ccc7d4ba858cde6d4a5ab755ce21bdbd53c95693abb7ebae1c7f36398af0b94a761fd87b33e50a6cffaf7a976cb2d52541f734b77a3b5bae17dff89baa9c1cdebbdc0566068b2a17f69fe6955a668d5ca7c8d7e6f7fb2562ee7db8731cf9928b501d0cf3b9bf3e23d38dc528fa1cc0c89f7532f6bda018fb8a72767db642be7ee7b0e40a91e02a4ef1dbdaa8a6531aaec55417cfca8e4a9c47a11307e725c8f1d1143fa2a10ecabb8bb6adb9d0b9a61de05dd9578ea0c067b4ebac57c56e38c3ea089e583359bc53f6223aa3fba8afaa9e679f64f899e4255c4f4745881cf175eab41eb14f9feb704e5a0682626408a178ee86076233e1f138eb7009126f73a2dc4e1c82c8827c34e0638f3a4e068669cf9962a7cdb7157685be11538684abfcf952abcece5835bea72fdf37bac976a53e637141738138d3df6b069056a6a076c45a12184bf9d6ca9fa6987d549bc4611d2f11f190b786474eef724f4c3aff862db085f0d6895bc1b4db950fddc0e7c0672ad264f2e77ca72be2735c3777fdbdae5ab512cc5a0b1dc77003e245bb97d3a9dc63d9623e79ff76e7d607728975bccf2c9f30af6b18e319e6b7e1955c35240bbb6d2a2dcc6eaf0e45e72da05e118738f481f1fcf0c263d81e11f362763517fa64098e36011de264db333e54096485f17eabeb9770033885f66cd6e5d248a4f1e7ffbf7c47876bf5167023b94e033332b1d5cc9c0dab10e3465b652ea5a871596ec706170c935091e3c32e773e802a6dd0769c4c93982904b03f00c12d4ff48d9863b77152d6f8cfd8c4a6571ab481bbd2ab2a08e503277ec138a3843995df8ec083f0c83bec633add236e82c5dd263d867142292c9452dc453fed9259d97c527154dc1fda24cf96df27c8203e5572a5651817c1e495ad01718c4d34a15a2f532f301eabb5e3f7b1e7cfd38d5f728c31533bcbac9b645abba4bca2bfa4e000a478e1ded4666d6e694089ecc8473fad7392a4b58bfc9d693bc62911805da460d7a0ac24cdb81b509fa02b13adccd74cc95f2856a01488f946e19f526a13c58308b59fd20aa81968f88e737332fc87c67b95ae8772e829cd459f6453377d17f24ad82afdb9ae123b84deac080c9798e8526c684a4c0b57f91e20248f281d6660cef44bfdb067dfb55f882c28f6c14d138d7555a5bf42141a580720442f74e3c4c25d3014d2e3efe3e319b875d7250eb0441db7c7deaac00e340f7cf99e363654ccbc6c46250e68a95dae4864294af25b0367177da285544af38566e1a6d109e1603a856622ddb60907e7ab5113c695a8b3398dad37e0b891aa7901bae6d8503f2b0cea92e104d922ed9341a9b305ddeec145101ca36be35e62b8da44e34140648be08795e5f3c50c885238041ad4a976056405bc33a38917563958bfc11d651a5ef8540cafdd346f53afe97920adacb18e5ff0b4b6937a3127cfea8324c98d54f6864c79831a3314283a0dcb47c92290fa02701bfbeab6bd537bb88acb5fb3cae7f3e23c6ccf4fd50b7dc054fca894e79e2b9edafab4b1cca6493025df512f14c33521534e933c8bfe41d510f6a1f23bbdbe12acd96dcb80c3d4c21d06aaafb59ad73f61c2e552f8557a123db19ad41821b30618f1a05c2a81c8b0a7ee51de6c8e62241e82bd5495bee0f900c691a233606fc93e6c39afc5451415c14dbcc3b1ee377cfe1d62fb82ee2c883be37fbfab5b8347d5fb84dfd9a53a71c268180fcc5f37770a10729ea50939f761ac3acd4c2ec066b4ffac98039c4da78ef877cb867c8bce3a339a9c69e45823e2dd67198de70be4dc4409bbf4932f3332726f2914897841f83f2b719f1cc1200b5a95a45875fcbd03b64c9b2eaeff85fbade24b94fab0288e53f83f0480c4ec696add790bc5ed71e2601eb1b816c2b3667a898a13ccc2bab748a24d3ffddce80cf591079ceebbf78f68beecceeaae7ec83cc7d4147188c5104fa6b31c5115774db81fb9c026e0818a56081c89a98b0b189668e1d42b014152bc564f9d8cc0d098a0e33307880a55169ef9bea0b33284be20c6f62454da700b789f064037a885c8c8e62f69f017f52a0427e8e353624cc485461950227195bbbe9793f137fbf665101958f11d8a18360e1ba6001a21113aeaa50e7074f4a3a683739be34091f46131ae7ddb6470f322a5ba0b2fde154b9b178484435b56b673f06fc9e8ad691d0baf8898173f4e7b1ee1f4a02bde6178b773476ef1003bf834ed243de9c8306054a07d607f475e9906830b1389a1f7c8f277f7bfe3d5336f75a64d33dc3f6edf07a1438cf8996fe8e3fb7a5274cc1de972385c2432567fb612179ba3bfca3e84042ad767557e00d4785e61ffd5fe0b2c3f8e902a2209e4fee695519bfee8db76b7ddfb27f5c3be2d2f03e9b8ccb5b5e99596dd206c584b1afde2d5fd542d68bb49717e3f89f13f06ea2278834481c3dc9f9d8045a436aa85ee3d9577ee65d46a59d0f784a308884f62ab7c9eb98ffcb6cae580cdfbcfb9bc32d341e308a7c45d5e91d430c05563e56995674f9958bd539cd00f59de3d928e87e4507d2b9af8681e6ec1bb99ba01d9dd52db07e7fbd81e5618841ee83273acf5c12c7df6db5209d98aab77c99d92020ab0f8a906d8dc43bab2fa8f641fed9301f6d4ba6f3997c43ece5da1f4e37fc5ee5d62abe5fb3b79e7b408d664f4f78e5ce8ae5170357782286313766eb2e0da2326f30cc811457bf9e6c1d8ae52fe5182ee4f9af63d3e30ad24971675291a9aaff083de5a589ed190b49016d771d80799fc0db359ff900f622cb099c577971b3ab378b930cd59e3324966c1d9b9dbddef499de80d6c0c1a2eee511f9f5a37555e70caa483a2d26be721d06878f84b963cbfbfb7923c6ab5471b778008bf3e1c4e7fa8d53fa2b1d5b038007d2612fe5049337d99421baa0279fb40ae6071db32246abea28791f548bccb369e70cc4c46daf9f230f8066f325958da3301a0810c3e9b7e7ad742ff36a2f6e09ed61c9b3e643018790a77da047e186a6ad722ae134f9cb34668af613c3fb267336ff285c3bc39999f74b25140941033a70ace1f7c1e2cc9fcbcac2483b02b343b115eb44cab7c0b018c5f176cc8ea1e99421c136a915a3749330591cad3690ab758d44a2367cb76a54bbfa106740da47271980b4d28af576b1b31aed4fb014ba0601a78266a96483e4a562515931ae2430766725cfd463e4cfb5365b050d8e0059a7ccf21e0aaf4fe7a1fac99e65c06d848a663461f798998b75686cacfdb4f9a3a7aa7e09abbc3eea7bfe44068f5b1409fb6b469d6aecd3ef38bc70e289ba0279e2ed1234aaada264ccece391e62200de2ee5d23fcacc534328bf0aac2be7f0c7386ae2febb19ba79f32d864f0a730729e5f797d3c87a171a415275e4c3c8345334c93212f90534779fb40ecdec82a68d354b747e7167855622053968c262d234c17bf4f550405d14dafa822d494c073b63b26f1a5f2b5f04f0620143151121289e40c99cf062a7702b1679b0c52abbef2332ccec915d8a6efea0ac650663e6107bb93129437c6854c4e78eec3afa8cc171e77c86474b36e3d2656b282907844f8fed5810d4997f98ff9e4c2bb7881661706c3e1fec9329b03d231cb2cc2a57b3da4dfd9ac4d0a3444f5924f2b07cdb09964e9c8141833e230a137da09100f5966eecc03a1f969f5cf62121d3b3fbcf4fdcecce2600552ff7fa3826692e1151f8787a96a1659bc7d10f889f6e5ec0bcbf02ef1148dc3cf80dbb82531f39a02fce0dbfdccab3a77fe08efee4d1ebdb5863c19a7e1848dfdae39e69027bbfa946c51d674773879db0f88cc51a40a9ffbe81ab1d312a59f5e348afe11ba5106fefe00fc94158a8894ca93b4b138e240d31bebc4ae29b8233e6bc0229318102cfec7e9a869a8c92428e9fa2c73e856b8ee299bfc2d340e2868711244fe3c71e6d68da2749733476f6ea8b6e725717fe053dfccfa56c3e6b95f133fe413a7ac7cbdc5ba5ebcbb1c8cc95212083a25a69161cef3cbb8c7dc42fd0a720b1ba4161efee7db9a0f2b09deaa6ec16580dc99a24b992d86c11ae2b62ab4e7489a2359c3dfa104a1c04a95b1dc866d32047e3c7cb66490a8f5ab31d750c55e8c990f848bfba3de2dc93a0480d7ad0a891b0f6b1ba8604e6094025b11085ef8157459e5730ec95d3015c958f921478dc2fb6346c03a9a27843be837dfb5562b9d52979e2214b0faf320e70d65cade19189c2a11a5c296d4b1695ed1d16bc471c0d8f647663387cb250748a4cff8426dfdae1416a9fe9bb5744063e4ed3fea43ff0dec52fd50829c972667a8fbd1733e698d6aa40bebbee43696ebdbf2bf8ca0fa8d1f0ae868c1ef4c4b96eebeb0154d947f4de655305906e00af9dbcd35ec963c9c7bb6694b56f2ddbc073045f896da4c8da63cbdf2b2f179921b0a63f75d9eace01c6824055470d48c076541ccb5220597d6e21a812003dea07196a757343c1ed8f36ac0d71168600506d63397ec05575c233f0cff2a7b38d7bf1c6968ac0c44b00fced88f1e196f42e98b6406db1aee2fca4484828d091cb40e43529b84cb8f821d09261db82859f0e7a4e299185921069f084718999006bc835978efcc72af20048f438fc80af177d1a85d6a6b7d35816c46c7503f55eec133995356d513ea47218f28159c01db27f9f17ac26d64e31e99c3ddf6cb2daabe31ed7e5f0f1bec27be6cf2276cd7013f49c113ab7d11d5a728dd8014795fa0aef4cd58332282fef2282195dac396c6d8f8c2b9a6da837f7e2cf65032f4f22842e1878f63911a66bbf92a7a0438dd1f506b4266fec4d8cbec266da6fff57330813d1583233618deac52c5c873dc3e9d90fde1d39bb58c9ab5ea8b958c57c3ff9e11425212fc5c2e338a98a89b1bd70b39dba3f7c49e9ca44d04eee802fa067853001b5043cae1316b4ca3b0736c780efdf963f26c699a727da1250179b0a71faef2e3c11ff18bdc706645fd6b910a3cc4362f777a73744623bfba618c288d330df69fc92d84e36be5c4f4802b8f81cac89974b8201109b2515a432d571b915bd107befd4fca89e5c6f3bd43180c0da71b0ee630f592651940c370b5ed14d930780e721e6395f33a1d02b27e2189621cf20ecba83585f0aa82b1331000bf270eb09a63f80e82101a138df7d4b271b616b0bdaad62f27dfefc1a9fe059346d7be8b420f9bc97472be4e9edc1cdf8eed08766b9a93feb3824cda8f9a33af15a73045e1d603dabd6ba6bcc7b57c78e8ddecbb1bdb150f04a26ff15b3ddad783f1b68e292ecca8a612b64829896c1597b1efe934e595461ebf139ce59b4844d47c9e0dbeceb51bd78b2a99dc9af34783e4d6310a8217a5e3fb34ac6f1111f11e9fa9bd76bb7875f8f8f910169294fe611e9211ce224188a378f52aa9b208977869134080a6489b22b59d21e3aa62aefec08854d7953a9b389916a9905dea3dc30e8f1cf1b7232385aedbf6c280f6164f5145e25ec9378bd913d8f3f12d1f45f9fcc1aceccfe863211301c53dece061b5e2a40dd19072755fab56cfd51d3751150e433e33984c0cb66c470986ab9553fbbed4c646d1b4c3ec14fb6bb4f442d0eb23b448c0d1d4cea35788e0245590465ea0f0fc15022cb8741dc6fd1f38194cce8c9a7b350c5eafc6332122345533654f8958b8ebd573d2c9ad100ff44909cc732e3981194d3cf2f6bce73f06d6b9dbc3179f43e40eadf06fc693300f8550d5e74fe2f1556cb140f7041e997cbdedd17ce6ecda4c222fbf65c1a9f3df41500edc842e06c20507af3267af0382e1b92bad372b39da9b71b680f0266e6e88972a62191a0d1052a116e3e5d15cf15d980587e36b0cf6bc33acd09916eae0a117515a88bd470e6ebd90a86278cc64f8d8f5bd92a0161766332ec374d6a7cc5828ac7a5c17e068c0e874a07b8f4b2beaf065c7579b8d4a2239563d61f5a2222109e2b6038675fa3d3d3d73b04f11a5f48f80a94918cae3dbf0823cfd4e2ba2bb2a2edfa0c0746df7f2a97ebc635cc7bf24a4c9d790b39e6c598f990f3d5bf406bc19ff82cdc9582c2b9d6560796d18f91d1e5e722dbeeec058dcf9a9b84117f76b8cadb68ee44cd23bb6a7964abfaf171dae5a42936d78f4ec19f6d455f384f47c17020eed9a5c13062fce521fae350f863c813646b566507c1693dd363d3e2597a394ff99c328e60af8900fa8d3d1b917cad3f7307a087520d3d3e1b837794f375d8584ef804d86a1d5964391914ffc2e0ba6b063f9f14069bff657440ef429e85d8d7a3c3fb4db9446f197c0a8717de47fb0fbd3373182a8bd52f21024a771d22eda8a1c43bcb4e48981bf2a207d73bfc9a314a0b0625a9774685b8e06fa284d34ae03c95e5e9ae12e6bd8769f3abf2ce1b7d7b537bacc2da140204b3ec91e0f75328112c8a5ee6f5fecf83ba3d748569d40323c5af02fd2058636ff46ce9d8bf7be1b1d477139e710c98b4f3fd5a7133882d7c704a33d5821586eef24691c150e6a7495c3d69ea317c22313553b3189aef73336e0419471241d906bf6bc620cec518d2272cfa1e98b88cb5a5e6feb90580be87cd0d0255e173a1965042dbfdd3587fa44a5313fd6f3b658392a2d7cb2941fb3d964f31aabfc9ce3523249f4b197fb7bbb3a2d02be89442fdb6799d6f84fe4353710a554b75f804590047c0a94ef35609382a47a24e7fc53eb058be500b30a87f4e33b498dfa6f35233c2dd013a4563be2793345c78c0d47c715fa0e88d284683eb9fda042a30dc26a48dda68b4fe57b69ba0a8b4d4d1ca7ca993e8aae1dc4ca092cbdc6702b66a9718824d27836603edd82000742c47ac832fd138aa772281ebb739803ef4214ad13d7c532a3ce1867bdecba7f5fa4200ffbbc06c8f0e6fb0a297e3a4b591a074bf3da10ff523ca535d6ef5d11ff84fc01508a3e24351425d330274f537d2263335f724dc42f88bf399e2b49f6d7b4dd147b00c8374e906e5e7f3357e96a2eaf7b3797e445d1ba3d222ad4a451f1d8a78049082c1239e13b98b181848956d5fa0b366b5a00a3a1f9355094654692ac1b0ae623a2b2a623f51441d06bde51beed6cb1d58944c46fe7163be06fd958876dc8dbb244e658a6250e8cc54a97fdba2a24302c89ad9e14e329cdbc193092a3ebd3d7c48ae8e8c5a484d6d2518626b5257bc1c4aa8b4a19fdca70ad422a77c2c9bf1f5679fd1aa02ba26b4a7a62cfae297f9b8d54a77b2794bde6bcce6f87d15f10566756de529960d5cc4697b4dfde77b5ded2f8ec6eba7e4f491e6e68bf114fe7d166786b52f902eb77d12403ff1d3d9ce4abc01e94ce30be9559a2e5cad63a516c370825306bbce38a49a34e04a79e8884fc4e765cf9d47cec6ac468a2b90a6bbd4144b040ab93eaf571a5928cfe524b6c088125de96498267fb03cc1cd124de47fcc87f47b58cdcb853915d2f58f50daccc586bbff80635d1470c31485c2e6c5747731be72b89e680b1c221beb8072ea6bcfa0159d4185657a58e1bf5dc1f577b9d0a5e0f5173dff666e8ea16889038509b77916b1dadc7159740b1e6f712d7db6cab68a856053ba8368b3aa24bf9521a10cdbfbda81a49dd88a546819a278196900e21838628e35eabc975f4bf5af57b20131c6eeaf8722f9d99a287f864d838175fe1f715f282f4eddf6fee0fccde14dcddcc2a4285cca7cf8e9ad9c8c5f741cac6795136bb1260e9330fd600c6ff31a0c33630293173ca77dbb2279e784ed0c80bc6f18cc6149dd77184aebc8ee0333a21602442ab76f026f633ebeaa7306a8d5edd6f4261650c148b95826c8ceb16d6e71a5c761a9ce3dfe14ee571a17ed334dcb14e20b431defb47fd4f592cb9753c93e5c0d9145413b3251cb79ffa27efd6115b42ec3a07f426534f05020e21de0636a7b3d21399e1453c5112ac62c457bc0182f51a6d77730fdf946d5befba468f94967162538c89aca5d5116a88e1c11e0895adbacbca9e9e52a0c7ebc27d69da0eb5dc94f257f2a065a7bec593257296991c73e899e4e2531cccd1dd359af72a03f773c4e1c1f256bc4719912fe5d14e2db589b048314b44d2017d4a05f262c50431f963a53a5ae1cb264c782b76714e18a9479e96166c291b982150185138ecf57c603b7d5aa280cfacbd83c1cf8d9ad59bc1802b4b448c0d445d6b70b1136523fcb219ee8fc0ed03e69674832607f88b79c103480053d10f427de6b23286d2548ac6b65ed2714a6e4300bec0c787e6baa1ce4f62513c63b64080161620d6f8360aa5ae988dac4a180308b5f1b67df9bfb976b6dc9e9e8141a4ba4c454bad3f3265cc908feda4f6bab0cddc61b0dedf762510dbd91758c3c5a3e2220d066ea7fe205cdfa26bf5b49744461da2a7a248df9b24704db090f39e290109d6845011024b755ee57fe9b0677ba4559a9dcc7c79fdaa26bcaf051f471c6fe1418d2f525f1e0f10128624df468599e26b3e202047e54d141a1657286c2839ff52180fbd2de42f0573232a4eadc928b939bbabc681986f206bbca00663db738a27cf65f2b068af4d9ccd6952d784f80f3eb2f785af66844d6594469e84fe07628c5bd73176eca777e7f95527ed507a0818d16316c78726dd940c40133d7f0ad0deecc388afdb530e04d02965436d386a4036a91170500882735ce9a97e2e62919333873f7d11a403899ce26a824d2ccdf65ad36984fbf1867281a225722bf971d522f6a3b8bfc83a21ca4ad537b47bd48892adfdc1f5f3d46474631bbe7a934438398cad475c1cb58d96ea1479174a27732ff59973fb406284ef06478f9b0f42dc427290013ffedab8fc63e9a7b422ae40fc7b2d9386065511180f0d8a4c63df33f62cd75be80c0b2ee51358356a99fc918cd1a57b5c380fd1a9be817bfd791a0d0d22291294c96515f11cde92819670ab6dbc4a189faa9e00b97a6078724f5c97d24588def917e2dab7338eeab56f6767d749542605dcac2a239f8142e56e6d633af871182e975570ec36eac686dd931bc405a6c3453a64ba362a8bef236e3fd3777301f48f52fe06d33c7ed5238560e59d9d17c719406ddff96bcb49cda687df6bae1dc6e1c4da7a46c3a582e6f63e20b2ea34e0b59c70f63217846e32b00bb8f603292251dc3e9e9a9c0490e5d1f4ff6e1c8b2191c35b2142944aa7dec776eda21ed4c1dbc44e7656975e1d72cd8a76f02c22af87ee60bbf5c2b8ddf4fbb99ec23c144678a48a83588142408ada76bb728f0c8aa5ab6365d2de675b3f738e5662defd1ae08d15807300e498f85edaf32a6aa0a33b8f99df7024e754621dbc7eb971c40a4c4ccb990cbd2c6f0f313e60dba38d862749bb9464e99073943b6faf72e7e0599596b50866df6c3d7fd446911e5347c05bc3eff10ebf5b3128634d3eef53d2ac6e6a7329c3c65e6f41e633fc07a1b17cd7525dae37406a955511d078c82d14b295ac0e96ab519b029a59a8b0674f0c95d7d9a78a1c673c9a0fffd6a9c4e2f0b253ce5c5d2235458db1efcc672f3cdac0cd505a344a473984039ff7d7eaa280b86939b3bfe99f67ed2bccdce73dab38effb246591d182b2bcdf4757524d10ce54e65482c7ddeeca95734908258627d6d4f93dfabcbe7d4707ebd83e2086359199071a61d8729e7adb44865862043ea7abebf2b3e52783cf096ad7bc1c12671006f605a6bd5007956f7c52ae8f4dc5228fdefe1311bed1cb12a3771b9deb64f3ac6e1c2b13ca8ebc0f7d9e09adb50e50d38d9412d79f80a29924e53fd8b7cf58bd7e5de6ee57b7166242735ac73e8225d16d542179a0c9478115709822b4e11f0fa607292536e81e659475e7bb79e7defe4d4f97353e17deafea1e1431592a7c3822ce0c6324eb0fc1b3337f45442d4a4979fd203e9fab965097c45ae0da3414bb5d0a56aad5587cceedd9a787e17b6d5863ce94926c15cfe72a656bf30a427611e7057a77acf9271f930d4b0f05d36467f3dd7e53c2a19b818d9be3c73e5025c7969cd26315f7b74b75de04e74c1563909ca38da1c19d4ff2299adcb7559ce6fcf4abb529a9bc1787312f39ffaac9d41f71070dc92f6243f74410022340beb5791e4457c10e8178d164c77c83ae5b9b345cc334d28861d794378f08b318f0d605b00f386fb625cbe1086ebb3f8714d9363d08ca39f1e37df76be345200d64b1732801c1d5be635326f7aca007e7ce599223a459a14d1bb4d1594eb66798c19d92629b9bb8de25e255909a40f58894a5b53c0597b898b2811eee38aeb7b4cfe157d67ef486f73335be511b4be0f733d992d05755f23a3f5afc26ef97bd5481880deb5536431dc35bd6efb782b059d10af82fcb2435f0fec4b15cbe54cd9f94b1d8db95cbb2c2a4c9ccd71e49f3ca1a5efdf361e839c7877e48141527ad705bdfd5f3b16ef932ef9f1f1ba2b0c9bee049dec830aef6507132df58773c798ec93ad7aa58b598b96f2ea84a4442b5cfb60931e643938de14b81d04897d453d576492fa1bfb253a62fe27201501aadd69c2ef792ce817e11ceb09a66543cd15ee6e4eebe3b76fd133f34425d28650d0f676a93e8bfd7fd05aadee4398a36de2571307256feb71da25df401357bd5debb2813e4a85cb186446d6a8a43fe48643d62b311d9b5a2abd9076680da9c64218fecab64fd5f1b3496f5f3326d3534856f51153e2aa948c2b5c25262647c79d47ae4abfa5633d7b2ebe1e0df936095e6b53aa6407b926ba8baf4be92f122d46c8bdfa9caed72e3d04b2f7bee5d9d90bcfaf09cedb0377efcef227b458caf1a7a34a54c1bcbde9ffcce0741a38c10206fdf1097ba654b3c6b74909654a40f24d1475e3adb1e9ab3936ca725c1c00934ec962ad7041cdbe02076c93c0050d79bf6410c32b6e2ba65bbe66973e8d1cd957fbe854e341937743e5631aee846ed5911485d244c5f7f4130a87e7f0f711be516e3848b2e5f0166af39913552a6027543352395ffba105ea4558156f16764763b57cf4ee3543b4f2c0aaee2b17d637b5afe23109a1eb277e1d90b350f77a61a2334f54161b133c91f68b4dfc861553f89eaca7e840a056651c567d1e0726a8f1551b7edb1fe3dfba156c8d240161eabcfcd497c5de3e152c4c9cbb05db06795d6106dd69fd92b91f5e6fb877c27e792c7d0d4a60c013d7a502ddf5e0bab4b2ecd8bed170aff2dec2b81e9df6dba3e05ad093987edcccc5da98aa4293dd06dc1c0caf1f5a01485ba7f3443512540bb67b794e98341aada8d0605d6f23d4df280fe567b66e58be27a8f7f57e5a2423cbe9855163fec7737a6484c82f75bdece17120e64d46ab7e83fe2972ec5102e4f6db60be68d7f8c712f8929ccc2799632dbab4c69ca4dff385a59ff5fdbba02daa3a3d5096eefcc505454c14cf05ccfa93be60b99f75fa6d71c35346449ec496aee274cf4d7231c47eae9a2219fb1a18cf33dc627139d2278fd4031129401760b7e2195e9ef70ad0d7e45a150ca33a2208190706ca2af6ec583a27491a751a216a1a36b80810d7b93a6be90b89e7de19e31f26a473565f845205fd802de9aff9a8b6c9f96709c2d049ed8974a8529562b4889474e3481239d1be2674648cf4eacc7db9944331aac76445b4dc5778a20ee21c9d0c4a6aebc04c6a9a92df6cabc0f2aa06a7ca32cc9adadc2e390d4420d471783e146f3150663bae4932685015e797e5af07249fd51c0158ea50d38c70c404ce89b4e21f8490ef94524343914a25ece8df40d7b3e9df77ea4951bd3fbaa7e539bd833cb7d5c9874f10fe43e0ef3750b1db32c22f12f09ecced4f82d280c0582b45216218f70336e50c9eb07b6ec36aad43595214880fb41ca31ae5bff16a4c96100e0c6002750c0faf77cfb184c3377ecb12c52c44a01571a99e98b8cf09bc47848dd719748d96ae9145c11f7291c563a308290b9912730a2a2c39de21d76ae1c67b40ebe813df1991da59f76ca3b59a4886c599ee1b7035f8d6e22dcacdb63249acfaae3c76c3963c0ca7de33b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
