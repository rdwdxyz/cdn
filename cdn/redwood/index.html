<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b86afb54f33d87bdce6ba62eddfb7a97fc5689c45bb7b644892e10cd09fec126ddb7099333346cea607b3165b0f9fc94512355fedda21d328c0a808f4d02cbccf4fadadf2a99002c42db769c8e574547a96db2fff71cd69233149a055c66672beee492bcfa74f0f688b8e7d1212d39e8d73a9c45b25fd345ae5bfd381f100074fb3f3006fc2ca963c9aa14b3f53c4f3fe0a475b4afe61b473ded4bb24c6277b2c60f3e28886373081476600ea4443ce3994a05007ac37cbdf8702aee518ad78fa60f1a1082edf3dfc9ec9d6da79b12eea64c3b49384c269812cd1eeb6b00aa076f866b2bfe1090570b5afb89bd39029bc0e24c3650d2ce6d3ca53a541fa7ec5644afcc843879f37544c9727e39eeaa6f05f9cb1c63f66168fd32482e1e48f749d18d98e2694b8d91e19ae8185dab874de83a52e915afc221b861b1f1ebcce614d9486a78152409b933c4ff2416e954fd48f10ee1dae2e4971b13c393fbdc96e6898c91cdcba84f9c391b5a9071a1195c747bca12fb446e0511708f918ee6f206c4fd14321ea6ebd8c830abfa7f569384d65634b2df5193cf570daf92193f258b1c2f7a6772ce059d4738d4f748794d8526661235dd76ae0db923d0c775ed5e0b63a03861cfe475d25d7352537cc046a784fb1c141bb9a61bf68c90a4e7195addcf45273991063e5e8ae6dedb8bcb4da7110e92b1b949f8aa3f015ec767c9aebe36dd59911dc399a6a6ec1fae687d635c0426821c0847fdbb5ce4323149dae4151cc739c9b40d0036c02388570a98a0c45ff268327ca2ea74762305e6bb852a4aa3448b20528d47440a16e4260a3bac3f863b0a65e96d34e7bee2ed925affe391e7ada397fa6bf3bf72e6a8dc123353ba4971e4b2147377096f6eb7185886df373820a27f16a45407186cce305527c717bd7ffc27e34658143b1f271fc70b0086415d67bb80938029813b6be4501f6a42f80b900b778e6c347f33934662e0c1f839d0d9dd046bcea1b382772f5ca2dfdc1551c3d94d1089221938c746886fac36ff52361dbe6bd007ca01daf4c52549ae18f4d6b25e6e6c1105273bc44f9b60546a8e8416d864c4defb0b385831eea6b9b4ae9f34d91057bb3710db9d5c3e01e36314c7e14b236862f7c37a8d3af4f4c10cd01040f1971ba643a353698e7cf308d20fb67ecbafbd9042bc0c8638b6b42b58f4fe3499448d11fe041c38736a1df5e724dc5124f4ad9793d16fac3785702cebf35cbaae9249a9ade5b00c8fe980111eb923e1d4ab116b75f9ca509cac0b4e6e676dae8c4192dc62d5bbee7b3d8403f568bc31bd04668c2b8adbae56a2237c628a4bcbe930388cfcf3335114d2d27aa795c5d9664d3d7a0d057229737b334d6d412ca389511658b6321b9923b7f79f3f5abbe540221172a7f0da2bafed2e014892213ca736b0693bd59c7dae1c26256f49a6e1105482fe7402ffdcc035fba3f06f0152716befcd759efb09ad32c69d7305fc9d6ff3c1553b7c0ae8d9acab19b465b2f1f98bd82aec25f347a049ca258358fafcde08f8ab7deaf442b9564dd9608a3983924f75ed5bf34e49d17adaf9a6103edb957b1cb3d8ca2691c7c67da0e85a7bf3ea0a0660837508fae411a42fc3b88fde17d14d4c47468f07c5d771aa76f068d6c1754908ea0adb8cac006ba9046d64008d12111b61031750ac660e6d51f8e00e4b137d0edf7575c7ef481e2b829b6d817c52d803065eebc13e63e1821d836da88144efb99234a488d49c0e22553818a61055b93a91be0d6677ca8d2ca80c4d1dccd4e3e9cee7d23095e721d0b9b320e15897085696b2ecca80106bee62b7f30e45ee9ef87c28d0662e2e717d79594154196980c3a5d57a0770c4deeb320dd6ceec4cc23df9c9da24fb02566ff7302d2cf382cf37931c7871bb45c9bfe328f96c74e94a487135e5c69dcca64716bb328d3205b16db7d906a4512e7f0520c8787638175f6f80170aa3a468af0a2a20d5298ffe54110310bacd32e0a4d2350133d5edbb34ed1c4d457237e6c35605005d7e0d85d47b2ad13db5107b0827fa61c2da3dbe09998a7f2b6bbfbbfd24b7ff2a14d8df852d5b5c66131e2c052ffc60a6971007f627039dbde0a8c20a52d2afbe15372782d2ffdd7f57d11f229c50f16954dada00982685a484479f15dc471e9e1be8918be1c328dcbcf8f45d150d792e845484e9e622605581df52d71d3d999162eca3267f16f4b502bd8c4963295f1fd381c3e99de29fe3db033a982e776c01107cd570bbee31d8c5f428650da94862105d46371a6a21514fa0c30e8ecf86d5fcfe70773fd205a67d7098b603cdd8a5df018f73901a5ee246750dd18691637edebb31fa1ccf631e63f723e370e128357b78c8ee4712a0b2bf68064b4af6b652758e73e9d55e98a73b9b52b18599d7cd7cdc6109a630596dc8c261ecea57cdf647e07f7eb74a206df78d835692740c2d5c1cf433d768fb4ba4b00b39176eb2dae4eb68546c66b769c7ba16096354c8ca12ce022a44b69863c6c45bc8d654a4788bc73ff001cde871274b9c4b7f252cfc503637fab81b1c018098954f1bc3f42d5565e7d428736a593b2e531a7361db08e393dadeade499e46578866db139271d51af1a7b570b5bcb42287bbc2df0c7097ed195434f8806efafed8a58e7eaf1ac496edd80d9ddd496f4f71a5510339a61ee5660777ca4ff88e17b80b1ef5c614cf8fa1df2589435e7edff4dc71f72fa8b241b48c8a4991f5649da33d41c336facd75a92adf9eb93ec6fe49399a29872f046f48ebdbe8f76ef569b56c36f6cb47aa41c602b96c0ab03bde00fc1974baad1b0901cccf945ecf1baf52a4e044da8494d8babe0e2fb2a00991c3ee8d2bd9a9cb1c3ba6315c6a5b625bf558d42d1b241e1cdd46af414883a42f40c809985bfe02b948fda688927f5e8de09a445bb08d7357facc49d863849d97ad5a17ecb4e8d98a0da95788f5b48d1563b4e75a124a00f481780a3d712cee53df7dbe0dbb42e56981e221d3966d251a3d27c90545add2a7a60931a19ee10e18216e9610a83bded8afc774908d6b326205370706fd3e944c197d2dad219535783df5aab128bf58c4c55f1c12f883c3848e4301d5cc49af22a74e3f1d3181beb74d9d049e50ef64f023d6a59f29194d29ce1787e4c7aeaa24055a0e6ebc279234bebecc0f0e99638f41288f9eb85df915f41b18a7b5344f7deaa0e5ffba0c178e64ba2fb14c59076bdee3ad3ffbca94ff47f21379c0cf117034e46c554a9f489054139fd55bd1c3c44d58e1ad641ea870d29aa282f92e2fcaf64574606ecb3b66a5aa35a06e131b863f745b34d5eb28e8e88e609da031c693bb00dc85f6627152b1789a4e5aef57a3dd5a83f603bbd9087accb973502ca8f4def0e6552ef38e31fd5ad9b5652a85c502353c527e45733f707f9d990dce20eee55067d22e6ba0a14d34418f6a04a1c9aacc7735c4536a361dd33c02b93c0d122bd56ca4d63102fe41eb93e3f3de09dee13921e25f41d00a3cbf89efc6390f7f2f3927e48b549fcd74776d5c33785878e4b23770a8e9e5683f03846ad0aaab7630e369757ccdbf18792038dccc7fdb0b70cd6eec49aa148cb204877ea215f2e6b9389090dde897e3332f5100b505407947c7a5602ff22dc6f010821a82c673b9ba32b67192eed4b76a3fd829fd6f6e69405ad83b443650b24054d46ff590c6f533380bde3bbb2b278f4ed8b65be6170042f67bc8aa4dc32ca24503bf7a36262864b832088066acb6000a9c7b8666aecf3e2f7107e7a5c5791f734246ccead0b23b7cb9441a9f1744a62e39b5bd33378f34a97ff5621a513eb0e2136dc3b1ea64d9bbc7e198499a8fc29cf1c8c35e8b7a078944eb85084491a5cfc000d31f7dbd5d4a7de9bfad04120620365966d955a4fa0bea07f0a839d5fdbeb09a8dd83a56a61cda5dd76924cc09280be2be17598d47eeb86c7f394f161ee44122e42c0e9a9d16e221ae55f9c6e287648f29704165a802ef842eaa1f06bbfa9d959b1461b83f808730ee395e92ca44817cb5ac98c84f33575fe6f0753df3dcbf7dc7ccb2f6730d3c147346b271a2b251a9f301de57128d5a116f58b4a86eef14fe5a1249472c3d7423c163cb28dfca73aca6eef2816362acea2b81cade371734fd39954e30f707eb45b3d2ed4122db44151845252d0c3ab278cb75cedfe8cfaaeb5167f8a1ab23549b9ccc6a6650be792711924fe3e4052e8a6a2edccee01c26b1ca8841b0cff2dff9f83fc35f7b749bbe5a740f3cc54cb321552b07448d5f8bd463ddb7848c5500324fac90b9edcb4528843a410d460318f37b43c01f2089ad7a066a49fbeda20f1c8b92db4e12ddfe2f0a82d5a3b16b69d58ed37ac1a82d10b32b291794a7d315cfda77d159261d5fb4af14a72b12bbe0bd2aef2e360bf116f02b59bc9d850d4e6a7e27f68f5aafe0b2207b552ed8419a5d8f479d17d26f7e0c57a59aaeb2a92d431be25f797820c9ae37019f096399a748b93021c5575d04728e07b7ae058b25635e07e8f2494ecfa946f2c2c3d7eb7dce1f6f6e2d1bcad295afec66e1ee07d9b38b2e27a96f2bdbbfd8948ae543509bee369a5ce14333873dd9b7c2e90b370e84389450aaea48a240db1d9445a968cd49e74b68c29129fd7eb52e789758cc6ef63c654533e2c0b2300bb64762fa1f6b0ebf8872296e3020f9eb3e17a30e5ab25a5b9c4fde3e5e1807e68c98fedddf4ca4891e1230374ba76d50b7f1438e20c865b70e6c2195591cb1f3f60fbc93fcc2708cac5e126ac89f8f63f8d7b020bd3f80aa4d6206244e9b588abd23d1901c00b047d1c012c9a83b803b036a807af5055fdcaed83f77499bc8365a84a47e72a48d737f78708168e0148eb3d713e3a92f34960ef3459c8a281adcee7ee758f4ab5d806b8482a1beba6e1ddf055d4f26c72fd8a7fcb0f379119fa890d9ab5eae071718488dec48b0df1272b8ba0b10b603b5739bac571f18e5d0fedd33799116c63418d7a01945bd6c72514ec5b75db781334abbb1f7b987bd368d5146b1457bde892fa8df36a53f0d826664bd72ba49f72c0cd9a09d0c239fc05e6bc77cf6471d49e0b324e973c893ffe2d3250381057d0ed57c654375eb95446684647c09b9b7223214664fe5ec2a116f567cf78da6d422db9f5849491646131e5cd2519a44c188a7057975a2c4392cb26f33e020b9841fc7e0384c2e14c8dfe6ca2f18b645b2bd902ff98740fbe73a03d4e61b439b6b7d652dbf8b2126e8a732a5808ecffc39d4770204a6fe93ab4760af6778f4fb4113e0b680b74530e99a342c3ec2ed965bbb30ef3e25fa24838322f5084a0867914d24df4a6a3ea566a5679c8f2fa7bb9394d0409e31280fbce5f4dc009427001d65618ae52caeca1a9ef30fbbd683c6fce74c4f7eac8e612ea3ac0cdb7977f692324200196b44871fb759669393d844ce089067e88b1d48f0d3cb3343a79dbf16975e3491472de74225320b228de6eda7f551fe256fb2c06c43849d7b0ae99616eb6380debac664f63fcd2ef132ac40c18f3b991af37c1b55251d7923188c42e2e853d23081a49f17a2169fadf8a4ef245c7b6b70ee7204f30698578a1093d43ea5a380e17ed190e25b14b9a59e7430493ea5f9a7e933225998fa1f624cb3c0bc61b1cff7fc6585c69f7c70c319ee16b18cfef13472eb91c5066045485fad6609488320d4cee133351f7db0686d837d4b2218924511b33ead644e043a6235c8bb242a6886ef12309ce29c20f446cd4d04ee35d1f4260ceca8f7e59adf33f52292797805780ada3dd54be9b0f7eaf7427f5b80af50c6841245c2563aee128d3092075b5589bfd6237f5c8e1052d09143ad86cfe707eeb1e62e70913083b24ac3fddc64aa93a4318621aa6567a5cf7e54ea552940a84068a717dab5bedd1f75f9d2e50ef3b49edc1d293fc706080a9f82f15f3cb1b53d98a4d2f5c9c3fe49bcb45b615b6aa9e2b8955a2c6392437e8fe095fbbdeee3fea049b1c1ecd0e952662bfe0e0e90fea0024cc757fffdea6c3ffd1e87f75c89000e9cee039e571729fb3e816b3653e1881cff9f5dab73a38e42ec39afb580c8ce10a7979339a1cd86e82eb34c740c0d636fc23c01a4a02a280cd30aedcba1dd713f69c033a5dea8676ce2a09135dce51d0d3f92947bc7c89d1e6a4e18a74c1778c34c53e5cdd5678c514cdaa70e23022e3a45c06789d44d161f127fb61c4ec58e1d31839b7dbd25f6f80fb0218857089709e29ad4ac10c7d6c79cb8d30089651947ad484e8fd145025aa3cf0e728e3bf77c4c3b9a89ae7b0b3051ee4d98ad81d4b9e125e937af5af9d42a549e8b79526973e0cd53d202f5ff825f851f817ab99917f638579cf80c9d9a475373991cc346c6c8fb09693cea09b84183db83a75809d74208b5864b6f765bba3f8cb6a77611c63544f9c348b0c48f679740e3d86856971980d8fd928c29e516ee9e67607be15c9e6a98e66d24ed0e230f82ee6b17154945ab81ff1705ff7998665d56c1327275b36c927064ceb7c0b48f7359075201650997bb84e0c01373a6f01703e2857c2f5530d3196b639aff815f3f78908d0fe64a762dca67a385bbd5bc0b59f851ba8f9766cc9b14501b9079a240f32708f90148961d7b254f3f6e64e55f2cbeae7dc846ac15bd7b0296845aab7ee38c428a4df5185c3188fd192c2d1adb75b281cf7b2503a0b7ddf3bf7d75b6b180b7a98f1009a4d714b75e430d32ff36ddf1359fbf60cd8d55225d4d04dc2db91a2d23e5da9ec0400e95087c36b79423c8ec17028f0b3e9154960354757695887d99bf9f840a41f807b748c2eb2a000f5b681a4e2114fb997c340134529ee03d5169017e76d6932288892646d85b7266bcf18a1b299d7237729106d5e6bf0e884c9fc9d7ffbb5f53e6fd14bb1f09a24d80985821f1ee2144330a135b2b98a14dc2621f23be96d7ddfef226c553a92cfe871ccada188f9e0dc8600b8f932ce5ec6789bb9afd5e860125428dddc9a12497428f176a58069892c8e9dd383596302a499fecaadfe444b5c14daa7b15ad118ee20d5f6422e4bddb7f0175590d9584d26493bf6adc073394a6bee3eb40054735c2b1f49f2fe92643e6323cf8da0a41f33c1a32c62075b9032d672ebb648db1968cb0540fd8efbabedd14a680df2a3eb3b9e2bf0bb8feb635e9b981d19d800026b5d0a24f856a3573bdeeb015458dc26a57fb18de22757e89ac6c1e26e2f35285a55e00f42bc35c8ad8afffb229e42b810e52b729673e5253458e0d3289e1bbac804ccc369b16136a17afbc7c3778dde7669afb2534b849272badb81c77b57bdf3c59b19fe9fc4e24ab597c810d1f1331cee21a534e1336756f8d20368c0d4e9e2a28ef2ef351f42976dae97a461ccb33e2941fdab6516157959c9072f1baf13dcf24a26b0b13546fa1a5c29a8e67a6330c39d0b54639cabfa1056dc5cd6d3df091376d86ab11f4dff9265c6d7545073ec3c27312cc2ad562088f1013e954b84dd838a0060f995f86f1152f850fb4b8b086233261224371e31acdb4e1ec3e18eb3c05b1a29c7fe046d101fe106b9c997875b3489607b9ba55698375120a048370b0e569c0a5ef2487fe4db07d43cdee7617d7183f383461bbc02d811e09708be442a90c79c2e15b4cb9b4dbf9fccc7046ddd8e9786358c430d810d04be0f97bce043a7aea3722b54e5be88871e70bbf3e89d2512c8f1ee4499ca0ef6325933a11351e71a2d6bc0c9d441bfd255c3680234fd331c8d880b7611072f71ba2438a994768a1fe2925a6c1cdde3daf935d91fb3c8e9ca4c6e4f6046ecf460691df9cd9fa16a8b9f20cfdba45f9eab652b48672090a4118f6d142029c260e28066f55a04d46912b9512f1654320512126582d7cb68ad45b355dcf0be44b18a2b159eb71d6b9f7ee589d2f265b38a679442da4157e362dc8e785b4e50a555119fc69b550427bfcd4b1fc27a7a94751559679cf5b378eebf4b1a86703e804708ab2918f6cfc76dca35d633f67c603c86c58497658aa7ea8163c84e10c8de24007bdf840227913dd871c34fcbb1d52770f07153a59e825b4d1575b3583a32706b426c1610f89c4362710f87fd301a8bfadb2e68507e4973af717cb591edecdfb88a7041b457ba151810686b6e970a2fb154d5346578e9e13cfc47a3dcda178ef3a7092084cfa7f55333a5581ca585cfa638a3bf0ba25a584fd36a7301b751152e629e2cffb162f5fefb4ecc88b1af7763923c2e1ae362e2ea16c5c0152c9c281c51b32f2a67e84e4d6670237fc975a680d1531ecd1285ba2362abf4b65151d2013da1f897c2bbda7db4c553170447d1813f789914539f49813c93bab0ee0aeda4a5035d5c706bdede6bc0012339b48defdb9ae6c9c03f6539fc410c76e6f0759b13683b47fd29c0513843d4293d7a0d3ece3d26f194e9239fd05c83ecc0ae8fb97df2f1b4861e1ddd38be99a3d9f621845ae3cfbd64a282f1606ea6de615f03baffa46dc89f78f5a275691c1c576f149aa5de1c377ef62660c2020b5f9d669650d2f1fc6d70de998267eed1b26fc9ea35ab3fc925ac3d2db762931648d45b8254c390c37776ef7fd42638c9b1cc37eab261b7949a55be00c7172386fa98c65dc11c1742f3d3257cb0987ff3a80eb4f43b6018c595a8f7304be56e86c17ecf24438aecf307c8708c015b3c2136fbc21cb62d7fddf87424d1b73c83bf7a5058a520b44793c5aa8c5dbee169ab5c826671222a293dff71059ed6418eac1749285e227b088be1162bc14feecc01bb6813b446e71c60888af5b997fd7969d466cfd9da60c4fbe695402058399f4c6d7bd35c08098b3bfe597f77354dc0821a8c849d97c5493a1410b40a470def63ecf523ccef8c18948f76bff7d92fc30633394ef5965c70c683876f4e8a0b81d687fe4c369332ef99da2d5b916b38b47dbb1ead6b5e35cdcac23cd073f1dfcf2f647d7dbd4ac666583cdacd23b49a49d04731145113a77b0e81dee077a33389adb3a20e884ad0dd38f4a9d2e887a96e93ac3fd5d6e0161b3cec5fed01ed7b9cb30527a62392d0f57a35aa32226ff051aee5d7eb8d2af0dac63fa51be535a0147bd6a049ecb5b7596a3481ffc4ec461ba7dc6be9c13def1791b2eb33983b02f4a6d8c0e4c73a96bd242a7ff4e1c7255936be20afc1421e858fdeabb1f38fccb3163cdd42b967deb647dc5fea915184def39579842c3feff67a444d44f965d5bce8f08a97c9841ca8b076915eb51024a675fbd43ded53b36716702d8db65c925a2dadb40d6cdb6bf6e92bcfbd5e0dfa322fa8bee27115d7ef44126e42022279a4ae10daac6196c4fd5932b1feb1af1a1d99c5baf4022d4299b4cc7f2882c0e4147cd0e2072a27a928e6d51fa2ddbb830ca1a6da83cad443e876941950544d4ac3427cd56f6ffb1a560f9dc9b2e008be9c160cc7e7a14b62a51d7921a49d3174612985cd04d7f60985f5bd9f5c2e159de38ce41464a698bf1b95492ea23d56fc559a5804c7ba575f88b9b9976a5b31d56848f5f57ed80d348245805cbd4577a9f5a5fd45711c2f46997a51ec42965cbc6f35b98beb87f6dfce229d58a8a7eb8b471e9ee5be7fa8fd84eb4481874ee8d3c5c1c2926ea7e02ebd90b44d0b8012c861edfdbabb09d6ad75e937157b2a1623eeff99936a82b60366ffc0552b8f8f2177585ec20f179936ec7e695817ceb1fcbdff41bac49b004e4f51e0c57d92124e4cfa41384195a5f7e3f4975c68727d8d7b98fd263a52ae47fdd0cf39a376ed96276a689b36facd4ea6f9bcd00bc5a9b8a4aa52c7189f40e517ed27bf928dbe02a6ab85120bbac456a0eac02384d3c3a7ddc72450350ba1a46fd0e03e527d0ee090215dfdb4ee10afb3f44788b050debc09f8e9d599b280a37a7eba5df45c6a934c8c657bd1eaca5530d436f932e6944e4b5936f70c80d015cdf6a3472b23b8547c35e82204da4297952499bcce4c346986247296ad51e66edaaeb5b2123347fdf3542b67ef69911349cb41ddc06bc4649df1d64746a7a8b12a1288dfd4d1791d2749ee2e818c4cead8b990afef399021818b22c0b0b8672adb9896f58ec9f3eaa79a536cd3b1b7c3a3104f4885d53148cd3af920afe75ee676244fb1d437f64a747996367f8772e19d48aa0d0f0f2a97fba99315dec6c61fea36d8749fd0053c670e797e20174a76da96bd95f77ee862e84fbf35dc5269e63d6f54d7d2b51016c24129b7d75773fee6da4d24c5bdf217c27f6c81f0ec532651b265c67d2ae4a393e031fc5f6fe643138eb3ec558436c77fc62a963db74bf9f1ad636093b7872bf381442eaecdf959988de81d76350ac29a7761aa21da15c62620eac781802c476a453c830b509626838ae2f11147180bc9a566f6eaf107166de6b8ebcd41a96e49db8551881dc242fa288ffd02d230ac97e4a12860c856d475db9c4913efb11e56acc1f3c349ce0eeb32b86424fa012160c669e1dab18dbe32979710ee40faa723dc3d86a230e94b47d2b2daa3063b152f696794c02d4735c180463a96223cfb68694aceeca050d457fd229c40b1e1c17e77cf1cd37a7b752b6bab440d1f4c452fcf9c05d159cb2fce49b29983c0fde08eccb36298796ee57c39172f893a3ade57ad58a73fcf0232aaa40a3e6b1adb2925e94838e33715e172949e65557eddca083596e4458274c1ece969c72f3491e99b81c7bf08fa3b688b71d51667333f04e3863b22ace1279f076cbdaf489e2e3f7938eb6196fd75744ce88d8be7386588ed73d489fd6cd751fa32ccff6e1d08eef9796ec7f9060b0413dcbadc975f5072925ad0039c37139363c0bc9dd39fcc97ef07779372fedc5a5d3b9d630ee1f0f7b55adfe8223b5981dc23ff90cd70a99bc21bb3f36192d7d8bb43dbad7e186ec861fbef889d82aea89122ae87ce9b681d1c6c3822333febc7850603d0129a708417169c6f2bbbfee81d347ff0fd46bf59a412d21a49bd327150db94e531a694a47a4961411e0c47628ed744b8bbd01dfa1f62a25498bade8862bb19e2c9fb95593af3ac1b2f2b253c08bc1a46c368783055dfd9392774c5fb6c149baeb513883d13048e144ca99f218ee9c899a42a3d1330244fa9bf5211f22a30b662bf2007db76924f5f725de9280b5ef5ae0bc575630654070a70cc76517641b0810fbc352a6a4bc3844e347b4877bcf77cf13eb5a2a294e2af2e4ecc7a89396c5e374e07c6493d1ea4850a108a868869be8d1cbfb1d2eaf68772b7d5b5fd6f65b3338961dcee1204287875cdd0298a90eb83dcc7e9cb33db498645197eaf8da7536ae9e233eb23894119226e6497fa50eaeaf42924c4c3f4b6cb08c76a8cc7048b59561dfffaae7662c567ed265fba4fea9cd9b825bb032a933ecf4d20f69f4df474290748160dc54d4a8f796db903e4dae9975517d849aa92d4a9b8a933988bb6742411c459ffe7a1f52ba8585b02c468aa2c0d133cffaf85733b8959b3f8c7a83a2f8fe40e260e0d981d06b22a737cab712ed5537848c54aed97cdc86db225e6f3f360fb7d95abcdb33fa5c916603b02bf4b05d00eabbf90d33101d5eb9bd722904bb41b2ef2497d820f0a6e5686abdb0ade76af982b053c97a6ca0beeefdb1d237f5e803d81206a86fb42b6eb463a4cca924b8ffec82b9ebfb56f71f3e850931f1420821f0911640818e9992a3ce623fa70bf373a1bbf1640aa14a77347e9e412509015b5dada2b43042a6897bbbe6b9e68462f8de93b0ea16e359e39af3d65a0f163b03ad5ef9b2cde9dfb1142608548ae1e728f9425bdc65e744ddbffe9083b6a7a6c13f4857f4336a6eb9d0dfeca7833570ea9cb0ce7d74170aee607b83a696d746221350ff5c6a0bb77e836b34ab6ee6367bad8d42d071e29daa00bfc5ac6e4e461246ac322dc18af39a70133f0bdb419303404772dc55253f13b3a4079c164b328f609d057ff8381711d586e2f7fb0f85774ccde391a1005d368682e9230b7e9ece36858d6eac01c8e34baa5b1fd380739224b4b7c2ae94f56da7e7be06640c1456a625cc318f73a58bdb68fb92544b67cac19164748feda9ad96623d35a313076534f06a157f60522167a62da9a9d7ac7ba48d073fbd9a4bafe40cc9774c8bae24798647b3cb4c25cbfcf8acfa3b1340a76407a95d2be6bb086377f046141d7fe84bf7c080c6ad8abed497d0cf98c2cfc7f84b28b9564f4be27ab7c3e9bfad2373d366277251c1e202fd7d1452cfc8a6b742d16378c79ca79b758784867470381d1cb6b1808a6e51c203045e5f80a4be964bcb5efffad6a3f969605a0f42a96f14835eb6466d0572ba632647938445d4968ebc72016c724b857c7ec3c7198c2dd9590bf4b3175cc0091b3cf8c6dc28852187967c2083b60955e2c4886584642c222c379fdca83ad17a03c0b0475005bd14cb13ce3d864ee181d7ceed213f8e25cfdc587a429eaf044fcb5c87edeff2844d6d8acbe0d212fce8141f4e5ffca397f1c1b1ecdc326bcbb961e881becd8c27482e16134bd7ac17429b3f997092f7b7d0a07c52b9cce78decaac0d62a95a63b37747ec53d7b83db8103d065af1e6c649edd40833cf3a96b017413715f253cf98608f196cd51d8d2ff4d7696740fbbfdb6ff4a493b1701c1c2d017a7c1b64e8aee1af9c254a74eb4556d577c70e7db34e481e941ddc3e25c04fca535c10209e4ede2b71ede3075f2e5b326b665f5e87483417ca37f2df84313e5af44ab8efdc7aecbcb8d0468f22d8edab9f9c4891b8bfbd95093f1b3e14e235ce2983c74a6c372ada86112c9384c030ffa74c4141ff654aecd524b598f2a1e64c164640d2e47e014d412f79cb3c1bb77bec1c799cf3e282a7ecb82c477d840e9eb3b987aac105a9c70515f0e6da9ff62636d4b34ce7bdf62ddb834d9363bb54607793a67390fdb72a8264cb47c3569ab953303306bf4ea827705ac586fdf6201a1248381d8b3f26a0b6f3cbdb7f2008a6e7c8f049da47cbb5aec1c533fc76e4ee7aa75bfc0bbe78b0d92491152b10b4ba07865ef5dad3cbde2a1eae89f2121a18bd0eadcc0c605b45413cb497e17802c6d31ce5880530c9ed10e4b0d6ffeb5d483a853a586f8b31251f81c13e942fd1a18e2c66931adbb2e4593133de9d01c8e31ce7217c0209e76a9885bb65a08de53f6f9889741de3faaa94e4cb67945d7b6cfeea352ae6e9a31ea58a8cef32e33e3026d67ee84e5ac68b658098d05b084073b7a230a712ce56075d113359c1fa90dd36fa158f08e2c41999e18dfaeb73cc153737036e190e9f1f3a204b6bb05a70dac0f8f114e10ca4ac3fd9dc2b050d26c8ece3e57d8bf74cb49d8ebf0f6fd1a57f4fabcfe531b49068659454d575214ad8160db48f975c05011aab426cd7a7b7ebad9e0607618d9cccb2fc2eeebdf43abc22354495b7ac9a1d330afe90f9062cb50eba9c46e85513cd4d4c41246b57be55ce29b8d55a77cf0842e81de49738b4bd70de3e5691995ea901c1e93014238bce99e9da08e02dbc9434c969316ee38927aeec8c022456a58296cb6496f9f4ddbe8e2d6cf7d9f9daff036a6bb9251fd6bf85f4895699e4d97b9ba7195ce11c220b7ecb7c4bc6a44376dd86cf2e5321597243a76b4b1554436610fde9228c90cedca63aad09cbdc9bde1e565e4af3e15d7b25b560c4c1d5b52c4e06bb800f330c571585ab685d7002f88a64478aa2bc0628a5cf5e85632e2b36888c70ed82e55a20432f01e7657491bba0b7dea572818172400a639dcd9a0f485461b2964b587156a8f61fc08cb569675d245a1977c6bc4b79e4b3ee0ce5c092051b468f5689f36b3e7cd0298b60c604adddb26fdfd366e3ba6f878aff5f5309ca218fe2268d5cb0f7d923d8d9310f0313e660b8b4f4d9c565f64bfbb7e9b52d97be1f11e7f3107e1c1e25ce5281ecdc2960d81513134a448bd2280559227b0ac4b3dc4b67f3165b875174f8f3f7a08982068c99f9ef575bf8e05634a280cc4688fbbeefe8784ae4bfcf31fe7d40e54953903371538e659f9f091fe5ddb6045842d4c779754ca5daedd0d1af7da3628338fa680e22a29705cc16706663bec10c42dd52492012ce6aa5276c5c6d59137699dafee52b9cf572a91d7185ad317fe5712be0b1397daab0b1a53d74965ee7adae49a613be5ce642a20325a9e2755fc94f7763be0906eedfc7e6f482663b1b9d9680888d400f15fdc1be9a2d0eab840b7e3eb032a1c885aed37e472460787d3f96f96a0c71486a9a74fbb77098984d3ae85f4dc111e95411ac7104a294aead6e2931bdefcb2ffbaab338b47364aeeb97493efc19b257fb0064c8afa3e43265298bd217f5db5e4f9ea4227b6972342d9332f7747444e77cf239f27ab4fc5768b70fc9acb68b0db27adb7e557d2599515bd363f75ba4b33550aed49ab993af592ccdb4df043eb56989b46d5073fb6aed67296adc173cca22619631d24a197f6bb56a9744323427d7cf9519d4db4d204793cc016a51c945921ca6090d88b7931cb8adca6339878a524720c98005813f065fe302a7102970306282af36b5c2c07950437cf4006a6d658637d7834e46efde2b0864a81e30569a431ee2e4cc4c64d2320401f5598800d5ef2f9dfa591b059cf289ea52002bf5fb5f0fd776b6769d731575aa3f7165eb75845a6763c093f985a599f83e0bb5af0b81e0ace411c96f94aa66bbdc65d32e9936d02f613fec507d4c2f03618425875d24274cbd6626eb85de7208204b888dc9ab80dee6dd07a9d447991c59c82b4c1729b2be910592049c7c96d72ec8549069fc3aceb77f187051fe2ca78991934a6dc617add2435c5ddad1f04715aedf6aac6461930fdb9069991af3fdccd9e20046c1cad5f18979577a841b96376f3eac57aef2a87aeeab1b3dc8e47058bce7894dcc54eec364a58d9aa8d1f4dfb053332d0eb36d1b8e02c65be9ae88395bcd715d27ce758b162586cc7c0e1874852eba028e25dc835caaa3f1d6914b10a8e23f031c61a72e9a53bd78ed91f44a94990ad9201a0ebb3d4b63d80cfd79b4a9a7df912731b9363c93100658799ae922472fa1490aa347f0ca96e7d668ae548c45c9fc3de3f0014cdadf2ea3137ab3e5d0f1f721613452c01edad479e20ae23c532f5852a674c178782dba6689844d054e6e5691d8e1eb986474ba686d75200c4609ac161b8dbecfe286c861eb36b68fee8fe4ff888bb920098d7d237c50c57d7b8a6ea53c53a6b62dc104fbaade06a4b171f4146e21851742de80f6aa65ea3a4cd6b1b5a1a42b2a7a8bd8dd5ea51f368609a972d27b32f38644d7f9b2a7693883d7bf8cced5c6f1483453554f69b8721ea2bb5456ee41ce01a3cc0682a1d8ff8572381614aeaa69c49cca369433fc44779cb6829e8f408dc7655bbcbe8858d6a6cea30a169b9d3c45ebe45c3a207cb7e14a6ac57f4f375742ba42009ed751fe67746bc8006141f3f2668535bf2a174ccf8a83e533a5a6247d92f2bb968ec092ef00e6afd126d52210ac2fb6110d389df3d225384673e5e060e049d488bd82ead3de2f3c12467202fabc644fa8d9aeba7015555613a5ca11454acdd964e91303639f29d041375c3d82dc24e12c790320862e16fb3407403838ec032813fdf32a729521b3a0ab64ec33eeb1d1b46da17640117b87a1bd032256d407b1b9b337987d1fc2d130f4552338d503f0316a55d8001088625641eb9159550f6b930b5f32c14c93ebb28f9cc473ee31a0cfb93a8ab09662613b190743595308cd122894d7f9a8048ab3ec077561d24f6fd18d07a9cf73d5f926934329894b77c567595a0079c2db874b6cf1df1d13bfb1e1dc76a7ee08c183e37814636445ccb77eb8c1fcf30eb5de607067d172120134652c43c230bd8c930c1bf4cf7b73afc536054e91be15b089c8476f76ee50f8e82ec7fda4a4cd0b1232d6e87ed99d53a912a87941249a31a70d8b038410314dd678ebcbc97efab12758bf88699e8da76b274926f4733455b2c6cad9df526c0df26510a88e8fe8f73f98703ae8828bac88b284ed5d301d86dc87b26ade3fb35a4dfb08b18d4c4cdf4328050adb1bbaf37af234d11f4d2022aef6457ecdb6d16c92eb29eb25a94900265534e172937e30c4a77d1a966290be711591ab458fdfe7891db859daad13edde42bdaac618b516c67871a98f693871ba0e124b32f4eb5cdecdade1567b00c18ac5af2682462cb7506097c974f7fe3cbd49ce821fa627dbe63807b7f839854c0c895f9b902d21ea1bab7a67b63e780e0397d9c8592581b515a8520b3d1ff8a4e4949dc6a2087452bbe48ce72ec43239f29f74174cd1994d80d2ec1473d171aacadc0713e5caeee4a86828b5eb5816d9969cb2cd916d41eb6773da6ea35c539658ad75822109903b0f2a8134d28b3aa02bcda9378238ad006b26695e48311c85fae8456ed1013bb60efa002a7682dd569bfaabcbc08f744eee66f6acda02fbea6c4021f917f8017da8bfeed4c35c309e09ead1280046b452b34595d10c2ee5f1122cbf1e52b36a0fe86adf8b0704c36d1f287d547fec7138751d792cd06ea204eb32ed84de36c28aaae79de9ec2651f3972b8db1a97826579fa149fbd85e375f8b5c999ecd7f4bf5bec83f2daf973872413e9e2912a230d5ed04c92af77c417ea2b1b6d6efd4379e5ad7bbbeca4145741815d45e649c84a286f11cd08c0f2b40db0fa0f8edae8ea1c7a3b36715e86dd987893b6475bb8df824529ec01d18725c2effc5543fa3034ebeb6a40b317e35f4692ccbb6d2b07d744f94b4af1b658ab4a534168792f35a4d4fc7ac4efa802c4b2a2158e0325dae70f2964087e76dca2fcf7d93b56ba5edd83cdddc326346430daaf66374459aa1518d3973b88021cc9b22f06f17b7552dd85f6880154923c15ff8bc90323191f43fb9fb96a45719a831517362afbf0237dda88c5c5c0991157f708d910e3a24cc6473d5b2329d9661bb78796360b00da8f222d4f8ce37456671e168aa0aeb08ea042c2a6382e235e0c1534c65b0b5892fe207d0c817c5bc1ab73f42219b7a95e92c4eefc1871f521c64c991a8a60855e255b3fa5591e7c1ad28d4cffc49ff26f7cda65b65ed6265c904555f2cdf5bc80fbfe07a87a764a6c3d1d67328bfdef27db09337bbc5c511c91ca1850c96e4d919ee26ac4c98526afa390ac5614435eff0e7c14d295928b827bb7103e82a0a14da23b637f0ea008a4a7bcb2490f719adba2eb2b28956e01077dfde01d71f889d34eda9c7d0353918a7e33d4384ed85e5b4622d9d3a8fde70e69a0d2a6cd02273dbcbe0fe3438009ee3b056cb681b3a0fdc176ec823de58b5009bd5776cba63b45a42a50c1fd20599f3560139edc12d3255218ae3ac61c2096fe18b484986d47a19ce81db351355194bc884cf1160c81abb7d806f30520671d3f10393198e42d8b0a9b18af1d03244f90396bb29ebe73b470a44afe0d308677ea337ca6dc2bc6a538ae2ffe15b285ad47174dc19abb749a8276953b40684a114c332d717e83de6a24f6bb16d72ec7f5e049cdae9e58d4a8cba99d74ab3aff0da58f6756cad1a690a36eee91459435ea7ffbbc2ce801b16fcb71af32551c7724b50bb7eb3b952c0b1991d7662bce9a038a440217738398c9b846f2b36d458f120a739e9d6f540c89cff5a3842777124c651d6bbefd7c154617a5ca1dcb5c9bdb00506de6256ab08cfc7f3d9ae76e2090e6d04f2bb3b0a4520512af23531f119d234a66c97ab20084c31acce5f87b0b1c912f9ea95473c2ebe890fb1113809c908f46f3e008c53dfcce437984eb2fc0491c9780190e427b60b4f1d06540b073ed89ebaa881798d5c350a8956f374d3f9a4207ca634ab49d770235d91c4311c313d094cdc8869a4a4422573cb59c86ba0a155e10ec5f131be6d23bb5dd2e41668c6324c112afded5cce6440bcdc3e0560833dd5e0723dd79587d56e1ed5a6c07e49fa7a0c5cc1757588d40704a84d6959b909b531ddb6595a7f7ab985","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
