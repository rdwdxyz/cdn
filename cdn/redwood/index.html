<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"668e95dc92e9ddc95dc261afdb2980636dc01a699c4bc8f24855cab6b47800d5f6e36e5c9ee367db0f65a03b36fbd37481bc0a7b09bf513c6fda47e3752217e8a04086b0674af8bc9a15c8f1d5bb7bf3360e282e63f82d74ba5aa507a6fd50243256b15862a37095b1d939042d77e8636de9aae884e14a68fd5441266dc4713f444195d03d9344f9b5fd0f6fc27ccf9a443530fca8fc7d8ef9ff309aff3d083c68e2afd3925284cc1cff98f03f85203825f21cacf627c582e95d180bbe640b0bcd3160af6b727d2233c17f44c475f9bab42ca057e1db09017b69a2771f75679ae1f1aef8b7c7d377670efa2715f96f486bb697096d0db0f9e25b8e66c035adff58af6fa0d2dec89a899a95600d8cbac4c678aa5c7e8f8f8e28046e5166160b118c18bedcdebf12259bacf4746f3b93afc4bc7b1b8cacf025559641ab9c2949bf7ba0ffd33dd567fa246b7f7cea4c4a493cd1a1115bc3b1d7c76ad72c22d91c9e89de69ab27570bb80370d7da0320a8b81fc996bf287be9ecffcc955e1315cbde2fcc11a82d43db2ae5a7bc04039d373b47c8d42e18321f64cf4923cf122e44378805db644fdc85b6d03b7e0fc1330c0adc1cffec9cb155c94844602e5a0eca5042fd635bc11e5afeb1eb54fc2acac4df686814bba2c6430e76a493d2925ad6ce377ac501132cea8ff5b3743b961403272c6427eacfe4d309f9cb67e453f7f5ae42de5ae7fcdc12f96340d454bd825c0dc3ce4502b27ebd9ec9113389dcd49b1a8f00b8ff9fad863429e3a58870b67feb1cf9fdd60edb7681018387a673d73f8d3bb95aee85d614db1768c8493e6a8f2760beb74f4246af6f6cd416d230f9bab88b04c565df57a997fd9fe91c53bd217e1750ce44eb5917511ff190fe869e8bf56cfcda4c912e7f043ed6cf0da137deb91f047a6885c773caedb7d8b3815f0acf1e1beb3d03e43d517aa219f11366c745f4b476d44ec60360dbdc6f707c0e8b662692f2c9aeceae8b518fad0f9fde7a26c525325d106c1f01a7289650c80b609535e50a072f7bebd6c8ad99770c37756c5a946f2faf3748b439fa70ca140444259cd26d9542c0720dc3d9c7a2e067723403555f61a1c901d91f22b48562c2e878df41e853cc58ec778d25b355a49a39e1e4f131aabb353d8a961bd5cedd97f6340026e0bc4b7234c76f4dd74e6d33218b48f13bc93b6a244d4c3894a3b18fcfd7e0d6e1f160d3e4984dac444322e2c234b736b1669d71e51005aee678901da3af71fa055af9630765e86bf108ec57450905edb3204572433660587b137facd49f40fe382a92e7d896a71ba2d87f025dd6b3434150c451abfad9d20beafbe5de3a5db127f8c7118e078b4ef083f88951b0efe921780414ddf53ac75174833bf30cae7ea9ef6d05a71ff605f66d1bd1af358a9bd301bffef3b75a09d530163165b98eea2c6b1ecf71b45c030a311dc45cb371d2bc664dddea7ad565143961cccf05ef19b843ba5e303b8be4c1bb7f191bd4e06a498d5d41cd258e9163dc8a81ccf38e838e5235774ed4ba821ececdcc118fec33406b15bb1d4690368bcc6eb0061d2d8ab23abdf5b8e0deac74b2196672425dfbbfc7925a620a975a1cd8d8b4e391d9e9e333e961bf82ed97687a236ac82d68cfbfd173af23800a3ddabee56428531e5dfd77ada7187a4c00055b7a0548df6032a2e9bc47af1ceb05f043d72d771cba66d70dca74daf39622d66b5ee93577a8c2a0edfa5809cae5f89d1a8d755c5349f06907a1b7c9730ef58e65e16e93cec65cb287cb864b8e26098eb3c0ff0e8b8d9d7892d0e3928bfa102b86048e17d8df341ef8d0c850f36e745c8c779af0d3e38338d5382d90a03085b1f7c52283311a0b108eb81feda85ec1cff2c12e3c0058409ce86facf1b77edced8ca9a1b58f022a4f369ded2a074706ab8f3cd8b6f74c21de1156eb147e16923e801ec9984de0eca2d56aa9668e3cc85c9c619c1e74d62d1b3ed982aa38ec90ef75fd1e1032881e581d880f694072b54541fc31c638cb569503151f8fea28e616761ec3747a9301f1b721b233e8a5b4b835462f1b55ad384f8aeada9f39be4157d48ebc89d99b44c7d4b9ba609267a9eeb7a056148076af0ec035fd49d75c9518ecf30d9f6e8c395a25c61b4554dfe490a5a9a6e47eaa241c361b99aca932eb6a0620e2dce9f09bd008ea1cbfc5c396a891fdf8d0b1c44a8ae760f7aea80770dd5527aac68d366d34aeee41ed0fc33c56780e0a0d4055da9280155b95376663451208f4cce767f1e6bc29e88c05e48d247fd42f527f5b0196e4eb95dba253a10b9d7d283d4609ba851fdbbe2f2472c2fd6a8800efb933e1e4a470a3f8e459e2ab18c5a0b1007b8e45a6db6eb128853b44e7f6337063341c5e12b1a88b999da8da3df61ae17fcc277d8456dca6fe908b62f700509dee05459c5e5cf9d8c70b914b234167bf0e6858f33fda67e408a445bf3c6ceb992498c938030879a95f0ab53168ecb2b0a1587a19edb2f618a3dd6337e4f1903369ed1807bf23701d6394f11f0da7285838eaf5f1e8ba4cb10552b0aaa751511c50f7e96488309f273835d6ea3366abbde2ebe1364995bfcd3e9085486a03f43de9572cf34887e7eb0266f3fe35280cee174083cf742aa17fba50cfd73c582c65d1e6e978826915554566410e91a47c25b817e870f7ba783badaebddcaedb148fb59458efbb2598e692fc94fe2a4c9c20167654cb7cf2aabc9f7f7d5bea89635c32eee7356c98efe2e4dd641a4c886802167e0d2a6a559a70f52e076f21245beac1ec86d05a55987fe51b2ad44fa648a889d64eef0d968377ed5c6a3ec343368f4b15cace40e9cf190072a6ea3958df0a94cabb686625c8feee548326fe6efbc113656a7fa64318db0962af85a9e0b9627c3a7ab3e3c7cf96f7fa781ed580087c1bc11435b35e923b9a303fc7970cd46da8b5df2945b5eafaffbff692735e73ef64095f777dad95abde9e321cbe2206ccd1ec92316a0ee1673f566c533be82850e7ed445f70ae729d403d6bb67a32b13912ab9134c8027972726a05be9edbaff80bbef615d2d6bee991a1db7d45c02286aad502475a53e8da3ccd5a928dcde5a8f29f0430ce68d49c5c58cab60778fb6614fa453f74d2cdfcdcc66624e95355b78f515ba6e55bcb7d6c3a1ee255a1f911fcb7abd68c7d3e73775b08a49970ee8cc42fad3351ee13796b26ef0ef30f4fba15e7b7707ca9e0878c911507c3e9a12b4c46aa403643596d3e29564e44c2754d60f63a5c5c596a394dc1d1f8184a62aaf8bc8d89abf33258949b6059adec073c08432bd3dea41d9c8df2c612dc1f868b8fc51614d863ed9771c1654f1db92da0a36fdbba1ed9f6c690a6bc8488cb625874613a716a2758f5adc6bd0ea4009dcb6e5080008ecfa2c8be3f5f60473843ca9ef7ce41bd433571097a4ff47582df94709358f86dc28fa2081e2ed39bfd4facbc57268eda58ec16d79aea8f806a92fba0d5dbe81b87147704ca5a82cb89c5234cf66e10d4c832779b05974cb30a8e86c24cfda6af9bc779a756066a9e14ee84afc3ba488a7a84b02735d7680588e0faa627cedff085edd9fe092be02648cf81754fa8e8a766f3d44bebdc293016fe6b63b7cd9b3b9772c0ca97894bf65b371fe20a5dc574379120bfa84b3686a117566e67697b587a042207c6b4f8a4a7e39518a0afb2de471ec6f565af945d21c3223509d4a76a04630bfc064c7b05d41bc97058944526917e94bf986030115216abe8ab6d03daa71fccf2611693f9806cfa2ffaa8c9aa3c0719ee7cfdfcfc8b12d42293f1b766361204c5394658b2da92d151376fadbff9271277e62f56b82911553a3237ed34e28503e4ab3d2a76ac25a573d485ec4297ff0fddb0557c718429427952dc40f4a589cf0bb3866f04b6b8d316dbf12f544be69b68ee33b1798bdf61434f49fe1bf0f9a0225b48b2c7416dfd760bf657f28d7794fef352f01563609859394e60e0571c5d66a69294a0c74d8b6e547737a9317b3d63aaa81873463d4c35b1faf0e19812919eaed2a95b54c38c54c9028a5e810e84ee7481d8b54d7c8209c16083e4c181e10ca686027597cd41fa547960b8a5e1f88e5cf8de855365421f336fe660b4b28ff9d95bcdc87acccfc006c6983bb4ac3cbcf7761133f2372262bf3a1e46c7baad8d1d7353da5dee72a9603745366a63fa52fca15121b5ea33e8aa683e5fcf70a72755a8bf5073f0eecaadaa0a2aa0c06896b79b9644476498d8730d5d3de97c3d34d7eea73134016143f097adc67542c3153b1285167bded74c1891750da3e0a8e355da2f4cbbec78709fcba2a1339fe0510dc164dfc126180daac054857c441a2569746b69a9e81dc56e7c60ae26fd8bbd120a6bfefb27da99412fd9d9b369e46c4bebc28980410aee2ce2500d04029df9647472f307c9a6ba80e0003e6af584c1d53f0bd8ae068757bdec2153029d2e79d81d91f19f3946d51669e6c0c8410297153d90d17b6160d0c56aea3e466698a5e70997d59df417ccbead36a47872551e7f371ac4231ce11ac3054f020c720b23e496cde70348e522a74415971f6d7beedaea3da5b0a6d3c9711f2000a8d2d470ef52a0481711f029e63eb08a342f4da2f4630e5ac048200adff4d463cc34ea2bcb42214e901da2ac744c85219c61d77b90e6956341f19193d76d282f0118edd67f06e5b9d4f8a7a6f569f9089c83f6a59e62e219d0e52490a865c3ece58d2e715b4e45ddeba95b5f54c9c295e36997556a2266eb59fc964639f652c040d8241192c7b74828b953e059f7b69c876c83711e6525b4d6bd3cacf7f91f10e443915be8080af454c35879244486ad6c7edd86dbea4e596c0bc1f650f1184a489b1298807ca355b28c5409b50ecd8b6fe1110164e2bb048f5844a1008cc1466da4a8c05238a7454597d949993e50713b7ef204e3b5a0e8fe7321b376713cc8aee2a5007edcd5b5de9a097a211e12a2b6e912ca3b205e81747fc771e4978a1d66e95525ef0a5452fa7d19454df54840aa8db8746711c900c2da2692c9735f3a8ea8363d6455bb73cb1615f2d6ef2da0da5d0e76e2c2dfcca154652fe99ba89a88a0f9e55fdfb38da48774a2177b31074c7c2a502317dcef77ac0734ce7af620d1b4e8e8500f92678a8a39063e97873e3d5bde47e925748a3187a2657156a9ec67cf63d59aadd3a1bbb8bda528d7fe4199592b0e9b4b095d26ccd4427b4d68eb810e11eab00d75da7ce5d43f03ed7116c1cee7cd4a2ba995aee4e0cef2cad559b6e889800a81cc8495d4c723069bd8b7bd376fc59cfcc429fc4fa883c98fcb6f2a6b1dc6a245b4faf71322839b8f435fbcc38c8d263b434cb8f45e3cd170bef42ad8cf76a2b9e0eb203e66e008f269e126df877c0338848f37baabc627988bbd3cd86138b457fc136d68baad70146ec26cc8daee349db3762061ffb79946467b7c71e3c83fef5b0c54fd4c0b8c3531025fe280bcd84523e30383c447885570b7bfce62d0c32963e3497a35ee33e5336e3778f1a7d849c660a9c6cd24ec19a333f74d5899cc7c1e136f3a86281327ef4d27bea4f9f863aeab3833466fcfa2a50439b7c174f5b61e4f44fc8b40f91139d021897a21cb3bd1e8b68c03b85da4a9369170eaf5b6e423f1bebac39e25ff4335d49efaa3ee563f598ff913aaa9c90e38aa109cdcdb90bf0ed5322c3acf72b4466304e267063e20f75a231762ea465c137c6c71085243e0b1cafd6513eed156b32b223630341b788aab9a7f43cdbf966b7a58df1420eea2d6bcc88fd4568d78a0efd6cd4a558503abe4f15c21b93246ed10b2102c950f5ceadad318067fac85358bd83d4898f3d2ffd4b62ab75175c9204ddf093d3b5cfbc3dd5f319ce8a4d8e5573a52ef3f9e215d0b0ece040368526b6ff3e0450197e5530d2d33983f25b8b0471b754ec711debf6c1c126f7173379544fd3f9ee1e39eb2235ae079dcf9d74e621984f198673070b643ff49dac1f6654876f160df47bd4a098f8b83b2b5eca1c998b44aa22cb7c1856fd3d864d73d3c720d30b9468168151658266de4a30356e2eba888e54093b4600c657bb185e81afca41b92a60c977ab2ecef18b559eac43341b2ed739e5254c03ff2549e35d44aafdaf35945991435c52bb692f5b5f3bb13b39ce96366d1640d1bab0246b1fbb8168448f6d9411dbbe32050d5c612db78231f4cadd04d611f6b999cd29e6314d74ddbd0dced71aaf166424863583ee998ddfae2fddf7caa1f65708b718d1eac10e6248c5bdd364a35e7bf4e1569f584bf1e4655a97a00b604cfec3a2a9469c85e78fcd6e4cb4b64ed58779ccb834972ce75b652d222b3777231b04f36334b7f7af6f402bcba950ba6058f801dbdce2facd97e5202b24a84f0cee2105c5e73f9b6cf07dca0e13b6efb88c5501657097954d7d4eafd4013457ef6670c955bf99c985b83bd01c96d828478ad5c1ab976e4cf3982c4f9fd79681e9970f89858b605386c0a6f89c518d0c53e07a2b3f0584067bc5da1717d5464dc0b1bdee0d6936057cadaccbece2a0a6546b31d19e463aad04cf5f2e9f83f19ed8fd2a66988128b2bbe7bc421e3670298b7d27e47998ffece44618a78840e01f12e4bc2445ba90bc28d69ac51ea98822c3c5c5a6819dfa46308d56d62d81d51f1dcd096dab64c47325d96b96a780d4e77a24d9fd90807957bbb7ddbed1ab892f442cae56192cb0cf1e3c781b93bc79190826f3cca16b814fcf4207871cb5ce16b87e0918c9dd08e69ef420f886ef3790cfb883af986ee69e50d65f0f9c01287669144162b9a8f6fee5a4fd6da08e99c11fbd45d48c4bf9effa948a33f1f0b98bb773ecf53b316346affae937369724267b53ea4f3457ab0f0465b0b68b9bff7f9e048e14b02b4377f7f2912ca31359e6548ec4207be91192784c22d472d882cdaa8ebbb4494ffb70257cc182cf50bac72179039e92f4d1ee2061cdf55a1321ae8c8f6491f0a285017a602f9742ccf3d04bf2e2bf7eb7d813dbbb291bfab1baa067f81783aee0a643ebc7b81f0d3855e5c649fb374fc43a6594c73ec4877007eb1180f517b2673ff9d2751c6e0e71f8a4acb0606136454335855ecb17c9b9da73685067aa91bdfca0e7610a8f90ece1008582e93159b9931722f78dc53abe6784fc713466bb8943260b0721279084624651e6505f2b53d4f6b89f4302760cac4585a473a994bafbec375ae39d3bba3907f1dfb94a7367570f1bf0e4b260c25d22eb5ba9ad217a9bb5854e999803af56a62a0ade6b32679264c8f51c1e0095f07318aa62bd9a598949c85cc77123e0198e00a4dffbccea904445e74b8789f2de2b21e3a047165ca9928ee30f620e2a18697d85dc2da8ced489414826758f98b0f87e9ddc208a2c587c4d95cc5c6b50604f88a7776d82ad9da6e2a873b97a1453054e66788fd2df7c99aa0cce3a0bb3c8df8bf5ee70eafb4d1691a23ec4fe28cba212a4f2625f5f983d8e2fbd8a41ccd7854cff0aa2366aafbd8cc07b6d69f4e38a75bb2015f04117097b352b78ed15ac28752672b6ae89316bc61447d08cbef0dcc0607eb953b9fd67842c67dc35b7453ef22432debfc9435ed743950c3efccb918c725e5fa9da5381a4db47919eb1fffd09f323af587f6cbe8a2a0cbc42f777e8ab4cb4eca65704d1b01d63ec564603239050aaf101675a2c9b5e08bf6e2d600fe09fa50f2a5bf1a251a1519354ab9574f95c02731a6be01a46ae4217f154bf20d6f547e585c717bdbac63ddfc66f6d0720c78bbc0841515d535633edbb8cdc1ef7f7e97cc3f2e51becb4315cacaf10465fb17822fe05f6bf2853277ceec7d8a3ccf8a51632ea667621d42e367e2fbdaf1b2e22d877a98bf23d42b1dd4461d1b203ad4a52496238ff2004724853429807b4b1e42fd419e0bf1be28d9e978cd5855a48c5ce44527eb34f8e7175e0b613cc3f4df2461b6a20a0f1d9804a7113504366c8f102cc287fcbcfbdf227b1e66067b823d844f91069155e04bd5a1e983be9d49034a8a4d8f189f4693d1e71489aaf9194f67b4948ece546dc89270516b8299c5b04768b59960d69cceee034e1960ad7d2b4178900dbfe0f937be7b6a3ba14892d52536534e625c70e0e7a07aec08a6c001174b4e1120d2b60b8b0ff03c2b162db57c538b79595c4aef7d00f81c92ac3e1cb6414e988eb444a55bab4ca4816da5578cc2eab4643fbbcaa2fa8e4e0ac4665e1713b8c4930bb636582ebee453cbd8f32fc6d2691a97e4fb53b94dda84580a049a1d20a10b92fb22d5199a91236ad25b049c98ea7ea733e8a47fda9dbb9b28b1d32c03cd02c8399bdc950e2a452d9c721f52e5b97af8becf79ceed019913b63cbb2c8179d61304b138e1053bf50d27b0f0d380ce853ca7f17008f862323f88048a31c8bd3cc681f3b2de8194e995ae28ae881c61f7dff63b7125f714567a1e172fbd6089706c446d8a0b17c2d9b11d14cbf4a0d0ac55b267941368406207a1620866ddaaaceb23ed369d99139c1574d42b8751e873c93f673b9679cb298b1dcabe51cef003e4fe53f3d56a5c82bea853d5d5ce2732469ebc5caf87c737900b005c3a11f47b50c59e6b7413fc8bee9baa4d4f8999aa6db0fe10a00008e592e4d8c03a69712d38b6b289b16f672e2bf943f700750b4a23171f907413d9a8e84626b20d9092ad11a9f16eb4ce3eb9f9acf23ccc5a246d2c193545e305e7b1a23e19e3bed49731caeeec7ce6b3b7e6a53a6969a81984c491f640c68b7bd1a74cd81efa5dbb13148d86cf4f8473394d8bcc81863d226862aeae0cc94a7d52aadb0a5550d67c40352d8272f06f58aa71f129ae6eeb37534481e3797e6524df4529c547e109432f039e3094f5f081deedc24bf261984c80a73d6c0b46617ad9256f5065b80189444d868eb0f5d2a5a4339d02162376105bca17051addda8780b675d24e197e45115de2d74ab86cbe830ac437b62bab8c80624a537fa8dcf5c08734044611309897606a3945c977cd26286a6b6d0e6ec3193a59766a717ae62836324b5fb258acf08f8fb137485dac6bb182ab869d2abaa59b9d7ba645548ca015e6bf9050301c4f5e73c92a2ad711e71dca0d5da53d863683e4a8979354c32ef4761f6c0f8a60c80d709338a75a702fe980c30a947e92044f5fd77b7c332d211813b444d8e880d3e5e34ebe40cc5ca307597bd8be555ab96cd90938dbf759657d1a66bca88f0f91d10ed4601c4c39ac45139cac84f41741baf6a21512fafe0b323e8102692dcb42e73e4f2812646f63c17e07a13b8e23d550c7ad661d933b084aaa2f1608685a54e813fa6a73dc3d2e6ca02887651a384dd12856cd0202ac73984e522519a04f8aa9ed83b756d8eca6d392d00a51966505a48d9b105b418789ab321b57049774b91f5c1c21cb42122b76026f6ace378e62739f9acbbc7005f78bcb6faab2aa81040d84a3f04640b0e224dc3dcedb16f0bd3b3ac6aa7946dc88e5f941c6ea153c1c1cb5e1ee9741bb492f3c87d8edd0cc3cb2d98dcedbd624ab1385882ecaff44332467d583cb2a132dc5141d01241be79b67f142e47cea2117026481fbd80bc4192e31f437e85c48415f71645e54b4e48c14f027b02220d7065a283826e88ea53abdf9ee304aae08cf63d33f2027a49f0a829956f019043daeafe09f06a4ab99ae85ce388244a064841be0d7a7bb8df6320a3cb92974ba2014cf1eb50362d7ff3cf1827875490cea0acab301401e878f0bbc98d2cd189aa211f23274d21b0cf251ef475d3c52a04262876e0bfb9c240be7158e21647f7b1055b868753f82b1238de92003dac1fd937efb353c03c225699edfabdc1bf48fb13db7beaf7ceb2df98b57b82d62b98dc38b1f21d622ec8b9de6d0a1b2eb1ea081aad4ef21c73fa19cd1dffad61cba2019fb2e7cdf58212d81018ae4dc192a7e58e14a2dbef556a19e278acccc1dd935016ad4db9816a06711657c757a9ecafe6fe6fc43a981bc1519eaa387793143657ad8ef287907b37e15ebbb8e9c1997e604ea16fb9bcbb4bbe3a145d3340db28da74eb8491a3514ff0f24e64b752c2b92508eef31ad253860b76db1540359eef60a0b98dcd422ccf7e1d3a3eee4328e9ef6bae3a40f1233c564806ec74c1229319e992024993bd62f2bca7e92d58a7a90fd9efbaf1d5df1a4c5063c9617060e5f349e400c0e7cf9746392e1f62bfe7a8af84f94ee5931794f6874c6fcc0447957f5d9a18d8b7b87892aac160764ca7ccbc13dba8ddf457b57bd1ceb844e7592ba3f389ceb8ad37c76336296c7706f30db424190d5e174ad4e0f56e28e56e6e2020feb43e40e70d4a6a44ea46e762a77b3eed275e0ba5b821a9873de39619a9d033d2d7f13fd697d406932a4ffae3a8cdd818e7c5b902ea743612b4c536211722ce8d9b5cfdc95c1fe5c60e59c28d752da09a741cb74780c58a918193b8e0fba3649e5c92e3824d0a0231f04304613dc74cde213309250523698eee102267713d4b48429c85ff52983599e93a01fada838b48792fcb5fb19cc12ea9425f7789d399720d72e0fad881e85ac554a418126d84684e30869bd0c2e076a5de2c4497ad02d11f19d766d4cb8725cb24454928949da2fe675501a9ee6da14d72e1c26177cd5760c09509a11efcae8b2d01de655aa605c1f8e488074e03a4a0f94619dc4b254315a47ff63b59d1a14284635bee5416fc3ba67ff912b9a73e81353eefb37f7954db8e85e6504e3a4dc8560c493ad45b0ee480715600b64480e8c1c763e7666fb8c7858268587915b155a68ec010ea6f37b4cb160618f29a8302a136dfd121e899f5bc334db87b856d97ca8609fbbbfddd9539f3a6dd7ce6b1912f0aee89ebf439ebc85079d3386cbb68047884b83bc6f9a1014ea7ac9e40af166d52574955b4a0f5aa94b2769ff4815aa011cd6ebf6f46004dba1507436e3a99a31c1be77bd2db11ffcf1e6ee438415939ccc1a6ecabfedee02e8bb952aa755c62a64ec61b67636ab702b4eac3554bdba4f9917ed73012f67cc854bb722a60528a8fe1737ce18f9e90104789d0b23b35aa13999f8a458f05bc16043e32ad693b9271c635359ad1a1c24e58c005f5d1146c9bcc3a3eeee64475e0a619200a1b5cb21d0bfe128ed595c5f4e00cd72bd69e4c8bc826ff9bb835156a2999cc4bfd0d9df28663cc15677fcab99e21879adc9291854dd33b39860dd1fde389f4aee4e989d360f0e38d55313aa3d2c84adc28fb58d7fb6b8cb6fb032fb786890dae2c4c20689ac2ecfc88b29472d8d52f13c431a31bf8dae25152fbe7209cdb943b4c7f0f08372e878c7a74350b34af7026a8c8ac4f2c460bc0df47941c4d714739b35063edd9bf09769f3bf1eb5774b103bd29720e3e4db140014af7339539d80e4815ccc3f23c5c3b83f4d19058469bb96f1b23991668b40c422266e222d8c3660076e2f89645eda02c041abe4b59df2e5a9b5990b7506f6eb1b9b2b85b3ebe747aff134ca6863247f2c0a32f7824644df5cca04905ecf4b01b91ce1e96aee52d96b78d2c31ac3528ac52e62767f0c8d4a9b2a5af666a8b7bb4e13caec9bc1c39c0da302d5f3207012320e683104b0f3f276236b818884a2ed8c2b0c2dd6701e39e1b737e65d8daf0c380cbf2db8f07a8bb07cf4e17df538d3f39ae33064286378efb3d765e80f67a698e1491cde067660931f700d048cf781dd545ca5d2672b9855ac1b351bf1720b2d756e075d7f45a627af10b8d0163c9270a8995ae055fe9e0008723a517a88b92f015f7bee31494a81326addbf7686ca4d0d14c89aafbc60103eaa0f8d1c4d837da9a0dc4fcdecaac2fe89394e584db941e231ac0e3891429d462f8786e1c04edb9b31b28c53b9b34e45cdaf85de30afe6e97952575d3299238f93e830d345f50900561364dbf368413313c01babccabc6e2d51a5ad93258bd5d18351acd1515ebf3c1dfa2c13bfe791c5f2ffd6c88d264b444c5a543642016b54778719ba7abe5fba8de04eaa31b9234aeff63345bad70cc35f244d849047e969d3ae4a0e5dae494bfb3a2ca0e470a44abd907f11abf8ee6cc552bb988e0693f8cb35b80b07aaa0129b290a7ac83fccb32ae4bd81011b249c0e2d5c0c74a5b57f79673c226b0f646dadf6c8b6aa0a45e6d0c9475a436ea77ca19bc5541b37c6d117883a57a4775420a659600f3f84b7d651651f5422ca9a0e69afdd738353755f72700e1322d7fcfdc727a46df63d1313001111c982f10d7e2f84f08af01dbaff8922532335f4e20bc9a98993fb2239dd5f2aaef7a0f4931331d07e705fdd215da83cc551d47768a67337d122e3d38ac73e6caad00c65ec3d3a00cd2cb6caf646673004e7d352a4451d954caef0c25338d9087c741aebb1c6e92dae43c08df2fa89b7e12a942473049f56dba89e75d205157f3bb00fe8b56fae9e7ca87bf616b5b83d33416a55bcfe9ece99762a9acd88266ea135786ebe7b5ed24d2c54f644d4f439acf07e1e40b81d58041996113ad05661a009e170f75425f64d89bbd9bc1f1d9aa52c7246ec9dede2c6703454d1aaef3a407e28a14cf4e37926f496c5e65e6dd2cbecb9c6cc87b61c26666480487c8bf322f61d8f3986739b7f9ccba03c097d9e183a1d742b8efec122e8f80ad1bf9dfd5977b17ec89c7e72871bc04995dd47064383f89d49501a283a8b6d1313bd98d95b19f583139d40040909c4e79c14566e6d2b19bc56b8c10097b9c98cdc4469246d9fcd51f6684114f50219d38c197f1a0b42a8472a09b605a85bc5c1521ae28d2b933471af0bf3e36d072942597fae8b4ec8ac67a711fd499f14d62e45d54d2c9b1a6a2029ec5b67072e72a7b870fea04db84d1a9550439c337343d76ade89ccbea13308bd11ebd7efaeda8b5f9b57c24894150b09445b7d1d79129e2bbf3d6429ed6c312eb41a45bab7aa9921ca9433e7470792a2949478ee622e53d6b384afc891218452c5156775bfb15b49d6181c0ba2c8dea2185ce8e865b7913b23a9f138accde38eb4a890ee08e44789cdee7e81c837dc8b44f809048cfffb83349aa53530f58fcdd63330942a468b496f8fd72aa05c96d58fef05ee82c686e10d831d000445f4ba04a0edece7980668a350b195d65fbbe4087eff78ed501d27ad423b56669f6194fb6d3e1560732642e61e0fd1a972f8d64980e07ecd47bf9e8966fb7287b6c85bdf312feda8c7c8077c545a644b95bc7c741893cc76c41a8c9d61bba38a409d57e1ebc33d9f66f7eb70c6e1e59bee067b9e2bef21e75d63b29c3f69c68df4cc0a0eb3b667bc2529eed3504499fa0a1569a3e1b86d6cdd93bdd9a214727ec41faa9839067762fffcb24d7618565d3912ebf130909a54b24099665b8a1a2751397e7feb4474f67f74abee27932140f4bbaf999bcb98446e98728748fa4900518b5ade77e42d6b309b807b5a7198c69f1227003ff1d1a5dd35fd62350fa179858f9a8b1d30c9bdc1256af5980a5077849cfdd394f3aa78045003d88ca92938fd2fdf0eba0af420e3708aa79b43cd850d03796f125606a68b06911cb0d975448d63f73ff0250e95ef855b26bb1751d8b1daf21398fa4f010a6fc2c6c26edc3450761a792bf75301ce3a670de0751bdcc47abc332a6f9d83aba1e09c51f5b3ff9922bec08ac97cd84f00d7ef3ad7423a093309e2aab2f7b94b418e7be2b6ac14188d9a32433eb9ada29f13b3398ff7b4e3da8b3534061b1f35a0402795935359a6a39cec69cb508f5422c56b1645e3156c2ff95ce6d31e05e473a489375e5d5f3edff17f9d4fcf8cc7d9b43840e3f54dd9da18bf43cd547031506e630ab0ee5405096a2a5552ab7ea149372750f56b14965ab92b063b4f74639ba19bb73b491d428cbc54d86da629d9580a6d891f822483c4922bab1dda589a44aad4d57dfd404f7543bf9e6aaf92ddd2d5112669fd230ab3b7c108607e50a90e7b0aaf7aac41321bd7f78d5e9ac84535bade48f3d4d2f82b54f7a41c5e7310d6174ea015ea276190130c5090d6a66d80022afd8263a037540c5d5aca04051b8b4a7e1a7c5b3f565c8fe72e8ee0b048bd91356636e8449594df30ef2950c557684182924e1c8aae0fa126bbaccd428b3aae645f1ff83cd7ee0aecacc5278055bc909deb1b9a0690fa760b5a86c8a1e636954cd314af0db41817e2b14658078092f49b933d50081073acebdf4cf383f26abf41e85361d77caa49083974caa4b96a78ce42124e1250915bc6f335bb7a5de63d9e5134a1407af75942f596587bf2b1cbebcb8a678be392864565d8d9536a75f33174ffdbe9f1978980cd666f93a06a625702532560fd13473b174cad2783a5ca21c4c33e4c06980912173997f72d2989c9d9277f7a097efcbf36939610a97dbbbf57c05e0c91da8e6786a57224ae23067c3ad0ae8acfeed5acce79f5727ee12236d26b99d180b2e2795c1a1b5fd7c261d70838b08f47d116ca855d3423452c0e09b1010f5b7785f9acbd2f6516cb518accde6a205d2159871aeaff0d4e873c9ce2d4b134dbf538ebff965b18427a2e1a9cd9054d6b671ac278e0cd432eff0de455267d5a45fcec13d0b0b1e19526a16dde7a154458c0526fcd5e764eee0669a93e1ac3335cb17be9eda50be039802aca692fe9464b16e20190eea15bcabbc2ba9bf8c527af2043bde260594bb3ec15b9c5f35958daba80a184cfe7e8210e5a48171a1ce6c1e1953e7cdbd93730409a260beb7a9e8708b86b54c5b79a70704e757f6fda49a3146a18eb3ce9ca9f7d8e0eac22901867a60df1f0724e8993e059aafc3f43ab62ea8883a5606e2daccb0d2b14a2c3991dd314ef5e4ccc0c8a93909bfd76aaed51acd6fd1ff733874068d803f2733a4cafda45a25830d80cbe77333bb528ff1d5c70eaba5d7881c109a9574f123f535df1fe5a4610e584662e468cf5116b57e1263e5437a03e5b46b72f1a794ba2ad96aac5665587322be5c4d8a9aad0fb95bdaa44b6bd83694ab19bf7b0b38400005b35e6aafb6886082277f8f6ac740889a9c18a9f3fd0ba69a9d31e34423e7f3d61cb3f454e923dc83b755256fe400569849e3acbee236a63b384217fabd90d5631337ae193da22931ef1622fe0e4124a22119e0f56b7339de6db4c9d7b9339fbd5371b61716873a2d34ccd84868f25a35d08f14c7d61586bbb31287cb82c8ac5eeb9348ab4465b066390cb06b1f70f833d7beaf1ea8ce6406e7b5e38f29b9834b85e12eddedec4a524772e393160a6ede4e60aa407dea903931c9adcff69bdd8e965f47da1eb423e0bf5c1ccef6eb429f8956c66382154d1c576cf863d0b755237680103ce06f774b6c2ef584d7a9a6dc18fd0672ee2a9dc97623861ce35be1293dd25ba93479b720b33763b55ec7b42dee9f874e27cb0315ad6ee14630cfe9d1f2bb9a1d4c0a0c2ab094294fba8f125947ec32b1a92990af5c9adbe4daa407c4af18d27335d50f50fa36979914b2106f5a854735cfb20d96638034e613e113db9dd3ce370bb1297dadd74eb92416329578ba09f1267918b3bcde29df8919c8cb3e3be8c57191b868462ef41ddd1c9ed14d25db2bcbce650405be419a94b90a4f0a64f49ea6fbf5842154fd7f02a8dfbfc96fc77bf9ebbf73d38b34f710002d44c6b568992c1f06f9a46ecbe91f792771a9addf8f9837f2372bfbaba7a8af223058597daea0bc6e9454f9c70bd181e66b9fd581dfc4636164c46a64fa8aa1c7e8f6860481172e756033fdf93cc2de7442c252ddad0a39d672504c27f9ca5b7098803c6c086b748ac8d928d0aef9427237a8a7b247f03e8d9761cf4c80c6acfd52dfdcd758aff96e2f3965a3bd0d0de6c6d5e4e382231370acef401d8c211f2ab9635d2dc6fc8b4dafecf2e51b0d13d21769146e8b9f036368a0fe286813aa0b6ae887496ada35edc2639cb572fad449289e5bd26e72e5d5173b765f34546aafe89f73700da13a09d52dcc6ff184bc7937ef1f30bd2fd9e780e399a71f6a6c97824a17dd19bd69ea896dcdcbbfb9bdfe2177440ca73d281c8f48b4328f587ddd4ce34ef1de26c9dd2c4c25afbcf351bbb296d7863ce82a5488d79eecc3778f932e141b605939327d37c82b539365872b1c27e40b5a1dfabe57a19b7ef0a55b1b708757b2d71e82e1ff09365724fd97f4e99314514a8ffb83e09ca05e718289f1325beee3733aa47f670111dccbf57ac149d5f549b381453e96fab9d4a8cc5fbc3a4d74fe43fdfbab986ea724faa7f3762aae31fe0a04b62c0c61b9249d26f6bca75f88d22b5bd1e5620c04693015fc87c7b4ed83d0f4cf1cf0c25aee003d443bf94e42d3b49ce7d4529fbe6aaf18085e09b2c355a65ae4173606467b6e5513908ba1bacaf46c75d53b28b28759a8ccf8a34850bd5ef843fbb5d80bcab3725c60c3627c29857e9dc55082165fe8e7e3c5ca8a176f168f138c7a84dcf6682acba3f37b90e5d51454ad047d97ba16e25c9dbcbcdd2601555beba965d763783623428cd3a66b4f223242f0941d09a43d82a950126eb07f706706de317c26ec95a39d42ca172cf9496bc940ff00835805e8973f84e7544b715c8c69464f125e0161d4daa21db9130f4ee9b8e71e2127848e33dfaeb1b65bc201330aa7d1fcdf0f5fa7f3a22f5e536b1fdbd9e9a696f65de76618c60b6c00fc31f1e777a41de1d76734acbe509376e3c64b74ef8447952582212d1028af7c877b29f02f7c469624cd56ef13e32338e3d289f633f472f658a9d0473b1aa3ddc122c72abd2c40fbd003eca6645ddbacca7d1925bc9a5116be791e8a3381efd9dbb856df77a8b4c0a61e30b170deb99aef1e0b95903da8b2e33757a81f023138bf85cab5aa6fa2ee686bc762fce616e94dd90be835834837cdff0d34ca912405776fd108982ce72a0e010b6aa77baddb9879d4bb99a5a99143bddbe3e169188053fd6b9c52b3e280a804a61d33ca2019b641dc01623fea3a5908c9895268ef9f9cdca5692c1fed4481832285720d76587baa131cc5f3b6c610944962af7a461695d3a2ab5019c7555373705ec15ee3fb4dbe3adbfdafe2f6c8ec429241dc65f1426f444d47ac3b149e337933ee2eed8bd5d6e88f90ed268d4f524b8cfe56c42fa6a5096bcd1cb9867b0fe7c370e129227c696d4135cff6ee359476fe3c35e0fe29e341488078751dd342d0594913a5d9897708f3cac8432aa20c4ef865ccbc01fc8e4df11e4614790889533296c5c1ce3b0eb4aa673f5411d4254ff704e3781ecf8df73997060a23ae84a8ebef7664b2be65697caff86f138d8d7ebaaf312236d145944ceff41d13c8a0c20ee06bb788a6187e5b56047e6c9b86f07a0fcc79051d982b16bf237805516a0a482a5b061085637f9c3d6d15faa5b697a035fecdbe7744fcccb2a26698edcc782859a6bffd41fe6703cebafb4a44515816ac1db77afaaadf450b103a941325af234ce062d8c7fb1f09efcd9df620249213131a028280ab9a09537607912b333b65548f1100947abdc68bdd782a427131a01db74f11243aaa56221d17622c6f78bc3ac6be6a9c8470101e59554936b81074ac246a1dfb01336cded1190222d5bf68f2f6a6c9908c6d65200ac7e49a94de0d30cc4fece371a5c571dc62a1be2ea07b2b414464a671c996aa09f20c3b015264a872feaf194eb6bfa999e63d6c421910dc08b2cf7704580fbac34f1db40f84255fecfed6b34ddc4b9940aeb2d83998d77bf1070931ceba42b9f372458f7d74194bba55b1f3c0333a4650b633d9add423f3661f00e29ed8c0539729b8fbf55a6b18b8fda48027be3f57f0baad1f1ab5d7f539790d6bb847580fbdc9203a7d984bac0385c974b5cff9765312b849a2be2cbecfea31e01d73447ac70fa5ac84047743c10a779443ef12f7088c1b4441ebccfac4d3b0144751ffc9b806cdd7a4b1667097c0f457e43b745dcd24f0eba153378c315a231415846f80fce80027007009e2a5cb27ab6418519cf1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
