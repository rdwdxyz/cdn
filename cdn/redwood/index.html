<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11b45736ee7a19b44214d787f642262302555e060a3a8beedaef47b9163f8f047da6a693a16a7874cacba5550be7110bfc67729061e5d25a9820f7af5a8027a3155d68cb53efb0eb588f227b040c6f31559458e9ca43145f902ef1149a078e954b90f57d096c9904bba9f81848c2256c930392c9a143aba3ac997a4524181da85a0ebbd45f3861a5a5153bf06870eccf40b17adc54742f49604ab072ae98b26c10f20c26c45f90b17bbbb5c9b7b340984df91235429409da6676cf24801e1f3ff9507bb48189ea1fa63675566c3f8ad6ab562ae0b0718df98dec36b795aeb8748a137e9c83c675a6adc8b1b2507a6e4ec4d0db305c44e99884e7085b44164d947d099a74e4710f282ff9e29dc4d3c523ea5cf5e4c688dc84213d3b036a57f3972adc9e546a38447676176eb3f1305149c8d3a2c5bf6b3d7b29fe11e95bdb579248c1b17503e9729fbfbd0c035aa34ac0b360b283d9fe64ae276029c9a028d6d27fced8533250de99b69aabe139918bc11c5576c52f333b3598f3f16541243e44cd6ef858bd2763f857628aee0851349562e8e621e1cd8c7f91c4b5b155b5fa48c1489752b78f902ee5b938d1b2bdd68b7c2c0e072e55822c52cb3ca249139613661eef5c696b0aee2f1f4fd48741e4aad19d9620e6aabff7fd8aaebcbe433f95329f99a4565cb644f10d36aaae8a32b779b716307cb03c26ae3492ea775e1f18db7b93b0792bc52b7c201d52b5d5ff454db64287c1927c34a4c2e77efb07b53425686aa82ae248d69499bcd4b4fbee79c302947a5974fe77a7f75c7ca53ef99bc9b2b46c4c8c86eefcf567343404b0c95e03a9c9ac0a55ebfd70e8f06d0cebc2d9e35387626829bf41e5627a11c4a09b76dbc07381a2c6382a14e1b0a08c15c7059d75c0f3702ae1ce005399af24a975e2ed727ce8d2bc5831af7d901a6376ac6d89d51d95cae5240915cf71eb38d9c6f2f6d9420c8ec81b66e93dcfa47c1c9dc5b53205d566d4b6420d2393c91ddda00c8a0376c13f4ef8d8aa1c28a9f073c3d392b25429990ba0478fe92905e4db71762549e66877345aafd6e1abf044d66fb17015dbeeef932d6fdaa0534e2280886145c7215d0ea31975aa5fef5a653d68cf19615771c0c5b632b15dc8ae6370ad7fb46e135daa73106b92a508e8a6a533bc03d933921218d07d3b0e2b82dd4ed5916a335bf5b75a1d537508ee7779d9b1bbece59a3fab093b0cb1ac387a19174fc5970bd4e77e1467abd01e8e93982cfa12b6571a32c39349c470c4f14b14b1dfac86b89e77831829aa4380553cc7acf489237fe292b327dd7fd8ea7ffc60349d3bb2339f86cbad05381ae133e4b935e9d15ca8fb91354a06d235757e14489a7b288e1f1d9001daf4b5b7a0e15fb0f07ea09de290af8525e2f4410b88897733c1389a0eb87ca32270d7ca10a75c297d3a338bcdf780c0d4736c137b112f8d60f12adb6a64f4ac99bb11bf747f8a2b104e7d24c18a551c4a49ecc4cac9e63f8fb9ea2abaf798d9baf7ee53f02193e3b8f4636667c8871d70b7f99ee77d0b9ec63b2cfc81b25192f3b07b9c671e483183ef7e3e4b7a9b14c31e23ae0c1061ba531c9f2339f7ed91dfeee872c9992d053ec7f940e7dd252b50fa22f9896fc20a8a8cd88c2417e2ea474473be2da14dcfe810c75d40bd960310f54bb0ed42d8b047792d69e9b74aaff601fd7085fce1d02c5c2c11149dcadd585e7d8d113ffc4604e0c7545482760c5b7cf9715c06ab0c1e17bb48e6bbd1521d54423f9c8a71086797f9214dcae859406063e24bffc41ac6e57f5581fb171d0ab457944e3259c75b2cda2171d6af05e959d010fb816d7b941154512d7dd0022daf56f6eebde5884aa24d0bff4d67176791df25469da21219e3aa01b43f96869f6084cc5c05392c88dacb424b209d12bf552b5a546d79ea36ac14812eee161b1cd678bb0e3b2f74ec7b282c9b3e47a00a7e4222d7d778ebdcebf556fd9d552233418b23d5612dc14683eb5c6a55dac7d933a7068634f09bf0780f475e6d52b21c0cb46341eaff5884b0acf3abe297ffe0db77fe97d5511a54d489540d13f9c5b3c923761b0db1bc84c203d39f56b0b9adba656f79ec8b2f48655ec7f7634b031628695dd03853094febd7a867f51d78e925b0c445f1b832e0dde5693cce894fdd031638b9989b5a1a026f0860fd131f25853d435afe5c7e5b972e0582c155c94c98e4087981110e2925aa9256a1c07608724c994bb49c3a62fb7e9c6bff42fc130cfba284fb33d854c8526298563dd2196cf6af5951873cb0ef2fdab2c530ccd9f711a43f325d4d4cb906b567609969382c55ff77500374aa33b191956ea91ac272d1b8d54d2547c7d12a517b325e9daa848871be9950d61187d60fdf1adef4265576677e1ac73c5bc95f74383cb96a5f98fbf61b474c6794d567a56c04056d20f4387e6f9a2be72cfb11776b8e1c1a4d5edf57c75b42180fd27befbaf0664add17161dfb5707d7b4ed1824d5d384d31bcf13b7784860a8cdf66a499348437a999d929598365a85c808939adb67fb1d54f38da62dd51fabc3c9c9731224644b0d0157f22c1baef80090576ae368c559dfec222939fb2afe648758159cde39955cf06fe7c19447bb7869eb77620e1d926b57808a5e4a1cc5678f02d6d44c975909466bc809b282d57a317bec4390dc0878c0d43342e5873a55c012187bf8f18b4d993484327efd982c657413877271ad1a5e6b0eacc41e4c79ae96995c85603669effca609dcb7ac7a522f301b6b744508c7158280d843a0d798a10595f6a4b2e457ef4b53df285057330797fbd22df249157de775cbdb255b80fd675435ad2bc6bc2d0b5bd924ce009551362f0bea885221b88c65d1b47ee612e1ffe592abaf8114b73983dfc6ba85733a7e92b73f0bbd62530bae1b8e0be681c452d77428039d718ec21c917fb2a4cef765c152e3b4734b744c074d61da4f5f1b646420baccf3feae79a593a3763d854b287ed8047c4ddc03ad6ef15520513d8379de20a29fee37720e8b154174d9def7f683a0787f963be55bcfd256ab0bd714d23126553053a730bb5361e636c30289274ffb61e52bb2a1e63d10fccbad18efc38860e69c95367f1a04a2854d40e1a1ef7d3912d9633ee03285172b952e64d91456242d2f1290117c95cbe47439102af818d0593dd1e219ba3766ed04f22de17f6957ffabf91fa3ddf5b51948744dca6e8632ad1655fb3de93d79552628a3fc5815f10a3d22b1fb77aa455ea0f290308b83bd1e7e2a5081762afe9218c0e8b1cf5b78f912fc39a3238d7ae6e3e8f5b8a0f2e01e1e3e40da0756b8dbc3304ab899748a2c4206bc4561e870e28867705c487da81c848a728c03077bbc9e026e10a10f6a23273c7443d42513504cadd7512450db3af619c92c973e7333d39b32731739fd364428f3606241ebf074af446665d083b7a066d4faf1cd65af5bc1211d9bec6408e2acfacf124c2f5224aebac6b52d48fa331ea83613d782407893ea202e10cb90b4ebab60d1ab8e27b92e1e34ebc945942779132e2a154099b4e33404fcf53526d396c9d9583f0ae11531558f41fd115124f3027c1dfa16250f771bfda98a5f0d26e17d114abd9dc7fc72a65310e2d6a9e86110ea5e3097f5ee5625968ffbeeb45876eb8430be53b8a796184de8e72498534bc275dd1448d3aeb15fd1cda63b01750c0a181039206541d05ea6ac54b8b51beb92c2d50ab5abd1b1fdd9cc4f5752b73db05b9465d8e3a5e7b53a696b086e36ae0272d40425966fb7e1eeebd1a981cffd15622b8f313c06faf692242d9f5a67cbabc7c27ae77739f4536a5462968bb2fe64c88f032455a1fb6e62e812790ac7e0ba648cf3a869021de4ce0d15e799276bf3804a907a060604870421d7978c7e8efaa66bd60c8812d3d25061089076736c0109e6574b995f0e08fda8e3d62dac9f7faeffede107be82b11400923abb1cb69c082252ebbd1d93d8798adf02475c8140ab53a558222023b0ccde2d1c07a3f828cc927c35fe799524dca078c799a42a0f859864370ec635cf102788e46306353f9ae75120507c069b4dfd515900aac23216387874b135ad4659afc1ff9b0c8122065b90096ae7a15bd068cf62ba80a1ec568fa5488670b4dd5a887da1230602730860791cfe9730678b181a1927ee324803938342dd9efaefa2fad9314a418253f3f7ccb85988f53c1816a1c1e3adc98b78dbc99459625e3554bb78260a3d3457f1a5165ce53900af3260521d1040d95161da8d3accce1d8df52447bfa090989959db54ab193dba248f4ca762697562e66c48710a7b4a8299025fd8fdbfe600dfca299330e96919664b88ade18b2c961b39288c6cef90da6535ca347a889d7f07e721f0f8c4e3e063c0cb8cce59b02c41b9d61072a04920f61ac3ff681d66c64032e68d2ab479eabe246ef119831a517a02ec871e87398b1971966c8ad6725e59b063391b2d9e6d839a1f079a8f241f089bc584a04e0895e778876788ad6e2b44f92ddf882e6f20de93116537d91f2e3939037be21ee8765f150f3d74812303ff6ee9775d4e47029e6e39c3a91244fd558ee3ebe2be7b3c4670cf5807f87b4f4d25c6138c3b601f76a7be74b1d9b1baa07fe0c7ae4f702f763a06a55319a88a25c36deb309490b17e2ad1d783189a6cdb4a0f3d9a73c80589a9335c9de5409c3c5f507b0ac2fc49512dfee17f64211eb9c3a271f19ebf618718413dd1790b66a226fe1da6ddf8e08f70cbaf7b615e8a03cfe3a41df4ff9ffcf4f5a838a4d5affb0bd08bcd2340e6264f2d3809e2b48c0afd63453c62cd40f8231ec21369f8418aa53530c2ac3c3a329f92bd3d737519fda163684fd4be8d988d554817267e5d50a4047241b2d186fc596529f347e7b0d2e3daead6df82d26bdf7c084508390c3f695406a1ed3712305861d0412c521f420ed0cfa7491d5fed7675accb7fa3a92335c5f9b6556e460c57ee04812b9903ec63c086d1b84cdeb0d343b31d8c1bb4248729de120baf684d27eb98a9c1adee1e7eb45320a9370b6a4f48ac54e921cef4db974f70ec7481ec8bb18122d2cc1146e12623c5efc5baa9d6a5707dfb2e2a38c79e4f20266d8564f0b3ff5891cd16c51551c8e6b46e3dd3987aaf9ea687ffbb6670f1569b12feaf8ac13f5280ad37440ef8b4df3f53118e46253e6a9fb84b5bbeb05f781c5c23ac107197e3f95426219b2febbfac8a2815f089450dd6b09fe98d683a7d8f6a1d992b4e486fe9fe1c60562adda7d05e6c7d6b3f39ede97d3d789266ff4ee9799c3908d27cf6951c0592ca52413a186b37968bfce10fea0799f86d9267e84c6f36efa190929f95158b8db21b2a734b8001481f3a06c4bf47aa68fb1456262d50d3ca5dd1b60eb491139481e31ad14cd1f60024ef3dae8f346f87ce9e9a1d83998331ac2efa8da54b1b68fc6a616302719bba572f5c7e858014910bc94611c4ad7e1a1697401eb67e24868982e546897ca2ef18f9d453aa3a8e180c38922eb19b0802f6c87a0cfdd4a5fa6b445d5630188bae84ba6607a4daee41761393093b876d65efecba4b5a6bba74950cd741ab18a66f54597f7e3844d3d0e5da238bbce3bab021e64df1d7548fe8da805c715238bf0f168fe2927b3beaa012c3a9cf5daa29fb9b5865f159e3c2c392e81d38bd4c0859616a1f1b93174e0170c70a48b50de0c81bc9637b4b263fe525b40f9535feb544a4d04616b6e1eea518a541cdd9ef7adad01cb58681a9822f8e0e6df8bb20fb4476648f7a0322f33a1aae1df2c3d62b3117984c33d748849c491a539adb7c102f9b919b366c5b6edc6204edbf589ab3636ce967908e208b616cdf9a9296bcfeb05d01dd02a4559bdd187b3ca733a2d9c539e231f6e3353417caeb2708a3904c35038462b2ce584f34ac305f3100a8b75146ff340d229f19aa99d30ef476575af5a7f57bb91b42d9fabd0d44cec42ee293409abf3b4f117d9be1b7c1d213c17946cfbfe260f5611fbeea8db616cd77bf3e674607f402857f0583b6a881019fda131e9ca192abc8ca2e3a9a0ae4fec419a9373caee4066a2dc4cf5888ee0ae48ae4af25a864fa1ec827c3c6b7c9ee7095e4202b8ae64c8bbc2b16ffe5058ed9394818a23a24080d958f1d8cc09d8cabdda6c048f49a3b34d03944a814d1e3a6feaa04a69807c73e2a7f69b8a5fca1ee8d6a53157161bcddff690426da258848be7364e997c383e71edef206283f4c0bccf1a64cda3dae606020845261f5fb6c25baed7bf0758f3899f989f5cc11619e8c9a4094ce3625eddb8a917bedc8bea8ecd2592d2724803f5ee6ec60b716d15323677ffa4e86603503a9effdb41d49c88f058a7071746e3bfecdb2c341e160faf43db5821dbad7db1277bd9a0540cbb503a11fcae8d2c72033d258d4e5cd13a0b25562496a5fe07cbbdf2fb2a1eb800b2a1674dc759ed356764f2411880a761bb1a4837001590d511dc4c5193a29f16a724d77ab0b07adf5c59e8e633bd3bc4f60f0f7b77423d9519020f59b1c656ad80ae0ba958e84a766c3328ea3227a00aca86ed3e0f47a12e13e1e0e8f8cdbb59a2372ac65b8f96b1dfc938b6329c69b0312e2e0fcf1a6daeb666fd72c717abfce708e19aba87112710779b9458fedfffc81aa4bb76dec4339b14b4f165e8298d64d53aeab30c4cc3839bb5fd20ed02ef94b17d3e54e74250dbc347d8569a5b2229cc3747d83b11a188a6328f8a024f79a7c7213a58789915e6d69e89881d315cd16f8dd49cc4c4cfa5387ddfbf8c5e7ac7db349ffe1530f0b7ea8c0dd9cf70a09067aa70d79cf3a479679efd470935d1dd2abba784ac303dd9090183ea8075835e485e47c0c68c53470b86b445c119d9ac1c0bee06fbda80aa6eb2d055adf63f84a3b005c01ebbcb4d0ab0e153597f2c8d9f5d9a528a956c453b8490434980fd679c30c243b3f88631eb37f5f911a981f772737023756a096e1650f574aa64bdd01dc7b0f6c788beb70b696def86279792d596a82a5c0bf0fced505e3f1c05e62413ae4b2622640ebb47d2cb3b4230982100eed6b99c8c7dae90912b015bcfc893569d3314f59dd1c2fe70117cf04c788a08d5501e7118937a7e32c9ea6be44528959a0f9e2a7a8d6ed178fd03d12dfcd31a200f8c2544d874240f8366b8806dca5f03fbe710432c42b1bba5d02729d2b876658a60b124a49b4c8dd1b6aa86bcae12c1b5a6424cdfbf1857ec1d9aba1c0d3e24116b7cf6eb828339548534fffba4f0d9cdf61feb62fb92abd4fc4eb15867d57d562591bc925e7ca15430314d58d2c59c207dd0f7eb8560fe8bde8514136d42f219ec627d5ee5c544b66494a8874ed9578a29ebe4ba31e612a85228305446ca41e1ef61ca010655cbea0d7cc356fdd12a8e6a11502305e71d9b91614de5571be045b09482274a35fdbf45ce18bc71a876fa891d5c1c03ea4feb4db6f7325e2399f08524de1c5d492cce4b2280b511c7aa5ffa80a7902eadfa53ee13570aff683b412057cd4b4650a89b00cb8160d63ab54c06649b0abd0e40190bef8db42e4ed1a3f71507baef578d3bd07b95d9d2f31d9aa48e86693b8338176a24f1ad9ff86d49207382dfb0274e62560fb81246f46729cb6a7cd1a3dcf31a44128b5a995baba24e990e21a239988560272860203426e41007fc100dddb495c4a49c9fe39d48a28f18bad70bc899d91c92f2157b0ecc50974d08f2d96c2a1bc7c092369d290adeaaf52ab1262f3da91e3c200fc218a037746ccb158831c9bdf38036a522fb6da9f9b89edeb8058ce70bbfdb846bf626416056c53ba8431cefa5a6c8225161f5cf96c616d16b88d35ba52da7336036b4470c4db3be9074afd824b056f821123db6acc4d80175642a25bdddc5e3579221979677c6c1bfcb8b114af9b73ee11934ab3ad7eb882d7a995e88a6ce6e1d4bb9011cd1122ebfafe131825f480d1e0d4c3953dacdcb75e205a6f84c3f0381e93efd7305e8fc3a949b4cc81a54d2914565ffd67aa701f3ccdb34eb6108c070418a594052b62b9454fe2b27a74fa3280f4c7b84f0e7fde0721827a617a4fc4fbb7867e2f23bedebd097bbd88dd08f17e9f715937a8eeb3669a5609b8b4bda2db316c2d45363a31f82f5544c9124dd76fb63e23cb0f83a2288839eb3abdc941ead194d5c947446c1fdf6229ea4320b744cfaafed67447a2ef8e55effe4e83749b136fa51e75e9d1ae7105f50ce0b5c624b1b24a64f48531d865aef0265cbc991c889c26ffdeca75b8d479232acf0590b5dc9bb6e74238f6ccd030ddbba77f4e9212b25a884d10b42dda05dfec1a9f6e3c7ff1f7fe894dfbe34f4a7aee6814c47333388d9a1b021407398d9ab742b0e864e21683dddf17be87477f1e2ea130a6d38a9791a7d89bb8cb7323e9a566ae7732cb83a9af795492bfb4bc3c2af62d50d0d2bb860463d6d0fd1596d8024cf0b78cad2b09dbb201a2e0dba1a92baba355ce6cdf07cd9e74f7bb97ff69910a12381fc3e368b543e6cd19c37d1a16d108f13a3c4114d42291f5282f49c801d668426569811e9a25f8e242cbea755fa9a7a26faab77cff45dbc68c099e74589954f89a1e6f838fe78206b60452e07d07b73c556b7c0ab0140210025baffc53c6b3ccee83f24eb6dc448cc91b2ddc02bf2f8264b16169e5ff73e0de8d0b71fd66a36bb0cfe8904ba6bfad1ffa2310393214ccc0fecc31ad4ff64a2458de56d72e81f1505e3161a87b256195b2dd4df08f5e8861568461734dc1b1aeb4cd1ebd0542f5681a9a92acd837200fe70238598b79b8751d63975ad2d3c048703cb28c99964b7cb6964562c3781ec7963769a04c89c23f4d435547cc4729a111d5265283189fb4cbaba6367e73eaf2fab3046e6702603a986c0d95c0e9bcc14af97d4fbe089f2e1c2e9e22e5b99df3033257a575b6422a6641bcb190160aea2ad01018b319027e937c6a4311edcab9eb97b04290384bad1242e44017ea5ccdcb02d30a772eb1c9c048a53639a20055093f230e6178aa65aad7ad205ee9ab8f5d4d2f0d4256ee5059dd714b3e0001d7723ae01c783084bcd0874c2e6b45190d5a18696e678dda5d4ab133e198055bd1d2dd19fb46b20b31ded3c702178b6e3b99e005482258edbf804648eff7d7e2bf609ed1549189e91becedf3a48a4ae184996327c738abcd9623431e1350582d5f5cc4a9fbbe4f6080e72e86b3b53c5dfbe642be2eb8a3541283024e24f83ccab1bfd1f2268b523ce959bd1eafc16fe65a0c6a93854ee005e3244dbe102903f0fe2fa339951775cb46188bc60f439764a607d7efc9b4cafc2035ce1e381f75605f4f69e808e08a2498daeaf6d707b6b1757faa6191fd8b39498658d9469bfb8b513ad15966b7a1d98dff5a9c5d66e2949acbb371c1a0cf29ce81dcc0a2e8838c173061dfe672b4b29f9cf58ddfc585033b6ce96154772799e9b5c223949d8ad1aeb522705413856bd32678ff8d83725b165730e8446c4f20e4e344e46d89ea7a7bcc0ff7769d407ede601e1acd63e87dd6feb13298332cdfb983ef30a6bad47932d88b39b654c9407f74a9f1d7559b5e48218ff13c836594462cd5d071af09a3b74146f2a86cfc14c2d1db5b3c0386fe32bd6ea8d6cc6092264dab019d5642e18e396037375531be31b1360b677d0ec8f3896819b36af674b0c54a34419e4af91fc4eeafa5cc3625a39626ea915e06cc228e0b0454ea35017f06a7a5ab1bdcb3930dcd962752bf2d7ebd0e867f7f3ee9ac4c1ff813dbb5da8dc02f778ea9b58d3b618dc44c919738a91d0a2e991c1b59c2c9f5f3403bd4d62f79750d53759177d413af343d39afa7e793a5ed28169cb934dcd0b765aaaec55b343045c0ca7cb9192a8af13dd0c8b64ccdb0d09f7fd069a0a2b0e8bb70cdacd173ac0394af100c2ed79752cd06b81fbc2d79417236fdd6398718b3b5dff3472e3305815a4358f09e262ca161dc9750e04e820c8f778323bafe4bc17ad58d96708a7296462074ab74bb0e0b0491249de5640e54331581aecf62c05369f16adaea48e6f8c9ac626e5cbdbd939108f949af87b6ed1a6df4f769697ab7d055269b728c7302ec221a1194c6a1f1cf7e9f4acdb3485c464fd4e91859c1940182b2035c224ca66ac3d222868d16edf8509447becfeedbe9253816a95e9559a69242a64a677cb277b28e8470a055c192f9c13eb67be4403d6e3a0f50114fe3c645cb2b3cbb6f685a5f792f0268b36c6285d938cef0fd822437c21c7d7fd04ec44998f519a2211eff05b0c33d454261aa9a75eb8039597da55df9b91873303fa809b4b8dcc0c930b6085a20f5db4399d321112e450e67a9b63945cb7e64dc9765dadf6a25b46a39b4a0b78c7e5351a21865c63e687946e468a5b96bcb9e251dd2e770e0348d62013f7594572ad37f6c9d61af34eb070fc63aedf050bc934d1baf05aea0a7e579d73081b6d1bc9b0c123d9c279cf77e8539b7d03640464d424066dd0a7356236c13e5811ca34e6b10eb6e8fcbebd861735ca28d5f448614856a4afef56d07e7aef5ea8c0d61c0928711bcc30518b5d4b9ce8a6fe2db543317b918f20a4f07c44f763dbc35b578b182ecbb5bae8e93ed642104a6f67f7e27ce4ae3e71b4b17acf869f0ad0a653a349d72891d5404a26b483fe82aa37519b6f0acf7840ea8ae83ea168fae4947d9b2de86f224255b93c5335e09a3ce836c80065a864b628246b311a5730b00546fbd45a408f6a016a8e38feff61c8d66d7e3cda27c190145432d44f56095678bf91924981d95a82b68e999141ab7b918b3b058f199ef1fddf3f1437481d624c22c45fdebbd2e73b85b370dd30605cad9bffbeb7b72622f30a75642aacf64ee7de296facdb647421da12d822617c05bf3fbef67679941ed312bda39ac806b08cffcd350a07ae3c08d8b5fcd63121f006147d986cdfd5d2e6eeb74615b38750c36e285671bbf9d753aed5af58b01a65ffa637801a9f090dd32fffd361a8b291614287664061a449d5189f534e9ba06288b1046a1c20ad94ac6b97b630f19d2208d4421a65e5fb10107fe5e88b6bf14b5d9c1057b00d65b4c42e23aa7b98625e6e488fd5d7d2dd5e51e74526bb0ce0e93964fe638d71d4241d9a3c070c9ef12d2a840891b7555d7fed40b1cbd3f3c374f4cde5d945aadf54255a998f51cf1486083ef467faacb168f5ecf9b895096819f67e356c10665c7ddd8582571e404051b881724f64130fd5893f6135be59ec00eb3934609c23f8f2cc4543574afcfe67a2eb4de2d0c6de39120a5996e7ae34fddb2b5361cc19a748c38c2cfe4cc39608cb4ca21529635566f4a5af06bd46c473e5a1af0927f3977b61dc810a1a1bad002c7d193b1fce9ceb22a3f52a8f537bc8ee081654a9d4503f292849a17fd04ec708901d1404fb9ef657358a5b6d90649731d6235f20f6fd366add0260e0b33cb058ecfcd6e6d0e5f9a76e54905f34c6b6aa82a85dd297c291630efb34edc02409fa7987087fe743591cbeaf481fc451609679c2da584c8a6bc302cf4e6875328c8511c34e1a149f3c92baedd3a67a1e278945a15de12e2ef11636575b3bd8a5cf137a66543f2e4256b09c720b8c618ed7398ad9d8ef80d782b06d8b452ebf357cace46af30696f0156a7765d6844aafdcf0b790a247153f348057612cc8bd0d68bd2fc2606ddebd99b166918a39a079284fe48c78586d3b269611cc444f06de11ac831c46f11c4f8a4e6b5d845be993622c227344fd3c151280ee29302acc2823a433d0fd5789a86b044a3272ba963ae10c7e441679c31dfd6f48656ced9de6a8c90a9709c3e876c41044d5612703ad11f09e5c8ecf2a17a6dde36324b51291ddea2a1bbc9c530d4406f30091179e79647205f3b48a9f77c3aed2cd23910d84d2731763352ac949f9e2bd0e5fb22dc3e44a8b39f45e0b26a059e879f077fbbd35ffb812d5d7cc953e0ac57367619387b8b93620114e28eb3580a578e423897adec82b9a6c333b15b0688efb566160484608867e7fa581e82aa05c96996bf4e07f7a3b901a9c1d526ee126ee5b4a7538c33a2eb0401e7957629bf00d1f524a0033bb072a9f5aa6ea82738abdb294509b971a424afa94e63639148719ffc1f50b9f553ed38fda4c18fcff88e56cf6c5a4dc2915b620ca55a5cdd19cd2d4a563f10e31b96594efad56bed4d7b917b12787db3389251c30b138236712b4b0454b31f3e53f07455b0363975fad13c6fdac394a69f6714a13b2a2ae9e7f444c83570dde63969de2d563170665c49e9694b8378257735394201ce2f03e6e4be2fc50ac7b13b6a8515ae904b6a428509236af7c522c42b4214726f688fb12b84281d596029a89847e3046bffa2a3971f02d9e1579f0c44e5a952cbc4a04e3655046dbdbe573e12bec3946059985e3c7723348f3c7b3f50f5168d3412c497fec7b2498e06ba15fdd39043e9805b671b2f01552989e0f5d3523231b202a8e0446b6ee5a09861e1a44cdb66f8e321fd999da481508c32fdbefe3056180e92b50c1b537136ba91ed5ece256d3daa318c12be297d11256ff1ec46def4afa62eab09409765267a45ab2dbf8ca799ae3f1a94aff0534fbb6a9fb3ff6c53a6a609d586e3cf774b6cfd7b775eddd6d5e3338ac4ff9ce068ad408f648010b2ea7d56ec78fca09f014b87d59afac0c71743e0fb8864213f894b151f1180fd82f87cc9a5481d82a6cb24d1a4def783887db8e7041a7b736f4b867fdfc8fb544d54e977ad029d8c097e30206b4cab1956a557e4134d6a246c006e447ab0a6cc42138b28943c42bd8ea2eeb9caee87b56859adfed5d22361ee55f9792555a01a6684298120e6232bb25ef6adfb75d1e08c1224836fcdd8e8d94204d2fde18eab15fa23fc4ef61bf06f97b7125ace96f496f27109aa0217f7cd1d79c24a6d87e1530690ceac41d9e9bc97c7bab8b4e9a1341854385a77db656c3c50503c8036c075ede115b667e2d30e9e7d0cbb6e688b142b7c7ee8fb0686fb3de0dfbded3d3c591d8d9801033a5439bc4d93b00a0775e761e6122a210bfffbafd5e360db819fccaaf66e3ee309dc2375e5dd876098fca511083c40d18bc2d7651ca16ff056f18b8b08f8cc349c31a9291a753b378ff680c977ebca245fa655782f51dc501bea3bc27619e90e01c60c47a50cb6d78295b52fcd9be15a6a2cd6d97963a92d2d272b4455a2bdd24d14682b5864d09658de4efc7711339a96096e2e4d4d759d874a277252e10c7227967a60eacd32917cb29be073020f7d246e9dd8535f90d4f555b616a347af2f47dca69c19bf6759c97b20d8c7ab73f1003c66dcb99b5bf0946462e6658b50b4d1b41fcfc04b478f45b2620d0fd6161f4442ef4fced6bd679fba5cfc14afdf5367d3b6699e668249d76b7e836d8644baa082d4f9e88017a9a0fdc11d5776d17038064b78ffd07659a7cc31fae872a42bc662fc44683a8a1f99cf245a999426d737f1cd513398c958d47d226b32e1860ad640191c6c811676dc6ab79ae73b1f4ce227af88f8d171f473fe1520a49e7afe2078192a36657e95603ed0b6af9e4ba5651f152204e867fd48abc0a227387612702416c5458c97671adf7a0c75822613857ada49f75fc633d2f4e7a258845ca02bfc6ae82ba9b10b91b1e7b8c1a240e03b5f94099fb13dd2ebe4ae1de95a4e379949c7a76cc3f2af8cae297575979cf1b41b21d6dd0b778ae04c0a8db787447fc08028862548ff9624ac25845fdce3b857b842ba2586194899256ab7fe1875394e1a40c8f9de739034904c262dbdc8e64e92d631f196ef8be6220f20293840b6a0a1bb01ff7285f851cda446215d619626ed031a8c725fd0cfe2b947a87c66566934ff7219d7d2b85a3f454bbefb5038d6e651784c3e1363f58005f716c8572f93200cd85a06d8397659e6e5d49c377ba7628cba43a7882cbed661293f067d8e1bed1859151c197eccf5942ed39e965a8c19d6b50663de249527c68b8b415712bc23054945a46de3c3b51dbb66dc3ae6df8ae72073b57695f4d66295cd8be233bb9da94ad2927b304ddad6a2f7e41544a7f7d6ec212091f3a719304284cc1a792279c3631dffce7c66388466e8ee43b03a85662a04691784b516b4b4bf52b3747b46e69d60b719f14b4765b423e8da6b07314a5266134d6a65f7d15f92815703dc1bf0fa2eb6935239f84e98afcc7724bc4d170b5561de9541864eb6cdec34be4e3dc3dbbdfb914d39ecaf9746a41c686807835d46cd8ff31c8869c1c5e188f928bbeac570b9ee6c5e1f88989962b50092055a943f79966bc4a2f141321dfa3da0dd37d36213c1ccdbb289fb69be4532dba2ff78259455366c12f9581038f9aa5b9cc8712f530f9c78f74c8072d4f3b901461bc6cee61f4b6d7fedeee173fde0d9a5677c3b739d64de4f0f39897470af5ef3ba962d742ae5a45e26c9abc81b9d3d444100a255f9db82df50931b64d0e3f4062f2f66381924355b8ca46288d904b8c1988511e8a4824d2f6976e7146c57e051fac7495383248252c5c0f36b1af5f832fc41b92047b0d39b37d82c8e08e8b2901b9e768c2439fac25660ab559ed44178491f0d0a7188bcd12769fbd518fcff05b5545586927eff297b919789f89db4e473e28f322eb1cdbb1f69148033db8b8d75b674eb04dcb93ca5f8dc4585e0e1a572a2430125d396bdcb156b55dbf412da7a9c15609baa1b57549e4a925c272c0af5bab0146f742b313443fb3e858094ed2ecb7dfa83d62ef7510001692c9b5c32f8e023b42f45282dedb45649cb9d154a1c6601d2d0d39910915c718f39e0809324dddf33e250b8895d9ce5b7bc23012e4250500f227ed0a9136da2cf18b8f9cb4885f7d413f832de35313433782963d05f5f3625fa9e137a9d77397c64baa5f238fdcd31e7604d1b828a918ee894ba1eb4d3ee2e187437f4edb628ad836353ebf56913bd502c1a62abea4b32149429319d8759632a5ecd97ceed1f7efcb4fbd022df3f4590f41d4014b2a547a062777f31f9efada8c39e0f4804e79bfdf2852ddb7a8238fa7a39eeb2a59ae209f335","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
