<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb0c44f1e681fc2493c27d50a157dc7400873a00160c965a27d9e003ad90e69d646498a5926bcb0035489c629e8828ee796af8eba94606e85162a6fc7b6e2219b6e2d5b38a9d90aee24bff62b6f5ded42c14ef7c98a61c8f57267102701a68a7a8a02bdaae3bcb4f9ccc4428ce47ed8db5aae4372f48ba9744cf011b5fd8ee0baa811fd111cd96f67eb27a531b4f7f45d37e678fd47d402317f76c9e439781ef94f2db458ac33bb447739a0f84c134203f5441e5cb4fdb66edf5a8b6d4451632809dcafcc84b726c753c38c2b4240d187fbb486e2b1e6c41684fea77a1b68921f30718300fb493902cc449389e11d03bbbcca95b4bf95dca0b9f9e2cb8ffdf3b8d1128b2566b9ef62eac19653ef25996dd555c51b712ba2866dc4ab20bd5a99357b8b7f893c019151d0c5d4b3f007c4e2f379980a2e1b2280211aab61ccc36e318065d061ec37b1e3ecf206d16f4c0a8e67620d7cf45f5992bce9ce790900f3e2362e552346031ccf947caa091307e420979e290fafb82d2066b52c38555ab355588c8b3037b38c5b1edc72461eb129e90b79cca5cd8f6a2518370ca26665358f8ce7760753af839e2c2ae0c36cb53eaa09e3f7227809070854d1be9468e8b48130af7f40ce0d1d8ab45a8c371e5fd168fec106d8acaba817c030b61e751acd08240083d6f8f2d46e684609c43ee126e072181e9beff27de5bf51c409305488c4c738ae2ca2addc956f3f606fe5502e6cf4c204083f57725fc67ee704e6cdd32cbd18d313f7a6e9404e66dd784bf71875f5385de465f642a9cdd3c4e9923be9fd75a006f6050d4cfd9c9b0fb9106ec5081fa77b7f69bc95e2e99be514f30ce1054838a21c5b410792368bf69ffe7518b4eb0cb895b8898384eb6f451f96dd09af3411097a5aa467edffb3e6c49bbeb08ee9c82f449e136c47a884b8f06cfbe64eb67f34299ae99564f698e94a7e7ec89a6e608ff8a3970d6b0e1dbc4c9e0484c47a6d41dead86c3b79611f6ed693eed5ce9eab8be380668c5ec64ee79709915bc032cb8cf076112f9f18889f241ca79bcc3b6c626350f9a02af4ea3c95c69221401e84d0eaadf73e5ca5178827af46396886438b8b19d57b64aaa2a8cae04b7afdeb05e40b6bab878fa737901cd1327d637f92952c894381e13e33c1162e10e90179b2b8feafa5cf59a9cafd5d36234b42584d65ff9c72e2d5c097c324d9426bafdf4b97f1f5ba4ae779d188081c8ac44c50a40215b4ca5a940731ff776fa81eefbcecdbb7cfa33741a42a2b67353a2e64c8ab8de363c9ff9ca75c3f0553ecf98473a6ea21d10cfa948b7571b734c69985d84c2eae3425223b6a221643954db869854451c98bbacc26c32635c6e3c01e5fb136053d30ee1a0982f41118a386ac2ea0e60149f8904f95611e3318704373f4cca5c39eb9ace4c581b11dad21dbb5fe119e6ff29771107aa18902bb0436028ee23d19ed049df926be283631d66860f4d12f83626adff8bd2e5520e613fe0ac0a6685fa9cb29a5ec8a02abfe80d709fb87393212a0c970f5f391b8efa1aed5fe2aaf85f9bf57e96399bfe321cd79e9415d682cd8cc7d10e360542ac379510f727e3c3ea8d579f128bca39836aaf78fa3bd5faad293381e6f7fc3c329b762a3f4ab72a80b8306efa9d97a47f70430b4378c2dbf6f72107fe64d1d5d3997461323a62b18a7adbde5f398406b6223c1b399589407264775096a9434f01ee28097ff307cc8dbc3f6ade14b81d7bfe1e079c78b55e7efeecb7c245fd2c6ef51bbb6ab6416bdb5b03690f0c80f4697752ef71530e0d12083e70d5f9159b8373d507cd01c57e5d83b68a8e990b6a25248422c7ecc0d0da25f65997ffc372f20f9409f3459490bdd3566e45b86791cd8a2cb2e7b449b0400088f6eb40add3ef19a715fafc737e019dc5ad43e9e22b4a3f036d3a6fef8efb787e5c03b705e87b3859f3afaa87656220a2ccf9852ac40ddd638b5f2b17dbb6209de35b43c84aaab28d24c2dd2cfb2e2997731edd1847c85f652c5a12aeadd5e2dcad2eb248bf50650a493e0219044b1c44a4d1142af15c2091f79ce5b460fe31704cb52fe0ad5e41c03d9342a227a5baf908b17db188a16171720463dce51c79ea3e3c7a4aa1864b8538dd0cd8202f9eb9d850047a9476521f9ed1a7d3c94f0c22892a0ff4adff9479d958e330e8bc6e98e91dc1641d543a0bab97ea2d109315ad565ad0f59639e8da80cf299991ee5e3f2370cf9b4ee3ed4edd146fad57b7734c086954a06972de4cc43e79ca0f3ff2840b86437abbe8e6338d86d78c5a691f03a174647e2462770e6f211aa8f71c1f93f994682cf9476a571e0de2a78155dd1aad2ddf559ccaf1745f5fd9ad007b07b7c3ded8ad7f977d5a043ad68a0039804b0afbab56ba85418dc6c5bc381bd101262abda9fc21c97caa70d6584b195c2dbcf63fc75c5533db6c930cba64cdad4ffcc83791c862e98f64e2a54307229140461320da39de7d645d9c65ecc0340a9a14fa6e721238fe771f3040b1977732865b4a3a760444825c97d33802549c869aa3b10056da3db79a5f8a840cffc0138ea62bae8b59d3fc18cd9988766094bf9d42287084cb6d1392bd0158e859f21d4826f073d6ebdba2d133ccd9a9f0156bf334448b7076986502c98bdfbdf2cf7e0d565108e8d8960af16b4fd7c40e1bee79678099369c0f372f7d2ca5af1157641a3c6d65e80d781d79054e6b76fd1e99da7e1e85817034dd92baff34ef18ab49aea6420cb750d60bbdc7ae7811a3ff1393a1494d6fc43303960875ed81bd301eef2d1a066f2ef8ca97f95e1527cf04cdcf1dd85e5819ac1bc0bd1fda96d35eead4753330c57447dbc91c2ffed5e8b673d5d8aa9fc97a533582801d0535e733a11d4240b897a6f2111a205ade0e3c1d029a2bea1d9ca30245d57f473fa5fe0bd1b93ce52daad67a1ffe973ab619a78f59eabe862216a0ef45f17f33f39261e7187039b6501b6fd5ff6e7a93a83174f1ff6f587b0d49c98bca1ac3c4676115c457a51d7fd940d876f41e0a13e1e6c32096eabb86d515fed84a0fd6f97a3afa77fcd82329be0f5a07eec07431a9bb1cc22a43cc6ea17f98f58906f78f9686e906997acedc84fa464f785135f3bfe95ff50c8339f2c7365978d045bfebf609e43895ab500857836a7846858a18cd3203abcf425cf8b0d5b0946615eed82e918517c3c0a3845603c8842dc9527e7178a35955817432503c4b133bfe119e7b971bcbc6a337e3c4fee5b4c5e73b1aa1869de11abdae07dca810719235b4b7ae0a0357518ee246d742d269cbc9c29ca809b2b10098084ba6c057112693baf717bcae605501e9d7a679c52bd42c14dc5f68582e6a68c5adf32047c49b827a3d41328013000fca82a479b88ae6359ea9ea7127e8153ae956f5371ebd3ac807237477b68b3d745e2724d77ce2d228d13e67bd11f4a78b9ef62bbc1431aa3ee84ebafde24af60b1ff02f7fd04a40d52185f8566ce3c819fecb867a0366343c70af6f55cc39602aac07a78229dbbe5d31febc2133734f66d83ba67444ab8678256d6f86884c22fbd0cb1ffb657ca136714e83bcddd8707bce880b4a60f809b81553a0f29c5ab53894c3a2f26d275027b07d5c99694c7883b067b9d304d1a4609cf744766574b2858ff48b830b267b41e3b79bbe0de403980621985246ecedc63ccaa179b3b3d606ed8ff094244f65082a26bd87c54ba074977b3d4b3bb82cc18ea12d0b2365cce0bcc38f83c81b73e9472bcb8ddfea28c79953e126301b64f5555a101fde550d27b6efb57fad4b95d4e50c9f5b63ddc2dc61b3732a580583d0a664601868060cda3631e38b557a1188ad7ac5c55b22a92bfeaa180d088734145ad7744d79042a225d2ef231d96ecf6b4e4c2f3b6ac5b6feac853f3644e1552cb686caa3cd79363ceaa7f51ac42cb4d19ad2d7956bd8df9ebb9d7e82ee4947858e7f54b8f82931346fd08e7d384d4ba49bc4a9c00004fff6aa0636e8785fb1df675f8370e030db84aa67780016a97c3cd3d675de3b5664d0c12b5b825b90762ceb56fc8d6a138e8437197e88dfb2a51ad1c863ec15742797bdf8ed9a80852d4ba44ad857b80b814d1e3867b9660996394f3d5ae55e39d573be381d93750abeaaa94f96dfffffb9ef613cd2ecde664bbcc2c46df76458ee36c9402a3956ced2757fe2c07ff365ec3f9276d8fe231e32ad2ece08782cfe55692dd6a8b7548dec77856a090bba1aa5baf66dde096f7edc027267db8cc359bd07b7db39800f11f49a22cd49ac82c9c29bdb37a2399e0e60d403c8a110f074c527496bac7e2641e6aee1da0cfd837bb9cd2de96b355f0220ab0bf7ade496c4d2a8c71ffff7bb1a844a5b69e662112e43375a2dfb2eb765ee6f30a5bc457131d3b08ea478d445aabc1b6de0a92868406e7bf31b35a2ffaa7c650b690d33c1efae128d7d0c4f7ca55c85da3dfb77b78c6d1e2521bff8711dffa52e11d8252c7c1dd103cb7354715e212cf5f33f4f2e20312d9a14e86682e4e31c39c7c9521eb6fa284537cc4b0f246e38025c8481028578e477f96fa496630a79f3d6c1c74e390e410f4e7dcff20f876b28e1acc21ffd50f497cda63ebbcc8f1cf2db9032a76021deb9987716c0afcd482fc3a6aa7cbd23e49c8b844ae31280efe0f018d037f09b1f818ce498e58fba241dfbe188534638089e122722b7fa6758230983dd0996f94108936d3eeaff6fa321ac3b9efa8000831a648606c7205b52b2dc0d35e0f87f2f5a1ab03134fa7a651e8c4a7492dd52785858fa81f337d4e1430b028323615625039ac2da71b0a28966202d6b70c9330737aea12289f0d439b010c707368df302f6f7b2c6803cbf31ab20314b10dc90540c9df00f03b6bbd6fdd0bbb26e416ac6f80ab496feebece9cfaf441b73c8fda43e77f1d5983c43cc2226a2fe05d179a4a1ce3159c9e92562ceedc93bbed2129e19a53616dc1daa305216d7d15fb0b1cd0ad2e3018bf5cfd702703fee38271d394653e0a8a52c45975b718ba99d6d2fc3fea9b359ec9772f17d44d84f3812e64ce1f46862c84bef1361ee6fc05f96aabdc6ba9bc786d14627b33c6029bdd256091735e10b3d4c9919f747bf7a2879d4970942113b44f3cbf986ff4f647f4e32c4fdf2ce7a6a0e9c29a643725bd6e86653cfe67b737f26891f0106326d736b1e79d6f59a38747916519f80c4f536bc58ddf8bc6e684e86924fbebccad125fe38c1e26a69ce45cdf4c089712e6b5c8574a90aa96830d408e8fa6c545bce860b7666e07bb2e12b175576f2d01fe448a2079bf965d5ac004776eabfbaf7678721e834ded841a950aa0c895f13a3f7d770280281a2404a007502415231602125c3857dcda3bbf70b6ffd9dc898412fe3e8e081a304658e822dc012d070f46e898c969ae2886fdcd000918276ec767ce709a73f4337ae46e45bb716ebad3d9b5b1dc2a6e84773e03ee3cdbe9831461f544ae503771c37cb0ddf9b96b33e5e72605e9cffca2b46f0f3aaa8db667a651f0120ac962c5c7788b71c09c4feeac16f21bcf4bab76ee41f01910926f22b22140f33e77ef4b9173397fb5d2e34bf5b15539c7cbef6482697a3409876488300eba013188eaa2412907d19746cc22b2c1eec6210bf574e3f5f7e5850a5f8cb2cab64b4366b40cd920b5081cdc9f4c4dd61584305243427c06dc3550ae70007ca0dfa8cdec0599d927940da4091d2bc6f8621d9b71df6cf8dc73de66e1f1fc4195dbc06bf0dcb53de5512c1b3865aec27ca49c9a02740b3fbe95927cca2b0eb59e2a9a232e0b1318e70541767fc849270ff3c88824c85d5ccee8bc9870018265b0f66c13770922323d1f0665c819697e4c9414676a8d7106dff076853eac561a25a317a569c5c896c4911b448d00902ebcb1968937eccca329aec32da2d9bcc307619ea18089603fc4b9e209225acbbb1e5bc9706f8d517a3c0a52c1c96f651bd95609613d8a2e79458fa62ee220029e560e9cdbf90d295184b9ec0aff63b0dbf1ce56310099c2e6068b9f7ae507b1a64d8868f49c6b95eed5c274adc3038971fa458cc26bee4f6c1b698cb93b31916c34c452f3e6cc2a7f8d95e256d4ca05ef4cbcff9382dc0dbd8674821320e5505f36a24d8f52d6a5914a89e21d96782bc8b31611e302e0e7075083c50a5662c419795f425684007c3850a8e2342b87428f6ac06b492c3c09cc5efa31c415ba771eb619b12687508f31aeed2b63444e4fc1eb3625e23f6b45054e095fa0098707d7add6e89b541c0a932303a036434b8331de6ac068d370832583c01c195efdd7998cbf22f575c9ffc7207a152d70d27f58eddaf8ad7c711f5a276cc35036b8d28dd5a7806034f98ab3d70d938c9f4c13e9f7f6ce7f02043d2354f45bc34e8402885d80b39b59138adc67126ddb55147a7bd4d754bba0072978f4c89efa69567d8550b68f5d756dfebf45e9136826eb28f5ad4df9db5e130ac5511bfc14b18844cc6574a08230cda194a5b7ec5878d47612a8771b2a7a668a5cb352606f8bac4033da46b1d76ee3ba98443edf3bd1dcc8583e070dae238649eb22066521fc789d159869be01dbdae0b8079408e0dc8ae23fd77eeefc2841a033e8d5c8ffd4811f6620c98507a0d8bc77c65638e40f8ec98efca430f381adc436c8e31d3dda2596cd400bc29c209b8652c526853c95e7ffe40591a95e49888ae3d41666d33160b8f8e17826029e7ed02f0626ca566c92e3c1f612c0b6211f7e17609fdfdb7d93e98a899162513aaaa8613a8462625fdfb4c32d9664d0e89d7667ccae7e77682ac0d6bac9258c90dda97141076b25834720ecc1e1eb859e9ef690694145d3852d13e7cd4ede6066bf8e0984d6c01bd492ba9cfb1f99c15c9ff41aaae18555969d376da39c9d25526c5c4e618f167358eaded2d5c9c048375b99efa41a0b30da9a13e19912dc154c8fa3323e85f13535cd8770c770775f0b8b33c1f4cf2532007bb4b028aa476ec1e80890d3ee8aa614db6bfb0c3e8edd39fff52e5885723e8b02378e73ba70f60cd5ffebb1da1b64199448f298fc8e8cbe6b2e19e53a6f66433e3c588bf83adea73c34b32d3b60fde9dd296cb707aadcef706925beb6aff74a5e1b39df653e2d06e2d099d53e74e2007e762da87931a1b5d2a3eebac9dbaa12e999dbc2ec0966a3f05811f0e9600dd270fd910a673c60a5506cfc0dee168b5e1f29d2118732e04df8ad3f6036f397edc323066ace2ea956fff522cb2c40e225886d0ce620163952c89d77d1744026cea8d9ae83afd52821b1ce5f3df30b5ec9191ef1380207607ff7e98e6089c04256f0f16db2565e6cc98379b32654fd032d13c02fe6d5a9e1f7e768e367d6fff01a4cec27d7ebff956684fa2555474709f261693a7c85881683d18e81839428fb59de254cce038cd59c1b1aa827fbe7de4282a502402fd03e8680625ea736aa32687f5c0d742cf0dd7791893a90dd2a3ede780313ac964411327c9b13bced3a63d58e0cc88ec26fe1c006078b9dc269fc7de55dae7a137b993bfa01ab37a702a2c3edec35f36e73cba89e7ab4bdd3ecd8d719ad20b1254b0b94fa920de7fb08cb2a3be4ac88f65b07b2819515c783fa9ebfff358dc919c55eef4bc9c03377cf1cbdf8b8d7cd407b8aa6f35ff89565e3a37fdaf15657c315f4785ff70223d944083d52084875c4e5467e523ff84aafd241d8568dd45379ca8d160d47425acdccccc31b49c440819f6e51afd5944b89aa4535ba1e8d66c8b3d6ecffdf9304f3e9dade077b1d5004f9a2d3e5d3d7f068744b5bfe0ae7d2120900dec210c68c1c3ae1721c738f53c2b1ff25fa98ab4b5d8a5c469a0d1c99f97f448126e6884b8af48d5a68d651ba0cc9cae3a3dc795d4a85a961522ad21895f3e93581f89f8e2a600b4288ef39fec925584c2f9a29fdf61c65ce8c1064ecad3f80b804e3e6e691b178c823e2105e58838fdb6828016b2f09b6b7a96acd0192e6eaf086222136f535276a47e95d1e5265d9d9c2cffe8445f41db0dbb4a90542cb3e4b8bf4b0bab6555738f65bd45d865e3790b5e044763b6ca18ff0a0a9b9efc02cc69845a04206cb069397bf5a78e0e842852aa1f0525a6920fceb45375205d92f8c1863bf40fe736e520439afd764a39f6cb063a072f8176deba6710e08a954c982a53ebb47c51939b8bce96691f9f147aa17c8bff793d677a9820d955ae8c1025c7c9d50a093bf01e1d1fa5f7fded76cd6d2b8a4d2d9d9a86ec16a7380569a63d365995392f0a1513a81c22f44fae0110bfd49308ce395d08772d72d1aa0696cd02976de03a4913fdc477e3cef387d77c50ae66ac8a766b07e7499ca69a7f26e19762e87183d34b5f0a8b57b307a00a3c5bb2b4e55d7c31bb13a5bcc58893684baab8eabf3470ce269457c991f4300912a5990a5a199519f17a559e2e55a9fbb02ea685413b77405a1a5df5b1c1a10d133fc27d53aa0c28d8332000781ec6cfd7efc61dd6b38aaa4e2f462cdc0eabf28cc7fe37ae9cace7018830ad17f7b55da9c154c57d135b5cfc215b1bcffd5ac55f1c8f87952b45f38cb95caa8f05817877dc2394b8b52f7c5d76c84da8b230869f8539d84b7d3dd10ea0ddebfa65cf8cfc5c348a96877f774d94d75406fc8b6949bc9ad468a394960cb27a02dbe3dacca3d4c645ed9820e21e28443c45cd6e1ef61376d248d185b1125a6cc5dfe112d6fcddb620c47c24115355a55b5ba157e76d24ef983cd886dd987a46fdb96ae7d116cad3f7cfce0e4b65064ef9d3fc7b62f93c764ee08aefc4f85579f7b035d99e070681b23984eeb223365027cc50adf452cf5deef02768e260fae93e3eb125e8005a93f8756ab8845d1b7a597acda9da2af0504734f038a25a8e7a57bda41f12a0c87e4796571e08fd1b487eb3d0ed7d294fecb4f4f0118c1f3a8ddb7c1abb3df03cfead41c338c0167a8eed851452226ab79e9967ff5d5e50225d4ed3b25ed91be437d83341c6a88bcc61eff3ad0c765deb4042d9c78d5a19d23a550da88d4f664fb03e41a4db8fbd0c498065a4b91ece01cd344f1eb0ee3747f8e07a2e27fa0a84f026f16613019a8e3ee6cd34760e413ccbd71b711a00bfb711e99d54565c1ed0de6ecb68bbe84bbfd71d046b3a693a43ac947736e150fe472cc2909b3dd51406a6af8d9d4a578850b7702b823ec7d185614c4c55766476ba6948e719bfbb83b647b776f5531770aab5d6f16deed7bc7fc7fc358f4c605a662e81445b25d5bf6ce198070487f41da7b265519722377577953b3878bebfa07722c735f5ed89412f3d4db2bb4bcd3ba773ba0f3c4f18af8c422190652c9aa8c49c02f278d600db5b1b30cdb5e5c379be564801ecd7d51b3217167df1f022a2f6f8b48a742a64995eba5399a8a83e2b0cddd8df10d2e4ed1ec3c6fafecae90eace52290fda92f10f66302e7735dbb19ce271996a8bc9feaaf45701b64f661afb9f8b0dde884d1a8c301e6b3f8ea62e85e105f52bec01193ab4ed9c8d795cd74e74f362ef03f76a28b0f49f8c2a5cc215b4a15efd863a5310abbae08bb6d523dc86e809025c78267d46fd542b76d98ea5b6d454159d5bd0e265ab1b6fce8030347c891832d412a84541286221ce46ea362cf1f2445efe5d459d001e62333b095bc2750ba2033cb6b53da8afe74d2d30249a93ab9b6b0dcffe9016c3d6d63016cc2e46a181239c4d1750ada93c0a7798d0ad02064fc3bebe8d38d95ff41d1f084d26c6ec981eae6aeb5d08b825bf7b730c6d6889d64ae22664185d59300234619bf2dc0730406c5e559faaf86845524ac2f956cbb1f2e281dd3275380a278c928848f30dbb3f766c540413dea8357b8fdee52c4cf80cf3ccc9749b3c130c44532e67f15d18cf849c0afa9a9dd5f5792235e2be2863d12df70ad84d91abcd491c8b50c15ae106e75eaeaef0090e5b24b9594a01fdcc793eb6dd1080e121a0175fd3f84f74c849ccf40c1715fd275b27dac3efdf089df2ffbb4414f34a56810afba7fa0406f23e98df6ee80a6e75eaf06a13809f34bfc014eed8feeaf023cb7d5fce199e33efc705dcaed0462519b80701d868f0e16723bfd40bb790d099c2d2c83f5a11ba27dcc358a8dc2147b4b284daf20df60772d0c300d3688ffb328553c5165405a74560049d20bf5d403600c04425748c3d4991318c3f73db666fbf23298ce4a96991f8b314c7657fbf382de635dac05b22e55a792436c9752d285230e7b3be121c9345ec851ff886eb1aaa89a600db66b716bdf3d1d532a81de83cf8fe4d16b06dc24321ae675138c67817068ca166dd05cc6d29186b8c367853a3a4973cd7923f361d19f13f9af82112af14cab8c0dfa342b4fcc338046b5e1f275a123229c7d02e328d913257d4d77ac0bd6524a5066a28926fcfd17a427f9f72d6578f075391c99320227b44f7d5324a2d0e7914f329109e07f5e498b5b8736720a400712423c0f4af486b08816d61d52568f6a8c2243fbe5a4720309e8fbef380d318f149d466de68ce0db09573374abb7c218fc8db1e1300348a70bb070bb649b064367834734453046d7fb2ab9ee6aeaed4a6b8452271ba5fb63e6cffbebbe0f9f3f28c7212238229557cf83d3a7212f4b3b36b14a05825d598fde530e878cbea432671dcbb98081bdceebd0b465126bfba14f325b7f32c1c13f8987de61dd0630c6fb4c3584daa4f72f49aefdc85dd18f8681b31ab46a45585cd38611271a3be970d9c4bb5045be4580c769fe0c98307993c6098e7752bacf726d2a1c9fdb7890ca53386fadce7499fdb9b631ebc935419f8a93d7590882db7f6a43a9e065657f2f5ec47c92c5b38d990b33f630ff11ad3a84a9e7ef1da6b95dd55812bb0b89dc2963add0f757bc8ec818491b73c1f76242eb52bbe6ad6aea5db08ab357e2f404a758292cb5b5218e2d5e2edf8ac642fc2f99f1df92bfebe5963df89ef881080cbff07d2e2b99812adaabc91811d8d5eec4e33e85a94ebc21eb106978078a83b4affaa855f36823216a01e8b6befcf61a01cb448ceb53525b8159434eda017dbd2c91464e2872b12a9af6e1663c9ab14c90ec80c9d633035f276e57ef92539b6ce3ebd2bd8f3b8579a5a55d571354018220680918c1b31282c017a03645e3847b82fc6f154760b810da473db3a7a58e946d81a2be98b6a1acde46d8a482b6555e84e3ef2d390850a98c1722d88b833694129f35248461285dfd3e71914b16b022acc8b9c6b3f309828412ae22e809fe813f1bc12d5512e6e0aa8ab6342434365480250fdb78e87611faca321c1f8b29da64c0cbb5213a4ed9e1dd23f04f5a6b571913e0c02f95f4e5e134289b1063790144e26a7aa2ef99d04731dfbf22dec76cd2a4a831ece2e4aba16f098fa01e3ecd7d58533cb99cb486550d56a1ce7602daadc902826ee4da9290efcfe7e927505eb946c511162da06a738cb922c7708ffbb7550db744bf0c22f12480edbca0a6e145c79b04e0881b32bd1f17549108509d6bab87106b34fac3edc1370bc86739f5391582c4e311abb5c79db7b33d9f2f446949a9abc8e230d29dd9c12ddd57e3432585b5ab730c8415f59e6d0c75636e4242f26459b0edd6a3f0e7472fa762d6cc3374505ab723f0b1337e8ae619da684799a4949bced30d23e6bef2b27dedce3355032b4b04c52f60349141723a5fb54bf5ebbf6a9ddfd7f11121541f693d59d1cbeeed67d8c32e6b7bfe82b687d78360c48b303c795254252839adc4d6bd40b44c0bea69e30bd40bd646fb5e162584301a56f930e2c347e5e5e718d9e26449c728f0b9f50c50bc3201ace6d834af81984ffc01e9fa43dfe1c8fa13c57727cc4749b05457ac9c505151d1c4691487c6989d25909a20a24cbf6a755bac6adc072147eea1b621a49b5e68ca4a954f1fa4055e16213b4bbb81771d593d19bbea6594671177d12beec6f6b35fefb0e6512a49e431012bd3d3aed626519b5c95e11321a04bafd90df59d32794d67819f496a34a7a04dabdaa9f8d6b5590e89ccf71a9f6f3663b6c2b6568d4be4314ebd59e170db2c6ba3f297e47a63d1733d677bcdbdea788b9df96990994d94ab911fc198119d0be343622d4a90fafe75a702f18146bc860c093b03533f9829498ccddd5460dc805c511d11e9636fc6c734260209919897b79081e7602e08c4210c462de65250b232153cc35ac453f94fc9a79d873d60c10b55a2250aa762ee0cdde86412659fad3fff4995dc0d251fe58f7e40439366247435b1f67700930e7c5d708ec5b49b1e877a01bd9740d353e6e7a399cb3da2ddddf8a99fa4b2f138bee0b7850b5a63f9fe81f9a58a18f10742c7a592b7c7affd32fd1ae70ff8b7a6bcf9a26d75523266429260b0ba6863be517a18b6d00f5ea77ebf2df774b7abd643716775f3fadd0408934abcab2f34074b9e86fdf3ee5dba47cfe6ef26004d172d35b1d2a2a69d12fe981c25e195250f1c5382b42f385eebde4d14d8603d79656eeb6a160d12f6224994a3bd615a97a388c7e2d1ca95160b2345cf3b54bdde73f4a9fc544dcbccdc99566e347008355a672e553e43c23d5288e3f99753bee4177cf3b4a227119e94e24cf6e30832bf75878b33a21c148bc46be7a03d0042b409137933b5c2ca7e11065ab941ace0873c4c1fd539c10fbbee93c2b1245ace055bbf16bab680ed1f20128ebad131aac92d1a2029f6ea9ba9b65b43aeb6bf9271eba519dc9e4cffe245ec2f458378f1cc3d0fd1f749f572dd5d95cc2c67faf45be0fad78c446ea41898b1358c83a36ea7812fa139b0cadcec9110e9ea0b7957b33e394dd03a99cc5f992cc212bae552c4ae4f21dcce47d09106889c0868dbe2877e135593f093574f936c8dada816825f99ef42e491a94d3db7a75a32a3203afbb7f085babf925709814fc019fa0c66e75671fb299768162359ffb5d85c8424a0319356f2fdb346d0b563416c361858223461a21eeee6c7a479ef9e0d320258005e5511b5099da0d95a2178ea2dc5c1fc73183b23aea2cef5ca4938a9f73a76f2143bd38943b7089c7933e6caee9864cb033011d55198296c758a8a4acbb15a1af5e8d4ee67c82474a9453f4c9554f547d4d112c398ff79066879d6ca220b0984d1a5ad995672825cfdfd8784132c5d3bc612f292b56fee1ced717b6c5fbe2f8923b75e1df88750818f099d5edbc48795e8b836e3ca744e6d1171494ee9ccb6d2179f610215f8b8990dcc13f34a11b0a1c00d7514af80f66eb4b692ebd3127e9e0b8a720fcd317ed13adfff9e11092efc7dd26cbad8dc310521ed3a774eeba51623fdaa760078698124ac4a32fca17f84c17ffd97bb601bf03476f7d784ceae6a292a127148a6c46949ecb29c2ed82810f08df05e6ffc748e127a547d554e7697749a0b1ccfb8634fb07e03043499c2c807d3efbd8b0b1c6eb3c1836f6a6cd40d97020c3e8766ee64e21caef8810c55dea7a72ce9c5cf92804698ae58ce3e619e04da2bd1e0351acb2c1a451205292dc8d80812343e80f879445aed36ad7f44895b93c684e0050a34c548db07d6df8e428bfaaad0ce310a4d3fb01c5d09943f6103474f22768a7c6d6a1858fed41ae9ee515deea8b0e8e5189222bb13263ba87f3da77dd32924ab7112707be89c14776a66b42e25349ea3076414e72b89140d6b6e0b89435fbb27e8b8a838f4f090c1a26327bb689f5bc97cf12a5ad2c0015205a16f54d4b62c10391fe89dd5f05886b51899ff13f4c6af5eed24e0682106b94f009afe99931d169752265e646067f427d8956d0a2e8bb259a0ff46abfbc6dc2723d6f883d5dac4f4cd752967d5ff8ab3d6d9095427f273ebb62dcc69cbc9bf3f7bf6b0df314a5657e6db737c94e1cc0503cad60d0e128d1d5d3b3b45554ee2b1527e1167e7acc81a9bc86fd3948a3b1d5f4bb8efac6ee928ef02c22893699fac9ee631d27d2930ef50d81bec8b2f049b76015e9b5bc2e8921a9770966b66308935b692357c088ed9c1381cbb914c32dd17d8b4894a3e59716b732c9ab1fdbc2d9696f87f5f456820d25d4fcfc291de712910a7cf11c4f28d96199abcc5177715b8a4d417516a2836f81af9433422d3044be2e0a5d594cedc56cf69d20d39143c3191bf98201f8b9a79ce708b1c2a4ee228eafb3cca46796c214bb97d069083a013654a6cc039607abfb658735a743f674ee845113f8effec2ffe3f878dd8bf9436790dbf17c2961a67b166bcb110a8aa54a9924fdcb9812d4359674d196bc86861f45dc15296efd935d52d82a78fbd8c1885356e0a2da8b31279b1968e05c8467b950b8686aaf031942c2fc7ab8851fd293e5547a3b8253d7ce0e6afaf020e287d86b2865126c895c58c7c6232b5e45df04594532bbd9f99c214a1ca835f2dba343bae49396d7609df82ff90bc19b60e4422188abb215dd6f1e3a0bfa6fd08ebb5693a421ced33e16a8cc31ad932932d1067579f546138fb05fa04020515bdfabc941eb1de9679feded5fa739749e09e7d913703c70119fd3186b6002895556c94003b32391f073f3d0bd8f46185dd2ce16bf06205fe3b6548edf17e6b9bc25a23ad2d32ebfaff080cf7a4d07e74e1da8bd063767ad6561dd764aee3ea71f168b402aea9cfcabafe188e702240bf370a65069c976e7850616867527417b6b616648b75bc429c9c24fe3b1f1e74bc4c842dcaaa27d1f4d5b131c649431e716552e0de56fc90430ce9e38e68d1cade39ffac9484016225cdb98bde1045c61584f400bc16fadf0ae2624ae2b43ccb625ace4c58141df260c6ae0ea15255f5f58fbb7ef295094011c311de0c6431c250a0645b13a908e68db1ed5c9ab2d6c27e0db36f50d5294738d1ac728a5a09708c8f10c2362e531492188e9066eb7610780441b49d4877d7bf0229c6f44d9c3bf6cb0f15f84cb9a2444b5dca57816586720f806b765dc982285deedfdfdc3ae05aa65ecb684678cc3b93bac00d55633f4e25061597f247ad4ec8d1b121bb6f43d69b11c19a0baf06579275ffc820fb2db70fc7c2a6cb77137e879f1d81a6c70eccfe53c2ccc1b4650d04a281a05235c67f11161a14597f84e4912682142d28f210cc2c2288ad39548eb746e7cc52fdaa6983890cd3e18e3265ee9b218f5a0a1e6a61474d086e456fc73b107ff30ceb2f3f5a3799cf2ca4261f7e44d3a824ee23445133422693e177b6438239d01528eb682ae7f7c82ca262b48f75bb282d89c2ef2b7633ed210834bfa2599537e89d5d71f8f8f6d19d0bc316941f0821523773b74ee6df951439422ef28de035718c27b4ff32d861943205af6aa1e76e3918cad953113ee447868f804a4316106b12b2fdee01ea7e10496a54978cf6ae0300dab88dbf894e521c3caa73729489dc20e47ed0384ce89c9d2bc7e072278e8862ca5e6a3887bde3fddf2048495dc443db5cd329b66a8b96f6911c5a25c7f639122d56df4a236353582cbf5ea541961da6d10e6f7cc8bf86602cbf44b9e62b6f3ce426dd14dc7b58b9c34cd8f7da182f1952e275cf95ca57a4db30a5e5a54054a61549fe28146035347db831d3932de9095f90f38fd685080f9eb52406e09631ecd1fc828014ba76910d35e879bd2aa1783cb37acab1f60e32ddc8038b6ed1cd16513ed70069f86167db7ac265f7a32de26ba320495c15d13e5451a8ca7611cb33e40d058ee41f6dc5091174ea6fe1d456cf1ede2454eb0ccf13900047d6ceea87f93ab805d426eb4161a631cada85212a1291a8928218234f372a3fc5ca0a2acb451ad156d0baa40ea35f8e360ff1490e2b943397707bb6ba4ffaa7da46275cbf6d4b9b3f761b55610322a0092cc1a3267594c47662f84fabda6e616721863c6ce03b252f78ccf2c5932eb9b28223637cea6494f7fa8fdcbd03325c4c6e81d9a0cd2339cf48e379af331fb5335827c953989236b4ac960fb295e1c3692c784a8635b2ef57581943c54879178e5d4fc4bab19d4c85b0c5d6f807c11bc66344c65904099e838487c272e8d43bced8f358b966db5e4010af8b4567055fbbb05d0b0f2be7afd668b0e328f729ce1b3ce043dff1becfb7b5a0a4096fe0f8fd21d69cdea5e0dac3cc09f60f9a5d50736db10e293a91e7bf1e4e903dbe80724f3a4290bb77bc78cd51092ce7c1e20211ff679d3bfa31203e3635cb6895e84b9c50b4d40563b28df86414af75b8403bee6af89e6ad950bebb37c7658aab3eba0c0336ad7456aeaf3cee9c85f40a155b2a6790e46c50d65e5fe4e957c60336ac6aaad9ca828e6ae73bd8223cb7d6fd63318cf5c3098916ed7cdaf30f313be706608e99424606288344d90f4053473c2802b69e1c0a30537bfd2dff57d616eee7795aeb05cc3cafe77e3043ed77b8c7908d1584f98f66a9fca5f0a48b2d324d0c9ab07197a401cf99c1fca921f19c1984169a76281d44843ee581315d84406388f33abee1c1207a24b417336193c558484e7c5852b863ac8807878bfff46dbdddce5781dd05661d4b651f5aee1bbc7350a99411f093b9336249524830deebda2bc23d10ac4b7ce5704c748cd692c039b9a67c7bc6df7ff0a070b3547f52638c5638eda13c1da8021633abcf2b9afb6dfebfe971af28fe9497480a936cf793d3c311d8fd4ce880cc106924d570f1261a45405bfed1ed20721632848bfefcb660702f93d3fb7c91698b162f4a8a912f0a8cdfeaa0f64b717a588a1a8fea86e6ac93cf96c4d7d67989251baea7470c14aeee6eeb244e87d27a9d3b1e61bf4308399688330433a84ac4d342eb7f36879d752c4c1525c2de249cb31fa88900bc72f3e07d2161402dffe0747ccc8e89148ba4b1d23315b928bc0fb0deadfd8a589d6fda060a665f20c5e98e48e43df7cc0071aa0d69368f1a851f5f53dc56b1baecd551be924b7e46602bef7bbc619d8fea1fe61479f0726b11931cf4583c5c2dfeeaaafb2088ee99fb44c9f9339a4161178cdc44a4f4fd3d92fa06553a4c55733905ed877e3e538767b9bfae4a370fceefe87266bf8d76486ff00019a05a14fb1f4c9bd0079f316093032853831e274cfd0669f3b6cbcb503239e8bff4b5dfcd3e05c1e98ea27a88a25bd2d4fee58ff684c1e6033b34703ad95b9c7a597798de0b97ed1850cae407853b2a9f29e31a1b929a452dbeccaf8c6f0f68492cf32aefce9d26c15b464746791fe5a61c5f9e1b78285de4d1974b10db7c09940fc2566665e20f77c7754fa785c8395171aacafdb2d83c7329a39cbd818bb9ec12868b8ae97b15d371778cd18be066030d010ff0687d0b8e6bca4e680dde7a91138c0d47a51f09abd318a41cc0620494311cddec9c176a667131f3bce80161958107be9bee49a0015822691953bb77c0f4910e1855ca6c6f1915a9dc703db9ad63a0f5dbb710b04c02b170fec6227ef12a5d1b75a9318af65d244f33c9bbdb2bd8f634c57f3c56d7f2fda9ee4b68019e6153893b148266b797bee90e7e492624abc4bca4adc17c14ae3158a80db62b1b760c584b8d3452c670c56ce8b6e4d69012ca2c532035a628686b095d1267d74d894b4418df5292914fe7015cb7534feafe9d27a62b59dcc8251a325f41b1c13f374f87f2db3003022b806b70316b5e600032cb0c560793ebcf5de62f35044ebde6e6a66d6d3f42f9505660d89b9e984bfc2eefc0221231f0bbdb279bb031daae83da18944d29f768eb1b292e76dc72d74fda9cf79386c6875c98fc107a3a871068f64aa4ffd22440a3dd6532e03f6b6f2fb689522d6415e5ced7a743082414da2da0dc127268b6c32d9930ed81ef28d501bc11abf361ed8a3e8f9834c8878a5f5270d420524fe2154629ecac94783aa5de7bc752434ced1d50b5331670847aeafd9a524b44834db079b82ab565038d12a4560c1c95d3e64822b44209c0fac47cc6f007e675047c1ba6ea9f0fb1525e56509aac409de96f70b7582096f6b9c106224f9e09675556ccd73790868e8204a401014383c634a986ae44d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
