<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0037af4ac8bc553431cbb4a163760d666c29e7215edfbf44edae0756a97fa5a6848d62fca773644e571f08efd41219d1e69dd1a9da6af00c3c5e564af79ff2c17d1167744b9e6c9a1765dacfbab7243890349a51575dfdbd6ad80c4716176a1e76cb56ab885e88fa9696250b946b72a50c6092676464ebc07f2e54e5aec04dc5e3e15cb6cb582241796d2cc69ea5782b4e48d8b8b10131c438d3cc44b3a61280f59e7b93f7205f14078d396f89d31daeac1d70eb576f90d5f11ecb4e2e47f1896709fb1f1c71c8f3e77b3660f336b694328da95722b618bd56fd1b760bb6d5e4514481ecbb158a226e045071824597d5958a85a66e9940a0d183cda2169e75e64edc953f09bec9c98881c7b6dd706dd3ac3d94b25966ba6bf403661d40e2494d484b46d35987676a5b7ff00e9697357db43944e7cdb487f8169fd157e8bcd0aef78af6a34d545b60fe84687e870519ff576e7cccedbbc4cec7b1ac83af01213cf512b68606874a3639dd8092bd8770dc5579dee39baa992443de06792599eb7e61c652cdb646afe9741c295dd62db0f0c0f3d2978778e465280a4eb0f8c609d038898b3e830cba793bb5c27feda10630c01224f6fe08983b6461ef394cefe01ded71038ab6231bb4c23ba40c8867bd74953268ed9f08cba69995980014929a1c5f5806bc5fe8381b0e7bddcd0d573976acb31cc9ff71a47f0f742c777bc1ad88ec67fb9f30e0d53daef84ba962060541d6247814977a396ac32d97f4edb9f4f7bd00f613fe9849f7baf24f1e898f5f766ba9cba8e5b424e0b75392e98929be82bcd55a2fdd789350431826072971352c74d9086b8a00dc763573e00c061f6851d03a73e70b95bd5d871d7eb61cc655b0db0ff32698e682a4e8a8f4b65b9bec61902478cbecbab48757682df4a44eb74d482193786b4a8eb7b646ef4adc4093be4890f9c2dec2cbd4c76f9a5664719cb79c4db8ee6fef515923e679a3f76dd646a5b9614081b8fe72537c2a47afd6622c4f82b8ff1c22d47ea2b3ad39634501632687e4103a6a66f4200b651c49d3c850006750bc4c1aa6ed7d0a92a2a0bbc592b48fb417dad97ee6e4d34e8d450cfd72abee596b9f8e193c5b8385ec4db003de0ba644d64be5d2e584602cc324ce60683a800982edb8cbbde409dbbf740979624b5a19ecab28372244af6532b272d9443ca9d5e6b5b8a2fd3367146c91d7afa833a133ff373271c447bcdde896f238aac71a504d545f0611e5ae980fc23e051a4aa86ee8d6512c8df4a5e79ac8dafd53901661c78b418f3c79d6a3781c0a96c06e73ae726ece34da3cd9bb26fe09e20961b057a8f4396f900a46c5df7aaf66b0935a52e4d06c8ae90a7ff106f253c96f08a3ca165e5a6ff388874ca3c685a3c84ab47cb0a8532224e54f8856355c8f5124ba4d81e80afb4e6ed4565d6f07e08205d5d77399faee44755c8d3ab06bc5ee9ad229b1d3ade75fb9889700d22a8a19a2ac8a3e8d73e57f1211315d531cc2b9fb4f3c3d667c72010ee97b44c382fd4260117659c143c79791b21aacf24e298ae49ce2be356e931cbdd7465b6f6757fdef1d3feeab5f36346ca71e71bc00888f7d6e248a162ebac3a2f8f4f460b496a0b7c8065c72914a967ec385131222b3258c853e6582f1ca0c00192aabe15d64ab912e32c7f6900b5a01269d08047aa9ce994c700b3cdad85d94fabf5589ab0371297938bce8c5d8491e92fa96de05ae8ab5efdd832457de959518bfc3eb3fcdb012fa82c6c45791584e3f55671350e6a0765087c633869d5bb4b49b875b8c6c8120ef588f471d855b2e5d9b143523d064559475c48d3fe423dee84bd58d4a48c71178e92fe5b20244f9e8413b58670f61e94ab631b9fcc6eaa908d2bba467d69141ddaf7949240b897375577ab2cf7e6cc099d1fc603b9844ea70590da41004de3a763df49a703fb04b5f0bfed7e79535925354c7b6f0bc79032f3ae5016a8a67c0aa97df00871371227e13025cb9eca1e0061507c3ee5f3d1fe91e98bbb5d4e5396c437321eaa13715845bd3ba8fea3e17a831ffe2ec4aeb57696e7d3ab4eb919624098746c87e7e0cef528cf4b67c2bff62f00085a0a937db3c213531040df703aaf1e29cfb224fd1ea9e7871182645553a01eafabdad03683079d5f786830a87c8fe0022499d8f1528e01e5c3e9500d06935df31c62e92d95b64d193d3fc89cea1786ace5ec65e0a9498ad23d269ed9ab464ce9374e48fe162360bf608e533075ad7f3f36a2fdbb7a7a956f9e3eaa89faabcdf40fb3f35751a083c63777306d6fb489143b6d8992124e2f2de0987a28ce2b32160c5b8b29bcff61c4b09c30973343066fbea1016f5e13d54bb781fa0c81630c2e07ea145c71ceb99d7d03edabe3b7e0b34cea755382dd36f3b7a68b33cba8966dc7997efa4ba1f8941f6bc1937ecc15d47dfc775cc2399a092c1ff6b1506d19a205681aa9445fb25b712de3d3cbe27376aa07ead6e4d7464d2a2944dee1c41a4d7e6dbb1b093c5cfcd63ff679748c55768fb511082442c15716273df00a2a7c9ce7ac82bc63a3bca985715023cf27582c3b5222df689cbd40727da939d885c29718afbbd7a1f268b0defd4205e2ac591e90b4b874de8b1b9e05221fc1a75e2d6e35b18d9c0b979e64484dd6e92d84ff99aeca3bd0ad5471542e5c7b50000633f10fcd183f2444acf1fc8162bb549e7f7a8a158447d1f53ae1caefbd8b98050603ea6ab35eec7d799750470af23927895f9e028a3e89a50c09438ef8ef2523a2ad94dc1c058e14959c5bb73d93c7ee45a1a6b03e39c7a760b219d6ed4e138fd957b4ac084de5508a72f7834da053806b2e492d4162b7bd598da39e80e5d56e343bf33ff8a01495509f49a10c1acf4dbd21441b31fada3d08b9538860c8e7f1707e53e5628be00d9172f1bb08464b38f45218b0e865478f39d7b7fc7f91f07c3d8450a4cb6982e8193876faa669d83b486595dce45dc03c6b7c27fc5d8d26d13fcc08ef45e3352fa990c134098357ee523f312615cf5f01eeb14df3273b016104fcf4691ece399988fd0297a0cbe05170babccc4a77b112918916962f1e4d88ea9de5b462a93f507cf4dc94024239e594dc512fb94ae594472fdba2c553f68f5ac47995a285fe64ab97cd4922e98551bfe6c2606b8b700be85e1e6ac1d21655a70b79ad7e13a7b8f342d7099d23be8e86888fab27e134a5a14b4825b3ff20808b4649e16403a33aece8055a7b2b0372f0c5a85c541fe221bcc6fe954f7c4e9118b5f315640290cefed79776c469b656b4cdc379a8c9d76c31c2b3f9a9cc9289386a8c04175b3e2448628352f1dc4678b9b66ccda1f266b4c115ab473ea7e3f8e222231af13d38dfbca09f139a4958d25844f67ba9d968d92ad21805e9f52b94afdeaf3f37ca82f14570bca3cc410a7cfe6bc7c740c93e5bf0ba5fb590a077555b91ae16706fad764de383ff265b7baa6807c8e2905b276970369115c1c6a3e3f30489b7b25a1ab12f7ed7b1b17af237939d06fc667ca90593466bfd95b0bf776c5851e2ff73ececc9559b9f8edd63e300d93e78a128f2c782e09fa4529432564e53e968f9789ae6974070afdd4b720c9f5d701d6837d05ecd41e9eb8590ee0cbdb8c38c941f35b0ec86ff5ae8fd560de2251a4e832509c631bd8deffd906074f9ba90e1fd1ca74f144cdf03f1193a39aa9b9a8c985960e799eca4ad8d2622677e8e10bc361aaf335038393903f42f204b442dfed9ec0f6f4ee4d0267a29964099e3e7cfacd6820442fcf95dfd90bf4cf90d2dd9e84918125582a8db64bee7269f106e6438d220d76f8ff6d2df761a5a8b96071debc6172bf96cdf06800bdee5b46f9671a2b6720a0fa0ae583f64e5b9a9aef7b5f9a7a95b5eb152b5165d80f695ad30af5b550049293f93df27ebecd1d51be2091a8485e70fb9c13cf65250b1f99f2018af77cf5f424c067746c0f17e524f28e22b8286a978c85c2b744611e1f790bce4bfaa4cc468bcea15291e0db426eae70f517a3df30d0b3812cd024b4a86c90349871c0a3cda5817c04fd4d581a50967d66cdb70dd1dc7817b1d3684cf8720290853b49d338c42aa6c7a71b50514c0f1f08dfc05ee78a976b4d64f09c61336aa9211db12bc91d82e3be13f910c0d7a86f4f434531e9dfd8d8b5694e929532532e260da1ed1c2fac0acb2c08089068fc7c2b2a93e638624970c018e48d6ee17704a8593eb869b58baac5619b5f2efd1c22422d6f00d4465d8eea4d4c0c30d80eefbded130b57ccbd35b3a2abfd46ce17284a398417696472dd8a40404fba46b2d9cd494b32298c8276e85c0cc56a9485e9dbdbe461dec4dd981b48d22f9cefebb2bb810881b51a462672342c475c1749c76a515670f6103fbbffcb3777e29e9ff3b67745ada638c25b5c284c9014a3aaf7a87fe50a72e5dec4e64de3fbff80fea466a85c8f2c6fb2c78892e4837cc0aceb91c7dc25db5b0e45422d1d8729477f09e47350b2cd93a6ab520b418395967550e2605184297d32f8a69ddadc18fff5fa9b1ff34b1751dea1f34495d97d007cc358b6caf3eb2b4a51cbf1a230392c1ba1da4a3088664f930da15fe22bf7e405cc275db92776e72bc4d8460d877b2cb8cf2cba32ba682a35b3fb4697848a316a4834625b69355d23ff738a82c0cce5e11f9912aa49e7c97bbcb383ecdc6a6905adb99c0f94cf6e35a26103942d87f07987592a72cfb76c50a5e63640a4dcca3e17b47c445198b1c157602ed88c9fb8edaf2c9a98281ffba4fba384e60f6b5d7b34d1d54be6c2b2fc5f29baaad055c5be8209fd2a473d9f0fe9c3ec9737d3ead40b47ac38c53d0735c2b531c70a41c9cfe018c2e21a0f219a282630a9d0375022b915c89420ce798bf7daf699a31bf215f2b059ce079f6eaa1b45733b02e3794357a1872c3805076a3c6fca22b95e9a6d3276afd398392129bc0aa49e460687ec8b404567a1cc852af66d69d8ee4ba5fd94fe6baf55afeab4b49b8ae7c8eee9bb8365e8b01ddecd34dfdf1405fa526bc2366499f346c89feb42c1d3357464640fede9cfd3f22b53691d46affa76fb4c7cfd173dbe2955fae22b7f5e4f4605a20af0cd55a53829a1069c8cffa9d98876e4bd915205dd6e3dffc9b84ad74a409c001279a6755b0f4f253314a2e14da61745980967e08ee40c528780736a57629004b35fded656037435aba3ab3b8cc25210f2b5df54a43218d21f53d5b1a9a6b74d93804d57e19b18c2722497a239603e22c086034f472173aa587f68d1e4f1cc3fc42de2ea9f6cfa7e01c81a24a8571c8e221300fd3db90b34f5308b6a0d46d755a3f0a7821fc179152c580193a27457205bc02ab7f9b2c66d2f78e2a47955faaa95b24d492352dd4c663305cf7dfe5ab1c7ebec34dae30ded28f188c2115a6e7d9db7b6341ac85de4cef806db9fb8f0ab7863ff383f4fa771e7fe9d4012828fc81a7a3da98aa52618ee16ca006f49fbbff8f5f83145cc788f76810c5ba4fc1d3852ef4a7f5a58d5e748398c16d70717cc1e1f6c7d2e03d064f30b97e4ad26f4d585f8f30848fb096a45d088a0dbb2e615d2dbbaacc2c037a2ddd9ef626ad9bcb5c6c2a5f5daa8a424627831f1a39527ebf277b61c82b32c852d2ecd17affd88231a60041eac6c26f691682cce0a502ba16b7a620fc885dc0495901acf574baa0455ad77d524b9e819f0115d69615f67b3b6628e42a1b4936615952cc69a778456b628343aaa46c7f44c4d2dc3f6df61919d6d28f156b38b93536cdf663f9a7d159475fde305445a4588e6009cded84e40ed38520bd5390549cfe0506d6516d19090a1414c8b2bf1d97c65aed439100b087605f132681d49153a4a2d6c42512f1461bd8073d90ede5eb4b242b9a44918b3e20a491b3fd05e6992cd68591f15b130a2cbc11467d6bbdf44eeb61ca6d7c6f0986dc8b0b0f341b008cd9201d71f11e03a05678e4d8a7a9ba75989911ea7405d3cad36e7cadf893c044679033a747e06b3db3f49af296de6a80d1896393be0f0608d352e0cf381195264696d0d23b349db0d4cc597ed9d02024679775cc9d861709509b739b73f20b6b0df046ad0254642f6a27d3706caf47dae761f6c27957c2acf396badf600ebefe1dcc469333161ccc93163ce9d45cbf35d08996bdec5841c1361e3adff6940a02fefbbc6ee01c5d85fc6b779d64b0b32e7acb1b7d5f4a0efb417b5bbd5be8368df72a6f0611e5478e7576247bdf0b990a4309e63e77cdcf4ebd7f455e9d21cbaa5a606ecdbb70b987df15857f7e8c459bf7d71f9ac2abfef20da6a998cf7efa56432651fee0f21dd0f4795a2be2fccb1cd852fc048a41af44ca6cb445a42fa7d2534a9b70187c9446b9f5b6ec322665b4bbac237e76b59a49ce8d0730b11047b89e85492512211f5c16a594edadd325692960051a9ac06428cb29d0c7419895479d48a3a9fa8d7ff12582f1bcab877e39b8b8612528393d566c8d51b0ee6d9b56513136ef7579fd4800bf85f5a076fc8ebe9dcafea54df7365b7c18fb6803b71d52c3a31d467d9de30be09cad7eedf69898d7f367500d8bac4938505ede8f7ccd39e6f10bf09efa9d79633e9b01f690df1535521be542fb65fb3b2d22ef006889b156eeef82410fd945e4bbc6dbab8664b311c8608f766da6f7ce85738b1668c51d5fb4c353b1011a87d6f6a1f24ab6f6e119bc8003fcf04c0d387a274c693ff1a4d9abc6f3b4319108a9698928033c0afa2a3545947cc4cf579e56e8fe795901cbf725d66fa469e13d6c3d9e0d44eb9d117310b314c1a00605fe711f18cdfe63909f231ed30ab88bcbdc98ec82c57faa9885507fb2d7b4d43ca1a08d0cd66394981908a9e08732d7f9ea91130a22fe73f976f1ab8eb8d883951439a7276e5cb95ed950e8260c0345e21c2ecc1d07dd30669ffade362c3b2494f08ac3eceb271d005778306a68109a925590e8937c029f3d31bc48f0e89439710e58de9fb0abcd9389f83d257b43bcca8220c4ce1d7aa99e791c4217d8750508f6d5d94ba11e8eaa33fafcf1adb81db5b3e1fd9a5c897df77346307df72dac15308066eed84d514271f784c0ac74ccdf876640a90333822c2c39d6e715cbae3fe2e8e9a1cff4619edffc0b3bc30a984e6500fd80b3a278b9a46e6034ff4bd182556006fec1dd1580ea647d1215fee50d68ffc0c957f0c973caa7be353ed64212c6832454b24e43ab1336603be680326dd8e582e05e7480ca6994df1f8a2c171cd63220b61d5a3b22a6ca26550c8bfd9ef9fedd1d0973a8b9ccd5284baf55547fe9b3eacfc68f7382e8cbce3e57e3053b57a2937ea814d18884d5326b319fd7840b4b0b2e3301a1e5b69b84142beae7efdf9309d30695985a6731bd0e772158d7918f6d6a9c05914489af65d2dab1021a72073faf548150dc7e01afdc59b3fb4afef89f8da61399252e43f93dfef12ebc81d64fc84f047736de52cc45c8f6eb10ef3d41f803fdcab10727fd1d95f051e0ff005b9b3546b6e1cfbc58fc516c52a28e75006dbd49f107736ccef98cec7c5c0f858b9680348d0ec37d28ac6edf26fe437acad020830de1cbc9616b36759d48ecc8d6e0535a2e85fe3a1affc2dbdbe166c8f7927b06baa569ef6f16af7b70e7fb534430553b6d6f816dd18501675029bda6d857f3d42a0b2c48bb74764a02f935c24bf71c059120239f2f7ac6deb6c584df03ea7cfa0294b14b01ba6b239826d74c1560beb13634ef99d8326c0566d3c77ea6907217763ca68a1db6bb74afc2331d44cb970d55f17c05dfe710b665e3404db529802794652b816c94ea325e1a294058c901e383dbb7f817ceb3a333287c42819c9c2ece7b9d2c235f6b621b3f19d4bfd3680f0165f563f8c7f53ce2daa0dfac86854dea54334e3efe399c97dc13e011f6b829ba104e55c530f82fe5e91a3d1a38321975b29696f86ee825ea9994cabd82b0a57bc753a6cd6cd17c305286566328ccb2a4d8234ce72b53ad7bc289b44774a39a3b4a6ef35dc7f81bc59bb01d303854895a250bf46adb56f74e873cebe8b7618d845794537fe8776ffe447370df5f0a18b17a4e81cc7aa6fcd61fd7cb36ebd27a5d21d60b3ce420a138d3ba861ff4155736be8f663470c5b9d049b274c78b43e090147c7eed1c90a6d0acf78c8dba1e78ac010916e8cab7379d74ca9f1e5b2bf8f06d06d69b0a731887f8071b569c98568606f82524cd98759fdaaa9abd367bf43a353edb9164b21ca1a958a46e5075cc6af079b9928d5c43e7efb3117906d2044c42a81a8416d27714b9574da563c91f0bb4d74af8daa2141eaa309db9c3c71f30e2f50263c967d270eb323b9e20e3e7ad7fdf6258b0d5f027632957d958f293c999a8b1df4778a6ad5797ff602fc05e4e58b693b2650665b3399212fa700140a40cef13f11de64eba2bcb6076a343e1e199f108faad6862828f32c8ad1ded20936cb1e16d3b8cf9a38981ce925e4624fc4f7722b570409bd8cf87ed1839db624b51caa1c17d65d09c21278ece4d9c5310dc98e94572a4c44e7042f730668800ae7ab04b54342d1bbacaef52ac9d40c87163ff960d51e2426b44f8914f46c7621e2866bb1ec84c8d367ae50d4c2fdbf2ffb405aab5bbf74f8694d3340b0fb5ad03f796c96b454c0f79595e40416fa5e1150304117f519cef3077225fa6e10d8c25e2f8124fe09f6b26debd5d9b99766f788cc455aef13ea5866c322d17e2fc68322bef52cbd442e485d4b429b3b3812f11c497475b8fbcdef7aae5092b69758407ec7e1bac44f19f0f0eb1eaa65a7e47739c40ba6c9f01911ee289a4fccb4a77a2a6725959f4fb7725f7f8560e009d531c17101e68678fb1994a354a753543ebc739c059dd31e5b9ab626376f9bc80878fee06ef176df4b4dfb950fe229598c571150046bd3b11ee31bd4289f9022672c1a8c9d247315c7bad3840822719b80889dd1946ece9970638ecafd085de2071476a8441d5905cca1f0d1ee4ece5e1dd38cacceafff2527d62ec2e0394fa5c3f12dd88382ca1cdfcb18aa473b54446bbb0421477a96b71da01bc3e4fce9b04d518e1c6a6f0e564b338cdefcbd2fe45d9291561b49f12bcb6cde778cd9f4fbf9c0cb169f98e739b071ff551a51c4190c57545cc8219c74bc81e210521b569548f72d2f78a23a48f2a944e93e652773925801772bbf8ef2ab3df07ff6d7caff831b4bdc133e753787eac303794c0b655f2f8e5dd3d740f30ef224d6b477dd2b3906a18438c16ee073788b0ea8aa43e152cf9fb94bc214b8d145f42acc5c1f0c69eecc7ab1c2539a9016b2a4ea055f7e632c5465bff77498a7b6cead3a39f403fc77fc3c41cd1233d58a5bfe605504fda248f9cc76d11f2c5695b9637f66c0ddc3063cc43a7e83488ee38e3cb670536147e897581e5d322b759cb3e107cf35b48c5fc747f23414cd8c58fe90d53ae26504cc8789e35835e2a5441e738eeabbc1b4a8a3ff42c4d0410f20e3b23f1bbfdc78ccb6332968cf419165810314d17991c4ed531c8bb0d74409b5e777a839a3d62c9c4b58c4e21107ee96ea8f1eafbd494953ee3fa6dc26e140a390c1613594ac234b33dbba6d4fc95a0c301231f8e6b4d36291ed585ec57ca0c524e51940ac6941565857bf42a639982f88e74764741cdeb89f2a8f106a253b7c7f5056159008d77e4f49d859a07fdda9c3a41016c8e03d21c1124a14ada4c254a971787972e4064c6a474d8c9a12a6d96906fda0fa5d421e2a2ec4a562ef9ebb2e1fa862f8c54c1d451ba23aa8747d7ac0bda676c626c7434ba301a2af80e6701ce1ffc8f0bcd7fb7d82c6174f06579762871f0b28e667a7ffe5718bce4a047280da4c3a5a61bcf51677e66f75a5fbc04f0f77899c17a0529c2bfae8f710f6454861c005baff5779425df7f1091bcac2d7811bc9cf518b122ef98342ec0e0c11aabb34b2da6cc4b2fc19662ed0f2971ae845787b748c5bae69d1e1ea9a8daab49302a4699015a5d891aa26788f2bd866993284cbaa9181f0d691c9d361bc0dfca6f7385f263012743478dce74f81369850fdd49094b1750bbae5e7754db70c564e642fcb72f3d9a253641738e67e3de97d2471d78a915bc3e248ea70da1c530def74a35a0497818f944f2c1d7155eba406568b4aa6dc98ccae24fb93b07fd3fd9b4d5ee5101564d97a63102b493d6473dc7b9e1647ef9f19df1c2293d0d412af1f7afe5bdc1a75c55545d6ed6530caf3232a6b901e7218198dee6fd329460679248cef7e4a56a4f18e693b88ded2a222a327b0ca399b4eb4e7ddefeda122fdd6df99a245304b25461c315552dee870346ee0937cd29d225c68f4507a3b7e5ae122ef9cd1e73c00b14a67a3a2e99ab1ff41287dd4d60335beaf83b796757094379346fe1d49a213952f69021e82a6919c7a196c57c0244e2c562943bd5e1a04cf0eebe0780cebc71c71f9ebece3070b5a41f61d66537f14eb88bc9d03e4c5ce5cc06e5ca38e48a36e8f8abedcf1b264cbed8626fd88ad3d7a70c9845ef430c0bfb8d1414b310826103a700c45a55b33df0c3157cfd71a4bcf362f623a9a27dc98d0d564a53d523a6545cbb995565fbf0d6f2f61b37da63a9cb7c366f6b10d4b7efd7371095b8483ca2c937dc6bcf62802f2e0767a8cf71ddabbc2ebfccfbbf3e624edf50b7c7bcd166674573f7977b0d48b48101ffc8c92a7a638c16321b48c21c8377de8a4939f5e3e6f2967aebfa5ee27c2a01a2159b3f8dc81cda21ddf90b71ac1af56a30b9bc6f765d0dbc13b3008303aaceb276f51c95a5c9264b4764af38042f96fe316d1fe66c93fea6e45ca5697d7ea07cfea175d2d3a898e138ac023772067d28cc3052c987228ac250c24f434cb578275523d9b70001184ead8ce59e6f1b81ef52153967fa4fd91d610908337858e3d320815780fb3b4730570d37e4ae365fa42ca78fd3f9de5ab5f4797c90a295071942d1eaf7d8a7075623b790e1f286cfd6f39447e1b4d6dcb75d2be23f4a4f88cf4eddcb3aba77df39784ca7f0d628aa16e56fef9cd2ef4a3c96cb698813fc260f902a7aff971a1be973904bcdbf2fb9e2038bd2c565cea94b60c5d10f99ae59b77f5a81c2323e286588fb8a0b894f421714e4caa373a0c1a8876750fa12f71274c6d2fc00e0f15847bd05f1bd093d586b65193e6049e7e5ed04ac67c0c3d6f82a91b8f688516da72d89ad61a3ab3294ef93b3b2483ed76c444e8c2074ac07dbfc097698d281b0be3cc7863589f1e44fbb1d4cbf67027fd577e7455cfc73f1a799cdef73dc1dc745e8872b53777d21865dd8ed82275af80bca5ca208a7c12e006941178e2781c7038dd8d4b4d9e77e24bbc6fc073cee3a6870b2961daa5f005df19553dd2258c750c64f64dfef98bcf95a0889f24d570ba233fe044f34b992a95c5d3d39aacf1a1d6839871e5d476b6bddc24f6259a689820f504a98762be7e70bcfbf0803c85b16f0685bca6ea0d2adaa50cbca9fa9ad1c2a79f779e1b04289b894392c1718032096e0ae4e357e64916b47c505eb74f6f2b84c77541c26168799bd75c5f52be022e7299dec589740ef49c1986630e2f9224a97414a0f10c70fc6d289b4f719d2865a4566cc25c06cb4b765e0d047fb6bec88d9a7753f3ff08fd2b95c6be9aafc310d4ad56790d971d9e968161bb996afc39d425ca63a5e5185e4bdfa5cfd815cdf1b6b156ff6a8a52e93b7d865822e549d7812363f6a98a078baa46f75cf2460ce6d5f4a7fd7b8e240a08322820e4a8c444baa01cc67b912ce7424d041edf6fd1297fa03339e125fa7f962eea9defafe203a6f730bbafd5ef2259832b2d7682e8d917ad7cfa3c4ef57cf8747f2071833fabdf817db520745dc517dec0a43d02dcd024fbfe5619fa0c56d03a56091bbd39f6bb7f0154324edf757f17b6adc6ebee72da18d1332bc8240f0e439bfad530191e9b92ef88b90a17dc55887e9950f00741be2d92bd83705698e179da55735ef0ba7d61d6cd370316a39480a3a80fd27fe6ab2d530da7e917343206628f2dfcd3642efd85f244b666d4425ae99c60c004409620fcbd9146b37b68438d258c65724781231c43f7936f3639a8beed7f9bbea6880856a7f5fd26a356bd4cd1832e875a348254283df16a3366acaad6f017529823234e16a47f0ba4ee1e32d7ed9c5a6e3d96bb1164b7f4bedbc2b9387785b8e0c52e83b9e98679ea6ac429047aafb46bbbd0cc921eede8eaf8204b2172a4d73b498214d0b0f59918e69212895a89b59b20f4559d74b22fa57990bcf49ad0e76739b5d2fa5642db71fb0a65911f1e28a6c3a3fbf39e0318fdd2e9e6d1aec7b744eec10d3796a6a8e5c5309139c4e9d04151562e3527e02d3c4cf425d913fac8a4ada09a67f09d0020c96ca8c951d6ec312cca9bbd4331de07280acb2d003538e3234a5cbe206d9e3961f66758da60b6e5840e2bad691a878b72ff067dc85d7b6c211e1a8e75cb2ed2851186165e1bcf8e964093c0b1a2235a7c7693d7614a39508992e64de1d6c6db4921e8bf1e995886cb274ba18946012fbc4d5342648009e29fbd6cf025119c365e46fc5a473def34b58173467fdaf7b5af1007250bbaca51215f0e36e8e1112f9b20f3e07b32c694be0930e7d5e5323f4fff2934a21315be4953644f5348254766404297687a3c4a626720c3c7708d31a474c9411260e6cacf0dc9177bc01a0591836912b203d1e070b67842d283fbc2fb6a72c65056a1ece5be67f5cc5a9cb4919666b141f0fa052496d8764ba22932ddf02c3acf52a30d9d83acc6de0879e0c67d416a7fdaa4aae1a17ce9f61c309202ae3c0cb7c61f0d2abf953b97034eddc1a155cd010f66ba5c11a079b748d55118029c98e5cd40d21466f29e833b30a012ffda962f89341702d80ff44e11b8c976e6ef524a2eb754205db9188e7141e0d4f072e1840c3a13d6ff4a032c977dc7e8905ddff61bc8f62b5bb56522f449670494147015b49a3660b6cfac32c0577bcced2fe5a6516dc3393a8f416942d2432d5a7bafe6c5b063b284e4233d5fa1ff1530f9c31fc0df85eb04deed12045342cde79b042a365141c44dc6487d0df39441c45f2c7385288ce37295d5ad94a6ae919be0395030a0416abc1691164a7f0529162b4f5ef8a325385eed80938074c283f7e1fa527919b113ebda1e11c792cc6cfb478291105a3eb2839d8d98dd3c15c1940c680c838501454ba37bf03134bfd37bc76b3f547959aa5817c7bff1693c3634f70416dc490c99bbe788d57b0bf044bb60e0882106790f31adbaf852218d8bc3a0f4398cf9894144e29e499a04d330af765b72ceeb9829370c178bf71521c67ff1884cfc2c347d08d3beacfe6feee168067559bbc050a0b39e431af3dcc0855bbfebba448f6a97b836381c11c284d4cee3cc7a4b69def2f1d4c6cd8a7863416ee53b33e290ff5941ea70ae5c87d65fc3fa6e0d2e88601a30b98b56ae3497b3721d4b12fd6a690f53e52ccf5ffea4cd35bf51b0816c4eb007887114bb6e7af3063d094ddcb56f4c92e0b1ce04c7c6d0408261e822fd97ef2ae7cf38cc60b3d3aa9ad4c6b16d868d638f5cc81f71f034c0bf2decd0b4ec9aa7f3441d77288d90a9c1ee7c249277fa21080e3d917add6b5ac6b2941f26e0ea89de353fa06dff11bc720ba45502fa3fed8212c8e6e80c9ba156722b87336e7e279a99ea199d16f6428d4201469aff4c21153653fb5c51c75a2d0d1db101844c6516316d84474bc17ee3676c560a3cdc6e59a30da109507ffc75f2328b88af6e5a9bfe9b91793b4595cb72bbf1426fa91e0863a52362de418bbaeada562b1d42569703b912640b5b8501156e3d99f24c7a19ba08b5b329b0f5356f0cea8c064c90d3e7e87607d39b80ce5bdd673bcc1b28afb4e0c9f9038a0b47940c4190ab72dd3725746214605f10e62d9c13b299d7616160d18c7f8ec0ed43c1ac47b28e9643b0d040583ace84850ca78dd63b50c22bf798f3641829730a3d14fd319e8be00b7fcbb28143dca8b74709d07bbf5548b604c61c5380a4e760be90db5edae21995e1d717bc7d2cb50cfc13dc4eaef0477b08324c112f96e5aa92020f0e1f24980184277e6b2c1145b3b0dd294b9615913ff065192b991930cba29c7122519520a30fb81f31dd08be2bd23dcb51ef1a7ebd7655d11db03f65207c6446dd3ed73cf435c1110162e53067613a344e809ef2d606c6ca82686d2b3f6c73bf11832da67feeec8eeb8f3369fe15c0bd1ce9ac57fe2e645c4a564a3086104d1bad5ba6f104afdc66359aff76303b01df4174c2537042e56a556351794d5411ce88c10eda0f32d6d874a715161fc2b11922d32606ce9e46e49186fe191d8e123068e3bb2108e308cdd9052e746ca12444d551707baab0d11ff26c61e2d452b53c92881921676bb97c7ca74c34fd4ebb249ac1dbd9ac871bff51180e0aa1a6b47b041d7f46f6dde23ab6d29bd41658d52ffd1a36f3478d9a242665199fa39268acc29349e893e8126ea839cbe9c755d9b0358ee398c0a1f89d8644a80f07b466e08883ab4e3f1c94a40fa57d90450c41620a8644c0bff6d49203325950bce92379b15d4d6e35f065293f97347e8167582b3ec27490fc354af2522c6e06771430550a74f1e674bbbd341cf67d1dfcaee150b50ef772fd58f8f0e8152f4017c2cf9009969c00ffb47dcf07be4c9055c964390946c0188dd73037b2f333c2722a34ab82b7513207411c1b5fa2c6830db5076262266f8459b54facf2d1e46f1ed18686ef69d368344efb3d19f93663fd0fc0a31c3cc18e2870e50db85f3bd3a00147efe6cc09397b294530532179554cd42c13b59972fe324712297f1361411f9eb4748e4ac3db29498b0c5a83dfa7aa2dbb7b2104ffd3fd166154ca6c730b82dda232be427ba1d31a3051dd238968e32398438130d42d1efe63fa0e7f7bd7350422694dfd190c993125b6dfb576ccf00f168b1f2b46a9470c4bb788cc671ff35952aae0b3ce1a264e3a29e572292f170bf9bc92e4417c7bb29162b60da43831da0d82900734ee668e49e8a31342416dd1d76cc393c5093ce52e880d59a6588490d0153772a3f2e99cd69e06074ab78518b3bef6db28b44f9b9814c59b406ad01df4b60833e0dedcfea6e9d7735e148bd93ac74f40b8f518cf426a38fbf7c1d911c8cd275d1ae3fd14152c2803e9c16b23734ad88273c7eb3091d455c145e6c4fbf35094c97efe675e817dd429f51069ebbfae1de1629817807474b6bc3dd8f2bcefa64287f23ebcae38a4cbf101267d48fc2d955960ee86518dd7490a113ead05be52162ecc2922df967e2e4fcc7ac69d0ce54bfa34d1c23225674206be481e03bf6a11067faa0474a4d83825e52ca2961b981843a8602d41d53ed34a61b806e9a0f27de3e0967fe93bb64ad835bc6834c2a98acfcfb7b55855eae0d278161012729ea55d6d48a94625f5409809e0792ca4d3c22bd138fe3186f16bcda3b68dee4cc4863b07d44924e16dd3e29c761a18dbb270b643b33f2f81830f44798a1bd0bcc44d98ba062a38074352b2f116aaf7d672b073bf96c326f208a1de21d20de2a1381466e2c7150ff5bda4fafdf1b834048c0b4397baa407ddcf349533f1ac7e7c13778db31ad54a9172681aa8c488376d113ca07afaca050ff2d4b69af2b8f0e4c08492e268135eaa1a50766f4ad5185bd6da6fdcd37b3673faa4e490709d54319acabb7c31e9dde72dd5b01e241406b46e5962860b69229a24f78ec3ef5669e4637ce7b3c680028f00073f96627f979670868348e654e314ff0ea4fba43508804424b9918f5389d11a0fe92cb6482abc55edf44975f5a82c9c9502be2a35b3f9bea6d0d1a0d5c663db2e826de48a4a4460d2acdf53f4b2887c6d4ee3994cfe5758957561cda57022cbd8e16844f3666f12b30fca254b6c2e9c9f1edb307996103408472a779b3efb4f5eda9c51339952252fe18182a357aef443f0471c3f27fed5b4a2ad5f2b8f01e1efcfe6030e23ede86c844928732192fd38dfab6678f94930ea353a248a779b6e5abc2681901cad903b2bc42f0ad5f68899704cc346749bbc0e130a4148f8f792fca1be6a754b18f05e96564333624cc4711a4d8f70dd1b21d7a47fed9170f3b1d9f0f8833107147b1536ccc33f2971485ca0debb36438198230aaf91bffd86c713d4e604253d36bcfbc688ab57f6ca0ee710fb0089798b478e97eaa0e9298c732993aaebdb78dbbf47b47c63e9bf033b57d13a598fc10dd6765e982c94882bb5ed564210ffceebb8baa5ac270f7b355d548ae6e61b9e28d3d1f3e33a16790f5e54cf7b527088538540075b9978ed9c3e49d40e41f80be0b158d6ccf1ea5d6c4484c7dae8186900d01ed75ebd945a0fa4fff742f301cdf6d6f63124862491e0ddb32abcbb8643c6f03962048cf16dcb0f222083e42cbe38ff55f2c877ca311fdf52f21670f51b5bdc855a309a0834f78cfd13f5293a395cda4cfa7c904cc1051c612160b2f035364160eed2107a844aac1f3b216b581028a02a596570b83eef06c23978cf22dada70ed74c6a6f8429be5d93d3b399df876f5e9ca3ce25a74b5649dd5e2525b6ad00dcc692e930e30f2e49e53344e9c02da55ce0e8a0d1c3b9e343875b9ffadbf9f1cc860ac94d5575daccf1bdfa9b4338cd14c4b3428539f4dacf79f6091a76b9223f30756c8ee22d8d13a67e921e03fdb6bd2bf2004cbbb71674732a051c519d774278f6b3006a35117e7ee891ce8d7826c25e7f208914418c5435f4a26224e1c4b020664f4cf7e9485824a25acc78071d95f1d65db94f58a7432df2da0caf6ee6ca63fb511e6ec3fcb4bc9ebc94f7d3000bc5f2f0fdc1afd0cd939f5536410f9bca54108023a0787c664785e3afece88d956349fc9e77ccdfa849dbf89a4cd0b83590d48b7920ae674bfdee3222b47af894f0504c05c1190fe536d112f60ab725bcbcf808fd796a97ab9dda13fe78da0fde66203ebabee9ad1dc96fbd7e48fe029715c7b239562ff1ff2947194dff98f3dc706f083cca94f7a91ed7219255264d3baaf8eb811ab4b39ca4cb5b72ed4d33907d65c781f71a4382516dcebc73bd7998685f5bf9268f51e87b5ae72c9573ca8e024bf502d3f56c6a1196a2e57d912e16d6e0f489215c747917a9eb4ede0b913769c97a1ee58616fc9999db6bc6a7dca9dec3ea8b411ba3219f8843d9af51829d67d9d6f0c15d12a62c0c6f94966368adc6259294e34f2c50339a76593a6de9782d095ddcd6a3543955160aec7448aad838b3384d65509caf19f7ac2821a4fac06b75d89651c3972f63a247cba20ce81cd5f79bf923a04d913d36c46f1e99b74fc392efccfa5d50760e96e3ac2f821246f381f2150e73411309369e4dfb947a0353277648debc79ea54f547648a42d981212c9b15d787ad68ad75c4e496a6dcd1371282f86dd4d1c8a8b406888ab16e5f2f4af5edb44e688eed40a345fa856d52c027fe6b3ce607d0173be8c34ec57fcb3410eb4d175d34180a57394e028176461989b20f64c08714f6599c21de1ff69876a37e370e40b6a4620ef4f69b3477f132c101df492ffb9c85b7b34b57270ac0c9628b7caa74b8dc735d7870a2245c8871ba6e55a1fdec1aa95d252ae76054d26e693e17241e8808e169b6c0ee3b14f11fa729965f2069bb54c54d6fd107a751c1cb54f99aae72d2c3e449de36db545ca20ae70f5c3ec416d121e879ff01e69e9c98490426fc829b8280703154a29f89aa2a7a28a1ad77c1227eab851c892800f5104d2d2a1753bfb2b7499dba98964702449156ef3d9f449c7e69f6b7e08cfec9cf70078eaacf5c7f4ebc1e9891b5f61e380e7074dce89346b15f11488df44f60cdf3c892f736eb9bd5c5a14c337a48054dcda4317d42097ce335071c098091bba7f44b7d22ab752ac4e684514e67b81f2ba149266eb3a09c3c4c94346cb9811204201d9aed9c214a02eb3515dcf920c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
