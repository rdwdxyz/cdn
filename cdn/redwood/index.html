<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba612e3cc3c5735fdef20fe50783728e1f1dcfbeb63c75175ed4f562db2619170ac92f3979aff14ab9ab52cd7ecd5ab78ba3bf1a04fb58fe3c37a59fafdbb55e15fbe92de73ea459e429ff7f546e764a82a9db5cc40b7203631b2d8d5d3b924d6624003276557073c8e4467e949a5f5f2b739bf2e619c5708d830ba75bca11e52430f78ac2badd22a546dc471c2f3bafe042a8a649f2e543dc0806c0606f7e592b95630ce5411b1fbc014609310c40641d7e84d60d437bc464311d954982a8d95dd201e36c266cf138352fceb182acc65368c61e0e827eb8cabd3f1f31227459266505e61311a81d891e8fbbb8c93ea2c8f219b224771e84aa03e9378ef48ec3adc290d571cf565351c3b8d40059ed69b73b6bafa6bbe1b30964dcf0da004f3855c942aea93db04e70a12add7e5b7359ae3113b4bcc67c25fd1bb7eae823bc6445a12a67aa2941147925fcd9959d64dc80d98c7dbe7cca082eef24b3bc353927d3c2d4b04a394366d3281a4fb303efd5df690f4fcc83b66a182cba36cab63570a9138745762d2ec69d1127947c1a53d7e6be7e90d39ac22c95f4112a6dcfcfa62bbbc482f93a91c45e5d661b3bdb6a695457a600f2cab413a5eaec97346c97e874fdcae4dcdb62b213be6ab7de7e9f8a09730fc98ac5f0ed35086fdbec6bb185b7429b3225320474ee529cf186f0141317af8632d9632d5d47053605526e4997e47db0b2016969d6e37f9afb28b6952f995ee34e6d134897899fe14dce2652871ab4799c42c384914b1be31a40b58192d50aafd86ab2e5e63d639a2cc9044b61828e3714a165a79deb42285af3fc3379127113433a30991900865ccf7f861825087689005de68da57099aa41c601b6f84c9d5e35a278a7be8ff4b618066ce27d9821bc487757649975b4b9534bfb797115f24dde6d94445692c89a37d0d89c74d0bb7be5aea40f0df291d5c635176353c1f6ea82cd4276fb7b55010a118c4cd09d4a5070206676a77a772eee7b314dd0adae4d5bbc09efca52885783c45a394cb679875015c1015ca71f2eaa7ceafc62e421691ece059925816d1d20689b0e351f07bc6f99eb769b388c69d39efe870ba19ea842a288b41cbfff4d748255af90622fbb01363a27607135ead26c441ac3f03b110f6cece119ebbfcabb20514905be36414c535f59044cb01766a4e5b96c64f004586b9dba1e1a1bc30c5144c334be721d95f90ed8279c5f7048b690693024d526568c4bf1ba4cef404336a25a78847c59ffb7e7e111281c60ba78f6ad8d9ae6c3806d3ad94a228eac3358afd4711576b801db9c697163807233eac461988d042c228af44a8a73378d25085093f881e17df5bc18d9790d14166fd04e492ed67dce197c79f7cb7b5c2de4b62639276cb1152c58d4aeca629d9062a44245a2f0a1a7fee1b4ea109c8b28404964b61ebfd4b9161e4aa19fb3ca808121e5e8e4110bf78383cce421241681461a6b0c630d9a965dbed4631a17ae5e496d9f34eb6cdfcdf56b20839ca57516e24b4836fd069798d0042824aad159d47e8ff5ebb46194e2ce2b8c6dbbfc245125619baf078f85c398a1235c22ccd8d5cef039aee18da2c5c5e040182f4b40771a5d96f19b7cc4e05fef2dc410e491d468954b88169dfa2c552be5098a06e18c59a58bcc0d5fd23302c61448d2d881c569f87b9d84be6ca7e5f18d3ac02a11f0696709bcd007c3a21a341386bd219e3a8a9435f0b90ccc5ad3b7e5653f44a7e439d4e4fc569be55d8efdd4a253ee7822c47e74c5316fe9bee16ce81aa61456871fcb0960d9514d784771687a6397b6362d11a133ce2db8ec4a1c794fee1901bfa2ef7bbff7b7240fe9a996e90003c67f8b4282f96f37885d7dbebcbc70bec0971dd97a566b748834854ee468a423008266e48a1052e03206c45a8a603409c0666f2d276c169b1e02e0b2333be81a6ca42d88eb2e3b9826f9dda07a4951cd454ce407fc9f70ce10524a6abd872edda7ef53d407f7cea663fe8f0a7c1530a83fffc628b5fdb0fee3cfe9a8c0134a4537182b1925f646383e06cc3e9b4f667ad7bf2f6f2e8a28dd339954cc23a5a37f8396206d3311dc8ffd3959bb734d3db6b97088313796979e046c38314bd0a139199555eddb575d0eb2f94259dd4516dc2a41ec5d56cbdb8880b6ee99312ca7ee5d81ec5a4943eda05033197f0f063aaa2e381fa65e7bc13c2070b549267a3cdb81d38a0a4e66de54187098ddf3365e52f6f3b3844502aa47702ce363b768baeb6280d3ed7851a445d4d5c86693611fb172b2c23ba4028cb3929f43e5ab07041be1188300eb84149d169595b58813867833fc9349a6850b75b697be44586cc6dc83b5e92ea362b546232313e118cbc162c9395ee94fa3c1ad4689849567715e627af5b2fc0a39d8779c89af7985c5aa3a1cebcbb0ac91817d876d0459dab60cf8c487cedd3cf6dc81d4bd66ee1cea8a098bd8fb070ac3f9bdbf9a9d0c099d2b67952c1d517b748eac874b770ae800677364899454e98ed9eedb31cc709b4a38ee0ea54e38378d96f389a882cce56dbee39232583491bbdec58c99a6bae41aafa7026ea81b307543504b73725ce193795c4f98a5d4c43fc99fd862fed70fc76f4ee523093cbfea6d88c30cc2133d01b09b9a40168f8a04f86c4c09fb9c1e5aaccdd72576837caea1a2e698c264c4c04f5a68743c42af128eab8c7e30113b95e570e3c937db2ac2658635b1b6ec06ed0789a15549f67fdbf782dc0e7ed4e3e8f0a3dced4f3c64c3197087c8dbc2c5f11640ab8d97b2e3a877df4dd5712913db9d9681a30f22d2d654aea6368ded049e12b9a7119218fccd68cebdbafe42dbaf89e5da8084294178faf92555a4a5e9d5eee8550943498cbd00f5833f58d72f7bf3c42489ec69316328be7e64f996229acd1b1b4acd0042076d4f8b75b3df4e63a078b9492bd5e7d68cbd9fa24a3c81a8fa8f58bf8d4c8c62680beed8995afb2ad9cb4dd2984a45efb2ac39b20627de8b4ee6dc0b38f1549c55be6b799744e9c70d18f04dadd6a26d97c9b0f645594d9b50f4c19f54247af125443e9cc7e8a28b91ee42f17b172f97400d3542565076759fa7b2675882ef09bbaf6746b5456293f0a8eb20a2117ebc58aad2272f2b56bdfeeac43ba33f5601e5317f195deaf4d7f36bd1d9df59e7f3cdbd4a1bcbcfc7b4f238b662d974f4c58cad2a0269cbc908af7682ce4557460bfdc8593df0f58e6b4e05f4d3caa3fa04cb3ff1de2fdb3c46ff2c12adf5e87e5881afc1d509df120ce37a1a47323860cedabfb633497bfac40768fab7b0c9919adc1c8b1696377eead2db1e6f4ab29cada884468fe97b9661263f80ac93f184c1da14c7a22507f1f642d64c7a812de32b5c76d79843ede2720f6454d17f4f18af7e5176daa01b742f0723b7c90362d72acad18e1d001b4ecae3c819b418c2e3e9c786514aab337da6679100477722e51414e28e6cc3dcba878b3943b8db81198f8508673b32c7463b47f0bb872a2679e6f6617b931a3842bc3780c1b94c10d495420f4b2b1720c23f6ea5bd3810b9059e8d3e2c681a742bfe3792ea44059691e3824a522ea9033dd03db0e82f724051c1ef55045a1185d47f15907c5c29c372b48020dff3ca450d118dabf672bd1c6e92c2deae3d8371c11dece298c99f787c22bd0d0c4aa2fd6fed738d8ace97f3958a364a5709610732c7a19d5f4032a1948d4719edcb5b03f9f545c862929422ed582f57d11c893420294bf52cf44b52b41a1bade8ee861b5092f16768c2c1320a3d8db2482258b30c507f5959e8d806dd3896c41385ff3a079c0c009a7d9d8dad249e09627a63d1c34d608028478a534b82cd4d2ca2cfaf19462dace07f5f0fad21ab83b8e2dea0c38fdcf11b3741135f853acd6fd97a322e443826621cf7a452cae6f4845681e6036bc57e48a8a34a2743ff1f91386afe5f98115f98ecf9802da6f63d27f533d5d828078ebd0ae985caf2d1c44132554eae666fb6fa7dbc33babf9409e8f8999143055e3bde40831fec2103fcdbd10af89bc0bf42b3abb85d7fbb87e45fa7d564c565f5ec1348fdb6f203a26693832c9bcfbe697a808ca2e79344d862761e27cd509d9ad624f53e49f3adeef207c3a4461612375434acf88a52429f8ef749a22dcb84d102a3bd677fd2b4bbcc2bb72274d6b0fa3a1b97cfbf2595badbc79a247f1b48ba1a424fe3cbc99d0db7ec88c95d827ec5d0133b81057d6c4f73810f5cf7781d2a17b027779a2439d8a62d2954cb6c9da0c91a2f8d5700578141545a559c555c613263e4086b9b8a064c89e200087fe0241f34f3e1240b42eea84f95530577746761744abcbffe6e4fa0de77bd265d03b3fb106f0a7351e102c6d26b093c0c95ecfb8fe3a5e0b448e777293afefe223045f73b7dc97033ca6b9b8fe10ea5a32a876d12155dfd4a5bf62f33986c9d85d7ae1591996a51c98025d129c7a5e116078775c0b87662ba6a71730bc2d9fbbd033ca55f16c8029da2f8e0e50bc8430957c958af824b6d85c61b9ba74c83c9d1e7b7b282fc58c95fe62cb287953465351d44dfb633e049bac4d9ecb739583a5300a765221fb92b4f100bdffbc83ff98e77242a662d7cd789c62a98241fc3699624522d39f06d6b62b28835f27103353aad9d7c7f7c29825a81e4de909d7a00aa62d81b65e68d46a6700920dab87d642a75aafac8ba02154b9fd4c9885245a2dfef09ea533861842cc6e23dc29396f8fe3eb6267f2761d94417efa16c155272b5bf576ba901941362292118f0bb9cd1bd8a002487796e09a394c61eb5905cc6ebb4f5b4b32610f3d5f6da48818dbe726a9e9b857d40ce4d2fe11eb71b00736cb303df249dcfad200decf150291a4212f8c302113c45c1ffb34bec032b6f521cb33a19bceb60078a380b186d94d3543a5174a0d01b12e63ed4d4c733e5730d1c01bffe38d7fb2b5957feb8626f9231db1930ede7152fae7e671c592bf0e6c375ade06382d59dfd0790c7ac0346868107554bc64e345c370fdce59e655a765db911aee09e37953a50f7dc55990ebd12351f70f8e1186881e45f314d23039454824066fa2c7ae06b55f53cc2a669d4bbb2c03008bc71f9daac130034ad0ec5b80391efd0e038758d9d9336d50267c048d2aa3dad67aabbd3413b559db410b71d9c9293bb2fce8d00db8b47b461e4a5bdaf5c0476e19c327cabe2a2020f018c605885e75c20b3689ffe9ad781cece06c1d6ef4338d2a6ff10287dfe7c87b4cc05ec072dbe8da6fd72221d47c3fb6c63831787587bec75a7ad079f70296ab0a994d3bde1b584033138e826616de5cb033ee001a56fb6cd2e680ac53b6a77ad7e9c59de57082d4c2328dfef419e3c8f6d821b4064d58d16d3ebecedec9b2def813de9e3685ee21b7307363b65bff6438042d255eb90e035f09a7d6b7e86cda15c628146a5c41901de35bc2b5f5fba35d613eb63a52be684680b10a9220608e3c8b95f1d815e55273bc1a99ac6b800fb5f8ddaaaa7835fcb46efc54632472623677b94df3fe3698a7a771a32cabab7e9ecd3a1a13a6ba8f6a86b79acd2cc0064d001c734d3b8b43c59d92d2009b62641866462f986befa401f3aa9b939c363c10ce3af09068cde5137580422b4dc3718f1324e7cdaba11867670a023bbf2577293f0471bc14ebfdacf4c038f4b942e938d58a85e5058151a33767da20434f948881827b2f9a56a087a9dbeb23e337d11e76302816e2cc24d7c6ff88e5507f0880df8d9b2b9f5af5f08960abf4d871b563b6d0a371cccdc89c3ad8e65ff2f94d672c30040c5011a34b2dcad3a8c242a1ec7d8029f67e432db435c0e0216f9c9f114af6846fee83f48da594c5064533a8bb7e62578ed2b5c95e7846a32d514e7cd2cd7543176be5642ff4b5e6ea4aa8a563b8222d1582598ea007d5e0c2e7e6fe1c3dc9bee25a9d0089ca75d78d90ae1af291848006523bc726c10c627597b2abbf2ff0e62e0d341532cda635ba49d00f850f406fac60f4ea22fa154ddebe059ee6509cee94f110543cca6ef6ae1d664f29e102188b3db39c9d3f62bdc1a6182e2277424452ce98ac5df4b7a2eb6db60ef4dee67440442b4f9fdf5c99855746f37e16c334f262b3e02604c4f26f58dd1eb30903b8ecaf87a6e4fee6ccc3f2e9d585797418f79fed4521964523860519b489e4d9727398176af9e4a4aff90e35eaaaeaa4ece785eef60f7aeadb8e721b459800f3b31adf785370aed59846a9e8cf6114cfc5bcc5b7a249ebf3c7880f3fc6d666035fce022d519ffed420d5c8f9daf15c1cdc957a532c4304cbd6278a1f67017ae32b8fea628bca7e973750b4255b3086685fbcb013852275bf005be569de4cf3a39e96193e4ffd614c44639006ba43cca6bc89cb3f6a70e3f02c67b5b609cf7a8136416978af50b831b1bf38b52b32f3084700fab9d76a2042a39cea9a989d386773d408c3a5f5f38a07f52ae8877be52ca87545f825d597b49539889c46761f666e4df57d33ba84af4801a2ae84f987d09f731ec81c256bcead543be54ee9e186974d09a63dcc33c7c40da4aca7e6df5d84396ff170ba34f607fce735cab49839c0f385b3178b303c045953c97fbd67bbd0a9a88f119dc7087a1188222b74c9be916c151e20fa640e419de80fdb4ad708ba995858c456f5491f3751df9a6e65a96e1de55367eb44a84da5759e308bf576ab9f2c4cf399d4849b754419cd009e6c95ba49066b8c2fc0213e0d6782d4f3b0f8ae7ded75697b4260d36cf0795e4cc5228fd0a19f29bfbb65ec156cef7c23d47afa53a7f9d5d6efd0ce046f15a294631bcc30ec476f990e67110c48c17fcf0b158d8501209deb1b3de62a4119652e0940b1fffd1cb87b4b7cb9f961fdb2f8ee3079d2986f6850fd06e891b9cf7bcbae3d4d49072220a854fcdba453e991bb01dc6aca25c1561383e903ab7d98739f9453ef9720242d91722b6601d345e0e4a9c7c8aa48d446375f13a30c4956b28d69958b35dc3b965d4bd33bbd8400f5eeb20d7b91bed897ff1d1e2065a0c3e748de1bfe557c35ead323b2429415a245cec38b8aec5a6cf27ab756b593a2ca1361a6b3559fb542ead215d384e73583ceb7757c18ffed73defa1a32a5a4e3a87b605e94ea05e0d181bba42f0512cd568d6fda00e2271d5ca1ce2a65e4de507bc5d018d7dec0aa8b3ef1ef56bda6d565fbdd864c77a50265b30d2f75cb2d7035ee64ceefce5bb8344a5a2536730dae327ea7ed2a3a98fe3c1c119c254f4c9532132e568e5558152ba3e095cb21fb342c8b0907da3d1fb7ac7c7a1407bd7e5f314e8a650e5ba6e0a8838fba72bfe169a8f44e03c0dec6ad11a4a6407525894e371c8d7790c2fd8b8d96936f58e5397bbb93aa0142784721e6d5b1821f8ba5f851fe987ece58ce941e3def8512e461f915c009d134a34aeea133cd1854a3beff97863e7d944f90cd75d9ac4b52c9b53251527b537ec8a2420ec3a8248deed8c309bddcfc946580c4e1834cd77c3415d4e27f8b2280fc31f056b2dd1365582e5b8dfd233bc1007772634b1d3b6c154543fe608b6ebb3376cd2ea96b322954798019d6d6f6d88e1c2235f6f4a0a32bfa8bc1d6a7f7a7839a1e64b5508f59d10e08b40abb8ad0808f842a576034159a66e5a2603825067c7f5ad0ee2295090108b552ddfed8d2a8d6642b877d3fa1d8a8811246d8aca7e5dab47416ca89e1245f70c0d48d1c1742e6ea2ddf91a0cc1b338d28c0172749d24a9fc6d8a36d4aab95f713eb4807f2d7f503274fa26b7d213c6f4a9615828757db241938ff4852b80ad6a19a602b21a83d4f9704c7e3769a60f59c3a23dc04dc1a12e85f2be7c379857b439b509fae29b99403a1ecc7ed0dda3fd43c92a4f06f487f561bb0dae73e5ab0e0b3276e11b199e8616f600340eaf92cf1d7a1271197dab05fd3ffab8e1d5afc58210d79cd64a6d742837fa4b09170e03d25c6836c0a7cc7271c91334f857b6b617af57c9ed77ec45a7f268fb8d40218fb10696a1af32b05639fc46ae9472bd211a4718aa391517e0490e00b9b6206fb907cd52d42ca0d524ef74a4684a7de06be10c064d8d6c3cc865a185e5e684789d1da44a472a08e78a47880abec2d0aedf8e4707d946ef78565c1bcf316b235e30d2b1f167f2f66ae7b44cf886dfc25424840b8f6348ca9197410a58a26c224b074e8c0337eb63aaae1a26b6babc8aa0e13b2605689d55214181be3132917377deadf1e78fb34278a75f4c91f2dbc739458a63638abe62380a2204a64e4e90630cb8b5fdc25eb4d749f8db68f9d0f24cdfd6b3b2e5bedadff4f5ade98a97df6e421286246ee27de3de11f9e7bc6f527af9cbab0adafc2be12217f4aac6288ff9e0e3dfa63b643adde5478bb7bcd74fb06149c949bc678403f272e0d04c1be31e795fa7965308ac65524b92a379fe06e2cd33493a6cdf6f97ab32e789b73df33f7297b073f7bf428f43166369dc0a5b4470a6a1a07f92da34cec3af2cb5e661a68d8c29ad92ce0b93e095262f627ff9144c722b4f6f16abae5b39b1cd233e7192457ccb83ed4acb931f0f694a0540dd7f7e5a9188b8b645c0038699d1b42dc612751debc0ad6c1bcc42aa8ff0d3b8e5eb66dde38e3031fe1f67a83829e2294394c6968a79d51105d04ec385a6a30df30224e62de555a7eb270702a9b993d36c2cafd70a6f525ed8232d5deb77b06c113db0a203309606a5a1f4d458f624329d44b6af5c6c4b8c4cfff9a3c96f87a8f92a66af6729a3bc218491036456526e16d8955ddbb8f19d1c773b6ff74f864f01060478a35dfee57f89fd7b92297672b2f49fb0eee4bc60b4b043eb0c025278126d7af32eb4257799ab1dc0fb61bc6e8074ba6ec6c26991a2bef5efdf346e35583d2b53b25f09e219c726fcb9fce9875b995d61efb61e1eaa9a2fe7a46d97d26c78e73139f8333a78068f7e79df33e6d2b609f57babaaf9fea1c32626e4c0b8ed00b419bffc37432a1c31e80585223fa94f317239aa01e281e5eba4045e4e65f814ca3c976212c47b0bf8ec9f73f1d5f0ca773d41077ce9e1aa9a80656d6bab54e359506017f74b7552288e737e2c194cd6dedb093b53cc84ecf780c05bc3e9c4e11909a2934646886a9f8f5d558cc437e88242389a4eef2b5868eeb0736000273238ba9b92e396e0ccb2b0ffae80909b8cbc9868720a2aa2b6ca298e459330cbd298916682a857ec61856817be1b99b8459dcc87edeee535d5d388a48843a92ddf109ff717778140859a3f4d32aad3cfb49ddc9130cc869b9e158a482c472d539a2d7fd28a76bab1e13f0f891e0a1e1423e3584d379369d61400e6507ccfe798a77ce4ccb41fa00d75d6ca7d0b89baecc5f4c6022faa0b2720ad2f9fea2e7285ee296d6c77969bb35c39d86aa23e3047d86765b6a7dd62206ee60ab1c9c77ec810978d7d86a31ae40d57ec9a442c5f9e1a4caabc5ef211351996d0317e193b4719236a701015ba40f39555bb59044e2e1cb87983fa5eb8527af33695da75523c87da6af287e53958840769a1412a06001303217d0a6cc0ee12cafd4886a292755be66561b9930097ad6c13503189ae24c2c38b97c5a5125ae2e039fb1081ffe9d971557c4486bf45205050f9728273b6be023303b58d34636329d08d0b61b85ccd5c4feb4d27e5807f76c41b9522ca8c38bf06b9015deefaaff8fc26b14064e70235d4466d8787b59742160870c7c3fb56b747790d9c4045819a3ecf683f024059b79d85620126c8da515ac1554a851d948d1da7b5d3eaf9b25fbf0d813827db7390cf518f4aaf5ee47af85bca451eb0531d1490e01fe454f90119df62beb490c9efd65284276fd84d022f873239fd968ecd87602c3330eacd793d86b728703e714241f040304513f03e5288e91ca80caddd0de2401681d15c3f74f0d35ff680d3032d0f70b0352e45c51175b1703708912a10277bbf18a16964551b1473319d0aaaee5bf05d829b5c065d044f66df7668a77ea23bcab478b3cf0ae6bff5e985fc17a46369ee8e31df479d2bcac277bc1356270d05bd10d46465b6b2bc261fa76260d6cebe0c1e268cb70383d0dcc92e0fb299804b6ec2413876485c81e9a978ca98e499ec05be2b63a9ca53eac2bc5dd6f69bb98c2f4f9220d7d400f59c86146bda582f559d7ef31958b132e7b802a59d711dc3aa409e1e551af382503fce316584d42e6f01fa84796af08dd97942525b7061a7f75325dedd1b7845e17110a2cab5c0bb37e287613f15b4ca4f9633020c847c42f4dbe87495af1bf324fb546acf1d3b68b89b3df0d8c94e0947a2d322217e958074a459fbdf62d4b2e4ad8bc2f6628e51c71eede2c2e060125ce8aa1efedc30767d787fd0776c7bd29058c9d47bf2e063f9f59331aa7102dd68f90f65e51d0d9cad9e75bd407ac226256b218b4d6263cd78d88f69eba5278a2a3e788912f94c71189705df34539374d18a223b056a2b130208c62c1b2806406ca129fd74e5f46e81ce59c1d95cbe95119d478a4f2bd1f9635e25caf0b3885d13f1c8c7285b49d528b4260c5ccd50c13995b71bcb774cbc439c1144b7db3230d3ee25233086ab1080b036aee580551b6b704439bec6c73939f02e4931b0654d5ce5593119c4e243e54dd2e140f4fa61d2cb87dc3755a6e91889c5692838f85b5cec70e8741f18051dcb3e13479fe337359a267969a95fda81a7dbb26bb9151adbec9f4d3a5341124a91d2fe4560d4bd7165fc95f6080416ec9b87f7d9639732f1454751b0cd3d39c90c4df7cf62c0d4e0b428393d596474c683505610f53fcba9f451c46fbafe4159d28dc839675ac6361e48377832616c8ac1a4d319b9df8309d3d6d3b12406aea9fe0baea02ea326d9b7517b43c2663f20fe9aac68ab79ec9b85b8ea84d7669d7433f6796f5008da8ea32e1ed0d89577ba540f8e13172afd9587da52c3822e3a58e8338c490917c05e2299e24448cc42757b47e396bbc336bdab2b219498d049e10089dad247f3318d33de5fe8188dc89bd3134930f7c47d11c68ecd1cdbf4166b9954aa9db29a096db02e3663f387b5af1c109ca6e06f65bc09c961e36118cc3d49ae157de6c3dc8087c96267b4e9304ffab5a6b38b6a164d55084a6875a42ea34a75720f3b61445762fef76b2370c63d85306b3be178dc78c7852180c30ff28f11c1e542cb7d9a4455176e32fc56483cb4f6c445af6dfc27402fb2283252f32e71571df4e7dece44f54cf37ae4f6da082d0039b155506c6d1e3ce15867d99082c426765eb3cbb9a959b98f1e40fcf4808d56ea3bc21ade58ff92905c6a4f94e088f9d671e1ace73c20eedbeffe7e664905c7e71ac84973e915532b110355df9057bab68a23fb02dcd48c23723824f17a8091e28bccaf1f7b6b3225f185c5bf60693541b0c3980f351694eec6fa6696c4f0edc9c98a22e0efbc03f864e2470c6087abb29b41aa7a3f2efdd01c9359af48d58c6556357883ecf8fc1bda2a6559bbe06d59098f89805b1925da02ff00062db36f6a53d57e028fc5449f96f757bd63124f37600a0f7606519072e71ac630429f97fdb3199e54cfdbc30e51d225474374989b7bbd2e0183ce5961103d04777bd5a080519a89af722206ed482b200ea22bc99440c726ebf5d6b050a77515721cc53433bbd20702df38fffd909345f030a5bb50b8d0de302f96ede11911370d4e7b9a620ade3a9e9bfbed2725e7367c4c345e9f94024d4c021329aa0b4d4f3781209edffdc00246129018cb99762b3fe45aa75371cf8ced0160a755e1fff3d5de09630da9a70c1bf854b9c2bcda926bc5630aba21654a72e74ae5b73462161ba96809d870995a9fb8a45ad02152f2be89a99a159d6730ab21d75c47a549fb7316b3bcfb9ed149d5ff69409a6124f829fd0ea6a8cc027ac456550285c957ec6a14352371041e8e51807f352b73aa025e1aea5ceb867d3bde93ea325648224c96ef00c08524a4714d141465e8e1fd13b270bdbddf028cdcc7e646f38201f944d1704a90f7623d0b7781fe199baedcf01f1d93bbc1a0b57967ad6b63ceae013aae754d07bf4104903009b3d7bcc0ed80bfb87e1ce5c3d8bd200b5586048769d1192bd6dacfcc245d98489748882a74c4a01f9d238d4e2cc270a8c0fb05e4943c32b34af4375841fc5694cc1492de0ecf5e9fcd67c0f6969ea8517f4e91ff4ae984be82fa180d95082316a914511c99cadb5c655bdda21bfd1384ffd583833cde04f5288e0fab4da87ce7a716d658698f148bc09f2265901f2318ccd1bdf43ece593e281c27ec432e739ed8ed1ae9222312fe3d69a6a8cca4c2068b540a58d4cdc19862aef3fd013ef99c61e1e9a83fe541ca005582a6de48daf8ccdcfddc5367045cab7a406d96a2089a6134914dd0ecf4c7315a9807060884581637fa780df0e5c4578da9a1011f7ad37e495c6111ea561f1ba167b6f0c952dfe30c5c06c3ab73720098b079562b67b00730807e1e294abdb01947f4be7cfb22fb691289c27c2d496e317dfe904d89eabd3b912742204a1f49dc2cd03be91406303145f73f0fd6569a9d01711fae3b8e10d98e4b84296513da55942fe4e46547a3a37b80e8934fe19dd0cff86a326ac32bd8532c2a2caa305851d8383d83033f441f18a24b8ce0cc3017b8e850874dee1b8b96022d5c0dc4ad16985689528767c69eebf8c435886b8f46775267e4a138c794fb8f6ed056b1bc7973e087c91431a5f1402fc2e93295c2e95d4ef76d6666520364674bfb923de96886bbfb416797dc5d7d75478847e50523fa3ee030684b5309c2cd6f541c92697439b09cb967d29796f38afcc01441d52965c0b369e6da53703712fdb781a1b2dbad48fd292b5fe6381f365d96384f3ee4a70c2f5c5f421930f130e5694c40affe5951da227ea29061952e00e9b7978b5c058d8857b2aa0cfe90a2495aad0c104f4052062ac2c24f7360def9eafc7913b05f0927056f62bb321184c3737888d2403e11d33fd141b14e368e7c1b00c01e99ed1b44cecd6ec62d40b994296d7cd540dda3bc7368b0e5643b20ed317000dc45d5970e4be1e55e52ea04115f14106346b534fc36d626a28122062716e4fc31bbaaa3a99004f75616dd4bab9dea6c5ec177c776086ccde8055c58bb317cdc0ef717088985b51fd75ec5809b880209afd09de34ee758a68ebf226a1e722df5f3d98edf0ff69377c7c3a1a1371f806bbd4545c46bd6749b5b1065d0c3e808257afa497084bd66d170bb62e17035138f8fb934d51b623f19afcb900a73610033529c121f80e4dd90a782d2a9d386b27642a6b44dec16cd9402d7ef138c6ee2b8bfad8bcd0fbef14b4e54300ecc11b81555270533546809fba2fdf1b0d3622b140dfe15cdbd12c0c76601c581fd416fb9cafacb1d97f146ebc2996c941ce2be651eb4d9a0a543b24c2e633fa14ef25ca6c14fbec91e048b13fabfe6303a6639470f44d359f5c8e4bde4be38dbc545e209b7fa49ed89de52454f9451ce4bd115b32916171d74aee359a29a79402c6e740669b8f97f85711a6341d8a44c453caa4ebedaedaceba96dbd67744ab2fd6e6d44a02ea14cd793aca03cad18941b570d4ecde0bca639d5e7b21b7fffa9c6fc8d9f55e4e96826f6ee38a6a7d5b9d1ad3245f2452d8a3e92bb617bf1178f7fe9521804cfbaf3e5019b86d58bc2e70462e6d6047d94b424902e7adb7535f32ae1d2be2ad59deda7d1dcfaee1c48e255b2b474f8410daf76ffe307a42a0b0f4d7eeb76e07206ff7296721ef673104fe3490fdc901393e31eb3b6e3ff8e534700ce8692c27dd9d4f2bafb40fa36d56249305509e8911d4fb057cb00112e8ad24b7a9f0c2ec338ee79fbd262e4278d066123fe4c66d243e469097fac9bade9977843c337d0735e82e3d6acb8675357b052008703fa9950f566ce020c9b5c73adbfc4a2185c42c0a73437594e422bb8a81cc2d85987f81f027546dbacbdf856cb0f7cdd5dbd6f42c6f443ccfe0d76f45b2f66468352e2bde3faac7334af4cb7b2a87812d8ec32332167a2029091a51c10b952db25d2617d5945f6933c82e5d0d2c28a0e010a94418341283be30a99638e710351abf9a8119ba8870ed288e3511c2b3e3762480bb6c99adac42f1c0306113fe6b10e891c03db8488566ee9ffb31a1d95095366572cc6d7a3548b9150e6bc5c51c26d4a923b15e9116d4df775043fb5851ddbaf02c78f93389a82fde640982ece19d4a44e14c93284a6fbe1301c33a226a8f683d9704e4718f3cd910d4ffdeab697895c119fb469dea8f0e756244c1196a4d02f7931ced3afa0ec4ef1b31007695a89b1583d6716d2eec1c4f00eb0abd2010df5ef44b622c1e896ecd98937b9bec91ad67689bf58595236a143b34a602f6a69de39c342c2993838f86080db4d75ddd519755066cab4b6128a986d7f512f7cbf3f452367e844382e45c5d8372b49d17a49899d15ac28886deb15a25e5cf8ae10f8a2771f9541b819686a4bdc6be3d2b2695f7e52a7d6314f70bdc7152ab974f83bf74ec94d36b5ff2065cd09ec33eb1d4923a211fc68d4c7f53fc3c11766adbaa442f60f88aa3868fad5d70f751520264707d98e48f780abe83c8c3e51acc73de78b406138cb440b45f4d26bc9d032b64b28ada225e11dfbfb1ec8935f95828e29aa232098d640673eaa6a1e5a7717917734b889e311de0556ea887d2d1e864d84d338d67b3a85bc85d6306dea69d7d664290a3c9f4f5562db143522c118693f6ce76a339efd5cae8a137efa40b8b174ee7067c98165a82175a915f44abd4009e74a12b4e3499b88f8bd27a88f83aac03cfa854d30e8c146fa28a704de3ab3d074d32b8869db1dca0108608932d8e09dc071066d7e485bab706c95c9df8c4e80310fb64e7b0b85bb9a0c4968910704c936b82475094d9d2058bcdddd0193c6d48732ca7be813fd414d6b5a3b2bab0457963653008d6a26b7bd2370ed50dc85b11eb7ca063ea7a4d43aea9ac015f2e361f413ebf18bcc74c37988044407ab2f9dc46b66b04580d71b7fd2046fffd73e1e749afccde097a6c4d79dfc4ea65840b1b386048785266124b8e83c25c856dd9ed361029659de8c97d0bb3f7d0f75f8a911c4b5e9f7e9edd12ec57553b4d044967bcf6c2cf604a38dc13f16108c7144e29c08e59ebe8a891beebd01bb8380cfd0aea6a03f8622be2d2ae45d445147fcf330f0d371012fcf52ff364c3f8985d3d082ea80554460d9e070bac71e7068ec96fff0dc924137ef7ec48d6bf42772a20725b8839ab43c44a58ee5547457763f72f9e3613d43f9e1f0a5a53df3993141b53fb5789ccbcfe971a194e4d5311f093c61065c2c265ff85d94e46f226df0e88c5627715b97dde8892096dac4e01254e52339600004abe151f5627682a7b7557a0697682fbbe376e3e3e8aaab760270e700a4dee5ed9dc7ebd4b167ed33d8203452df9e95e35b52ba57b8896fb812e6eda8c7d2894d50380731adede094ad54c82b941af87f1f4b57284433f481d64eda649372ba09098ea3c8fbb6c24de67ea05ce1cbfbcedfeee012b2d62ccb5d48581c5d26ce30c8a7d04384496253d80d10ba29f1e3dbc272506043f68a4f8d13e73c49817ea2551abb2a37772ab070ea4d7a1612672b550a881bc3ea3477e251f840a2fd8dcf5c6411766b6787eafa80f047f9a13443efe5f5d4695effb091289244b3a1c22b58e43fda8224aa6232ca882c484fbfc9dda5cd51b629c62359a1f7e60fa3f455d1a00c8152f34c71d853dd9a78c0055895c6cfc81bf5c4d25dd8fa0708cfcd928fabde140d16b6c226b107695140360b358dbef23c67e93d2578803560cffac10574bb79fb95435ef365b03be9fb57c7aaaa24928e00a5d7a0635d20952732464bf4498cbf4b8464a86736980d5a8c0339450966f4f764d750ca2a5e069f63689fa661fbba542407ee71e601f93950103ec28b42e606e312da55b6e6829ce0a069549b46ba97e8e836d942fe116bad238ef74c20fddd0c62e6693024e0547bf9d1ece834b7b38ce05a97a0d051ce86a04f79cfdb8d984f685c33b5fd38b82b82aa66eddb018feb9f5bb38932c17b1d49966dceac51acfb31a07aa00627d1557368f7cd5f66063827089ae6955eeba998ecc67de24f9eeacb84bb6005ec40936cd818a12767c1448e11c8abca82d94da9b05c3daef91ed58908d4376ea2dc9af32f2167e1721a73a739d1a1a5777c9459d5f08e5a03ba86f3c891a8ec6795c9172982d8360021971608434af4d1b5844933a34c770ea77aeeab864bcba3574afce3aa15b4f723594cb546cda230aa8c02c166ec1e46de3c288cd7081f445f723c6cff229b8067049611460a9e7022682726c064a27e3fb6cb3f81af51fadadc8d5ffd6ed8c83caee32b913d0afbd815bd68a06682048d2a712ab522a9fb6a3035972f2cbdf10ca3f7a956cdacce20dc0857002868db1284f559eac7d38a817e472a3c244326687e24e17ab1f584576b020c7beea8f1c0b6559e6bd04ce3f5f7e39236d23a39fdc97478bf5ad3e1994bf8a28dddb4c762490e447bd7b608a0a079dbf902e57e33be48b7eec484f422221ae4945d832dc3a533a2a590652aec12f00ace89551eb23204f1fe7fa70a83c9425421b2afab03f4c57815b47c7648f4dfc56ef0d999b08c886536d96de6452506ebd286d72df1e8502a56ef86c27100167555b6a73eaa98044a452ebc8d8963002f436d57ad6468e5456c3b157b733a009ad90008a357264b08495a73b5b8facba9e2fc82b6b38303a4ca75f4041e6c8cf8e17be0c7eb0748ba8d506fffc17dfb1668dbeda0ee2e335c77dbac05750d75ceee70129a668b752be6d5058f5462621b5ca3a3fd6dadc9f8f522c739e55fc99ea7c097d1b481bbe2e07d23dee3581e65e80c96ca7911d4e2f7550487dd9d15a2df50a409bf60401f4db3b1b8657d854906c3330eb5ed6a626aef28149862ad9435742de90c29302e553994636ae5df3164a7a660e352dcdd24d10bca97fd44dccc8cce76095793a2bcf8e7d849deffee64a00a38d0adf796349af85bca80995bffd3a5dec8a01ee33475364f8dc2cd6d0be02da296d6179e112a10c262b8b481fb91041be478d1af891264f14df7f61fe44566acf5ad94a6a291aad9c7a9c35fd6c78a15438aee29f392c2b3eb25b10efe1bf2ad6ba7d9559436f295c62a319d0a2641bc39c25910301bdd9dc0bfc5615c0a808f0e44cb8d9c6ebbf61be8373570a2efeea2daac1e082bc2c54e26d43e6ce0351a802bec91ce91dd2197c1a397bbf9f5a3c55008f49ff951e0d307a00323aa81fba2359af2c81af2a7412b9bf0467c3e96836c367dd33e1f8b4e3b00b72444672f522b0f167550f5eb9aa11af07a1c90e4e90e702b14821bec3acb241cf24c47147a029377d61ba33bcfda71367b3edb2a89c0f24517b2fb85068f586cefb90fb9a52032993e403ba1239e63df8fca640d10c15bd7eb09d2b6acb9c6f4edf0aba9ea96ea948fe5c307cbba2baa13c95b9ccef7bed39ebf78ff46596e55b4c69685cb95112640b0e9c34afd5b7c8bb4d50fb5a9f405818d55610f2c9819af4e00e237cdfad0cce0d74d8350155d7dcecd606d8accbebd19f2cb4b0e0fc914eda58cdeff40abf6b92636b069c0a50ba78b614791a6cf43c81ab3c6bbfa2ea40329ecde5de7e3a1470b3f78323cc408dc767aae7366bd94e51fd5c7ecab2c5e82490a1ec17ad687f0cb8175192985618b2fedf6dc464657969c8693c2711c4a1181686e81c6ad59639a6ee15cbc344d9db76f7c430d793345ac87ed1500e8aac2b54a5400a0a7d4493addee60dcd03a0c10cf4b4bf57d4b1471164396f7e27ee2c5879eef59f123ac44346c6028074cca24e5f6465928811d2f857a7d683eeb31bdfd7b20a8d7035f993ac883cec0f323ab3e7f5ddb8db646d32e3c22431896f65571f39814cd5d0639d7127608951434cb8625fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
