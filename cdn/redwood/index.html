<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e56fd8f34ee6dc21e65d315a168c737fc4fb09ee08ac4415dfb4291650d57c19d8c2bc6d7a05a0e09979bbfd2e3ad4dc006a60849208b5bc9ee43c152d93cb765eb2558bc4d740f3327993f9a5ba80d652e6616c94167cfd6849f48cf42e4d524a23ac3f4e1cf7684aa21b084d61c558cba21c86a6241e25a5188e4e6e7cbea4c56c9a0b2806bab154ca8f8c603b6c967621152cf00e564ba7e38b238b6d6603bc5112098f299995903fc0356f7edb0331d5ba13283a27971cacbc5df9119e460adf5469f6d820f20895c6f995396784e3a55b17259a30466e63f5799cb3077563ebd5f8e29f0a26e59709cbbf9a4bb1c4632adf5396647e837e0d9bb62b7ec393bf1dbf26cad95fa472c910c201c54b6abbf7bf3e4fdb3d952fb5409a0077c8a3c2f5aee269e53f305ff89da07616f24f79a2b55a3794ff16ff44d1f283f973e69dfa84b4063345ceec84a6fdc0e4b8f38d05395bcedae9f76b42edcd017169b8b7e56d505d8c9d6480697dbf38ba0bcd2e5e81f2a9cbe3aa4c63fbcd76bbd500be85dc4f30f03a98eba921f27e099e697e937bfc3a941ae4e1f25c9910dc10c806fb483d7b2c2cff4b07fc9090a749150f64d12fd742c643858bf8bbef47acabd52546ad50b8828f8bc9a1f7dfadb70524278895ab83801f8987983e9be7a00467b899ea2930b36f4330226215e356065eb05c80ee7d47a1308417cdb49d26d387116a345f3bfa98b74081ba956ad9eba9a6991d269f14a177cbd3eb550baef5283581516daa1cd30fc0c78eeb86b730a4ab386ee06eecc01d8ad85c1d05f33a6dc8d909543dc07410c29e7fed615dd22cdce6d5f20ab32723fe17466dc8c7c36084566e0d14eed2c237970fc44f7165a7a0bc0217da98afda2ca7342faad16121987ee558754e1c8d7c3f5b83d2bbfc7feeda0df59aa09657c60d1a9b1159032a5074b13ba28a37258d050bb910a006952d2752ab6582771f11508f0696938c81ce9d536f2f87fab54e8c800bafd8494463aefc8242cc374adff2fc9a93000b382d5a7bcf3f4218bbbe1c98b64691fce28ebb9ebe07b7bd4629bdb44d401d3ee6a41a33189223ed04086cfd04b8a10c02c068922ae43b76216c11913c9eb75263f9f1c1795facb307fce1f4834f943fd3c9272553b0ce487324065577357e123ad5653d52b30acc06bd6c87870add3e614501bcd8660a6329d8f0aa7c09a8201f3ca139bc97d82237696e0653e14b3150dfecc15539ba466a3d7c8e782d45ef12ae725fa30a587cad0b3922aba6e46ceda1a786bf327d21a9a7db051a1153de04c9daee3749d64f871b9913c0db8e6b256920697fe9649689ab8a46165023b528032bdc06b7df49c543c7487c9523fee03021c00b766bcf5e021c438c7a8eacd393f4ad647056b0b8fe8864a1a05274c39cf686f891195d46c0c27737debff498c9c9347f124b886e63f43182b10922b4bb5c52d86069f94e4ac4a5529e83df6b6f21035b0d61bad291a7336a67dbeb80f66ae4e0df4cafb5a6c3bab4b61f893fa571d972ed1c0c51edceb88d6191b0086c7b83036dca31285c3cd007147add60b0227973c537af514fe4002d98e18cd7c3f8ec9987740cb7ee2e9e13bbf64df1a0b8e6c00c81297325772d8fb80e0068945455f55b8ea5856e4fd68f3ac309d0528c2584e621f161788735323058df4a481f77cb3baf06ce474ef777dc0b5c803a0ed0f538c1ebf3af7ba071b2705bde1be9da067528e9687a37e95e08a6cd5002befc987ca39eacdb1a90affc144092ffead8b92df7349b3bb00217ba887a1e5764ad17876da786c9f49a4482cb45873f7aabf4f1508524dbe31437bc85df7d05406b325b64c863e004827be2997a36c6903deb6e70b1a232bb1e393cfa3f9c6dabc65424a22b94ac22c45266ea1aac7fa0ea0b848e40b61bda6858b3f82d95d2620f7be985c1a74bcb4d56578a680ffabbcdcad014cc82a2c027b56668bb2293f95ce3fc7e0febdd4e1eaf02ef61b399cbf5c9278b419aaba63dbc71aa59a16fafef28e6d95fcca15d2e8397518d8edcc2a4a852c803eed758ff6343af01c062cc2dd36ee318210539d77a1b050ebbf1467b30c90eb66cd157a4d2f13e40d9af8715f0080cab5b084fed5ef5ba2ea0c1fe34ab4d2711e9b046a62961b0b2c590891125078024abc86cd033d42588df5e629a01bdd87f4032f8e8febf8951f385ada14b1c0769e9ad2608297aab97f8383bd5762c4358a66e1ab8a0709406d3dae2bcc4d484e3629a90f15ee8031cad0b81692a5e2d1e804e61d03423e49024717dc5b7c8ff7b7778aced910f5a19f444acc8157e9eb4e1a97478de92021415ee426e3037818e92bafc3d98cc3295c3505ebcda26be22558a267135eee2d3b70f3a7e407e91e47d7d56a78dae167627da0d8a095c93909bdea078ba999d3293f153d7b0b07ff4f307045fc12d9854b4e52d63ae318dc3c7b0211978da5883eaf32738336c004f89bcf826a4fe26ffcc56792697bf179a059f550e0bf79ef307d1e1c5cc9b5ca995c8ec99164d385af5a92b472fdb1e03e06d2beb74e96452cf40871a9ed8e8e0aa7619b4569ac832258d1d755b15792e1f408be34b4eb8928e78a886e3de916609326a2e612edb52b84b7e1e70a155ab5fa4b3ab54d2b191926c7ef8b65e5291156f5eec0757dcd95ecd688a09a4d325e7ec53b28631a5304ca7db1b915a4babd0cebe0ea7c3bbd3f0d66dda88b3869e395686b84f5bee494dcc8bb5e9de5a54f92467cbb9956ddcf737f4fc4a87c2f1affbac3704d799928c650665ea67471d283a9be57f2320fa617de5ec6cd6eca50e2bde28cd3b88bc77fd648eda56345d7eb1bec67f1d47d28d1e365da51aee9383498384e0adcf1dce346063e10614250839dbb7bcacfe44681b277b83a130c7ee435be6ad8f25fc635b941b090d6d78df7a1baeacfc4ae4e15aa16c29179e9d36c4d3a71937c9bc1e789173017651cbe47c0fa2d9234812de537aac01879d97519faf91cc9d0c06098acc24e4cf54b2fd7b3066efc545fd2e57e8908e8c1983010d530becddfdab7c32bc981c92160466619f7fffd817315a3c9f254371659e8a234cee5643fa9bde5b246812fe5b9b6931ebad140e125a703d31387cd9d462dbfdd437e386c177151a48b0849153c3789a55bbd888301b8294c1f129dcb7c2e3e6035a87a278ac81752a73b4f8fbb38b85e5a3dad6ac7ccf18c5e24fe31a14d0588cf8709f429078bb34041e18b1bc1beed55f9d7674a41b746c601e0533abdba6c5e3519c2f26c7d639c9a5dafc0b821f91adcce4fe69dbbd72c06889d4cf5dd326d21ac2c1b43b83afa1973b03611ef8f214c7ac83f49b70f194131fcb17b01efc6c21964f615c79e631ea023364bfefb5646a964cd3082c24f10d1d18941db2da00cc0d787f50c2a33cf747b20907d2a5986ae893e8550ec63dc8cf6a0e233ac110e86654b872c7f73b55086cd5b0c60af4a6f33dda1963f826717cd1e1ae20f3f1e58a2a23fa33773e7c3a94eb6c2140ba83a7ec658cb885197f97db9c05772e91275d4d83dddd190364a4cfb876c6cb9ae69a8fce5160d211849426e0a8f0fa2c8c8f6fae1409cf4fb7830e7a9a902e5695967dd7b488a60321bcb382010fe0b097d3bdbc5f1842e0140e95b6d77c8e3a09e730c57d152e32b1812bc5d53b036d88dfff2b2a67c50f8f6d4b8cfc96f324382a7cb25eb1bbd539276f45eee2e5be97080c64e6248dd1009e14a0b00860c7288bcb931d01d900aa4adfc88766ad9183f17875e34349628ff9a45b955926c46093c4350f190d40c8a65fbd12485af49b1f6e60252198ff1deafffe041faca104b86c67475827a2343ba7afc3f4b9b71f8fa2ad9d060bdd0251c0a8982f6295db80a19c68a6edd633ee8bff44e0b8cd0d188cda8d1b1b08f5ae77c8db50bd7f432ae2f2ae7dac511a54540dcb21e4f841e853785c5129c7f250bca4179754265ee0d04e05de535df7195453133acc96e29299cbd5099cb934faf8c868f21af185fe9ab605eb27a8c6bd3a6cb312f468d0123fe3fe7950ad7ace1cd79419ab378795c4907e80b38a55e9aae6a38fd04cac57fa283bfb5016698ad4cfccf50dab5b2fd2e70461577f452ae1110daf2b8fed762d1571c582d879cb09117c277e582d9c5eb515f1d0299c7941f4651ea082a5cb2d068233a7459c83955bb6fac6013b73e8fefa5552905a098ebfc1a5eed8331da782a67349b3a87432513e95cf884aaf3387e325a58d1b1d9af1253a3d3229f43d77e0fbc3a57db3866cb17dd8282138cb52eabd51878a20ee3a6aa244f98c654dbfd2a67217524db0b87b804ad19f7e0bb03818e50460e69521e30d702117bb63c4a6867b2bcbdc29c291f7dee89cf0548e0d5cc486caece11442231f472c1998fc305beaa47fdce98eebb1aeaf3235e544f97057fa4920c0de3047b3a7ba51a66b11ba7839d8dbb47b3c5bf078bde7f5fd60c72dd1142f44ffe5eb83abb9afc550d4953882bc792d47c8553a023a8c6ec7e33d62a51a9c623359536e0c88ee6a75628f391d70bde0ea8ec3eae9e6a87b8d3fbe98d1fcb38c45f233dfdcc9ab6f134f77da6979b5811082e263374d9b953d7e6e274c25b3c1f702442a5c9531bdc4aa581964ab4e8828d63b25219a96912ea651661781cdb82dc33b973d2acda689afc69cb9e319f4ac034869398e6c1e9409ef9c45f273bc6bd5c6fd546e33881b618aeea761f431598bc4de35ec34e59546060626b1f36a5e38a3226ea52ac64633b286406106dcd2bcb275da34027937fdb6360a684c3d1df4b858e4d3045a38f80b4907a8bb9c4b26c0d207f31ee83ba6e23b381a462e6a42866ec27b9c0c1acfb3a5050484d983aa652d062a602283006ee1231997697afef22dca766613468673b3e7645c27f33f041dadddeed508ee23c9a923d8e8fa2721b3c0fe4f495b6ef37156babdfe0f3a9282e606b3d7c1df05782c2c38ee5d1f80a22a583ba9a27d8d01e1b25daf21931d1377c8f6f9a6a5b74637f814f0efee916be7034108ed555be109b1f30f736b5a11fe80983f13420d9fea8a106cabeda3c1daf3d91855ad5887975ed6b1cb778f52861d8416aaf7e89ab12660a06272bc6d660da271366673b2d900668c05c6c85d48a64daa5257c85bdc6bba9529753281aaddfdb149afceae4fc706be0a4ca0e63cffb72f61a3523439eaa9c73ad952112b76e0381b2797aefcf88d8016b00c94e654684c6891f3e9c767eaf46a93f69b62e4f02870e83f4bd8fabf73c7199cf85194bbe15441557e1fd26f3cbdf46473811df7a960a198c7fa48d312a9fe0400bbd16240bcc8f7eaa3c0338b5b6252985fda9b774c2eba007e513000cc83f20be7ab97004716f157422eca59688ea90c526de18dc26771261df37cc45692ce188c8ea1b4b4f5e518033e9c1825e2fd496a6a81e2bd0336d2326b2b8e28a99310c0fe54cd574eb9024205114c004025f0e9769f439ab0a625f06eb2683d7e510ef7056eb0bbef78f0f6d054f47c3c35b0397cff38a4ce0e29f75f3c8d04dfbde9b223c0dc2df322a88c9fb351074c913b4cad85d5c88cc6c661c01da8da98c7fd547dd67380249f0551967db193599f9e62b5508806e3c19248fae42563acef7c4174f0d732ebe3a0c890cfb669a1776503db30fc47af02e2c42b3548a4463d6b6b1a88cd3121cb6b6ce07fae9d5cf77dd48efd9dc0489700d1cac74d2ecf80d7b95aba6874ef61ca9c17663d67a4b8859322e9a2cdafd9fdb64f6b5ac8f2c5ed9384e423131393f68d5acef0984ae24c6f40da263360f390bf7727bd2c488a2bf40547f2346ed0782975b3bfb2f702cef12e4abb07171153bbd50e44767f07319bdf8267c76413ef3b2e657d98cd10ade6f14ddd70b6b8dbd384ea6c4605db62a1ba3739f870cb22bb78d47c4e94ad46b95adbe69eacaccadfa5dff190a3f1d7f865d09ba772fb67d7b125401407a9837d86cc2c2cba73eef6fb4061fe41c3347417a5475de3d9bb8e30c252671b829aa0f7eaf71e4725cf3e3336831c693e8dcefe0f0e489d5c62cbcd6881ca7f609571ac2bc5aae428b6232f834c6fd21ce7c0cd1333673b239975a914f685951a11d7729e877df3c60a87f73f0ba8cedf97394e757f9682037245f7ad72e44578bc49c1509be3cdfc9d4c790d33e96f64f89ceaad45294597ecf80f1318bfc763baa26a545c2a358e9a0e825fdd9eabac6e319dbf3e7b666a8132de38aef9e37584edfb23bea5d7d6b9c92a59505072f1c183483c6d0442d788248b859c8eff2ca24065462216694e63cb9017a75facdb506bff44efcf56e03d40aaacb11c092843bf0d523fdde6356fd611219eb600beb517eb490362294c8990236136c8b0ef4c4c442f932296024e59535323c7e3dad7f13d10d79e58ef28fb44777ba18a253250b2bc694cf7d03a42bc03bd39fd8addc7767a9d14e0a60bffc71c4b501127f09a2948e66e2521f95c54edc2b7e74a54779048101b3b238156c9f8e8daf4b7ebef3b6c34d19175eab73d028d8ba129dd6311b4e9e3ddc953c307476c997661b67d3c34d660bd6e12649848837954dd15bf2f4f5012166f02aa751ed32876ab2cc2088ef2b0cc9d116f67cf249a0ab27c822ce8d0aafe7eb60c311aa61dcc5c493b92e17c2fc3ce25bf5fa5015785d2268af1ab0c672c4cb597dbc3f2adf24bbdbae33a03b59dbf0e0e1d84ffb8354d906bf35449634b5de8ea63005a65258cfbf9f5ec5f858a68228f39052ed5af73827425f08cc5d3ce10c9b9224ad4f4f6a031940baa91aa4db876b407be3e7656988c4aa525fbc37c6a0f4902fe3869ba91d160e040f36520582cdf48cf0ec589f306ab052f32af4a69c1395dc19045d0358cf946ed67491507f47f69d0af0c2d98944a33bb7a8fcd4f437a77c276de584f3ccfc11f9f95524943c75d28fc953035d8feb7689065a8271147a5b7da558ff519dcb0b514d088de7f3d4f0f4c7580e21f03cc7679f25b13a185e06dc09a00d545b0beac6edaff2b7c1a83ea18e3d3d8439b3bc2e3c951cc274df521dd11e5041e0fb14658174e80391c43119f896465ae819ca5676ff80e34e724556fa935f543e84e728436121e7f3e6df6569f94f17a6b115fa825fc9e3a0927044932c0c854c7879dd0f7ec5d764e5965719c0b7954f818cca8aff24444dc7cca3cad90d86f09448576d7953146f037e1e773f4d6da68084e4c100b217b783625f6dc621ec8132941dfc7ebc9100189ce362d9e81d6cc9186df7000819195760758640a9f985a5356e95d6873aeeebef63f06ba46978c686243f47b57bdd576b1f30e30aa233131d8dd2a3985c9db8b2048090941b2198431e1a7c79568d5dcee5134e8f640c449dd9f3b9affafc7946ec09c104166481d1686f81f9c7c4eea9e8d6d9bec7aaf672588eb37789099c6a6a5acc993a4dfff08bdc6e25ff1f420eccf5be2a6a2319cb6e3826625f3be9d2955cbc92979b5d1a8eda4c4ba5b2d85eaf06a43b629b748344f08a41801d9aede3bac3e2d99bc36a9f6663b1a950314fa853776f21b746d09af65ff079115299619c90a3c4539b21fbadcf1d704a4289b6c7584fac5003cbb01bc1f3f0905ac9f82d3f28904dac45840c124c76d2fb17d303fb9e662ab3cbc190ce407c3f0cc0eedb5da8cbb7b33b052c9bc757b4d0c4888b4041c6704fbba3040d68348aaaec8b14a12331787a45d90cebdf9eb2b2bdfb568bda04c0f80b6282549f745e949f8cabe93f7a96badcdb6b04860d6ffdec6dfa788d51256c58189efa3cc72f2d64af30da9b8084ad0236a4a758263064941f29664bfed21a2d8a7b72847cb02b639029c9f95d9fc00004eb4748193a2495926b4701762e5a68d1e5111539de9aa2d5b6e6edd937c71cb4089a4a7cd30e14e620262b3f0113dee084314478b16ff0d19f4fa70a5ae94221d78d05039ff5325e13e887507bf62caaa41406da5c44d9fe1ec8d245232507483646016228fe92ead735846a253fdcf47dfad3e047b26f1bce0f4efc16cd249984104d9fb18d010f35e0a7ead0d9281a87a9fad84149973597887dd143ec6b3e742511a5a81674d63e9883cd6641f11ff6a48e3e8562f19e0f2375ce92874b754dd97aeffc6173237fcbbd4efe38d27343356c4f378171a66150033efc3e508594afd79fdc3357eaae9110c1b4dc26d8231a11622090ae07a6e6399c9000ce31fe9574175b935309e6bcd250c8f1c861d7c233aa7cda3b6ea00f921860a26e802646a5a7244b524049c19b294e24ad7ef2b151b78732c3257989b5053d2b4a662ccef27de9c12a7d7dfc09f3ad757e6efe2c116b0b355dcc4074dd31d698e820cb0e0071764ea89c0ae2a1727d3819e33843106d96c5d0127198abcaae0d9adbd6ade247a83ed15acdd3c49b9da66e0e0a8151474bb7af9bf7997bb8a900ee5f68fb7265f6d89455327d4bac1721963d1871de076ae379ecb31c1bc885e9ead97458e491e64d8d94b5ffcd07b4247c62e6c31dfac21e714692f1c2cf6d9b539290976d738f4b671e44092291d460b211f7165568685aa7d3bfff178819863d99fff2e8826ecbcc7c0d20084ae737b8dc27324bb60421df285efb8185a2d98a5c1f738c1fd01f774933fadebfb89c0e6c158b4d66e2c18d735f117d4720206efcdf9df51f1c063ec3607cb838b0ea9e0f26af5b5e4dc52461fb1535dd830b839535f47c3bcd4ab52461c406158b513495e623395a50a9755d833ed0522707e0f26913d431117dee9cef81219a7c15e96ee1bf76844d943af2a69c6f7705f7104bc76f9540fc8af63ee4a003935e250619e915d093c9f156968621859e6a6c4a8c8af248d0d17013dd05cc2d6ccbb565b170c8b47057958ee848f53362b7aa915edc292fbae1ef3f784c8c608d960e0a657e6e0da51321424e169b11d047de375e475e6d964427ff1da2cd0b74924abc2a3d85c5b91c61ce1cedd3dd6e51d1039f6eeae6dbf9b975ca326d8cf39b9d91ff46ac3a7866291fa08cbec2a2a39c4f12595096229f73410f622655f7f70d8aefe8ed78af3373f2e362db2f669d93523d38d5099f2f70bd2fd98de510dc0bfdfe22e2b43df3f4a5afb2638409c8075c7efe4c5b3f860707d2a8e69ad80a58be8dcb7d55ee9538285dd58946acc665be7bf6e8ebc110fb5b4266053c9d8c8324215a6f3db3fa752fc3f0ad966d8417aa5f70a45841f6e1542012d913584a75b2ad6a5198a8d24540f82b9be02cad399838f3e0030da9b6b05af52e37c5dfd4d3e245857366d45c2e811273447080cd1ce0e8772048381518c4ab65a5b9888beb8bbf611fdf08646c64343bc595910b3e8ab735e1e82d2333f0779eaab9c0cbdb26e536d89791d6d91513e4626cbf64b567c575998442f6809e84edc2d6bf5d4896eb7699143ce79963caddbdcc8d96cf1ae8c4b38f9008b7d96862c17fbf2e8b455b9460e7cbd8e40bafe2ca54f2ffb1008f18852e5b154663a12a74aa2974d8908f69136366a1aeb8fe739ac8339142bf2a1d56ef9159f33b16ad6bbae4eaa9a1875adb265095e7eac27e16f80caa10cdc72965cf211c61a04dadef998d8fe073d9d71cf0e51a6bf03c9321f28340e27c763813b04eb378004181afd8ed4d65479ed2abe68cbec401ab614165dae72338421ee5941b0c93662ac636053834ebfdba16c1bddce7f0749e534a04e2b6b053f8a1ffa1c84ab6adc15c7236e1dd0e6ded69ff48e3c9791101a324d41ca33472b761f94d414536963740346a41d5bc46aaac113ab8867fc4e3674fbbfcff19b068bfd59ad64734865d60bdb698621b6af4f08b29640b412348197fd822e135a55263fd69370c3ecfffe11e36bb7419c1c21bc744ca421c5a46cabddb95ca11f6fdd24e6b6f69867eecc218858ac6439523b178764a6e71f40672081d59fc7087961caae2d83711fd0747bac595f4d1355da6f2cd896865e12a42d63ea6d55d445d82d090aaaf1429aa7a19609377704579329a4e3f64556574ac7bff679c13edf879a26b1bd7cac5f25b6108dfcdc73413d3e4d61510c05d8d20d518dec335042a8d07134692687bae6d1599e932b1434288128b558364e1a2342f295deac14b5578aded06e43bda454cd554e34f786ac9835b1636957ed3cae00c4f214e5ba9556fb349c8c69d530701231c3f2e7244695a79ec431aabe8bffd36de08664ff357ef6098e5018b19fb96abadb74a8efcadf1e616dcd92e283c68fb04b5d12d1b42c04b2b6bbb97cd04c5d5a6ed0ac2ee45332a1811820771fce19b929c54656726139fa3dd261c2fb43452885d1140e65f6a7849cc9a49bde1118c5cd7ffd10d0925b72fb95fe1a33b8cea56f5e888245e0e98ab1c61d54fbea52ad47327aafd8aecfed6136793c371cc462b8b9f173e78c9f07f94e79451810bf2a091d2db9987cac748509ff513d7326a8c512733eb87e162b2d899bd9525b8f874c35e97b59c07a84b72b2bedaf8ca46935719e55d32b7dbcd3e056a077dd0efb5fbb2a9545beb0cc3acb5adaec63763bfa4ff94217eab9584b0770e0c0544b017938b106471e17549097994e71ea765e8c8c8d765506c90490d4004c7a9f867d3bc31b90f9b9060de5d9a86edca08c8dcec22e6dea8f95d06c32d1729923f4790c7ed3c6bc7663c14084546c9543560e5fc77acfdd133fc3bdec7b079cd7c5308320a9a3d48229718f9538c1213b70b7125449ea3071426234fce98651164a983c3772b31e28a8d0690e40a231dc83b7ce74ab2eb4b467f9d543440b6c3d99b414447d4b60b429e38767f9e44c285eda03ca9ae636815225275efdc556100b6822842c9da9d32d9aa75153515ffb2aa013454451e2b4176c78dbf2dd7f709a1f50af2fecfa742b1bcb5cb8d54167dc636f89cbb639d308e7e19a93f53312c00da782803ac24e4679f2ff62e22cf24d50857b9bcfc0e15ebb647a77f29501f3fba169e62476127af9accdd28a678b85cc332da53804c1ed979e7f5ed56933f53d68c45e307122c54ad42f68405147f1960ff09e59c2cdf37fec603dd34f90301282d8af70772ded0f2ff0538e4c12e6cc006bbc820a2884197d41849e083755460d427ef764e435672807846aeed3b4e9faa18ae677ed0dce9e9101c5b61c22701630fba24a723c556e5fadf353ea4e6c5487e08df5688874c5ccaf3ee2d3faea9a098d145f99ca65242c003b279e9dccd65f05576f1b5a765f31e78aca0d6681d0116f9c61720e023e2502c8ffb0b8386ae84f8f3717fd9b2d4cbf471b5bc0e03dc9fb9c6300a609321667b805fdaa4c505b84845e6df19609252e43d295770f921df0b08e58d27e942c04fb81636ec7d49f74436c53c7abc4ed05b0901ac94fe1993175b8ff4cc2f4bc4cdd36781487acf8770185e1766af9a2bddbf7277dcc919ca0e4b6934ffb37dacb787b43b27085973155c522c5aa303719b432bbbb7638dee87bd759fd8805956ba54bd237ba9663e85ab12ae11d61b9b1dba602f7b41cc839d9b264d79f8d8bd45e680137655100db9709261c4d3756036a70f6e6065b3e5cb2a8497e8e94d6b6997d81af6b26a8a547efc4198945b16992d708b601ac72fafc1509e82c6d956368ed006a3dcd193f74d7e3e29684adec4318d1101ddc8c3a10733466160e45c357674f58cfac8abaac4377a2ec8134217663ef39fced141eeb19e266921c09da384bb58c82fd58e1365e9d28544ded7c2474a33e5d3d5a0cece447c454749bc88accedf863c497956983ac6fafb18e3e0490fbfd339afbc3a86fcaaaa9daa7cee9d1ed7709a550216cb8c4b0396041e163b53ec1b0cf66b17e3b7bb82ff491ade57b979e6f9815411951de5d63926731bb6a46027f5a8fed9221c19661f19059886a89f296fef9d434a135d83a6abdfeb26974de985f9dd449e3a0b71a738653e6880071be5504c7ee7054e73d80b0439bc689d3b215ca6505ae49c22f2d715111da71095536bed848ffa0dc4a4496515e952acc703e478f2908a24028db914ac46085c16f95c400a48dfb81ef9f461dd7c2bce3c398baf9c3bbf813053c50fecba596af17bc28e3e08a5284a236f1797c9d2f6add447cdb58eb69ad25df625a579adce8d080d14e2d80956fcc63f57c02928d93b5aa85d486a9818c27d5cd330d123fe98c9bc7514ba134df5f64f661aa3e657745cdb40f5f39244d7d8c01c78dcb10ee61b77888ecb2ea24017814159c8658370c009564e434cfc695615d8cb5cf437bc5d9f49fb7b0f4d7ce70226e556116b6a86f426c285ab0e7042de7b54f01c37d09d795f388ca6fcff29c7403585152761e29e586be716c4c58701aeacf640ca868be0f72509931c3ac5040bad0d8d8f735e131b0a01e1b91ee8dfa8ffbaa99e474406c14b78344259c616f7f752831dc13d48c8433b1c4ee184066d1677ca1c81f9b229ab9324fc4c30a39877bbb0343809946abe785ab9437997d170994fafb55dfcbe26225e77faa1caf9ce810052562e84af853da65e30f75671e18583a2c58de1c879ede16d708b9bf58e652d700615c37d75b4561dedae1b7d9e79c5e82a2cb91a4c02a74eeee4979296f8ae9f728f300ff25316b66bcc4d027515afa2b7c30501e1bfa16038b77489dc996dd25a0676fcc182c486b2e421ae813c82460c1ca1464c1b603234a7418d1121a5446f066da9bb64c6e3394c9d8d2be650f4e97e342f70a6117e448b0996b9b45dd7505ce44b32c449dd7e3fdab20562b8b6548c0d838463e6c3aec33ba7d4d6f2f0e901775d7c035032415a1f4dc57b00a7a33efeb92e15652b6edc5cb047792a2a077fcad80a48b23b94ce4d2892a4425964a08188757f93faced6cde6a09d58ab9da439ec76e25451dcc68912476e04ea9ecebfc64ddd0ac1abc392da5f5c28c97659835833247ee53d6b3de17373b60b0a5fb0ac92c67314e86925c69613e1e6769fd249e72d33312f68e1bea2488516d72561199e17b9b7ecb855bd9c2fe60a1aec19d3353be3d800ec36317fe33ad113a8d62a52ccbefc78f20b491adbbbf507d9a3454602bbee9f2f29c41e4ceaf09e1d94919ab52e7e8cc46710015467788c4b6072474e2425889863d136c068ca0c8ea2cdeb36f208cc57b4a16d30ff26af08b13c87ebb62002caa322ae56db99635e483ae43e2844e906730f543c7e70257bc46072e1382d656158a81cc9c2c84835ed0c2a0f5216b4fd9204d1419f10000935d604fa55b018cd1727a1718fc338428cdefddee6e1155adafbd79b1a4401de2a3b43edb6f550021dcf5bda5c6169a84b8bb743a9848635d21a341dde72084bc7e427fcb3b47b16475d92a77631abb88dd8e5c58adcee8b950857d8a05d7c65b57fb080824fce2fb9bb8a4dd8e62703c3dc555bfc666e63a2180661c7f8895490dae8a0131dff719e36f2c842c4428e56af8b6e99866aec28053dfb8e8115ad7d22a3b77068f7a811ef866e10c887a619c1ec52798ae5501d721a2071f59202cb1e503dec6c2cede30ad631158188c51761e6f375a77aa5415f81e47101bab0a2c2ce1ecfcd4770c26d501a37c3f396a2bda662f1bb77ce658c8738d330830104369a78e102e1fd072ad23e3fed25ed771bfe4eb946875146f1677771f4005159186d70771eba3574b77befeae35bbaf7bb75abb76dde318b0d8b0f3477fe4dddf158e9097706fb37ffd2997130d564b01d0dd1360de3483a5913a93af83762918e44d98ffac5f456ca7e4b2777488987c6c3ebba61fdb01326434e1c17ae7ebd962c1ae6492f49e4f855e32fbe849620625dc24846c8c76f0b5f72f0a1a9be7a6e5e69d18f78b14ddaa9281171aa8fb749da4f72057ddbedf78090f6af6bd99897e8ff749d010e3d043471b06c6a35608ce7e5956cf2182b65fc1786e6f57a543f06548a122cca6256456e16b79dd369312280eac6afd597638a643320dc6dbfde08be936408e77a767d5868e29966f03b925bc108454fef8025313b640023a5b6900f1127bce01b2d62324f8d457e1259852d81f1196b73b8cedfcb566847d33851b82fcfde1185d261174f25f90252ece9fc3d273660950767364bc45efc09ea63736c20263876510642679899c219348827acd9cca557d0500a0088ed70ea6d8f94ceaf370fa4d30578615a30c8ff6aaf4c5681511f62b91e6eadae0a0f6dfadaea32c713c40aec2c756a6dd459612160008fa1931a5382c682e7f9fc861d71a789ba104cf01e814f91e4ef0c145b4770336b249b9014f8cf7b460d0222823da535e3ba8580b17ac8925a8f25f3e42d83571c20ceb3cd953e2fdb14003b4c02cb638f96d175f85af25f6a738d075d1bb22d73b10be89535da84eb619795d5a0ef59ca5bc2562b32f134854ed0839e7eda255f50023f99059c58b6baf1aaf68f9a9f048d061d0279af5f14c125d789236e51ac343afc33da0628d2cb1799ff84b600ab4c16c3c23c3661a524cfd76b62530f2670516991a3b67301ff48458c362c15b73ab64e09fed1e18bcfd3f7acabc7390526ea60896e6785094f363c77be495fb032ddedc44811ca242028776ee3536cef2e3cfe646727a5a173a2e7785d366b2b616350e92bb4d147ebecfaa68d933038f095762eb579012b6356ea9f59d1f632e3c97b6dd8533764d3a059973a0e40a2fa4d81fe7bab1b02a88317ee57348e774b2d2817ce71b79372bf8fd6a584d6f8149787d3c1fd2334a8c24a68137e69a4fda1901b9e99ca2b6a87a14243cf7be2c20a1c22284c45a2ded7e16b42d52d3d776ed51115d830c8ff0d3388db877430b0fa2816db1f84baa18146a4b3d6741d45ec405abc815d8b533003dc0781ea6cf7e35eab628ccf9367da1730d06176f2de271e3727a91c7af0432939d11af4bd3dd7ec4f63c2a4a921e7ef96f5d9becebcdda01282b0a328996afafb144061baf4c35c84ce90afb5fdeb97df1428a08b7d4bee698f242caf7962ced49f2af86c6325f3e2126815977b5a41d02d91451b7b68f97b6c9b100a3f82cccf0a33bb93f895ac6d1a565ab60b204fadec5aa8ddef19afcfa50ce7450b17e44c3519e24cffd7d2d03d72283ad2fb91abed53f330ed9c1081afbbbba38454b2894549da1dbd6ee0f98dc401b0732e16d14a2a48f9e1c3abeb3783a34312a8722329e5156916ac595fdffff24acd94a3af0b0d282f1853dd91724e53a9fc03f1f479f201ea6b8b04fdff1925cd76aa0635fd5118f1e852257671391f4c8aeef7077127b1b15636dca446e7a1fa5bfc6505284dc143dc795de2f221b24d313367df80f5685230b61c826450fc518a2ecf3659cd03a9f273f4a98212f304fa265a2345177cba05ed73e9d0303e0c5fc4026578af7e83469a826aa79623ce79e58c98f70a06b23d1c4f31b820f49d9471a8e497bc8ef00555c54bc79e9ae4a89e8d0865c7735642a588789a070b50a57816985aa70bf7e20da114ca08bba10cc95d433a9edf2b1a8e26986a508fcbdb043686c6efbfbf6f795a83ed210e457076d5b9ef4762a1a1f3236cf14632fdf522a502790fffb6a7f89cf75cbc02dfb2727ceff368f367427ce0d07be0feed572f1fe6937e45cf1193405bf2c57b3900573c684693f867e3f73165826fce1e2c2cf967a78efd413f01cbd86a095c219c2c5d9758c5bb580fafd4fad09849c18980daca27824c61741acd9d1d3cb9c851d6b7d3dbe7086018f72d3a1e95b339887323a41f8ecc179f9617e15ae30ac3f8149b9702fa3497e2146501ce39701ad19a47ed04eba5ce584ce7058ec11aaeea35c7d5dd8610818a13b46de2fd231a98b3dbaf6447bc4638218b9cd1f82d681b19ac01d64b12fde3d29abb79ac1335de7f58bb3f09abcdfb00c6c01eb80887038f2cfef8c69c153bbbab6ea610a70fe8586206b8ace37a273c3fdbbc8b18c49061a683936f9dee017e885c82dd092faf6e67bf12f586f596a1406970d8dc6726a6dcb9a7f129314b95108ab823a4023d45919f6f64cfc1b1df5cdc32158b3557702139e23fd18836f08798cd9c58028c87f51430ca58cad76a88f9788ea74128fb12045076a565cd2fe189bb71240385f9a25ddee37f1d46a85829e1c914e1978be702ea68b9391fb934664bb5e9cff489f602b304b4af8098ac3c0986447ff09d8b0e9b49459afcc82d8e1e45f241b43830b0a8cf975d843740dc2d3872b3b137e463a080afb12d6538d2ed6a5419275cb3e982185fb8ef0a4bffa3ba651a3db9e27949eadd2248b86bcbe035d98aff4d0ceb13a8f64fcadf8845215885b5c779f58e4992ca0f62e32b058a79509df4e70f3aa873e5042e6ea45f8072778f313dcff7834faa67e40ce972700e46ccf123d8e568e49cbd3f6edd14fec983d352c9ccdaf2e36aaa0aef8d5271d98ab5092a7ad44e000b9a8fe07c3993a2e2fae25379e4e3d9db2b945cba2896fe4774804a424517c9c1fa4ea87f39916339c2b228afcd774085694445874f7601f697878fed3817a5eb94bf16c86aeea554736b16d4660742fe4be3c90955fd5782df8be4ac53c2a3ecd179043b38958f2b2609adc6867dd02e0454230ae427d1479505356337ce99a3a8b0bcbb29be0ecc84f508d9bf8f733c7394d5ff452e44e6020f355cdb568334c0dd17e0b0ea7d18a4040f456029d4297455d75d38477acb5d28ac84fd7b6c7eca7c5088dbaad45ec08141af10e10f3cfddf5207d812b30264f24626a8dcad9732b47add1ffa2a7b4608374b962dedbcafee9cec266f79481de6abf1bebe941d8306b09742bb47603f8e4577f4649deb65e012df832e1835ff8be581779a0825acb18740fcaaa8182578fa8de6444414a7342dd4f5d9c3cd3a50d31d0aaaa08f22986fb498fd17e74bf007fb3c5e6e4def2c6431026f75c83f03a29871e6cf0a8c16f554e2ad71922197733974464b20555133232d080baff3ad7922839ace9aa3b5afe9892e4243ee47ff7e26458ed51ea5e02b6ba8566eccabf5a43594f613eeef31271cd7d8183a140cda5d2705a64db269e65b4e8d5d9fe826307c96024a5d9f461c5f453418a6c40d81ee5be4cd2dde255ae74e613f89e857e223a2c4b3c100e1c5bc1551e5460082a65ab0d633d1b487d136a2040b413c28c7f8419f6cc43a750e061ab0a9ec333bfc7ad69b3972eb73915ca57cc1692cd50ecef8c80fb51d55899a012fb0793c39507ec6099b91285208f694d34c78b0c5aa6618f85059c1e3494e6d1d854a7cc6af9a740b26cc90700a57fe67237c6d08986c856f45a57e831610791ddc8c7f8cbc03214487b5867cf1d3b8674cbe22458e53b2a435cbab53fa29e3ba823c170afa98a70fedeefb09ad31f15ebe7fad2f1b9cf8bbc126add14145186964fa5416d38ce1f82c5473d61e895bd8f15a150f1d51f3d4fcb76cba16f663970c3ce901b7f024be6b604a1d1821036173769a7c83ffafa74a15f6626561d2a1d4544a3b01a0e228dd1ad334ad7cddf9a80daf40c19aa72bcd0e220c00195c971085526ff7188f193cb6bb26380717744f61d963f80302d03dbc9c7afdd5825a88f4741b491837eba5eab31edfe5eed2d5f990d5d89b4c4d956f05b81f38fa26e061b466b26f43a4e4ef29fd5848deeeaca35560c0ee978cc3bd6446cd02d3598b919ac2a8990660e526fb51acaabab81f4b7b328a052e6065a2e5c91628cad39e10bb829b32562df1b1e403a11de593ec3a545555b5817edb88688087246fafa181d4ec51cb25e9a4b87b9856b4b8d9a8318515ba5881975cdd69a5a618cab221e7235ab0683c9f1e6f36a2f5f27f2a9f4f7cf3c0c6436ce5f602c6be475732c116bcd28184e09345a977e929c4645f9c5b13a78d6dbc7cb0c9872309552a88d0fc62d4c0d0ce348c307e78c07f4cd836d474591f393d5c0865485db535c3d4b5feca1b0a237625b772e5eab445d5a808d60cf7615dc689f0892b3f6a725473b43abfe3a75871d86","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
