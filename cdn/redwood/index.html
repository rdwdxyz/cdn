<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"faf181d7bcfece397c9c8c59636f2bbbb595a300a4ef5dd97b3a9c198e52dc3c2dd3710e6969aaa5cc634105395450112a8ac9a685683a4a1c68d6399da3a9381c4bfbe43049920d7b1291ee41a06acf4f6f90e3fba0225fe3a52be670f2354a3c516accc54f673cbcbeab72410c914c15cb96961858895174dc5ff5b191e5743b6b19ef6a07450d32be122d0248732f36bd38f1de01c930205d7f3469910c094156c6543779bcd36ce6dad9f99667608b7e19a26fcc51fba696ceff8bf7e014ee513fd74a0fa12b20457d9be9cd8449b2b67b20aeb88836dd818f84399e567fb1cd87493aae75c8af4d51b57bd467f675d9160960c2a774e4d395a6ef69f8bf2fe0212d5cd854cb8a3490c1d3cd0ab3d27af1bf84b269558dc93e66b5fb598556939c974c2427c17e8886c0e12f544e70a0b418e7ad3e8fa160522dc92d2bb886586559734f76436d904d0229846bd262badece667d240865e33c8000c2ded5390ef72367bc168b5269f6d6df2dd50eee5842406728b8f11bfaf7979c1f31386d71ebd959ed6b284d2232c9f317333e0133405f3ece7c0a6468cb4d7fdef4042ccd7132d79ce771b0ab84ea6b5d240fd2072925f1f756f88d48764c92a11ac61fbb2ba663ccaec99fa58c39b8c24502141f4b6c9d768ce56567f78e8d17e10f7261ce81ced72be396a301796c6216f848ac2c0a6b04d4ce29d8fb73a5e08c67156d19889452279b3b735945e2f81ecbd9bff4d758fc7585e0980d01c9e7642854ded314d6493c164c7215b24fc3a16041e3fcfb146a1095c609c9de8f467cf75f98957932f86149e57293d0a283f1a2ef7a16605d6f3d093effb5015af395ccf0d8c29be8fe452b3a5eaa01780ecc54bde7eefcecacbdd9760d949888a940753fbc0e7d17ecae5369d7c9f52fc58e17a01ad910ddea696a908f1cb61dd73a3aec3f9628be7b812c7c5cd8bb27970e628a33f4c86e90b46dfdc7db92ed7b6b9a395ca543f6d425a64babf3b70269d30c961abb6c67bfa1270e75071799af886a58787e63b3b949365842139f42e61fbe51ba57000c076b7957e8ab33a1fda6177d1cc04c97359a2e25b4cdc9ad1daf7a889b3e8a0efa08540980aa725ac9af054193611e77af7648454c395940d45d8955c0071ff3936e1733f0ee0608992318b0683d7fc0bad2f3370ddf02178d4cc5369aa700203c4f88516cfb88ec250f75871761b89b1561748372ae80508698279cdd486803c61bfe0a44659f82433240eccb4457e2b2f6c2ee79e2fc17d678f90a0014c9b0b46b9a6abb3480891b6917248e8c19e199780e809f4a612dfb34f55f82d2a636db2ef5e3602de506472a34c0daa9998e1bbec22cd6f8bac3c4178896904ffd1ec8081fb2789eb132eeab9e9d4547296b698e306cb463d8dbc71bfb4229a60ae178bf99986b23e321585b7702ff856e747c9c15bc87841d3a43df4bc11db154f0a6ccb6ec2ddae0831b43c2eca2d0ffa27294b87666c633fb599cc0319e0f58ae51a41d137d601fb4f705ef0672b55a25df3ea05aca321f0c6dbe5a92def4105f804a79c9648cb26f19b46f2370a24448a405b89d87d2e72ce3d95c412a4c66f998578505080d12c125f890fcc779f1daad37715aa1cfe3f311942f76d4230f3c701fd431bb60cae73b3c1fcf944d785c2e12486a741d795c7bdab26f1b8820a0a4297f5eb69960a47b6b17a2fb1ed28ef694272cfa3c1d420692d4de73129baeaf012ed986d91482493f0d9579f239e547eb5561cbac69eb77feb85c7b3c2ab674c3423fad6fc6f3c17a0667d55dfe12446f187a1966c6497c9c897507762258ac71a083ec0da71312e4cc7547b4fbeecef30db87c91bbf249acac9a43730807374a263ac3a76a67ebb01162050c762a4d28c1e42e1557b2785f008412eec8906eabfd802e5b4b63cd3ec34d794040e061165bc6742642d7bbb8ee0ab25eb84490c50d11abb1e71a2580a93f0491287c3dad0868dfb23c998a1090ee6ffa6c318bc6ca40cad91cb4efe9702816cc78381446ff35a9ded0f3972abe59b4d5a07361bcf989aa2a02b09109ccd07a24466545593e8bdda430c6d95329a0e3e43d2ba238fc184b1cf21e1cfd43d526cc7fac2054fb37285b56d2599e1e902776a9312ac81416b5210409b7bb5c7513c1d45ef56a9ad632b79188b1ac06890de601e04278953f2d59c57c57c7eb23d7a7c07e242f82e574de89a4ac4e73b390fb4e94b5a0272ca95f8d7d7633ff894dcee62f45f048cf49ee093647484b9b463db61ec22d42a11d8390eaf36bf84731b35a8d5f3c740e24b81c489631a7d6db36ab0a529c7206cbd33ee96ad5173d47174095523f6f0cd591336e85498bfb3e63efc4bad0044ed27f4c0517c4735a84df75d411286be71a5fa94af24d7c1616b9fae074d378fb2ac3c82165efeb63fb1a2ede7faa49164e982b69e73ce478ec26c12837af251d232d92670376aea759f9b4c52d37a869a5469e05ca613fd0432a185ac8fe02feaf963a229006ad5ed56abefb5a7dcc8f4208d95d976b71db503333b29c79bc1c35631411f9acc9d28d112bd45cc82aa7c1f469f8715498e88e1d22105af8f8366998243bab147b451d0b6001d4762e0d7b1c2203ac4366d680b8dcc3583be01cf52865e9f030df313d306a469412d6bd4356ebf0b71e8a9af7f1e7fafd656eb04237c19c0fe0d92f0fc48c6ebc50305bc3dedc09967765a70ecd280c3ae6a1439325bd338486b8d2ffcf5ef6e905afbe54e7c2f2400e3af56c7c715089adf56dfd058e40c3fc8a6abb71d511f70480b434fbaf9019bb919b7670d0f91d998b5af3ead59e7709932e765d298fd4821662fc2fb13da4a6bca6ed5c9ac576aafa2238a7a56e35e7fe04073745b0e584d0e8c1258aafc5957f65951f2def951a590d83b8618e088d1b8503cee4493c27e0482b9fe0cb529f0030779c6eedf9ddd78b9bebeb7e9b2d689b498903689d57a54c6a6376399f81aa38c7d05733c3389f3c28a7f9686db01011d7a2012fb774602e21c029ee193462945d80770d9a62a8ff84a615fdaff52cfd081cbb3b2abd87d781f60dd98cd79ca1f70a03f7c76b399c7fa28844b2224d9ef39979a57384b0db796235140b6208761468a56339d663d16b140c1155f76cc46653f516f0b029ffbd7e8a7767de68b29404bbb0620f1be382b7e6c6cc2d5f3d7d05174b02399de75d7657d10265624dbf3be2d9572e70c9c7dd40efcbb080f710b332e9816256d122228d86efd2746d4d3bc56a23de56ba3437da03c919f96f19f4e1398bac177cdbc29887f5c5743e8890eaac2e96bfd01994c9adab03e43bbd8d5d62ed61fbc9807bb6949cf0630d6dfa8532e09bf4ce42d4f1af60ad80a73d38cd0310d9eb1aaf8afc3a5113bd4e378763f2077267118e5ae98e7d1ea2cf9fcf1d2e9bca57d6a6254c2c71c83b35229bf96da1e5751bd8e2920905da90ebf05147f2e9fcf9298a108851870c76cc12b368f3885deabf09f54140694286c285da5946c324e34b8a4ce8d3309a97fef7912c15ceee053b68bcac49178a006874fd6821bcba696223136c097f09c57d58ba451b58b45058e485fef4fb4ff1d8df11617458d9595d9ff82842010f2d306cc37aefd5bf0195d3433f835a24b6048aab842fd5566feb3113caf79f945e8977d1bfe364b71a5990ae7e837bb999595d79701bb5a2a5e3acaae2f9ac03a9b9e1e918dbf2adae47ee06270674e6dc28211c84592ddab4069dede744a6fc2f64ce4e6f81672b3d7d272c5b8efb1c540e59536030b872e560eacf6b95ec31fb7dbbecbeee6db6e2cc9d5976cfdd73aeb913a6cf4eec14b83a2146b97d3d1576534d80bf1c2c4f9c43d986142a7ba4421ce76a0efeaa94a3897545a2ac5c942e17822c915ff8e96dfcce550e10515a6a5a6ba50de7560387b52a2df9ca16051adc2d4ab997888f99b00d6b47fb99fe564776a3617b94284943f608fdd47c513df948d255cef81d6d7548ad19ae4ae81b72329362be32164182168f4488a1759916ce9ec769bacbd841911935f6d84c127c37eee4d654d7ebfbeeea36fb27a9f8b23485034ad300de049916d1a9838b5a1b95e8dfca028e694d82cea464bab63c2e2dc60928a5bfd15bfd14fafe30d144adc1a5266894a657c6a1e7e7662bd3c33ea6200d92ed5c0aadf821e0d007025e99ad3cc21f0686b3e0623525d51a314f9607f7a48cf8817c41cb36c5e21c85da8349caa43f36e0864de9bc9c765281a70664e2f2cb6dbd452f27846adfb33bef8fc934f2905efba7f0d7deac6f94b61fafb315ea30b3841503003d20d484672e80d8aac993e8e1aacbb15b2ab39e6a6fbbfe522f2ad00e310da3c7a095def5340457c4f6f9c62527f7f3dec05876cd7507aa89f279bdffc9bac304ed8bd7961f85ae1c9767c25cb7e88eca6e78c43d93e86f179cc7af46502349797bc82a70e81444087e35f4f42b941d55d8ecc9c9de7b9ec096157643f738f7851a8ac4a21f4390a3036e17d53e01757bea8a4f752edcf3ee1025d029cc79cf7039b4d05998d4c7237312aaacf4d62bf9968216508345eec86498207f35f3971c8ed74a1ed8039c43b68b41da0f782d6cf4574aaa84c791913ef2dad69e0173c4568eb743e39dfe088b29fd8313f204d84063cb5e8888dfe9f1d1f318306afdc2786e310f9f827dba0a6cb17c5c57521875120fd423aed02ecb530508a7442d9c583208e2a69092dbafcd0b6266f71fa6c75cdf8b0a0c92874f14a14dfc82891c08a9b0f993a927514fe24e6f7f07a9a0de41b716416b11dec8a5833e99bb6093c592e6101314a230c991bc4f3dac9901148a73a7813f093f5c0687609390c0769179e958dfa62b9d550fe1d6053168316218a64e36cb00e06e4adfa994ed55027b5ab8d43047bb1b7909cad6fd31e63257b533c167628de85012be728efd5f96f26f4ff5b5d6d9a83bed73392044403ed884024df63f2af41108e78b161081f356d1eb52660510f9c81ff972325310404d43bca09d974d68fd3a15f8de2d099b4efddf4ec84ddcc79ba49a588e95740f63a1043b1ae9d1747905f4332b6af01ec64e7f06b6c5dc0828032eb421665241f59f6f0b7ec2c3654123f77820675540cc91bd66ba2bd92525b82f998d1f8c0b48fe5401cb62ae3587d2d140a53574dd718d8efaf87efc53dcb702504736497dac9d45030cc6dfcf9f6945774e8b3c12a2c63085eaf3b475d1cbf07416fc1687751b375a15390e7d452c077e37bb322e66a79964e96f6c91b549d7319c5bb213ee1369c8ba1f838de646014408efc28b91929dbc95ec6b4b7cb2aacd395b8eff2655b0ca96672cb5b6a6be7575f5ac12be4182728052542c10c29c3270b93046f694095e34dc6719376f193137f624b79399433bf2dc04846783fa3cba2eace666e471df31c716b955f46b84ced68bd4b75af7bb52d9b41c8535a25347c47120af15243b43e57b1313dd415e2e68a2cabbfef7f1440b38fc0f9e59591bac373516b8a92f9124960d24a7898038f2892a2b8d6c808bd0d7a11dae1d8bed25e4f5f3989217ab9296d9f395a367f951671bc5815354f28540c802baf562dd53713a070f190a950b81723ce9524d6e3efa82f372e619f7d21616df98f769dd0ce929bb17b762870e1d167e2168b6145c0e3c4542e761cb9379ba2328e4d8cf5e42de189b7538650b4357a1918e5862444fb084abf189474c415c1d8e43ba1a0d1177d0e6490ed163d321b90bedb31b26454fc1f2a09bdca0868e9506ad58ff9ca4e958fc8868ae53357ae922d320a850ab8345f8f76f39f632c0d6338fd84b3fdbadad38e0e58ea454b23cc9caaacaec6500e6852a521a133b69616f83857e2ece93c4482a7aeabc25a7ab09cbdc2c44df31f049833c05ea110e5f9bf2538b2ace27a5b44235f7e1c8a9fff2a6130a030166dd2701ae003a77f53a02627dfedced861350239bafe20bb983f38c6ff3ab16740b1465b373437524cf5cd2e86126bb12851024df61d921febff473c43658e37f037e1ca41b4440e33965775631d77451852bc449c873730519d10240cc09c447bc87bb7022a79e04ed7b09dd56301d03fe95efd78e2c9ffd9b4227b1e727e8371a7c06f3786f684643436ef75228d1943b57859718eb22b530149c813ddc94b47e4be92cddb7467d9e950eafc22048f4ec2b9724c8654ddbbd1d6f1023ef40e1139503d7adf8938c45daf3def6a018eec1acc80b4a314d90eadb0dfb15ce07123016927c5608545f107d98a9b52ebe5dcbdad331d435316fd2091b753077b6cc4aa2392ab0efc61f42c1433b18a37523a1b9b08bff1e4c67e06baf6362683a495552c20cb3447acc726608e401d6cc160ffbcf14caec23f8dbf81c49eda16ff82c68492bab4502cda91eba26b67330eb7f43ff26ec8e70a19d77a94a13106ba5c62b39c58f07cab62ea4d8c82b2daa79ee68de4910b1708e60842aa57abdb2051f65338e70670c8ebc1c0d36d87d071369465d6550f7dded3c8d2dfadc39000c7643d96124088aee04a427012a94e042904cf7a9eac0eae7f781c43fa93d15fcf83df8afb4accdfe5ba6ab31939060d06cb24339ff4812d30c2e0411a524c5cd87b27fd0f4d6e35c48bf1ea9600c22085399c6989280d7a5a9bb21d9d86fa23784c15ed15e8c959c3974926535a3461407ab13ece2a9b326263e309f03de2e13ea6ade78008302edad571ad5aae8e86d3077d7332b904b60b13bf9284c918f605c9e461268f36dbdfd50f35ac9ea043337f2d5863ef69aea356ee20db3544e2e7aadfed7d232cf250c9cefa0316aa9afb857f9a0d563b36a64138100572444dd91fff2bff1839007c8e68e2715d17ad1a0b00eb1a4b5dc3a6605172e2cab36960d6baace401e3f66d7093b5ef02af7549cf0efb0ba68ba108cc52b9bbf01190110eb5df0074f36da59f31338f8b659fe20e03feeb626f0fab19e18e4b33c6f2dcce8ecdd1b18e4f75005404f2255df9f8e957b4603a90b23979a00e8a8a6d0cfe73be29101d550abc3428cc7066d8d1c6b4e9772694417e883288535711336a110bf10ef354fa69a56b638af7815829fdc23a434dcb65c09a84820d92d41322b2918733270fc465543427698facc0051c2bd2e86e5df3946b7b8cd8596832f5623ab4cac14d09f81e53b1429f93540a677891ae1e19f75e5a463f2dfa547432269a9ea6e3cce81b73ccf700d6056cc08abf9d8de36b51cee668c1fb84d66b7877ab0e3bd678eb18dbf43b8b9bc540e9480c20849b5240d47262e19a2640870ebd0fec92a46c5b1b3f9a87b290acc40e9a3c65f58dd6e6f946b9038b4d5cc98b62efdb2a3741176d44dfde46f7acd5924b51287e464e38ad8e95272f47e2e7abc0fdddf93be897eb46b0a8d5aaa4381c22288a884cc2d96bf5a4abaa97d3463070e37943c0686787a122c4ef4ea4d6cc50de0c37807f65d28e9cdd34370aa852d6e14f5ad415a93c1918960873eab430faed7f19c91a94819407f4c49b8647fe6e594a7efe046029753d670f5af4f73b6a4617a03da5a834442a69648393ca05ee27024bb60006fcbac9e7bc57b59cabf1c6e4c640b1ec25b02194847539d469be695f1ee77464eb62e35c278fcd6ee7102fe5f5326bc2b4dcb462c8b28cffd16cb71f7ea9b5568f719aab11a4524d75b5353c0c39dcdbc34d38a42f3f8bbf7da58ddd4ef65f80d76effdadf228f135949f7dd670f6667fd596189c2003d0e9fb57c3a9e8faddba776c95f79f0e33914c277a8204fb6df8aa8e8069285a6f3a9f2726ee7fbe0465cb997e31edab36931ad1477ea81e56266044fb6e0c37fad6bb9f9215870dfaf9d5dd7317160c6686d45203265262ab80094d4531415e189740dbc2a4f3cc34d2da7bffd189278c188b2e45dbb456a975c0d43d611a84ad454e5d24dd7ebab8806387ddbedd0cc912735c84e5ff3819bc3591054b761c1d08d35c5f069c7a518926398e30123ab2cbb050fc7ccb5c9fb703402210993d77f0d87dbd05785aba27f40c22d432aedc219c2be12aa6868dfd37c0f088b05ffb7629703b9edca9aa16d7ad4bccca59975810a7b3b2be1ab415cd0b06170f61fa380ef70bbe4d0374d8a23ecb83f23476b0a015a4683e2878a6b59e21373b26be5018b625f6ee15dee32d92cf5958241ab319e335fbd130170c2e2a94825e7f603d05c07888f359b5c880fa89fdcaddf7c4541dc9b696390dae7505073e8440254177d9d07044834ade6576ec357d6ff1c2d8ac73cf07e205029127789b580fa6415fc2adf399b6be76fb40a1809aff62b977d1321091487b4a745372f34026b21b7981ea8737958a12c77be4338521dbd9eeabbf2637eda11e69c6c6937de41c65b4ef508a3eba0a3b6f30e5cac06fe706dc7e3d1ee5da591f97d969d6e4d208192c6f106181d7b8afff291ce4b6a0db7a0dcd02462330d9b02d3cf100a9d9af38951fb4cd0ddf913c16297978894b507a5146b84a82fbf978f0868699aa7b484dfbc140eb4d85c18458e0af67b6ff8ebc8444fd97cbdabbd8636b59a76ac8dc947ae45dc4395274de19c13099b38617f06297768c0341b52a6670c0e7f921f14c7234f9aa8a2aef283124e767e889cb925c8673e4ea8c3c35378ff0f5b6f07f02eb0af0378e4376087b436f000df908d9bc5c4f966288015166aa08c8ad075f30ea5595c9efa06dde725571ac06d30e4d88e29ebe1fcc58bace6c10cd2d240399a97b55fd7fc479dd266cd1f4bb59a0cbd6263dc3bcad2fd2e23ce95305c51f0296b41431781d8dd096f4956d9cf5eba8b8140c9d267ca08320b3129127eb4c67c13c06090909f85fbf6dc3289bfad35141fb0b74a75c3ff08119f235a9c335b57cb951a1614fefb42ed712d65213df915db703f9fed7980a9b7c9dfc3cae1c9017db757508b28f89eaaddceb6a6c82226b0801d07cd7f5150d67427afd7a62f049b9e2a344adc448bbda04103678abb5e28354dbed3cb1e3475ec7b95a69d3b77235049fb561b3e12f4c4a3abcf83f057aa9da54800f06ff5cc413b63f9b3fa24ac81b73e048f2c9704cad66a49e2afc5d02b77f68aeff6e146a374b086884d33fbeeb2d62c6f5eb205cda1d56870ca72d87dbbe20fddd845b86f168bca3490169635febc8dedee09c40b345fe1799e9038b1db9094f0e003c2570deeb0da517dc7da67705437f7a7c517d6da1df4584058ae383cfa2b5c1286b650983ca37b58a85a70b20fc31f172c0985d97853434e50ae8e6f508f8411bff41676367a105f4524ffc47e8b3f3e6cd67d56a4f2152d09b35408d041768189ad2f011e5f9a4d2335351391f13197222ec3fc9eda38d97ccf457ef74cd5c4e9ca88e886913f112c0fcea363347514b897d656341fcaca6e5a1b3dfa86e7e9290c59fa5ea145a7a43fff9b836895c497c75a58937ce2496a648df773c2a40104e075023af53b07e0e8a50f9322c0220d7e755a3127d04974776dfd107bee71f67fcb26df418ff0000c4ffcde93878a10968b97a6e95dd28b00a58a75f7d7a45b7344e7e49476c492ea36501330afb9a7d8aec6c679b6c27df94181b924bbda50f2d47c4fad97f5caab5dbabd609b0bca345d5a62a1124d6f7825fc22fa44e9e18fa309b996267fc294ca2c42a7d289a8c9a39db9b2f9096adca05525e3adb16fd44eaa7a0cc7397e20835fc9ed04c0363f04e1cd6c56134f96b80b61647952347abe0c11e0eaaa437421a21d3c0eebccaf193e3af36f8c6a126b996d2d6683213d66667b7b81bf3f720b91d50bc2193fd9d4c1753920cdbb22ebd22c01555715eac3c896c2546671215189a4c9834c0705bf61b2935618082f6820557f998f13bb3fd697ddc6276c9725e24ddc9d8afad886252bd2af4242599fda95a22114983cb28c5cbfe1d5c70aee524e7fc1a8213bd1152c6e2fa2280a59089be2fd8c7425189dcb6cae57ecd66646d6346bfbdb599731c5b6fd066f48160638803c81b2253dcb230cfa846ca281d70f6cfd287aea7e4c6dd9adfed7f7a2991087adef81ac786b9be0334a1ee5cfc477dfcdd187cb86d25c71f699e44104175ed25235aeb159ff7cd9ae44314ba248ffa30d6a25f91832a2d139af2619a739ba6160211fdd26e18b00957367bb2e92dce9163bfc87c8e0601d0adfb8ea9d46ffb22af2ade465904a119672e6af1f059b3723d8db23991dc157edaf2b245319093e06943588ce0b2a11bbcb5aa8078db4a4b0b274ec97c3f4ad8de4be3724bd69a70a480d3361a549c084b943ed573af0c5eedc7ff7aa09873d3824be48b0a7c8533682c6341c4a8735dac4f558df674db17d02879ee7984517c188082dd905956b807f0128a5e5b3fb6a31213c50ccacda4e3d22e139e474fc632880d4cb28348b39c701afc1e4476ab8d1a3ae28a6ed41ec1dbfa30466fb1828a76e6d215888e1e0cbf5a7ec2f8563e5cae2eed0e1c15282f434ab16667df53cc6c525cf1ab47a870758486315f3c6d4c056088682812d7d3c44d34ef763bea8a2a88a700b1cd5867225197453ac3ff1f442324e03f360bc00eb722a2a1df75de1bd989b2d0f7ad992a29ec6b4ecec0b6dffe71b7cd352d20bbbf7af6a5ff9f11846eed17c0d24594cd65f107f07c5a00678b039a782e884a2d1e218a0923863083774c43bf7983dba560ae26c238308af949202c117a696d6d26be26d3af5586f9a0070d7991fe3b9340697df957452a9688630648e7ba074c2bb47ea54748c3cb442e01c66da92f8c4eba7f9c1da2a38ec6f88a01706dea39f2a98e3778b82895bd3694d01c3a6ce501a796695bf3549414ac55e73d9a68cc41b794a6c3df8b3889913c619effad3353ab7321a22a73c049369c3bca4897a23b52f6c8ce43d2e27c57a77adf94c93714c39f50a99c86f42025bb455cbdb2590c5633969a0c58f1500bd3095adbc5ff11aa4f70669d1665a8596bf6f9af5e09aa50d16713a9ffbe2ba92eeb927a7dc59189ed041d72549cbffaf13f421b0fb9e5d60d013e07671c03c0bb29d1024bf0ee797a7076ad2b8c63efa89905c673728cc6ec7a4e070a1a84c5dadf55a5679e03b70851ce8225886c2ae76f40ada08f18ecdee09a79f1e83bd5fa8a4dbee8a7d472a9b58ae6231d7a2fae367eb11381ff591dd7ef5cc3e039ce58d86e6766529958f7635b74f6935ef1dc4e0dc06d38c18d7e5f3209f052c1b1b663864dda36d114f6f0cb62b120156d8095548830ba315e2a605a99f2eaeb2fbeaa644d21ce735b4baf6269f0c2ce83646c876e5f4d827cefad143dbf39d2331ee483c7842a67f47e7e0ed244eb6bc63e36669907c06dd8d3779eb1232b979117b620c167f2a3a28f4d19d32d0c37b408e23e785b32105f736320020595c60c43186ab46cc9c3d0896241ba3c1b1e4ea2708b821efa2a2c98a1b01d16eac54d7a7cd52ebf018127df258449ab0caa4b2202ff0b472ac69c194135379d8d82ba38cc8a0f741f9cebbf1f2389ed990472df2a3ed88083e5d0db863296873d9e7025f01c2c2e48da2eb81d97e6ee27a6048869cfe53b7514987f6f5c8c87b5a6ce2537d7e6732ec687e55ea1a0aa1ca0c647f036d47d3a746837fb55ae92b223a538f54e9f0d62cd3e36a3e48184af31f8fc151c9d0b3d10d0c073ffcf3e7cdf19978a0d2aebf3b83a02de889efb2c696bbff88df1883507ade621458ccbfea0f46c0fd81d2b6e6b928acd69ef87db616810484c3fb66b20ebf21e7986060aad39d62cfcd0fc094505c2f2bdd0fa9379b7bc45e9c92549e97facb358e257c272e6b465ba4a837eb4c5bf8d35777e51a311d0519c3d088c76e20f9542f071c1ea1ab43efd9a1f3ba8dbdf7a3c36b29b8009b10982cab37f28a429894aedf854bb0920eea09ccd2c93df5099eb721a6016a767732b299ac25924183f06ca4ebe1395a37dc34cbe857dd36fe72bb8f007f4823b44b1c2171d5842a1b72f3c1ae17280b1a2562ed408abee8382f26194c938cf51594dc5ed5b0f0e74ab12294eb4839fc9edda7fc5a3e790a5bb32694847f43c1f74b1f453c1e6d9bb307a2b1cc862bcf8d155794ec01d19a7ebe3adf8d643d82424241ff7ea95ed2c7f45dc66207f30c1307be2e71e0732ecb682cd274abacff89be7a5d8262512c1db599958cec3fcdf9f0f807a5de58b42050692805dc2eb7bbc7bf1560a3c0d8ebc0a00e1f9f230d9736147d83dff792ef9d96ba239295fdb537b254963e786c9a318eb7af40d219111b4f24729d138d048b6cce7d7277f91748f2eb3ea51dc90e4047fd0c34b3d80025bf810503fd75c84ee0cc083cdda6492cd0144a4017940b7c5e96fa906e7356dd3d8fc72c717f868625181b720522e1b7b0d24e9810501779f0ec6a261236b0ef6df5eda877ba4bcc51b5b28414e0be9e043af03b2442eb1890fc68786160da12511a248559f4f8f847cf936b90151e34f20c427eb01b5b06f718b30e254fa8039e8aa901fd6fd681c3fb71571c0a4b7641a7502bf12a1b847384c985f197ec622ec7e0507863452c48ad6cdf82fe165a402c59c3b2dc07a4ed6ada1adba3d302044d9fdb09e2777d93f8132e001d9b7ecc528af97dabebfd8944a0d6ef42ecf080a794965aa7015822749289a9519ce2217906b6a87c219ce7987a2c53fd8fd2f8bff3bb82781e7b003991db35117e07ab0d1806687e85ab7dd4a38041af78a6ea10e9527b15c839a988ff5c6f0cadcb9c18baa5474fb2f626af6b1b5083c87ff3d1e6e30ce03a8e25576034d766b70bb104e12dda21b9f1e82a60b32af526988980916a6614e6d1830f2c39060cc0fafa5f0e61fbe63e432b6c698860fd48447401db1267406af43fb7f3f0c6a63877557332f9564d38ed746a3caf40846aeae3c2bce2a0caa3748728040123195df8ff168a62f3fe52acc556d8cde2dc3a08172106b59f9113f4a5380335e85215616c19074c82e9dd0834f122657ef134df1325fa96ce3b8e998df141f2265b46092e296db5dac03d72691b434c9a15c5fd8350c2c6c23187b7d681166c061770df7dec902b81d15ef82c5cbef45157e7b556d03a5b3293975d1353829c049b9bdeb5700efee4b7559a2a82807db29b4e1128de545ff3b055afd41ce7b7593a68c6d20baa336412464661591120a0cda767989174a06b87618bcb1437a9909f1a78397b5e6dbe79621a554bc92000cf653f451b1bb634c7ec2da1eb91b5348a3eb6e31eaef9e7ac3d80c627a6cfd42177b1061c7dfc31c67f84e7e475c387584719bfe79d6058a28fdf6870a6c59a8feed4fc490baca7d3828fea6cc83ebf84aafeb3742faf67f43e99a4555aac53064c1d368cc41b8c78e073afe3836b91bbe4b47843b4bfa71972e625bf80b82bba433be6348223555767ac291435e9492eb06a9b27c62d8a7ef26eddb79d7e82159e6d5692f964afe4b3d7eeccaace96ef19a2406983f78f7418c705d84f3f16944cdaf57d88e656e3f7328893dea69326bd76e620b1234d5cff8fa826097052443307cbe9e369dd8a137abfbdcb3d548a5947d22bf77e9028bfcf65ae866fc8f53cf6d1edca1c215a366f2ff36418c5d6d77e02d5a596e3e43a0455a4b6031cc084c5824fb863c8ca762e76e55e0702a3025b8ee4be6a2bf8f1a02383585e343a9d08c0ca3dae47ad82fe0f75fbef1cb037525fab5fbcfcfd4d1653189bb0bf265d2914278cd566fd264efda9c1a1fec09c8053df2015dc46cdcdc129ed2f851905652f4b48487d343278ae11f99047e27de2a66b6222613d2d52eb706676d1174a6a5f0ca3370c302583ef4d02e75e88267d78e451c5ba75a16b6e464cc488ce06698d01e53ed4b84dd17d112c32d79a976c6ad92d3dbcb8e370d88033a11e1bb3731279d5fcc89e493627aec9b62eaa88c0216d8e2fa68f2e70685941341d8d7e7b677898bdccf777eeb98e302d1bdc585967cfd2f5cf83636df281eb0801db5ecf0b9d40b37742e06c321fd51ec20b6efba205bd0419338d9e76accd31ad5f85814957869158c742fa59875b561f8c6df8ec2ed1f9f49c8ef88c9970dde65011223b629dd239d034a5bb193e30e5df6c08e58bdcbf4664699d9f348afa5c507f08550e7ed64f2041988b162c3ba712477b871b4645b48e07a4e74630ff20ebbd98ca588955703374c9101c90ac8aaad6375dfe30d54c317247877abbbde1c75d7d66e78023faf1585775b2d2a8d9c646d404060649ce04dd1bcb2e4385b54f3cd7e68ba2fa8bd4f93012b1ba2cbc778721d8eae2a93d742c81514d70f129e92116b68568b5fe64be6303e46783f842e8a5f080e50f59d72b984ba80d0a611ba3d16a955a937c79faab72dc4512fa5243015d65079346a1f9c808f3830c0368c44fcd8f24a9963e16d2ceac5ac85b3ff32f5f2a63936fa8933fa748253f9a8cc2279a07804139fd691722524a89d3d76f300f6d52a14019e91c5f261cdcedb7e42fabe2302b34a10603bfcb6d578b2fe43e106f0bd322b600aa800aab8157a348548dc2d5cbe716780a8c9f1ac7761b4d972c5559e04b3e7e822ada4984a6d22c2c904104b45624ef68e5548e40e8dcf8be17941e60aa9814312eab1118dc3c88b0283cace507415d46aeedbb776e2e059039b9b622d784e0d9d32ed32697590e2f48a14f601f3ab3d167ee3a7626db96287d2b80ff9da0539d6053bbf4c685f477f2476049f0f97e9696c29a0fa4a8988bee9465e5b1e08626f0723bb60f7934f3a898f5b82ab4a210a00d61b9943475ca31b1280cc3e8cb98cb9153b343fb5619c04ea87e4942971569460b3d72da3c9bdd48b5d17d63b5baefe49eb3b496ab1e05acc55850cc158bac13f791af1b9743361b97b0d9aacb4c37632ec38a9cd9722f8baa1634c0b1c48cc27d3dc059fe77d29cecbc2f88d558732feaf7e7104368cdd56108fd7838505ac078cba19aca96d5b26e88cf963eeaff5bd16dfe836558c2e86aae52177c2ba700604424cb14167ff3bc32c7696349e6a076640d8635f40379a137c88df7ca469d1022e40f822afbc1add99533f66d790784933f4a96ea24737d1d9a59e36b25d5a9bc8e21feb5e11b4fbba2649057e5a960982d82d1336072ac9472adfa6a378d212c25b5265e98a983677f9437807387a6abeeb8a62d7f98e3c3cd30c19bf239ac045b53631ccf309c3c78a1e06a76760e5dfd7d9bd3ff5ec6161d8de4d84aa6b8116239a5366a861ef0c9422075369c3924ae49eb30c881947e495e7abf7da4ef9f491899bd164f3ff67db21a1b1ddda0b345f9768205558a2bda8ff3b751de6f4522d7ca68f5f8a0364274f0ebebe8a7b050204e489c001a808008c2912ed66982d1266ad3354dcf4d385527bb7ab72178ec342ef5b29ff5e133dac0da76e5eae7751cac1b7b8340672f57e4f864412d78a26b229e4e7a24209e8d944c0f25574a4a2f6eb9874da59a3830807d80034e9a595108e587d207b74c3c9a810cebbaa4325808424cf8616969d4c191e98a6ef59f8a253b9e72ed5f8e4d37bb19a1f8a6e72dc8aa6882044a7966904e4fabe81778a79bb4828e6f7bace28ed2d490ab92dba664198013f0c51a6ad0f9111f91452735e85731fc9ccd77b160f1043f995c80221561a726ca55ca90edba54fe4ec183e860bfec236ff351180e6b03c6d20b05d5205148c6fa52e369e0d3a7eac222ff689b75a51ccd4dd8b223a937d45d71ae00f10e120dd8f87eab4fe371040b0717fb23cdf35391a8938be4b57334e175cdc94566a11664f05c5cec1937318cd05315f4c52e52bd11040d28362cfd29e27f618d64cdc7c3ca32314b7c341c82275036c7de445ec6db5c36d7742193367efa58ae89146ec3b00e53c82574fab1a7646e92e568df8257ff4e6b0153ad2f24b4086cfd9c3b27a5afea848297f982bc0547f5b58a2ad9eb17cba0afd320efd57a1562616d39642cd5b06f488bd11973229cfe09a8896c8a2a5090f58527a69a51aefc22b6be2d42156b5777dfa1def612e2489a960393d3f96bab11197a629200e7ad8ed46461c46182934cd56df024e1cf9c288b58f786802689b57272c582ec87f19e9af7c5b133a54800ad4eb30de3bfedc78938de5e4f6cf8c77f4d70ab8ed56644cfc62a2efa9d3e6041154696c416dfadf7390c21b416054a2ba05db031eaf8be94fcd88987f4adb4519f3344bfd5fc48f7c67622b65f4ab550879da61c1c4f30ee30b54879dfdc4e46186250571f7150c6bd52d510002186af15eaed49938d8929b521b8bb0fbdf35840dc1f4c0a8efc1fc768d613cf461dae5dc05b3b75d7b7177c55e4f45b2615a44d2aef889428e7cfb81cae4fa8475278625c1b691864c5afd57709149ef1aee506d1f14069f161665ec078c53f2e9eefa6260c30e18031dc2b86ff60023126b5ac25304e8a8ac96949bae445bd9d6cfb8523285c37f129e21f8833985bacb53b6dc52d18c86ca2623ae94cded72aeb483294df1d6de576fe28f39658be13eb7f105b5d151345e8b57022e6c6b5d62c1dfdefe81e16e882ba94c72639ff87c5b3cecdc731c8d16ed0e92d7a7db83f9313f4ee7a390e39293e5d8c291721ce7003dea1fff8e1edf461d032787cf5c32fef8c47f950f0f76698a8e7cbd36bd504e8eb45a75e28959aaf04b00e3c6c82ab6ba1cc0a91939a0b5b4344906b6c900e375d71fcfeefea79cb65dcd6906d37b9655365b6d62af7723f983e104ddf627f4f7b5e58de82799b154ccf04b2be416b9aabbca808dedbe67b19325663627e9693f00827f707048df0f97b4ff20018aadbe2f37bb8d9cf993eed7bfdf7d5b95240110379dbfa343870713bf7ed1d9adb3fcb05c3a7f430386b011dc844e395d36ddf895f4cdf40746514d2bd4abb1fa75fe9e8c257e45f868791421b0847166d53e76e8219c36a5f75b50b27a17c008dbe9beadb12a476a6b90847bbbb7e35d2392ec55e48602fe04c10325038665fb07d35637725f3cefb4f2231b17dcadc53457c7e125481d98841c19fcd7ceeea6391c5be24bf1fdd99b5bc1c18ecab5d44a72929cf5af6bf5f6e8c71094d0c69d98e15b56218eca1ebfb19e45daebb15e9494c088cf97797228b49df79a23524dfd8091fd7e6e13975f02caf97202909a067ffcd1c67ec854141df1655cbe8cbc9244440a26cfa3ea74db6890bd9dc3816fbacaeb8fdc51b7c067cbb5ebe6ca97cf6190ef66edbbc7e888ba45f6fee2b0552c55da93e3b2e7e373fe87adddb612e640f979f058e8f3b734317ffb1844af68e733f68d443f6ac13379f0a85b91d0457f5f40427dd223e0a499b5a044e0b63cb524f98071d380acf29593d0aafd77901d119d5a1a11decdee48d7f6d63a4b169bdcdf74ef9a2c84b46fa0d3b1de94a35ae9bfe4ff6761e0e8530c79444cc4de0ab97bc6cfcdf19f36eafeee9c1ffb6586351f98f0728f4400d3e00b3daeed4ae67c82596068315d1db4cae79e2900940f7578e3c15a38c4454bad6b75122a9f7a248153dcb0ee9285930ed2a8500196bd81c9618fcf8d15d7326e41bc7d2294be7a52bd1144ad82782bf55d6e2d824172242ffc83643f573845fc55b33372997c18ffda55afcccb3498531c4247a53b2ff18edb78b0b86d2838a69edb46ca069bffe17192ded1b7dde21cc9957b541964c11766b32228b9d655afb3b3811a7f12cbd4d5d3f9f2509b453edb6d93739f0a87dc8f43875518fbca8c37c00590aac72d32817c23bc4ac021da43c7233328f74643b7df1f20799ea4997a0ed361bd9041146296ac8dff8dd8ac62e03767fe8748cd2b82336c813c45fdb5f931bf4d01dbad27719762d231ad2acdeca4101bf3c3552770afb2ce5dff605af46d68256b4869144b981a243bf2984ca3c87538a77259b93d5427199981030e011d9735f03811f46900a5ecb1f0a086665fc6233af112a19f58f0f7bf04a12b1c00f4b5a07b0b5f5d2d2db1fd7af7f2c7db675408d0524ddedc3ae7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
