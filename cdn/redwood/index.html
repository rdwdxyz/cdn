<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0be0dc226303ac8711f0e9bc402d3d89b7e688180283656a735cda6bdda1ad417a582538faeb79e3a93683b594e1bf6a326bc319747d3c923862a68d129ea057a12276de7a002731858b399eb99a9da3467981b9e434ee8900998ce6f757c5c972c67245843389dfb73a9d2f1db3244fc72d0c79a6ca14d1e9dd0d9a45bd9eb28aaee6b595f02a36ea67b471441da7e880d556f7f9dcf149be73702639fb5c6a6cdbf52d7a54f50cf91ba52b07856e8f60c54aa41b1f3b5ab9f1c764841b64aaf4887ff81b74efa0664f7189a11c48fa7ad51a4b092dfefd5c9a20a2bc2d379fd5e506eec83b7aaf5717eaf925df0772b1488d13fdc29ed2625c0df2271d5dff8e63da7a2678f5d07dead33d99a585b41c0fd90cf11e9268490159d7dcc51e8fb72438f3ac5b30971ff7174dbce204ee0c6e4e37f9819d8ffa6143f622b0c8cfbce339bb0c1c98ae11d891eaa645146e80fd1e9491c3a1847179c5380c2b7d334915546ab17d1ff3f1081c4485e29e6728d52059b123a366812074d9ab3ba53716dd6c40f7f0f3da11d6794ebbf6bc2cc265d8f3d6615f1ebf21c609eeae2fb85c76da305a83f3d56183b7147c4af4f6d578f048c528509abc24daf3c5d3b68582b0e0a2ddadab81aa27e7ad63bb183a845817214b8bde02e7837c0e47c65f059353466f10b3780b4eebd4c34c14ee66011827ab6005539af454379f2cd797ba0047b14f9fa837db9944f1158fd956f4e07823a440f60ad7b3219ebaab76c8d796d604301d4014bad6b9241db2dca4be01fb4e72d054f1258d375b57ffec19e3b2f06fd7265e9938f6ce5d946e96bf46b46a29b1bab303a797c2fbe1ac94ecc8c9e0f0013be7d617722098e891a80ee18cc14ab5a82e6533b0ad0890d92b47bac732c40847841df5de3021cac09cc25e96b61d5077c8273e07aefe7f25073fc99dd031f7401805012e08a01544a901826938dbaf405618b1b7091fca30ee22a5cf439f93e086230efb778ee0168ca6ce7d3a3b9ad5d05318a828fda80f75c16bef70562a581111eebc7eaaf4fb1055d744ed32495cf7a2606152d7588d5dffc058b2f12b37b7898e15c8a808f0626050c610e178cbb5de05383b0abcfb5314e455e5fb085727f24f802c10422764d52ded1f12a1f223fea305f87addab097d4fdefe41f304b772bfed7766d120ee44d3888ecfeb0b182d7828d015b52b8b7e4d26b139366521f916833cf3f2517869ad009e7626e3bb4789e91137f3f10e509b0daacbf636e8fab5cc979a0ff3914b312145d215a56f2ef747be93c0f270b7c390a975efd75da9486b2b264da1e2a2531fc7e39b9647eeae9d110becc5441e95506ad3b035c79193adc901a32768d452d70cdbfe968c125462f5e46defbfe3dd507b0a6ce2e670c578e8e33c0d8cced3da9cb11011a23c46cf9927cf9ebaf0c133acd24ba583c48ef5526d45871704b106fdc2deb2cec9ff43ee569199fa28f2176b57802c627e0981b405a95d41af6a4d658e5b23a80ef4f134f13ada19fc9af7a44e004ed62c3705b4afcd13630c0f11b320818c3882f6cb4debc08b26b2529637d82bc15a0c030f2aa378d0430edaf932a1ac369024f0193829b271f22803350880dee5ec99e71e828ba586b45503b462ab78972c6a31e32d92523c3f7052bc6b9f47e6eaa231941c3b2e3c8f47bb91110170bfea885243d58caf71cc9d20f8bbdfcd7c97fde2ce5089933f28ad01c3eacbed8312895c88937512ca1bf0f896c22efc5e21068465cf115b6e65e0955f372010ffad0ee69a35349a28355277aa3c0a88255d6de1ef5058141b4f5077ae56c5b94283bf3033f5a60a893192fef71e3d6c8358b6504204fd4894f1bcd2ffee79b1850e247539b3b4f95d0fec4626d01362f8181c731ce5d65e783e933a204cd0893fb4e6e250548e24ba154632ba1f860e13834dbf84b2a4d60fb78aaadd55ea7fb6ca624607a6bf7919de4a6132a762903ab4646ad370e3cb325dd168e38ccfd27e93879180b76729b0521096260d46635f1c4b7790172dfb0388ce6e2dd444e73027810568b3267b1b6ebb82c62779c208ba3066287225b237cced0c8a1ed3be519c4de92415be2f3679d2105a76a82c0b87d66f22f6c4dd18f49976ae00c0e1119b68db0cd8bc0e167196e87f82dcc5be713f4a5d4c1f0a322ab95f1f220dae2515a74113a015c5c644330784430ba7e89b4d0e0064fdfae71ca0345b54db7f2fa11bdb4c76f7d5de44521d09848c7c166d1019cd6357b988495d52ae9a5c7079b0575c2ad8fe43a31c174f8580feed3c5abdfbf942454206bb28bb4f9c8c28dd3372f7261d012da4176c0a058c698c6e9144105f85ce31f7fbe371a1a7d37a71d82d0100dcc1a2457a86f5de1719f4b0416a64e5fd970cddd28159f1ed36a343a9ef1435f8dd52c7105438c4262c497f5c01314454742f998953458fdabc1e74a5838906998e701736b7777d7d75d41e072ce5ec597eefe745f3367cf5a75e5e289e7a6ba06d49c00810339308714baa494820ebeee3890cc005ed75381aad927393d5e60809bc14ca211482c3d1a0b5ea525f27dc9971a6440017aae24d5f86d6881417c4c9f5c20fc180e3949c0c3f4ac8bb94647d2af8492b55e087df8f10fc86da68772ed54b1ff79ce2dca81710b2ffeb00415834cd1ec8e2e61ab230c895eb1786f51b75dbe0fd898f4517671f8b0a282596f8b9f9aad09df61932d01ad4c2011d7dcfec52c51fd0fd843801f2fb17183cbc6f273af5720ddd3cb4eb1f9112a6ba941417774b3e8e4b718df472fce682370634763a2ce3dbaf24a80db85b825c0d8b4f7bba61085e4aa1b5c2a03f43c08594ae260ab1b1fdd98cfd9f1e1f75f23358b62befb47f78679d162bafc97f8c520e13194a346389fa899caae635fdc256541ac15fbbb30f73710524f6a9da1a42b9c21620fc612f3b387de3745c384ea1823dd1500c2e8e96dcd02989358ec2793b41407e17d266e7655927d4278102e263100229d2db36ccfd08387c9ba1cddcdb18a40f20fd04b0f9a2957885755cde5e0cda280f90da9f4f909e2959805299965cfeb450f5ebed487ff0ee419649197c6e78a093eada99d2437c1a8fb596a977bf103cb9f0f2962047286aa0020730944986e9589ac62982d112eb2d7116e41ea9b895dc18525a1740dfd597b3c0e6275d42ac45ab9ac212bf710f33da242307f65ec90c016694b473b05ef1ef3a624b1caca3a6e784f9f32009adc37ecdb611c674c2ca2c287f913a41fccb06ebeae29bfcd8b9e930b9474323ff72293599b84a72d3e476981dadb1565ef95a3be9516677d79487785c540cc15c176f44e6095c538d16286f9bbec06798850892e1937f4eb1696bcd44afab27a0233b8a38a85db9db204b572b80dc7f56487a94a2d27ccc555b5dc4cc8227251204bf86fec7f1626b53086807ffa18774b69f3cabf6518d73dc60edf3df2918529568f04c861bb37d9d80e2f1da3c8698db22ccbe34a4b1413667e8424bbd8e91b1a22eb7c9c12fbe9bd9b04a0555586793b00cf5c7b39c6641e1844146d632f6e92da06cb317b1ce7bc13bbd6820030957f3300a4615b4fec81d4e19d2e6151ef7eb7b8758947ff807c0e9b229e0df46744d35b4e10210ba1810f9157dc21f811db2158339effcc66d750e01934ff17ef4a3ca73c805de1c8bcb898d831aacb2170495df21084a7abd21dec8be2f4287db2729ce0d654fbf55c5a595a3b732d292da30cd0d7a14c087d685f5927a931df58ebece9e9d4ad895053dbbd847b278a68e209c674d8797871888431a793471ac8237cf33c84aaadf7dc14ddc426346ad1945492ef4ab75edb8862adfaa8a7f222c3efe67e0206ba33f193f80ff4437eb4f485368f0f5ac18b57579f3350ae2457e5d9fff8ecc80027e441ed7338250c5ea29e490a11418c3ce9ab44b987c44187ae31f28ddcfd8ec59de4d5deb5e7e6995ab5c06797b4ea7624b4760aa6b6167210fac3997a19471b7f3e4d5667cb31c7ce74241b3919c5edd2b6ec04f73d47b5fd3a7337ad5ebc1fbbcabc6f502734e62c6742cef3e51d5632d2ad8c0f0161144446ba7935073566035259af155c37bf9f5c1dd5bd32b5b7e8aa2efa002e14e795e3682e37c00de5bdc12f396a358ade37cd14531bf567c2852e22e7c9c1ac784efb667df270135eb35d97274c85d94053218f89c2dfc69f0d039b40bf29d3f0c192e4d4cb95a075f9a16a1853c7852c11a5ef1888d78837ac782833f7d93e466df08455673b145f7237f816e7b232163fc966f43911831c757b6da428569f8b2ec6cdd7c1b8b7ee90a8a5017a94efa4119e1855c93db39f757450c7702c5f5908ed988806e7936771ff4fab8eb907cde3dd6316dc140b8d0e1edd2be461d13ba49214c06a12ceb48a336a10a7d3627ecc755e7f8ce7332dad0fcbbc8a9743f5c7e47784f3623dba5a77b0bae5083417ed461d769c8b87f9def711d852fdd9a499a0f907efe6e4fcea0e60399564ba3cbe0d07f221b6e00f37c1941870fa66a854bf0a78d9c7a3dcab577b47c7ee57e352649691abcdf2a0f473ec80344b9cce582b82f7955a0daed0e732e043e5f335a38f2deb4bac61156f3966fe24195c2c0c69ea3d859657c5c873322f5b23073fb2f6c308a648b05e8cf75335080ff0f8622f4b6c4c4c80e2739e7af74d86c92679b9ef8fe41e0f4cd900d54306cd86c4517d8b387fad522094adcf98aaae6d60b15f3b1f8f976d9c46e20c7f36b8e6eb34d3f04cba138d3e74ce524add80da2f538c6a597e5a5a802a54ad9d67b6ffb0cd0e3b65a5b03768c8fbfd46870612156be0bee56bacf3f2e10ad45fc3f1542cbfe98d7ce4af02d4c62538285d62ebca4b9ba7379eab6f539151985b11c51f547e449d9cfb331736771de253153a566e8e7a4d5d6103ce520f77d0b005f6bce2e322fe7c6809a4d2535c0fe6a9e653fa92cf269b267a1e15480bd065ec7d3b2d50be14a4a07973ab09d9a497fb6bd86e9a6413d151088a15193f2c6128155ae9c20d0795a1fb51bf5de07b48b1f60e1be26b3380b6899a03191d2ca31add79941bb01e193b850961419f2f0422e110e819186e5334f505d03e8a77015ff75721c944b23472866ad7d9e54f83c0b12512de0986fbc12f874dbf903e5fd4d086ff65739297e28ec25ff9a69116d46b6915eda49f41a11d560ebf2f2bf13e3c4e600f3cca32c06614d6c80dd036743cb214e797ae76209dda4c3fd15f9be72bd345395699fdd0114700bba890a592a00beab5ceb8eee72421456a561956699867c75d40eb58186e53632a4366d271c62ca6c9d58cf0ef754e8acdb16596e861b874e573c376e8a98f58574b9360741ef840d820ba87ca14ecb8c58d2dd69bbecbb7baff52efa57f0f0cfe08cf3732ba1a70aa41c36a8a43b563029005d85f4fe643119b9a037ae0416c9a0569682a00bf1eb8d1e018e5a4ae6c4563dad9ef65d7e83dc9e13877140dcee4d2ea4bbe06c70dde074b83e94cf29447bbb025541248c28576493db90b3ebaae7c8a36e53ca5aabd0d5307c38c0950e6d5a020e46d620a936e3e7f9e5d09c486778e3aac85785b4b073afb86d885beddb5a5bbfc876fc79e3f2b380587f3569e8cda991e8a94d72d304dc1fadcb2b064761a7df4b70d7a10ecd808bfa5e45b65c9a2ad724d0be007d185ebc95bed0c497b49f3207b37ee8e66dada9d47fb87bba0b717e1aaaf3a6a15920a118810cb892fcfa96fd45f416bd71b0524edfc9b6d37faabbdb9f3b51db648f682f7e4f45b98c73f9177455733ff3c462c6dac4df9c9f395698ae774d90993a7c4361b97eeb9f324e9d8033dba9b8edbbb979bba53f965fe5512a907fbeecf93ffc0e83b5c03e413ace0d7d639d6f89dd97cb269528d6b4a5be183f2b36b6d1d7f14e84856fc936cfbf232183bc78ddbe710b7760367e4aeb78531aea23b997df8dec0aba0a457b2ea344e193c7bc1ca8758e685f79a1b5387bb03d911250f1a6b3450256223acdd77b216ce42ff838d44c8616ec189b120c20dd49e78d7e5c668fd56303c5a1a3f211541a8a15e6c497c2b30d01062d0f531a9ae72bea0f72468301de4499bac44efa22c3f59f11f448153eb29eacfff779785c6f17471c2225d23fa3bd3c6887e369b96f27cb48358f0d8a9e8b1006b921679db85ff1658812a3d476b2ff0f229a7b4e9986438750216119207d44962a1ebe14e987686a3dbc021ff8390accf1c13c0ffa44a72d612f030641c2931d258ea9d258869f4a2d21acc910acb03ba3d68b10f7a37bd23d3bf49bfa6d5d97e6f452793f750627d2fa64c78965f3f9eac9e8f94b4e9cd58b4c750ad4ded32b5196e18b7b4e30b5fda7a731184a4c80884e08a276a7e35762804c9bfdc4b574f2deb1cec136caf9801e4247bafffefd06a24f285ec57671fdc7f0bd8fec8bdf752443d973f6055813a9cce53f8d8e43353b4a19abaad39b63c24f849b7fc57a766cff50de5c1df7c7279b653c30877b4b63341067bfdddb799a850fe6db4eab6c73ecd954b8003b0237db5edb2930d55eb0cc0e8fb95603a844b91065c2cdbd4acdc9917dafb3e61993c65bd3ba7a9ca0a5564cc9c92c00dd8c75c6fc3ee848610bc46cc0597cbc95ea9ab0d32be6353171d4ff5264c777287d12e37592a2fc1019a0cba7b8aca1e196870b558a9b2687d57587a3399ac0a0b20c9463ab8c70fb9fb65db9ff328cefbf640d30226b0214a964f87910e967256a71646bc5b7af9941e40c4f0244ce9b0f486785953832e3a8fa9dd583d1e276261420c750eb221a59c342217a5819b5e3e3010c6bbfaf102d2823a49fc71c04df70b436fdd892ff1c321fbca11d0d9c1f4d8c7e51afe84f03bf46fe1822c43ca6e79b18f805ccc1281cfa1ca998fbbd5ef438596f7c4b9cd52fd97947a5fdcd079d817854ea77dd833e3d27f6e06b60c1fcc47ef1f2617904711cef2513fd4538211a5f9e5db4509146b819eec7269952c46875c718ebf289bbdfd7bcd5d7565ada9e98b1a2452bb55bf965152c100384ac991e386158597e216c17e5ef57dd3eee24d4d32ecdc6c7c802263730cd617e19d58fca6debd2a25e6e4fdbfbf903d8aa50d0d0b4ec2a66fa1789acbb3558686693be26a46cda97d670f3afdc4ebe58e41df994be5548b0079370bc8c5abd0eb2df9235e2c8caf3a1aa0ef73e3f7a453d0d62b9cfe2408f98222b7f135e8ca46a9aea82a63ce490a33995bfc883bd32af1bb623fba852e8f6ce916aade16085e9e9a24c5719e89b43e62b9b7a91be91b37bd1039813ecd8ec1ac4c02fe5ad456c94b9300fc5965f41839d185a3c307140c1cf2c3c86b96c3286170058550639c44fb2dc69257e1ec32312aa7546cd57f4c6ea532e6715310a3dee0ac480ac65466321cae95826adccf781213002e7deca3f0ab4342992a74867595e710cdc2d89068303e0575e8da8cc347699e46471c30fe9780acdd011dcf454ac86c7f99f44821c63fae10490072f1de7a26e6c175c54042843c884c73ea956c6329ab0c6bb18f2e660584eee7f41bbc9439a72a82a00d64b1e2360628c7cb64dffaa832c6089ab5a3d5675b9d5dbb90a1d096cd5136878672ecc4df7b276649fed6af37768a5e2e8c077384b18213a8ba5f6294d809d5887169b9061b1ee7861444508d726645eb05c4f8a447656dbadd6e01c403063747bd3d6121ec1b9525b8b2c8ce8db22c704703a5097c9edc26178e50f02d5fc99fdf5d871ae145c97f6e7aa6dcb65be2aa49e63d51498795cc20d0c2e32f906f06c6b67b00c3fcf418cc1ee930ffcb8f03aee45898592ce0676fe934a5c4f2def898991b2925fb516ab8946c35b2d179f6b6494229bc6941d365a27f943ff491b6dd80e3cd5446bf674158925787852ac9d3fd7f73756bcd8bb459c9a5b63896d563bbb3add84b89e2e199626378fe1ee6fe23eb74b82bcd430da60a5ce440f56fae3abff810b52229c040b9e7fdd108b68303f644359dd7816c49f043806a25909c1da05e3dace73b367b369e66936fbda82c52cc6f932d406d81418a84b5a565af781a75130b55ef0f3c555d3c633ea970f9b0d58a647bad08178041e4eafc390c2773d17897e28a36e2c5ee0be6470a9dd81a08724bc75a802b27bf3858bae495be78a5720891a44b2c639b069a519a34e7d5536717875fd73d47048de1162b0459f87cf5ab59c0e7f636ddb81352b995a49c8a48df24b2e3f752d5c3757f40a53dbb205bd4f4d522d684f1f94fa79674054d85b00876903197bf955d31a051395387a57bd2aee0fb579243eee2aa68808b0ce6fe10863593bc735f888edea070abcb6c6ea1b0730a3d5a4cfd48165b9f34664f8d4b94ad510dadf1fc7cddbd597d40ddf1bc0ff691b45d2c883ad666521b98726cc7151044e5261253f6e757a315a1108189ea6c470c8b9e0ab02c81d8a25eb00b7e0751540f37bda6f456dfe550516ff35b7b1df9e9e2e8f05e8fe18f9ac69d0646b75ad0fe02d2e6189df3f7f93283fd7ab1df1ac402acd973d9b6037ba05297ef448b43d063da7e09c58006f1bdc4b86ad04a556b8cc74c81d6f610c0750cd22d9fce43aedf82a2e5e2bf0ae5b7f9a5e4ce86a919d7cd9e969791ae088d7f5ea41e626deaecefbc8bc05f8df9b22b6fa6c6392993fad4663548c629b7203c21ac028c4d184b83db56f327799e4cba5a94a041f76fbb3d9d8677d76f1fc052858ee5a341523f67d8a2992ed3e51594b0d02b4118ebc00e1f34fa81d9d0c5248e7a78d628ebda1dc5761b258643f21926ebadc80338658b06ea4304ea4509081dd657d545300eee336feff0251af548335e8ae2dd49c4437c6eaac6b2fec0372d76d19db1683919cc143ad99bc7ed18caad6503799d5a1ad5972f5e58b5152c4ab7027cbe9bd5a5799dd2c1f20fc9a860309749ef8d4e84ae318071b72d806e2817de5a4c83761b63e9f412b3c7080262c5ebee4c9d1302181d31aa33a5cc6672493aba3a8cc27aaa83b741332d32376db9d863ac0c6dea4bc2fdf344688f27aecf63e89432d93681826fc44277aff4b53d3e7875ad5eb4a44ac9f2b121d8c9fd265520aeb4a7bba45cb217d5aff8032024c644fd854baa9999701e850236d0ea107136c9b383b04a3fe6caa182aec9bf63656396128bd71d9c0cd26279e838cefd8e77f08de162d45811eeba3fa4cd7d69cadda6c4bb67339ed11002a2644ae65dfd5078d4c211c80fcaa7fcf485340e67b53f209c14de30abf58d875c43fe414b38be7e76904b44475f1e565f4491beac5fd1f9fcc74e2a3aa8cddf37a38075da28c495af7c801365df4e7c417b0efc8111f31ce15c695580e529e146ba7d01f4880dcfa0c4a2491d40281eb0754cf4c118302bf0648b7129a793eaba035596dc8d2d4fcdb1ed230e3df189d74fe42e8491e79241162bdafdd26cdf30db09c941e90d2fa32d1acf58d16f30c305f05add507c0d6ca128d641ec85915160a5cd16d2a051285126c5faa560dda2d58589f9bd2b9ff7b39cc36d1900fadcc09d4ee33a20edae0280d1780ecfc14c028fc8012c95910da0d5597fe1951ca66f0968331981f269d3103964c34f55b6231b96ba41549680a5c5cffd58e52106d407b70e0b7ee2974df5d4ecd62237ed1397151f55566247e81837303fd7a9e54483e3ea01c7ee23bafc5462ba66f83dd93d3d13cfcf1fa96efbbc3e20560cc2c91778eba1d4f9f56d57c4349d7dfd6ac0f8225a1e9b9908b48909112f4154ca517e753f8dbb4bcc50c793fc9ec62a93b9e432e0a9322146d6a0f0fe4a7205aa18fb66f297a10c38d61ed428667520506d9b15d1a6beb679be545bbf4ff8f2908e9d1e8e1f9dd1ae98adc12948da46ec011843c6db566b773b562932284291cadbd8cbbb94c34b620a4efe239265d97f4befe050f460f5a4089f5cfc50712decdfbc5104ae31b5f0da394aff56b5cb71b83c3f43a20fd735bf2152d2bb7e8c21ed111670e0dba144bf17f7ff47ad02f4234f3a59be844a9b5316990bcdcb21a42e4f58d83105d7c533379ecb55e4b149685537175c7cb3c728d56970196ca9c413eebb9645de20da3b09eea96ed4ff59407b32356be7c126fcd6158a6ee29b4001eeeb457b21d5da62b00ae58fbd0a3568d48831837a24d3fcfe5e80caccbedd407e885bd8d0d7328c0a5aca3142bf69d75698dc400163e574f42d0eac00a489b82441bfc849089b8492bb1ac0805496e9d5718ff35682a82eff7c2813dc5fd77359ef9d7b31e07617f4afb419e8f4c0d3ba345e5b8f3f7c1622c1c1b211455dd004e79d03e9f15abc8352e98d304c2d0967f55e187a4a97a78bb59c721aa34553f2f0c08a799e937b1bd913ca607eb8f7d70bd06a9ff12c10014a5bdfa8e5541e4f5eb0e35444ebb7cbc14785cc14cce6952aa7da2bbc88f338d72de73d6d4b38f9dc44269673826785aed58e19d67eec8cf4b2106445173e2d954c75c2501a7d71cd09e858dccaf92509cbc967b49c51ea27e1d140bfee3f9df154520c95e624738d65c5318120efd81a63c9b3eedba15c5fb764f7405b58be195cb6e15ec908d39efa4f899761ca804b30bd7d437404a36379c24cef56c54fb08a26f91f97da23bc4c955e0f64e0b1d95f6f082479a3be77e68f468fbc68d84be9e9b0f074285d2ba67c0f4810ff9c34a387722a54d40911c2ba245d610559c330b78d8af6e3554a4b790cbe8833b20c740ffb1b569e17f8113b3e6fda99de83d8f8e1ab35afd0fc836c81b5cccabe320a32dc825f9f7ac5910155290c80c40d2142b996be465fae0c06b54cacbb06d1430213fb9c1683367b2fbdf6323b30d4e2b8a5b83ba11b2a0e945da18acc764e5cc8219daee3adb85078f7e3eee68e9168268c191da563c1151434c303974e0ccd1c5243b9ce9202294751bbeb00253a20fe1118c769e6c16ad67fa135d21b26c36bbe8761593759f82c7f3858c5dc6ce3303ef81d63b1a82b6cbb59b47f4956434426e79f5e75f91269fd2b69da87796e15437c778fc65c1b04a2dc09c8febce5caf6c2be1158656eb8cc97387260875dd659eb8537a890100a0767ea9bc8d8c0d43aaf852e69d59477244357cf795b916aab8ea9aab8a98922660ca9a6443b6f6f29742d6529e0428a8c2e813f72e5862e6bb8cd7b5d72b74d169590ccdef4ec902ff73dd77300954a22bb00b4607d705f61626b08fffa7c8b5450e6f27d3172b35402ebc10f1b9b6dc4199a7b283115ddee1e011977172dcf25ed7b64a4ddd6dded9b78f772c4cb15e9ed4bf463cea9f82bd04c30adbbd8a87bb48b877929d3248989bd08f367f9aba451d89edd09b92c3132b2aeae1c3479ba928a2c77e17e5cfa9e8277d0fcc979a21ab945f8926292d3304093be120ae2efddbeb1708e9c6109067de458ab391fd655be68124c457930026e6e7bf91e6419c347cbef2edcf403839b9e5652879b48d2c65cb0f108d6de48a763af9eb569b0fb61da2cad28940d20683dd3691c99c4b9863b93e4f11b8ff1967b5020da286f5ffd6e12accbc33746f890c68967e8bd04bfdbaa0d1f4ffe8f4a4dca6b6ee78386ca156866ea314b781613ab2245e429a85d18e0ca0db73090a01662025b06164115ab923925895726394c68008eca89a52959616183bd234522c6d1f11fa1f494a0d5246249847dbf7580a80b2c6bbc263336b342519a0c05c4cd205e4890b4bc30f5aacea37e64dfe70e855e1d7724a3726ff95d47bf865d7386e83d0bad2b3f665a25e2a4b2641c83efed61ec83474049f1a6e0cabac283ec5bad3f6331d2de44119fb4decd9c8875fef1f3e8de0edc22fb6ddb98a06e7f0f82c939c627da69e9dfa38a730be4ae64a2b037791dd023378d7d88cd354d934780e87aed7e07732ebbfb7d19eb28eaa6c45e5b6be2e11bf7920886ed6e2418dccb649bc40c659fdf0bd3a031104ffa624edd8aa4a4e7a671b8455066a8e54e7293e44f3cd56794348c6949969f11184109663d3315dfc6de72866d7c8b926c361e5b0e5c0ca26c5be2b03be432f451e24ae319c6a1c8348258ee58b8de71256212fe0a5c34c3bdd8e43d3b87b93795df4129f4621623dcf400f38850ec71aa479d9a0921bcb016516ad0217e529de741a09acbececf48c9ff21dd99cf96d2b53076c8c847dcd26279a80e3538097f284938591b7fb160892466c5eddd15e07c254459232f3582f1e5a02acade8ecdc52258fc014f5e0daf79a39c198abf89f777fad689123d29b7ad1d6916602bf5304cf3e7ff872ab8f298fe84f227a6ce7bc66f25f8bd74f676dbc98850f621d65e89cca3519af85605ea920e9bf0c4fcb50135beb27b818958f48b3ce2f918c844e29d4c97666da087416c04ebd80dfaa12a918f0fefec0063dc84437fb6eea000f5e72084bd895e5bf6e0fc026b85a4f21491dae09d0ee149540cc80a8360bb15809732ed055291531e2583dc31401baf9b08377d981ef970fbbc907e65ce6e94af2a342678fc66630b587836994f938162024f76a7a7117a4d6b42115e63877b8bc81d4ecc66af2dcd9d55201e9fff73ec494b35fd702b1caf897c06bb2bf171f7a6b8dffebe4bd74d5ecf76ae94aa6d016c3c18e3fff09a1c04c602d177790f144ccc561c8ea35209288301893d53f2d0fc4ab73d6a7c96899e9076c50864420367ecd82546111896037d30dfa6121852e5b697433dd51c1e06fa00479427902adeebc17cbef7da68530a68d429cf0a843eb541bfa32323a0af8df1de1c89e3bc505c627d491654e30c6bb5ed3450aadf0fadc0a6ec072213c8e4faa5761f33c637bcaec4ad88f554c3b00ef7ea37509ead7db6c56dfbcdb0f7479d990b0db7526489317849dfa3188c43ab1161f424b468d5de15493cb22efe1fb9e6d4b9e8b0dbf00b4206a27ffc088000df6829c538539b61e406a08fb637c83cff128ab1c3dd62da0f01582eb5acea645379d3bface61a20a25146259e41ca521ecba9f0fb3daf137ee4d9729641e9dcb11a65347780d5195a7cbd1250c5f8b0258ea8c414d143b3fb6c60e969651c01eddcf86697d9f2cf13ab6481dda071f05589ac8523eef1186226e99b3a2f4ec3473f0242f5d465c76a31ef78a950ef06a05be27d63aee7add7767add5b1ae1f3d39f49a2a5ba4b7b2cd7c7d722c9816c860b99f36ec2d36a8e2a192e3379c30f3654e26d5786fff567ac595243ba5d69c9dccc3b172413b4c7d42edb66bf4635ea778adc565412f0846e958aba4ba383f308c93151d7ad18d585db74e246d87208ee9d0692c0e4e5aa76f1eb3540551b1f65aca377cecb13d90ba50967a16c64d2dad468be8ccacc178f6d386dec9d48fff6633f32190e598f4cd4b4e9c1aa505e6c1172031f5d7278e1c931464535873088504521761c8cb551cf2949eca975efac1fa5dd7dc2861d5d8669d0eb6bb8849d82de6872be8db31ca64fabeee897d6a97201317fa56158e59ee1f918b9ba3c33d7a66db3e90b68dbac169094bd13aa4d08c371b64175845cf4105842284ccc7966a0c8644ceb5c0333f9276b04e90a5cd98ee7f9ad7cd7f6967c8cfe8524be81f677897432145e77638b6735d72c6cef2ae1f646645d0f2460744787a8da6c408727f723a8f229fc1218539212b33a0a6508e7ee74912c6d99f9fae3d9e418ae96ae79182d41bb103a8a7b9bc414f2fdc05200f721da70e10803a16cc5f4b8250e0052001d620c00bb817aca87283ee24d1ba61d98f1453bf788c6f386aafde40207c73a3ed9ff2a0eab95aab6a03c575acb77987ef304d1252df6f77c911a59858a0570113adcd140ab6254a415eee1b19baa672e2bc9b0e6b346365758b9518ab3bb7ff48409782f9f91635baa299b00bd9b22f0483a75d0215d9b8ac52af8d852dc14d49eca96d4148e3e62c4b73c0d23d2139bd92170afea69753f4c0f0649778139267ebffae8312ca48b17ffb38e086b2bd347ebec1e134f5ae2be98ecba031d212033459f6818630485b372413b0280005e88ec3b138bbfb9950cf7eca3d1ecd2be21db20204f013bad5c21bec5c2794800d97e0d497500fb5c3377f45ce93d00d4c3cbd9e988a498fb775d8fcd3005121a5630a32ff87e234d34dd4bee0e31f8fde083e12f25f0c15e8c0d71acfd06cb63020c5f622ee145ab550ad525e81e29c6c73c6044b267453e64bdb41d43ce6681bd1bd747f170a319ec2f4ba14bbf6ba86d778c08461405471f2832fa470366e265c40254565d9508267d3810517a3a83a5627a307ffde8ce229ddd77cbcc01c40ac1aa86b6ceadb4b551e7f5ae7ebc365484c5d9b78cfc5445d6fc815629803099f0f4c18aa89974ef124ceab203763abf456d4e91c664ab30201fe2d0fc5b6e34c1be6542a1f54228e2a1da73117108985d7e6573febb0f8de6dc145346e17f2fe5c05f94928fe6815da6e62614285fd59b4c2cc89f12a7c5d614ccb1f79ac8d33a65faffad70b3844f25c69eba24e301b7e4d604fa1daa9b406773fd7f05a6ea69ad411c5d29d92a576a8df94af07f4e755068ad37fc4be63011e390660c0d5c119ec624e920b4af4e10fb8492b37b0444ceb07dd63d48ad1819c72381a0644572e9e89b549b5b08563554a52ae319d75fa84666dc6b6bd8f13817c02b1df130e5e3b22687513560252e1fbe5c38ad85271ef3f5ad842ed1bba280318ba96b00a62adb543ba72a3cd7d9313946b6ebee1d0c0034db60fb35e7f81266fb808c61438717e1fce0fa5f89000630d7e7d2b05152475aaa9645b37af50c283bfc324aab23c745b39b7f2f1d93af82c817ba575f35419bfcb6cd47eed036a08c5bbc1a3c62dff2d4cc0aadbbf7255a645405e1d589aaa8281a05cdb79241131cf2d733df909b4af45fbdf639df0583a7c505cc064b88ebe61e75dcbe3f460a00a850c9692bbd2d60ebea3a0ccc8019d4a25b2d5acd8144f030b999374ca510290eeb719aff1057482b164ea9d980d05bd0a04a7b9643eb73eee26291647aae7735928b0a351f10070659b28a40e83bc2a7ed6dd8cc1a491c490a73375566fa6ef80fad8fe7b6dd0243b66444c0faa9347d66614a43d24419eebc9e05ec34a4618eb52d9c530853c35041f8729c828825ee776bef92e9adf60ff382fd74d56938fba863981b51258ac7c2b687ddbc8a5c635b81dadf1a74a5cc1dd2d5b87769ba5ad70e2047592f6e182853c2f113999fe5d701178c53b03fed79e7d5b105d36bd4db8d9ced79623f51cec3637dadcafcf753878195d9cf71dc6efa5051fc9e7c7ed3db21421cf4013c04dfd62a7efb6a2e7e21ae3ff0eeda1a5612a6a4dc7792efb94cb6d5617d613406a7b9b38fb08755f1e1adc76c4ba426b2b2931f37a5f0904d9bb62815d250036095f6370d0e9c2b4e6fbfa3cdb0b99b4c2d6077f1f8f8589cd8b5d34a5250416faa2544c2ebaf59db53396354b860022c30a49ddb7e91a7084d703cf58b78b65a56968853660dce5a667b036da53b72d4737b545c678c4cbcfea8e79d3fed9bdddca8d3b4806fb590b95753a4dddc074b99b1a8c790d953f3a250df91dd00f37747d602fd5dad03d4ac32828a2591f0477a37f80049e50424b6bd2625120dbeb76d3f853827027efb85d219c838953b8040df05c8224d98e475bb63ce45c7c0db32d85ae54ae3f3dc33608c074d913216c90c4e7d88f2249d32b4ec4b3691ce8022c81eb0a127bd83db66a21410249c4d6d6dc49a41a8db10d990f6a1a2d292d658ea30f4f3f851825033e4bb1792f3b97d4fcef88263cfe512f30b9174c1ee7be62b2ba42defafecb3440047f0accf11c51e40a4d48b05b055e53cbbd87a4defd56bd8a26d47d1cad9061186f6c0946b38afd1202accc174d4d15ed9404690193304792637b56c9348360c67bbea42fdde3d24a70b1564499279c966d77fa5648e0762b0070d3e1f2626b7a75b1bdb11af14dc10dadba51e8065bdc954fe07479878b0983d5144199c12147fad0339f665cc39124d0135b0eb083bce35a34c5ec6bd94c6f44369a7a8ba22fc8db6e5d7501fdd4e5a06f77c4cfaaca6413d536c69026933e99b298e2c7da8a05e6709002bcd75247eb9d3796ab7397e5166f8737b1d4bd3cc37c9130cb74b54e6d7ab890854e351e0e450418a70945bb04926ce666e28d82cc975615b0786c1c3bd062b2383b01e421c249dd2a86b560de1f1506b37625b13bd2787cce2e8e3ce302ec46fd1c7bc19f651da9b2ae8befcdb5f8ccdf83503e2fead2e21edbcfda3b2ca3784363df5ff6f140ce914971eb46625d3b4de075b592a67c97e3530819398e0a0cb1eb5ae391aabe30be35da03538e95d69dbdeac37a45e9829c6daa6eac8c11689eb13bfce73fb46187160670a471aa3c41a9315a059e25fcdcf05d9f95aa7b107c892e5691803c6941b499a023b70e9bfcb575c6fc8670f4f6184c26b796d473fd1a557ffdb804e648817c6773f5478ac31c25a58f7a6c01df2c0d2d0127f165861d212f3f0820dab9b964790b17a486159fc10651afc3276f2fcd96e381aa522468531e7ce9fcbd746d2c3158c1315a00ace283875590c65000c746e144f2c9a8c80549eb88a7c7ee35a1f52f34f3dd19082f3a07e3c3974d3a376d6cff71becf4f89c83ae89ed11ebcfbd3006d0cb8f0e4d70ecb990901c03a69dcfcd7cf4e2df1ea4315df3d4afc98ab7caf5108e42c489c8b00da8c8f0e31faf3997939d59de2cf8522aac4578b8a5f3d39e1d9f4191fc16251c84f9730b9925289eaa450a74be16f09ff0660689a9462a598d38524c4d9db729c25d5810abfe3f0c1e523741939b913599f55de6264e2c798824fbb9aca5e37b6eee8f9015fab0540054a94aa842950261b08b6c01ee06e8647eb393241759dd4ce2c65632ffc6701dff57dc7ba3fc08b6c96aa0e1c8c8d6d65fad70d410e6c2063603b30faa2f77e27251a3ad9d775fcdc72c2502e10dd74586562d3d0acd23c948e0138fa08ec6c6164bee2c2b369d5f8a744c7303b9d047a9a79d988cb8c6ac583a67bb136f319c8b7b4643f2c25bc800527788fa973b7f1c610af7c7fc7a05536d181d42203c62470a266ccff5f1e1f1584ccfec4da99d0bf28948ad669d5621eee8638a5fc4b275d289ded86d96e5f9a708dc3fd2d2a5ae8f3b429afdb89001e43f69ccb36e6e4121b2f8488a5f4fd1799cb8645206be6926797e0472e4930731a70f6402cc4d73cfcf054e6fd8ad3bf7fa26d1e4fdf436a8f065c6de85233bb5ba6c3d3bfad3f8677d72851b2ec150673ab2e8d79dd4e8698a464bedd5d173055ece19849ae89f446a3017a38c1eba5e6992520b5a602700145f6dd22f7194c84aa91f4600f51d9fef2ffc1af3e2aa6b6d2f2db27eaf0f0a71e19aa0f0e649a08fe44cb4856ee9899358f58284b3a09d2f7a087766987481117acd448defcfd51623618311a9832897cec1a1542497cdbeb57cdc7b1746b89157c2028474ff2c70082784a8e1037ba0d9947586693166cd1b3c28f54100b2cc2e152a581fa56d3951070ef7e569efba1c1d5a8dd91d815a981aac51298b31bb59a3da1aaf238896e901d8072c0c750b7cec35cffb226481e7306a848d6cd24dd8b3ffb662b2c2bcd596f0122805851610e49606d9fe9227ec4f04791396e99933fe1490239ef167e658960a79ff700fb6b101c3007c4755cde1f17e4826ab0b944cb75a527553691906f1b1721035f5f954d83b712b17273798bc952284d216651a719c731b56df1c810a34c38c5a0e9b45506c25da489b14ade74f7c02abb0d1d4943efc204db50a5f5d7178d911d3cfa1db85bb50a25997faa3b7ab4124bb385ef3078d2aacf1c0f929728390f3fea6cf73997b83b3ad99e87aa342b2e597fcef1d4270f3ea878bf8d9e06e1d69eadd478e3f3e8d1b9295ac61f3b8b5f10f59482f4db76265c279e38e3854800da2b0e91f491cd04cfcd76f054239fbedd79eebf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
