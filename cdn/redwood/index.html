<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0cf6ddba368662906064e16f14e176ed9cd6d9a2e3d5c66579e2028ee5913e52bf239bdc73744dbaf7ceb1600a660aac96684283c311b40888c4f31f614c63693f43bb4f8f62f49d6fe9c31aca013b9da56632c7c870fa58cdd7b6038ad989e3d904712885a23d1959034660e0a8e5526c42c75a69bb47b135f8f3fd19571b810a69f0272154eee32cd46d33da205fb06949671f3031ff2a83e0560eac7761624c149d3e8e3fa2ed1d7ee7db982a1e086d2179017367aeee775f5f512c63c711ee830f44bb09939a720bf06571f02bbedb5558c54a2bace7fbb0c3b152f617e7ae1df9b64c0a14c31b1775e468e5867e16ed91cdb32b95872d8845f224eef85c8b253150fc371cde8d0bc4eac0a926af01935dd1927910c34273b6272e397ead51ff9006201cd0b4b6eb0f0f5b1a08804c9b3a1292bd186f9d2477ec41a2af22082276a18639febfaddcad957108739bec96dac9a38b1fffec6b6b5d1fc0545ad11887a5bc64d88e3d71f0ddf50bead9d8abdffcbe9bcdbfb8d94b75588c7e7e21a192b7d09abb1ac9de69cf669812e8da7efa9585bcf9bc7824ab549af94ac5d0d5115e3149a3d8ec4d166b597d00dd560853ae3918e2839ccc21d2b3d95e2f1400359205f99f00af3a899912f550c28b9935b0cbe8aa758c36d1190e25cb0d4d8404f03a076d8b50f7ec107b206dec98a0b33d2b68a44bfd4f0380c053575d9f7b8d4b6cdef09c4f90aceaf3b8b19a3f7908cb7c503d3a2a751643fa8829d177400b1f44b612ff53327616f81a2279f9f3418f3cf7457bcac426cd1861cde558d5462c699aa676e1e315cbfb3a05f1f5e4ddf8e08879bc03a886b9aa5e0cad398b75a22590a9f487b1aff32b90a4c11df2c82e26d41c5eb2fe82ca7f05f9009eab93042f1dcd7598702c873832f1d74069ac455de363d98d20676ab1f21d09406e849916709ad2ec07282abb8af7c60f188f437940420b07d900475c173a354ba369e5334a191d5dce3aa4e8f9983faecb110ed1fd8459ce8499ab9f122698f4f0f796a716ff05b5593be6b14dbdfdcfed272c5cb2831e15a9ee446e0bfe2d6c670530399a292072546c4cd05d5301c11f84df4beff9d50068e15b3974e49dedd3b0cc2bab76cb0ee47073960682d693303b64ffd433ba614e300a9058fa7ca47b110dc4b40731efb483eafa280a1f7f42120426b945c6f3009d35b54b504afd1889d42012ba78e22622e78ab00a59400c1df4d9921bb831c7f3789e986a14e74df1d98a093ea7a86b0de691bf543e80773c239a06bc6af4d19b3b71ce08a2cf67959dbb46290ec24b31a2e1eac2f95a68504babc1abbc3c7095701c01ba3d8761450cd14bd41590d53551c152a517186277a973fce0de65f50f28e969aef07293b9448f8c80eb39906adc37216327f0b56c09cdde11b80ba6f46033204f4707c89c9fd1d560b37dc476b3d4b5e39ab81e251df308db5dca6aa837fca49d361fe3159f6e843fef36cc39f74d0886fea2d0afec7bcc772061b0799e80bf9dbcf35200b241bcc7b4d0b0efef59f1ba2e475b8691ea14794825973650f113b83e96f5eb477966189900ca09ec7830eab465ba44c4082cf2370648201be490b990705efc995f9f12b270ff1212964b6b2ed43bc20ec37afb39a20f9941d295a805ff640d9cc8320378261e5a671eb29f4d11d68a138cc8be31d6c52ea1d1523557ce9aeac57c3cdf414ff6718503e6fef9380ed604c24474182a93438684f57177b5faa689693a4bcaf4ca936ebf27acfc5e980cff8c88d2a72ee62760ee62764ad6b8097acbdf81a665b4d6482f3d0542cfec68505300da32594a3ef95b43f4cd5f154dd29e244ddf4278016a7f91189bc8c567a88c7b8015adcfa03686f3a8f399e4f615d33bab4fd1a5b0409e027f506ddd960aaabdf01791782fbdc4bd5e77ba4b01010161d6f5a5510a9ccb008f587266d0657d52cea6897b3da8540608ec15c1631c2f94e02945420f1da586cb1d682979c6ec0c2f6c8cc69976ac9df969a2500825705ec77d2d14d6c5b3a9e861ac09602638d8b5f38a8bd375e790ff30a42df5d941a9bd5083aca4ab80e61e581477e97653fa8adea9b173bdd4a64ed63c0207fe5fda14b8abb10268857743398611d94ddf06d82ab510793a5778f7aa5a03a436f2bab42f7dbf23e66d52527ddc2b9395eccd1fdc6966cd58e5f51b65dab9cce2b21066e6fb94257bd1abfa3401365899883e00e711f438521d429a430899380ab76bf7693ec10e24e1cd062e0214b46fc04fcc863d47ed5df0da5e44f82c11c1326c533630830e5e2ece15c5b37c4c0a2015351bbb9307385ee3d30405dbb5fb8aea7a94750bbc68da19d065d8b0780b509fef305d61ef53bf98c92530cb73983a8952d224bbc77de0982af74e7a9cd583215deb3bfa75e7f55bd41b2f99d033492adc6677b08bd817b9284a12be926433c7e9f462806d9fac4eb5c73b1ce6bd5a43df7abe728c14f730f911c046dff47cd52f22ce3503a0f612a4d09ed31a836fa72f83cd0add3400dac22ad9e6242018ddab72ca8dcd47a08b108ed2b86751deb33db91dd30ff81be0502ccfa37c6221f60bf689a94e80b03f741e38daa125e0cfd14a95764019d2572c8d1df47d12f6f1853c02c2069a176b07d04afa83180f37247fe6be7bbcd039a1ae5c1b3f466b0cce398aa68297b2327e1e20b9cf201d2246e9495a7dc3594c9ffd1108be00a7d2cac0b5bbdaf6d707f871b0e2073ff44d981034c54e0aac5ad2c63ba110b7525a306842ebc5bff8a6f9d0494df5f7cecc5dc2d7a9e52e0faf89caab7d0fb1cf2dbae69ff88637e643b58094c82726bbb7f7634e0336200fdfe73f43c13f8a6f9d8360ca371f43e2de1d748ad2710ca5b5e8cf0b1ea1fe5ed6d990b181ab3790b3df8060d4738201727f9f732192d98e5e041a5cfe61a51d1c83a2a01014140f57e00ae77cf07118bcc17e22edc607dc57b279f25799addf338a3eef76910b751903f9f87582afcb15c01e3fbf2998f9b78ac4874e321f81a8e91d14f8fdbfb043abdd316a6ad3fe1152df005f04dc8086d51965cf6eb8f40ee07574ce6c62b8c3c75c99ecf08f4d0f133385d2e064e2132d612a07426fca905032b3a4fb55cbf44580903dc7b1ad17af8efa1d5d6e7fd6416fdb9421ff3c365d9f3556a3de4f79500b6ba6f034c971bb240dec8b595cd21d690a723c1beef44e354bea1a3be5810cb043e2a97a6daa757b1f0447953715b8f2e373beb75f610736ff7229cad40d4812a6f3bb31e14ae527e8cc1e8100540ff1f5055a991efa0d53fdccdd5c9d198069d22329c7623f008e1259eacf15f22e1a6ea5bb0b5b0b6b8d60373eaf06b3fa9d73ec8014815fcd3d30d3261260ccb63b34e23a7e5ca796a54b470411d2ca425e155ba3d0e395b66040bc4bb9d0948dde5ed339c9acf9354a1b6dc5d1b50dcaad0e323c29937f6bb3eeb7aae73f203d85b903b14becda132aab9180f0a15ec671a53dce1a190246d7390ca751d3479156a9726a451a4b5946988b00791b91e4f83a91aec588ae3982f19437a547d6554bf633dc64bc3647e376d7da5d5b5dea83ca6479e3985e34cfea6b77070e723dac1aeb65be091c32f3eb263294bab62ee4de2ac1186a06289a20447a67e6277a2133bedeba8de538128360129175b4637bfe2ac1f04a653cfa24998c77267780f88f89079d6139f257d4bd59ecf17c823cfc8266e41ede369a5c1fe330cb727ceacb86dc9d2420ed5daf20abf54c8195ec4b397bb2bf4842e1cf0f7f9867737f2c93b1aefbfca21234c25ef6c9c91b6b2891948093dad93d6a6e7ca98aeda67d7a6e27082c23d015294e0a640f5e459848aa7c03482e44e22ed85d918e5c5d3107476e0356d81be1a8ddce6cc6dc9663f85c6648c3646e9b33787137c4cb3a1593389dc8bd68034daac652770a8628a6695a91911c5e72f74c6d763aa741badae4aec07af32cdf9e91ca1aaef9295fbb676096f5253a4243d8e3f4fb6f039e518fb75c3243cae2d0abcbddad2a81a9a8493b945117eb20483793bbfd7841b748e120e89849b175b9c787f27843847a3a483fc99a172b0c53f2ca36f7ff41edec37ceddbc65919d694c840beece5a54404b4fc5da55c131dadff352b19e3c55d7065b1a96397067c378efe0336556232a04084bb022f09205f09eaa6f11b672c5691bad21096fcfd8a9ad9ba2a65d5c048561665f0cd0a48e6071ae5235cce86863da41cb41b1caecdeb2760889b5ca129572679dce64af51637aeb0cfc88a55282c67d0a8aa074412c0e0dae2670e81d688d9f9bc6e59509e9ea11d066420f77f1cb619a295ba4082a3c336052f6b67be9a4b6aa6e24c9983aa78e061dbb8553119954f4524f002419c7e7ad5ee84809b04019dd309855f6c7cc824cdab82605dcfc017d5a35557f10539bc338f1744d293d11b9de3264a7f5535bf4f0d70529d003ccb5775c9de9a09d0d59268b317f93f3786ea13fc8c1306d19e5ef060b1d6013e5743b6b61f1be6bc630258746f750fd6f345829e408834b18aa734dc553158c467165a5521ebce8715d076afd165290d1b258c08b51fccfb2e8822a6eed5718986dcf3d748238ade7e9a69a1e6b51c5fcf60ba5fdcdd839d47b6eef25d906b2e37b8814fe61e65149e56b415f67d91e4c02282e5cf2d3d461608aa36b704ce86fbc82af6ebb675ff6ab0055156ec78bf7941e0ae359be675bb7989ba9205c60715b5ae8331865b35527a7b12f09420f9ded52f6ceea5646b609957274175b6cced344b43de527c720e8617f8c2570289b9bdb2f706007189cb2684217933169a7a2475684b3e18c684fc4a79f8265b5bffbd95a6616eefbdc6ffeeaf2129295131c1d840c75bb7423b5c6535ebee46c160fe17f95c3cf31ee9ff534719808e8f61fbe7857156f271556e9896c30a92c091168b28da89bb85bd23b83425ff864b2be158da80943ce170c77936a45aed81c5b38d3e5073afcfd9e79b39e5e2b1bc948476a2b609fe333a74539d503612d82f3972e343a983e3689f53dc0be87f455faf9b3c2f5814b3dd601931665b120801c038f848514951d3d49e6c133584b6b3dcd8a519c46bb37206efeb59822e021c16085c8d190f946740d91cc37c224c039a54320b166f79adb5c5ed673b8074896fe9c98396e3c7acd134e9bb867677f8e065c4859dd674ef2491614cfbb130d36e930424591bdd7ca95484a00a10defea9d7e0399d0366de31c2b34f9db489a974a8b9136857a5b725fdabd3d9907ef4bf81740b22a27f15f993e63cf748f68ed6eb4bd465af40659b5db450b4e535c7094df77c4d3c483010acaf5084ff5a87f7362820b9445f3fc74e6f96436b59e616a2ae50aec0f64d4236b4c53af992ae52d79803e9f2b4a471813d0da4f20075efc9fb95437aa03a7afd26d07b62a41983a67e591435e16501d458e33d669b482fae0ef65f4c6edcaa1c1dfd04808f02164edcc7ae7a06849f0e10bbef45484c154bf01924d494d021391ea4c09484d9f82500088b2022fbeee79888d33af9f2da84c05f1fd147058f13f22bbbac7702afb8a58408a5e8183bfb1a98632e98ec610d419d6fcd6499eb5b785a0513e6a71c879078f95035b52b615d69bf6c13913563160d1d5c27525054b2c3ef8673b5de9c9fa4d2b536d432ca82281967f13463c51715ad6c23fa5cdf5146e65ed5a6433db1f1ec54476d96e89055a2f196ff59e1be32af4a14a7c27e22f5f28edf514eb6d55a795a3d534248d5ab9996fe654b1911a1f4f4f3a03ac8c2a0e887edf9a89a8f4aba0ad92797f64663876f1dd31d76423f936920e11fe559b7613b097d244d26b20d3ba71d766cc7e0dbb7ef82c65565bc700b3b9486dff4891621dc603ec3706d09d1268efe8cc4fc538992ff2ec187da14f809991178e5f87a9494c73ccb6b385baa31d6e56b1f001d80c8d7cf4e41e17703c7d616df58633088cf9b95e57645d6d1a76bebbcbbe9642ca7c71695a639775482e015f883c3c201f5a5efe3d080670dfc32498ad635bce8ab564eb8167e34eb8222e7e4f3b8225a4c6f89a6bbcad63e6d6d2c73802a879620f9493a78997e1af2fe4f2cf7cd753faa425bafc77b5666c77cff8adbd744e33b51e588a8367853568e2cfcaa243b57ea6b2e5fcbdf89db425c35566c4ef06d10cbd0705c48f77b3586075f563befe1c0e12cd5da957f2fea76cf937d024cc08d2b97eec94efb5ad999248cbcd9fecd57fb98709139a649e4b19db7f70c9a765bbef1a5fb744a2cfb7656fad1966b98e378445d989b9fb96828ebdea07cb2ff5655e5e87612fade757572f8778c69f24a46af8a50dc476b9dd88e1294e5afd327debbff8f2f1812bbc98c7dc207b141dc88f65f165cf0aa4f6aad67413fb079ecaefd6b9b48675fee64cb92c9c3f94163e208776f27b9a2480f62ddf2374d1dfa619740d8fcccf0e0451c325b66b9992d170092c97684fa73b2fe1ef50f433f4b95892de803c29e6516ab602ad8d4d9b35b8d5e9a81a84b216a408cd44eeea5292655f00f9c638d0dc759bd047d1d00ceedd66291b81ada0a34fcd6d994899a1b7e7a4e0497c14b89f7f4acfaa619fc4fe9498f8a4d8bd5cd59707c2adb7035efc21c68719e622108c5c78877f377e70ab75ebf9fd161c87609dd2d184ce9d9af42460d85999562b2fa5c40aa82ec3144beafa590448e26da5f6e494402d9d24ad55f2ea656d0547788ca73797af931eeaa08e40bf0166e79a542a947ee8d4f7eaef8b230f5cbf0f6e0440f060401c7a60f39798b61ef62017a9ffdfe3fd14ad365192914b529d7a4dcbe1beab15ecb81c6c26fb682b052bc03e5afa13313f09e7a51a2e8852ceaac7812628de8894df06e87589498d13a4ca9d80c52011c314efe76dcd73a8bcf9ad643fad345e4b6be85da81805d9420c48bcc13cc5f610b942de1e9e18c9d8b71f12183a5e0f6b1a870504b1850eea8f03c7c897b534a77f5cb6c033223867f332f337d1a467b03ba21f7203bfddda2dd690d5d6e35ddb48b094ba105d31120798d588fa3de1ae796f79c08e3726c8647fd0a1ded188536543c0283ee50ba67600f3fef3ad71c03fa085949b901188a939dd46cb3d4ae2e5d63cb1601e330c55597d02f63a4bc2fdadaa1f8dc0a06d98c14579e6c1ace43662671c702b2cc7c0ffff200df54dc423a112ff3b73a54ff35fe34e36bf65671e76522868dd8a74969186b64ab1b113d122b968ee647768a3bf0f4acf0e8abdb5798ef734eb3e050d0e63244c875bfe7e22a1a8c088807792d9cc78321ea60fa56701756acd0873d84afefaa388d09ec66bd437a5b46a0242099ce942fbd59e939b4dc1df0a341b26273200bdb4811d69684e6dd700cd05633a310f30ae7f2b821bc5c3bc89f96ec1b2cb1a5579c70dfb638aa0fe434d964f73fbcfbe376876e1ae19e90837b9230340a4f625221b9fa61f402e34305ca10221ebaefc9d02ac663f2a132bf80bb9f144aa97b509ec3ee6ad7d7571300495776508f1bb0c0570153e266ebbfdbb1f4fe2a9381b735d009ad6be7c81d2ea7d87e1e29ab3f888968a6c9c1baad3b914e4afc98837fecaf80f2b7a87c177623d17b929ca26c92396fb7d6319c0c76030c68927b665ebe342ceb916dad2f9cd788e4581f78873f987bb027ba6c5101d9274435e6531c885ee81adebf0602dcde6dc575dadbe86cd1567fcce18d50f1b30028beee50444a3377576bf2bfe88d6b2ec81de8744658cfbb094ae5c18240e059e0d2329b60291a7079022ced712bbb5b4046ef72537c550468ce41c11a0c17e6b2881cb7aa5ab9f23a885368b7a561777e5ea0019fb64d009100564512ce1d512b2b4ecaa4248bb56467c1e7f56f5eaa703d5c0118b16b9282e0c138fcb27f1051dd56176175cb7c742fdd47d869f26287220cdfda5a16284cdc35b6c73474449be63ea4707e91df769985becc5bb17fd662ac4ce54a0ce7433e97e29e0b3fdaf94d4804ea7f1d718ae004d041f226a0f39253788f74d6b0bfdf6b833937ccf79d10b1728ebaa7c35ae8d9d01b204e237734341c9743a67699ae6221f44c64cf3ee5d6b09643800a14ef6115bd4683099f651da2fdbef0f3f7771924ee9f4709985a854f6f6028cec2bbe51da7c5da2046c94806fc06512769d7e5c0203375939696bd2f1011ecf3da19d4c846e6c9ebe5b8eae8b7bd4886ea838d517822acf632e2c2306f2ee588680dbcbae742bfdfcee676c4cccd4051c8a3b19670664b901f06d1a348ff5d7329d005c87b8c90ee1a2aa39bbff37e5d1da7b9190858ab7a44b647495954a82f1fac4d21518960088f3920e66928e4a8cd20acf2fa560b6b16e6a782fd3e7e0d54e63c41b1d757d5e803aa2b1f09c38da96c0dcb08a32506e83fe07412c3e32cdb494f3ec9958db117631246df9e3d50643b728583f765e35b20b670472a9d66cc506af73aeed7ee8889dce0a6175c0a341970098293758ee1220e557f8521c9229dc8a940a0482d9ab9100dfe9cbb1ac5bb2ba53d86a2f6e2fb6db6eb2547835e6196b4dcc38e2a629f671291656b30ef826bbd8c81d2558738a24a005875f493a261cad9fee8b2d281292b643e41a9777ce917e495921b7321ce891495960230973123b65ba7dcd30351244930dae134c681aabe534102386f6de3709996c7d51f5b2df75768cc48054d7346b1b0a8866051dfe0b9e02ac0388dd5853e48b1df6dc5be8cd1ad8738d9f8cc0a95676273ad5f19407e26b8d21580f505a8304b8a4ef6002e3d9e3774176f9dd60cfb1576e186b2cee688a1e300e28cef967941878b79fb31f4263365d74824ac08fec9639b9820206f90d309d57131127b16d39a66080373a474ae2eeb1537d313c424e8b5ffe29343d9a119766ffdc69e0614f84083bba41b5debc21890f91acc4f8ff497d99043d73b1bd5b8898e5b37c2ef8dd21976ba151fc6a897ebd3d03eb290a4a0379d3e346383b832331b73be69af452afd2d9a2b58ef11df4cfb0d744f27d3f563a5f4f51eb042452d2cd0be6360a5dea86c8ba1e29ba4e1ec14c422ee1f5258e2683487201c192e89e17897a7f2c8180ecb9040cba550372aba34adbf4482cf3585209238c22cd598d9f140ccde32d93e5ab242ed4f67c7dd7b160c556a4492b7bd1fc05ef05d5d89f369274713f9ffe96f48476ee7e7f83e12e90fe5666d6c2332fb98532020c6189742e92bdae024378073de2711b2a5bd0d4f3ad38d10dae8883ed6295c0e18f08caea42c4899a575e01a1aee3ec177b75ec2968ee94750b2b72605b7c618ee49a2dd1a47112b32bd2bd10e6244b366b9021651c42bdd84801ecef563f81ab774b682f23ce70c33029c3eead43429b05187da7802d8bc7b57cba25c71feed9595b03b817937253f806b7b1ebe5dbb531f7f2d94b09d107e905b9592bbe76017449db570482a2a1a2efe7defa4b0ab2bf75646b0befb47c391ca21fde279aa449f6cf1556d65531375b893914d71a8392228778e72d0f09349c6f300b65061a5d2cea525251c1beef78294924b02d110ec6e3064624c7b1a5f8ed3672805ec589e2d2935cb9ff68543540bc19e8b83574c5394404bbd418939bad1b315368e7d108c7bedddc4a10eae7a5aa2f658c02647abc98a4024c81167f5e89ed0ab6ed6b555a9e26496058f6a10be4eb8289ea5878acb9b9b100983674f14a1d1b1cc9615a362567baf426796ad728f92b87f05a476f349f29cae8ab435229a0093329d19adaf164f1749baa9da1b4f2de8e97d5284ba49369b1c67f28529942e2b9976feb96fe9cb11da670390f716d4bce28f83e31b5c5ee2f176492ae605fc2e30ca613f00117d4a8cf8369e341b1d4ddd78ff401ebec90c9fb81b372353bb9172810638cd81b3e56fbe2b27053c499f523e6a9aac96292b0250f4c141c7a9579d09adea84c1bd33f68a9d1ecb014a57c891f721affac0e034b541c7f203b39fa698c4b44fed65727d2511cffb07fd28edfab205984af126f2e361b8bdc64d35a363b50770bf13f42666bf2473108de3d693c5c1363ef785516306412cbb8d73bcc544a5d75d371010d58e2131b95b4d9c756b74fbd6a3d5cbd42412b01011a45744fd2e8ca4fc04cb29e1d7565859d16dd26c0cee50a08ccd6381e1065067921827c2a25ca249e03c055bd49f782ce946cfcafccbc8d630b027c87590a01bb23d408c8e5b34891f8c2084ad0b66974991edbb6bea254776eaf4f410d807c872b38f5b0e5ad5e0ec9c82ba8946fafeed9a3c33a3c1d234562cb7d885786e73d49f8feeee43210f9005fa7526ac43070c1602f4194cc8134f387f8b4e4642cfdc0d4a1753ff5cf28cf25dc4ab4f082ee514919bbadf8c3dafb16c19795966a302070b49b8eb62b66daa906df99f67d16ef19faa77422829a9551aeca2c403dae7bde5248f0f2bae524a9605db177bd4e6cbd2096c59818ce9926d1b93f028bb3ec876b800c7c2e9d54c5e9f49ded1291213473514ff97dda29cb6ae6a7507558150823deede93b482cc955120023714393496cdd96da649fce6aa96d60d8715d8bfd5af81232ef39f58e05daeca6bb80b73ce986bfd547f3c471bc0848ac46850cfffb669fa40965ecffce0239e48d7b107472651629fd64ed2f87243c1c49f145e013eb69b117e6ad12a1f88bdb884cc01e35d77bfca62e7b7eee564882b0eb3602c3980160d00ce367bcda3242b02524d5be8191ab4b8bddd13d2955aa9ab9009a98827664cb2bf9f4d43e04a6e1d421c5d5a0ecafddd3bcf1d8d8e7467420ae239644528e0817db27c6abfa1c4ffe8b452adce5f169686aad1ed9f17e97f3be2de9635995d2c40e94209a91f5d8db2242179239f0c3a5ec8c85aaef856294188852548a78aa54756bd31fa6c88665b0b92a20c8160a1206c770f1eaddfcb25fdffafb0d2885213374a0921daf255526ab87109b4eca3bc3bb27bfdb5bd712da28da4a68667e859f7fec5c775202ac0de5289d0b42b6642a09adb18b2ac976bb4271b5330e9b743dc6dbe89fc93b72128312301dcc007c87ee7bf43ec77dccc5598dae3a5485eb47ff6a02814f29d3360e8078faf9148a7a907bfca511626f6e6b318044ede3cd7b7db0eb65d8278f847fc47c8351446e40a5f4a5e1ca3c2c4cc83acaa09402c7786d5dfc69ea4c10969c35771c36206df4d5375b7fdf8bf60f0021b9a1727ed9ac9e09f6d12d6d80f62e1e3a3fa0cc572e4b3181fe46eab77961dbae6e5a922fdaa14ed76c003a53701247f638c3d6fd6780e542ee2d127885059c341f830fedd134ef2b73ebb3cc28e04b885273bb8b7daee704f9ebe4a34d2b68417173d1348f8996c1d0efdf62fad5ccd0edbfcac8d1c9bbd078c0b59d6773f832608c2aa535018cec07c57cc5f422da0f3e0109b6bd626494c2a15f5e1c2c142360d0fc2a421e67102745e068201a1bf80fc363fd6a9020590a6f77e12ff5f74b22c4e384b15a8b7ef8a2d0d5061e76dfb11ff81b0210f8c49c2703386499b57845a750ff32cc659125ced121d4fc268dea0d6d602a7e4201352c8ef6d70df7cc0a1a8019cc66893668c265c5c26d880d7f590fb46fcdc3b5f94435a73fc334ba06f90733a7e712c8badef3fce4f7d47f3ad8a6dab40819fdf3931aaeb99f529b8c22435036d0f7cbf29863fa25d9e72e3fbacd1d13ea9ae213f6f975f61bd4968d955c9b010536dc23cffc2a4c17bcc7c3e15b32b77ca43451bca1dfac2cdc5ca684d6b45bd65c1b7ffa883999568a28004273abdaa0cd975d2093e843e8c369b1221d3a18c2fd38641415e24dee3c443f35380bed8fb02af4b928b4b6a9d971eb04b7e85e26e8f6aac8c20cb3d04df20389b4da6d786d86df5b850202c506a23f24b3f64eba9f1e231b294eb1a68ba5b9b9ce569bbb07b4f3580639be7fdd4dad92775f4af154271fdf53061fb6ceb0a8e90c525eed020d89d2b3fed9168c604bd247f94104208708378d9ebc85178974768279ff431797269c49a725d7fcee33f1a4a1d0ff4d38c2bb79ae298764ba2a2a69e5193e16320b17b733204a5848c41e13d6378e5ced856ad4f7256610a36616cca63e5060a14d52e3b7b5eca32cabbf6ed986b2a25faf2563060a26f7dbd0c8135f6f92428b56d10be2acd8de54df5f83fedadec183dd0f77dca860883e398a976b307e61c902c569eb081cd9dd0c651e4349ceb7f33ba53ae8fa58d9be15759b6d91216dbb6fad4ccfcb629662c6d5bcdb5385bd6df71e977a98f7cf7e2db929f5659f2ec4451fae66e3077083bf5e22a927507d7cf47f55de0f17003f3341eb5de0b1dff37fc7621caf98a11fd326361131b222fa74ffbc53b4229595bb4753972f63c8bf8fbde1993ce54ecf1440d8ea95dc4c3db515924b2abbdf9618328e0b33d69b9dda666b67ba5804c7f80338a08dfae186b086fed437c1d806f9b591cee68ad86e0be64900452eab357c51e02e3ded747fdfd2cff4340bb0c6b27a60af4e04bfc5921f2d2837971c947717c7d135d26bcdef5290b86760fa33603ba3c6915051894372407dbfb29d27995d5a74c4fb196e62bafd18d331bf78845287f5ccde98f9961645b0132becd4623d077c6e7798905f0cb2240ee2abcde02d885c843addfdd4370c37313f67f31292f3a4a4d24d894a850124cd4662f291f640c4545e3b34f2b158c1541eda6d7b2d6ba8f7f88f91a977822db77a36d7a9fdce1c4cc38ad2360789d76747ae83a08a8e7bd05b4923dab8da8171ac9e1403d326c0767db0cf32f841cacf06f5e2b3471b9c1233ccffe7c443a4afb43f392a15f5783086eef9390303febc5fec66aaea0bc2a02005bc427e3353964dadf8a89a2749dd6dd2b15e1b47cf103f8ad01dd98f568f1866864ac3a1392465702aaf9b047ea16b8f426f32e361489f40c1c7cc5d78c83d8ae0de7472d6c199b2438d6743bcbeeb90f8b31bb6bd59826a5dbe4150825498f775891413e86da169287036cb45d3b5a989f96b2f35fde18aa9ef0de6f034563f71cdbf2afd6e9c60ca240b6361a98e1a4e93f877ad6255b9d6722ec6ecedeb43601792f9f531a8cdbc2792f927911327513c4358ffc6a29026b4308881d88b7347375cfe15703a7b35ede146ac4611057bfd94437637a79d63565561520ddc54039c0f52fdd2c4a04467161e7435733b36fe909f2614423602828c36869c66d67a652d02b29754d6abae2c4e3d1aecedec95cd21726fef0daa2b2eec51f2862a4ff7e6caa2aaf1067df58324e418404e7899ac15056d4ba40b606e858e17700e253253cbd56718dff02b9b78ff923bd474baae84f053d731b9e4fdacdce5ed2d5d5bdfd6596aefb70142b75005df5bf262a4c18cca73836bcbff31b1a942afc7ca2dafe82c4f0294577a59deeca6c69b9a90363b9f96c1a72cde2f801cc30f17b663d18a40739de522db353e7500e24659acea15c995417d363274bee9051ba16f371977281e6e5ebfa13061f70aafc8a144509591218569fdbb0caebb26c8ed4bc5e037ecc0b6adf11e4da5b4ca580492ed3e77dbe96d6f219ed6bafe94ca8caa19e87d9af1b5b1e29bc6fc03e9bfb0c6cced1e6243bf9ced3afd0fa7536912fef455eaae22a837e4a2cc6626be98bf0dff6eb1540de3ddd6171b8e367e06e036a89a1e0472dc6ab91a85cde9465a52fb74b3fa5bb54821fd8f1c2dfc0da5183cb7abacd1dbaaac88124598d0fc50e106af8aeb0531a459ffcb73ef621f8c88248ef114c8afcb5ba7c09ea0b2d91cf80353bb8df116adbfe57d85fa56d691704dc755bf40a9fcefdccb97eb6097419f892b9d93ce200c85ddf1ac6cc673e0316fe05fa95b1146bd345c3fefb0ffbbb8cadb06790b43f7d9c1bdc5bb30a653beb5a33eb302668cc4aac9d3765a0b5c9249397c34e1c5292038cc435953a6680cf18379fb1a5fad03451f0e4a17b3d546991d433f2ac1cff24c48df4fe6dfdb82d7fae9679b671a670af6612515399afaf39fe5c7bdb2c753b8437b6660ee71ada4d1ac22e162690f10ad2a37d6fb75a23b29636750afbdf47eddbfa04aeff8b1e5bf80fc73c2f8e5845831af628a6b1d491ba97e7c95506899178403bed6410c7da1b825c896a50d975d1be1eec1d25edd6579feb5f6710ad232c5b5293db2a632148dfaf42447ac0995a45d15dc162e6331a72eb3349db9f986aa8c7cfdcdf0b0c4b041b2d8925d73175908c53cfeef58769d06a1af371fc0893f7c00b4a63086220a444ff2f6f77c0d6bdf26d4b37463146c41e7f33e48ba18662e358d815e4644e89d5c45db50e71691ce26e5478ed0a4d16c2d14032d0b1f9a339c01f74206d5150d69d887b54adfcf039e4df21088f24504b37d17c715a217a925d4f92bea9d3a90b71634b5979bba8136fd6b6e88391b07dd15a8066da14ebdf5861bc866babd174acc34d6653345a6b06195b9969eed26edfe3d68d4fb4309c9a88991daf0c7ada8729407a75bbc52cd9b243cf7aeb31b33f087b16bf4792b6a38f86ae7589fc227032c9addaaa542dbea3e1c4224688ba14392f2cebdc813633e07eb0d1a49bb0fda51e7813ebea05850382f1a4428d014700e7a2fff254f806751b49e5ad2e899d113dcdfe4f1064cc4f3b3b87e5d5f235626c9bad6479fccd4660fe91d0ad39f652d51af4fee4109cc4e72ac812fb1108e3debd2aa7d1e40c1d817009412ed281a2833056d3bc4269579cd412b4c25316860c498dbf1c71f4edd92a0ab1a1319213c26a4d7bd03f57fe3654c74a369353c108200a1ba1bc9784ae67f445add8e10403b884b2e747bff26677f78b0f0b23be1403a6f413c2f299d055906cad8e5e822f5a1748b6055ea81b980ba39bf1516aad976e72903b1b4282086b2623a66525f68eeee351b6fd6091da34538f4666ba6c115db672eaaebd722392f3788074b38641155081727d9b68ac91cfb1a42b6eb303b71099651b849e0beec9491f1b6e214b981822227ba7ed3fcd7855f07dd8cc5689d8060881333a1a695d28bac4171b83bfec69a88879b2d623ee78ea08cb92faa8aec4a09fe9edff4d46bb6d6ad8fc86ea89c5022bce310bc91a9cdbf398fabf4ea990fedab4f750e82df09e919e00d86de6799d1fdbc4ec552f682f2678ef65f6df6deb0f87739267ec0b95467cfb2837eced0f3b1a950ca3b3cd997c190a4bf0ad90de072a64610718603e5c2d8d8af08e8e66e088c16822d4eb76338841028026388d565dd7839a7c1c3f60e2a83a87e5c3af2c4b1436c147b1e5729eb04334f8490a6fd37084ff9d09f38e6315dcc58b184113e2636308c717da71b9442c697dcd6b4030e7997a71097cb02c7a3a1df81cfe7770c4ef3af24a3c8aa7cd79d55605d54073b63ee84e5aeec41007543aa8ef3ff44aa78b8466b0ba8fd4bd50e4be35f8a252cb0e7a36380e6e26568b7fd1dcde2b11a0ec4ac02a8c093b8ecec3dcf35105644194ed5161d1d3eaf4f837c11d9e0e9cc4de1bf183295c0b06829acfdadcd416b2cd30617238aeab216c6b7fa5a02dc2ccc7edc76d6f15dcaea4f5c0645b55fccd0202c73688f279dbe6306cd408d13a4664ddbef362b0302c648d1464d0d4ea19b0e8a825df9c029fdc0e93742c403d32904d4c3f444e1a7ecec34c837c4fd8cb22869811a4df2f36d77134f668a60c9cd7d4fccc22fce89fcac8645bd7fd7e61b10b9f28b9ce6b5634c49f26fb09aa3183a8153145bd4280efcc3cfa93785105b55515cfafa4d81b1d156741e21603b4ebb2ea8545e9a69e229a4fda97e23d71fd4370848bc7893befcede6925493c7925537fc5c4dbe6b1930ab4caae6de106414dd3042324979c612955bea5831ac5adee47552284acc30d509ca0033fe8344516ca6e3a99fdbaa70e9721e4f5d8a520832a7bac8343001f2d16c745e54e144634be9d56542779c7c91ea2fd26e5d8af912e8e4577841336796a0edebb6afb53452525c2200222f10d4128d3f25fa792b84e23061f2dc02de058842be9654cbd68f74baa9992acf1d5a808abb8258142a5ebaecb5af627babd7bf0f4d089f1dc9345cab99e2ed51916ddf6360cffa1906d5312179d22ba1ce378d60e89688c39373f456465d75f86d98507d6ab8d71e35a84018d21b24bc65d263cd49d9d3657175147e56d804dacd5f3e98521e54c7cfcbd575f8a7294ddc95bbb1e595a275b52c03d7707543d6640a7a987b41822c1f019c3d1a96f585449f0136c1be646ba43a3603dbef64c99757abdaecc2be931460e1fb18255ed6fb66578b519a43687d7752cfc7e6fab185672bcadec62d599aa32c2c35393ba29806d1034a07cae716cd7e60eb40b57fc8eda20168a0c91a3cc493c5375feb59d3ccd86bc0c5c33e8418f304005cb64144d10e891ec198c5aac028c4c194c3ec2462cdf56f315575dbaac5ae43b161d1c704f02d95eccec85bb7ef8e6d302410b4f10e0115a5af5271d6cc898c1a614f151318ab7fa01c7c95fc9e3f5fdf058208b40e5ce02de9d9d5ed9327354472957ceec6c7239665525d28c43bdafe467cd9816534a5c3578f9df0c0a5eeba71b98c133c3f2a21591a816e5287f93705cf2d553132f5536f80255f5760ee48928c5de467052a215721a539ec8571ad830a3aef9e12f9a32eeba393a201542aa0a03e31160e5abc9f38d648459b3a7e5d2438c3717329186f976818777621a31f19b8840ef7e3061c0631770c1b7611e2c6d65a839ae909a1757c7a4a197bc609ca052ee89de089136d0293eecdc91d50677feb99072c01c8836cfd022a67a297497cc15285d60246c3dbda445d4f00f24095b0703885df91ae8422563ec21834a2a1989fca054facd34553e1e4fac1157aaeb7e2d44de2069bede2d240f751ecb360b076ac29d65c0c76048cd952b51fcd3ae0bde50c9a2d4c50d74523e490ea81bf8cddb292a0225994287483dc31d4ae8daa948330a3b124aad3e1fd8b6770fe38b09f83b3f708fa1c43234f422b72c09d20c611d45e7024a43cc9c220fcead9cfb26dbc7e4a24e4f5ca3f97a24f391f06e990749e7d50c7091c47435e2560bc69967d1b649d5ff5d7c12272f265b4fccf53a7ba4857e7efdb43d3f7a57f9a45329dfa4995ef269da692075b27d4d80c758bb55626dd050bfde687e1d963980db9f2ede823562d2e63a72e490027c3cd04c4dc17531e9b74c909e5948dec538029e9bbf634d795c19d08ac7ebee4196c97b45d98875159074dbdc3166641304198d0b1b41268304463bfd0f5704b097508ee86499d16fa495ac00f72ce91bb4fef258c946c86da1dbe29afc02a0deebfd1d5cb18399c2ba46962ce1f70a690aff8fd1c552d53f1806cfe4540f9bfdf0588f68dbfbe34d62bc094b778a9082c68bd6b9c28d5fd4a94f9072af50d13b48b7185d45a74283ead18f8366726d695f4b5ccc95b103b35f22d52cc9e54d0f874741edc4382e66ff6230d1b1def6071467f20fbd668e0c0a52ffa193ef5b58747845134f935df84ca90eb120c49e597d818cbd3609ca85d0a5c75bc4af69bfd521abcf2bfd6aef0e06deea3b8ca2ba62d456fbbcf221232488c8310be3361f3b5fd36f39c809e7eb097b12a1c38ffb482142952d2d2bd690361766e01d440e230a8980762ed5764f28c83f9249c9ae32119788a1fed4fe7bb4e1a46b617036b8fd27649f8fb365d3316271017368602e1c83bde74bbf49e4b615dadb11e7bd0166bc117fd19dc478a53071c9400e3167d9a8670e70019cc8d80739c86c2e79136918516a650a8eb80ad59de54a7cf9cef3f853769e7ed1cdc9400a55950fc0dd7fa65abfcd721aa01f0785d9867f3c57af155123d6f207f22983996d006d6dec3397f0798e0f85f7aa5b37a99bfd8e95d807a6c622d2aa580ed162df349abbd552b8157682e190617e5ee465e974092d9df98ca7b1ff55d8052a9b5512589e8e19a91a2120d62e02e50c0743c75","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
