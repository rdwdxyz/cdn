<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d35fa074169f48a6e6bc5d210b2b080f3dd95430318d9d446f52f4b6a9ca6f90ba85218ee6ac3464cf219b94937d6c1718309e6aa6e996ebff26f0a14b675a97ab75070bb387f36c9ab921397a5ff0ec0f801a8c0b8886d6a1d4f5e09ddafe88ded26da81763a4ab447c1b41ddeee1d36d871995f3f1621f5e9fa7e3c79ccb9ccb4ee277bd6cea8877c23cef9208da3103a7f9a8b1e54e811f4066fff1ab9e99884d5c347c9c5ff843fc288edde970698433076c723f14282665172546a8190f9094d23160253ba5a1684240b4d72439f9dca06b1fa0555dbc632850d69f0d50d540742cfa975d18381a411417dabf791681ae83b76a6443bcca5058dc113da1e717bfb90234be4ed0e80424872388afd6af7cf1c8bda4ee54d38554ba9f58d42ad4bfd60cf928fe2c8e4dc3afaaea1b0a0aef60ea2170a4836ed14efdf8bfa96a4d1cc0181f977c1c6a45939a48aa851f0efda24611bebd6639f855a3c94963310912732ec7198d22c2f074232ac45bc6a31f910595c371f00a5f659c34fb7a9cc67756a84b2589c9ccdedbe10d8631a95efa1630fd94908443997c1e3db0d0f45015f62f415f5c9734e65014bbe56ca825b1b4906d49fe784ae1ffa328334b1370c9c1bdfd5272f36e90c7b821b3779ad54a9965f5ae99af868bb3417de9664ebb382393fe46a2fe2e9a6e9a0bf0cbb4f07fc30ef26af8568b602c3c197cab8d74a3d40c0fa9cb46ccd87da9e0fb0dad1096784a1df5940b8f2a5a29ee00b5f967b34cfed2c6553969f35e9cb0f55de83d54eb24f0f6ef8d2c5ff16f6dafbfe3bc60ba2195627408a3eeeb30543939284f28c13059db990a20fe082eacd366e8c594ddd9388c9a3ff2f720475d45ad731901db8b0b5a5427deae45788e724fa78cd2ee1bac179eb9e57226912482a197eee15338e0f80a7a2d98d8e4b9795351d7d99dcd3d767ee27c2604b8214c60e1f7796e35a0ad212839ef1c3a46caf97e5d17d35e82a515b077f5232cd750a2f58619e3ce01c67d5a2b00c04df11a02887db8ae3f500ce935a008ffcae4c592e2173e389900379f2275745d89872b95376126520ff6dbd796bf5527837e779031b09f66e5bc51490aa2089911f74f6052bd562a8d084547b5dc271248f7e0dacce8b1f92017c5eb04647435726dab2d7b08023bb4148996dd4e2dd6683b8da71f9fa8142a0a1ad3284a39a923d168d510b0e411ab14d1de268f861fcdb996b87726abe14e9b842eef52ea2210a0c85972cf82daa054c365c9817634fda0e2aa72ec3c9a926224a4a45715e4c1d6aec67e5019516c204f2b89ef534f74535728c3dd585b75c0f1265bdc0ce1fc463c951817d1548fb36e3e58889a84f0e657cd32ea346869003f84c0341391f8f75e06bd997c6c3092fecf004f562653d8cc040f7931bbb4b57de63d21399167433070c19f26a60a3030b95fcffced714951807467b7dec11748002ffff58a68837c22e97082e5f5ac416278515d5b8df9f87277999b55d3ff3b36d032a82e36caf9f1a44a8e09fb9ee065de8afd06a92f34ef9d1b39ec358a68f4d8c58754b3b4cc4ff6b5f813074b3d4747c4d2c5f7b7b4327cdc080b6c69f276f0b65f7aff138451b721c81b1ae2e1b52efa8f634679323c5974510df5fb5eadc727107fb2de5fb565f0378bde8170b8685bbecb0d7952258fc6b03221af72f9d231f3e482bfa32cd43170271270a92ba2a2bee86764391dc1c303541a57dc6b9d7f525f1bd2e7031c1e13f636eca4edcc1348e2d2587e4a609db69a3a15680006d9e16ebf1c822c2beac5baecf4b82fcf32e7accdf648d9028e278291255a1adf60fe796e64716d369f58a020426a84effa85f9d96237cb831978b86a6cb341cdb4ac480b4d1829ba7b2ebc67dfbb3163163f65f85491d12eb94bdbdd0b7363860baf1d77da949714f17a31d6b9dfa89cc9678d2386e79d7524d3e0a2951f6b33c2d81c806d00ee39329e5906e0e98a601b78b7abd6bc87cd7fda6c32bcbb8c131697bf718bf5080a6b436ad929a87a4bad348767c1488443c1adfea491b01b2bcdf990063cb5cb123108aee255ded12395444fb35893e7339846b2caee421f9846d538d1f9739b23de9681ce29d93b4256cafb06655b6bd8f054128ada4b721e3974ba73d99f5a426fb732e1b1220e86b4bdffea3d77630f7d91548ace9b22f7a0b4374d6ee1490c16783abe413a38db69f42a486047fd33d5e5437f5ca68f2cfdc581eb7e1d71ca97b643a8462f5a7942df697d8d8e387f708e7842ea3e1c306351ffcc513f6493ccd4440664c64737c617168f8270045b315763500ff0431d90c0f4d3b8f2b66a974c711f703d20ad36ff6549e57034c19baa1b421aac0f2c2ade4348ab84845dcce975d9ae1aaa952c68e9b8a973e68ce086b8a3bc73bd814dfd2fbdad43ff6e7f1e0a78968548a6a88d1f07315959dccca28c5f057a7045108d9791adeb1bd414e082a3918c6845727f936dcba6caf97632711b4ffaa60b43cc1ae3faa3ca9da3eb403e701916b61fb5b75dd2b32099bed91008ce0aa1aa8e0bbc6a779afe03ca85ee3305f164491fdd3889260516f24c0cca8e015f3f59753c8596fdeb93705a09f4c7794c3c28cb8288f92284a4fcff12224825b6357920ce05e3da0d0a54bb1a6ce1addeacd9ed123669206257c87f0c1323dcee32bcfcbc20c97c402b8c32bb77ab6190f10145114361795484e53832cc77ee557c9ac1b842af2b8f40f724af9686cefdfd9188cbce702bae06f1970ef0f20f073543ad6420646d4886d5f148381b6b89d3fccb5d8339eb246268c4fa5709dac59c9e1d7d1d0b74387461a8265a0ee0fa9d187a51c749b593e24551f47a3bf793883d9be83307dd97ddb0f322374daa3b08a0ba62ea3d6d966c6a75ceb3fa6aecf09b1fa0d3990c2f0c50750d53cd06957af7e702518332adedb52952fe3dc7422fc436310999ba1937ad9e078b82765d8c1d4053e2e3c655bfccb42a80e72d7de6dadf881b70c9ecab2e905e9ac5fc4963d0d5b4fbf4d4eff95d40e19da3b411cddc770dafd38d1ab88399cdc2c5b382eefe5cfc47de38c1ddbbdd869ed5f7cbb45278e3d07bf9b0e2db7ab389c801b0d6afe5082372201f43f020eed99de3d82876285cf135e69ad176b32e747d1ebf563625c0026889feee0aac7d32e6377f4b129674885145e5900f1490d579edf59d94d05b294e5ff111d25456a4c9019343dd3a7a22fa17b07711e2574b497c6980c639dab66458af942e635dc2cfb1704d96eb8b687f71757197177ffef0e3e4f5a5b8727d740b16c070ce78b37b6e271daa7a1919bab76ea534d3ec60252623b451e2d71231ea229474ad3709f8ab6a7c76d64bf190946edd33a377e498129d44e327cd97488a4e4012ae82557f071202c04d6d529ea1bade1697c32bc89309efc969b8e5b6961df842aeca2af5fefd31e3468effef044191d355546b7e61bc0e2c22fea334a2238265e10216d171276018966af57933fd077a6be9d355b9a5d790d181d8d804dce967e888bfed426d1d7db222c4943e959c9aa0ae4adbbd0606a72828f40cf4eb0a82ffe8352e13dd4f3fcb80b32bc1693b0a81acfc534a6ed754d847ba1a2c60f7585282486f9008b1c6537b522a6d920e234004c6defed4efbb2e837ae3c736d22866032fc042a6abbb68e948c54f5714e33fc42fa5bddd28ce2f0733f5b2720d3c23fdd512d03e6cbd7d1c76ecc0cfe2744817653f96734c8540e67339c759a6fc49edfaf6eeb935227756a525ab60be8f8ac75a1246415c2ec6c6732110e25a6fd7024a3b1778acf7d890ea5ad40d9a4812a512a2cdd61fa0505a73a2756c7d5a1f76a5e104c18c284b044808152c6c42a050283f681cbf855dc26c79922b4c44808404b2ddd7ccdbc5f49cf79d451fabc373014eea1827ef6c49adcad034935f2d6cbd5f6ef65cf4fdde45bdf25806e5dc14a63313cfcf611a724ca4789aafb9fe23e9d3f605669a967149db622d4a949687d676d24882ce0eb624d646b132c7b6e22e57bb80ce8c65a54bbc8838e4e70b1a136be661f47b0e715e3b81e69a503987ce45e245196f717734fe19fb52413d47c87f90e678f0cd8db6efdc4fbf0fb1222b79b83e2d12faa8f365f5f2f96ba55f7e37213dc6a962d46360c75e89fd8b087a36e4c094c47fecf28434a51382a1fa936d2846f51ad325e8180a3e66dd8c8eca23d56ce8434b0f4237d05a4a8cc0f11b2b793fcbfcac2da20ff2fef2c36e2e314084e1644f31bf0f92840a2ffa2535e4c8e11563e8e86a8fb2188541fa2e2877c81cff81479572cf628dc71a5f5f8a5bc5c0e6c8892e9a64a904a9b13f835ab60873aafed97489786004bb8993a0dd16196ee0284649b8ad62a62770945cb17ccfd9f1680d7f92c3ac92c3c924c762879b0eb3e3dd6e9b101044fafb2279a8c58d9b2bc74f555091581686ddf27927e4f6dfa6d02e6be053823c886ee2b5c5e6d5c6b1b0c67f5aaba998adb118e20734e0fb9b532f4b8e4a7d13560141262a4c345a6e1c6b44c53d861eef6844344f6c0c0bfec0d9c3567d90b42342b480fc7cd3de34a96940b973222a4c61cd9e496f534a5ed842b4b0c855f68093bab560eea35d014c1c5bc30024b72c3a03cd277cbe87ea52ecdf3fca00091f5234280adf260172f0f0b4a8f01daeb175ef4b5716dcae6782fb769ad5aa1eb5aa65bf0836126b473d322b7dfc60f1f1355703d8e74320f9da7df63b641fd4c4d464ab919e939987f1a9b7440258dda6f587f7ea628e39e8ce184a84532623bf79a4e18aa20021f2469688374ba943f4803490552601a9bc2287057fa9686527b943ee67228ea7706d96d2bbb810d6aad4b3bed26aece7373d1ed9e5359e0d324b824e9b6e47807b50a560bc2ff2c5ed2dcac65eab4867fc26f2f26f64dd5ad55cb1c9066027ec53de74688776437e5f5f824ef05a61ddf0e3a33167059ad61430aa4493d91864bda0a44704cb3a18f5ba5ddb7a14fe5216250204d00b80feefd1e4376497df5d83eb40488366f2146bed2f9e2f50917595d632edc6e3b28fd9cd9f140e0fb0b0f47b0d1b552d9d03b683c80df2e49b5049959f4d20d178bee7d352d634b805f9dbaf9f1200c6df38a7e3845f8e5db1338b5c851e61b484e1fda52fb0aaa5e02bb2baffa0426c81c03ef95d6c707a7f3fb4634d494759287a500c427f77b6d5ed054a9b854c338bce2d756765dda4dae6cd5875a35270d749f0901e320c4d4f3910c8688207bc56bb3213b26a9cd08b24309c2c7ccd2392eaa3d72ced1042508aedff64ba05b9f53d99b13d55d2e19732acf30b8b91cfdd45273b44e717dfbca4e946db636bbf4b92f68542ca383814016343d60cdb5d29099286945f747e1b5093aa433cb330ecf5763f5c3e1ca4921b9e76cb8f9aeb7588afb2ccc3f601b6e3d288236c2a79e2f9ccc60174e0bded79a5c4939621f22fba299e4f063c9ab7bcc40e3aebaa660e9371f598783d04ee30286eab3d8ad05c761fc1f1cbd3cd638e758c5095cd8020bb8b49ba8a8a0b4f3f8a2d790ff573f1de02b50ea7c87bc3c03055668b4b6ddcdb4ad37d1184f01e89c15004880bd25f217f9d583137c2faf1c1e639416237016daf25d01281d802be81d19b53080cf28fd199cf6e3e82ddb5e580d75cdaf11e01b653017c0edc5ae8b46a38587f4cd697081381b4522b04205f06b61b584ee614f903c571d59199dfedce40fbb83b40a3645921905798ffa970b449e33afd2f4e2aaeaec60aebe7afa91aeb31f75a655fbb51b1fa1a9e7c674d238b74b30a9621883408160e61715b3324422f21f6195495cc01b846a4120564feb69ea71693df1fd79cb958ee62fd08fc0826d37681ab4952dd384c085bfad4740dbeda7d7f3007dacddab809fcb6e90bfc7bff3883e6fda22089eadb2f9cdeb032df6e84f41020180b036e55045c78a1d03159d8f60566243bd36cd57df380b0d1361080e3d43b504fcf185596c83ceb9ce9802074300a8eb1f82a765a995bac271a84827d523501b7a161d8a3be91a03c8a5d66de176f20761ee045fb4376e03730bb079139c7e2ae88f432d51252f208a81908056c768310115765116a44b754b22788ee60e92c9d6891dfbf601e20cb2bec563ec206b96a711c03ead8d45a6f0ab7a8144f4ae8765ddb3f823283e77aa9af65dd62ecfd77e53bcfcd1c17b72151d0b168482d1ce9ffca5d95add08b0e7168b062872dcc78da64afff72fd635aaca09fe6fe15cfaa23a0c2bc2d0c32f5d901974771df6ddc5048b04d6537850dd96ece61d777b9a1900029e75b6cdb95371f62757e132974fc8a8211ba74984b40f2fa91910e635f6f8e6601d4c4f6db2cf5037419a7868f88b190af3e1883a6ad1e57861aaae8fb1b8ca176f47ca4834e8736abb39022ec59a030b943e2388a9214dbfa2815cd6758656200c3f809311f925742920a201ff70ca2fc2cc43264d38f786207991b81e7ec0f42e342a7c475629407e879e135216fa0b6b43dd7add02b8a2c6f681d6d63d735f03a17c92498209dd2265a34a3941abc504613d768dca63eb555a0a186d79e3e5c5703851071a3dd933b5d27637f6ca6f2260e2eebfe383aadedf5f46d6e6c979c9a6b818600a7fb6c08c0ea2a511aaa611c02d17183f285b2af620a1c81264ed61723d95299617ba7db5f3f417a226feffc683530853415b3526d13bc3dff48c43853a31894a5dbcdc453244c4b7f45997c484e183f8e5f23b2153cc03faac912ca4e4bbddf5c9f2723062f98c3df9bbdcf0b76c0ddd63a2fb46e3855340f62280c1703a3a7e9c11202ddf527fe64b2ed9833d23df19710364dfd4091a053622194885bf02f8b9dbaa7a531c2a1417855f1c1b970bcc79bacb51a2ba9c5a8f9e5ba56e7a9489eaa75cfbdf4cb24660a525a18b45a958e976df9d4838219b9f3c2504597c3b15832492f79a58b0e13c572cb3c71ab094c0a0a056a23ec1bb1d3127aed92afb1d57ed329b1d6d9de96f915d1c3466f97e253ba1b623a5488f3ccb84f79c7101acc59410561601e661dddaef9427e97160f137e9675864dfcfddb98f9a9dfcb08e8a7020596b4901f12ccda451f77b74d6c69cdaf8c14576bba7a7d4db7f58387d87713753d74fcf51f9a63b5b0122629f92c90634b034e38c1efc9b70249c78b79e66667e4c36b59f31411aad7ea3257c1551a53103c8d986123f8c69238d98e3800ef1b3959afa552a2deb2076254d35e00aa1bb0723cfc6a48619a89be280bdac7863d985e1314d31e4af1ccfe167349b667dbec4e715a843cfd4ed3ca84e4a024fbb25d8b7cdc6bfe0675b8eceb9deb3ee7da486d1a394d3348c3007b94e4909f25923bedb614aec94e851b21889976d395475688289d283e10bdfd86f82263fef48d2999a6d64a1ee1ede73c769579149c492b091a25fc6edc29c7f83a4fce0037dd6494e347730470e26fd1fda967fe6552664ee0b6945ca99eaa0033a16d422b923f80e568184830ca32159cee778b1a34ff246182744b6c8919e9fc5028d05a5c9c98aad6ed17be3c7e6e7ea38c578af9b94e0d5428de83481381ffb35af3285dbe7ffb5f84527ad549d50b26459b19e09f3269d779e42dfac4b933f7d5374cb344d9212b6cd98709309ee70dfedb4840e0a3cc390af4a0b0babd2d7294d2d9db87aa3fc69ba722d01745247c9bec60f754c8a3436e314d54da87fd83c6575baf9a27600bebd0fe86e75663d75b97e1a827f373290ddd2fca2099dbe41e5969fefeda11dab796fea5608ae1fbf2e1d1c9fb41ba3ac0984f7717ec2b430c88c2a1305083c36b8ff4b088d0328c35e68007142b1f9991294e138929c3e6087ef54d3503d50567c9419d3e364b3cbc69b96e929d83933f15db6cedc3286ae1fc2b1f86ed81628d101567f85f6ebb6e5501678240f66a5a31e8b18650b19cfe57f6fdd6d4dd975cac310b2618edaf49f82c0ed70f9207a07f48da8ba5e8473a3d6ccc6e0a1c9382d0c8153eb849af52cdbd3801814bd871e0f6bad215cbe5d655636a00f5a65bfc6f2c4459c759bea70677704337804b7e854e7f0a9f29194a53159068145d7750a41423e5e2fa03eb0b0e07f082c6acd1bd321f9a98c5c78c4767997fd6ba0c11e9c5761a4c6095638d7c06ff317a198dc6e1ec541720c780688e93633b1a30c403b76e90848ab0607062d3eb73009a8707907e36ca384f7a211117b047e42af306c9506938baac45cd7d9d20554e19ea54453d7b6adecd3bcafbdf296e0c43ac446d16556a0345439538aba29a5f77db7c9aa78cd5eae5dec5dd638145d284a52d5c8fcda62a91e75f4d5097f0625aa257b4666d2a033f87a5ca563745154be1f87e115925607d2ee36211b35deeb67e6b41fe9c35ead0b14aff1dc90a2b1de0b984fa00d95a4ffe54101bf2c1d772e84715b2a7817e2bdbd3e06ccc8b68d2e4327e150c180180195ed04b0dd309914066ac3ecce19659f080b33ea3d7f4b38e177b455db1087415ee809bcb00a27f62a425c8d7b748ed869ad56b46fab9a8c272da79e5388d61b4e6b5a1339072e99274ebb7a0327dabab646834a14265e8da738bd97d1d75485388c55fa477fa49078443832387750ccf573ac70090491d11d856110f8972e5716a945019fbec79efd2e0c26858b5daf8f8558d2d2683acd422f97faad72c5c3788b69cd575e19535f5cb01b958565d36cc57bb497fcec21a444570ea90b0cf4becf204e38b81b4eee62d0ab5ec6f5daff73b9d69154acff0a31585da42cbd52f51f89b7aeb5915a73fecbc097861271ef2eb8173d67d148bc6b1c31deb57108a813cbec7cceec34be5c0791e80f386cd77b1c9455f8f8a42001310f836cf3186d9170c51f6fc46d64adf0d50663a3ba5ae560307bf5ab5c68ac5b9307db20a3da4b47e31313889eff1fbcaecf1d9c52725fc33343294632384edb365fe9c0d49d714e4739f38bf929355a9a64b9c2ce72149b84aae8bb7352075c5138df934537845fa4d80fea8cc9dda550efc313aaeea2503c85dfd187df00da75835934d6865cf0b51f916df752c53157b2e5aa460f9b1d6af0cd4a55fc755016f203c4251ef462c741b18c9cc36fc233a0770accaad993a6a52be47bf270c1a64f6e9b526f779b17f916742582da15d16874f59af44b69ab4cd0f9892f3c080de1ae69759f7bc9fb9df9f0e66ddda7d6f487df11171cc30912cac76885957f57f62b8240f69a94d308a9232c26b52944970a67dc4438849ffbb54160d4560c593ea1e62022dcfbdba11970d1f2e39243fe09b94026244421012228aafa839265ea2867cb373e8d3ff69552463e7f782b8f02bbb7ed1b64ab264d648576feab170d9bc34e43608dd2614ee49d4229d975bbd567e4aa4b157768c843ad35e897850379c32a4b6acd11fa3f1c78d70de49f2ca1f43dedc9782fade3e6a0a3f0f745ac7f1dfc94320abc5412cc39a8af4d3fd2ff30c563ab2a6b1a475834d4d9155ad4ea05e6758a0ec8a35d6fd2a4f850a7a275079f52721fb554a88bd4bb7ad129a2162b9f257a03fbb184a88d6358b0ed53ff4af5bbc10628bac9f20de5704b00c829ac32f22f728277a71f7cb3b1d99fa60543a89c823a20f8db0d84d74d1138b20551d9f41c83dc82b78de4c33c8893ac208015bbf1ed83009d96ca40d3407fd3e472561dd4cf65a6b7cd19a2178a6d2e3d24b2c79e1e794f1d5e95aa95a5b111e13e4497a8075a70f1428317c98d92ce6b06daaf113e364b98a3147d8d764abc14e2a3bc95d8ef1e13e02915d400a3a21f68c7a8cd9c9e890a55079ad9a3167259cb33ef21ff49fc36c394971a7a3bcdd58cec8a5a8d64d9f1e67f2c6f33983809d9b3b6650bd205d8af4d5586bf504d56cd8208ed5e9a5635a1b14c652d34d44b03d8560639019c11b519d2ee1c327aab6caa7db6486e4958781b5e70230a336c3d8ab7b8d4131abc46d50d902898e811e1ca9e8968e2c4c6ab26a625249a5be9024c757925bdf65562660a330cc54a32801f18d739ce9b85d947b5d4a25ad5601650f2b0f1e4e2d8a7896b515c5465817ac91d9ae4f2b27c0bc63f27c853b7607fd1838df538a0168aa592343c732c1aa92e1f4d4d056b8ebcbc6f4e4d64add77120ca526d039b08db8e117b378291d7eba8852de4bcc5bfff44ff96ea4679a63adcf5502d22552af9a35623fe74ad20f334cc08db78eac5881986d293931345ea7a3ea2a9dad317d14cd5b3e5702d4af2ed615822c81d38f455c7d25bf506720ec2502302f1a6dba2926771adbd8e6166122b4ac298bba6bdc28622865ec9291d42e0302317cf543ca44056309f5c6bb2d9c62942c93d31298ef3ff0dc3e749bb6ca06f88913db4ce364a935b6c776e6ef25ee60ee6a291012f2f4b38282c33d13eb34e485be4056789d4f12581cb549c9dec485c804b1a5363393e5edb343d472523676f53966786ebf9267ee31a0e15c23d6a27e1bea61853b89ade0240efb0d9fcd3752ac6d86f34e931e9eb6b0c5f21389d0bef43ae3361e74f6d511bc6b7afb7acdc7d429adf49a460e75dc6ec3b830e43a890e53a4253651e2614c9822182a0ab40493189ac631c7cf23ee8d5fb9fb823e67005496484740d549975712b2c7916547867edc6cc2489721f483740ecd244e791d7c0b2e6dbfc37738457588ffef6f71033586b2024201fd3fbd0e5f0fe9b0644ada4c8ce7b0c070dc1f1466a512c299caf76d21e76277dd016fa990026004a9a006e5a4574a023e8829f9186c4287b1042249d6594917f438ae76b1309cc183eb82599ccb03a7b9439f6622636bc864a77c599447359137bec84fc0b9b016aede0c0500162e746513d165f491af502e5764ffc349b978565ac53c5619a0b62f382e081b082199874e1e4f02ea2404d4a4849aa466a6361dd9589c9d76fc91f5b4b47dbcc1e88eb7290c0dd1491d51696f302f90bb8f5ef22d927fe74717b8a7cd9ea3f848962db3aa65186923d64e9c6427f956c1363ef5bde5decc4de4c1df061807b217104c74bfe3a453518a0992f992db3da0eb74c33c86cf395c03d3ad05acae0f3583530e31d02de6b6ed12fd93659c7d71d4758f03c0e3f3c6ae3b8d521bd3d6b96392c9f533fe25c13241c6d64ab5769d18e17ce7c04847eff364ba2130e20518e7f0194025990bf538992999634b6338b144a78b63946d36a83a718a0bb7f140abcb6e888485bd9f7560a9fc409c05f76ca9c6c5abf4c3aa8a8bb96f713da02fe891e34488ac5431db578ba0608005657df5c464bd5a9ddaaee68641715d55885e01d4fe7efe8985c06832efd1ffef2045ddc4f8a0220c148ccaa24cae6dfbf1b554f3199a5faac1533bc80b4bc477659bc3c66c603a348d22e9dd5b3c47b8708b6f32e5feab97ed2085bc51713b06dfb296c800c6ec5933e0b62ef70b10db47e861218c70bc59348bb5f75302b1be0eec2b6b3ca003719c3e595285ea1ff37a592142b58df27007b6e1ce5567a191326bb56280c9eafa661b15f56cecba6ae4557c3d82b1019e03737174d384f1695d5d21d0c166634f3eff3e5a5c8d9fe779befd2a2b510f37c07833127506c44b90642ff82ae3834a5f40ae9acee1e10c1497442a7f0740ecaa5846bbc8211d0be697fbb40b9766e82e789820f9b7313702b20cf7015270deb1305862bfdb83099501cc05f77443b8e5454d436db75d17e18d055b813d543f9b5a69dc1262eac0c9cf8e971adb79a2ad77155992f9bd97936669569bfb9b4096fbad4d1d76b02918e5351e63263e74b40a81791b627b89fa4814640fb9e7607f0da80ac5e5cbee2ede5997bb48d82ba1e8ebd95285656ad6748b8aecc14c1f838382f2b224fac7d404cfc0e252316477379dbbd3204ec57760d1d30b0a871a7ec39821c272c7f0376d071ea3aa483e4973b3855ce2f577a16afb6e6e5ce2d7f0425a0b8c1e6e97c1a8128e563285ba14eba62b61d49750f5a20ee0fe0c2299dab92566428c200e17de577c93323d3af00de04cc70cc6cd98ca77f7bd09c29154cbed6e409b006a1e4c672fb80635c11f77f93cd217575ab752c838106e1e402a9f921ab2b598215dd104134ae182811e7a9088a194657fc4f735f065f4670a0c230658914a180bbf31b14d84c592f2279950332b391f7042bfe49086e20e948d3fb03e41b8a90ceb9bfaa5d638895535f90c784fa92d761a9ccb46d5b791d742d9430a7ea9300920a820656ca5e5946ebcdd65aac58d84bd8d9dbe1c88afa7b4d6c6cf43e5adaf654062ae289bbc1ea7ffe82db539932ba32eae82cf32730ff916e05284ee252e8b0654aede82e0ec5e09f78a3cc072b3a4ef4535ee458e3b45777e515e8f18f7a508169322ee4169696031f74720bd0925ba35f9e0ebe67cee4646ec3a298209b659b113e0db1e2a5d2412f74c0128d8f70360c2d31b3ae59f45377ce9490c15407b01d652c146679740027085ba8e8961e354fb1db7d821b6d3fbb443609d6af8b1259e27e4678a3c0ba3ce43761a8f2a2abfcfdd73ea0a9e810b0f0004aa00f9829ade129e1c3ee8b4ff8b6696461449a2fe1f5932a5049cc3112699931529b11714a508c6e7e760bf617437918090bfd56504058acae5e5ae725625a3fd5f3fdd7ef51604b38ae6267e0419d4e3ba100fbd437e2d61a994cf7ba2e9a48a0f2ca439a2c390c542e6df56a43665ea8360f59e40545062f66cfdd773faa0d88cb4db15b84ec857bcc023d397a73c3c84ad17c5676052a9e9bd9af861e59b0e5dd88c69cdbac84345061eaf908301ffa8550a76df7f151b3564ab1a66d7d2d958ea4778d46bcdda80c43f015aa9bdb91dec85dd0994d02275d5ef84c15ac17c6f0f341b53c83d431ac4ae38342ef472ff047de3dab021d27806fa9c1bb40febc082f48ee8c4061e199c81f6656d77fd310706aea651589d7b56aeb5b84ebf83f35066000dbd2d90a2ea42bba2651a8e7e38ed2d685a97f910e5714bbd746e7a89da6da3d80f777acc5c26f318955becaa6a1b66a1c53ba2abf98fe37c4d70a1b2f9d11b823006808c3a3a1f10bbd80bd0a33c31665261c85e05ac7a1459e3014898856bac3f1897fdf59b949da11aa446143045cddf61279fd53f9f791273da62a243835bf68969f589862bb1479dca2299592d6034a5977f198aecf7e72a2325418b782464b25763fb0419e9286bb1b7ea07ee5a18d69af83f59cba0b4974313139c299ae6084f84fd011a0b802eca16289f173f6e116581b304ce242b447a889c035051dbcc49a08e63d5db80e043b5ce62d883ceace09ecd470df914de4a568c903cb7f7a641f18aec01a12b7e1755739ef933c32fde563be4ad06783ac7756abaa9e93497bf8491b64f1cb8e9e93dc93ff3e0bb4ce6276b3f20f39a303e25691feefa8fe85c32946c82f2b2569361170f8c0d7cec00a532ec75a4dc2653d1e191e62e1d6e4099419fe6d9b54446a4b6f5bc763fffd50ff9dfb939a8e9d7089fb52f61737665a45dcc1eef6437339dc16bcd79b91dad817e177ca29b99b1e0fa93e458a04dfd841d724cc12b10c9604585dd479344bd3323c77931cae99f498a3b2b9a149a81e1eba57ca4761a1d37fed501b914e557c9c76e8e4268a2bc355a1902a47dfef609f0b874db833c5ee9e3b4472e9f0daa036fd6ea11a0d654cbb8618ab9a3d33dd590348aa317f431dfabdd3c0fea09f12c88646eaa01c9e5a8a179cf5f8f15295e269d3a2345282d58405ac23c82ef956964858ae5dce88b9f310377c041f7de7ac0d19d283713c8f47ec8dfd264064e5210d0bfb9f1095cbe90851ea86a3f958498dfaa06f336636404d7e24401e121f35f4dc5993a9f67304ec9852c53c0ba63ccd73ba36fda219acb1b6af758dcbc6b80d29068d4a08f0916219daf29cdade4269db989fcdff936bc66aefa2992d46457cffe44a7b45222a2749c3ebdb3bda9ac2857acfb14ea06fb41b2b1e96a3ef3a46f15b29744067c235f41f7b504d611d6bfadcfd782f05af7a8bca9e05650d0fa0851ee2c2b0765c59b72ca0aafd84b1ed1e520a4aa6aa7dede64e3b556a54458efb26f4694cc5627bca57d5bbac7f9de11c7ea0bbe696464d837c1dbfd510bd64535c631387c901f7acda64a613e9bfd7446764f754b763d033fddce505cd43fb354ab5d703449e96d463945359e5730a1962762ca7c8a01cf916bb918c4c8a3db02f3894fc1410d11b1c38cf62109d427c3df7c9b5ad2e0f5b6b15eca2b3615603eafadac31547e2b3b94505cc614b0f97717c7abfa1ee97fd43516c5de79b2bfa33c76c2df0dfead5cced269ecb183d65d2535ca950c74327ed029dc5509b460b1fd325ea9e968f3d0d01eabedd601437074b6da2adffff909f23d5648c492ad9fa0d0f9f37e1e43957f8206524ad3d9fc9ae71e4239b4f73be150bbb89874753ba00d7306bc4977cdb364426033ba14ec94a1a93e05db8ac47a49616a9cbefcdf188189ad110e38d6a027ceb664b6a5cb2726229f517b2ba4662f812eb11da7ecbd4cd1be86f2e2e4a7fc0e0a7c9a0125552c6cc1d7aed4bdc272ff1c88289957764f5a5c3d281c748c443bbcee197b5ce73c02051c6c4bdeb48915c6185afcf710ba4925562c1fa1dc7ebf9753cb1365b450d81d25e8cb54b0a3d99322eec7be510841bf680907612bc54c4f9cd4998d4d3d22a04e0310ac3b3b957686ebdfa7a47af7eec628da58c527099ed7dbf4139ac16a63774febe72de2f5cad92adbe56dfbaa411536ae9f2d2369edc8056a9b8303c32969e147dccf07afcd18421ffca0beb6b36c73628bd9ab028beedb16291b9ebd52de5a0cb87c016af7280c801037b2b9a8e3d48916c68229f33f5c00d0261908f07caf2a99b47f3276e7755eb351641ac3f7afa9be8b5b8194ec2b47db94a3883bde684efdf32bcd899fbebda3e4135af6a1513cc17855729955f35cbd0bec57c584697b99d14687d73e822b378803bf478660c2b31daa7df7bbf88bb4b529ef7093235e407b1f7819195c3e90dec32f1db9af64a765dc183eb37880cefdced934afa0962e55a77111028a47075a91bac7a676b98d69d7229783471d865a77f2ad44c4c73976a08c23fa87a108dabfb162fb9c48e5c33574ff6b1bc60a9a3982c11bec41f92b5e8dbb41fde0cf24d6c9b08983c7d0b254fd2f0e8556f1e3a89531c167832928b525490dee3210cdb056c4dd1c52c4496ef551bc8a93c2a883be015d8b8d2671a849a8c04c4094692e9c5650e4ca5bac2c2cd9fed4bbe471c44e7687c79c9115b924ccb43ffcbfb358b07d87e4c24cd32acef93e9ff473d5e1a5e5fe83c947b66a8b684a45e69c06fb4cc0caba2f8a17bef40a7c3ecf34a935539abc69a57c9ac62762925b154fc0a8e2b1ddc7ddac289c74f5bf8adc82f2e12c740d7da49563d27932d8cc0b695606a3bcadd599f69893ab98ba83b3356a71f9b85b6ad88d002a7746a94000c01bb4b31284b614f8cb5590023179567f8ebac9e4afc2422fa2820661cb0aa8e12e202781131807855bcd251598e4a76b1044bdf54b73262101e29902fbc2ee46a78267c5b3dd60b13fa0d919f8954c84202acffad90653aa91c3091b10393f9c2ce66995988e0acc400f8d892e28beb2966c4a76bf4e4203ff8de25f87587939abac05ab566c1fd82debd13b08cf0313edeeabe189ea3d4658bb39c6eb99b667df5a7202663ca9cb01d58d161e839ceac1b90a12cbf377f047dac83dcbd9231d7814b351e9dc6cb0e19642863e6654e1814c2a3ae83a7c8f357040863733c78fff518df4e3b9b80c9a5e96fc503adb2a25cb8b8f35974a590b7163fe5e07d2e18716da579ee98c8f4138b5b71c84b3ea3a0c284e6aca1e40bcbc1b31395c9f01a58b054d5ebc432aa15df89e08c107148d455e7fcdd6987126c3128dd06aacaca4987d8a460e894013f8839c198aaa17cfa6df46f91ac903c5beb573db52d91463ac47c588869254682dab4dc14f5e7aef7fa4a4691b540e32933bedf0143578299ca7ccda59b79672f6973d3115c00bee4726d87c8ab569843d392f7b8a0e5e1c7ebd6ef01589b9130d6632c8e84c6ff280efc0c5d14cd07cacf8e7ef19ec0a052e239851bac72cefdda1c571f337848b7c395c525a4cc26485114d1fb24252475e207547f3535634502d9ad7f3f42be7fd1c203e05c51a138a5f7a4edd79c841b85b121968624381e900febf006e770a1a6217b62f7b9e4a8317db91a4201157269652765e82cffae5046266d3f3db19298e95be0209ca06f4330d37b6298b58ab9ea63740f6d855c8101dd925b8b593f1f37ca239d94d2fe01e043a2d2eaa3cc263349c4eb098502e1840b1ff673e56bedc9e57875059870a8ea0cd6e08e01f99ea7f32150747cce5beb79b5b6763a339396cf2b8d82ee60cbfc9cc2004ad9e0498eb466cb803a04086578d452887926135b8c570fc6a43aaa38adbcdaa0d0138abd6c7e68ed4ba649507ab14179e3f60faf75ee6feb47382859506bc49936f5e8be99e04b71b2a19d8c08bc90db9a40d344565bd90ca91b518a29cb4b7ce58059570e77750c64e6363dc9a1560430b4d66c0e907f228352e4916db7c4b282b97717da03a620dd4b1ad47a326b93254342f78342118a88a5a84618f1824539e77d5f02cea8bfa279e52912321b2f0a84ceab3b2200e5047c797586849891ea1587e9782f72571c139d5d2f4e805bedcb041540c0dd4f9f0898a14f08dacf342a9e516aea650f9083efb05779f65f3e4696b31a7c89eda2b794c8ec50e9780b9d1497f6c6dd03a9a4357229d8cac476ef3fce62c9d3b6ddac4dd6a20e5625f633f78d1d5ea4de73e1d72496964d6f1775907712a3dcf935f79d54d85883b58eac2d7b2fb76455acf689e9ad7155ef901cfc5f01ed9eb693f28bf3f03634fd68b1356909fbe2163ee0553187e0817aef1d8872c539ee2170f604807e0a5159d5e86d6480f2c8f9a2d85f2b12b9e748da2caf43661c3d4954925595e989eaa631acc5d85ee856942c9a74a78597211d273bc9a5b90aebcdd99ae4388d6fb58f6867f7af8751129792d619c85a8971f9a110d9ab99d4f33454f9ad540575ee3201a1acff2694b255b4768bf60b76da8d02f806fe848451794f86aa81666535646a709d977baed4c26b8b78a20baed2b77595ea6ff768cf0abf4259e7194b164b902a868665388066d41af3ea4417611b0a454b7144386436b67e991bbe57ae16bb2795c42d91c7586d94437f29e4a8086c768595f06a2828fff5a81bf4bb30524b363fc54e69c532097df2f733a35ba9b1eebf00358069ad2cb109aa424a161633045d055a566dd6f1ebcbf31848402159d0421ad7042b06877289a6f5024c9833861ede59dd9de9a07d66d2bb7b9ace3db572af12ff9a6918cdd3f046e4cfca102ea7695e66ede3b7ebf0e212b8ded77dc7f6ec6f40cd8f0c7be1260bddcba930ea0f355720e9bde05d59431887e1e76604cab0aa65e4f7dacfad0dcb79f7fd1fb2f703c01e1cbcca1efea0470283b98dd70867ef04586e6e497611a848f2682f6ae8afb75b19c6dc3cd0b18d2bd3d3bf2f1a11078055f2fb17d9a45d1af05ca59125727a1655602ed4387a12994fd5e50d4679e444e97797f9cb311ccd8e09c446384d6b9d36203add7e8ffff3b7de3ae96348111400efcbf30f7a863c990847fd72e64c8196286ead10e0593fc76084a466ed3949b63a32a528f4899a547e47daa2425c57e5de48c62661d0a6eae27d22a810fd08bc6996ba66a4dcd4604d2f1fc59734760d82fdd3ee671ad8463fbd9fa370f1286cfdabfb3fcb11dfb480c6e6cddf816ca50f30e44cc601d0a10d2d382c9e3512c2b46ec97eba1afaf5a6580fca3d0cd90dfe1093860ee0a1284f3863b19e8988a4e7480b783dc988dd19ada9a6879c3a5bfd0c996ad79eab24ede358d26eea256920f3038f4e37c49a670eb440","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
