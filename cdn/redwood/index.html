<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fde3fe2a78861bb8472707df7d4cd59bd0fa045392e149a638e1a95ad0a981a65fd876918b46f38833278827a98071bfce3b203de82921b11d610020ef2b8068f014cfc5baadbbeb06820a25956ca4e1d464288949f1708597006642e93694ccc6dbe10331edd0a4946c7d8042f912696ada93de2c057cfa1d7d4e04def8c34f0d7575e1aa85218b8e18dd537bb58cc90d23acc1fa17ea0cb7e5781c13b87b51b49a50282c6780785a4f161373eaae3b3105dd54583a96463b352d1c50b411e7c3cf70228277f315cd8b7a7d2102778678782b7691b6c262b60b642c8dd415f50ddaae36f32dd57f0c585819b47fed7c12e404696f41351f127f0ac901d086e29d6f521e083e372a05114684b96ddff9bea7670488a6dc9f349012923fa952ed9a5575f2cafd5a6c01208308068b40b858e1e3020923b3a8787067c4599d3c38520015cc60b92b7505623f3d45f09a4a8dddf116c33db1e5c799b85d797e7a61522791d5c708a1906651e197c466661e2654defda4664bb795a7422c8e9a8da4cad98978f32f1ced4766cb8c2fbc2025e487dc55e6e7bc94ee6f8effa223deb2419c313ebceb6a9bf92a718d184b9f59ba97202c6259949f37ebb23e26e25c10bd8c821a0642cf518c0e6049da0a01cccf39f35d8279de8fa7583764693e36eddeda221f3b3c93a6a513debf28d3d72e4728b0b640dff663169fcf1d093369eb53ab4bbdb819cf19fea24cbc49e482c7749dbd2c9949be6086b09b31a5abad8061c5f01887f06331a0564adeafe00b8488b99d437a1195d702c56ab372b726abb0d5fb951ae453833cba2c80e8858731ba73279d282bb3fe998aedbc23ccbcfaa5230098629af2d0c2a29dda7fb794a9400b6d53983e90ae4f6bd3dea40949edbe885a8e86080ff8ec40811ebee0de4248381a5dd12c8c932d6545192b778d9b8d6f4a30b0f622268051ac1ea5728103f12011150a71a7ad23b15721d7d5162b17903842efa1826fd862d2ef50552313b6e140cec70ce4feac11329ca9029cd5137aa74cd7ea29e2b70f391ca5fd29ca090f808ab529eab35729259b0bb08c61c9a4ebe7851e23ed0c831fad5b515980cfd0d76f16be8d8f4f19e1f06dc56c8dd51661709c03044749e12701ca205740ba277390cc801af466854a328ce13e7add8d7e6521d88c7a8dafcbc4a1a963120874378cd516e15e8121b48902ce11be24676f63aa1dcdb75fcff40e1121c5d3eec1c27643ab766f4695bb094901aaaa5fe785a2ff87bb8aaa7c960534851c36e5282904bcf31db67621f417b51576551cb865ca7d96db50d59fa47566a558223fa47706c635956e998fc83c7bffe844492ec3658ff4ca97486880d7d179aa225b100274fef371905e59f6912b7d555c6cd81f126afa8fa537383bb3a12fc7a514a9e864a1e14ac32f6aab0e283ab7298569b98a4c43e466de014719d227f264d8f6b46e2a913b97592866c192ff29d4bd70e13695c805b95bd5e88ad300e00c3c75297dec786dc083e9fab37dd571e6fbb1deb0b72366d1ab868516f3c87f7c40ff63d2c57178f10c8f3f93ffd5a3a696c30c824aadf1acc9043d5c7db12c54375b21dd4fa7b7faea2ad752febb016f4cbad254083d06d9c4ed76ba075f75a3d2ae80a82b8b3794d21a02531e04be2be05f25507927c2d9b7f8c003c78c850a6e6074ead806f0bac4f4e734e09c439d6379600abc9387bfb7a134fbb096cbd1d62bc530fa05139c759dd55dc77659435ca5e3c39b3cd694db8b2f19ad4471fb3b92d1e09cce7a9655a56b7ecd35380b988dee791c2232e8f28a2e95fce6687638c01e5f021f6bc41f7fb65c3c9442f670bc9755eb2df39171ffcccaacfac8e0e3c6d70719db6158ae4a13543010b8447500c50c02d970e6d9e9849f634b1e687cfe81c71693604a936a8b48bf332fee29694363a008604a97c32cdf4f855b725c63f3f6affdc3af52243d9928044d92276927b264f66e857a2a823cd58ab7dca829319d583114a9b5a64f5b933f820f03cdc7bb65a472fb548f6ab82b27f8bc2c4311c3db4c8327eb9bcbf875b92db88130f78e4cdf1f69b53b6158792c1338695d42f895e90ca045c289bb21614c81014bb17038947f220e14c09aa9bddfe9d65cf3ba1b75994cb1c1ad26745c03a8ba8094562e47d6c0add3d5c756a0816f73a95a713d22294aa4f82da74d7854ae072a5a25983af36170b72e74d3e8b0ecb504e3d980e17dcdef7f605347d667750d8b5988634c897961bec060ec671aca5df727dd9b38940871b55999c4b1d47cc3d0f5bbb1bcbc8b610db6bfd09a907d8cba64ce80c415a47753435c0db5b2a8d3a7ed50a5e591a38cdbc7ae9b2d8362ba8ebd56d2b6bfd3c6173e0e81d2678e15b83b8c7ede279b56e3d777e52a6c19c0e6ade1a6ae7ff92c8b116aea6f2f2477b32dded03db0ab9252407f2a4b8b85d1a3a7f31894acfe58d62986b73d5ad75956695c05073235b0937bb16262c1851f592692d7dba24a108d1e0cd96b9df0b8b5e50eeeb0001c53cdd320983f1deab181be2956c3e2d21d17a979482d77ac387ede7d8e4aca84c75d4140eefda5ed1ea744e35f8327fe960269d30ae239cf6bd05e04f664cd6261a7d162d72d95f5f3ffc2ef2f0ffb23040b44038409a1f3258a54b1afd0250dbe54532ddd2c64252dec64cfe976ad142a85e9c2c0329096695c2fa5eba223416073a5deac4089a48a5bd605bb79a4128b663d77c9a8eb7edf7a2ff2ccd3379cd53c3ce75c7e168263c578b1ed54ae207d1fae3269f2fe826c58cb3357abb413234328f9f86a15351ab1e2a79c9b4b9e9925c92d16015e10deec1afcc923ab2411bb0a806e71ea39c449f39943bafb81842e3f3312912a6c86a07a5647e7ff520c6af9c2dd85fac540b8c7a7f72448761936ca0a665821be761efad431f0a9d8320504bb71ea69d18660e090ed70ebf4369a0e75296a98233207769cc320d076564ffcd5cd565290be27c0fb8695e67ade04cefd76445c72299172dfb66a6c014230970daaba6a647de8c5df9c8f9f6fdf462a84847cda44975ad0e0748d5206feab54b5e6fc5086c9592f01993f1843b4a70853b04c7148b08519c1c0ef9f721ffeb0016c4f2ecf2de650a5e46dda7e90fe5d611e4bf5f83fe626fb0105aff8f863e5406625dab4a35c8f96431b0134f135ae3e17aefa8f8763fcec33de1d948f9a94fc26d30f6335b85df8f411bbe7626f9fd18d60c8639c3600ace0d449cf9541e7114b72597e9d88557ec74d8839c8b30fe760bd574cd1a814aa98b935711a0f5c011c9f5254ed4efb8dad6a061dc2e3bc52dd03f632e1e26867dd8e0b188252cf0efaf6b684b8c5938339eb931496458cc4fe9d86ac8c876746041c0c03e621d6b7424827e827353e69b40ee57cb054cb5459967597179731bf6053751ac77fbd87cae62c1df297ed2dda8f3146818ed36025a4205c2226dd16e620313a9cffc7a645acc4cbc350583efda4635ffd147808fc2622eb59f9825fe91c6f26c1656ec84f1106fac41f52a0642d29e1fcfab93c74f5e04d7dcdcb1d5f265af3e786a54b9f1871b9b3bb0f56222b50d9ae6db6eb336c9d0fa11edef0fbcd3fbd6a8f8ad5543957da4cb3e7a24774b4f73ccfb495984d707c4201879da8197de23fcb5eebfa94bad4979193461699981638fa6e4da21d0d758c5d4c6ffe723e3a9d1cf7f7cfa7b0534b8489dc3684c80c403361ecccccab54808d6a8bbfec98260ff0178e1ac079a759db263ceb159ea1a32c2eeb75f29d9aa8ba7274d8c29d26706d725cf5a03e1289d82d44536e70345372f884176d5195a97e36a5bdf1374eedb566318c057e27a285f92d8d58dcd3b6c81e23d429fad745d517f02197d07f4331166cb6392ddfec160a9dc7d25bfa27fa66ab7e359601a05cde2c819aa22c0dc9de0d032359baed2c8e7028718d787513c77c055e978c7373e1f9d1fbe9a5a788f862ad6bcf5914a3e2971a335bad70c6fc78c83fa8501098f78edd027d516e9eed25637c58c7700dbe19c58d7b9797c51beb73270790ba7113b80bd2feaad14a1037f1bbc9cbc31f7d7ead00b9cb6a54d9b3edd2b904ac52f5ce7c1b7ff14458bc355ac877ea7d841d8376dc93b2f79e2d3713c1f4a55882ecfef23041c9e1ad0c8626366df1075d33a532fe79a026a0c45708b15167d9c91033124e6495ab41afd62703e8c2043231d4a77d83843d99693b9be9a70a61006fc17b3ff861dd3f42254046f39ad048ec364a01d1d903e2e8a1fbd79309928b05456fd05769f0d840910116ee0dd479cc12454d096ba22637bc70e9c95ff639727abf30c779076b2890c99701ae2b040b519013e909401b7d81ece35bafecebe37db5204fd670cc8e3f2e5f84bdf5bf48bef23663dc5b23581efd8bfac8065fa581e5ff14686df4a92d3f96250c5e269803f9ffe3c01fdc1238785da5e53ee336909f4ce51d37a1ac32e5b772a0d026ef91aaf57f29608d0ff2eefcf94a518b06c1e350380f4e1a1f10700aae548128137f8a0da6974c2840c221dd7367b7f47acc296db5cb80b970bfa321783335dcb4c66c66c3c9e650e3a4c842c89cb4e5a7dbb10757aa73cc0c6ff1707c1d0799e8b25b7852f40498162eb614267c8b02453c232e247fb97c92388aacf0eb0b5ce2891636bc5dc20b14d5dc216803343aa106b96859d2c387d95834404922fda52f99a7bd85e448c7a01787fcd1daf290935eb51305bc24e352fb28b79e935baa5cc3337780ccda31dae730f1c9b07d1330303f85cdd4aea4160815ba846ba2fbc615ede2ce2300715699cf566f4dbe76090d174ae2edc020f1f65ae14a4c97a022987a14db2f53593b68378dc91009cf306bd3fa06e986107e4f8216faf435036a4223c61b360f4929dcb1690a4968889c8f9ac064c2a2d726f3b897833b6cd3ed77e44ba0ed27cc1598f11c100a037b853fc0bbd95b59edc64be31ea671d2e2d9bbb8b82dfb8ac3f0da0947ed1174a7c6846fdd92d0a003fe1ea7fba6f9a43067bd419c944d6f68bb0b5ccb8ce9875c4d344404ea2f488b080d66e0b6f714908ea8e99b29966c3f5b217dbd69e0240e7ccfc6c2d5a19222b6fdd0e691c1d9e5b92ede181172265b0b9d0e4219d1d61e5da16506e94fc3eba2127d0ad9eebc12388928dd5217d996b4031e58f72322c402307b5646babccdb4a1772e617aae6c718f3d0b8ae19835ec90616347728ac2ee9945a0049cf5623426de54856ee19f8d5e634731b60657e2a07630b481a7c2416126eb5d650b07ff39d4ff43ddf58197ddbc26dd6a8f4b850c4287e21b53fb6fcf8f0fd06b499817f6cad764f38b3e652cc906de271453cbeb51ba146bb0ae26eb15aceb395cd1387be952f388f89d21b9e262d3bc1b35f0d6c99b33952363ff7f2a1e74a0f1ca36b9d8a5c0c561148a3882fba0180088557b00928a81343b02054792e799812e74be50912b3254d3db4d3918e180dc9f68e1f6c026fec9d60ba6a69e3e9eb6951bc19d6b69c7537a9690ffd3cec3b2023bb1e1cbf1d716f1114721db2b846ba553f65d8248701d6befde1638d9d7a4c8a10a3d19680c5334229767c59ceb217090f86aabac38cd269c8ef6fb31d718768dd3766f090f71fbe4cd07d1dfa1da0c044955d2631e66caf376eb998eddf01ca2e2b024e81fd20a6d155862dcb808e17479474033e842381413dfed4df71dbdd94e232c9d5e154c479468d55b3ce0cafc938be76290f9e0e8c11a066b6fc6edb68c9d379628cc120f526af29f2ee5c16872c6aac3bdc3527d93d8c52895351f0da8fd67e19c33a0c712161c5bbeaf95d5306f081a3f8cda4e19ff31baab5c31b2ef37945e0a22d048a8d9f356fb13746666aa403e141710e44f35a5216a9e6567aee812624b46a55a7c47e382d2d77819051f7f3a15277fd6eb70f5117b2f20b2f9806d910d3f012730cfc06c19c2dec39b8bf90a75b7de14e909a7359eef856ff33747be948d13ed22a644c19b27db6426e1da1e32151ff3803a3d90e4416b97d7800d8ab671b309fc3542baf9a7ed86dfbe6d4eb34f918cc0ca74ab452411a6e04b9595469cf08e7b591587f5802384b739adaa12a4c83726015482002b2447e27ff990fe7dab7f26efa4470a1b404e81e108ecf03036aa83a615a691f672f7287b172a47e1e241954238ba2360c55f5ee615013bec6a59249934e0a573a278c22e6c345628bdf1abdc61109066e49626c8790647aab4aabb53be02c57172feee09173ecbf7056228dc6129e732e17dfbee25b14629a054d9c9145a4598bc5794976a9bc57e38ce3dab557ac89365f6634c43ab370d9cbed5fbe268d57dbe551666bb63c8688c05534374af99f42f56e5354af10d43d176fb77b25f5a4a6b443b8911ba4fc636224c1992c4cff893bd5507d7f11230903153f65e548c9104a22cd8661df1c43577b664bf174200368dc7862a9cd60f4d9be602f3b7a6d81e49ef78bec33cae0c6c4f272b9330aa6f07b51c9487f1d7a741c42fcde328f8fa34107ba3a7d0c17a011616ffaf30d5831a7ccae15865ed259695bc332d518e7e3eeb5be267e41d50348ac46b28804117926a5923add75d00e2e79aa77c8f495226b1d6a80935cb9ddfa79aa18dbd0a7c0a8cb06ba180727edc88167586f33b1ab12af47451e60362dbcc81889813f4e14f2345b55031e347d19d6a39e1959f99a96128ec29c51fea219bc9480eb3245d4d329364c4b3326da474ea88edafaa063c89a33008381852dbaddbfb0d9943a5b5635b71eadfe6f63e0ce437ef6557ff02be594d682222c784795bed439ee43406edc2b947e62b70938a486bf5f4351931bc7f39f54ace838991fea0a9044656cec61ac05a94e67e7cb535cf62cf19e304041b813893357375c9bcfe95481cecc2cace98c11e49e74f6904a4e654ceae815e8705fe327a882b76dd800e119fa5a7a9c9dd98b48d87bd64cb3504f14335e045f1410251b6b690245875d69a6be41d85c57eade8bf40b75070190e9a12800ab52d9a342aae453dc793d6f2cc1e456432bc75cc1b53759e2bc93113cc7693550f3c77ebeb02d0c848bf4080b8b2bd7702bb6800acffa4ca0987f8fe153a9042c72b5073744ec5aa94255edeb1364145522a91c5a572f8857f0f71eb01e987fa7969034d19928300bb8ee63376206e206c437231dd7e9e38a7a8cd0145329deddfba2e1a7b73fd0ec1b9f3ba2c4c8b9bd2486cf13dde07db580336a4e71cfd241f7188bfddb178fb422bdfc7da7ed700658062df29e05adbe174260502910ef3e3aaddefad991cb0c0f9c762aaf6b6f1cb3a73a82c492fdd2214b03ee4db582cd4d4dc1d4f8aa1ccf033efcda640e7937abb996adb78185b40fc8b062df3a11e51e657779eac0335ba01fd82fcb5acd8c071562cd1a1cf47a9aa847a0072711152f24dcaff5bed009e10217625ee052f68f2829387d045b30cb04fc7d7f611f96b96c894af38ab6726189cbf0fbac01ad2531e816c72066773079be433eb0dfefebc92b3353e256ebf058e8c9a2863546bf01fdc858d5186a5077e4f1f062b66f1e8227d2fe8b3f1abc111f2dfe67dfacd077022b45f110f1ee17f6940c4a3e66bbb275c86b02d70aed9fedc143061403e694ed52913a22fb4fa730020296e9a6db8ea57e4ab797fcabf6558e2e2b8eb29cb243ed94890b5bd3729058d8fd98b112d433ef872cb672f6cbfdc2b0e6d3edb7a240aaa4bb28a72020bec2390172a8acafceac417c569b5841217df787532bd9e9a30afc5839dc2d872e8c7023d59b6b1d3dc7c4ab5d496b3e4ae66af63a4ffcf70ae421e8a72a00c9b3f3de2a5c76e988171909d44b6ca8b183821596dedb52483568b3703066017bf2637710bc01ef18df47c555781d4165e4793df97287dc1395c363129bea6c9964e847efba90f277ac1b51008927febe64e222cb932e55b6cb24c91921c60221e8e1219b3df259fca0c7571c713e051fafdfc4a9e4e8bac1171fc2b70d73d3dbdfd06859c139b3a5f29187b4dd6b08be7bf661d55d2da28aa2611f1031ddfac8923378588dd1e10aa07dede926ed247502a79140ab751f1e071b9779c89fba4e3e0a10c6a088f8af73aa376ce885cd4c3bf9aaae20dc769700b59b3b0e92ad5844b39e82601a48d0e716d884e25c201170df5af2625b1bdfb58e7e6de8a9c352bb7594df5255e7c7d744887b1b9df5768aaba3d5f35a6f957682b3130c48e33e98e94bc32a74e7f0148a3362b57e6d54ff05d936bfc242a06a9b06dd5e749632f51048228fbb9abd32268970a32e5a505a880e5b472177ac66774b3eaf0991b3ee50817cc64a1b27ec43d83b3a0bfcfcb60c71d7cd1e7ae134cc53cc00b1906b1e89d03ddd335e39d06d1925931b687a7e1b17a0291f91147ccc550ce0b8c4105ef00d579e348571f789184438e928c1519e5544b7ec9961edcb15309483c85d5de09c178f822c4d7baaafcde71ec8e977436f1b878eeda6295f5a4230db8756f51212324d8a5c0b7c4ef58a9b0b10c25526f373f81d5bfc5b86255b3335fc1beff89443219aca8c26a71690d364ee11917eea9d49da77c84182bfef3438062866890ba9dd91778d3402f37225935a86185d237eac76dae1ef56b0c9e598f8e6d2757af6429f7912ea0b50343783c57094313d55aff581503694ca893787db9982f76fce024b230cb8168335eba0e56cf0c2adafdc069913b1d5a9b45c450224a7cdfd9adec138ba72c6d990b8f3cc310125f7a7aa7a1151df332efcd9010508491f5ee74632c74eda5dd7dbce2838b72b6636700620f8dcbdbb262ace124e0ee862149df0f61164ebd8fa4647c77b68ef7e02c8bc0bac67b688c96e3e20d0440ddc77b9539b9687a2dc676eaa37acc25fbf016839da77fa4926553725705e9f0c238c6c0753dd90ff87db151088e4bc16558efd839d9ac01788ca31e21033711fb59f2aabad1e5d8adc7aaf9340946446264376cc8b3877df73df74c6d1fe3679fc791782137abbf425dd04414b09e0aa8b2a8ce42e021ea89a386cbcde1be7fa3e4f764912e2f7f46a2d6fec9c4bd00d6c406094f9d657d70856000d92c4f0e56f354289842f57130c5d7f1c9d87b9f437a857a499557977665d7255ceb4a8d6192ca9cd8fb6b6e9641c6741b6512743ebeb3cde70b1856d1e7eb59f77258f47a2e060d87ef02f42d37a335a68fcf6d097ebf3db459e15ca97f7c9bb7e4789c06ea35295b1a61ceb1e5a735331db26bcfd2bd3942244c616045c50b0dfae50af9b1cb3ca7ea1fd877104004fcbfcc333d7993a701976a7a12ed1e391a85d175e80ce679a7ef23aba1d2b383d731f5f5b1bf62a73a5f823a4b2bac893baeecf152e8e3d32f98546400b0e9ce3a604e757c4dd37a2966fbe0d9f50aad063e6b9a6e5ae2fa5124f0c1c7cabaa68c468ac43a19aba53e92f1d6d1d5ee01d2aaf8f56a15584075004edf1cc8f8c12c1274c187ae1d575fec39c48e1c93c029097957d26bb45ae076daf9284d3fb6737e8c1e728aeb02aae69dc9a2e161950c46b86a2c12867cec9af96f2c9981d287e16976f83967427b61c8534de35ba033de13f15250426614b2fc7a50c0ea2b9c41d17eaa17122fc513256b2bae1adcb0ccabb62e726cec590dcf40c835c3f56c119e5c9b19fcfba09190b2baedfe58a0cb8dacb656b0f499e38690570f569e30ac58a4e3b2f47735339fad57c1106219adf51b2d718eb6ac9f5a5a1628d9c077790cfedd8968097dd8a88ac7f59fc8e3d627b78b7a4a68cd451b3d840a8125946016067310f3504cc9417f6ea13332b70b8ab56a02d9463763640aa11efa160263d954c01dc589a6bbdcb0a80c29d35b8091465cc7cac2c5be0afaa7616509650409b8099a6d1b7ff6adac68bf8b2b826eaeb704078f23aa42a670f1f97733ddc2bb0d1107d46b08c6f87e5a1f7b02d9e8ee81e9903fd0bffafa0c971318eb5f5ee5991e5452348dd78c9d25c531dea095ae099e73d9f143d709fd4450dd69cca2e0ce2d83d3f6fb9354d4e6939070d5eb09a43f436bcf26786ebaaf9b7905488be7007a77d511e8070cace0cbe03bc2f8f61f9f08cf80dba39b24b0825fc57c168bc31c62d77ab6c676f656cc19f9bbebefd5c77e386fddebbfd78907ee5dc3fcbb4723da45db29c1026a5a94f43fe5898a169c94eb1fee49edd7899fcc6bcf60245d5d7a25c64fabd4255c3a3c7da7c6262f152efe8c98e5e2e5f7ead715835630012f9ea755f481268512cba88e6605da19dffa531ac41b4a323ddc95c8337b8167fe35afb4fd2d0ae4ed53c5b51d5ee18c53f86115be430ddaf8a44933e60624dd871855485468044fcdb74b833e3799c60536d56e0c39a01c0c908fdb1647c8bee454be2a751c18cb951a850a99c7b4f2051403b811c454839c2f0b4db2d9aa630c11251598d9d62be1e905dfe80d6f9c72ed8d67457bffb37a0569462fc030a073eed728e51dfc8b4264a7c580f50d0ae227cb6b6b20dbfbaad996bbed48296753714301030782bbbee9a0edfd86d0c969633708741732be49074d3e928ae12bc71d54561dbeb7636727ad257f4ed4480f831b02b288ce5d72462d30831a4e525856518f03df72dfaf57f5172dc9407ad51db663447e17fa5e693be52f92e81c06732671376190cfadd737c809219009a9bdff83c6ff2236853fb343c02539700df0b7379f761c371a151332a02fc677a53a1832dc8f257c73ffbfbf6d01993fd3d40b235ca1d0b6b223ebbcebbed2d8004f2275e037efc83faa56de43bad0ee957d1a9203673cc09214083814745e2c15002377589249674b42e47b67b989e73bdd7fc10bf86dcd0ce87bf115707c758a6d56c2b7349347e3ece2b6ffe41e64feb41daf3dd2a785a200f4d3b053b53f021ace7b4073652a2da09623eb85ad62087884e7e908d24751eda1e285a8dd103e5a8db9d210a94556626250ef7d08142c8a3a0a03d44bb9dc6eae4ce479566dcf81529e87d882e6a6790bc96b69a05f4ed3fa8cae55a8e319190b079d221d511476d39e603fe3526903e14d87ff3bd8baca4407aaebf9ee27fa7ddc8c3ce19216ad144251befc77a7cb5775a7817898c95c3930f00c4f18fb608efd2060b6e108754d6de95fb9977e29bc8e39adc2c1f8ffb8cf77d513cbd2153254cbd297b1d6e61b40843977ba7258b316cf56d17eb3530db161ef10c87892c2dbec4ed0710da66505a5e175a0557bcf4a11f5e7578d6f17fe1c2128308b488b0ecf41bbe99e4f4a0ff782ab50dcecf0985b271f911d7090ec3d4abb68d4692d92e3568d17dcf1f7567c6b41357f31708d11b0fd0b37d2b71a03bb622e1fe9c75dcd7f084f1d140962264423d406f25ae8a9265a993ded7e9571fa3ae5ce4e13105352ba9d7d6735ae014c2235bcd3f3d3a349b0514722b330836777ceb373c916297a92541900c487646ca92bb9b3e2285c6c2638613a49d43d8357be63a6ad5dcb2a508f776c898188163e4d291d48f75540a1270fbe729d0c00c9aa6034f14c796ea46eca6cdb0ca5dd89181e30fd2fcce5e4a9af4151aa7aa01f41c02e8ae637d2c782cc4ccbfec8725a9050c716eb51d9a844b1d3a112cc5d51b4bb1e0e953fdeef6db56e9d21c0ca076847e07c19cab1c00e3dccf8ad117df91f8cfd1fe62bebdc134159760f3d4ae4eb5c437bd78b9233ca34f1be0ee95e7c93693e32f9e706e5a009cb51c52940e26d7a13a7c082a2431c233bf40c56bed8837998e615d890239eb1ca645b7eb9ba3af1f645ae69c7798884a9c8e58b1fec0d608d64421bd59c9ef17f17b8f8f70a37e889fc2b7bad610f92d28ba4f70a372d74f7f73abe8001b7b685c69e9343fac3a430159dbb2310708a700090941a4fb8464d2e8f0cb3d164e954fb21ca00b873f144cb7f4b7eb8bf46cd89ec1018bb993ba712756e2e6d05318e693173d2b3469253d35b48d9c6b1de8b96eb24268538bf856e15b94aefdf1708ae54409472007bffdc7886b4fe449e5456d4cbdc0de6fb4f6743d7a3228a2f960d5bf7d653b0e7afc13c5f0bc3b852de76d196ff0ea3b9943deb58b71254316ed7ed6d9a10d63c117343db23f39320a60e221e7ed61cd526af0b4598b5c62498e099a55d63a98b40deb2b7e4e8ccc2ed553cba7b8f53bd52f51dbdab5b3852a78211d227ba222a0343469e5fb212b88170fd6afd3c1b1ea23b078d1e0a17712262c64122ee75ae2abf3cc634cf5979d9c64378d0cc4b13c52c7ea8506cb01c6b07dd2d0b5e3ca75256ba23770cc4037663ef29d1e3bda8beca309d10ad551df904aa73cbf047dbc5c49ba41558477f2b4c44ff98891e066c0584189f0bf89ab03d98f729ddb4410592539a113bbf14635bfe400c09d324c6261faa56cbacafe2d3a731de8feee95bfcc23896e76262fd011b75284dd8cda7f0cabd7f1c7635918b1dd882ac9e4761674c6b96e2ec5291ccfff8171e9e4a6adcc697610524eef2e09a870809a6b663c29e7ac89feef612b2576e107a506467cb4304de4e40c9237cd569f60784673e8ea27241f6a89d7b74cc1aad7b27c5d3e3ccbffa523a709ae16a3021da42812d48346237120387a714853e36b4ec56bb0753c7f9cf08a7bb65265817bf379d034c50fe75a4b2ee9de2ece8a1407779d1dd0c7dd5af7082c673c9ba82886350a3301afe7bef773d149530a0590801a7beb309238fa6e2ba8f52cb3d424669134d21fc3694f09ca208824966d023c81ad639efb6907678dbc17070dc5ec1e90d49ceca157c62fea7337ebc419370e907cf861e340fe2b26239d3fc8aea7f766cda5bd791ab236d9c7d2157c660ce6b2796ee615403bd959d01c433837769b180e75cdfd45005c4bbd3db8468cd8d17ed9b2d7c36e50939fb42010407f10499b12acb6d77d71f52de3db3401f8bb8253f0ea2af1e0952db1b393047909989bcf417b56274199efeebd94e92a16f656d9ed42081da9da9d4ef0fb11f4e8dea9d47b3bdcb409fb741d201974fe1f2a4865ebe94e69599ecb2b2a9d940d9519e061c21fb72e6df03372cc2be0781189c8da0a6364ebf6eef5c9656d96c60da520fac27e3edb0c45c2f69a37effb5446015bfeea8696a978fe4ffd9716bb3606358aff6da1af4e46a372bb036ff7d7cb998ff8aaa7336eef916eee16aa4f4e1757127cc0ca235c77046f00fc708f201511604e541a044ea2c3d425ff4e9d96f0997fc58595dd6ff6ff01b0a537ce6b2a791794759934b4f32a9a6f6a18e37b783b843c296e1fe35d594b35c17c098b619665d2433a3dfea85885dbaef6c9d2a122271c0ffc732edec68400a8fa1023cb715c19cadbd1bf4aa59a783fa499cbb260ce43eb2b9a78328bd4cb69332022e99146e67b47790dff122d289f417db1a95b2a709d400aa88a640b725631c96a8fa78625e45ce2233406e3ec687fc9707568d3cf58a3a6a27954a4a8c227fd583099b6f5ab8e691671d470a97abb3957b51c7aa856e4e15445888bc202650395675b78092a2050c8d1f15944269596b3cb5505f8360cbc134a640432247c44693c364833ee91db2d439980a7fb8a7664ce79d67c62fcfde7be5f484e293c992cc51406854a560e2b990e2e41c5ce962587697d305e5e5c4005c3926f03221dff7b872fa5ec0b5b016b2b2248d7bb26506349f028499aa7033ff85808fd89f7b738e85e05b3f82d0f843f0f6eaf6f46754b7dfab5945147d0443f18a41d373d4feafa1785ca48a308613e7798da12dd093ef0e9e327234391bdc3bdd6a9e0de8e3e74cc5c84abd616f44235679e59ae1667d8ff07946a4e7db5b7182152b192f4f95531a6770c82559e901b07ec5c8df36a536e724681648679c6f353de9f159cabffc5feb907bd15fb1010614eefc9320b000c444468fc053aaf6bdfa494497b9538816863229a12393d6d6dd49db590f349ccae74d182697171c4f4f054d4cebb275137cce71137e9c3715346e09f28f526964a9f09d17c99667b574df9dcdcb6c9887a6ad585b5d4541a961339a6fc75011418a431e433100b6ad3e025d29f15d042139e15d313fc60824273788c4a5aaaa2bc076f503cab63531f8b0fa977585e623fce58b57558423859996db30ed6dd3708978ad836ebe9d59f85fb54828f05b9c987fc482f692672b70dc3b1c0d3ee4b75e711306035618bdf049d2741dd20707910f4b93e0d6ea126f13932067a9b4972233418b815228b0c5a9e5d78dc821efb27224f18fe592c03e2012188a12e0d892d62379443f4613db9f86be56790dc62a54fd9901c4be028223e28b08a67e6654df576d78885568c50818c3d72e7829146138a25929a1349a3eb9460edec6893def69c0c4f9d271147a7db24a500ad21cf09df2d46faf3593ac9cb658ca7a463aea60addd423deff515780b5cbb5f35a96dadafcf846582053f26753d4946c0bd677fb81fc4f3ae654607f8dc437afc7bd91f6b15bfbf875a86040034529f5c069a7bf789541b9b21226a18c6f78727ad2d6ce8a7302532385ba82bd675e7e228031717df7aeab18d21b01bcaa739ec82e119b7d3b14619ccf88326aba1d3c5ab2233864762d48893318ff6c4c165d8f9ffe0d243873a0360463b40815d8eebb6dca85c53530b694e9d49d26825b87376b660a656c019d560beba36f395ecda8a321139e29ff1828df59eb3ff8831f5ff148a98e17ab86ad2c0d54b382bb6eb12edd499439c5b29855e7c2d2fd5c6a2aa09ea81cdb97ced4db6525f2b4650700250fecf2b6ec202954803111f5a18eb80962fef875c55dc5ae4c81d0ebc669038e41ef4d50771c7770fdde18ab4b4dfe8c7ef22b5fdf95c1ab857921f79a85e39f99988332ee93e1dd85b10636b60eeef9d81ee109cf27781a351fb9f57b5f39e375e815e3e2df87720fa109854332f63486208b37d32d5338e679697a78f7b5236137c89b683c0d9707834eed615c3af0c389e2a41368f447ffea33636c1156132c9487993f56e76448810ac0666e869133e82807196332dff06428c3ae9722516e50fa4f3a86144ebcba51a2e0bb8be1c43d09406c2d1e19e6c464db39007c152634e5c98e1bad91193c2e36ab6311b896758728a312b176d785f113b516a5c2050f7b50a98ee5263bf3a30cea0f4f2121dc8e6baa45c8a8ab02525475c5f46a8f705d888ee320c164b32cbf93019434f6fa2970c230e4e343b2aa24a2543891b08bab63cbe84d1779c1425cbb98dcf464c9d833478acd6c7296fd9a945985fc831ad5102119fc0d164417a94d114bb6b311de0c044aebe3059afd482621a044ec4b339fed4727db0251d217b25df8d0a10fab7864c729e197b954758fd567a92bc8311d0ae2b0b15310fbf480e086c62e1147dbf083cc0be757b141319acc41f85f7d90e7c9002f874abf3fbb08eb87bdf080322a94a70dbace8359b509ef75b17ebe70f0a3c62231edf9e7161b1c63e2a9174587dd5cddcf6eb89ebb1ce074aba3597f76ac79c7d53d4633a7315721fdc01b3675b09f77b21548fa08a43e74e6f943d9a80badfeb20acff91289671520e5d23442bb9dd4ff605b778b6e4300ef6e7d3e94381ee55c6d83f97db385bffa47d7b6c43e71de6562e002855fd2b4254e8953829bc94e8aefe6e03742a100a04cbf0855fcae696ae67abc9c6f8811e9533238082b75f3c51a6a53f36458b3bbeeec8b01f62a72a3b6b9f0e0a3880d0f768aec5d1ba07e2df9b9a25669230ab38f2e31369e4df58746d2a27766719cd8f089b02ad2491059595c02349da8f45739b478db93e5b56b2c582ead9f3d6169b6e4c96243db30e98ed7b2129c09e7c52c25a4147dcadd4b5af5377d40b62ec8fdfd1ef99f12897220ff72737830fe96f99260d860b8a3feea3c1fae34803a67049799f322b92696eac01553773813f3a9b0fae86fc062a00c99b2ce5a208480e9f044d40591a643833474f562f10da04a39f026418a4850de62d7a7bad18002e46bb3bcf4ff6e347a2c18f9b16001cf22fa60045bdf7b0cd4bf821eb6fb3632f3faa02a9671318bdbe2856618d76306318d796539df8a653b61c13c27bbfdb017d8b69a096a7c8ede2f1693ef63f8f40df00a37c14d7c49bc0c63aebf3ec0c611a21413a1a98478f88a8c2db8737a24aadd92c20a7bda8fa0a789a853c2347f2d1e5bc0ab90f41fc47866c67cac8b70efd632b29a020d65f15edce34b0b6a02da39a70ee3f3e26af66dfe11044e16945e853c3854238d10d66b284d92d9cd06fb4fa6fd4dbb90642802370283856a19e70a406b543d7d0a8208abbe40194031230d1dde94fbe2c003d19afe0eb463a28aa7c1d547620055b93ad26133f6d2e7bfa39679a5daaa12866d48c54b50d492c048429fec9354eb9b58f005217cadec22816fae9c016f467a87544d457c97cc7be290ecf42bd0fd3d26c8d1a4f4078f88685c1823db05b4989e72c5ff0e39cedb3e9a1b560c4999e83471592f3fbe9289e6ca47991247f390cf7b7a401959b1373ea9134e9fd56d304c334e1f27530047ad4d9f067dce5840c010b35160b0f6ef7242d6786d5bf6eded2e19f8d54eeaaec9717c742fc866479259620b9dfd72d8b0d28957d4ebfd4251f8759dd6687a94453a22f3bd6609983bbac42e065a6691ef91e5a329d17750d95e50626414b2e9d467ea0ba55e84fe4a233609e2fb1a3033d59b9ea90bd4d54c9afd199307c181ef94f77c008451b11ada0552e4a6d7a865af39a18524048479d14dcb25a493cdc9e9e0157e0c5ddd3ec9db39ade2f7bb8566bfc844b6ef398af1dfdf7cfdb8710e694411b785ece916a8c9ea908d453e08116697bf5603b7982791c25392e7f5dce2c2d36b9db31cc5246b2472ab64b3c5d6d9f5a88b243746df394394c3638cfa6bf4f84386ccf585ee4545047351eee7c8b805b7ee07bc66da05d59ec26cffaea837debc00baae553043742bda37dbfdb2de1958d75ba70fa7b1558ad0cfbdbe8f6a079d26a8a40dacf4337846026355e53b9abe304c7413af56811cef1e21fcb19d9a1309a9479bda30bd096e8fcc3a078398865046e4c0502196b3b22cb13bee14f192967d56d25bb79203a79dda7b31230bc07c8fa9aad24e6cbdfb2cb6834fb6aed965a7e4deca882ad707ecd71010c10dc5d52f24a65e88c54472f8a95f479e5029702e2d34f26d82d365365a583a28b8fc32273c43336e18cdc3c5e196db5022fdaa66e8d07c3d41c640486364673419f2a9ca89cf9c8ad0d83442e615f12ca717c5d1a6257c233cd3a9716c006cc0d7e68204d1510841f7ef557cb43cfd24e00605960e4290521475c45f8229f00732b65cf0557b5c12d4edce91854ea77c188feeff6fac99071030a6329c045b12bc8a46d2d19e37e8bd0290308a6eb79772b0d7b499c45e52aa0f91e95bab436cf26fe0eceb82f0cebe4beae205675186de0d4ab668fecff87e8c08c3b6a8d5ff5de0aad04a6913ec8b86ba5185b7657c2c4bfb7e0b54388b35676cac7a6db3e63dbce4bfe279c9d56da1c0d0b9af5d716e254c949c4c76f323060203e48885cf4b5e8cd78fdbfa91631b2a25ff3884550d2bab219073cd20ddf6c3dcb8a0ad48cb43aa676b9377154246f112ee7472d4e0effc0f7999f5864246963c327bfefa927f785b57cefbdfa261ed27bf5f3e61d19584686d1d7bfcc057446f823e568cdbfeb416fd9ed5d90f1b1cbf3079b7da3c261d88ee4c760362c2022b8011d795e07e4364ce66bc3ecf72f6f61518075a316c3b67d9755c7cf6a1035d71ac2124bcd4df583bd894b97a512cb27906bee5b90fc815dfe6de84850f80ead403fc1a04ba2af7a294b7c6720e53234d747fa4ee1d131be61745c10ad380ba58a2cd405664949c78cf6e9a4982a517b906fc2c78bc4c8730d1393f0b573459583d92a59cb486e83e6863574d9a74031e35d7db695387e7d9e07df1210b9154842f147d45e7637fb17d560f4d65a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
