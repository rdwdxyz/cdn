<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4dae121b55f69da1bb313af146bbc150e344f53dd0dc22fa96b05ec5ca3371cb3b5d3a9aa275f9b65a516200f1894e2700c54ddbbfa38b0d833eea821bdbc28fb524e8b053e501b29aa3d4018e8b635863807a81bf9d64dbce44026fb3a608e6f5cff072ae8cee978e432be5b73bf6e0c889f61de1af74c5a82e9a46afc17b4322318620e21550a9a9f3fdce7d6e2a45dc6c61dc724ec7673adc000047341f6ead1174930eb1e318b62a72c755ef3be49595dea8eabd1cfa0da111f8561e7109998ad5c55c9b936ee4605036f2172d0789cc6087607bcd17146b7389ed47c93545902d6d06647e4912e0c175426aabadbb81068fa79d901e922b150d4304b2e6d6805cd4a0b9455b4ed21600014c0c1b43b7d6e1569ab9fd3912e4445eacc17bb0fcc4fba27826203d3b52bef705a3de5e949d9beea49b0c1a365ed8ccc766731e7083b7cbefcdb95803b6ade9488cbbac12fc472326a632f148c44aaae342e99f22ffee72acaa4e65de59ba630d9e4fad8ea0bd4ef7672f39b1ddc9c34cc5f89b5e14752ce39239abb00b2926b0a9f2d85a526538d836071731ce0fb777643e87ace69868172f96d0d2b993dc35501e0db62140322ec867836a61578e23b76183ddb8627cdf98ebe24224e9cab64d1ec034d24bb284a3de3c7186584688ac39fc38ca75c4e0137ba844e2a22d0fc426e4c087172b0b8ab54d66bc2048c16676ee7ded9057cb29c4d2b10140c0ef195ea5f4e0c822631ef736370f7edc9db3163cf40a2579d91cd3c5848be06f00943e2aba45c192a0335572002fe3d082a6c9a42b236e62e80c2076770ebcdfc9da79d9306574da9dcec2e93374bdd96ad59fac69287dbc20382e9ec07b5929ffa84615838e0dd1f85d1e5d6dcb94105a5e1e6628402f4ab0b08090a6261c9cd2ab7ae88853223e026843e5b923fedcbebd04c5449abd4fce4364f909b57efadf0237589e5849b80542eb7e3b28d5d463c3e1b72ee232cddc16c29c223752d7e7cc563149db1bf95709e228598f556f759f0008f613692a3faa55a784c2512ea8c8072285a4a0e57ccd54e206faa4ece66d4b5b346deb1363c672885f1d56f8d74f8e0673fb8ebf75174a7b6ea880c2bd9db30cf38e837a489975a64a9fd4309a540a7c72822f45f06bcacd58c92e968aef4c83f6211b2147be265dd850ad140048348a77be5a5a6cfeca289950d182c7016d40dc6796a365b8b6a33d84ff4343647d23bf671b96f40281031187eb723fa1f7e723e05c99a691ea9b5608e2cf737624231680bfa8292e15a7a8cde8526d5bfd274b622b13aeb4727b7f92c3ad618da9e188035636839d29f7811c7b027fa4008afc41f388f7f269408062eee2d7281f6621f1ddb15fc6500032d82518b7e3ac387653e7db3a4299b6ed48a85e489be0b2a0600a0a16afd7937139a3244c42cd8c6fd490339c7a5964ac6df4fd53196da7468157ec53d1c44aae638fb9fbd65d5187e7de563c47b315d5edd897152530891494e4523bd234ab47f93b778e220d0a3aea6b42e76ab1e1293fde206ce36e63815a7cde0a3147a277ec88c04df6806e5e688f5b9bd919df3206f373eba0923b535c873df9f21916175d3169db7ab280889180def64e66c56937049811d6e8a9ce9c79435ef8c32331f0e5fab5e5ab3dfbe84cda03b3ea480f6b3136c2a2d8c457d956dcba117c2e3a699d8773edb49b022d852c1fac6a4d2a5971800ab8181b63babd056fc908339199459396a0684c3b91eb2541abab144d24eec95547c3db68267a3316a6e4d858aaf4561403478e244bbb826856377d2b9850bc4c8a2956b43335476fa9503b6cb528b5cf01196d8399f982b5ea5c82f7653ad88ed71a0a667d032f6333d0ec3d7c3900aad26e754c199f7d3cf8ce9f724e9af59d5e127a27990f809a9daf399041dc6eb236343b2f0d73b9d615cce8d0d53d2fc97dd9d411d981d7ea7ee7b68ad79520c069649ea55b5ce62153b2809e757661c90f70c3b647f5f519d41ae99640127d5dcffbcd9dc6b7f7f7b556d1a0b1e3b7ed07489ada5054e8a04dde80784f187875c89c50b4189e70a2d48caf7778df88c41377b075135f18ec324c80c8ce769944c60a35a65e01d82865597ac69e3a2fd02359934b2b232eb32ee07b3f205e8b561221cdfe45eba29779124599b3df63c45cb190b1bfcfaca4a78b82355eecb4b6a5b64213dbf03d4caff790022ec51ba49b007689676eda5f27265a05471dde534899a8846d1c615be4e3552c36def94a443ffa9f44f06ff509f20d3fe4fc21f9efd2a537e33305571f46cd7f5a09e74f72fa43b25fa4b2b438253382e03b0c6c0d8184ffeb149312a4c1b17916dcde62b200f98098c84c0b02ad313e1d151761006b4f573e4446c9da748b85cb1e99b5cbad4319a5dfc3460eece8224b0d6fed1a84f21445e410204d66cba856db4c54b9ee28d633a665f0039118d4a0c06357e12768fbaccf9af24ca3dc58dd7d1e8994fa5e9ddbf3369f28345802d62c9c109b4ab1379423580204227e99dcdbf3f141f7b29d814940bb0b7854d8da68ac80d642aa9f3e1f1640cd1470ec6696437e2a3b4446139dab943d892711f3502cc57ad155ad76833b5ba6f779c9e33b01334971807ed8662c8720b2bf54cac522f114d1dd734b1fc3cbdbd108a33ba3bff6a4d4aafbddff955ff1cc63a239606fe13bb56c209fc930293c935a8391f5f2b89ea5835728515396972691fe571c0a2e3a13a27db948cc02fc7b4ea1ce1154d07dd0ceb0c9efa42bd8ecf2e363270dc6afd58cdc478229f6f7af55c0705e3ab34ea93bf8b9dcde238fabbd2e34d9f2f9438bc78e7125f52e0a0f1357c276e3b8f75c28d2a54ed6fe8862fe4f37c70c66a6855a1e5bc2f4fc4736b18d79bddd7a15d7a5852641abb5381042d37f21c4ed7eddc3f3a3ec94b3e577bc812d6c60ecda49cd190dade071b4dc34720a8eb95ab6d9e0f7979ad101b41ee5152433aacd1986b323689059d9d253ff83849f2b81d2340533e04bcc438b0f68f29f32d62c182deec3d679661ae0a30809514adc8df858974d75c98ef90982ae851d328ab91beb08da46dd1cbd3f346b39c9c6e8fc07543154de101034b613c4fe4fc09bfdb2be82ac349ef404a05c0cc93fb4a50d9ac3bcb4fd95ce08bf6e4e9ce91eb9d80d2ef0d702e3ec35bab08020efb5acde3907d1bc1987815217b650b1561e604b2dc5b70759545e0cdfc33fbdeeafc40f563b99ffbd47e95b013c8d508c9187f646518c20bb9a09f976194eba3122a0030f43135620e270a6c04fd3b055d305d3813c2480575dfd65274160534b9673995605f36d8e631c7a7fc43be150f2d785cb4e2fa79b2f7581a95a49bc9aec91dd4e0111c3d9e593c95bfe0e4566e46c81544eab89c214e79f623b5f7ad7c9933e3cbcd19f740dca2bdbaa8a5e62f6215af1b764d9f934e75d237cee65d590b5424a7c2bdc249eac51433b735e40ac5f6873b9f17ae97554f277368f32a6c42b401b28e4c1d5efd6c23580049cd74bcce97da5fd521803d77d5a6519357899a8770d1b5dbe350743ebdd1613bb8d3ce2de839c734484ff5a01fb90ec88701482db78f6c92f85a4ea7766f5b062cf524e9ec2dccb765e8c36d9c29c22b5fa624b47508b8d8501e37042b74ba8209191af3858e6f401dc54a039bd1bd013ad83fe84ee500a168ff9a4f4ae3de78b8a01eae251159b3cc3689e8f7db4a23e48ae6fe5dc1a46de965b44e5b3f888503d51651300caa39b0e8447aae45ecc03219b7475f2035ac7a61760af53ee8ff662bbcab501861285860bf6bd63133ac1f03e37bcd476043732c2190198102eea31156a8027ac04f51689a71c65d16e8414d8f1a419a14dae57b1938e0e3648ff111f893437cdb4eac3e8c5426a5a5b24f331b82d362b9754ffefd9ccbe75a313f6430f53b1ea8d0cb7ecf52d12fd733c82c86222620668ef9a275f36c8d384098ce439ef7b7fcd2da55ea753a8d52a583cb79d85c1767d5eb7cece1255dd7bd00385914dd98a2e8412957b546d818235964183ec5323b959cdb8f2d8e89671a2cf67d51c895c5ad3d141db53c963e18c80783cfd8e08fccf6420746bb7f2444e8b95052a91360480442910a9317a9a82f8746a0bfa469faf02743b975f9ef7a467f2ffaf299016d6e3ad80e0047491d24b8cf7e46240cb50fa9c29d45d61c41da137afff67945957aab562e440d0c68560e62d725ea8067de679e4482be51b995ebbc4572b47cfd033372d2cd17e5359e926f934b7fd0fb7457315aa1abfca97a760decbc9ea7ff69736169521ea069a262cdf1025c8fc8d9b248e630cf35805aa22a2cfa4d0c68ee71d8ee352131e0508ffb2cdb0faf67c1e7123fbd9ce4d95d705714b9225c629e8e5215d13e88741edc42074229c84056b09b7802c2dab4db03934ae7336528e6a121e12b6f0f62f051de2d39e3dbf762bbf1c7efa7d887ccadd3c9eff69150d0ebf5aea54769c60b171640c49df10d6557181f5fede896a8594c8eb70a3cfe0eaf07f0c35f5e7efcac78a65c7cfbd899faa53db1de07fb4893f3ebdeb2504b1d354a11f6765c97cbb07822b427b5d00250a8290164094c314665868e5a764fe17ffd9172d940afd4a330d36c03ebbc644e75d520852adf3f2b2284f425649c8387e1cdce2ba6be5a701a7ed417df6e92f2d64852a386833bcc03f1286bb7997343a8f16d951cd50fc9a6581db0dfe45fca2c06a9eea3bcc20a2fc9bc8a2d1a4b3c1ff7dcabc5b55d90aabd03fd91b6b4d9a430772c18da33c92237c96a8406d28d881b2e04abb27d2d5a32e2f27bb7c9949fba5f0f960888c9ae245abea11b017f09cce58fbc425c4940d06349509d8c1f4e32ecc4132935d6169f651adbc9fa979055e4ebb270b85f5b521b62d65b2a2c6f7d232c95577edf599c49cef4a062375018ed32227d965206251f033da7014c79043116a601ae5416b3c13df5528acb5c8459fb84e359a5bc0104d305f5b99232b04a3c74b17a7535ef3543fbad826f9c52f8b9b0c24b1ec6fad59dafc18fef41aec3930cb541610251fdcc63639a7995c65783d05528cc8af8b2396ec98e468f6d42156675464728531880b18da61cd252496f0c40ebe22e0479a35098b1b8f4716b75ccb9fc6d9f6002232c4b142768fb26a14c5574a6efc1602cd0805aecfadb4ef4cad89c5627db148af5c69ac36b028dc151a5ad8906dba8ae987e64a95b6b8996c93540834448b5b048c90410ab6d96a343e651d67a7c5138e436c8b6dff8fb93bda157d146b1df0548c550cf54ba73e8417cf918c85c8b1be779603cd82b1d25c8b3c8a570a514c56604e13de92a752f7a6c0b7687cb66b668bde35c60b87e24fa61547853a6e75114257033b5127adb208d3559c697ba84d7543d67c92267d7c95ca8d6ef1545e75abebde706651c2a5723afe06ae9f0b4e3b0483d23594cd87913b886c7d36b44aeb1290d1ff20161ef7d23c834f9bb4290964825706b6d8bbe46d8b15a551f7e57eab5d44e3fe5949ac88f392411c3726eb4cd0df8f46b01335ebe9b14429a9577989a327899aad5ff2c4373c4326ee6518f5ae34d7528b42484761e5c280b7d9c455338320fcbebcbe183b8ed5ce8e5e3f95557e4352c102b3789039b2caf6287f842f37bc34aab5df5c6c1c57855429ba81c43bdc4000beb12cd3a46db41cc4ab1c7809a4a7fb2def6006e23bb212306b2dc65094e8a3f967c1ea7194bd6d07c2c9b521444d301c6f526fc19007bbf4cede74642313e360481ca7bf2367b23a777e87107a48203dc3fcbce21b25b77e000400e3ed48147539febf5efcd0fb3b60d4e645e1f974fd5002ac3e7d93951a4e3ffd6fcfd27f7fd5edc6aaa4ca93d6f433b24bcbd013b86210ca16693a7a0575a431c0def0c010eb7e9da1a4629a94eabd4f9049504375980e77eeb5a61c7405365af366f48c4fe5e9abb8a479e1d5e97c9384dce3855b851ef73f285dec63a37eaa1ef00b24bb9296fb63915ea75c0e732c5b36bb373fa2d5b4cd184393e9bffb5b49dfa3f934407967177a18ccab1194032576fe4894a8599d23277be79fd5bfd4ed2daa59045118f83c55d76c77887b2b569fb42dce629871d4ac093839c186c3a110b38948a8c533305e74b41a435b81222bb088857723ffde1dba8d545232bbb4d36f8d0b1ddfb02e3ae2636f55b95dce1ed66e6be04cfb6c5c5393f4b315653d493dd44948c32afbe26b186a1b7b298627069b022c7281d58b6908d83575c1c22b63a33f837944a5f300cc0e04a1d2917ca4615c159a5e51ebbcf6e62cabfac21bc7f3f08203f6c0bd0adeda70ad62b2f35f226aa98a6adb609fa43cb0e851913f3eccfbd9cf0536ab734227660487774ce886caa74d92db4f1b6de257323584918bdde46d35901aa584a376a98a0f872f83090a6963821eaf0772f9e3b5b88f034cfae8f3a6d870551601ea5d4dd88c33d984ebcdb8c3c4f4747e42e83c66823f4378ccbcd14c2d4da1b2e56d6cc94ed5cc3a46ba61985837dfce7474e802268edb6dd3f5447b845eccba37c83c0cd0ba6c32017747c9417bab688b3db3526f3aeb2be46a990fe673af21edd4411bd940d01af283240e307abb8a5d51f6acce84f330a2c51e05a69c9d44089969c5c863d38fc19304053d4d9b1a8b9e4f6d236bbcc29974f476722c60b2a076d7426d0d82b40f5f0c8dff27432582fb44d3a4d0d62a8bb9e07fbbda048eaa502c62d23e8903b856144a35ad2b453fda43764b1830d0821c85f54011112a6af539883f3ddb4c0a99d165699b20869a527406298176128ee9cfacb297ba24ce5fc9989986dbc768f0fc32de296114cf86ccdcb4ba1efb99eb1d5173c0d891d02d245067106a0dd2b26b9cfd21887234755c85b5b58e22cda9d96c312da4c65f50c00f26e01f727b24c546b9a1dfc0314faa2e2baae4324dd5389223792a02ac61bac8b7b7922adf2791b21db0381647a01870cb459d3fe1f5e35353f8901125a9a5fc08e74bc7cc4a7a4e73046075f91c978bf1f9d4d2a548dd269f429dad73f81162497aaa279e2ce73dab79cb85850294f9be6eea89556a3222f1d78901678d09bbaa5b7e9b7edc44461b4562e41a220eb15bc035e706417c9f3d46538ea4c1b4ad0a57d459b4bd843413495d7464e4acd8120bb416e508f1ef9fb45e567dafb398a176c321cfef1fd87c3fff7083a4d3d0c5172f14369ea3ef01cb5191dcdf6c4f2f96445b47b8742efbda94c955f5ee660baad8ed28b77c9ccc22bd50af9d65ad7d8dae4549d6f1006cff2658e16c45a3a966205aba7c101e145babd8fff5ebca283975899fe5b8b76451b4e4887c179e8e748d820633b71757cee57875f646c3bd799a57166b2b9ce260703342a82e9e5f30c4a4593ad44de8303ed8c5539cb321dab2d8f1dbd2597c0b102485b1dfc2838e4aee3b6ebc6f791251f321a96779552d9a621a155fa35f0dbd5c79d93fe31ef4b9eb185a2b7650306c7249ad6923cd4e8b3972aad976851cbf66bd53e3b88167c0ca0af70d6406cdf5eb76b477dc85513fcbcf7573c6b709094f4b22ef879d56eeb5895e210bbf6b6dbded9d9040b2f3f30148a96f5631632d5eddf5f2ebf91b800231782f44b450340e369b6754a97341ec029df0f9329cea8dd2f4a33418716a25efe23728ce5c1b53214dbaf8667199aa98c9d0c71707462c7d3563a8e1661de6ab983a8a1228b92767744622aeabb0adb0dfc1a3a30f58cf7fc44139a3e51a9d725288b3a47c0f414adc927324a4667e36ccf7e9f136766ccd02d0a8dcf239c0655afaff41a9de3b9e4665000d46d72e4f505179a876351650c840f0b68fdc8fd49a49b7c4c32b7a18f2fffa2685db9b257997eb211a3058c61c1c7e2566eabfe479d87b3a92614c46d37d16d1e12d2bc6adf6a1fb775239ff97f16c69222dcb2b8f9d3d8bdd1220f390b35f5a49608819076a5e9849ffced20758e43c256ffd85863a8c3c624c688edad2b2b9789cb4b2f7181d1176c7cc26c0d080b07af95522cf6af12b81f2c1762661b0ea6a40433795e594affedf42908c66fec145868c91ba738bc086c49c16666f59e7228d7aa25baf787b95dfe77347127e4c72ef8e06b412473507cea316b5af8d80f7542e01a0cd94f7c03c601111fe6095a10b64e1fe7809a5b47e42d86a0e45a98fd079b03f7551ad7f8b33df75d8af8ed62b4ab2b5b9810553e0c48a17d16b07f387a74948783201193b4d588c68bb6b8424ebd5ed6735d5811c09c469b9778a65cc8fd8a91602edfaf81ea1770ed6f55367d2d04d42619efb3c53e20a24cde844adc9d7f3b85287206ea206959c19a9fe2b8a87e2a999872b067d296b22380f02cfb8f62acb71da416e1e3723d75ee5076437f3832be455df1203121419203281b566fd1efa6a1ccdfa3e02908ac9d5ae97534819ad69882b9abf26cb71e930925aa216f6253df13131ed7ea2e23f67a93cc5cc4f57223b71e50c3254edf2921163aeab6a1300836bfdef869f5f2eb57e552463bf7c8e39664c853c96efbd3ace86177b74ef328a435f91f3f293be99252704a8f28e481f1978c8f3deb3c1afa5a6c02f87c0e852064e7ac016ed6d083983a8271967e06f3f34a00de65a1d1f512fa7e2baf3e92f08918ae3b8eefad1e2c051e221187f80bd70ced1cf098a16fc1481611c6353dca2703191bfa3e6bcdd4537a51c9d00fe5a68590f7a7bf3ba65f1d56539f57ca22ed5aae96c7efea45cfc8c7e4902be27c9dc634927738b543c0031cd1a8ad301e983ddf9f05c72fc70850b0e2a6caae79379e2eee8bd8c3d044b9353fb59700e3b63bb4b017a26be159374593407ab6b4fc08566296221947559bf414cda78e48f4d6292cd188e3781fccc87899fc4c03aa292dcb2f1e796b5090aa7be4af07b2a6f118c502dd150b27751a0f542dad77e5702b8b6d047c9ea32d15b19c58eac6b28db37e23645df2d60e9deb0780c1169f6f6ede593d8428a2b1fec2189585528329b45662ddd0ae97aaf46875abfaf17cff7719f2785eb772fc3ba8f6a89c33f217c928332c643c43d29659ec9e1dfd6154b7d93d901c454daffe11036df3306598d8fc425ce948c4a376ae673ffab480dfaca0a91615a517279d9c452de95f2891a189686bc6775cd62bd48cdc3b9d954d3e4890019ffcb60063ad46a4521f391539dd9be3e9a1c60a80acf45d8a7d3f2cf99b6f2d12a381f63bee1e3bef62822d6fef76eebe5602988aad37040e1016c9f8cdf3b4e44945a545867e31ff99206f2578f5b0b1b197eeb357a7e2ec30e7df79a408ce48d0c68b7fcf601c2b62dcd59378c58f01d9c44b8335dc678a9a76aa97386847a832a65b2247dd3a250c1fad280b0cd4096a985154e7fc3e419f7301e7747fe77e570ef6e4a3307a9cf292542362f5c7ff26f14ffdecef6499b8ad80951398010d76f9a3bfa31f3cd531c8ebac6aba8d0c8fd90de00b3e3681504af26886eaa4d6a1cb86dd15ac2144d38b11a51672845817be0fd134110959a1b299900469ec29b314537a491db78c29fe3460407700b60d5cd2f93fbe95a3b3052d2f283529772620c773bf0b83dd74ab6bbc1bc33fcb8d8d384a13f83ebec0995012e3307187564d8d101f96588ff08c844496d0f511042914b3b18bd171ab0bf408680ea1e1747dab413887068fc3c945befae7c9d3c2ca0c92863d523ec5b9fb9bafd7905577db252993576715293a4e6a5f9ceaa6af65a0b16462b23171dbecc38f355f3ac4efd0ce893c4cfb45854ac0c6705a734e20f4c2d71d39c2a092cf525aa2896f67dac72565b295a6ab53ac0fe299cb0c037d3975bc68278caa53434e31e0df349aef05a439f84dd2e9ee280d3ef7ac48592a215b9589c35ba79cbffc5e5a3460363be63b8cb3d7f5be84c5c4e63aec21e073dc473a52f7f9bf73d7aaf8c8233eefebd22b2df5cd603c86b8466b6c7c86f1497a5de53dc6739fc68f77a1204bd0c230549e4b78668254715461a95add057f6725e8036b61f8bb725aa51b42c82b0f5564d4075f8656b58f9d177e399a16b2cb08d1b66390498463364ee2fe9fae497f780a381a0ecd66575302b9c165c0ca5059432cd17a084e88b11744896f5173a46a277f383134b5f0990ba4ca62bd85744b65effe3f15268263f3ba5f71b7e6af969744bc8c1ed322cd122a8bc9958cb4f2958c58975fa36a5f9b43dd6636de7071acb7d86a2011decef8eb0d0aa679e3fc93e4b3a3c3364cf1f6ba0704087d6b6deea112503bf58dce464a4b6fcc0d9b284b31f1234233bfc58522c7d0530f81dcbbabdaca38b1bd76ac1734792db0e0891875d379e3e17e447e2ebc85bb5e5691d2397f4221cd5554b87e4e139c5e1450bb5828acd7230f3b17b16e49942910ba477d7e128014024508a3c89d5b2fdd09f287485fcdcc25d9fe20e84d562205eafa747f5f3e7ae856a6796e26f010b8c8eeb7cef48a6d9a02c7df94b3a86066a1d2c832e52b736cc7e2cc5a7bb0e19cb79bb7d73fdb9145eb45c7636432b4b7650152ed1e17d5a288bfc227ee606db81bf392d7c7c29986450707f5d20aaba67a9ec5ed48103d960e0a36345fb63005a9f99a7561a1cb5c76a9c4dbeb008d8cec45ab114ad16596813a331ffb7f7d37528c266d32569859be50a50497a7b4cba5de415420058a2bf503e7808e9844e81b86a19ba6119bfe24028187d19428c1e0b4d167ace00393f41dd4a66745feaed5e2b03dae3e547b7987aac09d5bd7fc6e73470c7684e1b41bdf2b7ae784f3eb6f2cb5b846470113a7d10aa346595c1db3406aa20f62b562917ce6093785fd2c351fa370d3464644ac69b12341d1c85a4fe320d1cda7ee725bde4333348cc3e740a71805b009bba5e9526fa2bd8e61bc3edc8d78bafaf8717ed1f52bbd3ab04d4edac3e3fc51ab9a7bfa127d25e0a2e32098efc417df66e5d4dbcc75f0132624d4ba9a400037cdb969ff8191334ceeb0c196c9a46f04021ffd6808453ee24dde872d0885e2fbe77cf50f2d03a61130372df9a5591d03ebed90ba73426ec0131625422b8b631bf3ea5a109a31729bfb071a7eb2852550063d014740adddbafaab9ed0d0aefc79818ae8cd87dabb1b42e0ecbf0c3d029822ba49e82bcc3e03668fc0ac32eaad63f25683c3489d17e4ee104204314e8486b2b6f32be67ac6c9cf7ddcd1b1bf75b7246e4035e8ca0679da19b2f0507e44261b6fc28da9fb9d8f4c1065d97f7a1b7fce25718bddcbd06c122e13116e41f458b3bc8f74467a422fd457444900c9167e5acaaf88b28afdeeb3bef5eca10723cce5dbe0aff619aca459a9bc3b99f9a31bf48f601d099b946493c4cb723cc0b6bc492c4337bf22f7d5a3503d1e3496a1cb9b04e3b669eab1c7e1ade6fbfaf939cbdb261b631c580aa6ffb6571d8a9d1626463e8b37d422481b5361eaa485305eadc7c788655ab1ca6db0c446e58d2821d794f5614fa94bede90d4531340ecdbab285e0e98f2c8974e5d79ddd3058ce1fb963b63778b7d509ff54453f2df99f965d566c6a588645bc1663cef3bdfedcaf0e56284825cfcf6470e3429baf8845ebb9b52b7197ce8dad5df580d6e4f8cb40d89a2c946c6b0098b52ec91256bf116c3e4aa025e207d6a5b3123a824d5034142b8cc5a390ab8d51ffc6d6463796593fabf56644177cd3fc4ea4f1f82eaf6a31c2f7f1db8a6016be178a639ae32dc0d7dd000b8d88a98f36d82e2b61b1531ae6149180dab73cae014b3605b2964f47f4338d42b1d33dd4557055394eb5bc0fca33f10c2131e77ae149cd5a3a5b087ddc1510d8e9ded1f75e572290c50203332d8001d75ee4d5e4dfe75f3108f18c3186cbc331851a09c54d11066b13231121cad05d9986c1de5591443a80bb5228d4848488801c26fbed0d3b7bf90c0c723960546d5cf7eb3bba0c947ed2b1be6ee541ab9e09c1d8ef0864c76f940687fe888a421c013a60d8bc92b0a54bd0cae05e9ec28775ed8919b5cc82a64ddbc0439864277bfd48f39866835c141ae918e45a402db7f63877c73d041379fd357691a4742845d2e47541e251108957510d1c2627c09034e16750a9a62be64d23199563ba2c5a9dc91819cfacb62da2dfed9e605e69e64965d60fc5133ac92a6123c3010c783f92dd42b9597c8c0401e1a55e6e1c294d325249286f0b02f1cb6912d1ef7950d9ef408624dd1be083d94f06e7cd0bc36bbe162fb92b87335c8f90f9875f9fc2b99d2215ef35cd61a3863c13c41ad59df4c90750c5041e086a2392341f9ccaa1be60ba891345c0b4deddea860c317fb0eba4b7a9e79491c714519eb87e21098ca0244814804c83e332f4108b2bcf5dac5e9ef5eb3c2aa2b303b639f84926af56ed195161e16e53ab148a34163b3bb8c69b746853fe22d636e99a789f161b80f02686ba8efa7dd3d2979e91934dd516b0d342bc94b9f0ae2b14564d71abbb8851009ea47073305e818a97d0a06f3ae9df50d1800ce74fed2431510dd4283547c56b2b77f27794552113514855604f795e3e89dfa4f665ebec74b0cf890ca478c82243a5149d067bb57246a9fa7462611f7adda0df49f014af33a65842e9dc9922b442a478b4b073b41cb27fb4677c09d2ab34b8089a38b8bbad5b9abf0a0cbb8e3c014eb75a6e3dd43b04fd2cce3b7ab3256b9692e6fb0378382500b45237d7fe071af1bc63e4b7b128372f3662b76a852f613fda3cb58c4035a1d2d8ba90c961896f7b5ec4702eb37414400221e3c0d6028f020c66ff52734ac604ec68634055eac92f06d00d2f122b37b443bbff5a06c17a4c47e0fdb2adc1d6ed8df1e08e1cc5a375366269832f26087c3235f6b622401ef9aa4752cc800af78c94000aa5e0d0f9049228436b85bb3c62b08c9493e0a51355e2adb6cd5c438c7636d22759c0314508c680737de4e61711f692f20e304efb3093de7250ba268e1b0a7e088f9017bfb4c6564f57a5c2ae41e6e0b80587684d1d4d404abd616ee7913f6686f574b8dca399d28e80e011ad2e868c8139204c56656d3034aa1c531f0085a0965eb8fe52884541cf2ea209082c7848a1b3d3532c4eb127c6c956833c9b4c4f2693707b7669517a111565f9acde0166f3043c71e7e6ecc37f10ab78d15ae41e5302d85eaeb6fd436f2cb92f899c8fb02d1afebaf5bc8bd153a74b0981bea29a3d62db025de5ae15e302a734c23b2f90c02188f6271d4fcb999646f99806f5266a11829953498c69378ddbcc4f45ce4ab6ffc94a6a41199d7b210c3d46255326b63129a2e6bc136466dd57e86ca482176fcc5dbdd581d163371fda4bb37b1bc7642f6dc631f41976ef6c31ff9ceb5e07f0a466e2c33fe9d87d809a6f2f7107613a5bd994ff1ae57ae472ee2c0657449c6545e9f3d2175dbb681b2f74f8c499fe7da9a8adb1b9ae9c6299d436ec96295d9a72d238aaf6ba1b100658b7f698315cda4167584d259628eb2345b8c5269014e5a1cda064b91c57afc05098cc06e5d26e44fc0253fdafc473d74cdc6ad7fd91f86ea7ff0256548ca6db53ac7680b225cdb71f4947239feeb5d37d0683fc39d51d0397f33a6aaac7485f7783e6f7f35752560add69b4dd869fbe20a96d08ce939aecda88f2c445ef235b966f8ac15beefd52114ddad897e44b3d2e00063fcb69e221fa48e49dc5d75e873f4f309f0cabeacc97392b4701aefae1a07c1403a67e0e7a29114dc9740792cb99144517c7247a39f58624ea0fc9a6af4d91e3df7c363f643c01523c8a84a158b7a6edb3ebf9618c6749ca2b3c00857d1521b40d4651d9ce3ae161602816fc7a9e9e60e60005f484998c1736bc5b348436cb4be44de14fb4982839e744fb182009e6d26290a2582ff6bbbd68015e43d7f347f9d9c6bb017189f6470a04373577bc6d15d301ff57d64a853798ccc85aa9c1c432a8fb2c7d346a71af25941cc65f281b42c98ffebfe2611eb0607fa978eb650846f57a97c085177aab5d6e6c4f5397994710eadac1d4e9b786381bc23b19c7d182408b4c6d135b0cbed565232c9b012a50d5cfc687630a4bd0941d857683490350d2e9014dc86188158c4ffe58e61c5fb1b7a8d10bc560961618cf7f85225b3a6d6e876d055e55ddafa44585fdb91a8eecf5cf88d4bc1989c4bb11209d3b7166faf961a4f3193a3da462be298522cc91e5bcb8b4c2dcd2c16e3cd93c4db13488f1941ac0631582b64baae3e6e2936b08069e02ea96c70dc51da0b650b5d004ea2de54d0a57cde47445fb512667b9ca629e21ee338ad5e63ebd54bae928a51a57242e16db99d93239367d0090a6763f1bb6ffd4096d25ad29d3bb5a72ebc637b938fcc240ddb29013e3335d7f1a93c3d453e851bedfc947579ffcd4a709428947818c6a5940ef10f1f682691adf5c0df8c3a1d77b0a7dc0df32df2baf68411228fcb36f6b5af2b2100438608b4d1290bc9af2f1d0ac8ad08f5257b336cd4e360d451293778642f4933165431d8a578d493f0dc7aec742cbf5470b1577c3ec9246dd996f002cd08df96ffc4dbcb7e19092a40a9f200cc653bc5d2b4b4e869fbd70e0080a1242561c5e9e3e6068d3fce7c1d4450e8e289648e9afe5b16f51fc5ee9597d213d0b81c5de269f76c5ccdf2349b03cc3de2d39fcee701c9c749df5b4db2e94087fa5981b648cc25abfb6abe22bdbd531cb6f906392077956e8b8472031a547e02189a4fd5b6492aed347c21eb650c24dfce9af431c1006d3d38c664bbebc697b9e978f09ed5f2ff7ce39c75a42b26381b399fccf77f2c1cc3983ee49bd6eb13fe97b4ac8ad267076394bb716f8188ec8bf3e1fab1d877e8cee263a7681fe85bf2789534f8a6b74dddbf8fa7a5b0610a52befc1245cba316fb7acc2efa96262256393ecffc670864c07dfcc3cea770142f462e0e42c5436e8315156adbdc461c73df43f2c5b781d8bf46894aed2e1476f58f219812b127543befd7b900b270568a20e4d2f68a2f6b188fcfecb72ad42de253c0827013767af6bb8351b61d6dda57029786b8d72fc517d47ecacab86276ce95bb64d9cd63b15152c477e8e3eb7860957cbd08b7b2749ab7c5f8c5e833fbf40dd28fdb801c8c36515a300e382ebe387be52f3a70644107349f3da8564b993b3cdf4ce507d3fd24ca9448fbaa0a58d8b3ad63a5cef2733c2631f049c4c03d7f0013906a4e39f687fcc91702895ba52f6152f130b6f1c87daabbe97b935634f26564ac73d07fa4d7f61de1999c03de4bc62c5e89742521fefeb0d29fe7280c1f0f0a0d6b478be2c7fd5ce21986b6c2f8856e3be2d8cc715e554a725646d37a4c81942c0026d58aa232da6aa63efda54f303f1fca96340e7f685e167510b4b2b8cd8bb39bce6a1254b889281b605d7f091df7c17624ad920857e032c6de7e8614044b63fa55e159029eb98d36978fcb1bc54d0611e811f3b927c6849b17774f6badd0b31f831cf22bf268cd075eee6a4527f249ae05dc88ee0e55686ba97c2ef52cd1f0715ebf78ead95c803ec6694c510202d1e9ebd54642b62da45d18a44ef4f215104de49dfe5f197955a786ace4559838e8285f477406c75b59af0a34515d1104e060d6772bb0d542bacd81b4f44d6a04ef3d3e4f4cff5c6f1d029dfe42b12a84348cdc75a9b3ae211b9fd4e61cdc3cd571e852db461473ed109ccf75068f45200b8226e7f72484557e3f52a05c47133d5bdcaa1b90d06274b1eaed236cc5d66ff2499ccf659af81b51ffa90e8ea6786ebdb12208113e763538e6fe99f2feb2af4333b449a830f738447c36abb86a904dd26ced2515fa2c8362e705668597611f4a9aae6915a958b8fe89c32a1e93353f216e7b545cd488ad8bbeac9aab94d10e5ac1240a735c0e8fc1e50c534247f8eb721044db0891aa6a9f47866de9ed469ae847ce8faa1e066a008ff9a99fde97797222fea28386ddab362a17af36414c6efd615feb176f0e82ec1fdb9b51e2f148ad409b601222572d05e0c14a0a0bcd363e703170a2ee62c215a5f4c063343a062a8c80c15265619c1b9f0800d97f08b3a81dd6db4ce61e2787fa71266a3ea1e5b297531471969444b2bc34a1e4c76c1d4dcd6effee275ed5337131f8bb77e35364f66a35350c2ccc59cb7650d6c8beacfdafa5d8f8e58792fafd9ae3b9a1dfdfae51d332c015acf588b886e1423c4497b6dee67ea0ae104d4596ea75f3c671f0a7d4dd663b23c46fe1f27499a458862b1f39f3a10ae53db9e8523d9b620caaf250a4d16c4a3668ff3c35197a37c2a340e8c64f2f17d520999ff3d6d74ab80cf416852b99af48b1ce1521f3210b79b4cc53f12d770aee3f8a31ce12762ec6f75be7ed33f2ebb5a27eebed8d3e63905a5ee32d0af6c3591114c6e11c079926c15b24f775bdd4755b56973d5542d9013ce55627911884c8c603ad4f26487d8095d0316a30f5423f606c1a6ee46c463df6687727c64b7b43e55d92419e705601bfc8e1a02d4c6b8455c044bd06498092e111946e34730998710639e887015d0419d8b98861d3f3b348e5c048ff6d7277c83f795ab8f0e3a7ea60b0cce8e6a7275560a2e535b1e8d915723a9f396f03e53303c082c16c0b97eb68fc8efa1da9b5364980f0e1bde9f638b1004f1678d80579d867e35f494db75e2c993de6aeffc6daa88574a06385fd2fea6f3e50130e2ed8b29ff7e46608778c03cc64870ea3d931be597bfbb03252237f52ab22df5798932d112ca6c2f1662c89d46c39260937a38694e0ebba270f5d0469341d08621638243f1e99792b5f3b161c05b212cb8b9f406fbfe871cfd62423d8ab3815b2bbaa6a7843395da524019b531f2625428fa7a4d381f2049335302a46c90f2a109727c49009ee4b30fd544d0c0a1a79ca5e69da63670ae0249e958998bc31c6679159f8efce392b984144210868827492864f1833f34284915e10ec484d55addda7a68dea6573848fc1463e86f6a4574ba3ddfbfa47f0f93cf54835896d5319c08ac033f0f7872a24d1009dad3e1e5ad683dc74fac8dd7e79e5f2eaf3113f6144248ad1b946976d0c87215449b0b02b93c47334f2678ee6f6df7868c133a12e1b975a8b44006fa0be9d38c7d2d6dd6e02b1857913bd00e41970b6f622237ef6aa63d5ce5334b9acee20169f79d6627514ce290b5ea8e3f50666fdd1868591eaae60120e1998f37a112e59640dd49ce7701330f632b146f29d5bd6830e860ab3b062428e46fe17f028db922d4e20b484655452c65627e5223efe674cc4702968c688453d202178ccf47bd12daef7c541f18c530459ffa848d50e75cd8816587c9f892776b4a20e346bfab4467a75aec2061d3c357cdbc4ed510fbcb8702320271c715460791b1a5e37142142bccb6c0344329864ca7f8249dda5a7eb0689d0d7a80be8e7c2e5a2cae07d6865db0ba0b1342b6d7270c1e1a5b4a76dd4f986a14a873497e6035f5e1fd6eb86e2affc1b5f327a45cfd1d31548cfd3a3dfde48ee23fc353c2358b10fbb1ee2b59883ad37326acd474f7a63352f180dd8c3927ea3df49853990c2c9be9b205062ae442260e14b2690bb3237eb8db825fa07b9acbfc83d3954f14e14ee2f901c0e4a0c80117b6100a8dc8c33e569688001aa515c05647a76412af801ad994dca0ce9ebbbebb95569f568dd2a2cee986be626f343537c57619680c71096e709b28aabab0c2f9055f4f1847584669ae4785aad8be6e17ea0892f40d6981c1b3ef797773c83a31271da99722fa3c97bf422edd60611ea586af3d6a109ab01749d07adead5ecb9e1055e00fb1e4e280e93d40fa364d535329f3da32e140b62699f0b13c91781e1f0b8ba9c4c884edc4184215342f12d604dd930412339d3e3ea9927451d9319ce08a601d2d061341f733f3f7809355cc71c1bd7db744b265f41cad83195d28cb5860e76687e427098e8ffbd7a2a986ce29eeefa1902eee3d46205cfd76bfb31e32a8e89a63f81f993f3f8a3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
