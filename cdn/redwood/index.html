<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"206278681d0ba8864041f244874965fd2bb68964163393be4f2c850a925b70c023677a87a22b4cd71b8fd0d02fec9d6c0fb6ca7c3f28819de5b8c5eea7bc74252af7ac1c35c9f396e9be19f91da163281bf4750ca5c1371e98a6fed5a2402064ff45a743a824fdadeef011daf93a6f1faddd5b72b062e0556fe9d225b9e5d08f09a89ba1380db3175cf845cf46d5c1b12054aad0e5701ef55e36e71fae1127e72db06efaac49aebdf851ff59f9010666d0568303a50637d2ae3f3cf4e358114802e5bd8e073955f41547ad1ec427529dc67aac858090f6dd97a7ea6aaf65a85b7eb3170406bd7b40f306d6719e0fcbf3c54e0e608dcdd8adac377d9abec63c34641456e293d97b5e2f2cffc17bfb9c6629d384afb7315f2b8db1b8b934c16b400a41391d309f2f04b9d844fe7da7e37529675d411ebcddbd13b42f049e07107ecba0c7eabb44d11e9493ad04a113547301df22df88a6550097011eb372e55e11937b29edb958e721bc8c18040a4a8b0f1908439b6c35fea88095235d0edbb60bae09fb639e20e5dca7617f435f0a3d6d33abd9ef1cb08f5d1cd9142be25781b69bb8eed182d10845a7c903ac6d9ba515aff75ae90581e92737964456a615e703ec5a4aaa4fa218aa3f03071992dc1a515a169dd17caf47dc72725ca1b02c7427a0ed5d3d5c7d73f03664dd4d841d296aa1e1d56b4420c04fd3c786c8caf198ae681e9331a33cc9d3bde44efe2cbf4d1b9df906fa30275b3b11f9ad38c6069818c2cea3a0b1bd8b8980ac6408a3c83421fa0260aaa05006ba6f4d3c036771f650b46df77b887cf80ff0002777eee0501a3f98b63a05cad6e6a35695f7858878a7a30f8288e4267902e8c19750f8a99fabc30da6d93ff8c5729bcede0a1bf2cd10ec698837d85ed24e1be15c83349b88cb90da18fd10cbcc354beef1c84db00f562dc90e9324f29d1b7cb1aed7c79c742fa7d63a4fe73fc6965e2ec8d61bb8430d531c029c692ddd241014673de90732cd8ee2311469c85f20ada64d496075b2d8d77746ea2503816143027f5a68e9cfc648bf8e507fbd07ef51c0bc664332528952748d4e8e95f820e7a76fa2786499b7a135006a80a1222d083bd52103ed91b4e7039191a8e4c305f6e7dfd08abfa6a8a7a087c988808748de07945b73ea28ba70258f5bec95dd3ff78671671b40789b1157e7b1a6c2e8f49d7dcc6268b56883043a160567b932eb232aa089f9416c7be478e021a7a52e8d1185eaaaf63440bdabefb8613aa3a80112e6426a81f7054f7f53b81e3c5968ff550232b40ac7d403309e7fe601d1d1c03883383ee8df9a76988582bce50dd8cf49cdce889243585bfb66c07ef46f04764ea6dd2eec58dbf73bf747ce69e6a5a9a7234d9d195bbac8046a6c1f689de6abd4ca7af425c06ce4c614a538d1d61860ce81352b68b92e16d92ce559138802b3ae08c1e486f75fc69c003b51de24addd3af00becb386c7c64df63bffd650b9b3ea455d7e8b74b7f5cee239b7fc212ef1f5a89ee3632278c32ba5a05a5798292b6bfd82c0a3376f70b2c20987b75b098d6e799b6ac7219c7e4a37948d3c443124e07028444ae1845129cbdf0e98c86012640a5df0e0db25e779ea3b4d0dc8a6abda6f3f3bc759825ee5a3ea0288962c5414f26ace31c70ca30b1dcd31c9717663eec375c18c2037385380ba3b2c9e5d50fb8da62989c981c79e43b40cf5ffc6b36847ee419e2bef9081025ebef5c4714b84fcea4eeec4fe40535a7d161bda5ecd5845674c72f67670faa81851adec6849d801eaedfaae8a5aee4b9a5f79d84f0cd8f1be5e12eceb26b97ee34e3a35181124353b7eda837a2d4ba3635d47884b66249e75a9c422d063533ed8014405eacab8bdf9ec6845063f1b528613f3a2bb553a53186b6524fd8a266ab722e8fb7480ef665e2a855c932233d3e32a4cbe3cbf202ce5e0bd492545ca1c26adf745feb7c9be0c2b42e2faba2b740b96c8794097ddd20508606f232fc82bcab52a630f1eb91dde23a4bd3c0b36f05ee978527c4db4da9027a58e9d53eb610125ce02257144dcdbd786bbfe1d162e28c26028a59d4b6242de59f5a88e4220812c120fed4aaccedd5983ae158f64ec4cce14ad874af8a1a8150d42b7c411f2c0090e88efbc42272c57f633f125d254ee7a224b41c40cd94f0697ceb29c25b5e2efc367856f59f16b4d829fe96c4a48214ad41cf306c7ccbb57835a20b1efff2b375d952e3cfe113f93e5821e75951b98bc919b3d7287b8229982ec55ab3ee1569a0172120d6c654fb30a18bdc5644899f0bfc1d90cfadabc506efccb116e326c4ffb0eae2dceee01732b13009f8a6422e5ee86520568e7bbdffe5e01e6aae00eb8c77717480ceb279a3d00858519dff9569158df8db9704cfe7b02d3ab9eee36266c04faab90a4f6e1ac386a264eaea9d029d2a0e3a5b164cbc5e54958d8716916bb797239bdddcfc5f1be88299b3ee895a524b4648239ebe108974a6ed7f4917d4fa2a8ea66f2d10ced7329d8efe19acf7958487644cde87755b04083826f7c77ac50e84463917bb80f8f9ed592ec64f7530811d9ebc12df7918ad2fbac54c80ce17586d1d3230818722daa4559024165646336bc8d3d9fbb59f09edb89b7716cfa96a09f4307534ab3b754cf4811e6b02881003f8c55b643d9441a5162d15126fd53aafd8f71dfa25965c43e7108c0332edeb7211f03afb6fc4b24ebb9cac00279edcce469869495aef2287a4fff82e8f2c5860f6ae7fe8bf89ea2adbc18cce020761b94af3186e6039dd832668f79eb52ee795cd6fdd272387f8d4e595645659a965c0bbd72ab3fac96d610498cf52625e37899be8eda4aa45596d1c5fe0cdba0bb18d359d0798c5f51d84f14270dee203397f5fca4f9abe519d8d67b8a064d0898494b212a753bd853f86d9c4bcff60fa792f89fcc22acf25911cbcddd4b59bb9431bdf3f4f2488b4551cd07575afb231df18807b8cd7a2010c59d15764406b7652b9222bd976cd92bab1e5aedb776f9eb47b0b90c7feedb457e539c938d782fa9b0c24c2c6748007e3e127eccdb79eaa3c3a9b35812e0326e7cdb34d3fc09e02a4fad1bbac3c93bec72a23fef80481e887d15504c6fd285c63fb764c210d797820bbdc7802bf1283ddaaf930e2779d67ce802394fcb0bc289281579d251b0cbdc4fd44458357ebf1b0f0c6faaff4d04b417e91269e88effc3be1c2ab64d3e93663b2995be8cec529c188f47ab008dc0b591e80ce67613a3598f7c5739bb8120a5f2a18138b86496b56a9c07c6fd20a9a58512cc5c1f79c44cf6d32c0fd3f7edf950b45cacc6cb046a7a07429434cee7e17b8c9e2004b926dea25bb23fc87a1dc0622172fe09a527e845b69940d1b35b51ca8ef6358106d3f05fce176141eb244864a7e874d4f05c0421143e14023b70e7eb178859788b8cfd6a51f32926c87bc71396beb3a997423280ea92fb8a5c87d8ffe67a53bf6012e742919378202c6b56ff4e2e2ffb53130df659a13df0f31503f290ad4f44599851ba5183905d8769361c3ee96f9ea85e67d6ab74364eaf9eddda644e7fb64a01ebf4b009ee6a9d9b1281d232b14a52acc44fa10ed5989c7c6f297565dff145ee6ee532a6e83a5f588d3cf3227a88ecce224daf9dc8e79f342abcd2e76b273c61d9e2398197d3d61e337d5177169d53983b50a14a57412fed619f998b67c5bf7f8aabc00e1748e695f070fed3436f249d3d83bb7a36705dc74ff5f3a6661b6d4271e78796830538bfd66b48870d66cd5afc6d95e32054a21e70b7e38a9df8f9fd119fbdbb51cd52cf019b5b962499455acb4446e39f0b68e0eabb4a826a973e6bb8793e8a495f5fe006b3e7f1a87bfbac3eb872169213271a4407cb482166af0004ad2e07f47a143e0b3cae2b31314744b43d6f8f96fa8c8ed995f7d18249393c0f558a58bbfa7f3cb761c4ea4f9b518bd70d5c441d565b88c39234a7274c399b1d2a8ac25641e53021fab889e8218f0c2c5f57362035bca5d962dd808dade2ddd8b2da31bebd7cd7db3560e42fd855243dba731eba539b299a81858f7d360f3cdf5f3b2ba2a1af5a7697e61ba89908afa72040aa1dc43c3dfe408deab9d6de37725f5f4802ba2ec20e79722eb82dd2b711f44290248a5aa419a8c50264745d136c7565239e6d90d0f99ca403439082564c19055a4834ea5490cc1504289a8c5cced9edef766db9390f5e53d945ee404b9d9f39834e628f980ec4ad3f65e49f5bbf3e4a21179a87f719ffebc70324f00af977985cfeff04e343925467befd525fb30c2d45cf639084228f540c3402ea5cc2330bebb0b47392499e6cf17ef6e1ec549c934a40606b62df050d6868af9d0f5ceccd6c78411275b74f4f51006e5daa0ebae91180989573126d92ca63286725145513d8f5e0664879a036eb3c1a66c690e13f32dfc90ab89e2c682b50c1708c63ea4a86021cc0c6b41ebe621d541704ca2e969a9348e5449e292bfb09ab82561614814fda7ac2debd8233ae5d64c8feaaf8cf2cf33caa758d83b9c3d2be7c794b080605c00d193fdb9879cd1436237dc549bdcc66364b90d5d7187507dede6c2285564265ae9082180aba759a650aa9eae2879a14e9161523bea3c712c39f147fe2fd93d93436654fbbc46bc81542913769b60ef9d68ad03b32b098525ae634a78015988116acbbdbb5fea20a1299cbefc006335f29948589c2ae0f346656617123067bc3b0c3afb3e91616f0e9d827385f9cdf82b2d09a9425d7df41537b097197aef3aa193711d5d187e28a75ef620a11cb3baf8087c94e9fe5d43ba5288a6c4e06ac8a62abae0762d1b5c6f0bc8642085eb0948c56ad338c516fabed1b02565cf571a30b0b38fa69cc1025a66c3e4f012e31b5e2a95a91a18add8a2bac1573311b3d59a20a2606df54ae354dc10575b3f8193525b6a6de710850b19fe081dddbe6d4ae47ff43e4e9cd9cc876d3aa7ae77aaeb072f7d60762df0c0ff8f4a38e1a9317f41572dd64215b92b42f7530d2ebc88b4e10b5c7362901a3b874bd3f0c6aca23d4146621867238bb6a7803f8af1d356cba35292ff5c78ac0ce18c910902e9f323c7810a03b71a6b6bc5b4e242dc595bba05e9454b33635595275df789744a297a8d33b269bf9f20a2ba462a74d1192679fb37b8b6f9d6e186f4b25e8ba862f29d37a23bb6517a30beb3b4fd47c84c786ef2bcf4586d34cb783a305d430525715cc5802bec5860ed01d1a758b5558f8fef58092eac5c8a4d48e7e4059a1022812a6bc4b704019231d7abbcdb2912efea98a0994eca59f63b145e2f38e894d00cdb86eae877b7e06ca3014de2da3026ca5157a6b660f63e86446c1ae8b91ed881fe6eec1ae4a8683e1cb8002e8c16809d9815ead3d514eeb219d5b86e7ad31b41e23a981f21aea35e50d563b3c59953383ee0e385a8ca08af238e8d5cd28cb9e9a80c57c10211fb23773f6f30735b0676f5dd3bfec85af7b4952a57fd64bd208e4ad44160e7a933ebed94604507bce244f3de71dc374875c0b09c225956913c62a37dd99b063ff0dd6113473029a60b7e8376d7291e6cd2c8888024f307b507f098ce0237933a6fd698939b0f8f25f01cd4f9fec7509b7b97c947750b900756078775a84d80399f98d7a6bd650b7a359c25acf61554a332c29dac51a2971ce0018ef9069c5465c799fbf64a867d27ef852ba6cbae2191db81ef02af805a8453a6a2cfa3dc965d4d34cd7a1776eeb872413a591c20387dbb00a842076cecb94f9ba1319241929d58a2cf50562d40dfca6e3afd0f20977908f3642f709b9fa3e3ab2e10acb2be6cca63011448028337d411565534ea5dea8ba457ff0b77d8dfed9ba81688cbd9e717a0fa19034301a4791cdde82f7238f431772aa6588f2db335e8e4734f917942e62388df83e16e55f9cc5221d2b2cc2dd731ffdf042638a01c5fe15fc90bca516259621eea7851ed0db84f4f728904b5f7fc10d46d143750465db5d405b308e62adc96efa2712dcd305646f60d31eee253c18c2f7fcc9f758b3d5bff514f7e1a95bbcf9862133adbab53ededdc4c9946e50ce917e4ba5e692877cd686b4c138d8b3a49d5fbb9949eff75fe09bbfc6668c00121e3870ade668f1065b4273ce1eaa2034fa1dd8a1387e982ab4202209bdb9b388b26db075a8c31ccd2dce917254b214d7ee93b3cf342239157298684fbf96691529fd57e210551c372e9acc268e9cd27adbded689f21c157bb015374c37d8f0db06282987734ef61833a7967d4f96db2dc1f58a5a9d1ae3f6ad3c5189bc4f4cfbcc2bd25aebac3967b8220a534da0c2a209dcd6781144b74a0ee2dad4ac825094245f1db619d6d84a23f503c1e042ed4fe05323f4b3e339e069541f9d0dd4c32cc59f47295e070e7c3805027e62ece0535746bee75835439236289906189483a6a927f5efbc89ddbd42ddb21ed3880d2bce1042c9bb78875631aabe4d1e42d946aa2ef20c4072bded9479f4f52286cf29a59092a089be6cd4018a536bf942a835c5437b8ed4ab2202dd3209143a36841bfd1f857c11a9a308ccf63409bc3659e102b3e9c64b8ad57303b84818e9a996be92dc94af7f7c5f5d56d2cadb98af4020f4da907663352408d5f6644c19e4842af9ac5043c9eb53d6d5c6cf8a403d1ba5a44ab9e00a2775cee1c30afaac1ce23d3222ffe4c8e877d1b426d8b6d01264b3372731181cbd45c71854c19b27a7f80dbdafe3b8d49b9a7bf469e94475932250c6b3eefd1f6bc8b3981bc1efaf7439b92b76aff6417206ed00fa622525f960e623171fddf5fdbb63030b2e3561cf050ccd970159c941aca55eaafb54fd36e22b1d972b0890db4099946d24f6335dbe8c2335e115b31cd6e71ff7bfe336c74ff97640d88e9f49d734196bca67c3ebdd331e80c586138cd25b2a6547398083e3e833a12ea06fb71cc2b546956c299604d67af2475820870ebc2e4a5d6663568e05259d203eb309e9ab1a0f3017946944b8287b6a51a214eddedb3b422e34027e79355b3d694aff1e3813d3b2835bec9de8c5dcbd205b8f0b1bb8b648600d2864ef129bd77520317da360c130a84aedce322abe243851354b3453eec6001ff62de1ee9ad8a8eb7505b9757e23ab02611f5fa29c9df1419a71ffd4d81755c386bb40e0aa4571be51c8cb18c9f321397b2fc267a95f853418a02782657193ca79bba865304293a2a6706da2a34247965ba1e90a7d71eefd6caf387019684524238d887ef36e984bdbbada28462fe715b9798d5875031e059c4c500cfe9ed57b924f77afab8af372ae3788f76fc43691b8d95f9abb947980fb2e39b99292bce385198a339c237212079590e81ba05a7c6fd491f16fd420e4d04d7db4ef3491c11811027da805c17ebffd7925132543eb5933e090a91e6ed43034fe7121d748a71f3786df89e22a033edb433dc1dbaddcae218adb9e0949f6e6a0a329f5d307e3a143190aed65d68f6e5e0e4d80d8439298d6fc730c13c9457eee7bcaeca950c1bb1a23687254fc098574a52c69769e2de9e2034a5dd669bc54ba583503f0708054507efc217e2282b4367dec8e80429d769140c69635221ccc00f5dc21f9c8e2d7b3480b685ed41644be086022ab0036054bf66f6c3c2accd448b6ca1099a6ad6ecf2e97fbecbc8170ed3a47570bd5d69a38d356d1f55b3b09c7ca2cc5b9e4536b1654c408cc01a4c97fe73d1047308b9a1b014c3f815199aa85c6d548ced815239c8a4db8d9374e11c5de1a4334b88344f4f51c23c84a46c848dcc02a303ccae2d63f3ca77eef4aab0f12b537f3acd24e675f6a19be44e0b69119d12497a8170e4212a4c1cf550d6f65f4b4f00341ccb6c5e7e3c60646eb62223586734458f9f7731beef3f0b901c2ed61e9fc3d5f548f929f2be4d616a10c53097026552ff65673c4818ede478f79a4125a0ddfc4b0ed0b4a44fba727629c3df5c5e00873dd27a9c99f69a8c4a3f915a4abd7840916080fc3a27c30f8752957f11e44ad399e473a22a0fba91ce0245045c8f1e7f1f134b556bae1836ffe33c6d25e4059915eb70595441fd993656b2fa576b6465af5087e6e14b11111a182ff29282005f4f75c60801c8d3f04fb921350077b6d7a107f55e6312bfc3c81e9f4b4da29a58cb6136d46e6c9f6b890d42637dd1b84519b951f994ce49bb4481f21ca92af59a5126abaa967dc890fd87a76bc423a13276f57905b3b3a0897ff17908687e97a1aaf2bfdd8b0ae56a09f0702d5c5b651e06a780f66f044bc0796613f030809b6562343bfe79ba772d31198bafb3066c216b9baaff5beef569601093f4c1557aca8f01d261ff9c3f87a760444a9a28ef0915c28f837efcbc6a3206cc5afc665e5a1c0b47378557f534440db242481ed8c6257bf87fc5adc6e7dd5d6ab4b89b1a9543aa291ad8b8dc14ffef36a535f6e8a4c6f97968b986c1c8960e35da07a3b2549db32bd06a91dc60159f59353db47ae2930df83caee6f8dc4465c42d20ae48249f371b962f4e51847f28114e5a475c3311fded238401b19b8dbc578f31385bb627db09df751f496047773924afe3f573c150cdcfb673fc3a82cb0e638e00f50e5db43eff8acc02e0e07243663df7b5407e53b27853590902d39858f10b61b40287dd03939628e92e322b0deb1113d8254257684c003ff49562f7edd9e0c7ad9fb85a19c79e55c82f80f086a3a87c6cb06147bd312b2441c824ddcd815c948317af02105ba6cc44b3c1e197deaa47cd760fcdb9cc7c5568a59c78431464118c5cded2d32f50a251624d8e2546c4bb7125a817de3de831c9be7cd288c6596e39b6591ce9780b35a71b637bea6c0b54dd973aa3f9baa2335f8bb60077d0171978dc9358bb0b7f71ab0f0959366eab6c921890f5f1b623d8eaf4cf099450d7e219d313295f414b75c26d5b5f28903d3619703061a58e1dac629f94e694277d0bb9a71be65cf8851735514d206ff5689f89c88e5554ced1155d3a946e1d3f3244d052804aed0355e266ccde001096d61adaea62982835160d08b26472e1dd5c210db7431b54f9dfb8bdaddbbc01a49069a6ad33172ce8435475d53b7e7322d3aa90fcd6c976c23869d2a133cadcccd25b00aa5968a4919d94c6d4789c1d842127bb0996c9db6f1494f72aa23574b11e352187b169658ce34a89097d9adcf5106592a7ea7766af1b82cde0a87c85cb10ec3c5465eaac9f115726e6df265bff0d8c25695eba584c1458be825aa58998db377c8a0e20a5eae8011e149f4dd0bb63feac03ab39f47aed123039f7cc08b91d1f8202dcecf5ef94c8f4d3d9dd10a0d902c6b9b703808e263a1031049642b68391c4d06020350bd5ef9b9f643d15e4b1e7416e7da3d4486c44549308249d69a4f2187d619a3511b438354ecb11113abc208707f9776522d3b8b2a87bb1d1aadc3795a62ba8e68e44bb46cbdf1965da2a997129487d466d818036c014172566a93f8e7d3519c7456b05e2f0cdb4cb58c4460fee6aeccac8ce736aa7780ba5c3f7cbbf98be5d0af01108bbaf36f1c7c03be1f5b119c94352960024632d8200dbe517aae9ef51dba86c7ae86ea407df045651b27c0f30f8cbe3d3d138a567efaefd1962a1e2cb6a0b7b589edc41298cb627671a66a969f6b6c97a5cc2d9a9dbce149546d310d991f203259bce8016f9ea3886b830e393927289ff4779ab68c4c8253925949dc0c25c9693382c8828483f99fd45fa1ae22e29f82302f2fd24fb41406d557af6fd09c866d21bc5590f0c660c3421f25ccdda079e93ccd0ac2c16965768758cfa4a556b71a5f74aefc8d75d31e5737683f339f8f2fe81064fc51919cb7797591d9a4375fe8d119d09e269fb85f9de9dab13a18d1e70761052e09ea5671ae47cc02cd2c4aa1c3137817454eeb3e18b8f6769cb592661c6ca65003937f5ea7083dbec8b9ed3dad42dbddacf344b64b66e1ba895bd27ecfd909c57235f1654115a79084bcae5c3c22e619d85d6ff8bdaca9764436288c87bde8123232e1ae0ff685b5e7d370ad12695fbcfeec1b13ebf90f8cca0f28b4fe9b894d7b93a0e06a32794a60373f2af75858fbc9e645902fbe9bc0c0f21bfceeb1f888f4357c049b2ccb4924b86fe40eac5980d8f0ebb7ff59b5e51ff6f2e63d16da840e96a7463d3228902c191470ae3d7ce37f9c99307376e7741fcdac6b600cef81142e9201b80df0c743dac5b7bdf2f225e485066cfffa05049af3eef354f1a7ef0192a2c6c146514f1089017d5d285764351aaba119fea0c89baac3e8264325bc65b1bcc6ebc8fe93300da661040c3fc2759bdcac442e0028ba80044b7eed9778204414d51d7a05074a602994ab60203a1a715d360b3723dc53e75b4d2d897d8e7b420a72d3bf64cc9067583a777ea0f699be9f290e54686696e2c0764208200e5b82df3709c62c6d08bd6ab8dee01489bd0b35c24050d860b20db93f266c5f821d90faccc01bc2945ffbac73040ac154630111d6ad81960e48ae3f2046882e2af451a99a92488b0b6cb1a05fece86facbc7c9e01e8a7972f62090e021e8fb790a8036bf955414fa76b4c759cb3ccfc1b8a5ed6f79b5cbe8da2e234152063b33ea033e3c877fc5e3659c5bb234874e4823c82bf1549f8bb8eba99015131031fc8b971ef925bf7f19b8015431ff05d5eba0794c197fc0f029b450c0e34e87be642c3a9f0380b58def7f625ff6620321d90947256be036ccb1f8a1c3c970f642f03ce7024aacbbe33b4411560932e51887fa02922927e509c0ac9476039c3ced4af41bc31fbb48b7dc053885838ed168d652efb9fc732d4cf29c3dee6df511e9ab259a43bf6a030bdb1858ad4b928cdb4e7c4fbcfc41afee8d7546ca14876ce03cbe912f017015456983248baae26f2b3e0defa7a8089b1ebb7363efd4574bb2d93ab64fc71dc6478f3d2e3a85ba98b399e4fc5e279cde0575bbf7f8278597fb62e316c2e6b878e994b7ebad6f78e0d963ce92b4f85f4c677d4fc5eaca83971b7bfe3bd64872ebaebc980a26f7d8dfe46e2c78cd329dadb42595b6227e7853883e3ca1213a06f4001d60584e6b47fb6223da95069587dec171b6f88d854a5197607e2c74bf492b9706e2e3cbdb85487471f0e113844f68d599b261bdd4f9eba204e8b95971f8a8f1b3524be2f469769d234933087d529a5c104d22f783da7a3040f499d829a7f30d15419a68031768f3a43c0d4ef1ae3d67564e2197fcb70c55552f299c30333a2f294e160ee1df6f515f7c9110e79c19d5d5352abdcdc874e86581d13b277092fe14608fcf1606d007a274c38a2feb08de7b57ad96f675cc18177079046fe837292e07dfa0ae8705b35c53a43ab0ce3374d0d951ac97c3a28238ed772ed8b371106e1f71228ad03bfc22f2391b4c1ed59e96406e4b9b71554d4e20810402877ed38ac549923dd7bc1b0331f494947356a22dc2ee0c4407443d85303e409722fb1031a1e0024d29003e10db78183595377350adf12d922192a9fba38a779cb33ccc3b9108cafb1ed3b7310b6413cdd959f6b24b54229d117c0e5275756993c13f1cfabc776a45f3d4a520b7f93e4ba883d545971ab7815aea6ef9332ad3438beb4ba31d3960ac1f5cdf4fb7f04c2809ac2f81a7682533fb4d5510cd6ef0352e47dc613d66d4c2245c0bc0e9e0098c23dc50aadec022aff9201f825d447911dc27dd813a59da50333038503d307ef5384a132258cc2e625bfd8093c12ec79a45810f456dbf1839a58e46c53dcc901b0850a3b63adf1fc9c8751d92597670a50e6f7aef8a79bef98a9cc15f1706a0ef6e4e7410e0d16320355b34726000d06c444120346cdd78a9c7e03cecf2deb6f9c17241a26eecec43989acba93e5ed7f35e8829bd75b8c9207d32a45bf46e824ac61dc4354a0b922125fd41b7806bbbda0246514839b047ca3d4faa8535f1e7db45b8e55feb1eb7d2d2c8bdc04af09384b0c70980f12ac5dabea64e1a61c685603839654131793a2b11409604fecc7444e1995999ba3fb40672fe9564c41ad4cfea2d6c5765722fd8d2ec5f00018b22cd2eb24a17d7a7a740284100b0c928135fb2307ea8821e50c8115b963ebb66c986dd563035a7720d1533aa8fb51d74a221d67b4977f16344ab018b842e0ac6cc3e6fd05b683d3ab28864abb4be7c10e86ae2bf3d80e081ffae412a18d33c6e8f220accd97e6ee4e24155a71b5dea199df7d0fb5030bb25abff84a28a35b99ad62ad0e492c4489cfd36e13016ac8968d357aff0c04aae95f12aca055e8c4ecbc3fcff2c33f7516027f6270df4f1a346e121e3237ebd19ad1b9a2292dc4fd4650a9be126c5dd2bc9ea2453c07b7204793226d3da0484b9b801d9a4291ed85d6bd5dc5d2cd181c64d320972b7546832f4d1e8eb4b234891b2ef1b96925bb3ea8f01307d3dcd67ddb65c6342ea81f03554d54491d05362c2685f8522349eeda3370fb53094d2b82d316f03d17781d580749dda224f7c90de827fe52c5f9e4fbe0690994ed0be882dc5f33e21d207f4bfb8896e1ddde09c3b600a711fa73225ce39cfdd11ad3719fb768d7c6a328f9ce60fb90aafb880efaec18910a98ae264326f8faed16a5cfe8ad621b51b601825346410a740ee6df47c4489c46d26b296ad6584e310a9d56d4f6d57f7687f40cb9003dae00bf2e96a0f8e8605e37e1090241a6d8d2252600a0caabef31703ec4341b981f0e9137e25a4ab7d9bbcb02653ada29d67508431f468c79b914b442e990fd13103c8c0bdde0efb9e973b94f6c10719ec11cfa9c0dc6f82e71610c8b492f8967fe14cd9787a68a10ee14275e6b9ac867b8f8b290b6dd3cf36d51013324410d89bfe3eceaffdb8b63bff0a552740c6373827f589881a5f927a03125a5eae1c6fc17ea0edb6e24a559dfb05fd91abb141086c43e3f9fb73c27c135b1e6a9c9a2a10c49f42c2de3ddd07a30e8f8322d7d008a32dcbaaf21bd3d09df78f7829d3b8e3ac612adbdca2d1f04f084a9866a949a32c72c0b7b5b7d1276c4fb5f243bb05826ecb216a869dd4246968c05e36b503e62634e35afcf2df0523f6ee3717aba8e0284d1daab3d37d1c2cf83f9302af6450c3f3915fbe41d936b4f258da8d5c98c1f0f241c6c3fe901bb79fc7e7a10e05710bc377191033154027516a819e8ef88778b28ddb642e7b0f0d5a371778b2a9106184e3803cc3a386c1be3fdcfbdc37f731bfcbb24cf8745b28cc8fa0f164121ced15dfec808a99d0379e13753f673dab44d824ba76077d20cf52a42e13a00e74d355710b75bc8c6b85f8dfbff2cf50c6d4675cdddd1062b69f2f54294efd043c1822ed2aa9076e497284b5807b843953477d1f0ef52c5d523bb3fdad43581869800dc8472f405ded8011889276ad95602636b92525f9adf0d3a9e15691544b5fcf3d0b012c87adb01225f16cdecc453c8ce25bcf436ec888604ef4664c457b047f10096beba7e2918f5ed42e96e4821942b0a2f91dbfa64c228330b03cad284e138b8371065a59ee39629eac3015239510180e1047a7c9328eaac4b8ce880013b2cf790f325c676c356fd9fdf1053bb098c5066e978e5156e7ed931e35ad0816861b2906e9bf72fba1e55700da6ead252fe692d7187b64508fa95caa251484dc0d441d3bf7769f242bcf8f701e7a7ea6ec24c00eb9b38943aa291586722b12713a8af82a674840d14b84c00603a40cbf83df2b2020cc33b81254b5bbe9c054637512a0c82f18aaff57b6928e6442021f9e13df5073ff7395e814daf27b56405beeac0d4f6076ab007aeca4700a03f74bdc39ef507aaeb2b282cddeb018a203f72ef81a88f8181432c005946f1562b262031a3d4000b51d30263feab18a389b2e8ae6e8386180d06bc028861e5658c81000d34ae1a50751a0a744cffac8eee7424999960fb1ef5748685ba773a456284ab0b725b666579d70cb45b83dbed457fe2986319d3a69dbc45c568fe5eeed56b21ec6d9734e053a46f9d13be0a2fe5dff99ebdf42c457dee0142b214405c3e3978f9db7fbd5ee461ccd8f6639a53c7dd14dfd202d527e136eaad6bcda29dc51539c6c626248bdfb1de1de080235af49a4672b2bcd401755413669ccdd9666b17f53ac3b314c36758e6613ac542d075dfef3c67c6876c13f42ce1c536c489021510b5fcb048265834ce0108a5008ceb9354d3cea28a7a74bfb1a28caa185fe690277340f48c9178de8ddeb2aaaabef659a4e2a0b8003b48a0539edd5ed449456776954b1b22c6169a309d3ad18dc961723359b4313c6bbae3315d233af2c79fab969b1f2b54093a09d9a7e7839b29326f6492bda805192647d0b6a8ff3edf6ef68313e8a3838de8704c28eb6c7e7403862e3bb8e530e1dc292383caa750df7200a45cedef4f446f4c84630301e501bb8ee72379fa75e545001f9386a3ab7395449ee98380e7cf845c6f9aa94cfea5a96c27fa6dc72375849d59e4c4fef378928d9f5913f2c8048c575e07491bfeeed23d92d7ee62056fb58e6ce5d03add6a037c37bac9f93637a6e0256fc0da47f78d737f074531dd7fe075a43d3c9164f0f7ab37662b995c9fa60fe3d8e1cb186f7117a99750dd00b759c020fafe5129b6b3f47d35648537eee3f00c553a7bdfd99df796583691e47443d512b31f61524a70841b37e2f5dc2835d3ea92a2cf9c661ba095ed876cba1abc2148cba494e4db537bd54f88bbe0c966305bad27b7fdce5ae148614f6893f3fcb5ed485382de15376785c502c9b920a7b0612d2e970615a4c761018bd4c11e7604796cce953e4290ac35838660628b0238c6de71b1012fd4e9f2750bdaa2b9edc28be4b34429183fcdbf4a9c9d773d9d51ceddca1632e70070829b006d715823cb810f033e8f1a059eb382d90d580d669d9d5ae8da5ba4233d9be16b512a5ed98ac2a692266effd1a602dcb5a917b41307fb03364e9c77822a936df21b77d471e67c77f2d5ce298ba42a7195aab54b416bf59ff3c2ee2e981e35607d692c372ded17b2f74687d7f0eac3f5d2054fc73bffe99abf05e01c4ef8c8e355fe6273b47599d78ea10c9221d33e0be4123d42c3d8462a2006ee806be279981d0be7d43234e8a83bb1f7650b93985645a4eeb49156002595a4531e3932c7e844ae7ececb27e921356d492b528f81ba83ad67f7313401faf010099d0f3d770a6aded52dcfe7d813d824fbcfa02131c4bb71d3287167a65237f09eeb2c8c0e6e7a55c97a721cb201fb2e87bcd114c21368b15f9f6c99c2fa79db27b9b01735e4f4de343d3f8e79afafdf04930dbf7f719b553caee196c550b9a5821e9bc8c9dfb8326414ad45f97ed548734696a3cec7be47dc69ee363d2c673d0a9944d290a80186777cff0d84478304e787dd521e037d2651027dffc10db0c476edefc05e3f25a0293ecdeaef56b0862f866aff7828037be006156d1b174be878cc2c064896247093b31590c8ea9678b806008baa43ce605b7494e80f1eec710df99c0a200bf2e471c8486fa59fc498f56cd904f49c44105dbe5ac2ca62548826956c22d095aac9c203c0b820f923a11f13895dabbfdd182ef4998a3f5b308aa977cec0d7afe52ca81c50c3d19be61267acfd832f4dbe525e6dccf4649a255f2c87685a7460da12c0f5e61301063dd3362fdcec3e4c75268aba29e6a50a993a002fe34c33193980b52228f6ee205f6c45a412fbb7117fd9dd165fffc65d2a85b1b50e7ea5a039782ab880954f0943bd8f8093c3876b65dad10d49055b7c7cdaf92ca14c8e2cd749066d447bf7aec2835f3cbadb53f0e991ad7759a0d1f76c5f3428b42e8c0571f25cffa798bd45b4cc8ed678915d7270198c7d29c748c0a646b1457273300e30bc793578d12349351e9a7e98369cfaf7f196b93af8943ea5ff01ae04336e3219984322e496682dcd5068919a6ce347223eb55f9505fa19023b461232ab583250bc184c827e2c7b14df5251cbc9a1f3c485db8c8ec3f7a8f80267c31f1e4531e7c9675ba8c11f21b30ca8dc43f8a8efb9ea4b020e3b6db434f253533e9e65388a59e236856d3278ed5e4b708e2ff210029269d46552eecc40e2104c2d5d299d3b686dc72b0258e9a2411320f00ae5da2a65120acd4d8505194862a8915040c56df6b81833ee92910882f78d82ed7fe6170c114cf471a41b7282ad180604ba252fdbae75fabe766d8fc3081dec226c444ff0b601bbf0154ecf134a10242ceec879f04f89f66ef54a6cb9ae3daed9b1f410a8897f3cc55b1261068c5ae995a9e2069e1d5864ecab518a8ba136bf643ec24a7346aeb61df4e31d0e1ec2268d59a2a3d9841fb791015053c2bf38d32f833879e94776f2cdb151292b2963353f0d632df9c7cda1ac00148ea5bb6574f717d432c6692c147b7bb6b2f4d6482eeec1a2c6f761e9f4d6085babbc6ba5570240e3e32bbb6c8837fa4fea9cc98dc2c74f510bf07fe130eb862302cdaae7e7f2e0fac3640ddde6be6b756eb5a7f39fb7473522328f282ef9aa89235fffe444ea0e779407af71cb4ded9807a6eeeb804cbff3e3fc10060e1fb41b3bf2706262635b977c006d99c64be12975edd578c3757cc687873a2eac113ba81a7a213ebb92ee99bb77d858401c00d215cddbe9e05b8da8172c4d89311d8830f7662721d01cea36ff19165fe1050355a163aa5c686e7bbf596fe629b671fcc098662f6ddf7e05bb6e809d74677bac57615d7238ebb8aaced0bb3765b8165aea7f892433c3890ea415ce8fd23a842dea7d6e67bcc8ab1498ea5f8bbc88b49d5186052779e96fb3665a1a04138146b1d1ae7fc4e331a0ea0494b6fb12b7bf4836a0bcd8e0b2b2d5528ff19890ff5a3ee0a8a3289ea6298bef2197f007a8b2b7a85f3cf5bf23715eacb18b2338fa65fa4ec14ccc1f26dabc127728c21526d4a2ac5a75eef7934cd52e050f1a056d9b2d20c0934ff0b7154e900636445ec1f5ef765d6f4dae2d2d3750d4237ebebcc824b3065f37e85b710a7b905ef55ea1ada797641021f86881c7d483c1973bb8284e843a77f408e47fa545de9401e1a32fa21eebc2dfe9913b7af4a80ea87f320e0075656145e345cd0741fd6bdc576310cd1c0bc305ac43f7d67eca7793a60f8a6c9fc7b5e3e93dfce41fa127a98caea98f26c78e5d1cdea3bd1b1a910f9ffacbd52f1ed8f11756a0f6663d7380f1e54539b68d1d76560acee5fef620ff294e3bd23f3b9d98b367b84bc754dd329eb0936e9b3afbfe4991bc0cdc13c0a8182ae27ab268d7f2a40b27f9234b53a90567d05d97f02bf2f1386e395f4701cc91f13b838f6b698b9369b1274c934ddc4d31ed4131576f7365cbf0493ef1d6c62c7d2e972d3f3b00dcbb4b67d9371ce64c515e6d9bfa0ad81b1e92442552a0a5a431dbcc8054e1ab840e21b304b97a4a0190b083feec1cb583819d823b638626ad8a1e2193feb1d4c982ec1fba72de1b22ec98121244b5adc312528f97eeb134933dff074e6972e97ac048cf6f09a0b30eb08cdf5581579f29e9996bf6a1308f3379d0ac9140531b0824a790ce00e120b34b6715cfa32ad12b42fd158d1b9d69efeb7b66da57ae2e8f165c41655ffb7fafe11f11d0b226b32233516e0b7cc36ebfbaf0ae1cf1478d6ac454bd64d98756ef7d3e32bd0aa8c4b06fcca1b130efa44693e65004a19f0664786028bb898f7dffe46f9f55344b4484347066bea2e697576dca0b5274233a329dc62587973bce91517259f6048771c34868637ce218f3982cc21efd336d393384964c22d5e9bd2268222aa436b7ba466440cf64a65b4228e4f9326a843eae80e271d4f2e805f0b389059dfbd9b4ebff3037e32c9be9421d7d9ad8e69446bcc6afcc17e75b0a20610f161bef825892197245ad92ef075c132c953f6bc16e2c41b2eaaf673488a34f314dc4768b1c366e1f4493d36d303724894c16a6ad07d978cfb7b5bb073cb12e6f04ea001068b65bb2a7dcaa83ca2e35f527e14950673e7e4537","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
