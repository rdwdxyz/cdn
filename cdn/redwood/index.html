<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70c45fc42a74bcdd94abfbbb5257d1c2dfaf097b9b4cba4430596595d908b49406dba9f65be701387b6a9e8d32de9aa2bfdb60293b7397349fe26aec8824ae013db7db6cb68ecfaadf06d681540278b984bd7e2fd2df8a8f7065a066bd86291d2bfb36dbfdb4de75c1e7fb6dcd7a0c27546ff4da000c418494aaebc4242cb9a87d454c24b3d2eafc10d4aaa6360bcab261f5801df7171befdbb3a99219b64649a41d2298fc4dd07d9f0b43679a6450dd00afea74d4435ed0f2e2e1dab6b8aeced52c5ab1cb4fc5db1dd54d6cfafaf7407a0543831f4b03ebde4f2a02fdfb8016de66d7be7d671f2d904133cff148ed0f3573ef37c24c2828d01be1ff38292fb9fef1106e367950af825ab116c5b78602b33f25768edea3a3358df94ef5dc0060f5f57e8d4b98db96a4f99f8b98cf4afe4364f4c2eba1c421600eda2cfb2f4819429a0fd7ee1837b52c08d1471d8c58dc55d3564d7024f0f9b3ead53c6a84efa0ac60e3f95aa1d2cd25949ae62ad52c1d7919181fc3fba7f918cd5fbe2fe5b35dec0ada0f8f446cff5c32fd5cde02acf8083713a5ed5d16423d37357371aa1136942582c013b38e468886f943f90914eb28b39f814ed7998b0e403ba92c3bab4f7a374b4d1c2cf5558285e67c64cec2b50a087c6960857b5eacb586d7c43ab5a102823e044b9914e336bcf581914f64448398dae1038d30e93de2443932a7f442cf8ba62a4b23675b40ba8245ca9e828e8b02b65da45b7262da7642a06b3fad9e5f1c918352169262b8c0d6658b8455ceb9b3754f74e2d0ed526963022484a2ce8a20e94a0c2c45603774294f5458070563dbc86e7f14fcfb5cad61fa7cfdea3362021be09062520bf08d7c050ab2d3233847df5766f416da576def61d007779deb2fab5557ff8552fc1cdd3be56d89dd6d5dfd1d7ea696dc8604298f2b0847741a5990c19fd7f3151c34d825201dd5ef5c51fda9d30da1f980ac53bf43d67c5598378bbd55e13637436efcf31c4096d4e80ff48b5262cb0162205fe2480ce40ab82d4be3f2dc6094a180d628430534d32ab237bee15e5247f729d42d154173b90a3a8d928274ddbfb3ca32772ee85a399e73e551ee64f516835e2b7b0beebcaf84151c8c8b2179baa0c77c8c6cead123b435dbb121732070124d31c6e079a9602caad78b3ae4e37b91375868a87038c3d0337b578c24170a16c2d8b03e0fd8594f8af5f4b0fd1f990dea1f82b567e235a0ee1a963cf549f0408980ada0b7bbf8c5c112e5aeccae9656b02ee2a94fbcb24257923bac8046ab59e18d4a7287a33088445ebf812fd8a88dea1c25fbf3ee8f949105d8bf54ac90c36b4975ce41f0dd1037073955282cac22ace078be50594db84eafb1de5946f36d0e5a897d52812975f2577fe851aedf147cd36686def6535300fa405ca05bf235f67294e5e9b39798e3f0f90a6222acaa24785b1d6e9e0d3b696138348aac138d53582d740b1c58c713b443340ec6d0ef201f85933e426ac27a6849d319c2bbbeae2762a40ff7bede723cec656fcd160e64cc5fb518904ee8e5512eefe0f8bc8174d4c8ae6eb33f4f2c784cc3c6044910c0a282a27c5fb9631b7ac72e76328d163fc67777b113eecdd7a9a8fb3e7c63a2d3a53d3fcb51087eada1286f54f40dc296184870234415724111d6f03d6c1c146420d2e1c67231cbd517b3bfafd83ea2f48bd8342f6ee13c546814e9f8ae2894d616e38d9ac1d6cb84e8297b1122885df1cc4c59638ddc76bd67d5f7f38e043bec59b715db44dea5da68997ba292e1338b9796a24dd9462f47bafb416e7b5132fa71db000e41b406266e184dc07a902c8ed123c3639bdff8282d5815f3b3cc6b0eb1cb02b49a0deca6c21a84787171ff40a3bbea5970d08035a08a20c3b8e9fc15cbbcabdc4210a47a46492cd03400f0400e3e3f2ddb33996fe8d7970fa219d70f87168768161335e68d3d68fdb527fdeca2b20cb8dcd78607a4dbe1adbd2224590f8d1d19c15956b355e6063952dd406c4d3a97c8cf2f78e6a0fe947866de4ccedac004b09c50dac58a11d3d20f0279b21ec9d899d72c1dc1db5903d2108684833a890a60fb5b71ba87c83fcab061997ddc4a19b73fda741ad04e21b285a14b5d9e3f6af60662c55a493c8a35e3c2a9c016b1e7926dfa0608db223462690d7340a7ebdc58d4981d6f9d84933d75b6cea7816d97ca7fb14ccc04c79fa2d61b6d1f939034d3aeff024e73bebf1810c2d761000eb79581a857ab8a20b5be6454c4b64cd082e1af2c921a1624900cebd07ca8d43e9e6f20c746c5b11e20f04a0203ee57c215be00dd1dd9f547b2263bf2eef4a19149dc8e9320d2f284f960559f8693e98f29d9e728dde0e04b40e9c4f46ad3ce879594d8689d661482a18f5ff9e130f1a8e2495668153c82d964250366b71847976a549ab516ed407a472504a1da7453e00f3b38e2528d18b9f47abc686a09533a4b1f11382eedae35ed5ee409b982268472b37e900d0487be7b89c8aa1d17052f6f2cfe084e652fc054cc18b354084291ac6eb78d9dc5dd61b12abe60e7fe554f69f767f84a286fca588061d3ab1fa9d9612c31ad73c8958094085f1e01c2dc5d7c8f1e87fe31a71bf6d2f29c076b48a25bda6e288e4cfb193c847e16d4fb19ed0d1d4bfe346a0ce6f8db0b3cdb394d1d6c9fdfe180186e55fac3798d5ca57da814772ec6780dd89953f9295b58abb31424908f28ba14a285236904a966a0fe69b4af3e6374dc6bf9d99726f2e507ca0e6261d6655291130779992a78e80aafe02f410f38bb5f6d8901024e8e98842794f8a46724b2ad424548f31c286b49d6245920f1f643680f39d1556ce240c209d1fcacb79a7b26b950f5646632dee02ca39bb69f3b03920103bc7970c0b1a4f1a33873a7486c9b6b9931b4af8991ca0841e3f04bbbfc86b477e356d60fb13e0e2bb97d33b70161e73c289f0ea3856c9ac73cd33b2c4f9f6b4625cd4a807328757ea68f44b7ad711f74622374439487bec8fd5234f3bd40212229e70dbb1e6d88ae697947a9ca093713cf2a04959c50292682fa78c1a28bd6c942c6b1968ab362563aa5b19be8325785624636476274b813593da9281c7b3b171508d7a14af36af296909875cbd92bf576e6f94892cf97981a5253f687c6f87163058f49171811f6849353608bbdaac058f49b428a9ad24aeffdf9f4bdaa4e0fa7538a6369d78a0e96b508b788ec794c55805539f1d50cfd5ef59cce441ac597d7933d2e525f9e25e34f22072b12f212253ffaaee46edb0a4ba3761954200c9f28bdb3e8ae25ee8da98c3485b536a88c66dd988b03106f88f849b1be30724ef2ff41f71619839afeb485f24744a91e401648d87ad83f26b19105a761b136b8d97faa9ad5b747fcb52d5e7cbf74eac6ee6d65758175e7786ca9f3954a2b3780679f1295e3920020a91d43096eba173474e71d63c79ebd7f0e4616608c381a6cbf2823700050de360fb2ed1239bda4fa9c4b6064e9ae2f0bf5d853ef5aa3546f0d3afbcbf1056f86da28993525ed7dddc0ad3204717bc9befacc8855af6c41f81843847e516128ef69b47fe9bb4ae5b1f8dc0e1615bb4267def215836cafdaf1a663c9951ba351b317314e11b93605a8b50c8ac64bffbe62cbe630a74cafb9883e9a88868ba0772b743c58d1a0c27b5499f30574bdbdd88458720e58195da76705f89b8abd58530e08881cadf7ed12e6a32341aba55614e23b50c713ed104094b7041f138e67b32aa064cb8fa524a7b14bece047f24e98319cafd8edbf16a11c7c6a4cd31d898ce319313a0399212b35b62bc3691c58da5e87c01d4836362613cb79ad9d5276943ce21536ce9d3d3aceae2990610fec95df6782bd9b47740c3492ab63b6e775c03551b371f170034ae2d0660ebb869031e2f97bad9f761863705b483f510ad9e8f440bc87aaa09f04dc17928bd6c5bbea65ae3a204fec154af07c6ef0a57ce782d28b107a8598e5a0dab025daf3b74275c9f5fe8de8f6aa7358e4158ded7eb3c7cb680c8e526080b309c4f8183656364a8378c240d938b04ac0e5c05e39dd48943ed8502dca4d14f28fcf5e13740c33f861625137104e6a693e3b49d6663ea45d98c72c1881096646569ff6fa6129c14decafbea030fd4600e1fedc6df79d422f816aa5d0920e40617506c4451dc548b1f3f6c673fb076ae62fbed1909a7e14c134d50cd014edd6a194f10e0bbf9aaafa07e6b2c7b9bc724def3cab96147703fe33bd3b84de88c9edf5749bcb08ed55e9f44e3b979d7c0f77be00d0ca9468fdb6b8f44b913a969fb44e1fc14727dbbc0d11e362b3232c0f627a4fa1df1f02e4e65c46bd1e221d964d4b61e8af20523b72a5448e601944bdebe597c6901ffb3ca8b53e547f6ecbdff6b44991ca068a7f6e858003c10da1d28e96de936f670610d4a4c233482e6e9e8ccfa0d21bf58e172a321e6651e775a7d35e64322f03820d12d110428259305a583ac32bae2abddc511ebb4001d698b55ea5bacac11546ce5c14f35de0ea7d31fd978bce8c19179b3ebbb10d0636faa9bce0e7f17958871da79a3a0ba72a0e7de5e8344bcee11a264b1b3547b504d88248db15d909cc92d981cf3245ef0bf742c7c0cdf25002114f9d08c8008c2896f1c7f8bd353fa55a7608af45ff6624ecac74cb1f2b9dd7855222cdf4f467d218947ede7d4cbfc5a9647f8cf08c33b6aeee6cc964d968ef3b62cc48b8e6a4ba58fcb48e5024643dc49cfd16fad6cef2ec335a9f388e59054f9f1f9876a7da3957861d768609e0f1e371d3b223d4ad4f9c1aab58fedf8fac764ae63c63a9f2140f701de727cce2246205be3a87c7f2fd8835cda33a0e412a9c9aa8c2d08ed4008e55b504758b444801f291b81d83d77d1c5088d8627841490be96dcfb014d0b7e3e7bd243c67bb43413c6b86c27e5f3a72de74e980ffabb734a6b2461e00122c425147ed0031f0a8b987e68ccf8be4b2eafea122bbb3b7d7ba09bd1f107ac402dd85da7ab746f1005378a306ce62f23824f371a6188aafe40e13678b25219e32d2f641f8f1aeb95e00c5c33b8d2bd57cf02966eb41dbc18ada8da6d9bd6279f15f6f8705a265e30e46074f18d043ca8c910aba848e11dae21d62eeda6ae46e10ca83967d22ce9bc9bfb79f54fe14efd32e426731fdbf2759d54c2e7135174fd2d4ca040a99cc233bc84f83ac4c6beb2e2e8c0ee4120e27d52374463108355329103f52ddbe6b361f7ec48394bb6eab4b9454ed44c6b4f0ac12e571019b12017a69fa75932e31d89387421be61c2525e7b72c08b8a7c7c0057d3f353c263448e94108c9eab983af4044f09fb6d58f5e123f73cddaecac5c8225a2bbc5a40abc8848e61d48dea318cad77e20f726a4a39397d4277858749b2d7f50f3a8592459eaa45810e968f69b69d162959c6ce7b0ec115ab77885ed451fdfb2cacd8cde06183426cb7e7d2f293e7a6912f46528772f07db3a109b5b3c1bde054f4e3ad687eae28d10a13c5e80e224cb7e0e3e85f7481e61fa1f7128ec033b88a9e7f2741326496686dcdffa1c0b7cc74e333a679ed0f6743d8817d550b33da26c066d6b9a0625d80d82d9f7ff77114438b742f3a7a098c087197e745ff6352a57816d305c0f924edad74043d63e028025c69d19b80c256ad0935bb8fc3eb58ac266730381d88a0c9181c9297f02f24981a54f8fd156d7b523ec0086345823907393d4148a9ef6f0591ff309430bab2f459046120ad0e8346127c65bc09fd5c37ced5bf459672129224ff5d200dc80cee64a567d6466c08db518fafe584f0c411743d01263b9abe900f79d28dc2ed1640ab28370cf3d75ebc0fe448232ae7d384f1c4fd7b47faacbc1efbf3ca2db92d53d86fafbc804ba050ab8c00e195639fa12c6a877c171ea5fd991a9800c8d7411b5aa4632a0be0bd533813d963f7091b9a3d8d456f2b53d921af56adfc0d3eb5a9b41ac2e84d9f2700a90d62ad54eeea47f4dd2e195ce03510a130d0e67c30407adcef05504281c0d3a4567807da1576149085bbc582abeeb12b29784795259c9e0c967c4e8ba16a8ece6df1b6d09426b8f8d63b22139eed99237bbe379a21878d7117fa4d88223a004e69a021979b78799d5b9cb6ba48462750ba9cf28f4b290201d009896c9365d689b0e3704030819630127ada677d414dbb006e326dccbbcf3fc5ba00156682eff90a7d2ec23359af8fe7b6215fd0f4d5c6093ff222d5112d53d6ae21144bb74086d5feb097b30d74893c3025f7dc4153edc7624c9e7856a5c1d07ed67f2d340bd5773d31f601237668a299c0857c297f1bb2e744a572c29ca70fa52dbb44d9a0dcd54e85252f6a71b3278643a4b727c66d9b930c03d4eacd1b867b2023aa9b83ce55e6ec783a68766a98d1c6d04336cecb171313b4ad9afbd1fd6fd4613009a1c64d4d608670d34258a0c69e25095c66430ede903020f392471481d28fa5128722928953efc653c496b0944f6205db70e7813631a8cb85928e75b3e3fc34c5df4cf153cb2a3a7b7499229936d0925d7dbb681bacf019d7506a8b73a27191401836c3fb0f2fe4aa583c850d132f4a4507cadf6ce16720292d3ed364ad5e2661dad29eea9d9155f9faf4855b45e24e436ffd5ec2d500d450c0db71054553cef1e4fb455e825e401949cdd43ecd471860d43b5a9a4094744567b4a2ac3970b84b8d5904f08d0ee2b3df05f696fc5f4f2490dc27b0b330bbd7e15746e7bb05293b927f37ea8c0ceaba9d80fbbaeef9708eebcb38ef9d2914f5733325a75e81b99e73fc19390aec8656fcab2faa7fa9de567e557f913e25a32aec326b083f010ec39e7b6cc06942c8f2fea9452977807323ae0f0499be988391b132275345861505c7ea6e0a3be484b48207941240f8cc593e5a7446136123fd0ba0c84dd6011b3bed43c561695f5177e1a96b0e02b0d0f8a2d90c0499cef13b1ff8fb86b7adea650f78d64068239de97f4585d7ec2c0462ddcffbb87f5fa9483339d56766b70f7090e8db5f3274271bdc5d34485112a7119f02ed55cf18c0ce3e71714c3ae734fa013fa9113191910f67d5a0eb54b10c30875d4b43b96c1986e18a522ced21809f09b771be4db12f68556b0c5b8deb96e21ef0a0c207578bb93ec27cbbdf7ac9e83c4dd2f7d1c5b3dc737a0388f926c645e6ea4f7547af3c4ece147aaf953f843e8fe790979fb2ebb1e09223423736f3a2fd2c2c702181d1ca43d82bbe7d7e9d5f6587ef61acf9f5491c1f84d5f36b6340ff899d728d0e93948ffe71e1a8e9c729fcfc39dbe7feb2456e71d21229b4009130a6d9c3c4e5857bc3e05c46f06ea8cbda8e3aee6a24d07627f5180a6a5a35a009b8571122490ba17c8b4b48eddc1fccee4dea4cd5cbc0a6104d87c15b524230a2dab1245c1a23dc36e4b7c9dbf4f401effb87183174cda4d110181900912b964fc3a2ec6a5f26069c4bd4cbd01a1e711d5d6c6f1a79a185401183005fda01273ab0e4abb1fbe477bad59e8945b724e15ccf6c2651c8912310d905ad5436f231994cf31dc9146360f3160bd47944b555bee896c6b610c1ff066cc938e036526a7fb2b110a97500dd9dd5aedf4d4611d000bb07611cb6b3c9442e2ad0d8eff8de9094a2d817e3ccd87d3da19fa52c80b688613491c4936bfcc56151e86a6a3288f3ff6facf3619cea56b90c3b19a04b471076fe14469a52dd2d2aa83bd4511ee509cbaf7343c857c714addaa14de10d110a0027bc9b99451b0c71d86105f7956bad31bdb25c64e03a21f90b900f90639c37c3222d08edf37908ba12a987d60a56051002826b25ca59eb52c98070838378953d044a5a478454a4c4315229bda54c83dcec346fc8f73a612aedcd3ca24c682e425cfdf8e12ac52e381e442f4a87e7c51c99ec113e55482981e33ffc27c07f6d052c9ffad3ac904d3e21ee6e69457c492e3e46017048bcebe794ce893836c8b03d532ff304909d4f98866df897dae2ede21b935cfbedddc013b5cab2fe262ff137bbca774e3e7b02dd2491736364b75655944687df2b202767fae722b99cf6bcb028f5ab14a809bf4aa897d923233d77ec3755b7d90b09feb374b1d3bd1aa596812068a0fd47bf734dce2dc06f03b89dad4d230007f8809236039098cef4c194a7854e27b617af5800dd271cd6eba497e0e8d83446b4fbfedd1eaffb300b42ca46f77fe5f8685503ed6fbd3750cd8ae8cd5b15354d459d64d5ecde3d81fd3be880c590de63788c8156bcf7cdb5c9ca45b8c94228789708609f7c84232978b8e4964e8930752d7dbc2884d8c265400e550c5bbef07a856f1cf54ff21afeceb3db6ab2b549f2865afc24a9e88da99c336bfba8af6661dfae8791fa6e36925fcb3794caedd780a8f3ff4d13d44b7a958cb664348e32504b8665ee129b42a9b88b95e7d38c3469b282d993668e316db8091ed3d45778741bb055fdb9dcb9b8898a5b476765db815c13d5f45f26d1f3b1cd6e77b3c58f04752d9d528debbe1a3971865398889b7c8788b3b28e47f1e46618d72db16f1c569b7225e013551ddafdefa2c8688efbe89c19d09b1b4e69e7b45bf8846ec7e0989ba2d22ab23d3fa1d8129c495678546c5d450c223a4b51f6e7150cf76594c0e26cde5e1421b9e9108c1b4ab192240e9aab0aa9f1e2c11e35d4c96a41c09a6bcc675b2ee57ecfb7dc61128ecec309225b4017d33c13a0737d9c9ee164d76488e271a1dfaaf51762bdecd270b268a9b3ef89c848b2d91b8877efb6b328de80568329fa976ee61f9836a89f25b4dfb54a59f966264bbc79e6ff108e0dfb6d483ff9bc64f30f210ee46c19b0fdb1f9c862d150fe9636d61693a430d4083e2b0c5e1f60ffde492fdfcc3da3ef753381eabdcbe45302a603e4df1d32dcd48b2f87566f7d17406ba8dc4307938f69c51c62cf62fb7c47b23ff3b17ee1950d8f04b60be30d80ac1fc55449141658c6147fd539be2a91af92ed9cf8835f8d66fc2e8a011686774c6a519dd70dbcaffe747d4e008737e24ee01d5f0812803938775eabcece78052281f72a4851661b69a0d898fc82dd3edc8f198e16da5d79a41bed6d17bc356e1c2b00ae42b52d2776d0819755c899f8c1c509e7da491cdc17142fdf720f37313effbc3cda833de2da657b419e1e567be6cb19251cc5623513fd79d0886da5bc0fba3066fcbb0d504d9c4f9a468375866a316d193cdc1fc33dcbced6858ae3da0e229368265c49db97a9c1ea6efcba6fee450f250c126c90442d099f6e4e21643fa505ca2db6e92cb38376a6a83db0e6031b37a3a6d57a10cfdbd856c5d1c7cbd25d9586fcfa3f6b6eeb80c6c5bd52d4048b65da43db160f7429896570b1aaf056dd6940140fa8d9d6cca87f982baa8507232614dd605370df92d328188001b62fc0033a7ecc7b6d4f2fc4851fbfc56f11ba297b36ad29d71bf8bc453c520a51d674b48a93cb74bd4d6419f115f5ee45fa92a535ba4d3d18e5296af7488381de277624de9d0a0d25643e60132d4a18d51c508dc1a1e1f1073e2b7d1e67f1e8eb25a0d987e01ab63420f7de05cfc05e3494f893fb80ee796a574792a412b6c48450c07d075c075e614dbe6f4e6fc4f3b12ac8bb66917882b8d8c79e09059893acd5b6b638e8292b4de692b6df0996e98098699ba61be95750a0cf8be4bb27f67978452b8a2a085920eb3f7e5c9a5e0a241e45e38dddedbe4f518f5f56189ad74f548c8a8562d6dd85b25d56f013f4e20faefdedff5c2a4c83c796734fe4c0eac83bcd180e4d90305fb9d3bbbdde0746350a54f6cac05de91f4827036e6a755b987bdf09543c262593b3286ae11bdb074a0d2c6d146cc60ab92a95a99f98602d807ea0e7e61cc6c8b72f0b857116ddfbc2674dd80be255807b87b3f82d253f10d3520e7dd32f86b387282c1de3f583e79ecdcbb01d7f812046c9ba6f7e50fb3259cb2f7ab5cccde34f7ce1a36742ecb4a52efbe1de815862fd0886584c92bd6598bf781d20deb3874e12503e3966772ff44bae5faf27993f0e70bddb6142b7a613a369ff4f1ff228fffcd96eba897b56396ac87fc30d5d990bd918ac0d9e1c787c8305568cbb7fb50cd03b89d43df4764611d3dcf12d88b7aae8ffb02f599e4cc1578127ce01bc2af64ecdaa9eb8c3e246c762afbbb74a2c4e63111938614bec4843e56524d71701323ce05bc4f51ee0938406a89308bcbadb6896a04833a8ddf75febf28ad91977c63ea3fcc5eeb1083220e98c7634a5c1413c8802dfe6ec5df0fef01882348d1b3cebb47bf8eb08b38966e9acd264e8fc45817ee08a19bd608b6af2868d79a9a9af856c16da66f48a5504235bfdffa08a0b7e11cc4d93263cfcf2225d7323e31f107cd3f70a54449e0debbf4959cb75d922f85ae9d1f8c9fdce13f9ed6a57a614feceb642606ba6b31d890e8aedc1c648d1d2a66ebf03aee6f911ec7986711fa3e12b09bcf2927b2147f52ef0da8448c6a1bbe297c002a44f43b001a5c08ac47e712b90ebb13c6f114ebe61584922bd4380b28e2fd9de927e6551bc402a8f01bc75ba91024e6fbda0f0fc289a0b8e1cb007e2a04354b7c19eb3b14d9c7738ad2bd44631c3cdc420b0873252b5ed5e499bed03d7a1e557971ed241ad239c9741bd126ac7610b2c41f3eca1efcdf8a5ab9e0e5634328d54e8ff84e1ccc2a3b0b1b78531d9d1b8c1edc3e1d1d6bb9d1d9ed1e59ed43543f5e19550706d5400bc6193f8458bcacddeb50659ebc081bc953ba3913d6a3f34b5e2bfc02343a354c3e17f19990eb3699a3342e93f875781f3038171f47c495386d41cd95c4a68640a5a831f3b98e499afa95ebd05496f78b51c01640773ab964480a3bfb38f0eda7cab86a63988d87fa200862f59ba207af62db460e174fd727373b3f8e0bd6f25f18dd34cb583988932d5de7f35b0aa46aecce47318dc080a35caf43d66ecd97db8c1d4e3265fe1fbd411c259dd3dd78e4d749b8ac7db87653ee4990a77c954afa5c4c20e1d6a304926bd1a9f8f240cf9c131caf9104d8ec7d63a721ba883ab6740ffe7d680ea5abe31b0297d1780508fc6c78cf4f2d2bb4d9bf610928125485e96dc3d2201d696f177937aef8b421414fea8547b0b477f27c53e37a3dcbe9de7c5b215748da3f449789aa5ae01ac40bc10e797b512a9a8628e85734c6aa2e55a78e2b270f6b64e410f8359d393172ada4cedb0adbb0e47d0a5e15165edc36247275607646adef25c7f625f46aba97db4c5cdf984d1a828db41c50ccdd07700f2ce9cbeba68893a2f2beb3a964a3c6a766c0a8ec8d9eaa9a57e2ad69cc2233a3f7e8ffb4223307010d8485daaaa3399dcd89df41f9f085f27b594ad96c08e18679fb742ba3d3c4f50caf995302d5c5d7078b46f09a26541ad2bf228f7f140add35e591ea1d8de213a21ccd67923b90c511ade645f4bc8613d2a47974f2111e1520bb4679cbf69f8f2dff9a2f9ec08803d865e595b9f0e442f877771316f6f572d6b6e7bbbf03358c0ea4f01cff44fb7f6e9d372ac1de5f8563f2be9b203d6ef73d342d0643383f2e33cd016b7f1d6e12d07607d37f410a16e3a9d14e45b0e903a0d6bb76d47ddbc2d033e5873a438d0a654b489e6fd4650d84157fb31bc2e1a64db0f7ebea845d97f3db4971332969ff24e20f31efa81a36f012d48b3d9ea6415ba484cc79bab6169738b48d0538775fc0c3f792b3d8f830f8a4418ba7c8e39f10e8350de844052b75882a817942d02604a4ee5c965605f3e55b5867fcbc91aafe4260a79ca42d61ebdb97a1f524bc9e5469288ea9c12cd5059169f2a917045cd0b096c6fad30a1e28ffcef11e0cb24ce3757ec62ea6b0cb88f758b5dfc72f7a63b427510d57362aa78cfc7fb677b11ecf2e3cd7763f2d8d841cdb67c6e13c94251fb06861092cd4f5e5b50fdc60f2636be8eea9575be8e6e73b6a9eeda77ae31dd3f8f9fbafc1d1c17c5386f1f48b9ef39c81a9f8e8034820606d2759febd5e784ceb8b1f9dc61215afb04b3e1268002a78b8cecafe7d63db80ca69ff25a990af972fa52efe69e0dbd5c31a02c09f4891237242e37e45a887eff207dfd33a54725d3f9338db710b60f8f0e3db39076da181bcd58891b81cac38c750236ee87c89140be40ebd37eec674e5a2d7f1f2437bfab6539ece171cb5508d1268afea6285ef4353dcde90cef6595e0f8ed2f037fe222e6a86b62316aeac8c74499e38d4bdf36f72ef61b45a7db76c9b8a1881a03b0e1740f081af2125843304e54135ff9ed665b26ef44a4703dbcd6451c23d75ccf86cfa6c4a637e8a596daecbbd995ea58002e8d0177dad6c05f116b00c88556cd439f3313bc5cfe2696277560b08b2c4cf460a78c60aa3003997dde30c9dc231e952e74b6001a8e95438cd5282096c6695ffb1ce982c5d7bd29bda461186353270896f52f49d57636fba02cc114691c48904678015d33a934f705017ec3b99e0d71ca72baf350abd20f5c50748137454f9568f9542473876857920db18d3cbcca8df11b81fa81c26b5a6dc086b8a13f0abe1f7afce16206a827bbef36c022964b0312487ddddf1763778d22b3aafd300ec6d72065fe8dc0a25779dfb9b0133b7e823a140fd9f7df0a5032cc3ff6ed15171ef537bbbafb4bc1b9d3de845ef3e62847bca0f635cb69c05bcb63c60e329689ce4e5ba5f3025b887f091db90b68e9e91db9cec418cada262a6426717cc33b1b9b6c316db9aa32864e41de820d5d8f1f906594641c76e9458ed3998db623aec9fbbe5d944d62cb0124a7e008c9107882185098ffa039bdaf51b2f58225fa709cb08f84d31161ed4f0c311f33897f5d83c905e9743e0c3b3afe02105d83b0460f85a8959569c244be662d6938eb14bacd1b7afafd2ec07967a25287f6f0ae18df8022f72364ee4107518126d08f8db51490a9d18fff4db2b34f56633c0b74ea1a4083287e5a75a760c789d2e61330a290e50551765c501ad37dade6110ee5aaecfa0b459b05b847ac07b1fc4295cbded05b47483147a0b4032258528c9995d25b4fe260cb5c67d36b077a6f91cbd244d384c74e28731464287a06f5b960eb4fdeb071eb825e3c5131f55a52f429a8c6d7408ecbe50598f5b56be636ef3a1c6abae16c4d61b5e7e05314bfef7ece2216375b3d7cdc832daf80f568909a3c791f6ce31adafc334c76469826f35eef05a2e44079291cd33957e91c408ccf2f8e4da08340c0bff413dc7de1c3e855ad4ac15905e891823b8bc78ecbb4059a08911398b3d18a7dae02a1d66c7277ee0f7b253f7dd8462b826f3face751cefee2caa6e2c2e127b19e7d9c2dde7df3aef8d0ae0c8bcc2e6816b3bcaa1bad6d4fb0550c78ffe1a35362781029b74b05ab7a19d0d383485d26f33dfd9d2d5e072df5592515f5825b96c1f2db46c708529d859330a30b0e7e12c456bf24fe888e087951832705f118a47eef62c089d1eb47fe2e752b238abc083f8bd564964f2975e36c2d00cdfabc284181561576619e6db895e56e6b314ffa544b8be77adcccecb97e72871b8140060acc46443e6fa277d4d0f6e870d489e347653a481b20e93b6b9602f404bf2115f18ecc5daf63343e3e88f697831f59bbbea2a02943c9295714606db0dec58814009a50858f23d6a47cb886406afe78469e3ab66440c38e1a3116335d864a080386531f5865b81058ca415d1e975ba204d74971d2ca1aeefde1cb3e253490cabc96cead704e315551a5ada1778fcf66fa5cfe27ab5f70a15d7c088a1b2a30222eebf7847e81ad2dd774881226a875ddda98c174fc99fe05863368412a8f22b75186a372ce8d396ee1e9cfdfc736c45d246de6f4509bf08a5b289ea658c3cf5e314c1dcfbb24fca4ce1e2d4fc4b3916ac92c3ae3cf35c29456d0c6f773bae5272376e96b2a822f8678488a7aa1f870bea4804826b166c206615f553b885b64adfd72a357398a2c9f7d12deff9e2ecb55df69a5660d9b98bafe0725a5a908d38ec257746ca53f9c7f71eca332fab8e11449c13b9157dfe142b5ff43056cdc863f10180e56cd5d3330b0874c970e3553adc417e6f444099947b5733949f4f05c7f5fe4f5406e63d08db994b8e72f621ad0e0b73b5def209b0c352547112fbf255ea39016dd1d5b60f64ef3df8aab4ba602c070f6daeb1a4cc299f03c3601088031bff7ff0dcca20da074df9296256ec245dac66c3023dec409f1c649a15d3e66b345fda001ab87d5b75bd986eb19990a2587ba9f31d0e18fd02e8bddb49cc3c14b09b4b9eed92916604c4b8fc8b4778dd68ff98765a762618dcddf044de79f6fa293d41db33d9c45a681f16ab9f04cfa1e09991a77ff8f6ae74bcde823dde8844f015f278b2917f22c3a847d805248d96d2eea7d53f3bbd23cfec30f4a8012456a2fad802e15fcc59c00a712b24eaadca9a6ff942d996806511ac907864d3bb9e98a6ce7b40da0ee5daa43a23af6ab039358df850ab9c8e8ff055a38880f4152b5227cccfbd60352fc04ed91f05d1c3fc0546d3a81f652307dbc7410cc606e2917559612ab3fd1c9a4e9fdf42878784b4fdeb17b8551d53716ad5fe0c579e72074b1a9250786e4d3756ee6619a75de524c7aca00d14d0991c3353d5f4560eaff282db44ab19fe7da8963e16f3e2b942cdf4af846598500ff035a0522d40b2f990e8a77fdadc69a39bb83e39bd241cee211c2ef96e0b5007e8bdfec9aabf5b20301dd76e0408a8b596ccec6e7feb803d29577bd2313d45f0b35f976eebdfcab0dde237799358ab45eadd3c93f5d44b1c5f79dbdf2c29cae1fa8d5e486f91d22df615efce2c7f83cc9fa25ce4590186e4e2bc4aa4c72f46ebb251180160113d429967becd515db3dda603338f164931f4e07b130543316ecc4d8e675c8661ba58e82bc20f78c2b08778f14ea7cbb7193c10c4723c3b40ef52537ee99d7de67ae87fa123424cb80d14daffaa5a0fc4d28398a88684a94f2062c078ea6d6e56340891b9bf6866896f212e25bdfabcd819c9c03f937be5977a7a42f3f912cdfcc9f7d5ee178fe9d68303a4d6200962f6a244f7b65357ca9ecc07881a6e41a99ef2ae6f27929958a58d8de22795ad2f83cec8c65fbc6985d972c41ad99b3745cd09c746468cf1dfd999aaac1cdfd0f40770752775a8fe697d1c85b6ce282ff5c5f80f7db3b65c821094aeacd64656e6551323b69cdffd6f62bb514cbde9fc2d2963be163826e802426127c3fb76af5fdfc5d028589474e8b8b4fd09cda9a24b09fcd87d67ed997182f21590f8e16f0658834e2a2894460d9e361560e4266a2562af8e2024ac61da079b3633b5f89d47a147058ad74b8e81febc594bde3c6a310879456c1641096ef14703b76661a85e39db4ed52f3faabf8980f9f4059817725924b27cbc744b90b4f731f152fd5ac471d99307d2046dd4f9ced5b1c90fa2e458986deb2b25ff9b99f738561379d5382027fe52e52e8ceb4ad5a9ee0e12fcae99cdfceae775067df8aa8c7bde2b60e350b02e309960634bb22ce475e5089735fe7f94aff5130729d79414e0da538751780ea1d59617d6cf34071430bee3c16cf6f23a4cbae0cd11e6e7536b113a65fc5bd175620941ad6554961b7e8c0e2170959fdf283b95ac8d28e9d246683b10487f13540a62bc67f7ba3d2094bf243b48c0f06ff4e7265e4d822e8911435ccfb9d530a61296ee3777d7f093d3e2a80a85ac72748f1c7b22ad37ec10c81498cc119313418b604b543050c779686e18617ebe2a347c679884db1bae5e17893721cb1d1ca22706b7f4992f7a3b4167ffc9cbb7847dc389d9c3d3cbe9971904ba45f6d870304dd59e99c62043e54624e839a6076000110cdb627eac6a4e3d73353ad904ab795d15fed4563770615c7c4f9937aaa82facc25c43a3a80bd343e1969962cd191c3df53696b09d2577d466e0aef6f8708ea264724f82ab8c8d111a359a9e774f103169ca400cf97d282ef6a8a446824c3956f2026d7cb3349683fa6c24a0da0f1edbd8720820f155f503933c11ff01e8f8d1b04e25da3e5861c25b3485a85669b621eb9e0807b2f4d61f2cfa36acb31d0949dc2236d37fe994174310a5560e3ba890120a539ec4890a7684bd9b3cb3600f4a57ae0b00fd335a50ead49a804c99c544544813036d00cbabe4f4c21db80695af86531b4fffac6567a10f957001e82b5db69f759c8208289361a7d3e8b1a34f801dd359d4179a47d6c82bac14a9004f1ac811f13e79de5176040b430bc6ef40de57984211db19cfb70644e3fc3fbf4b48404042cf391db8c93256b480e0efb8a04a0a04df28aafee392e1d48d4c37790ad189e21ce2ad1e96b652cbecae2f1cbcb27cd99e1f1570ca277de296fd559994f74c8cf09bfd39986f75db06cf20c607a11fff7c59d164ad914fc2bfad3ee1c7ee7fbb2fac8f5b156bd30878e3c303743d6f1e02c355ad412a91825261a1a4f2b4c5bd31233f35a15decd89f4385a6fe0da8c1e5cb3a276350d8fe32c0dc1f79a3271b39e39acde55f7052972c6245346d28eee3264377d099441c2f374f1031954ae1514f1620463421c6c886111bc096a3bab7c0bf4cd078de844d271d7a44b71929e6ee3c4f02c800b88051d7705823e4b77d82e1036edcd99bc6ca31562167586783d529e1b6c13a72dc5dfb3e1e98bf582c84fa6267e7e110dbbdf27c553e2f7279a060e86889738bb6cb99e066d3f80b8e79e2e149d4ad796a6d72de1c9a363ce50f82d06d631a8a68b6b5edc29d11b81a6ed62bc335e7729c8732d78165cef19d9a7687665d7a5a653fff45f3ae5be23abfa400648f88e50213ef99e25ffedae8f6c95e79488beb4cc3345797f59614c8823a58530353538cae449bded89c902f2f2733aa396691c2719b77f2f0774f9c443624b6ff7703df67854c732a9f299700112d46ddfd243d5d618c71eb62824bc75d9cdcc080d826c22f28db4d8b5fedf0bac5db390753aaad39a1684e8e433df4fd57ef4d267c354d6dee89e7422d3b6a084779c4e31193dfba48cac6ef68fed2fcb4ab6d00e34132674ba1d22ef92248a81c07756bc78e5e27c06535be3b10d8d724bc9d3865153ef25302d52d4d80b88096e131b4f4553096cb3a3c5febb08dc6a67f21a5610462cc6a2c94cac20181a3d8b50706d2ff19e06770c069b55b95d77edf538224a23f31ae4bd228e949e92c25d1e553b7fd75dfc235821a0db41ef4d9b7f685fe7dd84124297984c186348d159ad8a4af28a575c06ed7a722cbd38f0ed4a4934b109380ad79997f38d7b3d15811ea94a3752700c19de58ace1e9fbfa46508a0e0294b33372ab5f9bf0c83963b389afec76b4475d711ab12da1227c9bbea51a7500a6c65af3788fb00822d652eb23a3b28794fadbedd9c1e81423f219e1249f77bea6ead8761fbf06ba496213f0464542e9325f3103ff0dc5e8a10930cd88d2b54a1d765f586ea69ec91b9e221065550865fe072263b38f4577a02d6333828a2fa1e58db79555345446b4ee4ed9e703b086b2e859e0052ac39f7ebd6bfacb7957eb5613f079b5fe813d692dead3aa5967857f7879f5d650136002ce5332a9f2d0e8b33ab1c72aa5aaa1835eadb8a0f7be3dd93cf6df333a69cde7a409aca41bc6b4da46b4238db1eee3ae8efab2dedd9d3604c745439cf7691ee1c43f58ff5c030e13e5f62283467e06d8f6d99197ca9daa6d508de0a9a957ff1b4e3419aadf7e2098065c17a2846765c3d9281208c290e71165fee6b89bc21e65ff68c59702934bea8b6254e66e5eb65f3bd71c3f5842fdf9493c7c214cf883c45f08404a11196ca62045d919b21cd7be6b17d32ba5c55cdf14647ba92cea20affaf7c2ce618791b494bd2f9cafc28c82e776fcf22d2b613ecb2d7446831766e1ba72d27d5e053bc8f247754ca2e2886e28f0461f2861aa23c64c5d561a567dba3eea7cd491cb61491257721426121e4604072bd4f25d1f31994857486818accf9fd7b8a55af1ffb3a6267ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
