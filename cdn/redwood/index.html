<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8320e5f01cbd9db4affffcb9489b5960d39d789114e0e86154157b6c4c18c4178dbb21c780d265d4262a745886716e26108b5b8cd687fec727106b14b0f3a52e7677f57dbbe756ba393e9f07fb75f5f98d4c06d03db90fd3913747d5b24006641ceba56b028629f2fcb3c39e6f5a98eb1b9b3727f214b0c93970a6b4fabe83f6220fdaa1fe6a417e567f3e300624ee72ffcbcd7d06c0777753a8d1cb163811607268fd20c21980486de87aa3c54b40939bf26333f0d5a63baef287aab376f274baaeca393ec86216e378d11a51d06c3562f4d29ad409b46f838f468b50949e8fe55033492736d00b8a47b3f1bb2b6e7229ba5ce047e6e6f55b268cdfdd61bcd1a6c498fbdcbcbea5c67c72f31206d1b79b630026658443105d5ff11e31dc018e0a6785d2bba553c24c2c24cae0fa76b611636861bd6f8b0f771894dde6d837b52bf5256e8fdd0c4544ce42f9b4b23f1027b77350a0eee048914f975ccf477fbc2a9d98446802fd8a9faf8f0d26b62f0566e28c5660b632056687b935a2033eaa7d8cedd570bbeef3509c25a8ae2e731bfece952df94d6f82d3e17989d54096aaf606d538d43d5a9f900c40adfd111afcff1507f111931b7410888bbf1fe45822fc9b96e7a1cd786837b18609aae314bde691b3085778b3bd505f8d91bff8c32d0ca149cded192753adda60fc5ee8b959f4344d1b86a497e5c6731c03443d71e271c8d488fc332d6338a0f74283e5b0fcdac3d42883e505a8b2469443b5d609000056f7625939e317bd3234b2196c43c652285b2eaf0b1190f1e61fe4be7283434ff5ee55ff8ab605e035118743f72099f09c73193c3e2e8cbb906144711c481b5bb8ee9712f667f015ca7041da1cfa0988dff1b98c4dc49198e3c9263a1a444e88811ad79a83ac7b67695cb7fe0afb07119c2ee957d9e6d744bec222924575b50fda8e184f16eba22613a0d65d737ddd9e85841f679a91cb94e3ae199721082b16fff337abe6a04dc1674e88d3a630fcefd3aaf769876a010dd151e340192ace03e28c068054a615ab0509ab7ffff96c408b3e6c96c1e269887a5846b57c2300aa27c63febc331dede2765df204435b399c275ff2c1b89a9b51e7bf7e9e61d6c308b366215ed7577824eb71eb2f78d16a8044dc04785e91fb6a9f20e74606a2cc75c09162634569085fb929639ce257d277121316aaca72e44bf75f26b95798010cfb99d41dca04b6e7548b7706847dc1743f7aba8baffc1bb195dcf37c01f2ff9c4effeaf84a8d873da0e0f37b38defb94d77aa129f95ee01e17ca4fb8a351260a2ed5a6b3579b7ac2219aca6503991efb463e3aff0d85e011b605a7c0a7b5e94ae2be123e81ac4d7e30e2633e9a4622a335aa898142a91e871432018af0e2e38e3265b9fa5fdcdc3372030b7cb4e8b9a24ddac72b128b0b9f0dcad2473ae0a0dc3c7cec3bb9768eb3f2b9d13c82db1be7f8c7aff64cf2a765476a66b0202777375d0efbaff8cfd582a1ee16f4919f3bb029e10765677059ee107399e5ce5d1888c094c9064b855ed360f8f0acc2dbdd41652f02b3431c5fda5e1bab043f5bafb7a87446f6d18bafc1e8797940ce37c354fe7cde2687e837570a7a815d8540ce4a4870760e4804b6e8f2396c1e9706bd75922224081a44c979ee575e45c2ef38a7b31ce7d4478951c980b4d6e4e0c006334175a99f54206dd086e03fb6dca3b8773deaa84c55a777e78eefd309f22daf459709e80c10f514f29868384ded94e814b389a952dfb5a11764ea4f3370119a7dd884e5ee8a771d8af7d274c29140913d5e383afe7ae214bc7f246ed6c42a2e1efc26e240bb88aa352a2cacbeb93805ff7a26795caab5043a0a188a4a97ba2c3131e4ce783bd9ab65ed01838ea3da68d14e6ee785bb7522020d935b59a279a1c652d5a64f108722fb02b3213ec502fdbf46200b58111b748a346660cf62601bee68922e72d4b4382fe2f8c29c1063884f61d4f153f9a853420cb15533382909886f45b3d52b66e4b00254e882b970e3fe9966310f634470596d189c530268ca82c953b00e7e229ae8fb878b4f17b835698025d0e6fd3ac9aa45b29c1991f81132760e201a11f848fb8211a6b3c9706c387fdbeb6127be58c22a3db0fd76a69d484ba4372c18413c6d98b3bd4a028251c7b29028dd0110befc943494acb7e63565281ca8bcd9b9229e4a5cd49e700635d367f7a58503930c30f71b61c397d757a2124d100d86b27dbf5db0ea6d0facc4bf48270bfa4f01b7b351ad646bfe747436fddc483e8cda7706c21e90d5c55bce56cbf4f89836ca4258b4f7f00576b09e0991031c5fdce095973ffefde22cb08e29db47b1fd7855966ed57c29a3622c2c468afdecf7a96196fba4257dfe00a8ca7f77652ca12c25e40b819fa0547f0a51d255ded50c0fe34437bd8b1b3bff8122ed2387f3ba85a7ce2b69c08d2aef82d65b4889cb444b9bdece62d977d3512cf6f0141c3a416dc7927d1ba1e7ebc9605635a470094cc2a1b3835d881626911a63f4776b428a0c46d2e9d0895458f539a0be96f3be81a83731055e6697174377bf42724c3390ecbadf593357de689c75fcbde2b5e25a58808993cdbd103d637752763dd5c8f446ac8007fe7de0027b73dc435a5b22c939b79934d254c3eb09d1246b49c79b92c71e7d4ba458990dd5afa899eaff2f7dbd75ad50ffa8407720cbc24e10520da7899e5e5d576805311d9e767b4630a8d5967f593c06aef18e99a3944f1689a2122ad2af09b4ed29c467547a2fe9fd83d5b333de12dbb91fed9a73fca0703cd7fef3c10db91fbee125e674ecb0e8e0a4bad5606eb5e2c76dde01df9f77cf6be0c616e2bb99bef028858a91ffe1e42534e55e81156c3ff1c0ab34fba0ed1f0e8a9ae728e9b042690cfa95eb234305475b4a8070106ab65d01c1b17da87d7e6f1bd9781edc07d93857f437834b99246737d6173880c3bd5562eb0b9e7a57effcb684717a95b538dcbcbddd03d7e84989ad4a170465bd235d2b909bc6d9b0e70dcd87ef9f53aae5c151b294a02af538aa2b5b6a22b80dcc9e0506dd7fb40f1f9e6f25ffe56c775c4dd2915d59b1d2af7bf6ebf1e63bc092d347c0ab688e231aa2cb56faa106fba6f523d53eeaa6faae8387e1eafabd8e6ca0ea016310f35d30959731d0ed4e749b9731833a41d416bf2f83a19ecba2099722dc1ef832481df9f8275e950c3bb99ccc49508e96736e78c944ccbad645687580d1901009294e3fc0f6e2f3ab99b5ab5c45bb410fcae78f4678855f912ad4114c941cfed506177f752d44cd3b95ddb68ce9f253cb73124691f686f351a6bdbbfac21579a9a32fcbba3c4bb54c682578a68fa354d1bafeb83da13cb56de334513a67cf90fe1ce952759c1db3134b7960e4fe8988642526025bf8214ba4ee0fb178d617cd7b5f3c98ccc89d9d2b0388f9b90900e3506f21424cea9685a8fff17c9f8c70fd201972b98f3fad0409844c630730be66dfb54aec6929c4f417485a29146b688d2ece67c310acf1428b336842a0d45a042f803810ac97dd9c3cfaec3ee83f578b29101be4a0a4c6c1fdcd78c1d7f8511cf07b6a18a963533e4007d369aed10dadb9266fef65bfee44e50ffd9c41e89e9ee96fcad8fc7bc4bf6122fdb875526ed30f190b87c1b4b86ccd6f23158603a3e9b704fa7fbc2a007d6fe0617a31abfef0f947460ea273b5d21b2a15822154a40041a8709085029c86af028a8d3135122f710894a4fd995e2ef141cb3e4012e78c6345602aa098f98139c014ea4c793b97508e6b9d36fd93f901a9a41ed9191cae2fd80848d474c8c8fdb0a7abfb491fd99780086410c02ae463ceda391ba254ca00e8d8207c50cf5afb11c98b477cd1273d63997640d6967210f9e14fd940de13c56b2d9cf61e2a06281fa02642e6ad2c5cb6e80b65e878c5f028d8c5dc369e3b9de8c24c1c2ecb7d37ed769b3ec9b9424c1527cb4a8bb4d054c4cc95797c231bd27c239d899bb978662297efbf041d79a3203c96cc8eb88f1bc5b6555aa35be574ffb296fc522b7b052953f5bc43826eb3206c36a4a2419bc8530052f2a90066cbff7a83d5a675ef27b52510c0a7155e0fa817aeabf1e54d3f72e3773fcdbe9ccb8347a1005de1ca580a73c2849dd587787f9b3e45f72feddf5bdb8e99df81bb1a1594cee762c63189a2da1cc358b2bf5a5f7f0d79ddf16d7d21daefb58a3509b63a14593fc80563de795e2f02ecb3051774695f9bc69410e871f9fe11ddeafa90295e77a918be45d59c7fd0233a7ff15dec2d2e74d8c824094bc02f2ab183d34c4ea47ad75d075f925ce2a991f80f5b277f535eaca25906c495ea97b85df644b878a7dd5b4ffa48b99f947b035d17ea68426b3a9de38d25cb178bf329bb8389c57385fd76542ba4847dfe1d9bbd11eba52697f7cb789852555d942f68d50d86ecb52d090ce551b999c366a6892d33d3fb8b65ef3db8305568f188ead62c3eefb2486fc82b278eedb624b8b0bd2e8df87ecad5a5df9468e29a0db28ac0f6774e1e58e6e8a5826ccf5c2db926d358effcab67838cf966d33db93864de753a5cef53710fd720298138ed7119e8bf7e0d8e339908facb6eaf7a684dee3bca7031c8bd7032dd21eac42dfc7b92a294af73a909070be13f9b0e2893c3203bc4399322fdf2d48f0b115400673c56437066833902ce1f769ebbf518c9d8bce04dc2cba5a8578a8ec521aec3c097ad9cfdeb05505c2112fa0f24c3a438a79a8b8fd06915a7175926f584606aa5b779495c52530875c9d089bd2f507af4911e708aa0abf1bdcbaac92f74e412f5dd70363d004cfd2e991b92637e1e3eee1b4a015204ca89a7e3b6d5a185c9caa5bdc9b9338de542b83f098f4aba4f096a9d6259e2cd70d11a3760b5424708d166f3795dc992a0e1a24ea913209181cf8feee0abe411bac11c797458b5763cf359e029d6f7ca87014897765471f28a2a5ca0585bd723e094c1d1922fe95629e2bb8b535a973c685d40dd1346d60c7af940d035471e98919ec993c203520f143e73cc1e899feb1135612087578cef5995bdc86fb57b95eca09d7cd6ad7faa9c3465344da36d287fafaffd4f45e6b757321034f3d52573ca408d5cd733924cc96fabf726f4ee455feaa672a12ebc63bcda8d9d444b0d7d8a25852a376c092a9af4848c6baaca3f33e66b3e59eeabb13a4bc0de3683ed93426a560e4adfc5affc52f4f6b5d581fd213a209f37a7b86b82fb70186f77660acf0e0884423dc53d9f86455ecacaa0e4815e6bc7d59ebb9376b0cf5b70317fc66b5200a6da25a9dbaf0fd313b1cd704b62784bad4dfe5da24106194a689ef66fd794cb6ce99fb2b1473787019616815fca0a88318f67293a49cab39aa6052562ebce01161c1e130b3648725b2a53a76043765c3d5ec1ebae393de22f5edca79b18aeee72b0ae70571198e23228ad0b53c8bf94c478cb6236ec3b044b91dfaffa59a581dff86c2983de9d8497879911d610535ce6b8cbaa1259a92278ac02255e2901ac7362855c316f19f695694a1ce4f8504c5c90d125712f2e4f852d12df03af4c361cc778cc9dd33fbf03d8d14733be22b89e417882f68d6600f00ea2ba90fb215522a6b4b2c0d0704f92f86f67e4002317a3c17e2f3a2c7d2236b6671cdbee104e32b3d9fbf7df02958d58298e3c247f61c7650074caa1ac3681d3ad03d888b12ebe256f53857458f10cdf2ac9c011f9d35a8dd4c48a9e910507f7e66b659eba7ad53870ec3c2c7883f64d797db36a5fa32212bb4b58e0f99ce6b43a0731fbbd399040501312f8c0b6c9176e0d7150e862190e3e55ac8346f664a4721ef6185c791bd8028ec5162908fdb7dc4efb0c199abb4de1cc787769df8c2cd64d8b5e9da06bc4726afd576cb11738c816a28da5062bf3119f07a4c43d98b5e15b896143cc416e0ad410ae10de1af5df530eaf15d10f085599438df6909f4ac662c4c4faa49d6bbaa35dd88ff55c2ebbbd473c99b8f7ff29e042597a457a8980b33339afa6cd0277bda3359903a75f9e0bd207d87f02e23dfdf8a206faeee7b2eb5d4d61f90d666b08277345c9f1bcfe28edbcdb3c8ea3ec246f7ca0b527c0788bb131aa72d2988c5d3330b1f01edae2ecc34230afba7eb07ecf4f892b92603b2df0657536778f3a410246aae53d1d53149be16b4b8f38391d8f4f8f5336ea0152e5803e976b0ced7c51f984bc8f3efdecb20c7740fc59a6ebffbcb40b4bdf99a0e70cb081f044d836b8d9cc898fbd4a2a4eea37c87c69b9cb42a22a8f1cb0064dc20ddf122b732830bac7439063a0479ea5e4c1c5b12d16c8ed9ac59109103bb0b437b9d5bf4c40629a57a73f48b1c3592efe094a03aea4aeb72dc68da5768611be32ff8e3dfbe9e4ac97ac1804432ec885647d023633d7cd1bf997483df787cabaf4d0743d9fb24d4a080d33d25d78b302aa17f0ee98d8fe1d989582e7c68f761c8b6546d98725192bf1dabbe7c1f9f6b73716231c361a62d12b0b8e94e7e2439f4e1ed3390d4cd206c9dda77b1836dd5aecc64d80b379270eeac508bf517e53955b4febdad0412530414b198fe1eaef97a92cf8c1d8873475afc15094aeb902b119c559c6d7e994e2903bda1279fe3ea5d0b088a48aa9881d1e8c6e2cb4cdba7cda729fdf8bec2dbd17ea1116f0a9789caca38bd64f8530293029552b4d33adb836d9c94b11e333adcd32cf6633de2db682fbe7cdb96d7a094afad6b2d3c657733ed334eea37b04f0ba3265d88843aa809f7027eb918fe465322bd20a4c96c87cab6974698b8a663dbbfc16776ebb09d09e546dac4dd4912f759158789b3353f698b12e27dfe089111272fd80932ec7299c1b5dec50eb8ee83d0246551b6f99f613cf0afb70b260020c58dc5809b6a942a3947da564884127e9642a7de950a1045ac0026a3294d8dcb82937d3a8fcb44df1cc1773933f23c9de65206cd81972428ece8ae17f47b18d858a27190bbd93ae37f65e87f9235677e2b8bd9cbe13f5454fc872498e3e67bf81056b603bc60e5b4851051c000216c59ae605f872c51e628fae1a29b6cc8c86fecc060b3a7981821a23ae3409bcf9cac894140a05c23abf86da8a0aabb6915bf98f431155c0b2e906e474b39393cd56e8fe4fddd6a83fbed387a8124032a10628c9011d3ce5ff757bf95344b065093e01b4e56636fafd17a87f4964f60e7b3adb27628c1e2d5fb89fc60c2b9c025be920f2ec2820bda93c51a644285ef79cf031f85eb5a18d7c63b570056f6340045242b3b6a5e8187b1659ed0673346feed42ad1179bee0b4965216ddf9123f9c225bdc82cd9a972c37a5835950995a00d3164f747348890fac0319d4d12918982db54ba3f946367fd0b5af25e13fb31721c09f10b73704e233ad1cf2f882e783fa8cc84c60676c1c94c38daa2d5bdc3380d5673f443cc297d9dd5b4a4a77eef0e06cd670afee8bc55fa6d91bb6b8de5bae116e8c5fcdfbce6d3a308467296fc72ae6f8ce1bcad95fd6f8d898217c07f712cf2cdc946abd032bc598a74dc531916223545beaf3a0eaf5640449da3f6430e4263cfe2a9c43926bf79649d4fb007c3e7eebd17703cfd6cd00993e222941e78f2db8c3683f404d6e97a6088f4a631e5f7a965904c581f6a942e390a04d5cd2c145954c7723b781167de522974268a38e7c235859aeb5b0543eda678e30533896e8010192b643b3b0feb65423feecf60c72a51e383390ec79a654c8ee2d647e858c35df4adebfd40ff1cbf67f35fb3f82117d831a697b950c1ffd38b158a56739af6a7515861d33b1bae9b37f3f2dfb7d78e6eb1ac32e2ac7e49067ee44989642b752005f4d3039684db2d374519fc675c31337013026cdb7c8a3bff9fe07ef6385ad37938196ad6ea68332da5e648e03050f80703a9612d1dbee18a26da4de5a15cee6683c71beee480db862a12e6e7ea397df59da01523a701419a8d35736117ca7657a451cd8aa4350906402a83438468c270cd153d2db661e05342ca9fdc94f243a87db3a247021b6362b692151bba0b89a512fe9750f133fcb8db9104dceb29a5dd6061b45956b1147f391c5ad91c3a2dd8aa34ce29bce04f158925b09c24b1c2ff940fbf11166b81a23889c67b32a40fab5ffdf71a34e2e37fdb4229a085cd8ef12b3b591934fd3d1b91ac756ae33d0b4907bfaadc5beac7a16e5949550deafa3613bd60df7f16ab8a7aa44fb987a94f0aa5b077ec5a7ac0b20bfbba035dd8d73264d6854246319c0d9f35253f168bb74b313dfa5ae424bb993cfd42278be501a5c966b103c3145f992eacfb78d6920ec6ead093ed5e14d5e56d08f8d8092a4bb9e952a4fc59f9fb043b2b4dc2bd6964f039f338822ab84f814a13c4c49de92485fd6f25a60f4f69ac2a1024659b83739200da33eeb9495e8560c604e1c111536e16c907df0f909246cef0d07eed6d7d3461b594abfa82d30cc1051b33025663e5e0e54bfb04f5ea1fde72a64b7acb52d69156ba471191af5589dbd13cadca034a1931566058423c3c148d798055a1cfa8127409476ccc434277fd3661db6dd9c7eb80928ace586cbd858d6b62f798ecd1f31d495c20a9bba472eeff04d9361742d7096b7bab3eae00995b87869474156503438b4ef17fff47f188850ad6f8883e6ebf137053c6f54ba6ed1488bc35a45627c34e6fa64b0055102495726c6ee3e11257a2bc20185fe70db67e8680fc642c9f59c8c76cf9ef4de7a170009b7dc4ef310670601b174f71b572e9f78a3c6df026bdcc7a33f5c8a9dd3171f77dbd1a3ef90a5f949154144298e3cf75b65291484b4f7ed7ea7e6fd7e958352b8a22d950e76363f363fd01434bc588ad31982cbc545c2f9cc0ed3ae33cbb7bd2ee301bf320d81d1556a892e826c008d421d24061370c835a9feb9dd6fd7b8cb472addcd3e5e49804d706ffae36bc5d2f33a9389164ec5bb9fa0e332df80850781190977e0f0c8b7405b463e1d81f65b8f9b91e45bdf7ea44b9e8015d00c927e0eb6a026fd1c0ab54a181c03e93e2f2dde0ab6e8979cea1fc1df92db98b4f5cc7f8e013e0380873ae6ebf53f6575385cb8ff1bc1a858f5437a18032743c772d6ccc85b257042d1b70d799bb9c8390ebe3249e01370c22dbc7d5cd0dec2bdab642b1b0d55f0886571709fd14fe0eb8eff6ed2ba0b7d559e9432c5b3b674b49ca16dcb0761ceb9294267f6bd153384aa38cdc1a31803cf600724524084a67b5d22e6240813d70b0a05f27db46eb974f62410ffdaf5538871af9e510085e9d14dc0122056d2ff0d85a659314e6a99f6b779bcdfe1eb5e08a9910f8bf43773975768758e33e1a303c84355b6bba0f130b092925dd139f8db07f97294d86438eaa101bd6b93b3bb35817d94fc3ba20013a91b4daa310a1826c6c027c6cc5c090200cd0cfcf4919c3ed64fbbec96148becec5749071332d49f8b764e2aa2e20f56a0529459dab99047aa7bcbafe93aa4b2d88c701a60f052567c82f18f809bb3a890000905a39c018baccf15eddf07f6413665767b4c16d8712449571c4c01ea055488f5dbc77357a3816905923e87f6caad1a7b4043535fdb1b07670ac25a152643749872888866a317dd6c594a5c68b065875e48ecae032ee3ff6d0ee520ffe9024082c8047831dcc3ee0a398bf4847394c91aac313e7102161ca3f0ac2fb589ad91520dc23982d560bf8cb7b58fdb0d59580b461389f406169353b49c3707742d697c950447e5fa1c763f9794d6eed16df3322b8f60f2567d11043ef6a8f7409fe9f415316150453cd816737401315f042595a4e4630316df5cbdb3870cbb3a551ff8720ba1f05f55f0ba6e4da67f370a90c6b99c6eb868b50f3117aa3be91624bcbfe0fb9d24142894afb28e2d6588957d0642b672ad55b7ae196524be49f46c5be16a72b18b10e022121dabaf01265048351f3469abc8f5af4b26aa51aa73e6d76dc2a2daf01006849ba19a1e328496fcb9edb90be1a01031732cf18942cb0a3f4fdf317aa563c86a64fb7ad422449caea478219e307f8fd97221e836fc943953dd56e9f1e2347fd360fb9a67b6a5aec10edcc15a20e178fafe3b202f67e11915eade272584f94bf4f45a58cb349a482cf2f7654a48cce05b7d162c804271be5aa09e8b49856e78e59d3149709ef7fbec0e5f061e9a0f7b422f4cc048e76ed5bbb743a8f25bf6ed3282fec4cd354143bd1ef939c0aaae809fc3f32539e70115871a075d29f840ac12a5df656a22efc161ec506fd37a62fd24a71f8bcb86c6be6b4095c786d0c1532f343d38d362715b39cfd2014b52d5ffe1561fe62492fad4f30bf930870553a5a548261179044f9451823c0b90ee22e1c6e28f3c9f8834a311c39412c8b14f157e2f133b064fa33b0508706d668423d2cea398e2d2985fc237e70d6de7e4bc2b83206f831f8950ebe4f82a3177c59a56dbfb7f053d72d86067ca2b7af548cb529893abf8b8b59d7e4182c51e9966548639f06cfa2d03ace7daddb27580f22f5625db7b31caa4ce1f2d695e40c57f238d3306e480db159882f9b4dc7503f08962f3bf42848472c4a121f720ab5cfe77d477cf3dffd6c6042e0708cf131b2a56a21e4042069788edb201ab8f61352aed8ee428a02d377daca973be3e832710b1bd80fa2d39d984ba5d6fb9720a970d8ff7747f758d3c56768131a57e7355a60ba29b147305dfa0f19c79dd627c7188b0c96023f1b5a447be2c1191f0e68844c3144d2ad2b16eca50bf4bfdc0a990723fd54e77f029e8156125e6e4e427eefb021e2608a5b5d7d47aec5d2e3fb8a950e364116fb15b8264d4146fd1afc308d30826074ab325aeb7c3aceba40fc07a002d934f46c3b316b2d4b741fa2cd8f015fb77604b3f5f4073c80105499340a46b1267360b256603f1a02338c2478fd1b21a0e0cf57105c0d182ac918e88ec2dc3a24b0ba415c6bb3302226cd7e1400273d56daa2be0f9e6ea51bdb7b0ae848dc5b6aa1ff48d2e24c2a983e5f6b1414c1d9429851a7219f03c6fcd314d536e330bec0f12418e48ae60e53557f0966526faa6c9491ca650c2742e693c2420baee808c567b76b0baee426d41ea82bc45b33c75b1ba0b42e3a3a8ed99e792fb56d395d238f2d1b84e5742240aa4e32b93fe54ff96584cc6174a9a594bd801a1be8114e85672e066544cf1fed477a6b88fc62adb8811f3cc0fbde231f5e5379df184fa221497f7caa7b70da89e95183ca920e63b0551aa0836ba7f525df1edeba208725d7243d3abbe0f26d690ea08174127d6bd4175c7f07a821777c08f8d843bc04ee537e14d04756fe4cbd93d12f384fb699fcf2ae4b81fdf63c91f78499e80add51443cbe216f1e1a6b38b236fcb4126cb3c31043884e1d2683e7a82d2c1fc40145eaeeb74532d85522839f807c6fd68e99852deb40e5613282e35c6fd5fb5413d70837cb3494f4d765ed9b8bde13ac1791c01853f34b88df842fe046ebdf85364457076eb93252a6cd6dfd33df1012cceea08e27fb1c12a2eb05eb38ecb90499cc6749b1605ddc5e0e10491591d0e73377482b81a182a2b13bdf0ed20c4460e567f1f1e318b777494aa7f8764f30d0916caaadc44dae82295819ad60f185eae1ba08345ba908a96ac9322c30195db73b69027ce5a998a41eceb0f21927ea6497d728defaaaa97e3c56d7a387ba72e4198601a209df58625cbf8a6bf7690480c5e329cf4d550fd0a5a469f4ec6451b8bea7d174b6ec9983f7c3aa47cd23a41d67b633dda10dfaaedb9432743e0cf949c80e06d2abbf26325c42cc1687491b1c84a311ffebd4e5237b38157155a7c97e8d780cfe659cf4c62c6f866384ee67f9539e91507d268f4047dca6f53711fad0e0cc8c37a0e073b9c9239df84205fb1f1304b8e125874e0e071e6cc6d3ba58230a0e02d4cd53fc81c1cd080348e80a255ea6dd4ca941b8bb69ea027a88327460a20c66272c3c7cfaab86d486ebf8823f4362beff8ec426da04b577d660f0707c10295ee9ee4741e695f0b5f2fbd44732300042ca8d14515efc87d83260f810a620460a30941ec928990b56db4751ed0b459f33a22b0cc59b0e01ed7e06d3fb565d55fef667333c6faf6a983c3976474e0809f4656cf8e7edf42de7ef2d35c2f50f15577fe8c0ad7c77ac060270f99e35cbdf0abb0a3c80032e35d0123702f55440e0e0a8476353fca5727a89477359083a0633a7470a6affcef93a7b8a2c83db5eb26d99a2a913552764df832cf692d73168d4851e83f114486a4020d532c798017761da7613cdeb01121cdab3134327521c12cd27e7116ab1c7554f86c660635fab059ef026c191ceb1f419533f1fdab4ad438c0b7563013ce17c0eff44fdfc94d5068a578bf5e52a3621a2f50cddab0bebc252002cc5fba550198fe09c2d3435ca705e99311976e7b1094827723b343dad78fc60b4c0c4002d59296a7e607f1be4c3f075faf9ed8f7df7c0155be04ce46c2a03d51a44f97dec88b6e0db201fd3e2b199d3f3decacd32a64da356f6245def20172e635f4a8d342e3682506ab8f0c9a3fe48a62d7a2b7619f90a5a381120c6c39b700d961027a62cda7c84e540c215d654005d439a579e1f06517e7285afacd3313ee819fc2548356f53aa393cfeeff4056fb141e91da6a067c705d65d454deabb056dfbe2787f238111d7018568b21d8fbc08abc6ebdb01d18d535fcc96dafddb9c8fcff8cd6d6ed009525adda84004173535cf1c1f29e7c40c16f234d4993625646898a8c55b62b5f42322772be585aacf4dbf3dc9394a9cf33e2878b0329e429885cc09a38ab2e161e6b8da40fa533baea5adccd783ab4c7d4634ce69a257ac5aadbd897276c0fde2488a3977ef474939cef5241a4ca03a9299e3487dec072d06c1a62d5aa5bf9e360b0daadc5699cc970a5960259717bde26e50cf034c5beb5da1474a2898584f98104bd580ae0ee98b5764f3bde479f6cad249301ecae20645aa042b8b2c00eaf700feb29efd0c302bb242e3b9864320751cf34c68dc968d7f3207876b1068b08e3153cd8582c2b89db23917f2b4ef2af0a4dfc5403cfb96bbc27061c264e48ce43dd39edb30b09f2b99ca5068d4c5bd8476ed8f2f5ca46b6156dcd84863a2e82a8b2fbb838939dbb0d8b3928d9b9345f7be8200031679ecddef77893d894fbce30392ba1e967e338cafd5c476837862f376769f95c2f41b39443160aa40646d69c6bb8507d38642f2d4afcc48346ef619ebb50aefb14bc8ff6d856d83c3faa27678c9c6f7b6bad7d4b12646eaf5aafa0100838ef2500ffeede891c8c1a5f4a4b23c9378911fff9808697c027875f68fdf0d4ad9bce7e740ce47bf7c5cf14994046b367fd96a64e3186bab2d33edd4bcb5fee84150d178d0721602628e7a8cc14faaea47df43b38de84ff41bba90595f391dee0c5b441024f3ae77859b41078d51805b19224e81276902857ada519329fd21e8b55ae826abaed71c6023b681effd778c85145f2bf97d1039e8f840d2740d564789d99c75d28634704f2fd736d06f5637ccf58e63c1996deb4f6819dd24a76df37c2d30c86f415e248414dcae4be25161fdf7a8808950df3036822ddad179bf1e605bb1c67a812ad4c8255724df26487be1a228dd153f9a76f51fa8c74490a77d3add30003fe1e03a40a19df551dbf6ae343e786fecf3ce5f26ff2a6e33f0c26171d9766babe88a9983ecab73e0a109fbab0e1777c84490eb2e3716b2b0c2acaa860b9e13ceec80dab63835eed073e71cfc33f7061afcb55e4a14cd4327efdda7ef5dce067ab202e5f875a6bc7eed8b05d53fde89af7f0eea82c0f8c6f734ef316853f8014761eea953a498918a711dd5d04ae770ae7eed5dfe71a92615bb39efe3e9229bec73a643b8dabf62b03b3299f993a9b23030bd7ab5c1c2ad71dea44e41a8661f887af9491ecacf3ab75869097e998733fa516f5f04c53cb571fb7e1027a08e695fe94b50127486cdf961225b80743b0dc197956d2f3294b765377974eb0c843131bbfd2957c8d433a780346c4f1f22708316b32961f6c47878d861cb82bfae9042e92e83a71571d84628ddefd07609f77e58d767e002064d93d3013cba12e4ca0a26f06d6af1b590ee2d845dab08e552eb3045b786dfb7832d8a06eff0551be861c6a7b7fa69f6c8adbac0f91d2341b6a2fe8f6f89fd5fd100f3eaa27779badcb7739442e296f286520a042ae6066f702fdac23c8790f0437b5e26c03cb7400ae06bd33026c9e0b80a245df4d1d9b6df97bbfe25d46c25dfca0b1d9e3027883c8d4a659413f9740f4955a9de68bd543e99eebef6af5a1d5e25fc4ce6e36f59c43c75efbf5087a33009d1a18f9fb329f7c556b83da47b8a283bcfd6f0815539a52f11588b4e9bb5f014b48f56156a5201072dce8a9a830f42f2544d4958812b43cfde7be9990e8c29649a3825abfec3573e3735b1019cec75e83a64be13abccfef019c70c10c4b87abed0c5b086f487e6e4801275069d168a4d93af597d39ca8e183e6ab41556e78f5c01f56ee8e767c1b8537c5ca74f818b9d5404904678d701889363a17d70492e9965399c183a654c8a658be6e82f7c75856f367071d4d063e79101f2a40afbdb5d356c627ce0376dca63964c82012d98bd40fe9c2e65625c2dd48c54f7634fd5eb66470e2463d58291327af34979a4070472e9cad3fbd0ac813d401dd2e65a592a26fe1275c2363f98d13e728f426a40c825183ad5a405c667ff0536a4e8ae3e9dde7c533b35fdde60be43fb9a0cf5539fdd6cba5108bb45e03aa70df2bfaef126871d717005d2e86225ce57b387061ade912aa5e2cd41f29128c8b33f7ffef22c59f45d960296b152bafca6250babc34036ffb39aca6ad924264495669c2e0ca5a78a240e8307a3ad415619c1a21d36848c6f3c32e8034d3d0444472027d3492a609f71aa51b2981e31b40ce50dbfcae58be5e5d88e10ccc4abb21e0eec77cb7d92d91e1d5703939b046af75399f5e12c0feb52a2b50176041c935f513c71a33fc4075a6ac7592965e6bc6ebe5935f3c5f1dc664ac5e6025b65afbb34989c2301532d369ae3afa0b76f5f2dc262eb91b9ff0338c137aeb0fd5a37f460ff221855273b6c87cb8fed204584f7459d6ebf8b42dab655066d36234d4c464c1f26dc73d621cfe139ef9258d1ae7c3418f3347e032d51ae5b8f5678ee993a271c9e0ddd9b01f3ea7c61e3303b798271a92661b0ba58d399bd8fac23002a9e6096f002a1773aa0d67304ed7dd4ca8d09f035c34c17960718b9adfea8a81e6399c9f3740855606ac9b586be640e8f242d1d4a9479da828bd3ff5e11426318184aabbe13f56cb75128f954682774916d88bfa753b1b7b11f9dd26a29d80f6b9da0060de065d974f2febd6578b9221432074f46a509acdeffbd19db060891d16da190b8651358893ab749a62c1cac905979012ac6375cf589243e588fd8f315b5e0c416acea7c1dc4806cb2143e9a16a2dfe1e813dc1603c4cbda2be748c26fafbce56010c0d2752782ea144b1d94e8282e47fe8cd00d8cd68f28e5c25b291948e2db4db3f2f7763e436e3d5c1273416bec28c40a8e3d13461604d56bd80b9f3fda390c939f21329d1721108a64a9b417d68f14482218df030af586da1097e2bcf9c0ba09dfcc57615e362e8da9b999e3f391c5ddfc67b2e6a72cf847c6e9367f86807d6b06732cdbacfad0e7d23a46a99054794e387a939070c29babdbebfb45b0afb3c62e37893ac2bc19913c5e670431d5afc0cd9fee89969f309af2371a6b4e83daf36527a6f4aff47de4060642aa0409c4f56c874caa8fa76a6787bb6fb3882ee12c806bda2b10b6a95a184cde4e6dff2441a1349d66d6f1200580c2006686521e0959fcc8516aab379c0a088f89be0a25c0658c12527b27318a1d7119656d86b70aee57bde483382f75ff5ab5a48bf3a8fe1b3e8868b32a157d679f742d9059f8d56021d4b0819a44d12c92dfa632a531e5dd63eba398f8d70e42129e0f918c2b6c83457951ec229feab4ec9782d3e2920def79d0cf76c25af8afa00af3ef722d548c061550ef7a9d188cf3a2da345e651f368aec93a95c991c670ce529ebc66e93f883e94186710eecfb99988b5c5d4666abbc415ac6848361f128101b80bbab735cc776ae5eedd95dcfe766335440632110d267611cdc100bec4a31301ea0c255b8e50b04f73870aabe991fccdef862de43ae0f21b5fd6e1cb196bbf09a2a93de69553cfa7331a8fdb7775af4623f821da26a4f0c87ebc9de1bf3409eaebb06f275c133afe30f84866a06917ea8df0f40a94b693e937ade11f33d35cb29aadee3c33bd3e8c6a76beabb6aa4be3ed606a57062b2f2b83e75f91d3d66a19593285eacede72dd751561125ea37607d269f7599623dfeaa52c72bf755e32b85598acacf365fe40f4cc2dc53b4eaa087fe2a1e5135011d356b03c8a4a18a8e04dafc2781193273e289b09a682907b35b8f4f161aefd3134eee5d88903269430ef9752256fcde88ddced1e4c4b8887fe30c86a0957ed12b2259a871f73b3042c799d11d5fcec2f439498cee4f38ad49e7a06f859a3dae0b9e2e7ea1a36ee512aefb10490682444827fa6172d1c78d2392856363f297715a6225de262aa0a991506d1a1c025ca9a154822953cde29ddb72e4613c7c02769e05c546c41cd1299e1f3bf1ab7cd377b388ee14e270a470492bfb9ad03cbbf516e92a28241bd0c57fb508e64c21eae632b80c3584982e496d83f5c422f8c0cdd61849bbb7913986b42bc0aabce880da94d24a7a86ceca4c771b74907352c444d1a33d1f9ce5fe399131e43e51c9ce552be88ebd02c2e99769c53a24b8b9fabbec167b6f4227c950aacfca1010ae472eaee0081ddb47fc1752326359363b349fd665793f67d7bbd5609dbb00260b5004eae36542f6348f54ef94f47f41f10e940ed22c7a21c1e88fc4e640cabf8520adb2251470fc50d42b569b2505e3ff2d674cdbece7f27f7a4908aa9fc8c681cd045733c8f9a0bd38e51a89e189b15217b5ac0dd9b685c50fa3dedf560677ed71ffe9df3d078e3afc2ad5fb0d8f394f5cc7218fa998de693054406c6e339c87396881627675f11f2c5b26b0cca5537cfe099ea417b413303b4a3ea9b57d91f0bb33ec242266355cda7bea878c8266ace714d1e9f25ab2c78b6475e03ee9dc4431ea6f5eb39d856676f48f5b104e2b50cc0e987bdf741ea3c861b500914eb229f9a8f22ceaa0e9660802734883ba21716e25914532e3e93a79f64469b207de42c115d270df4575d74d576f940d1f8a2d810904426ca31c3ae22fd5b22ae0942e94077dfc135278856daf9aa7fa37a8155b87c7b58d920bbdb52f35fda2ede2005323e01002fe714a82b551d6f77c63efc55c2873e8cff2fbddd6fec12156740f2ba8b8de8947f52ede25131c07678a4c0a09c9c2b0274effe199d0025280c3fc2f354489b7e9765dab16de3af1d49b3bd411bcdbc3b972cae126ea10f6bd913471fc75c754d5d4d45d8fe35dc0ba5e4f4d121e827b247329e401a2284d23f046e7a8efe5a28dc52c421f2ab03fa9c1a392aa8011aab4e0a38ea07100358f7f8f0c815aae502f190bf9b534da2bc0341c14e9f12bda24e247bcbaff962a7e83a4f489fc6a0c1a4cc90c7b018d19ea6da4db002b947b0b0478c517c5b50c04062c1c21c0e896773a9d955a9c0d1b3288af28dbbb0d2982597952bfd0e829129f03f169c0941cacab2f7ce2f9afbd82cd7a68bde3db79f6423c57d81457ceae74083d97c98b7c9c86fc41243f9cc986db1ed805d9dd51163ff5e90b31b6d37d57adca59e10bb60035c01e28fed3a7d929dbbef95697a7fb8687b4303d5254f29094b4b6a3f3edb0375d13df2608c40ebd038578b26a1e8dc65e172008193b946831777964005d9179a571bc086a9766b333aaba54e5fc3b57e259fa2a33ffd7662d74c20a8a6c763acae98a70f6b5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
