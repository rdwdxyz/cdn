<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e724a5708ff895a165ce232827b005166e38ed225625165f0f989e17bb0907b9e3d275ce6aed5a596ab3dcdb4195f4433d90739e04ef3648f023f476db6f9c040e8face4a68c8a0c006045fd36169286f58f3f748a6102e432a4f0f4eddbd1a50690a31b2a290b5cb3cd674c23a0d39a69c08a2ec40ad90072207b87118569d9cdb33524a477b8e4a5f366c51d97feed71c5abf1b3bc029f88727e51c1af1c1f0dcbd80667e027468851e8baa7ba85cfdfc8e0a59908ec775bc7879b61674e5038114b1beb1ddc7d3e4097bf403549d45b97f9dc32fb47189054f27ee9af8488266837614d2afaf08e4369e6dd65f7f4fd0dd6051cc8996bcbdabe93e0eb3b937595fec3b6fa98f1e66275967001ad7f6c2f33767503000eb168305fc53d1984113b140993cef86aff9da6f59b7d4dede37300073ebb26134d8f324f20e3cb2096f3d91d1d24736dca22a3791fe34618da21bb394ebcf6901bf12f798bf8eafa1e5d62bc9890353b76305354df545f33a46c79d0c82b0f88f4a6ea183cc464cc93f5f6ea2d0413c151163e05bab67c7ea7dbd2edbafefb8fcad8acf7758044492d852de7795cea7cd20ffcc5705f64e39078dd35a3a42b30a587dff027d2d45b251016e8bb7262de0e8c2e1cc02d95e746b90324c832d4c524fafe88604db26eac833058cf75e0026306b678dde7eb90780207822e138e6acd8ab8eac17daefbb30aac3b748fc1824ac1359c48c5a3426371b204570d544cf1b680862e9ff0cb5b9e556da37c70fde2c1b075cf97b6244fdcc483039d00ce433c9f9ad74bd514f35d4a92e68a3a219108fb1aed60b21d26901505cfb09f5503657165b0cfad29ab3610f0800e2b1e8eada069f408d4ed4334a6f62ec2371f26e309d67ea47e81fe42b5e316a0335c9e9a822c5898ae258d0f493fb0c7cd9090c30d6bea9e00d64992e7026047d3bca5e1d0d22d36d97d448d1debd761dd42a10d65494694cf3fff8bfbf66ad71a998d2ccc4501c47cd3b66ef4bdcccf1ca2125de5aee034a2d54de3176c3e3dc62b74177153dda2dcb2d6552ea5973e126ca12ca845ec214e9a77f6961027ccf1f7c8ab468d1b4f86c8a672a499e0fa9b5ad99a41dd4ee1988d924ee29868b2bebb62b619b61da469d35465e66e1bb93acaa784f3f428712cf82ff40b7cd0eb85db1c22186e669d3815949a0d538627a2dfafee4a7fe42a37146b7f629a92dd57a6cc2ca0d8c95d538e727b64d214bb37d463351ca86034ccda534dc0389ef7c436c3f6cc0da9b53becc0c449abaa28e58c558bf9b88d963cc84f81998b18bf415c3d300d07750829d763784cdf700bf6492c9fd57cdce45979ad5af2973c838bc59d11c8737b7aca0ca814bea82b241f1b00395c6551603e49cbff7b0af5a425e5a2eeb006fbeccdae35d8a075a5384336c13ab7c7664d4ec1be5ecb91f4be3f110f2c1b4b60906d9b4af6adec626422e10eac8b4fa0684d7ab65d0462448a1198137ff61b413f2b150fbb3cc9a32701edb5f94cfd7777b717914ce1b9c5aa0ef4b0c6965fbabfe63eb407aaee42463c8c275793fe18097d9219cec1b5d7ca6dcc9709d0141434b9cfa13d19f6a160b0572cd8ecaf03a7400f7e83ae8c50035655a1226d13d6c39203c72d5182a377ad2967979fbe3892ad6c54ec66a69a2e349e5a069e40a4000f7d5f60b7612f0bd92fe2e67f6fca050c528cf156b28f7b5ddb675ebb22965e937a6b319873b98537f61dc04377243fa900027c28107954af02a0b851a05fb2bc6fe704ae805a44ab09ab451781e2a45022588be94d302782dd723cf3bb344b9e1a1229970934707eba53766f4d0b76a30c56d5ff76ab8a372fa4b90d339d6f9cb0dc2c296dd84dfc9c62bf605cc0ec97545b196a213b08eace327903223014b754374461111e9bfb18226f0a7c1aa81787a10a40c36018628e4cfa9fd291094a13130a83e088144e0250d2b5af4bc8f082a1744c7046ad8c45f0a1fd03eee72a0805b14b585311daa28c5ff3670774038caa4b63ba16f527daf697a73cd498a375e7dfad2f7af18019b5f7e8b1d55c8093936cc57cfc9b836c889f5a8813128996fc701d39695afb545a012e098084c92df3b36647f1564a406571ce960fa8886238f069d3d134b1d2891c7977ca4dcf111cef1cd3329b1c83bc0854b62a47aca1d5b9a2d02552bbdb77a42018c1ba8ac7de91dbd41013f6b0ae60378e5feb42c88e6829afe1a2eca41913eaa1e95bf019ca738e61c3cc70628930ea35c8a848c8bd95072d48a390d8c1dcca19a6d9eed4e67c69be7bce40d03fe99a3785e3863f9fc1168cc77444b6205996239aa85af7b742b218ff4d01ba017af4d2bfd43c265e5aca55ccd2e06e87e5e6b7662cd609bccfff39f9d9a7ca9718aa52e7430ad671f3bee70158499a53e19c179e23e8216b49d27f51383f9d6631309dbda25cce996b30f240ea171109111a72b3b3a03737c03834e3f492f2fabb302dc35e75341a48186597af751cc4cd2e3fec618f8fcdb61b8ca9ea6cf130db162ed9f2e55ad86ab66977a2fb184764184c7393694961db876654d534c5e43065dda4f9ff3df146542f611cc0fe845c9c6bd1bb673f3d7eb47b7fb341ea95b1889f4009cb7ae3aae495b15c667534238a073310f09ece4e6bc82b42f63bb6b1a1fa5df5af83355fe54582ba41fd48c4f77041990fa5ffd82e37b2c9d9ee0724e4b7e09d7811ef02b5af17c8b33989d11b78edbbea980ba5595838bea9e24100d9abba018b46d3086e37238d275f5272af7ec7eb0d1e997172b2b0dd4d96b29de0016d722712a12cf730951f277f728d35d860d377cf8eb9bc61df258e48178ab66e08933930bf8588627761a9ec953169ef6e3726ec327f0da22d3011c9bc7fff3523ca6050c8d59e083491efdbfaa7597ce579afb837b040cc17ae979df73c6e862264911b5480ebef89c4699f448acf5837e9c1cd4f4c8a3156efa86fbbedef50a5402f5a8c9166f0a6099cb81c4703c367dcd72cd9040aeab276476e3aa56f0505f738ff350b93acae7756c5aad16b149e486639ebdd44e44662595c2d2025808580f3deeb3d1e1e8a44990ad40231c7de85f117bb179c0138ea0398cdf19ad2ff624208d5727654e0f32c3c849eeec62543a57fbc7d08663e5a41c6fceb5ba9b6ad2c0980c5337d90cc3a6c49c4156d5760603b269201229781818a7fce8cd153b8b36924a6d3ed785c5590ed0b4aacc9bbaf6f893853d13c9cdb8704d3e6fdf0df29cd07175218dbbdb8b94f971acae785662486b898750578569b4ad90798635a6a17d6ae078d6949bc4116f29d253114cd1f6c64cb2c8d60c98cca91cba07438767274e57d1ae47eeac4bbdb2cb26f8d2b24ac1764c769d10d99259cef82431b11450017f5423e99dd2e12549d5e49f18f396e10e7e0f06d1f3544dff748b803b8cb8df768935d40f24c3b62c76982252264b2d4cfb4d8f4fdbf50c596b787dff52d9e4eef8a0ffac564053e5ba5df27d47ba93eea4e838882cddb86e6334ad7f7683da826c3f7bbe93fe2b29e0a9bb115ae3cd4bbf5adff1efe5e084aca559896ab414bbc07d3c4c47e884c3a938887c85db39afa220fa0c47949bcd81288e5088dce52ee0febe19702c7ae0e09b12654468e9d1ddd15936100b3644ca5e1a98893e7724f6d99b9e0f111ba32d369287960d75155d9b4dc4929c0c3bcedebf03e70493c81847c39e5c41de05cd3abdf3a35d2526552af2846988929d3fe507775d368f9c89298ed62fdb67ab2ae155d4b875303b7a0313ae1b0c8220d2e8f217df782a07ba5b689fc7b4b5fcb9a4efe1f8c3827e15cbedd901fe4e40ae70da2384973b9705f399c26e3bdfc613f2ea10395847d5d6041739300bfe679080a581e2d162ce9134f15d83ea63208ce194ace305c2733970c95b60f64985885343cf744336ae9d858ec0b4b55158d55db636de4523eb58c8978eb3bb84fee3e5de7551d4d85081a05145cc26c31ef1a4b6bd5c9d18aef0b5ab87f288cd669e6535a1a5b2bf524747416dcce290fcebf12110642c2297e6f1abae9f1caa5da9111ecc97e4edde14809745a3e9d957cad9cad8ddb4d17c8d0845cb70acd50db27533ab05832ef7ed043c59a39d8dbf43dec7e8e9c4fd4bd18972d90d0e99ebb74ac737dbf74f6e879422446064b7e9fdc8e42e7e82a366c67f7091bfd05717390425c3a085deaebfc382f8020ceebc3b7757bfb266b7672f490355dd811b69f25f41c8295ac35a79f4b77f95431aaac08a3e6491ebc24b3fe2327e420a921478df5db3b96d99f5850f189073e1db578be6c6156e3dc4b7eb8510e4617cd19807307ba44b86083329866725c512d24b223bb130cbbd66d23094324e20bd578035c7795652431db88ee56612ea86d1821aa8d59a949d5d1a78b108c136848dfdfb219a5d7326df4fa1ff001e0ce66d93f5caa13f13d40248625fbd4ba0839eba4a00265efca24383959e795cdc4d22c1fe8b44d72bd99e3b492fd00cc2792c1cb766674ef8f568d17310db5a18c3e08fc6c4cff5fd2138c8efdf89d4b0d078393dab4d6704041c460f517bf42ef3b881d0dab332546ba662e110a56c122ce3c29dc3e87b58bbdf5700372903ab6ab18692074a66e5da921afad1e8d8de59c4ec726e79da1515236e0ecff5b7d8cf9bd795ff7478570059eea077bdccf641d6d15a5e7f94811b00a20e4a38d0d8200c33d556fffb732dc9ff99321824b65fe98c9a4bec2dcc19f74351d3935a6f66e8ed3c62f0c69adaa44447ef3970b5e6247f3563445d512a799cff0cc3866189a30c65123dd63e6441e560a2ae117d621a8a4a4318986d80d49e3721a3b90db104bdee2cb73ce7c61e6968d4901a531f9a96417fe6afeefd43584865023d954dc8d0d4249c489cc3caaea6642c67ee71e5c01f4f4c0b4361e9e38961817b03891d04af3637af0371add497bf39142d41945ea7a4c3394d870993236860b51ba291984b8cae177f8c4f7f3f49b90f670e3b7bd9c39e401dd5aa4d5599ea7b86a2125669013aff58c7458386b7f4c1e10237d5b6d32e553916b24cfb87b9f8a920f7888fb1c142f5bd5ef1e8d5fbebf3bcad9798e8316bf7550f1083c3e612d2a57473d7e4cd02f0df073e0b546b898ff32f7c1a705d088fc934f607ea5cc1e6991dc135685127d2447b227295c701cdde95bc51761622519f4eb940d8cc8e29578988cf8fc370a4bfb73a63a40247647e19d90aa75c0f7e028605cbacb02840e164b855a226d1576d44997de620c53fb3ba1299c29f0fa075c27b65ce7a44d7d5e69e0b8215f543eba0465e981ddd3d90feca0d961b6b607d46fadf95d629d26c386ede2f18af6e0e92b14d276e40e13b6a72eb292e73f0021cb3b6bd5c63ceebf6a95ee09df499adf915ce4d49d22e2fa9a175c1a7d27d6b12e3ccefb0406a0af2512ef4c2c2de304a5b4ddcfe2233544743cae4725bedc997f95157c8ec00648d431756e51f2297e96b23bbfe41427b318423bdbff617d07b634672b195c6036d56e5599e4786b2c07ba52fb5cdfb7f49294d9ec6ad91ed3bc0ca16c25314b464b7b2a354ea8a1b75cf10743a17d0c39fdacf5e44102cf159bc96a858ce2d7498e25b9c87d04f6bd528474c687e2a1e4bad2f58ef75ae8faf7f863ec73dddcd0190557a59d6cd6fa2a66b090d904c1e097c446d6d602cd29073249bcdb1c4f56ceb8a102119755148f911befad98e0a02dbf02778bf6ff74db5c43e5b519ca22d03df3a0468d1c491a866445feae4394fd0e22f371c7f2761d5f1ebd51e4e203f512047565e76e2bf5d7fe87f219f83be21267356fcbcad279310827002d09e4d209b35802d4e761406d46d816f4492bb72549e014e8de9220d1780c5a922609725e1f767af52d49ed868769f46ad5bf8ae928254f1008e2e06d769d4b786b31f2baab35471b9f80b43daa49a0e8643d74057f8f4e0657271ee579195fc71518d7cb7f06f8811ba12d72167901135c9b72f1bd5e2b5d6bd5cfac8f82b25004c211bc60da689ccdadb32591a461a2ccbbc9df041381031273751ec4e380afb556189483d6ea244774bbdd2437cda1547b640e7c353f5e22e37923bbbe595ec9f74854f5a8e131fd7d989750079915b451b5b5333d6ad9dd535c8b1af6a6f01c62e18693f5bb2f732076759e4ce364a3b0831d7f32c4332b0d2d466537c7233460247601641d30b8ae698512c4e7701dbc416a2927c24d29fb93a1c89a1fbd1d668f81bc1f4819c75580a4fb3225d44f07fff0be4c22f1a0cc508149d4224d5aef1f09ba1938184ceed804ca3a535a1fde0ace6a59704fee0e2a4c5f26ebf16a17c94a2d67808238b862e899229a92bfa1c01cec642436badeacde3dcddab1946753974f81bb89cbc3fd0ab0898451ab874adf56a3ea43d342b33fadb8e51186956b19ad31568789e0e0d8c93a6beb3545fbc79de4a440c0ee4f203f376f9bd3e31350d2c5728e9b7a14eae7dd2670d0ff567aab99bf4cf392492f420e63184473267e4f03d770dc214bee03531626b66244c0727b2557c78b2df079a07183bbcdf0783c68ef42abb832a00cff9e91d98a0cb6d8c645450f327d6127b14057b08078bbb90a54ce6e36536ca7b2ce2f7ecdb966e6770e84e723cc4de1816630ddb7059b0d2ac19a99db28034eb8701d4135300bcc13a83a5e968f6c33e8df460a18579fb2ee60d9cecf6fc481e68658f7bbd7550b8afef8eb5a46da173498d5dcb735f9c6f728e002f7f9d02b8abeb1dbf0f08c3304f51bada0944de3bb82589f83ca09382f42a9525aad415e0e177d1e54bad6b2cc1d3d1f32fba3f61cfffef409adbb186295d85f10affa68b6a27285ef97953cb95e899f4f827d75cbaa4c0c5af7079e969052e655a178c6cc2d776a597dabd1902358bd8533175ca733fcd719c4ccd5554f4400947ae009e1a3730d3482c27aab75cd5a377fa907f1f7c19639def1d1a5be93145467b72fe20b96e6c0ee7e107331b70b6d51c113b39230539dbff507110dad6de1751cf51a079988dc2ea92d5bbcf4bef92d21768f375d5f5ae494c431b79d01cc8e54a0dbf588f69e507172a7df6eb8660d1bdb38e723ab12a1800b9cc6e0c680e08f04b160fa9a4c93f9a3af9ff8dbdb683f580e449316a13354566e304da30cb361f2738390cc5abc2fcc382d0256a00be7addfd3cbb0fc961c202ad6f0f50f0d75a0859cb446b9d1e91aed27d29ab70389951e7ab78cc8cf3d9603b964c4ccc48dc442ff125b697323d4d9e7ac224b98f64227deb3e629e25eab3ea9e019d62e290364dae0ebce9a005e74e9ec0bca6a6d1ef5fe0f81c713dccade30b100865a08ca68fcdb8b1e92a65b737624f0a6482bcddce885decf1a1e115c27c955cbe6491d4d4d1372accc41484f279e0fa447b7de87130449aac39288b93fd5438ba32ca8b3f853d3241d3425e71ba07eeedf53643baa24b2a513941382520813ebdefc1b4531946f80f9f0e5292252e1626d10ce477245cbcb5e0957cef9b1bf3a949c3e4ea6d7892424215760a226c52990b6a5ea563c88bfb02c80fb55119d04ae632f36e7e8cc2003c27509afc4f9759fa48abd23e7ca3cbd217ffdbcf015a5bff6756802e9e1902c05113f6ef8055675307cd602dbe10ce1a0ecede36155e163504348f5111c4ec0e922e5239eb45443f2c94a9b983d2ea7db05d24d1c1cbfa89a73918777603b813fc6edf458311124ad4850fccf9468dd8316df7c2f3c216315ca739dd5f3afdbb70ac869d45e4ae9f338eb82b60b6edc0b7d47b45fe4e4e0651264ea30d7c92e85ff5ef39c6626c0806add2a2429f06e6360deff5ee17dcf711e7b49393cde56c44e00bf7ca6f357a2c7c9f9462afa6a38e9680d272c743a063f3b271bca23eb96b80535490aeef8141053d386b0aa96073ec3a822bc5655b790ba893e5cdcea16f4680f47c7a0032952e90df589f5a0743091fa03433494a7627a3d4753130b3d0fa60f4c5a0b87e0e161e8057676eb1a43df3d853ad16bc2ed826743e5ad73b64e69780e686b247a65cf0c48713bfb2e2931dc18f1c89558765fe41ae0350bcc6ffe150bd986e9604af421b4e647fdcf7a8c48f4b8051965f7593074911ff3601e1761f37f344e2bafa0d23ce6806c9e576a919df02976bb9d116b8d77dc7ed3f21bb057db62466e207bd37b2c2f5d2d7e909db641c344179d037fae513884b7148f52ea9ca530b54c0212d5f3f72b168b397aed9031d767754e14a07fce6a8748d7f4e561da8bd2facc4368d73fec140ac6a42f4cb5954882984e47fdfab10b7568913a16dd01cf925a89bc6b6aa13f26089be6d8b66f14e6616cb65acdc0e8ccd3a96fa9ec698e0e13a803d55d38471fccd475108d33655d7aadd734b5a141ac30cb7ecc9150350d14bd238a523e2a1a5dae466ad73d2027a21ef48e854648794154db4ee633bb4976d2d55041bf7b0bef7e4baa9cd7c3f6328c85daafd93916c1531f5982188a93840a46b4843bbc858443bd37d445515b31950048dd30f85ca1b85d3333a81337f55bf80961dd3bcbcaec0313cb49f1c1668f8f60261d0c0a0c6c3dff27f453ee0e268d27f21c4f94d9ad6a9449807c33404debb8879038947a633cdbef15d1727bcea9e7b59475b1b8f9882262cfd3a46f7e631dc196c0ae05e93df82cef7bd7a5239de9cbb5e41ffc177e16d5ee5b2b4f39115bd6b9dce12b8637409bee30cc3434a90b59f2ab7f40f8dc7cbee56ec3965fe2fbeecbb8763b424ccb89c05a8e4e4da7a265feed9248f3f8621c9dcb26d230f468019f003e09d32ffa1468eed8a2dbbbcb8913807be8ba6d4613f5e88043d3319e855196efb9cc846307679947033387bc7840a87b430d7ede2baea9d71402cafc36d15d7c11512b51b2aa37e99be5762f351bf21999f9aaff658bb4e696aa58dd52549f8ced0cfff384d9ae93ca7392f1f3e9378a632596c7e1c30c4926c53f18bb9894f5ed8520fc2aeba6d750cfd758b20fd1681deabc1a73564d7871b71327de45c4d9e2800aa54c65ab6d36f1c3a64f39d5e791338e0c2dd8166d62122d8349eac17f953e44ae14d38d43e4b51f9d0664caeb999beb07e28ff73038976a687a14e53abea08e267cad4a9d749aee8e8760659e26c24451396ccb2ba608619013a4f0c9ad6f745a82d39833f1097b97fb4b5d7d71eb08dbd3f2a8726424645268b77ce35ff24a368ac7145e7fac572aff19cd3303a07f412a387fd63fe1704b0de51b8cf24de20b4d7952fa9525fb50da926324e31c448538aef1b35c045c860f969d3af3d1c56323599f71ac1c353bc19c6c6cb9c7fa386863bf111ec67d34c3670d150c73c18330830c4c0f17df464a29df556a3f522a5ab0dbb1adac5f19a21750b2d128e7ed6c34c0ccfb5e29a71b96d6b163b447d835d672bf2ce422e93becc1e2501636072ae2fe11ee7f198bcdbef04a0b7c42d9cc5520b1ec4d7e4fc6d224ef176df22db3a747f5216ebf052d2d1b4d1a5fd753aef64fb136aee1a11cdff42472d555798e81109ca2c9031b8bc8484f4fb9026f53f07ec1f548d0437b6f8298da93e90c5ee1ac2a8e3738e19bd303f1595da57a7f9ffe31c18758620c2e2fe495155c079168c0ae5fa3ecbc17903c763ef1cbd55383149a158a35d48502bf91a533de097efc5cfd43e446e0058671149f69aa17ae88062dbacd6b6ee24da7c3a90eafab13d8224dd55878a1d17091f2167d6af6f871dcc1f60bbe2365b9849e132251644fec46da6cc281ea7f7f3d56f073644f33e1fe78213649a43aca3d8368986fdd8c0066077d35881138d79797e29d6a7129a8ebfabfcbb278e968b0f601a001b3cb14055268384f01174896ea7d8a82cd8d36ced548179683b0cbbeb98a37a6b67c33964d1fb0db1e2542f2c5143e71d8cfb1bf616f7e2e1472f708190598d34e8b392fe2522f39aefee38b2dc5dd9253e531cddcda61528d600000194be798e82424648750d3d9f2681d715ea3aa5f5d12ab39ad9c5e4c8f036f267b9f76b11696c9daece3c04334b6a0355fa89cd151ced1d3c6ddfde594860e22449b47087d3fa634522ee998c5830b0451fdb3dc985ec899e78c5bc5c42c36cf17df34c67473903f36a6fced31356985203c1937b58236bb79848b7d2daf95bb7d77b88f413533c8fc493bfaa9cf631405c791c07afb5ff8e5d003de72f2a8457015dd9f8f29944852579e2796f1d3834bdb621ba0a13d914e9a3a700738cb2413802796145a7cc9fa331b127681d5702ee369fb87f7c82905b8cf43ddf8bd5eda165a54e45c1ac3a4a4ffee72be93c4a57cb796a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
