<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c0d1b8e48015316dd59467824a90bedf38e789189bca8eae7a9591bcb6e588df004ff3b0fece0d14443568f3bd62e13783adf4d5e7ad631b38aec43b1d8ef2e045fab7c40b7d9a13ff0ecb6dd568a7903f18bc08b26e303dea458c4f0a1ca617991579cf4005f7855d212f8ad06392923511a9a7724e3710d075978368d739b0a37d0c9e3abcb55a01c0f6d95fa14a9d32b9a254345cd90067742a2f2959f2d2ad63447ac3e7ca46854501fd72fb0f028040649056bdad0095cb73aaeefd171a52b90bdc4398abad7c1ede0abea846ac4a3ea71547df0d084951d375d690af67b0bb97e7d70d40249e41a19626893062e6c0a1c15d52254d76bf95a5b076fcab84a4a562d6cfeebc329c2e41d4365459714c499c6641d3222e3cc85e30016d83799a9609449d357002e43fd6fb80a95fa0cb2413911da4c4f5415fd6186b83312895f7a3fd62cfdb3b1889ce8d41be0488cd1d39eee523939bbb67cf0e05cecd7cf43061203435692acd606abf265055eee5ba606b435545a5498623f80760e66035171403430d7c00d2ab025857caa649701ff76b91650790fecd741efd8f42860738a55ae904cd0a3edfbb11c44706454e0a68fd4c2a779f28f2e6f6cb99b621c5a3960547fd27107d042896dcafcb7d36b123b9936fae6df3d74765e0946b95dd1ea7a64fe62330f1f6c12e53ec913e32a357d6644ade626c09f55c2e4f8ece157a8cb8db2f82fd81f4f086e549104f2905aece282e3a4998bff5fb84b54abca829f9439797ed7542b34e6a17a9c2b4cfc91f07bfe1519bb18653652c501080b059166ad325e906f8ecfa5129a873d978e1918b1e97c76201bde4c459245f5c9923b9991c3e07cc25a91b95817499ab0fe8e6e6bd01fc4f597219b92ebb79a1ec342586f81d146d852e9b9724257814c411c87c6bead07520846a629571dfa9c730fa3bd9476b10d0d06f035b93ee61743a7fc594f511f2609d29c291cd6ed36092789f04ade7b0654da18f904fae84f6c8d9a7043bb0bec57aa7130df49c8ab82733b01f498134d99d983bf3c185d228e4078e85794aa67692e633941a8823cec68c05549fee09f10336dbea7df4f740ebc9e5db542b385c0cfb7a94fbc83a6dbb860d8f6ff3c8dea1908a0cbb25a3a3c891d99898ea27fef803c21cfcd929611356eb05c58d65de7fcc37a809908b4ae11067c08256ac41ffe496df2b264d36d4f74fd65d7c68f3ca130a28f8d61b728f5575d2eb2f04c64379c4398d8f81e393083f7a4d2d6347190e57c97fdb310625c5e0189f23344cb0ee584441138c4cc441e6b5b8ca69fe0270cc42c28834dac0e2965fdc67d23231a1d127bacc9a09c7530d8a1007bdb4a8286aed22d1fe16271d9ab150feff6efc61ef02bb34c9a13908af7259242f7d5a9208a516f88a0f21abd0dcd03ca3ae91b4407edb54163274046b2d4c8399efac0759690ecd57383bd9a5facc34fc63959c34304245ce557fd56eff7f113ceaca5fc23cfb22aab316832ccb9a961dfe7ed782162ebcbfe3845836bc2adbc55b9291fc2045e36501294499215ab0395fb31f652813ae543865a63281bf9fe51e16f5c720d260b02c6f893330c3fb4068e58f8936e7b75c089809ef6094f6596d48cbcc1d675ea66af2b75bf26f9e420bd82dc5f31645281e15049653bd1e20f068b3f95a8b0739d08022d159005c989f1950eaaae63ff92e1ed1f854f4c7ee7c30b8338ecb8ff8b57a5355881e0e6e605afcf2d72c8a773a3679d4c8c85684689d4a3a66adcabb76266c80698d1d8a4b7a5020fc61a808f3fd3c00fd96407b2004b4971a4aa8289af9f37813025cd9101699ffa72bf87764d0cac8c7fb4750e73fc478d1cd7f1bdeabbec565b188e3dab5784cbf8ce4817f91efb10a6fdf73b08bdba57140f57dde75988eda42e5b26d09ebb798f7f0ba4e5b5025237f85ac809f1926f43cf864d0309efec492d495dc95a955c667ddc402327d52ffbd645be843dd55b36b8e879c870be4d019f1a3e6557628247f6fb4574c8114652ac03613e482b0110da849caa94a97b9a4c494ed28f08356d8a680144a97cd94036c03d1a527613b5836b296626f3144e28523e114a3c963deff80103c23bfe857bc2486d7a0ff381c70e6e29d795f52efbff2d9f4a56d85767963b7a888d0853700d43a2d06f8bd6fe538278a1dae6f5f6784cc380d7d227ee1cb51e7bfa9962bee100b81da303e5d79fed249f294b046065a8b7bc2ed36dcb3f76f442d3eca7c00bba880714a242c85615ae98ef4cd0c0eea47fd9359508af7db739910cf098b19c3f0b7c30494886c9162de96fcfeacf9aa7beba1a422186b48a177820e7691b93e1ad6f68aeed49bea19d6c483335c7ec33b2161263f347037ebd0d6f50c29736b3363da8de04b9f3abcb6fada596c2b04101a979101e6c314938b09b3ba28d4deae9f145a12d3d848b731240b0e206cbffd72a68e1f269775a9b7cde28946c34ea96aba35083f11bae75c1f83a3151d0b0ebf9986f22e73c33054484821070d02edd1566bb0480e231702c3d541773023d137a0f43d32a9f990d52c022af6aeaff6da7f3ad0cdef062900c876ef89c3c81626c174c0edd1c5f73581d54816a5ef1ef76a751decd636e4f0ae8a45c6aaebb2a230fa036bb4d2a03bae1ffc4860073a0fe8f9cb6391ca6b6fca6caa86e908cc7f714c822c9a81b3df75ea71819eeb0393d7e15b89debffcf02fe8e944ea27f9a9b5aeca945a98f4a20969f31a720c52be5b0160482b0b91dab6925b3ed6ec49f0c872a4ae159f4dac6d1ec0f813553575685c4a167cdcb7d5714ddfc7a48dc6db9eb99a5fca011bc91bb62fa6cc388a9652b8cd581553146fc4c727267492c1f65e7439e81f551a9ca9592c742304475ba92c33dd8090d0f464fcfb6ed9e2d6e0c3d796ec55861882c81920cdcc69105e1621c54b3cd357a1791d899d59423a167bffcc9ff67ea67cd467f861b82ca72faf033779b11185747b9c06602301e798b145eb3606b5259b0a0b336454c6b9adc432ba18e06fadef17e9a0bbd81612dccb8a4c0d06b6511d6e3d00d68161463d7efa8e668d16a5dc7eb579e98cfa75ca57aa947dda5b99c94d4be499326586164cefc5f7b44014782247adf29e1d72df92d63de63ace94e303e88acbea986d07443fd910cdab6e25a9930fd878491d7755811209be7fd45dcee881cc8ef152319f243fb294a0a5b1b89a6e55f3af4129ba8d3ef1454fb3991ce5df9a51ba0a2e248ad0ca54d08f6a2aa1986affb85a16e324acc0fe3305b48b6080c91330e0a2950d8e994c54c5d6fd3a12ac7c82e727dd5b2c0525ce01025e7c50eccf802ba2a692416fc50278a2e33edf74ec57987516fdd6ea7a058b902b8bd06c32fb591f83d74a8fc1856fbb51f3274a8ab1ee1c4cba19aad9a56d73ced1d0c7b3295f8a0d45495dc0c52245efdc66e4963771fa84ce5259e776416406770dc9856626e25bd40634d8d4a0f22373e56db83f4cb59c142389d8566ac832ceb87ef565daba6783b6d0dfcd5ab6f5ecf458e6fefdc87c797eeff9b62ea1d1c978503801e883ee2304996f318b0501262958a9ac996d5776d41201ae95f5151fda35ff505cd3966ac38ea89b989e7cc41870c29837feb6d81ae455d47975fe92508eec22a54f5187a1c3c99d41982cd66251ac6d164b7c80f35976b6d9c0f1a62122dd99102315ced447be09161e15bb55c4dd4a28eabaa169d68f8a13495a3f75a7f2faa1f8ce05256357a55a6f731fb5cad35540093ad18f0e2d371be66cff4b774e05a32ac82077faf5b453d0cead37fb7bc2da4471825d35eddc5561d6841f152f55c490f24c7dac97edf2764e6e2c5da0e1b7fb4bbec90735cfc8c706b5171129c78fe5c9efbf68fdcbf4346e27df92183e9352b67d5449753622bb3d35dd72588ab827b917c2abd0f0f5b609c4ddde21d634cf689d57630a1324a224669a545b41c48ee165b39bf1cbf4fd231db33209ab05c64bd235dbfc07008b91a1ada7a7d1b2f0a5ea4d9fa8d51066d67b974b1fe6b7843a6b3dc21e5c625e8285d209628c9071fe7487def1f65b6f9eb43659a33bf8dc9cafd1d9dee7416898eea8dfb29635ad47ed1576d7d117c4f2601f4ebbe1a9a1dc4217101a035a67dfdb26bc730f5f1efed49986d399464e66bb8881328f559e7e2eb405d15df57235feb4d5d697c4caf977a228f69b0cbf9f6f1d76e90fbc77e13e1da7af971f912d58f75684ee694ed833e3ba5d6c33e956f1a44d264a15f80b4e932f9503d95b688807af48c4f4e3019c85a6f5087c01aadb2c1229cdb786aab8514876f1bc2ab87148c424836eaff204335b94ca98d4cd0a79152932c5016e7c931c9c9e4f3d0cd337fce922abf6f9316138633acc27a10e520e5ee5f07d48c1542b0ddf44cae49705a20c8f0e2423d6db3f798109e158019269af656d04450d0f9d05f99f458797592a615f9079457341ef3152f6738ea300f693ca910c933113cc56e599855d915c4eda7f7b607a6bef927af845eb767560c34e6b06ba386573483ab9acf77b560f16621ea018b4ce75878364cb7834382aa4edcdfcfc608d383926430e26249f030c4bd9197205255dea6428c0d4bcda9d107d1d59595a07e701d5d2e2d1ef67f2905fd7587f0df74b1f2c9588668f2c8d1a31ae68ef0c33392dd2c07665878947a459eb7c6294e1bfb19acd07a1bc8afa8867d0fae500107d0d687714d867cbd489d7ec99d5be9b9aa28b1aff6658e9fde7949648a933849a77faafae4de3ce50367c6fdcd2d3a9b94732f03bd51195c72a4728e8d009df3623343bd8b13e93ca8db7f34a613520e7510c338258bf66fb1a52c44e348ae620be48f7a1483f016ef0c39f9ca3459b727de8f047ac531e574d09c949387aacc5ccd3c97786e75d0552a0725628193f709fab0a2e69fc39687cd65f0307f0609b77784102c9a1966076575b336f33d0c67839f037c4befc6ae5f73a28145ae42cf5182cc1079c4f27a57b65ae159549a69c9160a698f0b3c0ee0b013cc4de2fed579049dc2881eb4d6e47d2ab24ca3fc6038efcc301c0fb74930e326aac45f8ec0291ab4e9d37ac33d3db668d1b9b10f78be3d72ea25e20b458a7d7efa2a03c325c4240c40f457b357e12ff136ee510e51cecb9e50bebd0dec4186a0aeab59a07790fd43b9a98ff449a137997c71988e80a64ee2d7e4d2bc3dc449938f7b99e3038d4bd902b01e6a20c5a1a60c54f4d62863ce19f34072732d870868f00aed82e9d1f4472a5f55d1dd5b030ab9d58d915328a8f4550e6d2acdbd991b17c19731203f98f5f7e645d91e73d0ab5b7d02606c983f1180f4b8bbb4713e3b4fc69ced6f68f1f81819221cdaa19a606e80435ab295d07cd35f12e17c26bc2aa8d283d834a796111ca0a122d0f5344553e1e3d3993a09b85c5fd56b18171214d2c327bc3333de734e45bec6484cd414ac2ef8b8b56d04a815ef8ebbe748f706b896a8e64f2eb4b73b1ee00eefc6256511239dcf066270842ae68fe343572ce441a93a3bc4e4df9fe9528a764d852765dd7fbc37da9f46e969ec7560d8d1f3365428108cd6db63f52be80e1bb6fbd7427cef19964b6e89feca960a12a8d84dcb77c8b5e43d79732bf91dbb75482d2f309d0fdb8224967fdbc3b0cb7222fdd2dba8f0d91dea6eeed92d5ab8faf7d1aa30ae7bf70a2479abd0c3d7975a6c9493333ad19a8a7472fd56cc6a830cb7d525726c38e9e2b5e395625e672269db788d15fc55e78b054e42fbd3f971f35c3a35df4c5d98a5b79f3e17b21ca64936f198ab87a132bec57f2998bf018ba5193ee686f8bb7d35101e6f09c9f279ab86b84170c19bb67a3e992fcd544d23c0976e21b4193052a8c5887d89490d60dcd65b30569181dc1f0658c4a9f1e9431ceed325cb78b0436558db7228ea514e90f0d120ab780425c27c9ff13f9bebff1efb22038b1fc5cb8a80dc0e93766c9945fa0802a587152899b9f9d297d94e8261814f58ff032e55fb8f2cf5f69166502d35977022250a05c02bcb391f14b0b33adbb13cc585a2dc09814cbb74c8ef64d4c5196f0170a3578f63ffd5e3ce530b010245444095cbd38410f93181ef2ba07151f48c5bb7cb3fdf3ad03f0924d5f1cb4080df52fbd160cfc37891eed1c675195b01accf2688db6254023285188c253d6f6949eb437c28aac88c400caa975f61cc15c09a2d53ed30d81fba83c35e1019997aee63648e8602f3a40f96845d0d9babdc5ef778cf0d029b3cef7ddac58f283ef1f0438532b9f173dbc40fb5edf69af963eeb769cfa1d133eda1b5c83357a71cd336fc0bf2670079c6e7a35d66fecd5eec18c84ff6a2bf15029c053e8d70dcefa14aa2d526fd8bdc0f82a55957b2bae92b22bde43da4fa682d58cb4e6551125760ae238c732eca471d0cd16fee278d8d5901e2781206f4ded7e7dbefbcf5836b3aeca079316530caa01bf963b803ccfbcc18d8ddafa28ed0ed7b61062fa6ef0e6a8842f0cba2d0e419a98aba11e3edb3b39246a58bdf360f4c1e310673750c920740b4c781d42d6edff1cf1b5ff01d6c6de3b5b9ce7a5e9f21d6b89763071227d417d216c1bf29fd017e5a38250d67353dd3778298b75e27447c12b3c6f5003c28ff9513ecd95e975d29f87775eb861d4f4949dcf0efd9e0793b2cfdeaf7cad2a64f45076d2a91a229c3962549da768a956d5069607023bed43b712b1ff5b57b4865a84fd6a891540bd9f86a88a1a2334e930556465b475e27637601502eff8535e632a80cfcb845ef6140591bb00b07a792b0c4c3a1dc1c4b62b20c2e7e5b7100e1dea0f6f0767e1939f8ae520ff271109c102f70d96c44aaa14b355bb5e366a4750598e5e5f2b1ceb571ce9b5ca5dbcd9f2f1dc90f37ba2b7e43b13b37a60f7ce8dcf21b6ee35c1c2616aa239aa3e4faec897d864f40a99464109fa8f9e99f911272010c18769689beb1597380513a8e0f5523379d1f901177b0964bccd4950fa9e4ec44f0b1963aca7eab2edfe98542641084e900881d22180ae7b8c21462346a92c600641c2204e832cc6b3c39b8a05bed5b35a11debe27b8b42d1b6cc1b6074d08d3db07612121f9014e3ee16f1d3b878872707f2b707c144042242bdf8b7c7ecfc8164a5c445095f082690973741e1ddf329f5ea767811965556d6aaef48e1216de5f01ca2e22a35143d7c8ca3bc7d81850876999e8c3b28e3f645384c2fd22f0093488cb12981c9690ac0e158608b64521667acd553c4e8c4fd2b65ca62ce321207820dca2ce812707802e673b2fde01f69b098c96667f265cab020b4178402cf9aafe44843dfda1ebbdc295ff6014a2bcfe341a44236fd73cb9f758a0fe4493ce1bd4756b009e9ce43f00618e10ebbdefc132da3e9a3d0bd3e87b5288943ee3e72fc855a8cb5d64c8c429ed04a7b2290e20c652bd305aac421702dec9ff8a635b7bb9e81896bf1da9eb3529a626e31a422da0d7d9b41fa8011270bd1c727dccb8838b3dec3b1181ac32e14c65c4e76b2c32aab5e53d7cb7702a88325122c09443438ff7f5e780abb8261c783a8f1d0c4b03f2c49bf6239e22564f5923cbe91aa0ed7f0710b09ab719f3d373e9e7b22d1031191b0281166c54767b64f381faab1e71b3c983a78ec6c329a9f4143b3b1b168018e6dbc6126e2161a1919d27245a9c668bffbe7b24e2f81c5e40eaa8fb7b16457d80332ae3cbd399480eac06257f1ed49e18be99d005b6f9587cdce58c92ef0a00b6f89d344a32a00711195fd87c6477e9a4c88dba9a03064ca77e8ef483d504be81941db4d0c66c677487478025637402e6f134b8f84c2160e88bceb82cf898099223b19f98a161212c03fbeb182694a57a2f2b37c9fceacfe9a82dfc1912780b6414314ba2e23353ecaac2067293def0167b7ce831437d1e3e48b0c9fa9a9bdb2ae1baf3833c5088d2c5aa839d5b33f05de7ed6905f60138a59bc9db866b32062f0e4f680739a336133da217b8216738021bfbf4d4c8c548e9a3ee78fbe936b654d5e59f9e59f8ad5ea307671801f6fbb17fbf62182a387fc7715e37059a6a82560457a5e0dd8cd57ffb0e05e6db8e0115ed816592437742ac59c97ef8f7bafce3ce3c8609e673d3621819aaa28800dc49d984f7fd142cc584a6465c27e605a69d038cdfde5f8105c21cd9cf2a48805c0efcede6bca4c13acda09f11c9ec51fc7e2273e8d992cd8f6a7f9d58cc1b4361f9aa9e981a8d2b01ea1bf097f070816e430f8f1dd17b13596c095dd1202d118393e9b1708ac3f1e87692f66f6f6338b925c988fd773d752e86c8a6e0551e9281a8e83c36da4a5a7077d128d547043af51ad639b40fd27c9691bc439624d4f603d1145860ab58bb8fa33c6255206522ef7f574ace5fc320fb780be898ceec2a4f2ab0b6ee84b2b2d1360c4cf2cb86d3257e5a817c2ff8c408967a93118bd2213394ae72808a4de0e406cd57d650398e02d22fd316a621a51e730f1d2ac8b5682138fd8f2f29aedc8217d6952f276b7f3ab97a6437463da9cc218b1521c5d2d7944b48f678a54e5c214e0f4734b0b9889ba60d7058b53f9b996a4156325b4096795def698ac14f72b7e93ad273ffa34e2b00510d9816a75c1553705cd97ae0824a8ded49ced148d7fdd9e24c965f5ee1155f9f6332ca79e50764c57034cb4c118c25f1464aa9f5368b7a1eaf21b49ab6133a096a6ecbe51a329ca98e3e9ccd9f5129e21d9f5ab90b9a831991caef9a1f40be6bfa1a85fcc6e7cdca2ae272b776be1a8589a9207c49e6bcd8f6585cc3851f9112ab57e4832e475ef17f0e12725def290a02b048866ba078c00b1a4fb6c8ce9127d9d5dedc12420cb0d16cb651516bd8de2c0c05ba2cffd5ea3e314e30082b2fe1896b37963b8e9650b15096f30dfd1d50337766a5c6ff4d9b8fbe6f8e0f42ba8e0bac02a3f9919cd15fcd3732277bced3199d8979ae23fdb68ab350c2e603c94c9f900c0ac31f28cf3b2f15417e60bf601db81cac9d5423416f962db4273394b3a1f014c3f5a6984b2ee4f6eae1719363f72b106ec2b4bd61c100595d21469f96702a93029c13be7d3b6e3b9eae51aed46e6cc1828f63ec348666851d3c64a625eaa87a5e7959a79015969bc898f44f1410b8a399a163097ff3c593baf429d1e927e71dceb99d51593f1f8013e963a3b634e892ffe7409028f579809badd956b594a44b4be74d6e14323a9ae92ee1607c5343d648e5ea89e09bc277c710604f83bf705cf908666358822af1c7132882e088d51fc8310546ef094a1c58aaea24e369a7d970abcfd6aa19cbc6d4094f6ea5f5b6c1f3b4e5a9acc273cc99f18906dd29d181c7111066c18c4624bb8cb65c6b3cb8d3efb4fe9ebe9a2ad8931034061c29694689a492e89ac427bcbb12e8bfc9d0c2ca3364585060d0dee0f7b88acab424bad2b7dd4dd9359461b503b72e6b7a74a8e029548c213f60393e308363f82a417b26b06a60f6515d5e9703b43f821350bd0798e09f52ff9ae66d1c1ca9c86129cb087a2a31ab81059c590fc1c510d8580a7059566cae8be5af3873fc4c7e2752d5a5c29918b3312bd092d7149e539cc58761d8811654594a8997102cf368cc61c63cb2480cc8d8e91c42517f0fb66813f5c1b8884e74f46d59e4a51065b06c7465f4548fba0d8182f6440c8ce2cdc6518730f12bcb971517780181fda41c84ce54dcacc9f35e9ae9052057d170306fca4cf6793ea4c3d7ff618b81cf2f464c0b5687b265ca8efba1182155e94c6c018e8c8ce79a7dc5b8f57276e8a4653f04ec4e66f5cc128168ec9cdeb536a60f0869809dd209183025d48c1f4fd2498f4adc2da8409d98898513aea65f1dc13bbb5440509862321be616184f6055766bcab5830f0c43f42a39d3b17faaffafda7e32a7f8293857d129232b175942a3ab8b3c241471c3a9a549d1350f3d0d6193336ab16151232271a7bdba58218049451bbb320cfe4594f5769519ba553944cc34e465c46157a4f7b6b1b4eddc09434102e83c59053216528d854cd007636a6fdbebdabea1248a2f73d858753df06bbda6b223c1f9b7ef2d8383db25e282b970433f765fe485d4b24f1871e872de2b1a05f7785d7917a27988d9656b2137cdc61a75a14289d05543779f3ebf6e847f203cdbbd1ced9512f91356564034e4757abefe5186551e7d4a8c16b52ede69e0042d0aa09de8c7f4bd4c4aadff91e0d72faa33c3d9113f22e9c423e9a6fa895471c4880fc46e9f61e9b6d3a0b2e7b17730c3449849579f6f9f3a204ffce86eb3560736c2cea307cf2436894d14289eb3270f20dffe36799f1fcfa8c9d75f2d490d809fc57223422899fcdeb513bcbfe6eeec020b2edb9f274f2bffd253001fdc13aaed9955632675d0a6b40e251e9df782e8fa5b4e2cf986813ec25bf9a7e115a2351d03b1f55ad3435956c8f97a24b206f93e36abf5afd357508e8e8369dbd57d60d42efa8e0c8622fc012da7c33b76aaea72e7da85e3c459225870f6f1fbb350627186681b16c8f9d5a7fa8a98d722aec4376080e20d606b9474b1ba95f9fd7f539da28aade36f03dbd792e5df48ff72dfe11319f5901b6802ce0f6b0ff640d69f7a2e339896639971aa2e21dbf2f1180270cd6b0635ebf0d08925209500559fc98be06ab3be5bcbffd9d1835b4c2764d8faf924172825053f1bb91c17fab208ccda52892138123f0808222328aea6e7eaa220f3fb8c3434839d7435319504f1e2095d5a5d9fc6b0b63f45836af91adbbf8e573a0fd9a1c8813b54c131f6d58d4cfd9996661b6854838d707664edbc5ce8e366fba20b5c4ab73990926915d3580e2401a0c7765068c1e769db84be6d06f2080c72c75160a22888c04f7cdcdf372c07982c1b88287a63defb557993f1087d4ab8a5eed25161fd36b3c36a6fcf33f06fc0fa7358f9a1a9edb4eaa6772b5a8e35d14672ffaf0f6e61d6706db3a23e0abe9a6df2cfcab50960ff268faf2b6b6b76b102f3d0716d04270f952fec14bb9236537c2e33fa33d31a71511e96d24d9b4380d85053b4f98629bb1d1fc1ea3b2e09caec3a52426d1a1039fe3e6f8d029e3894240fc2b171ae50957e260af099cd99396cbc9a7eea18c621b8cb25c8d206a091f21996049dc1475553d15bc428b6201016dabd2dae88f908eda24e6a637553ebed7619302a23bbe1f152d7884a5a9e8d403530b81518ddbab10c60264df8c3caa9612c9049de85148e19058e27cb090b072fbd9f4f4bbfc7f49a2f3599844a01fd0a289e308ce3f2b91c3fe1a35d0e9aa0c875e5f7470e695006992d8bd76751864b7e37d9aff92455e1ef87e086dfd81ad1bd5e6a2dacc77e3105afacb680fc76ae134701743d5b118d222dc580d1d1479d2ace79312144c85409e3a5a1f64e5423bde2adc71e266e76d0ef348275a883aa6b5369cc1a7e9c497eedb04eda2eaf900283e191548c2034093bf35a0412f38dbd112adcef14acee2cf9f169ea6a6cc9d8305398b17521549f10e08d9d8ab62b86bc9b723f83443e2917ed8ce771fa86126f629f2254938477fa7a1dca2f5945b172aad199f4aa69ba612571e78ec591f4ce02769ce188b3363122b9415c11ff6f1e2c0ba990e3115e8ffe181461690fc5a1f1aa810a150ad414a439330012dc90a7963b711646b06ce12377591aca428fc1f620f61442578ce824f4e59c6a22b707ff42bb79ddbb86649bbf64b63c7b7b6008b79098f6cc818a48a97865a412934fc6273e78b52bf687d2f952b84de9cb653f504abd4277b0e81d92cee45c140396191c14637ca150bb2d90ab665cd0a9e393a4953b6881142bec7b40e8e9123b1a091081d4239a251c852b89b1075052166b33719860728ab588672726775e875cffc4422d27f3d14b5a3a2f8bfe958cb478ad867e8b279739e16abac42b44de5b5acbc6812ba0c40bd0751ad5dce4633f23c035ffb0f732eb0b85bf2c37b4c237d69de625d677de58d59a11023c1d1081524b067ed0c451c9988cf6661cef317a3708e3bc941011f93db2e1f5e142f5db834cc260bc953329c18dbf498a7b57b3178e283cfdcc1291e02680c9aab537603d462a85abad9ebf313d307d928f588051473d0cd37434e14cd954dda3ccc71856a8c47ea5c3bab7aa4c3e53aa09011225962eda7c473630ce9969b85751f06fffcb1023f2f8957a85531ec1fafd63e95e54d9db5ad56d1a438a72e3164ba105d4b688cb73911ea741f26d0b507849df0a22fb327b69e60e8512ffe18ce660218295e8f5e8c1e7cfe6792449240a9a39203a14865c98f9595dde452749359419a7d818544213b8e5951c7681e2fb9bf39d20aa5cbc4a46c90050812f78e753a171ecf0b218e2470596f280dcb64e0676a88fa463dce89780bc1ce2512e76bfb037bb34fe93ddbf53c0eb84d29aee3e1fb979cff5f7a70be1de4a50c69de2fea51100041c1bbc281400cb57122314e0cfc6bd52700152b2580ca33efd8a66b965e2e6d8f3bde29ecd1e739fa8ef930b4b5e4fcbdbf0f11c117e2499b3f07d44ffe6a9fd423e939b8fb8cf3b0f2f5594196fc72b36e4906eb76d9032820295961d9a1d5798b1d74cf1fd24b06137e3ac38bf0daaf3c047c9dd8301098d6bbdfe0b87c33df4566303f37b79a675f61660d17f8c7fa4cc9acba0da4b0e408b916395ac0873096a428369777012f55539526022261de4754d47f41a2129225e818b390a7c65cac240165d9746a278b4bd0cf2bfe916dcb807cf888142ab58635dd5b58855e0465f7755522d05c415e57cdc854e53360125505508249a8ec09c21221e97a75531265f0937977e847745098bf643db7778a1fc49ae8566f2111514d1775f20e35f825c05c0a77ab9d0fcfe229a419d017009c24e1143ee61d40d771b24cfe5b50a1898b6a17e133a1eeca6f46ed4c6869e8747be14397212b0b240371e5a28a25b9f3b167aa21d6b9c640cded9b9cc7366973fe4e5f7bdf680a88234d8b7b0313d51f1ad9ff5d634789aefa20d1b731bf198bead05242c083f971d2110b80ab972237d6743b88949ff122aef7f8cdf92329a70ab84c7c27c3365190c136348dd5b73d09fc1d102c75acec68d4e7257d159b095f1760a66e9ed4bf216e4339c7f5784c44107e6c9e1e75533ac7b8c3e9e36001ea18347c86523159bde58f019df7ed6d3cc59b145e973504eb05dcd77f9a7d814296bc9fa96cee5c9a7caa817b186523afa3407f33c5370728081485007254d927d925ba7b89887daeeb4c3be3b862532edc2b82629e8cc3b93d77b7a4ef9433b4840c1eb0a99282da4d42b60f7cb4563cfffd9c7769a10e728352559644456dad2bdc7269509a8c0ae9f46f49d33ea0a448ca5a8ae079eb3118b0b9f583d7aad939beb0a8fb61ce6d6c90180c15d633b5234056d0c514bdd1ab7079d7bd9d1eb481dce0a4b4afbd39aade50c095f8c3e33d8daa4525bea094b661ccf65b33a6514602a3e0ee60914f1eeaf75b345a8fbac24f9ff33a6dc9d1b698366e6cab18c0edbcbbb9d7dc2d3b9c006e0a0ed921f284f7bd5be2e0783fcdea565ea79b0add41c40beb3961207549a539756ef28e876f49d51a0c6c3b3af9db91bd4d483382e36887d72ff0665e678e22466f4b9ce37261be82de13d0a310ea1fe3e3cc3107e778a9c14dff3ca994265ffaddac8331841e459d1824bdca174f1e62fcb23a3ec5596367dedd567c6d9df90aec37758c037761196a2761c6c137114b690cbde8c8716b7f22fcc392f69eacc0a4c0ca339de98c893c966da0034693be10223293e2bb99e0a0c6cb75e01efbb8df2dd367269bfef92b2943bd81e16eab1b43b9b41b23ff5e97e109145e7b01293f23c3532b6d8c581bbf7495acbf3fd943248efc2d3e7fcce37465322ba1dd43014b6f2da41c568e69762aa382ee62d26534f68abd797e7b383af69b512dd851f19a23fe8cc3d646569705076dfe312fb97a48ab7eef880ad740cbf9ce1733a1e9a12d34794c7287dd7154becc7903639eb73cc8f7562d1eb30e6bd92466ee921c0b641afe9c7bdcf7f79373410f3c587c4c99ebf52e22de23d343d99acd79544b3a984a395675221245b8a8cde32baf2968a77b321b3723ca8b0c276444b3b488e8cce1e30b4b8670ad2bde97e3161eec2cc471cfc22aa60e25b874446c303d36257c9dfc74c1375a94c450aa897e9fe279de6400fe6e7c9684ea295d30ccd7c5dab22a0596e03dde359935408d0110ca3e6819d068a5dc6f20eda4ceb3a07fc018ebbea1e3e549a3ffd9bbb3a19811592f90e07d6c4ff5f1fa64b4c2a053ac389b2303c162f2c6365226b4096a95c716fedc7b33d5b232572949f7c45effb33782c6fd38d2fd9e5674e6bdd70a87807b67f3ae3af194519f6475bf023198c316819f921ebb7540ba02bcc571c1ba596667e34cf9a5cd49649e9492e7e81e48b8b67721d4aff3ddae636a20ae7c22f99a1dc616ba379af8838d1c3574e70f6d025a8b66d01cba967f45762d32827b1273c8ff50f1689d0672f3590a895af40a6ef2d00b94ebc5a584a071a2b468ecdd3cf6f7e9bc5bf3e7b3b0478020ed54965cda7efce56564f800c2a60fe5ae11669387d3e352ed830fea87cbd8f009126bfe535064510159301fb1c3a858c829922179157b42f71e0639f98aa44c0de50baee0d52d74ffebac508b58ad080b66b45c58450967a8330fe3843a006ccd5ba54a52b217751d8ec090722a47473873e0e78b082ec977d815a37b29bd7d36085809696cbb6d37b8eaf299d42f29e2287129b87822ec60ec86aaa167cb697ab4bcaaeeff004c01f5386f6bdbdeddcbcbf1385fafafee3707dcb13226650486532e77bc591e26586b3c8ee13ff3dc6f9ccc9365b32d651494b9a9d41168ab48ce5c9088a47b8cc9a692b1f5b6f221a8f042674177e7a75970bc0a35e6cd54a9efdd7aedb1e1c924a562a3805c6d981f42d118d5d9410818432a98191b6c07e093ad648784b86a53b2c11c934ef7e25d5284b22388334fc9ebd6ad380b8415d60c72eb5489c91fd2b61dc5c19c68a3427162b069868dbeca6ce72129d51d7a472326788d39de0ab5ffa6bcc3bbb6f506962c8bca4a5f2058389d152163ff765fa107340cc6555c9f5b45a05e549669773301a2a24b52d69ac4794a481c424a4b288040d4b71c7c4f65cb9792b5fa916adbc725d0b6dbeca4c553c815fb3101697986d32b5c908d00d30ce3cc7b3275ae0dc1b2b6c917a8b4743881d266fd3732ab131798c6729f2682748819e94a718de07f9f530f17f1612c4ca211ab9cac17cdb3a2d0197db37c9b2c5fb3034f6b98d6f8e1e1b3a79ede04908a33135af566a3d1a10db4827c8bd51d70df12c0987a803216d037d54bf65cf65a95abf173d4302a2f13d740212b2bce54614a8722413555defa0bfb34852366eca999142e97ebe2ae704a835fc445ac72adac21f648711ab622bf5833ec8c268355921d437300fd0a6ade50730f79a371a09d98f2aae810ff186615566797e73471084d948986217afd9eb985f1ad3b5ba4c597f9e15a9c088240e89c65acb1b4768ea2255d92b97317cf2913447f7d63c8295e1de2563f943b060302a2127fde818ae8e9dd5e3077623791eddc159cdd9a15af224ffe343fdde909864f5e8c2b52f70faad10f02c1bf5de9134fbb04854eb9e8350a983336d1d47a3d9dae8b864c4d4bcf740ffede9d46fdbd1ee9b9543fd4976261ebb1f55a724c42d1cdf447de9d90544bc97dc2288b886c199fea99194bfd214db488a1df2b2565fb2fd9b0f7e0e6ae3c94c974175a1ab79ab0939ca5914931b93061adec3b605b81c729430fd12d015f4b3ef9f237ab664de0aa324a97b10ec0097c0b052240da5360ac5793525b31ec70df15f707f144ebc4434437ee0ae6c9db440b8ad3e3083046da4d7715231d7fbe431daea8c0d785bbb7ff29a39e117a238ea8f335ccef6bfde0dadf95b047cb2ea09daaae58c473c8d58e5d10f7b63df6e2c6cf9c08fe51a6ece8c77e11611f53b532377b1c900647bb2a9b237c08277145631338e0e119764b157fc2d201a983b49de2a3c620c513629d6f4405ec7125eecbbc688c2affbbdabd7994c966a047b442f7418512e24ba011a6959a17d6192e72e6eb709d74d02d2913d1b15773ad965f410e4a015d249bb93e752bfe9c0870ffb47eb6f4eb732ffdd72aede9edf864b1633c66b2ffea775fc2ee5c2f796e879ebcc0b3c6c8e173b8b8a31dee8f8b11dc02d34871fbd0cc22b0ce8e1ae12c78cbd8f50df8c1de8a181113720d85f81de36ad2a5548942693d890bba0280e4a9ee340c98c055dee9d290ddadca6e36028f343216f1eb1bb7de4873d574e6bbe0f2680fc94f397df3d7372db30ac5a3c4dd82350e82e5bac7d735fbbbafa736e5757c10591f14423f32f917b3bd06e87ef746a9effda2eac9510f0ab38a197e45879d2508ac13886c34e2572b5a2a97e86e6f47078b3a7f20ab98a78407d66382beeb94dc226c8ed805409a27aa7adf8af0f758c5f06da0a65eed8a410c355b2c21bafadf0d4a3dfea3d09e4bde0bd213658a4240954a234ba364ea36d4ef1bf38701834a9c6c92babadcae9021b24d95c56a4a720fefe4d500d46962626a633b0f91bddf55d899a3e616c8857eef6a00e96a00cc5a94ba5f144397bab90cc7008d0c812c96d8d96a0cc7976df20ca6d44172d5d9b907a1a8505b2bf0430c68ec43a0259490123e65d00d7496037f65184adcda0089a97166f798f2d7e50e619e479ad2fed36f0fcc25e750a33e4dd81ef9d0a493df547f4a6502f63f325362eaf84310e3ab2076e6be5a37a4a307d281fe67153ef89af1d218f59c8f1646d8b141ccd229ec413b51880cd223d1478005918bef72d989dad6977c7ee0378a058997dfa33d75eb49a891b5a17c21efbe7cfacf1186f8d53e2e6f67c2b3ef2ecb82ff6f2a35edb4e1b9c6a32517f9737f048e1f7dfe3ce89976d837675c893b8c65bd0c68d17ab48fa0a050cbfe4ae42a986e13f7b9ca4acafedb5f25155e2880871e4c30cb5c93cb297b322faa0e18e79cfc6320d7c05b060d7710aaf2bddaa95c46d2747de4bfd78954f1b9b47105fae0943424c932c5bf0571c7dfafb5a9720439734c6d02c1f2048cb59703254a68e1b0d9024ee880aae614adaac7fe8ac795946a39abd4f50601bc6094177bd6ba5362181cf9266fba20b298302d5f07b34c596f655f00375ca6e53d24052df7443ed9fe886c156a02c6d41cae73bc4455132c80cad3b94048a42e4fea722188e3fc009ca8967058b79a86765815b413908d277f0308262c5634c5d0f9960f7c20b18bfcc0cde627d7c7c929368193936fbdc0c0db648056212e07baef60250042f58b28f9184fc6ec7af2b509a5da344b4ed7e13e8e61cec77ad7dce788a442fb522fcea92ed7b4c5fc219efa796045c370b292b053bb56f5e33dceb731ba672b292d6e2b8ef3bc705406ddfd16a873161eb8d48e4450e94710cec12f59624d69a6feb95e39dee482d980e1d78a4d3ea5e68d53962995549e310009862eda257ed6ac5c2d36d3f40c8e9216652768a0de26bff7ae3dcf32fac2a34d847a8f359421bf6e00077746539a49b3c1ac6fdc3d0a9ee4a6bd347a2fbdcc533d88d7dae865e3219bfc3a2bf1efd7d19a545f839380c89efb97132332d823023f007383c4f62be1bd0f644a9c90702a58989c8dafdb9d723eac98456f6c95f7cd42f633b609bd3a409afd413f88820904f16f805daff5c0308d8a7ad68f58d07991d48e9d00ba178a96e2ee26ac0974d9ba37f233d88bfa236959fb95971b00509d30139b8ceae4f0202237d089b0d8664a2d80ab9c916c8965c41306740b1aea1e2e990117b6815c3b5b5b31fdfaa664754cbf064db5fe0609698737016b3a19756384b2961f5cce4346907c16c66c4377f889e7ee75e6c2ad6b6ec194bd2c7982ba1d4dc80611cbf6db825982","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
