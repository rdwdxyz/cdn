<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e72754b852c6486620f65c9b98ae7b18c4ebaa058ae500c46f84bc55a621a8811f66e9ad68b3d5b1acfef254423fe3a8ebf9836b48c6f56f48b873feea3a7c5d64fc14d914f4f297c1eddfe1bdd96499fa4096591163aa3e205b5ca2d502153345aa7c58bcb669a77bf04ac23c8ca2287a84bf0e4e685f6674ee4c5090ca105f234231cfae13479a67cdeb801c4f97d322e074566114abef6a25abb046f45c78465702901991dafe390867e865e12bc0648b2546af3f73393b7256950afd1b5b85213fcb83f29b750e46a6342dfd3541ca889936427e061763479b4e5fc313abb4adfb79f68335cacfe286c5695a206ea9a0a2cb5eb446d8b85b982a2cbfb6671efa85638b154ba7fff7f32daf552aae78cef2b17aec49fa6fdeab52ac3c9c640035921bb5acf0f06ad8292e7a22715c18b37edadab157aecb7eb1c7afa1fad2da6422ddc8805ea60164c7933b7a9d784a6ec11067df0f58d9f8f8ae8aedbfaf24de68cb55cb5573c5c9ff91ef2c268f8f2d38b25be1b7dc2bc6189165bc718cdfd2d5491ceeaae5f0e2018c31e10734a537c1f1260c9da51766a1d43010149c7c963d2cd278c157d23f78fed65ae08b3a3eca3f219c4f5d5b22573ddd9d3617a3c36dabe8fca31677ac51a1fc788cedd45a667828d7bdff6eea1130c96cea9a83601655b85f85706c01e2ddf6d7587e53469679018bd05043df00466f2e137f1803bef0a5d2387075fd9e81a1a92874ef61a1e733ccca8070a87bacc39303d38bdf3678ba4631f9e262466da170972f2f58c2bd337614a6c36fb6491ad6caa19c42446d18328c69f55a881158b4b9d0f96fd11cc03f53b74e52fc556498d594da2220dab3156e5f85591d0a4e732eeaa63c49871e96d7776a16baa7776d4ac2b5ebd3845e4f5098a08c460b3136c02505ebd3ec82215bc14e7e4a4cc7411a793a9c2da76fa8004c110845bd48f68db681cbac5ce3b6638ea10bc88e1a4b7d009723edb3f597d0bae5031013148e10a1617ee43b396362986acfe3b63496f05ad523c21886c7e24de7a2c3dbee1911c7e0f4e545abcb55ab54bed776c2c7fbccdd3296066570cb8a45bd280d90e74659bbb4b0d09c5e95923fb96f0300d049c1a3bf9e7ab7fb6017177b9ad5d7b0d8dc2f7ae98d55fc0633ba8feab1c3fa48c955e41775bfd6763b099b0ee63155a220f11a3e5825287bd0fa18e87371f99e880fe4e820230d63bb5100c103baaa4029c18b76a7f36399b7e909a37a0a6afaeba44ff3510233cb2d3c42f8a5b91d5df0bcc1f4e43f6d0a04d2441b7bc222f012187386b808638189f194a9523119945110e5afba51b54d0420b26e585a8f998c98f8c566e80d7b8ed15782a8b64e69a36333ff08e591d2c812f2ac7d678c28c353526b0ffe5636f0f36ef7839e61d42d6786119b8469316d35dbb854427bdb42c9361bc6d0ec334fcd3479b201412aa61eab6ffdc43380bee5335fa5b75c284a28a622e09c91d4925403ee9715f716abc4a6a477f557dfacf4dea517930b2d22e245a51054146d2985498752538407a25d7c8470f74d948b35d35819ca4691295e21797f74743adfb0fd8976293f931a0e25b46df40ea0b01d00a3021f82ca733f96b548dac07cb3fb89ff0f864c6876ec782fdeb83ba9d94234a773149951d680a513af8964bcfe7978cef05caeca78a055d663d1a12dab8998f7d095b759216d0ca6226cce351d436c5eaed9f45eb9b401eea0d723ff3548975da0a866fce77f8673689f3c37ca86b960ea3354c15ee8248ba7c8b19cfd36fd2fc38f7a6a5721ac75c7b400892a0bcee5ae76d80f51a2f5ce94e374c56e361c947de10af8b2f04da4e7a9c714cd94528186d3d7f124c7a13f7aa9cf2401193fbdc46e206a7ea187fceb5a0d4aa6fc56a093ddf53edff03ac59b570a07b599c6e92a5ee35bb405e8f3f8659918b5786816e77191915df2fbfcd7d7da71c6bcf880d3068d781306e589ca322181ab6714625869cecb08f6c6f576a7badb80fc859bc5078052648246140b9e82578923bbc92ca1bb400b111ae4994947daf233a3aa5775d8a57c3fd192669eb9de84cf9f4bde7eb8c0a76e225b0d42f532a9573f5ade8c6e419ede752e268a54197c6dca9073c4a014ddd3afe746106088cb97b297a21295614b6553831e50f1fc2f87b6632c5e92e6deeb1dce1e6eaa2457d5c06c821a58b7bd77b72cef6265cfcf2bffa3aa98486fd3a53e4613c74f376b67a4fa01e955b7e4e4d7f360fd848ee7bc23ae04237ec8a5d877509d26078fe2576e26f250685449effb56ad4f3933c4ed42509eedfc07faaa99fc63c747583f8f1f02d8125d677bc31e557154a43a8dc207c6f47889f8a523f76e18159e8bd46d327a444bb7e4c7241d4ebb7546406d4a0811fec862997f2709db6488e939dc2b9668f1d92727c8e56f4ac5c797d0a25efb51257ef481e399d438007c159e526f2f420551431d2bd1874619987fb67ba1e72b36a70b5815cbb4bd1201727ae9f89d249e2ac0bb34f748a8eb2d218a5a7e8645a60a82d183c8304db88d9591b62ef6e9aca3a20996b7cb4ff6935895c6610404b9a266e56758cae78972a222b0c32187ab607bd186d834aa9fe7972a946857ab24b06c1d4e81c20a806ef842a40551a654e06f159fe8c8c019191962610d7597cc635ae6aadb1f5379d6a24afcbf825d3b14078246faba74c18fbebcf070a432d9bc0a850d641282a2ffa9444046e954b5547f3c08108ed96ab75563430ec336b6ca2dd8ff0a9a71e4772ca40ad853dc3f4180b5ffbe81b2d16b4aa5aaafa4853a00cb8ae9701ff9c7dfe6baf4d3c609c47719a0edbdfa7289f22b928dd801bbe8763c0285decd408f1c44cfe01043eef3aba8c485f2272c1970f1e7dc5a0669f87bec87ce5b275b90e408e00070fb6096d677ad0baabb3aa6ec7f5e37f87c07b1c8db61269f5b152dc65516c342ea876227bee358a54364e7f2d4d6873fffeae1f29888e5d326b84c0d328d9a54e47837fdd6a2597cb6900efb08d458482a357a91e0fa4c22ff91539952010b7cab189f2bbf74a7f2f42b3b60a482119343ce970a164e5658d2305d5211f0f9714e22ca603b9c24437912a3a9462813359766ebe4ea720d9804960be7a2d384d825cb7d3059c8121e5038bd9ef4b7f7a75adefe5f97582964d31648e11f3addc432636ec5dd81e41e5f363fa3a9929c042212aa0be103e6ac7b2586f3684da369b548f30c343880ede25ddc973421f8e25b0e2c10da95ed64ff9c48f5e51c47ab3e854d89571c7f4b40da7bb885ab81643f0d0605d5a549ab1f1b58f56a7ea4de161d299e9a54ef013e7bd820e845d1088ca4ef9a11adb2f725ed62633a669c42feaf6b2005675cac0bb787264ef30d7e50ed84fdb473dd12715644aee007d48c0de42835c42cdc0b3746c93f1d82ad1f9189e39663fff8bbab84cf73bd3ec9b358d41e49701aa4c341e069a65ce5a4b573495a6742a894514c0160f6bd3977037a8e56ce01c992b9694e9494c71e3b3db1d76927bd0f98690a300246af6776bbe05ffaa33655497aa83a4744b76f2941f1661a297edf9c1d316fbef3ca73e1dc42a1abb7b15593ddc06b13d376ded6c6e5ed62c12a2f5bf0d0114407f9611c9463fe00fc8c464fdca07f4cd7f9813b6f31864e3480bebda5c87755b120a692114019b4956f761368d39fd5804948a9d2b09b2aa428014775fc89f9f89e7e2aab55702587a70b4d481058d27a5e9bd2fab76071c6864a09d18204f54c2a1f8b1cbc572dd93dcacc7ef9362b3b00d10c90fd5689218fa76edcf701485954b327723cc8aae0d4758d2a38e2570b500acadb2a7e4df7e56c5130334ff7be97292f09fb2762db7cebf15a694f8365ee8ba25a006fae4266ff4cbd3b6677e3b231714d3bd19e0b80690c7d832e459361f5da46bc77d5f032e868cb316537546bdf9526d0292d50428e1f0c5e1ff8ec35386753c1bb3ef3173d241be12bc80d9466a769d70fba3e174e2afac4bef1d9d70a0d532d839639db174636b0f9131f741f0ff779e521521c46c0591068846d9d919f8f97173bce97ab245bc1a3174f0660d5abd0a27dfdfabe7e7c6e636efe56c002609a71c70c38373413123f23d26dc6dc89cfd6b467f707654120b53971d97a981bf511faa3f9789c21051216ed5380ce3586c04dc6751f5b034899a6cb425177d0082ba01b667909d0d2aa203e7fa08543dba4018a66348b85163b7d50814033218ef6c49eed56209aebbf1ea073b4e7192c9620715898a9651c2ffea1b0247e96eaa39ffac3a4020f968fe4d63ac1fbdcde2689b6dfc15dce133eaae905b42ccdb9e434be6495c1b37e2c4f84e4606886b13beaf82a30c83907f4383a2eab5e53db05c7f665a4b28c58b36f0ae8e5f0d48c18319a5014021d1f1eab031826c1c06e3f67a96860689f304411d93a134665f0e18d5675b6f20966148fab9122e43702e5246a5bf6cc4246cf00e8ffc6dd9f4319960df3ed0c3f35b58325b9504a66031129780202460b909f9b53160cba7cde45c1eb9fd6817d816eda1fe5c90b7b73133c6c99fb183ac546cceee414415e27ac27f115710442a8ed225e3d5eecc02b6afe14a2e580f4a3868d549cc716c7e05765097bcaa4743318b0d2da9cf34619ee8cd5624111fed497b6ce5d5cd71e28a4dc945dc1f496a9b97b729b158ff99b9d4d566e39bb601d783f2458abeaf802d63e611b900c9536a4bca12b65769c83ae30e893a77e8239fa634735823afcd024c80f7ea0bd6f374e666144a88da3f2565ea122cbabe1b50523602ef00d2f371639cf2c23e437cfbe0404407c6b18ca87ddbd1681ae4fbcf0ef2977529ce7c15281e47027da4a0ed26ad5876a81a8888a2c17ae31840755d54cc04c43d31a6b93d0c427b799770fbc95a30c0de03447bd465073cee4673dcbbf9e486267a7e33a24284f35d3da78735f41930578615e9775eba08784f23b6ff93740bc98b9310f7c0b6ef18cf2fd2ed444d7642a742ef2148460cfefbbacd3808fd0fe78cc9d3915a84c43d64eaffe8c721310d798f4f88bacbf771a308344fbcf6fbd0027c1a94ffd5328803cc393e602b0049897cf03ccad0ffadeb83a8d1d44500fd326fe6b261709a0e3171a287ac5648adda8516af94078676da69a1baeda151b838b3e4b5290e4539a6a9f77bf7bcd63cc1eb0b6e1ecd13f76d3d27e88730cbf4e814a6ec6e01f1546a4826224c58655ab4c2a102ec61838296cbf8d703895ac68791fdebfd85b3ee8b84f099605f793b445b966e0ddb0c6ae8fe54507de757be5e63f7cf9928961deed7c3aed5d98979534cfd274a7572aae0787f66ab18930a1db97f5af28077b33369f0d61877b52aced09e637af5b1b62905e64730bc3ddb3f963157162d6884a62775dee169ed83d36d3e9c4f09f4c7c30f63df1619ecd7ab2c17b79be4d4eb248b909d40050a1c7804862c718c378b1e30e11ebba12b69aa4d92b9a732e526e6e58dd26a7ccb31798f0b6f2b7a78792b69d39ea6980263d8d382e1a8d620804fd7412feb84c4e7c4f7a121ea809ecb2104c2f251a380cbb04f5608191254ee418c39930d8eca331e5f6bc3d51446c53b3fec5e1ff1124624f5fb9c9b8262213bc03c1b27f9380a63146256b53a57e71f57a2b6e95525a4695ba3192f9c1cf7ca8f017d03e30a978a022b76c8df99029c9c5ce1f483749577866d1c6bb8afb711cc4f320d207bccf1319494be0c83577cbc16870d10f6d9657ff576952fa7322ce63106f8e94d131231ef3d0c9f89ff6560ee8de048814bf92a0793f5e6dfa87d1a50acb0d790355708b6aa6093b9e5473b462e121338d86a3bce406a644aeae69a817734cfb3b7cbd71de176da31625a57def2564ab640883bcf4afc88c31fe19cde6209cff7eabd25ea8397ad3718da08bc067daa382770bef0dcd0451930e515d5a55ea5f68464e11b4e3c72029c64c46cbd51b78cb9210f9123a577b1fef53b213bfd5889fafffe518703b9c28865622703bf16acf72078f35224fc09cb94e915a512465d168fb1d9e70cf3dac6eb3a1550d521cdd1fab07595cbe50e7e535b85e1ca9adf333ca65a870c456079b36905d5ab945436e6f17e5aafeda449b9c7f4079f864ae5913e74a52634ec8bb66b4a23c29ff1f924feca495bbdc027effea474da71558d26ede20d454fa501171a5eba609296f79edfeb3bb71bd7a89b20b4e3f661462a431b465329078a72af555508a999e6324a635f7fc6f951a163c292a6f69d4e3a77a06b9f882c727d8c359f871fd827ce5e8b376a4486ecd8d38057353e77b2e9d124432f909f0c150f7460ee0a4fa355abbae31e2c8bd94e683d162d5c11092823a5208473e3dcd4f8756e5302984c690342cf28593341c3b9f6eebaa558bc4feeef0ccdbc87d3a6d9d9f63bcc710b7005476ad4d5688ddf3d71ff6c6b236b2295b32da8ccaa5b044a0d9b3c33caaa08a3b349b60d9b6e88078c1de75c79eab81a5ba0ea31a8896d9de8bcb10c596fe7622056e24860e88c268b9e5f9372e59d848b550dacc45a27b4c3f4daef0f6741413810adc12c663e693810b1ab6c664a3d9a69a4fbc2b8b335fc4e1afe84bbf89b2da414b0f48ca5f2fee0bf14dc84246a15f8de396ed61f840a9cc4d2e2bd6e46bdcee6af28025f711930b05345796f2d702bc7c43431fcc5b684b29388af92a46f3e088c324151b494d1702d2f9295ded165de43983a96ee635b5387d54692e54b689b66b0fa38fb07219a020e8ecd6e9f2c25e9e817dc7edb085b6dad9b15b6be0f9030422d7d7b3592b6b138f27a50547ebe2586ede21b6b3edafecd5e185be92681fde1804a4c2236b3235a0547a4ea4a843ce1777d3422e855b70fd5bb63d22c03d7d69c54593532cef4e403f3e2a4a70b19b29ffc3068ab1ef32f9ae1493e65a004b66972241ce17bea40baa3b077009251dd9bf2e7bfdfbf3a1ae863f4e20ce6ccabd6f9df100398b59fa214e79df7ff6b0a7aa0ae11e522e664d0805426080710affef3e02758a04da8db81056768feba0a3ac7e88e82906ade906668a8fe15d13e7c979d14ce5bf7569f8a7421870ea8f8171559ed10c9a9170ec5054a53e7918f63b2572d5bd0a2a2b7369ff26b439fd5187c2f16af4daf60b64388aa8bdab100b2b354685aaa615de87c452d70e3d17cc84a4cca819849508e619f40b2b43b715467811554143713f9fb3b7a74c01ee5ac7bceaf249dd163bd3e81b051ef0df03d22bff368d2122c3c574ffef1bf3a27ed2369ec61c8567a986afc246d5902c5e6006a62540da2923069254b2a296b017da6bef30634ac311c2272c06cf5b970edad6e6c277664787d24fccf9ca2c03aef516361aecc5c6495d65c37c11a7deed36ec2cea8c408714fba339c221bdfe52fecf168a9fa939fb07f710dd835676c86b64f6c15340eb2ac2db32214b457258510d0d7b0b24723eb9d64b136cf98affbfe856b104ae0c90ecfb5c4ad5305f588440b9d5ff516cc94876d029fdaa9f55c44748acc9db6b05d97eb66294dff5c24f88f2a3a1d15a5faea270f6a1ebf04b987c0f0717b27fe1835a81652c2f95508cde4bf1f5ba61744e25e4a6d3f26153a7f04c872d25c0d372610e6c54b599149385ef36c097fc71e3f7de7ee2554cf82e010b8b31f2c99f9576ed1de14a29df58c39164d56bb6ec4d2823226e84e74f9633f44345150dfaf82df2db849d2e953332fdc7872c9c60e492a938426eb9c761cf37f078bcc1f542b375a06d584987a05544931841962bfa71c58d8c36270130035dec80ef2bda1d9622453fbf28ac493ef54b062ff3423bfe6c57de23709befd4103a8a58674b4afbaf371e6f6a67fd03d537549e725db9c4c0f501c3c1b9606b5603bab8e83de2ee8c4158ef51d99763f279c26e58af495fbcdfdf8e37b2f41fc28aee0cfd1f893010c1f24a355b04819826279cbaaa3976e12079beebc08ce8be6b0330829da395f5ec4850955e77a13c5a53d2101410c958ac69ae9d3218c4ac4513c079f87590fcf45d4458fc3dd0c6eda33aac79385115cd375f5c8d84b70ceb48b0c5f994d871cf6308e8b8bd0ae5065de52faf9b54680392941358b451cb278a22f3d88651bc095fbfdab3bc6e6b80d200ed4af9ef57c3c82bb24a544e93fe731b4401dedb269dddf31f4fabc480b058084c1b65d7cc5ded91142af3227c3247ae5a3190a02b1b069712c99c48c2b865328fa95a5b9fbb09bb480b28cb0f016b0ea06646fd94e23bcc03f27daaa34674ffd4e81c89f16ceac3dfaffe8dee3b3d6a49f77f60903a38335ba1d8770a62ca5e53f68b50af0607a981c8a361194f5ccd3cab3e36fa0e1d6a4ee3791867c547e68cf18654e693df816cb76a32dddbe139bac4604359dd892e161234b5d4e758ec146b313dbf3f921211a88319bc1d848aa6475b4d86e15b116e9c2f0cdca986185378dd77452b2a043708789dad4d531eb5b29dd933d8ee530af10c5eeed6a931f8adae37d9cdf08eeb96f3dbe538ba71de34f81a8f36cfaf784768ec63391ada917db725683c7328168b1261b5efc56d9e1461d1136c157777fe444b5d3c88e90b5853ddeabda3e4ece15bb2d84c355a319f09a54a75574411e8a044e13e27dae9ae4aca126eac90bdd43b386928167908fc33245a0d7f05cb3ec7e8e2b331e63d84bd677f5dc8ace0665165a9163e922f09f9ffcf9008c49e0fcedbb87075d726b9dacbc901ac1f5664cf63fae137d954f3e55080131aef49ad8acaf59aab8e6b8cf18ad72ae854d8820499499d37cfa27fe2ce55fdca555d9367a282fd441458bf1a2266c9fb000a708bb67df2808059d9fd1097157040ff2afaf109285948e6344643911db5ed2a295b45d3d47682eb1a9ae0184ceb0bdb011b0df17910ef067e586c706b099346ba4ba889f32cddfd3e4bdf3176511b7470bc81d2db41d606f3f88bf7ce9f831c75fa161259c5c8e9a0617cbcd84dad2c41f1921c32ed58ba4a07049b5cd18a94df9467722b334c62c5a9cd9cdf0434aa8f3989479bf3188644f4b0e6262b102d6b50392077451e1efe9466b472a57059345d21705d32e7ae7a5dc523694c4daaea118d681833ab0640ba2f0b517d1aa6a4ba433bc23abbab6da880c79937d645d2f33cef66e8514528adc99d7f00552cb8a8a96aa876f0fe6e114794af56a289629cec54c580cee550f7a1dcbbf09be64e7ff4b3621a0127b5fe4de79ceacfb689495151469dbee5afcf1fb1c61e6272bae866682e997b24c24a60028692a3fbe0d92ad1c7687f80081a45aa05bb1b991c37247917f14e0e4ae89457ef015f2cb4c641fd2972ea75186a2e902edc35b87f88f3b93c93209edb2d79851491bdb7ded34e9d02c4ee547e79775053bbc382cfb31b9348fbcfc718ecb3f79d5dd6859bed86c1b1e49516b2bea2053a7246b110a2052285a2ba4b0a8686785e6b9a87dc094279b5a31b079a4dbdf1d8249a81fe10e2b86515aae4b0778d355fe8757b0cc597ca2ac3e945b6185d857820d2901d9c3daea12b14e0b1f3f2d6303993e5bfab4caec486af2d78b7f65bcc93c97d11a7c98235014e2454d7053e8e5d58fc9e3d7654b425de9500d49a08f101d0c9af492a955e98a6dcb28469ee8261d944408ef9c86ad48dbc2d1677b9a8692db074aa09e09f2eaca1bddbf217de1123bcae0ce3f667ad37c47c5db67369da72a4b078a62c5f9da483f9b0d7cd493dd8c8358428755a32baaf1e00127265637cda56201dc97a62aa38da5832f4e8fcba75bd025c671219790486d85f20d5ed6f5dad703bd5676a6a1da45631e269a5be8252bf2f5fa5675e18d542bdd4093775b28cdf3605640fd782535e08954a396d114357562bd038ec038d247ed24d7be8561bec9dd84aa021917314cd844c09bee5c1997d13d726544620317636a6487d1959db5dbffc7517361c5f4e8ae88abea3af8673afb9d0a2f01aab3dd9b0ac4526534f4d55aafce9ae6c21cb1c4f34460580f0c13f6c0b498b2610d964f86db92197bcabe87dd13b86a972615cd5cd72dcb9ef00bcfd37be173263af8302457c9b6141af1643ee3a2312d0f6a53851f0dbed12361a142d523f4722533a9d5ba909b179cdb6f79e294e852d14b93b3fba2497c33dd1834ccbd4e052432b3e88988e2fac376c5ed210abbaae266f8947252061a8cc688dd0d833a2bcb2f0f6c416c145789ef85549381b93bd16a46dede743c78bc96eff30db57b2a2a4f571bedc3ffcaaf13d37d770f6653550f9afc05b672964e63a976d22b9d1bf78dae14cfd8dca3aad92eb43456a03f5bbb7e79649d98ec9337bb4557f237b0cff7cabfc29eb9463122617c1a0429df181ee5368647ec55ecd05ab7f80b550b5221f2b349e38bac33066351320182269a1b5ca8a8d96b3bc0422b67035bc6db88472af96734e552ddf6f7d65644196378c443946be9acdba586a8b0e73e83b64d66b7a2c0705ae4dc74d005578df01314d863ca6f8ef66309470bc1ba21031e7f6c8d32d1ce13744c6a504f1eebd49d75a3d4e3de5868056c2f746c6214323fdad696a6c09a4783c222d985b9fc2d240e6d3ce6130d3df5b5f5b1ed397b82a089a4d14a910577fc7e98e5f286e84895328dab10180bd19eac29c2f4a6c42482c2b10acff64ab7fa6266545419af1d6b1ce6b5086fef2b5f5f8f5288a763204d7a211d0eb080db5dc773eb0ad38a79cdcc1b316c192466e3e36a89c788e7d2b40b894606324dbb26c257ba7bb2cd7e25d9e216bd0ba3bc115865da89fd6835a22d16159b6ee84dd357a1fad3e00e254f47b055be5bc097b9c5317a239e23207dc610a2bebf57092e5d55eda87cd035fd04ba6be18f70d045d195070b8659c21622325ed1c796355dab36b54cf495092b87138ab3a4ab82c36c5748e98806d4b03e806ed7faa0d7a648698692a54c323be6a26698fd35d652097aae13be8c3189e549aa65d3d641b21ffaefe9d15dec6e4f3db51aff9d6c8a8aa25ab81fa8e1c41c1704ba6ea7de4ecf3c3c42c67f89e6ba765f2986619b4f601385e44f62a8cbe48547fe2748d17bab8fa704ca1d0899fa1dafb005eb46e5f3cfa8bd01e00aa22cf03ba54b60307c0cbd5392067a771348f2f806fe9b2308403ec7734fc087d41d88fe0d4ace7788520163e150dd39fd439119691b6c8fbcaeb611aaa870129d7729e26e913ecdd794f3f76a21209f665610ae4ecfa9c6496888167c4512df44e3733266ffa409466fd50becea310b3eb7bdf584c38e3c8bbd8ea7b6b517a5fe50a346f544d2190a7976f6a3e5153693317053d5e09a2b1365caf707eae1ef464013a8fa2244edf10983386414ac33c526960b144fc9cab6757163012398034ca3b44e8b26881c3f31c2f299c46197e04395ddf47558588a63139897f61007552aa7e4fd763fcc7d2a9b5405d7e96c9feb316f691f5f82d1f3a98847f590ab2cb0fff3ab396390240cf37c89009e67499740d85ae2f64f82f4c8ff3e29847a4a275f306f0f942adc117e4167e62e59877d9214b106de2199c969164c2b41b3bad49ff2046d8198b795c8b3b9307421c4ae95910a6252fb8e42948b97d2235535cb033485838f0e9c5f3d7198305bbbe6d22750dafc8da2ba5b2beb1e6f241d78c9c53778b645f615f4878de0b986d5bba540331346d78a9a47200fea2982cb4be8bc22d3f6fb52d95f4bbbdc6781ef03ee7433492c577cad223051bce4ad0f198cfaa62aad3a915f6417824f471b8305fa5298a8fdd1895a217869f6eb6dc9c4f5f2bc513728fc6f7fe34ce9a404ee497e648ace95917d3b0e37f37d0c938a23e5a5514c7229fc5d0351856d9332d2a00c634064d94447501866e008afafc0f66ffa532a5fc2ee0d06d123970cceeabe61a4d308c2efa951c1745feee0b027ef12e971f53d6c360e74a8fc66fe0cfc816ac322de9f81a937eda2bc445bf91e470fb14f7295e07c867477e6fee9093a9ea1b075856a26b72b2e2dff6aff60a64f7fcaa20cb030b5370fcb1cc4124b8331e3eaefb8e4877399b501ac3d5ed33e428e52926d8cc7eea759b27b008ace8a0990c666c7219b35a8400732851c01f478890713d14c822cbfb6e9da9c7f2f3d91c532c1d46a1726dbe6f54efa67030fe126d9e11f9f01e51888d6e1735f76bec48a2c59339383f3324633da220f9af39c09a819112184f681628980cef3c58ffab2ccc52488ebe66213d5bf3653e170809b3835b3eb6a86b6bdc3777179e54d46ccea6e41a564f0310706e55061630a82cfcf5c30c42ad6f380a79d7bd67e494cf798127a1ee49857fd505d17b9290f1e51328f96482661b3ee5549c29e7dce5fe4ec9e752d0e7eaa84d528e3db65b28faa5a8582ec6c08de484cf24d33f7240f29cbbc853a556b057e7462a8a4d88b4e8a725bab680cc93c7797e4c403d3efbe6aae910511bf1ae6d56da9e28a5c43d15c962c3c0c71553b5df7a1bd3e234d9a99a7b61fd1d7bb143a830986d6264c5753e9fe40c127bc2d915386b840e1338604910e917882d2d052e9ea26f1663519a32357ffb282ed54864f5cc6b54b1444c49fe45d8f5b465bd581188796badf89106a8eba921133285403c5363dba7d986c9837b6e4d1be2414673c8bcbf0e90578b4d98778e1fd8557c3f024e8d9ce1c121968d18a72e8149a209f72c55cb6d1a34cd660bbea96571536d38c632849dc280dce1782416825f8e900fe3eba0547b709110cf4968b1611ecfec4f5ace9a52ff7bde4d6fea205f759f4b96a86872b4867ce0ddb3d4bee26d2a10e1a743796dc9e977fa3e630252dcf5d2e672c6851dd636a30ded511ccdad240901115d4c224c5637be3138f0431cf3b2dfcc96554064de313e16cebd5e98a83f275903e094db812ab854109b97b7e9fdcebbbf931d82cb0629e97808553bec939a506abc289ff939e4d2b9b817af54aa7e458898a214421e9f178a88d3489c1f0c28f9aa259b9afc3e142aa5402d6a9dd30618dcef80907442fcb0c3d39f8bddf3db2bca31f95efd0960c30e2873fae410260c031d674d93338557f9dcefee2f7f11eba3ae7c8b70b72f2ccc618e83c0107bfc434882e0889069e1f31ebb084cf2048e2248029de64f8e45a56e9dc7c2bcaacf4592701fe2acba80a572e2743f40e538f3b96af9bda1195eb8e0e04faa1b6880487429cf02f208bf65f7b5a4a794cd8577bbf0509c01e6b559c2faef5bfafa22dd58437d36b9eec8d1cd22be6c8d738bcef75cab2bc11909171b14c843895f9cdb8b6450aca9e2ab35a04c12ab583d3c45fcc94ad3f16ccd6ffc7281101a2862c0525fc66f7872098f1ff503e83c06e39f3510b24f06beb248505653ab700067984b1b2bd6de70ede4919dfa3d0cfe04cdf74ce1258ff1dfe75963ae8e39994529f09da6c5980db4e08b8719ade4d884d8c4f75ec226fc2481f81913856e5454aaa057be5b16627510bdf4770b92249f9726a6e415464ec180a50fd9072d7b311e74cb93fdaa99074bb4a9b8f8cf9d23b366a1964322ce441e0149faeeaf62c5c23c766408cc2b39254d9177464bcf236c7f6319703b5a5ee3ab472a339398b0d79f3f1800180856c044b1dee649e06cb48a3b10a859a01445d310700826bb76692e27b5205df865c78249998af1a61085d5d665fe7a071d312dd3150976b8c520754392f3ee297e63c96cc8b7731aa7f1d36156c61dce452f2db76c717357a0108773028f5d3f4e45d26cf6102cc404240649548c908a00654229f043211c576c1b86fcf1dda57a6443aba7bf5c0563a61694b56d9e5d5973e662fd12a354ef0c1e1bc285585da27cc562ff20164ad9ff9094ed622a3a3b8220b481787d3f805b30bf40ed55e645dbd5fa0744966a5d02587baa0246ef8c2b3566a195dfbfaf9c51b8a425da9b93764b0cb4fc2a6c6cd4bd478645e836a5274af2a797f982fb9b8c0333d5704f8d16b4eb0b1d78826af018b6569964d67ef10703be7824d111e3cde4a6e84efa08f43b00eeab6b8962a7019a1aedddbe0a7fa369edcf08163357803251a6426a59218719e6d39c044b1fd642283d45aa39b6cfc8b269bf4aea44467d3938ebdb86bfb16d467450946c1240c9cd3eedf359c1aee8333e6d7b3cf52ec14acde27a249156dd89868e9f0f7f65490ca2212fbd68467a687a07c94d7a42fcc1e863ef83e9be7c1fb2b69042cbe7a78040738946a54dfb16a5673d7caf0d27ec98edc334a0c479c53807ac421c01db4d72f6d4e2207fca2070afc76325b900f88dd38bde0650a87cc5e586b173bb3e0adaa3502b31723d949331b9619fd50dd670e44ebe7f890ee229fb3662e77ac5e029a418d8e3a1267558163feac78d08a418384d4af6fe87264b8b4bc8dd63cf784dc3386ac0b3e6a94113cbdc42a1b0dba3953d32d39ef9dacaeb3b53e73cd91bc0925cffee86b59b4da62590209c3c89bcfc09263cdbd380e291462a1a5e8131ffce2b3962f0572c21e9c298a602c9ff5dc3a2fb42e60acc58c2d4b9aac4d208d3399392714ba1d1829924ca38638a72fc7693a58265f13b92bdb6c91de0f87ba87ea374f04c20688b2b99823bfd29fd0dc76bdbbd6f2612bcb9cda3549dbf6ece640d62ce334079b6b6324f5f6cac6e25d7d0ff48fd845e9d7700f4faf205dab0c37e4969c58f742022294e4fe2102ca362f665c83e311ae408dc8d342c52e91b91f98589e40e818adc749674ffa3a960700e98db92d62b4dd0172ec3ee5c63ba8baf250c48b40ff7dddc648bca28e3445ea2d2c2f330f5506512d7134a8ca97177a06651e3bd6d2d3ab4ef9fccfb9b701789fb7d0ca6a6e3e35cb2a692e87bdcace3dbd66307cdd2b07b61cee1298281ea7a7b1f8ca8a380ca8e9967b60164327313c9eac25ceb4670168baed87b3ed48b62ded54429477d962cbbeda8fb9d1f03197da3c66dc03776bf3427f91298a8ff38ab1613fce5edb2c28a974f89a563302c3314b8c66166f9fe45e58e855d2043c2080a194b591c382cb37eab9b2f608552181c10100dbe6dd8fa19417c481890df6983dc054c8ea25f9ee217beff7f488a902e1616c11ac48b1e3215e05c2fb72c0a826d980c625ff8cbf831269d604f9de565b7077c0fa4603bf1224697053a6d3e3c4567eb3c8160107f4a6bda18ad8b0cb3feb70f5d28749cfeeabe812c021f0e5c1d73da514c3bf271bf7a8bab0f108cb96dd5be045fdb85b1ce623a97f5f821ead41a57e91b4159e3fbb66f58527a4f70348324601adb7b1b07eaef65bbcbe9e577188815429aa54943088a427996ba90a919337b01281ed1237f86d0a79b03baf0ef7f51b6badc1f7dcb61b455487c66ab2202a9a4f8cbcb4f9390a29539e827033fc4ee7f8ca1ee449845183dccd645c14da6c950cd5d82a6ce48c23f9862d8b908438ac17c2c22c8b5dfd5e0c6b13b78500e4951457aec1f284964f92a49cbb3a26d242dff2551e1c164d8f4767d44ceeddb5e7a05855ad9e1fde4f82ac071d81b8c68f8381ab7f3c5f7a64c68ecc86c3d33673ea72ddda0af51f2be481eb9c602931dcde942158efb8a499e2c08fe56dff405a3443a811b4039c7347a72f7fc6842f7166ed325b87e4655e8a07de7c51f2484513fb1ec5ca9dc718b1b02d966b342d2a0506a3ee7428739841057c711aa0fd06436dff22915ef0d6e9ef52a49326478b7d1797257ba72e0bea583fe0699343e34d78fafbf73d4fe0129384a5da2f77b68f7f5a134dfb8d3483f2fd53f2364597b2a51ee9dc4996bd06e621e5d5990903e6b13e5cc7f00e79afcab5403500da416b624ca6cb6989cecb3cf739cfb9d8fa16a311bcbaa3033458b4ada27d897e778290496750b48885da5b48745e1f1bd767fe5db5d44627452d1facef111b7e6c5550972da1b38d06dbdcbdfbdac9b4d810e73a63818674b81079e37af427d04ba6aef72259a72ad7ea217802e31785fb34d925e9c179ffb84558af4c7983b3a6ddc108074f0c649a0744f3e5db7fbadd95f0d40f515cff7d8a632a337297a466c100db1b83c695220ad067d554aaef8fa30b90cb88fd3ae9f88dd0c35b7a51cd4e0bbcb64d7644fc4e50dce649ca01cbdbebb327fd91ebdfc82955d5664bc402751f5881e04f229814a6fa659988ec1ce12bb7475db2a6a7258f7c3a9a949ac013f3f42908f0ee62cdf2f507138a035942840d831b20eca896a741a375951209b59027bacd3ce4ec977c65b8458de203d83459724f4b1d90fc7ac4d140870bbc054656ab86c900b98fc802f035225a661ed816b8dbc4623e045c4503dcfb5bb8c88e2ab703aa107f533324533ceadf5ab604eaee1c009b0a950831fb2945b9c860c860b7b9554f903f70e8b1c2f7c9d7f47dfc931b2cef1426b1e9140f74a17b175beb436bac21b63ea46010a212bc2735dbb943e7188b613837808a3a91c254f7de024525849020fa47dd7529ccdee0a136e51d015d1caf673ad4b86750ef4109777f9cbfd44a940daaef8095fcc2b3d366e1c7541e1764ff98096bc68f8764c4a062eff19fef073dcbc1a94707c4544ac5e63a8bf7fa2d9efcf373d789f69049516cb9df1206ae9f16d1cf8ea065566e02b7db65ca2e94f6b9458427c7c4813707cbcd9281f88df78bd5b297de1676faf013210214505d91ff47010a1b0575b0832c92870ea45c2660e68983d0c991a3a73a2134ea4d1bbd8f4c85b5ca50c226b8ae2b20d741d5967fba4ff0cdaba69a772c03ec5209d5dca0254debaa0ae11c8286778517078a14104d3446401eb78c1221bd14a8414da2d3aee6ce99a7764f64f6cd78f31a964829065c8c0274c20bcad041ddfce57a4601158c35ac03a39efd689b9120f9443b565c81a993aa6b19a8500e2b9193440483a06154330ecffdf96ed44e5d976d8b79dc3685d7e9acae50866688f216174fbd7edf9085b7c30c67138cc065e117c22c5296509c92e42b7a49537fd2af6dd96528d0e75ec809cffd78910ec158d3b9b61a51560adcaee7dc0130ac0f40ce1a164e3b0601628f62a4dfcc867e86decabcb7b86e8058a3a652d5f9bba63a634285c3f6fb9f9ccc18a285c4f276373e7b748d8222ddb86663c87fe04034af9829a40bb58ea1af917dfe235e7d808d6bc7120ecaf870d8a43d22400bd952cbd68465fedf26344bd23002e80dc726331cb5b1f82ae9987f5ec0325bec5200974465f25633bbaafedd20214227910149ad81d7d95d50253e317ba22b236c05704ec80478c62d94c8823bc44564419bc87e99dee5c1f9caa2eb6bd432fe3b8fb156e49916321029d6e5b4ca52e8bc67beb25d6570adbfa485040d79ad091d00f86174aa159498713b6b3034d3bf83e90700ee71c0cfd056400f04036725944c304efe20723653648588adf302af2076cc3fde90e0744f48d066f26235bc115d15966f8e8b859106a2078373b2e222f49a87ea936efc14ef2c2284f2cd166b1ae3a1ecaf685aba712724469ec3dedb68f8d2dca4a6e90f88ecb1ce25358121a2d0579fe8cef2bbd2d78316a17e6aec03e30982ddb1ee28c3cf611f2c4616e637e7207edb27ff30e07baa47e6d766cbac7c48174e89e99befc8b232b5a667c072880b6987be10cbedaf386cc604c53b849f9f080d697ab64bd97ddefacb4864c85f80e28c8027dd166496d5194b5e3051fadb77e5bf5a34d478a08765a54f1c1b31158e110e277c754f3e6b2a48d1dba8f1a1264281110169fb3d1fb3ca002107f4e9e98b6b04935b1ec092b084467078ea389b5ba48c89c386f6b7317cb3b5fac13b1ba5eb3291c61b652fac7972411ead6a642009d059bf91562f41016d8cf79783b43d1d09006e64c9b7ec99a85a259bb6c01b881264088ce9405c87fedf3709d1415ab47add358ea1f21d7e623f0db901b12b25bb93c8e17301a6fad7193a6ab7d1a531a94ab9ae476ed3fc6eb07735ecda6115d2842df6d696521432fba3d9ddd0efe62f02b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
