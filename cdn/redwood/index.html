<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ef259d69a71b9f68fe8908ad833a74fd7c74c5930cc6925d2b7139455dcff5f4d43d1908d3f0bebcdc2a208c615ae215a79e87f1c79f58a456e51a8d936b793cf40944103a91b15d7d54cdd7dcd7cc4d2730cf1ebd4a42d6fd76e8f852d11470025e0ff9c92c6cc05b09e1e3cb97ac935a6494ee67236af152a7e8c87df7a715d89426f58cd40dcf85fb83563f8c49fa668649daaf04814f6f300cdd4f844e0a4424736a8a0cbd4d9c9a562ceab3bc031eb2a9f4062092cf91abfc9d6ed8cacaca843ee79f4f2a4a49dcdd88ac3070382b4ed45ec122ee19dca4fc7fb8fea6dc8ad79d40d83db68b7419f81fc6d75342f7cfd0f457f4b2d9ac8640cb711fa650536490e93362b062391a52eaa56bd28d4eb5a9ca538a5cec70708eae0a77ec2ae4531182ef794ac3472042d5b9183dbf27a4be03ae10930ceaa6205379175b27ccea3c7e689c0d78dddc6bba63e53b4374de08d4973acd72466bcb339dd9ea38963241cdc0ebb3221a255ab6d240b35b162251e7e151aabebfe4a1fed8a3f5d2ec604b3fdc04a9a5b02a1619d728ec6a2376f1570d832e1c1a5c15e9322f4eb1665f8b3fb19ba49b427568a14c7dd430c6341fe96a91773dc663ee729d1ecd0bbfa545324bccf9acba3f52bade55e8753afc13a784501386e88b90ea990c28e58180eff6c3e68f48d08f466542fb0379a5b486feb2271b4ebbaa338a499e31f05097041d26ab27cf0cad8e6872549df7e1e3a076dc5749f6880ebc099f0f487a137015f70d0ba6d9849c4087f6b7f2d17d9504c567a84826f6078a7b33a5b99641ca257148af2d0e87ff52ca4c4976ea166ccb88e6f0ee6aedaec72f447680fac8c9ca36f87c75422726c121269830b75eedfa83092e45e540520dbe743bdeaddf566c5f16b1307610f9574ffcd20555e9197383889e9470bac0c09e8a24932c287229e5105cecbced6f856f7e8c6cb7e811972b10749670298ee3c2386f54b7a1be03e773e34d8cf47a7045241b89c5c1062eb9595ac3a36435834b93799b5f05657a048e78a89dbb18684b8ff42dad7b3c79c5aa0053b02bad152f3ca3d898a0e74a9b7ed0bb82863936dce9559bc75671c70dead1c361514c9239e25b228c9d2fabeb7d8af46b57acd59166ec0ff2bca57fe3b1cd37a15659f0e0bdeb1c3b8ad4fa2398efc5e421d1ea21e04f1efe6d7c977542346d6aa05a68a7fa70f91d2916f8e648deb0056a765c26fe5ec8aed60497ce3d51c63d75aeb391f19ffb128fe3c49a5a0685016d2afbeba7e02dab01d253e3ca1f86a3b3ddd6458b377069f9cd62b46ae0484dcd8904ff94cb25184b1cba1b839da3f610c5a8a18bfcf7f6403f8bf09c1650bdb28cad6fefb77f3478640029bc4109b0073e76c74e7bbebcfca206bd0d8210e68e8ac6169d7fa6b8732448e733b8430506e9b7b4bc3d6d346e1bec17940f662b0eb599ddb235f0b5392490c90a1550ca4ca8d5ffbd1c007b73aac864c22f7135d4efb65b3bc763e53e89e46a8b951c105a93ec4e4c48dfbc5bcd52ca1e15698731db27f51af35a481dcb25da8abb798deec8c2d388859f82799cc420d098c054aa363f57f861a1fb39262c9d82e8079ad89cdcd371180d8b89485c7980eff2ce634d0ae43b63a0950bd14b93f52d799b5d5d7e98ab404f5792aa7c73c676ba0c11357113a605259c28344c81500e340ffedf6fa135848bee8e3c1f277656805d54faece28238465b8e2642aa4ac796aa2fc3c8f19f8594d57927ececc49c79b748ddbfcf96de61db24a1fd868cdf93efe2199fc10e984b3e222ad9879821c804459b6665a97c5a25178ec1072ae4694f618d0d60254e051e0b49f87f20ec95bcdf13a1d4251b273beb789c2af5674cbb17dc298aab9562e20db6dcf378eede5c4c331bfa6d18dea318e335fc0192330dac5f523c6b826959455804b5120b3347941871a4ea69165b1b014dcac13ded22a734899e2806be56adea8e51b2f2c551d74bf5e2ba35ff4426ac3b6897c2c9e5073c79712b481ad980158a777eb2cb776ef6e2b110b5fdd71723919fc004c6a3e7b78d5dc8a6824e5ebdc9b24c885e7c87f480864b791d12f3f769a2f8d9ccf0b98afe34c1a546ce848655803d64d3401d41c159617c9698e469e1895a1ed30afd4557a1b8f3c9601362134ba4c0c3a4315d1df48e4de7fbd3580b293d0d078deda3a6d9bbcb82baf89eef7afd5a3ab0fe051fa1688a7b155452176bf382dbf32f9ab5e86c96fcf2ea2534c023c7c109640bfeaa5a220a9f97cc2804dbf880a44d80bed5a0f1f8dad2a7db5bcf299bbbc50fb79a8e8291ae531e3e951edd85bcdac26087b8c1c34e2d9dafdf94c6fa522fdec8b83a580ca050f908d17f31b8a22ba10c6a6d416d3fe24ad7580d8f280c36077f72449fbd1209994c5d91a3937f4e4208f6b709bff150ef96cc048c44cf829750ac42564fef186dd5747e6bc3d909695d1f13902660d977bd870e7ca497a3201ec2433f6823f641c1b6bf7f62af02a802795e12c2e8835ea27000896760d0956de4d5567f135f9258b4a2f8e35ee31dfc68e1bdfffb57999154b2678cd7969716912d0af3120f198aac0c5287ee6df0ba3e39ff76533758958cf7ab7002aff000f1aa2587531cf2cfdfd840359b0555f331ade8f4909da47d8c0558be78552221a357700b56576b413e920fd8ad623d7588d597c6dedceda016d12dfd3eacaebfb2c48969ffe2b88e8717fe96f138accb8c408d3ff9d345b2cdc88351eca89f3e7df285326b568e7f1ade07a53e09f49ffaf7cee9e08f373567ab678da56a3ea6040f76dfde3decaac08919195d24c85b08db7f94b239a705d0a2a1e68824a4cea0585f038001c1380d8cd53dffe055ddb40b6a974701741fb5a91505892c6ac29e05048710532baae7c923b5af75173c6ab85aee9023199e02c40615b9db8bc9b0341b7acdd6b67d6d35c2827f299f664f5e99fd3af67163457eeb280e4402f1116c3bdc2e8643b580b7cbf1d7d1ec2370ca0de9e79f7a1c7237b99c7056ce9487adffe6c530beddfa1617f2aa6270bd15117c8a073b7b2bca8a0bf5592d0a38bd8cf951258060f7caec085bd3bc3c73f7fb58be1d5b6249f68d37799ba22bd3a52e1c6a0c9c5021daa698e7877e28cfacf46107d2af4d83858c87241dddcc502fe90cbcee21420399f8178baa9b1cbd5ee3c68dc18cd577f513890a8e8b380d49be18913035c43eaf0400d400abd221b895ac8977ad9b55b6fe3a73fb30a6cd814588c4301a5601d33542d7c2a96af31ea9345a44525f14814439363684619e052fb2358042ccc2b4199307e3e8ee3c67d5a61836b76e86ef4742866e93e1bc67dcf1101e1773af318305219ee0b33032671e3feab8c97453743ef59bdaf6073312ce7ff62dff4adef6a3ebb0d6b6ce12ba4a6b274e21d5408f63f120db12c0a881cd01dd8af37fd7ace8fe6ea9f518a63e64309109ba3e258358b667c65ffec11ae7a2df0b0c80da72557cffe57c5f1cbe78f3e688afcc6e8f81d15ad8a5ae1ff41d65be963a5a2b2fa7eec5d528008ae4b93354b469eb28c97dd086e05f85f401bb1411c86bc734b63360e88fe00beb40cd2ace111a5bf9c41c402eb4a254535c138fffbc47919800fbf2b2dbe5fdac1d8157d7daf1d686462a43877cb94a4c83d27ee546e040abbe436eac1886cc84d0ebd34c8ec011753412d42583c72e9c611ba6e39bb4250e2405e5980e755aa3d84f906ee4a52262835de4e31003a8b2b73a050aabc1d309ba24d7bd792c1c859f11725b6ea959e75e087af4cd933a9b3e1bfe2581bac11c8af5e4d0e19e1cdebea7783f5c14609f0a5a92b6e6f5565eaafc9d9964f1f15543cccf5b1a660c7d5d1631b3b7c52d463a4736a5113c097d517d04f5d652255d6b3a60ed4910236ac14e54b03d206fb4c5c29e8ba4580074f481e26c9311f0398a0ed068cbc1e4fe218e397c905fc86ec1da9f99562a0bc85f6b8c87fea68b566685756339c8a8e90fc0bd5f91d4ab642508d722f30fa976e7d2a2816f9a7c7b5f6b8866ffa6c386240e48c80414b147214910a77d32e58cf6f569ae677413717fe66f9526b23bf8209df8185ce91d51787597297497a2a9ead36553b16ba95af582105914b4ef2f5f1e880ea3a5b365e93583de9557233ab46976c7bbc6106733f79ec1b376c793d776cce800bcd1b9b2a3652b88225776d0944576ddbcaad15ac10d591e0e8c80a4677faa1065fe08075748358e2c3d47c18ed8597c83cb16d75dbc6819c06b52c8dd1a053036fe9dd59d28bf380acf2cb74700a16f6ed41e1b6263d6719d6a81cae0374bac5270dd8e8f1bbaa67042030816453d8cc4bf124627d4c6e6a4784f42a5aec5c5e2d7e0c69eb6c4e120f96c3a397bb39c5462cba112af38397e28622461e0e84fa49bd77ade6f368c7f326a429c7d1cc83f655406f279f1a16ba783fc900b48feed3cf7c4d2a49690564faaeb22da92c6d91024a8b82f6de33144e7ce1060ba9b754e5504ea5de64a0a3ed2ce89854a04e2f4e80315e971082716a459cf8366793cf143a952cc23342ece566bbe72c5bfb84dad03bbbe43e8d6874fa4c515d47c3b5448bd451908d1cddee4695d3e9e8c17405e7b0b7acf4d0b4b9b5f49cde887313ca334f8ee6e95300cd5268d0e9228b4822b53ad166aeaf5a305bf15dd8a2f2d8a9fdb20bd659eee7bb749544851e24dbf21efeb43ece22cff47798775ac50c982ebf857a07141b27f435634b17cb0265f4cbf275cd68cfa33396307a00340d2f9d12b853f60d190494c7b5aaed780823c283fee8e211052a1b62251e20852024766ee6f15e700de4c579535b4737b01208fc86d81995bf493b6da8c5548c8f5013e54fa342d1aa6ba783c2f42ae6bc520cfd8a261e98d8669a65219f621b9eef94a20bfcaf2b9a807292abb21b969f3f408d1dc28b6446dc7b91694b4638884e27cac2d6ab7a107ca161dbfda1d7b5cdc60329085682d8782f4970719d7cf6d9269c131ce310f700d2b42b5cb44b2f9fad3c941faa3277742bd81f65917adf2389defc4b27eab7a183afcb25f92359451b783ace5f2942827cfae4ba4bf85deb40be1c3a70c4bfedd2539e588a4c615e5f27ccebd44c5bbd93a4eb905edc2ca22cbef46b98055a82b03153a212642b652fe08b03994801b7522783cc7683703c9878300632f12e2a3e3d0bcc91a78cd424bf6af19ac0b3c3526ee2a22219a5ecace3dfd6f9f9f243dcf98a9b9ca93a69de5c19d6412fad887f35fc6a2d6176b532a0802e282067161870524113faaf9807ab38daf7c0e63e5bf29e26cee12f21506cac8cfefba6420cf66f6bf0cad2cba2a933314b0d03a18572e166fdcfc5ed7d065fe70c07f07be862ab7db7ba18486d72d865fe564d452bea6e14f59231de73b747a16f7118eaacc4de63e69fc206cab6705b775fa33fc84ecdb6bd730920c1e278084a15192a031b6b0ea7983e3e5e4f3a55c0e4c8d0a1a638415bb3e167fc69b3240c0ebb770c9e82406d2803678f71172081afc06ac92a28f78f7d92c0092c0634ee046db076e4728ecb9e605b9da0e91886421b0610e8fd37e88dd1836b579118e413b90869dce68de16333f9eb3e27ac451922928e143bc2cae0ff70b285e29c6857592f1286ce282b2e822d8988a57cc82ab0b0d357deb0172af8e22ead911df23e6d43dd2a034c4ac840de89b5438ec6bfa22efeb8b259e6c68d8e15ea265e92041a6161f619e62bae495f51631e56cab01880ff0b3a0793b7021c72fa61678b737c8a9aa49622f82742550e537f3c88d2623903298ce615fb94fa75bbdef54d8317df1e95428e2f8df4cd84d32695ab1ca78a3b0963fa8d726d173f7322159adc9a4ce07dafe4e0d385e7ff7210247c538950bba79bd7bf07ff2d04b738fa0fae8280e8ddf4747b4946ccd22ea95ef6ef3789a1ade178d9af99121be93d68cec8bb16f54bfcb8e4714226f2f8f083f90b7c05dd149a46277a97bc7257d83fab0ed033024e89ffba54d29a118169f746841ba33cf9da28c381639d071255e8bf41ab7b9b9615a097918fe80748e893d5ba7b600f3d5ef96ec7247e3a6438e543000eb592e58832145904b5816347eb8b1c9b2c84bb3dac81f7ba1ec576271bf1285b35bda0017e6ce91a0a22c2561eefcfdfea8456063ee9dbad50b3822e1ee072d68fb00ac07289b460b657f3b134d0f453a592ba1a8a75f4f2b71ba5963203c83d28b30b3a8fd4b2ed75f4bd52f411baae79f8a26d75bd4712eabd6a97dae7c9b414c300cf3ad9f1a2921e89d078f406decbe6257531618c88779dd86ce097137bd0e0317845e2252ef2f36f28bce3c99df9a23064bf671e6fd58490b1e1019a721308e847d13f60a822799d2df080e289c0041e447592b1547f4f367aee5e990d9a1e55faece3d0d5aa4d60ea0f22429530e841eba41e78395200b1ab930f767453b21ac612140d82e914b0232a24e71343ae0709dcaecddcd11920b7f5b68f86eda15769add4f610e50ed76cc7a17af2acd4963b7cb146d32dc706d282a9ec54a4b27595213ffc1c7de1467976ebd707fa5faf8ad5fd4ac6813b09cf2031d033ae53bbea21b4cc3c4a45a6b2fa881efa09065c6d9bcb13b1dc6e67f862b8233d810fc6328b035620b45571a6728b06a472e36c2d454b69c63d7863bcff651cca1dd79cf5b9f6450be5f5e1223da1909baf8e92c7e576fd9cff2f2b6ec2e578ceca6870c5566e16ea0832b401295693f37693556f6e468d7ab71c06e390cedd5bd46cf78b02ea6d17b9f1cf43015f151561d36b843de790e1cf0714a8d558872c8e798f53e2b4b66bb1a7f31c3515616025785a545338051ba0157102047f3af6eb0eda01dde414ec25b7855332617448fae1ed953a7951e1471217aba2f6103d01a14ae8fa5f9f0fd47b376e763be1b6de609ba3cec71bede5130ceaf17f11528001a34f964669ab7ed84ba380869a67d68cec36841e887c4f7b39e67ed276c6eb96690c7119569ddefbac6bb3d1abe79ce53ba6394ae2efcb0275926611d6d8a3ba7bafb1ae52e2ad8de7517669a081b0b9daae7cc7438476640c274ca6a4cb07a6993313c6839000ec698208e71aa877f12f6494115b977bfd5728f9d5ee721960c8439e015add25bb5dfe6a6a812e0f313932eaf91dd74221154e587dd85ce1c630a2b317dff32c73b11ec0b89c75377dc7b09b17c1f24216729f28b9f099d3f764fce9371d42a9c2ccbc58f38da11a194a26a5e9902210d02492be501409303c1d47a6b4695ae3aa920059747d7244ff9c46257316903193501614d76c0cb3da96258ba779ed0cbb69a57116cd5ce8afb038d0594f6096c099ab302837e0f347c7ce0bf6705015040d24305d10a479b472fbdb3a1769f439d683a3a1dd7d755c2cd6b1f4a5b6bde95ff8348f2cc98f900a1584c0d71f2142a4dc821f413338a9dbc3bdccae928188287a1e9a202bb0f7da8418a686302e6ddb0b931cc33f60f9056433cab69528a69c01e1c7983e680d76bf846ceac31044d86bd3da45f8d4cf7d31bbeeda4c924e3f9b7ff5fe569b26f0c4b5cb0499b104b20935d9a4c3eb3913dda04d0ff1e7c2b87864fa7727b04b364bc29c0ee9f4bd31d0d7d0a0940eed51ed377922ea86c6259010e477ec6e6f1b52a8f89446cfb4d203f0344668a449126420ee73e074128b5fe7dea889cc347e54e7205a03c03df1920bdfbc8a6c83f6a481e0b1dd1c5842f339b53d210a3ea29d341066bd43fd60d27a9b772eaceb36106afe0a634a5c6a2dfa6d6176008dae0ce70d879a1f97ec84aac219af1ee78293f2d8c67b9bda7801636d6ca145c09a88847ebca736534dc6fcbf475a138eb04332e7d0ad89e317ac8cc930644fc50b981ec5cf5748aa2ef6ddbad08b26428281de3c819615dfa8c75bf6dd0e76aa852a84a2a0b5896468b2c53b3d2ea3473767cec192b1747fd5bceb7123bab3e02e38c87dcd58f59829f7fd22b4616f30f816d7c4d6fc07ecd0b03a81bbe0fdf487d1526a4a37ec9cd1d3d71019667e50d95df278c4fc1491e364a1dbbe76f1489cdc2a4ad18f18b679687d0247d598cf055a863b92236133457ef37a3f824f16fcd5fc3a87d89dddf5c631ae0d9f3880284eaf3c8fb52af778c562310741427e85f2850fc49885eac6f0166ecdb50fee2abc9ecbcf854342a82ea8dcf806d8a71f1e2593c48bc1a5720ed6a55f3d9400765ceeeda28e43a8c2b29dd8791972e1e0ee8c9a7a40974e54fec1aa8778c5fcd9f8f7fc05359d29ee7e19b67b63d48e1e5944c806e997c1b6287ab28d9756b8237cb6261bd8623b2918503fd46d41e530796e5b8005d157c26a74198cf538f78f448b3f26ac2db1575bc3ff7cd882025b9e3ebac578768d14b88fb9351117b22c3daee45e587e8e7dcb1d069dae32528bcefb11ae9d749981151544750f02e0df37e9233d3b83d8fa060cdb2cab2454cb142716117ac3bf8ef4d126b3981539a9d22554b46df3204782bf1a499bfb068d7e64d42212cba870a96cf8284d42bc29e17d3ed1aefe844070b401e6fe1b41ed89736eb94b26a136e93903ae55622c6a47483fc7d1a8f9d477be00d02776a96a0f98746663e3447c1795e791c09f750d0fd1161fcf9ec36b3b074239fab0a48ac1689f168331662c6ac313ce8d249196b6c2e3648dc9878e80eaeb9271a882de40908ebaedee2d4bc0b5836ac16cb7fbd4f846a4bb7eb4fe25375745c59e8efb7da40ba58b7c6264a9a43f1e4da2beee19ada5f3a3f05a03bee57fa47dc1db31c3af812ca107c35d0a0d19dad3cabe8f613fffa7205df21082c6e74bb7808b265fa3e3ce4518641d22561e130d89df034c9b6e4f2ace03243a7b65b30c9eeb39f48f5bdc418e7bc691474a216ac8e05d9eb21b3a246706e9ddb422a75fea0240922419578a7948060d733753384318f45447fa49f7ba17e73b0a518a7d2ba9eb1bffae74c4cec36cc14d8c1b80f75f0b32055fd16db98c55dc68c2ed30ecd3f4582202971cca018244d682137dd53c7ccb0280a0e9fd432572b9b583363bb2c49361b6ac72df51df6c9735c5ec4b484478d11675f07796c92bada228a753b6d2eb9981c26d80ff28e366c3cf56a0d478d1b505742d9db6f0ecf2f665e0027df566a71ea1e732581ef6902d5f69b7e262597a2460bed17b622ee8d2f91e53565a5627fe8352e160f5e4fdbaa0e4ad54bb315c7f492dcc79b022634042eeb0b934501332c792258827887919eb990334bd8a9746bcdbd1b88ea7bf0cf0218696fcc264effb67a64af625c5dee8a4b22e5e4065ffc4e27c9af149915f77120da942e12152364082eae61151eb9730eb257bfdcbbca877d9843f39a8f667b56ab780126425530023c6036c05182f4171717e37921e07fa27c9d29bc6d7f1b9db9598bb401776ec77641e988ea9c530591041f0a422ab0a70dce73e59431f0689bf8a6f049498d8d33e9369878458e4a64668010ee0002519725b2742133a9467ee315f84ff9da872e5c992421c9e4b2c8d42faa80ac415d43b3633b8939107096b048d63297aad00d33e4b77e1fcee01dc9faaae545512b64b799d127dcee96d96cbbd3b1c364ed16ec0c2752d3df1241bf60eb5a91273d586a25aaf97297cc34808157f2685ca51a02f0285ab020b55cc7eb96f725bf7ba4b9b27d5ddb7d585f483d7ed23e7b5816f01af8b8f5e2239ce94958d762857f6bb725e047fb1f0c54f194baac508a2dc9b1086cd5cc6179ae59bd205e243cd68dec66c4ca5bf4950b4e7f151e51c0a3e885794b3a40491d68fcdee15d64aa5d30ae3601b062c3a2bfbed2bf32c1dc02e8981a8b024dffd81b6ad4d6cdc80ca17f6f1c760d9504cf97f3ba717cf97a206d52f231a282d6fe57f165ee0ff80f167a067328f09e1310781ce1bb5afacb18bdab4ba9f21be894a09f1ca3d3c8f6d4ae839735fd8002fa3f07f68295a7a70eb9529dcb79ca48e1b8c579de6a216731af6f85bdb5dbd94e22de7d668a5241de3e317b9d0d2b3600244efd826d1c4f96a711c1de1a938ff26a1cd2e506ecb869b652eb650eb1193f4fd1da73d7ef064e06ba1caab1baf6cd4dc9dc9b6dac58621b2d8c979f30278f5f0f69629ab1a2704da3dcf1739591cea482e51eadda153c9c04c8003ced781bb3b490313086d463e0058dd24bf5032da60104d299a85aed4c5230aa6dfb7bd9bb5d364fd08daa1f2f4e345785ac26cf3c3f2dc6ed1d9cb2b580d5fd4f0899f6e30e4b4610e6e9ebd39dfe459d8e7140005a57d41548f69d164ec81340735b36f60f859fb1441b2705da745e5f137c6f92d08837766be7fbeed7c3d93a1b6df57d506692290d5b8d8a0120051260ceeb4d0ce0a06967585fa0c3b954d12b15a1341dba9ac8345d728d66c85265acf5f174f039d221710015e66b08b77641c7b7724021ae026d4867b8423e095cd20e3650903a5e7803ecf130d9e8bf09143a597353c4efd817955c38178bd2417055b5d180117922b133eb7e8c0e789e2feeff383a70bb4e1fe02c8ef6d9f767677a561cc7100a1e0757a2d8e6201e65f48a3c102651b2b8903b7f62ebb1038848230087f2facb3d04531bf1fd6a644c58cebb97c896cf7430a52412fac26be0121ea477701a3c285fbcfdf6004c6bef6ae7dea4270d2a097ebbcab13487c80c464cfcf5b2fa267b7c5199c1ef9ba1f173f0e59820f1489b259a1a497ea2898f0c70c7ea9edf8093822456d875a0012d2fe64a5806fcace44277841c2d904f0b38690672f81f20461942efec82610063d6f792967117108d83f4c55c5aeb60131e2558f0ca8a7b1f4d27bd5c0bd1a786e0bbb52fcc1a6984b9da6b88914be61124651bb476e334eca19b8c65355efc0c561cd06ef9cdc279f4680d2b9ad76b6b696241bbf02533697839e054467a7af203470e858f439e42361e732944cc53a20c063517d3e3b0049fc3947f5b39ad0e573f5b863ad8ba3214600f7fc1558278abed48c2ebe43aea1bc3a48595b30299012335c8547aef01f5349a631ab56e6243104900b79372ff2b58b0d72c55e9d2ce17f1acd18ca072e8f6f509046e66a77fcd2a1bdc0ab143e76a54650a0caee311c562f9a15bbeaf06c950d8ccad6ca2ecbc8f213aaed134dc5dd19fca94eab9dab107a69428b2ca8ded30841efc914a524b351aaa71dd4fc55ff8a0b97db61ad858154d73ebc860637364011fe78ec5651bcb90cc1443cf06ad98a24134c0f4efe1fd32c7dfb4ccb3f333122ca79bb16b14416d21ffec8b51f18a1c257681a935c430a19a7452b1b5ef9d88be65d300aa981993d1c132f781ad0f618d618921963a49642b8d937452f39f35a43c2a52dba0c35c7eadecfbde44b379434615df79a0839406b391415d2bc0beb899d1b7da8f857f52a93f48b5388a2c33d09384fc5ece2b81e331c2cebb05298085aed2c5d2ec0eb419f6647785e39aa5a0f521a247db8bb666129f082b883f1231a4c3b4d46d4893eba71d491c8807bb0473c3410d016c41499b1c2bcdcaf388f79739497a2d6ef193724689f30d37b8beeaa872f8f8c3e4ccb154d710abf0dd4f6baf14e9d9069039bef8ec0ed0cc67612a4862d4dcd19d4e36693b5a1ecc1b2f40c2c09502275faaea0b597515e937a5314fb202fcd44a52c3bd608c2ac5074aa86bc98020ed5e12052e371f46518604beaf5b1e4fa83c3140f65908f203f2ea2e5f85ac87b8e973b9644069eaea5a3034f0b83f2f3e6877e28522e176373ce6abdf9cff5ce89b20a449093645cf446013e94e036923c6879ec42f574660856df050e8b9fab32c6cbc5ef21835e7addb3e67f392257e9dddb3eeddffc7e37d3d21dfb9271c664dcaff4e783fe7d1ba886ff9fc14591553a8c5c146dc02cf2e720eedc2e65cfe64f9d8c4f0b65e0f3773f5a6c962a5b222d6d71d7d54ab62069f4d590c1b604a0221cd6eadaa13fdad040570b7b2e0327b494d157f602633aa8e007d267965a9d16665f2f9ba3cf1232ecca6824ca0b3fa1b1d1981ff5cd897461d03c53805cb5f178b216989a5930d4e51a098a3ac0591ffbacc4a8e9e0ecb8af4c2b71e1eeaa5862ea0866508ce8c49c8a5187bff83f37ce8e3012f8dc225aeae3e0cfd9b5538e077cfee4d72e546e8d071690646be737bf7d9641cc597e9773c1e57e931975e1e60fd8fa4dd6f49a58ca4c66938bb918650e7ebcecd525b4aab74a9266dac2d2d4392ff2e2cd2ec10f8d6ea85b48cf2f7b61ded301e7bff13c0492cb9cd0ea970ed69b530afbb794e2ba0ebd72610b3da61771808e2ba6b8e5936fc9bb9a7411e303a13e62bf71a078815b54746276469a22f1f05c0b97eb1e3c15a4244c950583dd790bcd3919e33cb44d3319160a2a7d0baa816b0963b4141e0825aef7a7bd02b0b461b325e0bc96899bfa5f8d21215bd3bdb1bffcca5fd1a7ebd173fcd47f3a1f351d391f493b3124f49acdba37ecc95e173363b26acc24b8916f1bd8f040a09b6a87e2ac142586b9f5db267a8ebe53567b0ebbddb3525bcebe60f305e60b09e3d9f46641b115c589d480a07ab7b718cb9a77812b7699216ffdc7537cc15ad4e5c15e6923c64a7f366029e92a27d07fa91fa457062447b47bee21717afb10a94ad2c213bd7df9a222d615be13dd827ccd00f1d31b156dc6b26a8239eb9c93c39b4729c5b9a6454cedfe915b7b7a32ff87088b80e918a9ac67beb4167582df8e180865e07eb44229472970e6f29e0aaf65735f3f077d869a1b1444e76970b382f4ca5db27c22d14512e1ec08a199e836f9feccdb0e06ea42726ae55552240a1a4a947582ae40b090af14291b2c8da374208ba07e9ada54cf07f1db9307a411feb86d2c3c4042909cc08acb26adbfe95d059c0dc2ce4bb6ffa325dfa839c31f881597fbd56e3d814dfc25ad43eeffd639f2eb370ace0a08eba135fcf1d4abb1835185392f889466579625fd2543990c7ce58178851c9950a258fa6ab8b0139ecd356d987e55e77e64dff9feb60a79711b165b779bfce71bf464823111d1fb9d93d350a06423d6b83732b0b92af7d95199617f530ba3c5c5712ae5442d2f9988302bcdc1ae45277466fe3a79541da00046776d6ea6b5d1b3f8c3fe192596757a34617818990ac3dde62062cc8a923e8e7ec3d59e77f6dc239a77f30494456c4f838aacb9cba156a14db4c71d66aa8b7ee0800c91357ba7d89c3ded8f266def925ca1252c110695f06b71d1e312dd9cfabefb9783332cad8e6b02b277d9469e8200051b12b2739cb7a1e6f6881f73546004e4e5065570a6e2b4a130cdd998b85e1998b3e340b287a8217db7dccbd584d4e7fbc717c2f71fe1773e4413a5707f2c50e1688f6046bc21c3875db97a6afd0b62621d5ff662eb4ef0e91c7771470bc19ef62a20a6d145c09edf3586dabefa9bce4a6fdf83a68c35faaec3265e2363611645d9d251ca446eb6f5c9cecfaaef5d91cde89d72fd8f0ad9683792ead488cbe28813d09773ccaf49edeb42581195131ac93ff01d64dc34523b8ea13fb76f7f7998f5c38a47d3ec09b0cdd450fa7bf0a0caf3a5eaf28c564367357ff9920754957ef3341a25d8e1d2b55017a10d9b567ac46d2ce4d258275762ffaf6c3da115ce1307239dfeeddcc4a22a573b5de4122a25036d54ef228708d650e7486b37ea29401d592c9bed7efbf6f87b0407bb5b1332709e67452bc1a684a767a2e57cadb675f24ad0f6090cf712fa23bc6bac5213e226e85779c6c3d9f9e9c3ee4c5c70558e4f729514a7c16f4d313e8c1d7c70da6c910d053696ddcf971fba28e3daf564edf6f2486da9fe19eb443f0ab430b34fda38927cf1e56d311f2c9d4ea1349cf3d1be880e42099b8440cd7f082bddedf5cb1c6d07bfaa8f263a674afd700f7bc397a32beedf858f5259d0632908cfeb0ca34a2a050da96ef163419e60ba00bcde70e1a5906f10b6d5982cc0933e7e637e1ad2ebfdf20a1d421abfd94801f78d309b4f3928f702dba54bb90f257e1d5104e08959a0091046eee34032ede18e7e267552ec40b7fec329d854146a49e4f32ad0c7858c1ba162000bf5b0d3e69ee49cc18a00eb27bc65c9f5e216c506eb1432f2be66aa37b2a5277ee22e36a647155daa43f57b1b8237e4e6d457903c5c670ef4be7753f989f1b7eb716194223581f1d55792bc76e30c98ead9825f242014b9511cfef6bbf7c3b3e3129b7e2ba7a691a1c8a4a6fe4850a2fa131b881f171d46ada6735e9dc445c1e41c34c920242c5e11b95a46e816f41a66454697754a66bad4a2c0d6f7de8ee61f3bd7522e205655fe039f3f61b55f5c9763ec7d56a01a3462371ea32576f329b23aaaf218d927a3c05d8a4b20784b2220a1ac7fa9bc57e0637e6ad82f385b9cec4b8aa483b6276594bbbd21b460441d66a780f40bd75dacb947558a492f8da79fb7782fbfbca61828b06e0a07e40c8fca895a9135a908c3b91bddf885d14a4d649bd9370b3e87af8224bf4402600aa6cb940a4c2c523189c36e13122e6279f13029f444a12405d11ad32bbb0a181b17aba6377cde09e978eaaca276ea902900bade58993fb6d2431afad89c34fd41e10b286e2e9f988a1e35bbaa62a6313a5257e95aa2b7aa68c062e788bdda94841c5205a3bd22ca54ce658147c075114572db26f8bfced3d429a6f34224c5ac30d4bae0c0385c6814988ab849751fa01c9bcd26212b4dc566b285b695bdb8e1fad87156ed2920787f9683b7883c14eb5745e612a67a8cac06a5d61b76b0a50e8dadac0af46f3c51e01c440ac8e3aa7cb61467a6def25ac56055ed6b640da78a0dd0bb2c49c935d46832da79762966a04c0f57faa37d4a00b94d2c7ce2bc395d238c57112b1aa2bc1997ebac8bfcb9752029c1ee0bba43de40f03c5bb4a3f87160fbf6d6e64328b898bcef270a4d6fe94ebe7059d2857d7bf6eea74b3134038b7db6d75c981eb227f1df590ed9b8314c8b7ba16eee0dcd4457ff6c117241d8e57ef0e7e8f13918fd2977d1654defc1c4ca977bc15d438b300dc5f924c70730a24667b3cc32431d984dab3d6991f9cadfdd37e422ea66f38ac6bd1714b5ea2b7e15c2212eb09c34317f2ca1f1ab23843131c81b6dc8d354bb5bb9a9e23227214b98249fbcd3cb8394e0c8a929fccb345d976c41fe813b55638cc3e74f12d914885e684d4a4028f2e35510df62865e8f3d1c52c22eeeb686bba94fe104917e219bb78c36cede949db954c402fb25545cf67f25e697cb9b4762315f8534d51faae0222d5f892ac121908efba306e64acb944ebdf7ca8cc77f79dff498b9d62c5dd2fba1aa7c5a2b4124c37378861425e340c568d1255cb0315514074af02101f416e03abf85c5002dc721aa0c6c67647f2b24b12fc30ed192546415efcebde350046841ff220e439b317d538194adf498bdbcd83525bf38475dc654e9e74eb6865db0bd98f251ef7f9b6d214ca0ff6b830fcef9532385d387f4b565fac3cbebc9ea8f0a796ea7045b6c246452712f7b60028977ac29c746217c452d088ee44a7988074646297fb8017e3f0d0c350e44fc012d1610eb3f0961cc697d4ac9dbfb32383652ed7dc81f68e3d12fede9e406ef1a051ea83dcc08226fe3b66cce76cf91bf32a188a93553d573ec5aa9ba53478ab1a58efeb3ee56d439614cb24888603eb09885eda20030fd9fe511f816315730f69fa90b67f1ef67f014f004f0ebb6b61fb4f333bf0a084e040e3f38b4047692a95b461bc8b6eac3406d1af32d31a6c9b7e95c9ff3613893630783e3c3c5798fe0ad000bf36bd548db7358a09cdc61e6a7d675c5c4764bdf629ef48b6a7404dedf190f111d26915cc507c8e30fe89413ebbde9f54f5ddd876001b96dbd84d865d0994baf4d12bb4bc580a41b5953853adcdada0d80cdd8498efafda812ccc13a4d60262f64e93290a6f5db799d17a0414c98c4887ee898774098747996fc403c0e8232d4eaf4abc6673682139bda8d230e641724f6b76561280d6c47f71c2000a5e6f42788ab15b24182038cebef5a5fb500215be82e4e58b3d523ae272b8936846d5aee464e178c62325c1bdf95008ccd276e1bdf8794135c0c304108b9ab3a25275c5ad31f86649efb5784eb6f92eca7b75045c9ae16022f7c355d325403461641d3346d62c3bc66ec0b40328a3def5de8083b48a22e6340c743e8dbaf7320428ad1dd46edc6d8ab662cd4b812adf9a27223314848944f0ba6f18674755541fdb1cee706c4de6d3a0f80402725ce505b0f0e37c5327cb4a8cb68cf75525d15bc5f22dbcce4ad5179640f11f00e7edd4d25b96bc43c63fee4242407d8fc68130ee216e7e245e48a3ef89a0a6d47a32169d19afaf567df8903672ebf15327fcfd9811b68bc23154d8815ded549f746dd839e4c9343c8d0981dca9f1627a8fe0651d3bfdb1973f712e030c46e8a369f5e55063b6f28aca074771acbf5cf94d0c6231d59276c8c5f73bc5faa13154cc4b0e2afddff296478a1823179a5366ec06357474133660c6e65ca23dfb753fed69f61141e5dbcd16aa723faba188033fa45f6e8502d767b50d1d3bf8209bd0eb7bce462d579d2566bbde532a74ef004c748f4151f8f286fa05be54886e09e98803d39d477b9a2a184256b2a98ff9b6ff06e8721ca5090f57ec61ca9d36f3d37ceb0e643288cbecb443eb9d0a00ff9ed13365eadf8817ac5e34a581921cbab6d56976be5cfcbd8fd3c719df4d30361123ec75b58b17412a1f6e79eb81b8e515376c9e003bc07a342f5ba781e745700e47066615a27c2548a25d9ecec9dbab0d7184d2bcf10467406b1bf0f6f96eb1d430d8eda62404aefc87a418f1a26e40b07255737810f715941378bf6b54b787d6967e5b2f4d95e08de368cd94ab12e8f3dc6501dc5d1260bf77ae482f6ecc33b7646d08c127cf370ce6690b62faa449b1b9dce1f4997d690541d2e5433433118e8d1752e97e3615974c4f08236614e0acd97539cf8aee73afaf8c8a1bfc472c7bf91f4119fee2c7524eda0e06c092ee4a55f0d6c24abe9f08618f03c4b689a452d5ef03de8886adc66b0808eb0b22d06eea1b449695f2190cbcaad3041a04020f509525fa96d4439e6872806c8b3fcb6f807cf2f0429d4d8f9f6fcd1063b15a237e6f53329a00e8636f9f27489d02dedd0579d065838c6bd47ab247e746415d0b7851fad7d5b2346c5597df55d9b7976f448a4c7986bc4aa5f742343a2cd1e9e6402909c86863d1566300dcdcd25c51065912e0c8bc2be330321381ddbadbcd5eade69aa6b606bde896d885b077b93843538286cac14ab3fac44ec0977cab5fb881948ec6689c128b396794f1f6e2ee72abd843e50926a7d7715bec0fd1b7a324f9970e8b5a0dc42dd34cb4184562154a9876eac8a25090cdaaf06961c007f24ccabc274a1809f4a727f0728e9fc218769823979da501ee6dde5957015664ca9da87e88d0a8e368326cc8a4e9b76c31fd66afb1c53393f7ecbed0277d30ca9d49ce6d0b78a2888d7ccc2189e8801a95f2d29829f80f18b632422cd4347f40a791d5f9f2e544155790f363f93c72253a7eaffd73d9ad8a3a95f33ee1a8fef5b3d09c4ee96a8ed251c7d4ad3fbbf1286995badd8499dfb79474569596637bd603cfbd05b72ee9d3012e026e87a935df2731baac66da8cf0ca55d64d9fcdc85fbe695201f4a1b0e37d080162119820001fe63ab9bc4a81032e5aab2792bd1788adae86228447ae1dbf5f1d426d35f41f17dfbdc0ed131a1c7f63b2d3c5745aef4a259816270ef1ce00270eaeca964f461a56ca22da816726fc9d5eacfb8fcf2e1ef87438b825c0ae25c307a1a6da636cb3f4b284a5f432f126c151c00c45e93ac1e2befd11fe7be4e03b71b97e348fee7ff1477ad1e376ccf7606e56364ac39516b6ceb51c996c3d7243876bb39cf0c238b9131c4b726ab0f7ef91878e7eee6478c02e21fb43e887148236c6277a90e7f58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
