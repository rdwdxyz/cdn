<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d1cd0afe793b92534364682831f59c4275c0864d87735ba3f9266df9bca728cb281f940b70b8bd23da342e1a3837930ba273266c9ea35518d549efb05fac2798c8afeafbcca8f85a064ee4e855050d62e77c634b11260f04b6d5dc278cf2c39b93cd8c49dfcb46bac8de08c7b3720e381b4ca3e033db38bd7f077f74552cafe14aa68a0faa8117be99d8f506dc3d776da51d82b62737f14ae5a1638bcb9caef2c7f53a6d4eed89aff795b04bd196b393f1e3512db6b33ca66553ba4391cc4a7dd1460dce6bc55778bad1131cf857c431d756e070396654b32c1808ec4a76d3213ebbdb5b4d204b41dbe6b8fcb86435088ebca7c0c82ec64f150d23e82ac152046296d987f1db1c665055dffb83ab1a7cf04392df92b75ad813d597e061310a7ac35fcaec5201ab7a9b905602f12d229ead08e995079b84189b252c970b6d7c813d0fbb0b69172e8ff1f90eca5382d2455f49e8ed8302d6d522ef80473bd157ff25976d14e329f2aab8095fac04dc88173c55299b3beca48e1c03f4dac58a8788ec06006d09db4ad453f37cb88a459f68ada7ddd1bc06df9705116e571c77d0adf9bc2ca5b209ff0f8f3e1fdf466e17ea07fe189ed1ac39e26d3651defda5d819ad3a35fd89a8266b1a164c29e651c03df330ee3735ed9ae90d1b9efa80e280115a740c61e3643b17db46fc8da50fb3af97549affd71cf1ce1bf7cc2beacb78f4a034b77bb5b92de31917fb73308f62b8dfa8209465075096b3dc2eb6dcffda82389d22789707a448e4ca8256242224f9d743fc655ac01fe86c00e0e5c6d2a8315b36549fda6db0d1dfcff179cf658d94af49e7aac534765c05547b8f4ec33b8a07106180781f9f8bdc040f241e2c99ef75602cb7fbe11667b7cd74629455b411b536bb352bbb2c13cf6cae749e9a9aeb4d9c76e45187637b56bee7359b8d49ef2cd2565d75072b9733fe4ce6edb76f8588d3790ba615355380c1bdfd874b00a8e772b76ee780f85b5ee1188db32f4953c619100e77fab7d90abe8817e23aa7d9c6b25be99fad07d75b7d11b573c40c0d83735c3c0c5b04bccdf7be89f79e25d1fcff016d55e5fd1eb8ec6ed4bff00386e885139fc3941c938f856017afd2ce354d4fed25b38dd0c1fae7a2a48290817744347a639b8247cc51fe08cc9446d2154808c87b3e62a2b5e073d90861e8cb3fc28da7c1c8feec85979324c8ffdfd63755dd468e4205f8a9ae6e226eb3ac742a63694e10a734bccb4430774aaa24224e32565d0a01dcae37615a9adfc93ef00d0062ba90c02a0f80a65c5e3c5d73f1143a726d752e1f6309179ba366eeb386ac9aa20ff685572022645f77d8eb0b79e44ad0462a4cb5cf7aa9012d5ab043ac3c99f3edbdd9a429caf1e6b82ce1e4e79fe8adb5551a44e5fcb988b71003e0dd298efd377e03cfffeda1d8fede4c01aa64b10bc1e53f3182573b4409acb1cd946355e5717ee13d4618bff765a4bb72138cd8572f530514c90c3c68b150c8abf1d3899254ed794d771dca43244727c817b46c10ff4c801a1ff291c313f92d183e212c8f66a1c435b15827a9f72dbeaab8205941cf0d8aae3ea341a8be97d3e1068183152b46c364316e0578a4a54e83a48bb07d8f1cb0b3253b774bcaf4c7da205ecf0bbfb5dfb7b814ef2e5df8e4b0f56c2fef41bf2f9d88e453874acfac6c9801173debc40caefc2baa87352047e5c511df9aa751fa5121f6827194a053da5a4c4a734a5e9a25c90fcc03b1d13e8a833346ac37015dc836e248d6dafc06d46b3421f77fce8be7bc32c382c057a98050405c5166ed286e11e3b7c26a25e7f3cd0e76e0289d98e94b25c380c28cd6aac5b99bc4fcdd0811e73452ef0599028368c26a0d4b8612203a2422cb62e1d3a4caddea29b72982efdb6cb0942c51d46e3806277a0cfd696de2c9caf59b8b06f8b21f4f5297b42659edfbd1f79e2f44f842a41848634a2ac7c4518336c37f3689389ccc06b6ae79bfb51740b9aa7d590048c1e28ccd0ade7a1edcb381139d6308e6f18b26d8c75049556b77fd2f856e97cd92dc2524d520b528bf96f71ba1512de66c5c71837a4d4adcd8f3346857b71ee046a40edcbb10516b4b91c14706041d14ab7607fdeb34194ddfd7e7103f1d4dddbc71a392f9eb790820dfbc8f74f6bcfaf6bc6ac7c03d03975032be1b85527ff77afeaf6461f8f75b5b96b0ca37c95abcbe724d5f7ed8ca11d0d4b0cd6444e1e96eb24c60974a0ab8862d65ce93626bbca586764fbec9a26c8181f34fa67d04610ee84c948998a56ad097927e2312e6b0df13bc679bc8886d1f40ed7cc2f1fd8c4f9d1ca9526f98f744f2bfe2693072c3aa3eec1babae413f9c06ee61c2759882a7d5247773c1f48f0db4b8397ba68fade700644646ff0fc794cb2c5f54d08e78ff5343bd2a3decc30adff74fd7c2c2bd6f1e7ce67a6dd4c4d09e37bfcaad8f8a7550bfaf14bb6fee0a381c085e0682111b1509911c76a9fea5e0e03e46d4d346653c0ed2ba69396f572c9a91e007f04cc1cb4658e949f2d86cdd53df431ee1fca1d361608dfc1d630a3b7f805a1e4516cb6eedb7405d11089df0d0a81b72638212f310ed2f6774f44c9db5f6026c49585c5dcb09a603eb6a5eb038c66fc395f98096e6c340c8a1b4163f15de0bd1ba0e9ef704401a08ffc4efbfe7060dc34d46f6059cc45725244b3e5ecc1de79737d26709fe0d93312d8e85c64ad80483c61a3fa18b840a98db4ff1d1059a4136363bef39f735c16b9f1c1b1ab98412fdbdb4db95d0bc5baf820f052acec62507d3b89b30b19a258a491bda515cb5a59d43b6d9c681154c6f62d0d72aa226e37d435e83a005e73bf624bc7c8f81be4aabbe37f34d4b318b61cb1a8e9d2104c8e1b03a67609c49614c4ed2d852a2889211bb61bd1c4f2cf410e6738c13b8ce4e1577aa581585c29ed71239c0a94a88801c36d526888932be15d246b3c8376b00ac5c1ab0e9d2b62b2b3e1f72847ea5b952f7e8334ce886b642987565cc0d70ba7144912fdd5627c7266a7ae2bd7936a46e20b61f48632edfff617c21044ed80796019a0835cb37c58833f54c0d500f952bd59b6c82598aa8bafa1f6ffc9c713c2414a35e6876e530c5d6335d990022d1abfd8ff5f9a10b3cce1a15251e017c596db65fb5861f9a599a037d58c75a4074bb1640481f902a01eb277e044b347ef4f6ac4503a13649825b5b853a03c28b7f9d758cedf02b3ee7d87e2671fbc6979af11f8454283a4b8b593d677dde4e39c5d9bc012cad454c1d60949fee21d1b7c3e300fdae206681bc704034b1c442bb9843e5116b5befa2f1011131e9e46cd5fd50e7dd7e47e2b2a7b219eef91c67fc913442f33b617265d00e64e2096befaec53db9cc2742c30811500eef0e3665e41663a38af1524b9f6dcef442477e4de49e275ede1d676acc4c10fa2da2241c3b7d2b0e24553a5a79ad06b74449556e51e03431892f08aafa45e06d8ecfa74091f88a77c30703dbdc9ee0230678d1027a3c431cd278580b48121257836c8a49fbba8f163f65b4eeb806efaa0334e462f9136893967d6d1653488aac89f988ee76069639228c6042b14746a35db31c9dd6de7623d9c1fb72785bc7fa4232b9c761a241ced06e7a949a852755fc297f66bfdc456de2b3a7ac3113d7896e2a3b5aaf2b9a9e32a4331fa7831e758b543aa5676e85d3f4bcfdebcf0dede30e5e15fde0423850b5a2377ca4c4076b47bd73949f321f29bbf3b2f30d277f908efb3f695e506c4675b790f06e65192ef037cd9e9640998e26b5d8d42da12f0d519fde798c888980708627f690fd1d99842f70ad340919c5df3bf65fb91ed5e5d6d15422517de4b050312bbaf3fb9cd822508b4f8147a027261ab502ab49f7f6ec6d7a1a7410dd0488206226b2800c99127c45cbd0e9e827488a71807ea32ebe87224590dc1f555cbd3a65608bd7924c5f53e4f5394ad489a68394f7bf1f43284cf0cf29cba03ccbee173112ca7345e5a56476d6def9b6f97b825b3d08dd72e8d9d3ce9dc856e5274eda0af8dec603d9187c68e4730b239f15d0b72a61bd77929b356955e292d280bd8c5e0cae74489b000e74346f631dfa2bd325e78e0c011cc3425b0cbe3755f08e7398dd42f000c5b5daf9d7d9b9426bfc228b1fd2b06ae7f047b1f985b209e13ef4f4a6f59f0ab9c1f59a7053ff049c98fa46011043ffe5a5f6afc9fd6216d89c5c9406b4f67f37cb2a6927f207e12296cdc73d03ad7e5eb2addfef918518f723a4f499e3cec6bd475547be8227620cb3bfd9428ff42dc3860c926094de0d946554d6a7f0ff23081045e9edccb6bd58f4b38f3fc7832c4cf29bcbad053f129be7cd5308513c9308138ee0cb0f5be7ebbf9a2a44e3ed77f4c7cdef663356e7f13c3d1dab37b1139d4ab9f7ed86879c1c41accff756fa65634dc80e43c03dec8e50baacbe61c17e1299991064d0087001070365127024e96da5c29e44476e566997bea86320a3e8814540689831063d6be48b617f529d8465ed619ede594f55418c9acacf91230dec88e8381256d83519216c27b715d42b85a2e3be1a618236f4788ca8cdb97ebb899c6076981b36f64a3ea38228d08abde7ddd5b4493d7fc772a39bb18c7af971eecedf8f6a460d3451d9c6bc9dda45d8f483c1a2e30f469759d2281bbf4e27671ed174994758618e970be6cd3021869fab13da334e0b4d524b31e4bf2cfa06d75dffbd3a9d8ce3ff51c4c02820ddb359d52e115a295672810584523a72fac9a4e58b27beeb1298baa9e960a197d80133a847e9632644f687453dff536b1f58025dde6e4dcd331c015e27ba6277cb55a7e9ccecabfaef8d77004d937459fa4ea710692b6e328612d25306c6439bcacaa4b917ebd0a5045b819671bfa8db14900855356c9caf704f6b2102a1fb0749b1d027adb10d9349e5d26efdae05dca467e169f13d385a43fe0737a802a91fbcc7e5c8357dd33c6b26985e22df2f1ad3a2fe5c99943d918a9d9b2d96b48104149f8de8d1e70e26941a3aa591dfe6fc5fcb3f4c52843ae323c93c76315f5d79bbd1a14478d5a90197151ade07d42ccf46867a781716b79779c7a2d4c354b49fd398aead8f0830dbf951959d4d0fbc914befcc4a8d7ddfe432999915debfc55db65980af661b883e17c3d7e4b5b3169f7d5ebdcfe5e7c2c99ae2f4d0d80266647fc4bd021132a5dd5349aae1bdae6d7fe5e3fac8738bde9d8495e1882d61ba0a48491aac3f3a312f0af4ea53dcaad0316cd12058ee001521ade2e90ea1bb81510fe9e023819a25d0a2dc071b64e2af2b5b47debdc146f2ecff596ec86545ad420cbda823e65942b931dff56694a71ab4d6b5bab0a9d54a88ee4a9decfc3002115b5649a36ef036a4af4df673161f5b6ac77c4d971a1a5e2deef9d0c6461a081d07dd2622bfcfc503f28241c32e98ce9bdeee92c5dd3a1f827e12a16323d799294c2c008288d93aaf038b8a533be46402a9f7a44ed44b0406b227db363d0101a59ca35915f5021d5a758d629a1c3d0f016d556b66cca7aa6875a0000e9a75aa7bb6ba41674ab3b1b80c4609f35988d7b289d0772ff47f8316c5669c65459e32bf4a9496e793ff3ee0d45e7eb22c01cb0b414f968aa0615c36526cd902f5c4a649380dcfa7a50fd570b63949f917868a1c9b4a014c8597612944b73e9c4431e38fd7041acb2c29bae29cd327f0228b62b8cae14d394ad761d7532294f14f427bf03fa5abbf56e48101910cf77651ed333d2e84b2f3301b5f13434743669e2bb224a5802ac12464d344384b3321a5465eb56e9c36225e2c3ddfe96fb373a1f9000197a8383d598e7b4fb0c100a589839d2ab90b716ec8ee54772644e7985c2ce95897c34b9e218b206b48666f0e93595237b86a1a9b2127b3debc3d9a1d84c9b91435eb05164538ba31d25678bd08accba3020022d4d03e754f48e4da07099167bbdfb4178fc6a3e633b60f42967d7bad37315aae7ff1acb825487ee983477126d673955ee823663ae1f993dba7506bd1162f0b8f7323a314012bfb68411c2a3ece081cca86a659f99f54bca1a943d99fb771a883e364a903d255779b8e111889bdead07154cb4bb8e35450d788eacb801bd57f5327648f7751375e98f54102b63eabe8240fc7cb25e1da8b49c17c4a5f3a393fefba311e044cbbb98aea03301535c8d34adfae6f17828e319b397e95a12a4662b0d67936b61d810a609b211f84e31c711423aaf782a375033056a85bb475f79ff93f13dea0bb525df3ab7a0faa7fe9b6b22974e56c257586ce5274b73ba855c5dd2a974d1b40b8e1da9039ea3110578f2a65a5a830a688c18d3e218739001e102eef90be8e52fa99158847018937c2ee3e0294e0179faa246bdd214f8a8aefa9fe7ffa58c09e617d39a94ff2c874665181b3c9e73c9e711d8bf27ac9415c6d237c1751fa8cf8c7c0d7377b7a58c6b477027a71ce8bd97fb2f91ff139fb34c5f15dd172b5f1dc589bf503b5b64b17b5a5fca98e9a2b8633557fbe8f2af6c330c3d951bfec534750796a6fc0744efb592f7ee2fa8fd818d9e29325858847778433e6b46e37d2ebbf1cc821df8ebab101eee5adb778c27d4e7ae75fde1df0aeef662a29b76e2a9785a29f5e8a3807e4121b605d279ea0a390d7794e2d54388ff79be666fb5be1f03c34db6b4c4579c5396dbb91b6cb114d56fad5f98e3a335919606c51510698f97dd1e501864fe78c66c26fed2d2fbb9848366b526b7854156b4678862068eff945f2e56b5d1c75b3a3636c83cbeb1b49a8eb363565c1160281eb73c72fcf898c8a43da1a5616618912605d48b2a05a2b278f70eb313210a0671d672bc72e3af911e2363d1ba744933e7ba9184c657517e21c15470b477e2ed8fbcfdab18cbbc316c1ff3896d6e58b24309c4a3984f65d204bb833a6cba075611d5a7a3e30a353f60a6104b381c1492fd5b9b53cc78ca90009f51c9413f9d0c980e6e6fb4357a41c6697ca07abb83fd176f13a6cb5ee8b76a3d1b84ede693a90203aabb6f5f6bb6c0c39d69c6d2da6132d354ed9fc4a8d9b8be5c21d6ff05e3636a1732b0ef4fa278ac7657a1ef861e52e54e7cbd9831d8ca4204cdb3c852ef153ed0d7145bc2ec6d73f50f85db9e26f9e395cb623b745f5e77c2d0bda6ebdb209f97824de9c1e9ca81fe76ed6e27b6ba522cc5f3308bd2e19158ac4a0753120705669bccadd0d68c07ff86b95f4408adc318e8a1f97afab2fb045f568ab7492dc7058c63256b30b56bcdad04cf22f8d19f3753b51d4baac354121e4b6a16e8beeda62932673d8afabc9afe67cf1ff2de4744aa30c19aa49791eba5fe6cadba5b9fd054760e25c22ba8926b301d29306ab0a6db5da74e1ce4c7d531a1269a53c7b6ccce259674da109a02efffe0a9f85a87b34545668aee1fde606681134857a2194ee37755edef3c0c27bfd16982ace32a796e339c08e2119c1e8c5056ea16199f68a6c968c92c7d806fbe2a51720d789507f976eb45e3376509ed0eef551ec313327f47bf636dd7e0b90bb5db5a9adb50f0eb28781532ddf550d45261d8b699be5270a103250d654b60c0d3f964b5d1aaa5c89da12dede3578e16c335f6c2a9ef3db5319636e5c5beb90464a8d7cda7aa1e9eeaf144fb8cfdb8a62f1af523e043fd9518a890241331da6383419259cd69c10f09c4eefc972da8a8c51ad915c16ad0fa691a089232a7fc1dba34e013247603868a5f87cf11ec50560167c12c1fc2328f364219e45f76d0fee9967bbcb7d47dfe992168fb0e5806cdc84c517578a65d6d067ec830666596c6f743ddd0743a3096a9646163da12cefcdd28321f995c4dc7be11f57b9e39d0367d24e8375653153c06b341068bdb5c712f2b61f708c65c52fcdadf0611a79c4c48a95c1bb34985e4ee7d1a3872624545d1b3b05d6de2fef839b8f5f544669e36ab16431e3b740f97d4dcefa211b392f7c8df58f3fcff9072e709db2f30e5e1dc0f2205995690c3213dffbd5a5e035a466b41d28a0bed465904142879f4f18c683be00d9fcb044355a34f1243e81b8d2e08a745b05077b4248088f5f4b609ed27ab37b3ee5a24ded42d02e6a7ca9ae4f42e781d8c74d5ffb28cfdc7361fc8e889b65fcd5fe75954cdfab625805ff7b318448ba091dad02316abaab0c2641a2c5bb7b593c30d6449791296c83e58f17efdcf47326df48ee3dbe439ae49d4428d8403b91bfb134a70ed5be250e5925a7d50a9a8dd9394c16d8842c7bfba0ec85c3e17f98aed52e928f82ac0c851152bdd2a5c403158c9128aeedec4d471851409743ec7782322bc91a19ddb0b7b2cc6f7a334bd4daf32bdf992668a44735eed9a225388ec3084fd7409fc0ad9aa94e17551026ffd4e7ef3053e66cf92dbf783b58b2b1d452a8c04cf3fe8b2dbd3cf486b02cbbca1ee1849f66feaf12f6342cfa19c4b8373d49a66384a6a769263fc721f282370f1add67330b2f42cb69112dd4a4d0d221905d8b2f256d166802088cf4ecfad575440e13f71bb4f61f2fd8eedb28d51d62ccc71df729c6809243e046a5b7cc7ac590553ae7133d4633034ec2c081222b3d2fa73bb0bc81a536baf9472c63d79734b282117ede632b20ea14e99a0c6f0c36fd6cf8517190e849f9189c0eafbe35c2436fc586ec0609eebd2fe6d1ec6087043fbc33995488022932345a05a43e08e61af232b103cb00ae5c9ecfb157a35e0a4eb450bfe0df6e1b67cdd25820701e21f55d025cdd6143e349e45c9b3ecefd49e6feba36d406c88ad362457098dcbe3f1c72703b0c9116128dc7f6b64a9cf8b745e9042614ce46072f32362c88e2300f72fb45ed5ac7184a128030bd80572681835057e1f95aeaf390cb47545376d367ae7db14ad9c2d107848603cdbd5f611a110c7da831b44e8c678f51aeca3b71bef1c7224dd0c0d9586f0cb53b506dcd1468965e4719819321244130320d37c2946cfb6e9eacdce70618a23aa64f80e1512973b9a94aa5d1da6e9b456019809430aa3bb6cae1259fc973948f538eafd0e9346d70d3be4135ecff9a8f2ecfa7ba41f2553989f1e8f4e52bdfa7bebe8ac0023761cd1d0d1fb04f1aaf83dadef5b56815f98f5710f3d9bc6029651d03a9fb0c19e7f038076ad22124130253665ef4c3d03e713112fefeac45f829c7b7c6b3e4a64b8afdeb38854951905637a0e50ed62311d0d274eaf3e50035f1da8e1c093e05213e80094bec19838d59d81a33c417454d192c17c031542f1a67bb52ac7d4cd2f54bc6f05368d885bd43efcf8dc7688291c930d8935412d438d7d94660a190b70de9a6465abb275cac27e01ee8e6e35c7a33c09ec689891b21c6e97c63124dbe9e3ae350c1a318bcfa71923495a88155cbbc8dce90e3b69529d7630ad31abfc17b1856e671e010c1b22ff69a23cc948491855cbbbdb21648566c96a27a42993c306c6216907fcff5ab52db40a565c783f735516b61fadbb24916f9b85bfc24a87a7b9c49cc745bdeee4d3f53bc285370d4bc1c496d4caadcc6258dc11ad44eb335dddaba67875f567ffad92a9714c4a71f04789a36415e9a5581ea4893916c4cd9975d66054eeaf4ccb5c6aeaa61949888b1b3c55da73d1415ef7a657db5782b55ed42c202b612e24cfed022d3bd797e4d05031a29f93462f779103136cc020a3877422a5ff49396f4f5529d6fb26110e6ae663403d5de9000ba2a8f6da0ce52910e1e380409f0579781b9ce6dcbc57268c9170bbc5ca424855692b34172e8b06d0c79a63d3163ba057faedd42f610974cb21e0f9dc9555012551abde4bed15b2898725c3d58a8e5d4a17e3902775258ed130130549d2e54fca3a29624eb6e750995ac97cf2041fcf39bd34b4e4683aa0e7f175692391541a4ef965dbdf09fa809984e3eeba995c7f017361155787975eb721de0618cbeb8aaae20aa6179d54f547ef04b24f5505a914bfe8ca161a9e3ca7e6a036fd1a071142e31fe9937514ec348483eb08d13ff2f494c22a5564dc9234ca4ed1947e744bae2aab53a422d7648230f655361aff03ee90cf1c64228e761e5810f97f91c66023f63dd46cd7a72102495828f7d0fd2f1bc52ce70f0192452473d35959c6c848d2407d0f5b083f7cdf5d3f8b2fd10137af11b3cccd1acd3156b999c9e8aaa9bb6bd72ee33f499a70153e8ab61a9a4e9cf1beb18ab66fd16de712700007a9c27b22dab5baee92f2005df2b54f4da0e18321b6061e8d72265a938e01c6a947fdb5592cc5815ce2c6bf02bc8dcf28fe0d915efbbd2e82e6da48d61c5c0d468fa5a2ab0387e3f34e3b37c897b343c78383b6416c83e871d4c612fae894376040f45b470227b70bfa35254d7aefeedec40165a3f1df652360a12117a2555914be47d721b36d35e0ece6ec6d04ae91127b6917e7fe9cc75012ed37fd8da39a319ed07b90a0e584c9b36fa17e42b0a4e7a4efc1229fc722aa01561cd5fa5970a1632213b56b26bbaa1a58ccce1574bc34c44f15973483b3a4f4b07819d042f0a0a534d8550fd574110426327cdf42b306081c4b71d5b67c1781c37940a34d1150364389fc88a6d0ee88e455bc4206f79d38e50880ae6eecce032a5e1a10a3d1a26f12f2f14803d8b02dd353de171650e2c89ea602b9cdb79e17d519f41e5600c80c4419c2b3e5a32802039a264e53b8210c513d7232f8201040c70459300c238d8ef1ac3c31a05ba80f4d59ea5c94cf083bd5aad3ba2b5d49dfb5910dd191ea45abcc39b6e9904fee2d7231f927e233da11ed22700ccd6ab342d1aee0b1617f481b3fd8247923dca032e2cc195e0b6e5db9bc808a884396974f224202ed1233ba31ac344d38f4d0dd43169712b69b66b4d98b6973e7342cd5a68a4a6f5b09b4ec465193f0cdb1f59dba99e464cd901eb09ba08e19fc0f14fbff38f634d4cc169b25496db8073a54e19552d1421cc9888af53a2467f8213d74e8cf0cba036eb8b96c79e6e2ae79b93ee9c284560373afbb449e0c9759cd6629a3895c194d5f37b0b9813ddd617fdcfed3765ee4505cac6015282b3ac38ab3d5d9ddcf33caa694eef190a4b6c2092ec98f700b37a6a56aab17ab25ec869cb41a7a02d295035969125e2b97092aa3064ad86c4979b55f5fa17b347219f0361db00b7ff5491b3190dcdbed2056610f00819aae405d93fc572de6cc67f186580af5df0cc444409eea3026fe43fa8303da7fdee0e6a93c26ffa10d7b24255c8e3ef343f40cbc22a82cc17a4e16dfd82767f67fcd7b032f2e2a06c4fd872e784dfd8566deca9d45a0dac2f5ede0dc85d38af19b736d3563ca7ffb1fbfcb6b17cb0e2b561507bd08f9706ec9b5a4ae72d093354a51cad60098275f0f59a7577c9e1dfd53f8c5413d6d04ec400c0ff56caaacdf97253621ea59fb98dbcf7ec32e8bcc31f1cafb3445c762c5d931041bf0e692a3a889cd1ee0aa15eead6930e85c7f7ada2b9500842d352c67d44733a1353aa1026458450199b3d7334a5058f189649a308718231d10d55dc66bc2ccf4151393518517a7c9cb6d5c5f26049e78e7592af944c5dc3f00b85dcd325522832399bd50abf4d2ea5e33f7942e897df0211723542334eaf8201dcc0ca6be7dbeaf447852949b4685645acc80b66055a8627b509af9524f472837df828253e830df2ae4f9850e4a74d9d510efb9d1082f5272bc3390f78401aebdbf0a6061150c9bacb2237b64d85e690bb72f24e8b012fefd5eed5f8c25d2aec19e52fdd79c6f63b884b6618bba209e19901646843d35f1944fa4c9185966ae2398f4fe256d12dc9dff394a2e7c64740ab628565bf7143176397a14740088327f63f97347c1ede4a377e20fbb72a2282facf3cdbba6ef95b96cd7bcac36b7c7b2798d8090832139da073a5f6f574600e5deb286dce989e3e58368261ef117438bd8f2b2bd4a4e5cc6e32892572017e20f139a4c101040f79ed234474141ecc2bb0f072bb460f9ffbb410dd5b91759dba1c648aae661f8b7e73de95fc93916da27dc79a798bd682b5908e9d96d2e50d45ab2ba842e3dd74c554422c4d148eb7f7b9f91fea34e4efaea54799d39079da17e09336db05ad2afe454ed6e3f890a55949eeeb66529b39eddd7c4e195ef32124eb1a3a0ac772096686d5bbc6d6fe410155c1c80e9a36c21a990c485913906a64e1a12ea4def038246cebb037931810b42f4d7ef67eb704807c73db94991bb9b4dacb1d7979012bde65751305d220cfd3db1237a92d08f90d440c84dab9229fd7dbd38701e1c03b59e2a4ed8d20a72481917881eb6f2737891138ffe25291736c2064eba0fc5063cb1b539996ed55267d8b9da5f95bcbd48e81bb600108c55456892a660caa65055d7ac644cd8995e7b7d989f6b73d1cd2723a12165f1a8dabbcbd593fbeb60b484c07cde23b064bf39f62e1079c24b9fc11f63443b5df88bca3b4175953ffe28d85d61691e54f7b6c4194490fef71d3244fb1da648cd6aee5ad2da5cc7e1497249c9d3f12270193b4d9c7a1f1bd02563ee2bf82cb755abfb79579407149d90dc5ca1747a6c9f06b0329f83e4075c7cf866149a96660cdfccd6c7911c9a99ef261749689a604bf83bcede17cfc379fbc1aae49b0de8cfa1ea741d185acf0e54874eb305e9f80dc57d1eb8fa4444566a43720abcabba0394a64681f7ce751340e08f6df3013371d33bd645f10d2aa655603310c6983542cc0a2ff9b1d81111e111854f987f703651c1f553cdb763499517de87b1c1999aefdfc0429dc111699044c0e96e113011c6db61bcd897cb474639155145c3abacd6d41afdddb85c6e07f0da41015718f2d83ea041db374ffd9840fe8735dccaac3f2a0726426c9e1ef770958c90dfdf191ca6a33e5cd0e548dad1523565c48576b95d35b7f7df48d4fff781ce9cf067230c3490bb595ab59547f6c8090bbcf3cbce13646a8b97e29d01dc2854e2b282173655a1c18129403b6463d956cd9638366b34969fc3af9923112b3bc14bbea7bc6f61313fe9972add15b1cd4c12ea43cb9bb05ad2e170a6131d8920925ca028900ffac27e16cc6f3f4deea099dff32074351adabc0c8a51d321691f58a1fb5200551dae40b9518b7d25555a14da365cba0ca980fdcad696dbfa9d213711d9fdf7e29bc033505d02b02e1b382948b6873defc916a6c0efd5032917eb29dcfbeddcd4809e9948c21012785c5be790c2e28a1ff48cfb0ccdc31f4d0cb541d0ddf6ae8ce9d58ce2bb303fe256d9c10ab91cfa7d6f1dde2bade725c0a0614d20bb09d91bdfb6aaf01e75de15731dc24f3fa2a1c528ffa184f8aef2cd252f3e3b496f81429a65f8d18a7ab46565d41f20a0b2ece90f4a97e8cfd1b1d76c50aa7ab98da695e4bedfa4409edaad0ce327910b7219c10e022b8ef8a97a2b4af115f80d7afc0ad08be31f7ee4c82acabb64e3d217b43758cf86902f5914b3c034f3259e30879d565aca628d68d1336e2b199dff03ca2e1c0419c6c91ff96990a0f03504bf2f0f8b68af4d29cbc3283f84e9a28c6d53148f10a5ff6cdce249ab98d7ff65815934a0dd3a8474b60436cc332112e58c31421bd5c497fd70eae1a8b5eb75081b85cb528577d9341109d668b273ee8eaab3983c254cc061f65d2e14c604d537e6248a33db78f7d1ff82bfdbcea5ebad30fa6372e68a95455c3eac70bfd4b888ded75a183821e9f8b6b1ccf15795e40a91fc136c06b8bfdbb89e4d4b3a7bc3b1ef68831711b58d06239891995dec01294ae425d58f33bdf0d596b6af950426ae1d75053d4b8a7ba4e5472952f85a7bdcf139e5c0c4be77aaae8c219922c6b32c1b3bf28433b0e3a08be2f5c81e4b2705739a03aae3c08cafae140cd2cfe8de29c2e4081c27afb364ae0a61a5352159013d9478363799591a9e8c896000b93c7af485a9c06f1251140df88b2ef8ffbbcfbed8e732c874961540ec5ea72ac404894f586c636ea6500d68c5fcb67165e1a135f755607d165fe370b779feb8d3c4a1d3a1fea514c1aa37acc47a6729a20dd8c9a5b0653d7ef4c6a8299366da6f9b55010b724982d951bea2c55bd632f018b7302aea9bde7ca50ad6ebf514e87f333b0ae7de19953d23577ca6dfe678b4deb63e21a678b2750c8647a837dd54bb7524342e7b8304f0811ecff8196a1dd41ffbb692fb177be8319cf5cc2eba0b5bbcc217dab2cd09406c694dc3e274d50dbb6f3461d64ff07803332c539cf562fb021c84e002faf7e550f15fa418b24886201e9c4b75420adbb9b96f309981d9dc8e09432dea5e7bee3033474f9622a565407a5ae201b78a1dd540eb12ee85870bbd7f442ac156682f7a99a5c5548279e9d540976b285116a899ab79db98479e42b82f1e82b6a81a96f54278441d87376ca0c3cf355fc127fe900fb59320e5c3e011ca7771744bbd6ab391e0230ce9432e575f4f4bb4de5cf9d59e51600651be2f89a2e8bf0c4f591fe2aab0adaeeb464132d13be6d8a6aa09ce4c68a256a7137695d3dd1489d0a110a5b995bc96663b4450452e96faac72f44b823f6e85ed653aef38f18807a3f039bbc7146d0024bf14aab47ce43dcd008936127450abce37b4c6df8c713ecc1e448e0fba759bb14cc12ecc35754a7d414d7304a6d351af50919d504d6dd482d14f8425a649f56b322fbee10b5d23ff1cc8e8a81e03f78b8f953da77401c59bf12d25a3f85cf58c82f5c70371192af829ef0cde41c28d9f5aeb30579a73d7cf493ddb2b89ad12c673fe1f7b86da60a4d210fd0328437d226d2fc8c409207e9baf39bafac9c9a5e6b8089cc5e786d4b491a917b301eeb5fb8e27978fa622701e48a23fb9206c4bb9a9787df6be87cd1b6634a2e958358f432cb878cee2be455d2fae0b805f1b5e060c979ce2d8570a4f5a3849573e8fecd9156f828edf156fb654cf214bb39473edca5587f00968aa165d62f7edd1e90403ecefc5f89ea0a644126acc7808412a0b04a394c72e2184da33738411fbed7b7ee7332b999ea907e750299ac89fcb5c3cde0f25b6e47fd44ca46dfaad134cb54699d8f925ce8ef89490b4ecd3093215c21c0cf52cca765bbe3f96f83a95ab272164cd7a6a3ae80a11c371c87333acb6b854c6c47f4bc276c61b2a28b73fc040e93c2de7bae778a2503ab865ab4796afebbc3af56cfe81744ebbdac12f9857296b9913dde9f3c3542bc884f232a611dfb1ef9c80ce8bfffc1719542753a8848650ca9dac2b8c9a360711a3f73b05e75c4885387b34c95b0191a9fe8d6d06c3554bade24b4576330abc932738081ff0f7b9c24d3a47f4d9fadc7a26a6990342ec71009578b652e5e2e2a7f1fb5b7aa0dc490ffc30e7a7f33bbfe5fc9583cd45becc00c3ea35d4dc7efe926888a9faacd7f4e52c66c4b185910686e744c012c1977d98eba48b2c53bfcb97ecebb183f19b66100203b1cf92c79a95fb1c89f5756e4e668938bb4312d1824d8910d1cd3f030ea287c320ab62c69828432d3777b8e953ca4f90a60dacd660d3f949bcffe18170e1c20f641859e464c7e7ada58a7c4ef28f0186f5f0e84f4962bfd4aa35f2332706ee8430b0ef77632717e2e0d8f55a02c96d4a8b1908b685b80c3072d0595a35617631e150ae724d65dbf56ef42c44ce9a2cd8350d321deb847686442eef4645cf057270c766a5379e03dff1d63143d1e2d6dc11a24777d4e6f212acf2c83f8e53aabd8853a35694aec1d90b6f1fd1309927f08b2480c81ece0ed9c50ae334c77aa3c8aca4ed09fb1cf03249a12b664e8a50c280136f1ed78d699e8bfe551deb9632aeafe17dab5c14bb250dffff995f9b8aa4ef4a89ff5965a420fcbc5bb0a9a132e5fcf0f0bc864bee9c66df5a3ccb25f0d54bc0fb58a37555c5f2116f926d3dc4cef54b1710883360da1013c2fc8549d097314cd8a98df2f083937e10495f7a9a1bcc84485860fc45fd7a8e9b1aad82d3be867775c5cd77c7256a00183ab382fad614cf7a96f3466a42c6b9fbaa799bb9866d89b098e6dec0a7d40902c0343ffbaac05f5e51ce9e0c97e126b40665908521a79696c614cb922bd6a7317000607e2782efdab3de7f07de71ce212c6daddda8393626a804c45e5159c291bf0077d28598dedf04a08d45c7186dce2deef1e4ea31a5ae8eeaea11386983231efb05a9341c20217509be4015655dc73cedf68c22ccf41d69ea652c4e7626d12bebd9d4c80c66f5042a184f61602a77249b85563ca21a2d704325261aa57e6777360d7233bb0eacb20e048ffcb0eed79377724d8107fa082c131d22d7b0dbda11398ebacc8114033a7e1848eabb09dbd4453304dadc9ae6750e35ba94161ce0adf0a727884c180e6c0f08eebfc23d2b0ac60b27d3865e68f0ae5320713087538173ab40e1a51c0fbaf2f3dfd2c7c85fa9c4b73b3d3b0bd4e9b291ec43e32586eb449258b1e4ba19fade023434ea8afbe52b7f6f2999c431ee17b99519984420c75d3a566548c7f41d49f985f794c0107935fbac15865e496de257e7a545fb090f66116c7d5b901ea3f79ea19c45477183c709b80d603744998315f976b2f97e45924640383202de3da0e7e3302c6663e2db578e77bbbc71549742131a85f94c6de526503b2c7f301efff173365113add1d763575a382d1f4cf023f0451e3bf0718eb1cdecc580782af0ee5f777b9a9d8360b62039cb0777d50c2f3a7b5ea3de0a248a62be873d1c589fc20c86150fdf86c441476f796dbd77a4ea438fbd2731dfbef41b08985ba31fc6cc072d9cbc8aa45ab80b30572c64d6b8b5263e3603cf3853067326c95df5f4b100c5f9dfd9c47f164b8879d7946f9b3218650578e924585787a62ff0f818f4d25ad1f7b3a1793ba347e7846512fed1834161addefbf5ac0e7b865d08a2cebf27f2f4b89ac36163ec869b2833fa0e348e24434dab110668cde67e4f8baa12dcca73a1d2ab678a93f4c898a48d749f80aba2730f90e4c6d35da594d249e5ff66de59865dc2070ffbfed7c56524ea72b3cb5b9f868d058e0a9c7e5079cfbb617d1a23842ffc468f5f4e2d81e6e4fcdcefefb84e0a97280019ce5f0047267b6cbd6a108ac87667e09c00e3c626716d14750b96dc8596d8289192f808b8fe84b71b596457c191963ee9f6bf3b30ba83c1cb9c089acda60fd32a01495423afd76f1fcbb7d24d7db0ef93c4ef08567abbdd3b6671641eab3b683cb8d22d096875c44a700e98502e9577ba534b2760a69be7de8399fb866ace589445fbc54079213ef7e6d06a97057fa4c29c7d1adfd97077ffcb234fdabbb8f08a3341e5a362cfc863ba16c65900a859a68207b42cbb55c44df0e10b29c315feb4ac9c73fe144b50ce0c3deedf893ce062e68502b36d2cfd0f7eb697149a180d4d560d67dfbca7b1afbdd4728ad4d2605fdce431215529657052f1bdd0bb6dc615cb87084eb5d5730c916d0186727148cd31b4eac889146e42f10b9efcb2fa019279e08419dbfbb37d701dd902a6bdd24950f10dffe5bf9066b8ae06b3d0fa5400d4a0da850f5df333c6b078abdc0b63d6d2e206297dd4846f9aac25fe8262c9691f5e13b8c3980d2834bf6bb283a69db43bff3ece0cdd5b662b8192f4d65cbba93940671c936b80654dec50137b3a8edf0fb2b277383ee1b317f028f6acf3aeb5586d2719e29ce6891b86ee0be42560237eae36593b9f7b524442d49e966ad0e7d140d7131defbabbe14015aefa9f823076b1cb64698ed883d916c9c81572de9b7a56939263eb9226ae48068636b2c486eef0141224e1a3e3d16236a48170541bd2ceddba5fdf7fecaf0bea58456c2094a53897c2a00f862a21b9f876cabf309390b3142396c33bf8e4dae9b4400e5d20ea27c9fe64c45ba8c4889df0883a7c8184f6896214ea144761fc6c66ead8fd8a08d8d4720d567a325b48fe621c61a856d97b9b6e4c0ffd9364775bb07cbdf4eec811428813667754ecdd43c33a207ade3681c5030f74bcf0192315e70a07fa841fad7379ffabff683fe386f4bac328f2ad87d12178","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
