<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af91b350172175cbee231bd67ec312c3218b727defa09e59be66159c569b8f933a9bd23565ada959103890ef5c8aaf4a57dce622f9cb83ad8d9a593704919e583b3d0393454dc92f293809e09a6442bc29a5c6d9a237d261e600bbf8160a0152e82d3855c4d9f10bb904eca6f6bc6bc8aa03d93a93d3283e576aa0692df218a51c5958848326b84206c3df34d6e806014560b3adea24f244946bb7382718370cd2de2f7ee25afb67431c9c5982b49d5fec3f2cdfe3364d417c5b29dd8d4583ffd48c3df7863e6ab09bc2afb5d5315f88440390e11dcfeb17faaf2bb3b12ba5ea18a8b8ba7726a75078fe17f9fafc9a7299ae4042bdd1a821c96b80616b3a45f0119acecd8d9dd21e1821aa56069a13432d78b7c24978737016a4ab3a9402c6c2bfa6ccb4803d5bbc67255ad6180c2211ce41701a105d1e45c38c7829bc6e702da633c29c3d9d6830fa5d45d3ffb2e97655de3945555f64e78306e7912fd291a6ee8938e36f41ec0990f5051535e1f307f65a7f300f9f252314a30882c913ffc7819fb7db34c4073493cc80ba6388808172b9ba490c37c858f15a8e31692e97132c1a169663c381a32198ffeeedb34dfb505cf0a04cb8788b4694dc2e6e90ab10019c0ef76d2af89d52b926684e37bc2508deb3fe1d432ffc52e7ac25b0caeae116ecdff1cb80c51079e86b041a685335f076dd7d9a9a8a577d92f6d65683c7b3fcccdee8e3b07ddf5dd8f66b7494e85416c0030970e204983e7886afc6e47e6e847c91e22ac6524973b902f53a0bad242da1fdcc3287428ff070cc02f08d20ea13fa42a2c05446fb6ec3ba093dd11c0c3d5508d21e45c6833c6a79e4bc8746d82c7070eddd8912ba452d2c10fecf66aa17283590c871ab7dcf2549f6049cbf3af42d2800945bc847be2573ed2fed8e2f208e31cd053cc60f88ae574fc5b3418e6556e9d2afd018df38a806ed4741a579d1f5ffdd395a05af3a51ca6a2a60a535603e50ddb854403fafb3c998b253228c04a8dfff7405d72a7afd2e3b6cf397ce511691713730089cd79783314809d50370e09e38b2fa4cedd2be5f283d56b52d5226bb7aa8cd0948dd1e5a62f089e3c451f97408d7040e1111fd548b4ce58f0c76487862a3e1d2d1e191b17b28680dd48d09df50b5e27a7ba970ae296b2cafb6d375dc45df3109548229f01d570c7b3e41a4028f5d03236f93184cf3c992ab362b5d7116e3f0f63fc71597c81ac538a2dbc0808b017147a5aa5c1595dcf648675dc35398869395df6515ad79fc84f59d97977e506d5bf6fdde5a3f4aacb3c6cf193f8ccbdd9d8d1b8dc541fb0ad7c349bc39497e2b2153fccfd3da7f0466a1693a3ba86603bd6e4c21816129e44d06dc49b65fcd32b3a34885408a0af70ea934d31d5f5bb5e9de4fc546a8e12c269a456fcc384a507d743222cd7152685c67a4a7342805571851d9b0d8d2c3bbbbe054628fe5eb373a88130a5a67b31a5dc3bf10951959add2aa77578b75435022758765fb007ac28d650e3a9421a36687002e58a21e06162314db70ece7c556d23b4c72cf07d3b1ca4ced7e54f9d67698e435a4f5e288d387a4641e21bcccb69d1cc7e847cf6e4ef758be886e67d438fb722269ffc4da27b6ccca0b81cce2f1f0709b4d973c7aad09cf3c6c2b9d2d173e1acf7e7ec8d5ed2301fa93a1444ec6ed4e975607391cb2dce18c86a2c58471a81fbd9446e6f085f5755783d7611efc1c552a84642000b04ab48dd7fd3c4bbc0c1a50bbebb6806042a0a9e4805e15afbe59beea75c42c6c7d1cbcc50b54b39b139e52d7d0ba2b42c562b9dcd28dfad6b1ab2bd5cd44e10475d4674da3a0e341ee82ae545f163fbf8c448f25336da616a6b08d8b558e4dbee53f0e15dbfccf0b28bb1357d2398f32a64117eb8f160b8890d04b2817618471b8daa7df1803a00072e9e82217d90cd1cf2f0449aafd1def0633369f413fc7188136fe21ac3493e545913026136f379d87113d787ae8b5c10dd08a68b5e827291cca6e7ee07df995b9023de8815ca07445b61e1785cf18570c8c11ff610d21cb60c112f266ece0d2ae052605185052b00ed4cd851d0f649ce9413bc5759c5e2a3a9ca68945de04031c7f4fa182a0b05e860dd4d3f751c608600fe5599601f1df334167cd452cac0a50d1ad110284691bb0519f698843d6962dad874b681db89f229f30e2302c2bc383d8ae4ce4fc718f2aa1138d33450a0bd16b0e291f18dbfb1c9a5ff3a148fb11cb7499bf76c97fd2253286f64e04cc774e4cdec961c7e1b6f3aa04b82b4c73c6ebd6c88c8ff365f0bcbdfd86a47a2afdab426c55159800fd2bb7d13b11f0f85d7cd770de4de10ebe95c136616830627175b078cd4af560df0f957e3852590ba0687c285bf1ab16a594e1623b2d77d37b08b06746f74855259b1c333609eb318047dd64c070c029dee2a5dcc8cd369f414975b74d33dd04930b5c0eee5375906aa2791e6f94507dc35c016ae9c3eebaaf6e6022c31f1053f712a9a09cab840669ea1cea51346a9c472b5900b813fd373308091a49c2d7b7ff922be236fbd46b7f925121dee2afcdbb01a2444c6d4e223128deb58fee3da8f8fb8a2726edc1b39ce7ef3273655d207e00f0c97f261f8b6489d4a26c96789c57b6b2a6915c8fdd6a3b063d922ec8edb3633e8e8e06f76ad1be7d282cdaa0013719c88f400fca7c46ec059c721c344aee2c02a742cb7763ffc1f69d5c50b1e7f55456fce8e75e5e82293cc91b02fdbb67a7b1028cff7213acd4a77ea036944305aac4b7647553dcb29fbf4ec948389ed6685e3768f924a209f16f0c48466b4f422c55409e7cbcb3d48565d8527799a00808d8192b79df843bfadfba48b11f6d8afe9ce0765aa4ec919759859cfa034f8ac94393f7f6b6839cbdf58c36fb916a20626dcc1cf114b3c0f2677a7857433d155fe693d1776ba8ba735d4468a5aa1153bbd7fa8d970bb0e7f92d6c7c8f2e5558308d3b9e342f084c0aa1fc79576c6acee146084085f92a515f2ad4d40878967b9effff9ec60c60bbe80e00047f5b6e9a66650cadd58eb3d583df1a744e551b458d8655aaa8e463c2aff4f0841e009a1189ab72b458419c85b68fa755b071438470d0144bc2abdb3a6412d6b3232d1a230228eb378529a3f6561d4957e08cb0211069ccc561f77b56daac69c8a17e2563bfc52c2abc1659184e762989bf1c0191006ddea8032aeefe1fb2328a95c2ae7737169aed628963df047d9f834ff74aef1e050122a6fb4bb8ccd1e5c5bcbeee8f77c351ab4e999fb6b0cc1b559253fef3e6f58a985bcb69b0f2a92713531fc55c16d78e798b661025ce452161bda259b70caf70e021d78ffeadb77a05757854f3b8f47fd40d2208c7c274ef6c0ca0bc8eff4c9903a4fc524d80b417fa0e232e22f28ad8670c664f61cd9607daa5a6251517eb516fff70d18c6f55a82ae4772f89124c3a6856f6a3648fc89965bf7167f673ccd0cb35cba17925425392b7aa8b51b75c3651233243c7cc49ca33697b8789515ac4da34364ab33cf90360747d970f41f9997d675dbba688029cfa4f993486e775dda5556c720f3855bd7ab6e631a6060b6a10e7e12ce9e55cd18d818ae04eddf81e6713e094bd8f29525ac57aa7d8b211b5fe7d07823918e9b612aba57675e187b5a0cc226aa23f304cc06167497cf5c520152909146c6e627f18b74ef951d198e189fc5efeb93ac87fdab1d50baca43571fedc0b66f148f2863baa286d04477545c7a8a34bc3c4cf48fa39b772267c65cec90c580a831fa401b651928838a4054331838641bad83f1d9827dcb758a51c0d0eb29b940ad522e0976e2438412fb3a87286fa1d1623971cfcc192c6de43febb6a319b58c904e09f8d2eb547e4df7f2920f203b4b4cefcded64aa5d724f156ae33207c749813fa80a40e0fecb811a8475b2d630fd4557882e2556f5fe895f1af5f991f7aadb601af01e04bdefec16b7caa4f26e95e9c4cd7ee50fe4621d94f6cbaf0026fe41b7a9ee0efec18d14f900cefb3a8fab539a659bb776689dac975ca8217ff7c3e33dcdd6daded43d993b3dc25aed80dcbab0d4318248772291c36e82ead66fe0803bace9fd45294ed92ee662a5d6069971035490513ceff56dde199c62e254d92af8990a0a927abe7a8b98d295d0a97ceb8688c5898686950a2dbde3ab4dd66f60a431d73c0f09a679d0c49d082f17ece257452f8c79f4dc98ee42a089e520ae3eb40666224814a9636563d867895ea22ea0745720d2cddc292b0c7b59450a9fc679edffaa5a44910625584aad3c30b277e02b966409926b90ed4bcbe07efbe9dd68cc4e31f902ec3fff8882bf91d0ff6190b331b2d6f1f0fb38e1033931808273a39478dc02767da4052e5f910431ac6bbd96ddf85202fc87b91e2c53c389ff97f7e63c5ebddf95e8f263413be973fa68533061c17ff229d5d996992fbe339288c5eb679e61ffd6400596e22d09661c924f0143e81b5b8d44fb8f777bf67d00a86d50d451a21f4023dcfc0ec66d31e3d80232b09ba38cf6c8537e0c3785f42ae20a8d35397884a2521f14572247bb175a6146dbbb1a36ea1e6186224e19e9285905f0da401da46cdc1cd539ad542c878bd9a108f4eba7dfd312bd86098e0784992304ece826f9af656d622b52fa0cee4ab8e0b5ac9e0a84d8ebbfbd0af98c495da66c124ee4e33ab56d32469eba10c376ea47cfbce65712745090036310bc4e4131eadf15f1010df730174e4fffcfe647588df9c1b1729ad318a9d0a2bf9593c1e7f2502659d7e67335b9aaee82bc350fb1bd8d1eaac70fea07daa357c8eb9f8d91094f46d48d368f7ecca66d3675664e9148dee9228322f8c352aaf0508f5959c25e747110470b70de9c554353630c99b68d74734ed2d97b4368d00de2e842ea04ef8bb233d8153041c7c3151054a806f9f8f4d6c6c7d436fea326373191270b5d315300e81ecf8bcfa84fc93b21e09714ae434b45a8e3f7d66f6b0e0e247675eff6cacefbb3f228cbdfa7a47eb6584ea9339e700a64556cc90f2aff0a2c3bd3f01f9a0e32a1d32a9cf0e55b9616134f10c029990f9d443b6274d7a1bcc18331875614d190813bedeb1d50fc9faf3fd25e40796bb0b5693c3767b99f58b072b528d1097d4ab99679cf0f684fb1ea3c26840ce9fa9826e7d9bb1893fb950c61a74dd227cffc3701199b4742520e2091f4ccb3a58ff0eaaaa18fa5bd0f0f2771582afa34c5db0b57c07bee5425746438733cd8b320ccdc04dea57b56486aef8ce579f9255565276bb1c018c45911d78638745af7fd9329ce3e87b10ab6c03915a6cae52e085e62f80b84fbd8c4b47f94f978c3e9d169dfb0b7a9bc80d3b9ebcc1ff95bbc9959809c2a600f3ee58f899d22ed21f7c141b963672f5088e5c2c40aa79ef688aa1767a0babec00276942869630c1a25e19a9f38092663bec790bacc630ee3bd859a5c4eaee48d07a4fc9f8f556f4a99bb10a54f580bdb66e9b193d2f1cef3085cec97a01f0c721577fdad1637d217bfc1ef7930cd86f85890a7ca82869e835ac704eb9d6c32d9a76502b2f21a0ce8fc8835eb266c046a0c9c038de88f8cac13dbb98588c4e48f49fc62b70918b86e2945480648af78a95dc6edebb22c08e15fec875bad28f5cfb7d11528089d55c249c7d609076f4dcfdef2716cbe97046a2c42ab57c9668e3d76212aefc11fa04647808ee5dd3960a694b27a5bd457fb048121af215d975032324a4e240dfe7d959f19414385126ce24ee9eadb1a7784b131ad2f72ad82e1d819a223ee1744f49453e15b144cb1db2790762278f85419545188b2c08e789dde3f04138b9063f185d029199cdf470a9c2051e523da432863c7fdabb6db0bc3b6a3cb2c853d1914d3b14e3714c6ac5674dabe4d318e9ac56a90cd972bc61a3a0d503d32c8ef624d946ceacee08a9f9079d7e561b16367d3b2a564d64e428b790bae00ea60098460274f4e53144f30cb62a355a0d01ea9674f6ee18a19ab68a13e57b066c4a1c30a4b2e4531b7f3b9663c2df6629e5919a8cac1c2091b6a095c106aad570a0dc5707ee282b968368eccd1cdd03e19ea4b244e4627c21d04e50e3c0d969c65026b72414597582841d1526c488b5d3ee7106c1aa39a43768112ddbea31110fdb4cfb2d987be2cc0cab375238c448c7372155bfe41e84c0dd96a944696dbdfb2ead1e9de03aa4c438bbbd9e7f26c71146b2ef6972482acb351a8b188b420d21c586681e1ff263b2459f13cfa9b246fdd72158876522c65453b6e202057f3fa31d4aeb438cc34e8433864dda04c6424c8900512bad997a67db495fbd26d35b0093a0e0da3693822b86ae059265860f62ca8a87d1900c975f6a8b876290ce60fc18cef7c392e87f7a35b7e33426ef8ce6bdf1b4f1cb4b1a44e4ca3b95b4192d39aa64343bc68a796574d315c9cbe9cd9da08e72cf14dd09ffdadb7265481dccb3f5f6d787ced49c7924df62696bffbf5fe914b1b244f0b56acb3319c81022a3f97cc708d1f7dc330174aa3aaf87fca7c319d90eff5addf1ec9225cf1dc8f313b233d843764d0059bc930c53566adcbcb5e5da767bc3dffe2f1633ae0aeca2868aaf29d025dadf6c8879ca7efdd75a0d6d1d0949f5da802267570a62b59cfff2aa28c802f512ee8191c53922d18b6bdab7ed7064f364f59500ede27a1e23f334a87e2d68e9450f5a98736e35382c9b1b9bd91f2c9c392b4ce5da7e73f2a678f6d697e77e92276ad0ddaea8e893397217590e145a79ec9f94ede10188454dc1dd266b65328a038dfc6419987fc1494366142ec0b18df495787aa8408f06513280336d2c2c4a3b5bc44fa585d2eb3e063d32db806a5bb6d321d45b8ec87b1b684286faca4c548eec5f04a4f018ea121c6395e43e57f82a128f0f5ed716e1a9c2782f96154f2ec67a705256dd2c06a5aaac0b6782b87ba27b1168ad56688dbe419abece0557774fb2c9deaac77392afe9d38ad2f15537da048d0d3ff0dff978e9471c885065c56b321a1d47b8f3f6b64b0cd08dc6aa7d12b378a39b32eb1526cc87ed8c9669284363e046f008818ed62c2f95b8c60df4430b7c26b871c3b9b5285542af7833f5c6d4a9c79c64dc585c9070264d51f072d5d1ce6963817619e7f9c07eb81ad993a469fe53ee3306403dfbfc345fcbabed5f8a3334104dd797dde9546d66a4543cb4aaee5528a504485880e7fcf54acc4bc4ff64b2d6002d163dd756f93c92977c2f9d2411e1e586fc929e04f02804bbcd424596503927b9b6fb577d1d57cca05fe16b00048db7d66a5a7615e05964e9bb3ca66d8d0cd940abbf2329b845d0446faba08291dbccc9a9d5a21621b6b9e7a74ec98d543aaa4e7370c91e0407ff9e9bc59e05e2dffd4c0722619dc8f026cc3c15bd0d8faa4c4682db908d601f9355971d40e0503a52eb48f3748e8220d0d587d524187a0d22d1f6801137c076355e6330efdbbcf55d0f7d64f1294dcb31b74fce5d2d0c5195c067da89cb73d0639d9a951ea898ceec29c43abb3c72715dbb094f3c142a4d49d1529bdc8cb0dfb011d58ce7290a60ab5f6edb7e42ddd40e40411f87a4e2cc05776eaad82fd71031fbd5ba3fce13dfa845f2f29556d44a9d3b62f566c3db98272cc0c6dd993d5dc3ffde178c7893b7268c42c5ec6e34f0dc89101185a0312de885a243042bf38ccccb748c5fe43f466350eac86bd19181547b46d2743cad478dd6c420b7f60030955db7a99eecd7c0bb45e022320b65492dae0a31ab5af11f88e2951881f642f89a549445e680e5b4cacad7f1ea20be5725c14aa9a793c2a55c374cb11f3fc216efeae10ea0719c8c15a7508b0d5b26675b6da588065379ebca1d74e8492dbab77e63b89937b17f69fa8166458ba0cad7b5fab6e92682f0ce96b3aa33fac190b592ba95292f15332a5cd650735eae6ccb6d6141533abc5ba68a1df0fad5f567c5b3022e4b176e4fc87701684e63eb66739c6112d4fd6f497bb23d65ffb22dcca3431fdbbe039e89d8ecbaa4a8aaff62fc7a02144bb7d3d32fc472a44b4f4c53928eb4eda1a2438cd1b07a2b68d2309c4ab73cbb133b5e9a312cdbea98d59ede1cde6ffee81e3d32e9c7b87b8c0bbb7b631b9dfc3bf98a8ed54f1188c095dcc8efc45219b506c44d5d16a1735d38f9d80c198ffd2a44694d9e9aa22b5aac0dcac91dda9b2ea93f64606da4903fced770b4d4c75ca8e040462a7b1c5f6310d1e8dd9e000044097107e8c459a3d81b3f0ca718beb1487d6cb287f69f62366a0e916c655db955a469c34cf4dfaa7f19d32c5b1a2b0863f545b51cc3510662ceb5de60741633033c9be74ddc7d3b5e67d444f4da764af0b7dfc2329b2a3c77583d026f04c07299544dc437afcea9654ebd0d18e6e04cc9e765a921879aa62381240ed8a90915cc4125eb16b65d82fe3eeebfb8847e60830435029fb3317225614c9b061deedd82277038997709254e6e6d5bb36a4f8cbcf41f0baae7d81684100cf28225d435f0be8d702aff29bad76f126fee3c5c263112003a91e3f55a599bb9813594ed130e1d91507661f89feb68b4cacb9836002f2536f516be70f7795987c0115d72c2fc24c5f8824ee435ca8925a71dfef9f4c481efd8fec42c5299323bfb6265d8dc99524ca48666a4effc81216c2969e3bac0d55bc47e72ac92c3b087c9f88336aab7a046838a54756e1197b61dbb44a8344dbc0d83d7833d349290fd347c1d86ecc72034e37da1f1d7dec92099ee88d47c9f8fd51f565e114d11c48c51c8765d37791a9d1b322d4d6240d4ea0cb23efbd25caf356066bf526ab1ea87823195d41ff7fd40a8c0d8e24eca43bd51f0e874d054beedeb312fd5c7b4a5273b91b3c3645d8fac66f74418cb53ff4bfe9846f5795c054ed12ed828a161aae7ccfc347f2da13e11e507571cdc11501bfc25f054903f3ede51c7fccacc49c09e78d168f976e15ddaefa2bbf4b9e78acb76ecbf7f412151037f62e1b5fda50402b472c2d614e3f789810b90943ce441cda3c02e0f0b0a316b73b3a9bafdd7f3369851cbc8fbde7f446c6bbb36e7dc51639fb3804dd1b2aa99b2b0ece9dd11f56d898b7fee96cf3050db75b09cc1bfe5dcb93f4086bd7d2d0473f50f67d3470307095685ee01400c3b052a480a5765b902ec208de9fc6aaab88d4794ffdf58426515e4ab4a7eba1b46bfc7eb93f34ff3b49a2471513ea8486db2d77ba32105818a1e6a503c810c68c828c0a323813958075c3391fffed4159ea16174ec056769747a3624b2853a661627b176f2d1053e66ec6722a7fb066423fc37d3163b722817e6c0fac594dbf9b81d7ba423b0086015b749e8dc37ba29f3cce942c655125dfa995aca5d0af6cb03fd6d3dbb7119e5f1c8880ead7c1258eb12b533a91a68eb4f7560bd4533d511f33b10d13f188b471f23cfd360d2be0591f9de1a2c7718c4e64cb637c9050c79c94b474e3f1f9d6fc219253f072ef10271f96237b6952b7c44978741a33d952f6d49cfba961cd669aeea9694fe4986cada39b186696f67bf93cac404df8b62b18cbb48fc05e38619488014a3bbc06851e1ebdd30526ab05cef36b34a36a6c32e5c46fe177b3f2c42ed5655f84c77c30c3017f641443a7e69d7c9794017797512fe1b1a2d03a374e6c3001dbdf7b759d17d0b3eee70e2cabc8e0b449b9dfb50839f95af240334dd0310278c87b0d475fb6cd70e542daf2aa14c51949a23a04e1e54c6fc197e0cd650d49d2e79b62819e2856609d70a90ddc844259d00cdb71be218f7e90f0ba2792d0fe284668ea989dabedfa009cd77ee6bf33bcfa7a5a79bca24d40e970ee6f6129e1de0379287cc509a89081712068aa843c77ef8b20c286dd772b8eb22a829ba29ab8aeb0c6dbdcf7aeec1af79e81f917458e87b8f9484b342db225aba38d5fc8bffd75f03774d722d405bb939d052c3712b5d89eb3c779cfc17f605a5b058b9c0095c8ad2e2db405462ab8140933940ba15530cfc6249507924e9ed7788c72da4f1fc852eb318d138e8ff506a4434d8f433adea51e0fb905a06341e683eef9c9887a034eb06ecf1921fe87caa93a23dce1ebd808217a8c233f89d3b682bd5016b903e484134d0ff8e37f662bae35d7bccd254f2b5b60803cd0fd7686555800ae1f1cb473ee200116fac6ec4ee309d1060a53b2f34a80400687703ccf1a9e726284f5b84e4b74a1e0b2f85429c2b1a79b53f54f3ef112cdbcbc867179622081b2efa3f2fa609df8510db389b17a32c4602fcdabf3a5ec1318530f420ae442b24f643f295cfde6d7a6cedd64b56e8c2c75328da74b517baefca0a57978646086e46c7570edcad718030fc5b8f1757a627f2105ebb21048aec9b49e7baba1b6c8caee8a57571f6f051348ed97baf64a579d46c57a880556f93f89b5fc8e50c9a2450cfbcfd4fd00e346bc8a9bbe2614458c3bafc2f54af29fca384224d64273525ef052e2f972da03eaa1416f759153184b5882597c7d77c65510f3d97bef56bc4d234f77d27bd71a06d573d8a0efa92adfd4b6e0e4a810066facc3be256c5aac9c7eae83b4c73804437c84519c02007f25d1103fe697243cd10108f519f9edb284252f044e84cf0da39fe79e11294bca6f715be5c35f23a6f4f6914e479f7570279cb13f5fb5e2b3fcd535688056eaf2c2cb87600e46e1175ae900b72755e1d2fdf0716d76200206c8269db7eb10042a0d52633aa6dec24f2784484f6a14500e1c91194a1fb853c88dd311f90c9d3fd2ff8e20f89e2ce9c45f7cd5a25ea82624f2998ecdb37f316edcd2fde575de7dffef167a34f923475a311a4f4e4abac2cfff5b0abd4fb9e211e2f4a0490697943d8589e929ab9479c84c6bf4fcbc3346945a1710f82aede1b424c557614712b6435379466c1478dbfd4e0dd5a22572936c515a9ddd7efa0611ca0e9005a0af076361b34d44fa2838f0bd14b150ab689a95b1fb4bfafaa6ef31592fafc10edb7024a26df77aec32fcc94324a3d4086cb628e73b935ea583b80127f1fbc6814859bf69c1ddf1da160b11ad2d8b0e003c0a930c1f1cc4afa82763ace55d331ef1c1afaba14d12789cd71aa33874965babade35500fbb514f3d779d7e8c3508b6c6fc2ef316b3833d5464fbd875413cc3a8b81056d9ca87da79f0583c26727eff213be3dfb6001fcf7189468c1c5e8868dc83b784f4f6f5a8ddaa7685bce225612d787d6b00335fc58f9c24464e26543030dbe07232f4b8c1c5bd6a8e5f710b1e24cc3ad6095700a1ffc3a53ae44605cc42a126e4707d58554a8f322f0a95c9863f55d6b0c55d5cf4b001d4ffe36a7578f315ded58d16bbbe16b53db97e5e40e62c37effd234fa456cc1afefe5a7dd53619efe9209025fa8f259ef59477de8eea14f1ff743ab2a10522456b7f6a5806cd4c818a639cf3db6484352709e45e69885a4cc21fdd4e6d2370f56bc39a0636cabcd1c12530bfff06c283b45bcafc7e8dd490a7a72a56ca4563f7c76e943a1e2029cb2e6d18cb61fedf303768e8ba0f3ad6327efdbf5dbe703a759f9405a39a1e00fe391b4a8feefa1e0440c924e18d73e68807ce9946c1e1af4fbfbb7595b8cb63483858802cb03f69f7082224f8010700ef7ffc1d8037fd2d373ca28ce4ce3b24b208c79df3c3b55cb25f2c15de8a5f4c3e91a1b6aff4c732a23bb6d14aed9bc6bb7fa4f82169ba2941247fa603f56847dd48d46b5d73a04eae9cde42f91411de3c962e8581e72132fc2721b448bbf90fed4a4f706f94fe2b96fbb0814a1282359fdb67cfee4ba993614719a6e0b81a83b5383a3e0802d4807fbe2c0b765746f40bfa9f711a84e463cc9c6c146ec864582a721ca007aaabe8cc1d7d3448145c6a5ba0a79d362723acd3d02356fd67f9003e880156182333f1a461791496096a50a211edf3b117125a7026fb8e41ca60982eb4931dc3e2417938a036b20ebf04253090c195332a21959dff0ac0a459ebd435ece67d8e8adf232bcf286d70211a75bcb455c23b6a87cc98face703e56c7b35f5ee2ae99745d06cd10b4b72cbf754dc9d062f2462bbfa6a48b7af819d93c65b7f602b07643b59c6993cdded3db6636c3bf0b2557440f56eb1c7b5a3800945476b457ff83a7f8627a8ce566d94cba4ad01a9605bed869a8923f5c7b37a796ff7687f66e4895d4238a061b57c83d83ed4911eda27d925355fb5a280d5e34a9ff0ca0552f686b9880eff4638e046e0eefaed624a387d09599effae37f5aab852686ac0952eb55f2160479edcd9f1e6c958fd4d8069e28a472595abf5c426720c7e96732f8972aa8744ae3750d940ec517785d25dce80220ae06f1441e4a4c5a7bf0b6cdb57a34ed4b6b4b340341d3a8875d41fb4004cf138ebd084b4f051b0ea4228a64b8057d894f232a97e6af60eae8de61c4e8711888cd0537f4e2e6f012f3fb81d52a2bfd5aeacdd03501d6f62b79118590f2a98aced9f88c91f7b9db1675b0f95b914da2ccc877560021e3c64828faa08521198bf985c6b401aad142cca1ae1de80bc547eece41eee05468d2c5da4b69291277d9c11fe110e33c163f90295077cd6f4dff81ced458882098ab8f13751b903f042afa7a10ad52d5a8d9b5029c15e3ede14527ec73bdb2e540b182b1046457e1fe701a482c08238506e270d933ced0ab6629c6395630eb0f59232f8810313897fc8c845906ed209cda0c17743f9f4fc59bd0651d050684e7cbc9600c862ab3ab17a2ad783418fa42e90de5acf3f6cc17c430e20bcfaded7b2ac88e5f2fc2863e58ca5dadb94c56e939cd3dcc82838fff8173a7bb519eaf7b78ceaf1f74c124f324b6910c556707991049d9e14cf27e545141928db1bd5184d67419100994696039d36c041ecadcc7bd45feea41c0f25ae270b79282b62404ca0383152ae91f79a4edaed5d7b72c2bf12bcb1966760b8221daa84266eee188dbe01620094d49b195b7ab3c09c0557f9de7f7ddd03d6974f34987872a2a5cb53f492d1709e732ca31d2419e74a5e097ec7001a72c69749c347bd07ffd746dc19a913ceaa99f26219ff63f7a0a3d7a27ce527859af8dca45f3300e1b20f5a85a023dd081a2afc7289dbf902062d20985b2b9522a6cd39a52783c8b6bfff2c558d41bd2a0ba2f27758660a279fc997f09cb0a84d8141709caf0ef8be485efe5fb33e7665c3cd258dc2a39986003aa5da6606121f8e997c5adb8f4aa6a1c6eeeba19e13f28c6981404b4537cdb93f4c9f043aaaf680569c090c5dda6d19e4a8f3cfdcc2995b472d0de73d3a1cc7da0496f0baffedf7835862c613e050c2634caee7e53968064be42ea20365e2fda27434f0cf8d59c8c592ad797a722f7e5bd0c2c1357c2a871498094e08bad0c0da962f8ac502aeec80b990c850fee5d3b36598eca9813b706d0f20cacaf9b386e21fbd1f02bbff423fac390ead94ada198d00bf497ece5ac0d513805600ccebc4dbbf744d84c095ac40c6c91e55527e5ee42c8e29d63d710f3a930a4e6b63c3a7897ebb23197eb5a57455873c7af43ea0478e7bf92eeb95ecb777c69ed06e3388ddfe6f8ba8b689ad6e16ffcb4203104e6799dc6034e3a6ac52573886eb079f795c7a08e37e65c7dbcd6deb6ace57145dd68b2e7a95e604268513f65cea99eb6e9aea7f7d1c3cd993153c63c5c70a0cbc199bad21c81fae88f98faf93c50b315cbba5c0d9e1111b232497d5f7d4adac6fd5bed92302b96b31f22199e1fedd03f016ec5e05bec08de321cc07893551cd44d719a39dead770bdd75d9f25b14f83e78e6dae1519c25b850368ece9bd45627e0c4a2b4fa1b8ed2946fd582f5d76f58feaf245f59edc169ef82b843146d72fcf8fae3744cd04d3bdf884ddb271684848d41b8ca42ce23e042c1b1dd0bfd61460b3c084507215488171925f382b8b46c3274f3cde6cef71d177d4e5b54c1125d847947b317e76812a4d3809ebe2af818ddfc0809c5f709aeb38247b4208b3b3686c425b4328b5d1c73e3be2e66ee77dbaa1cfc435bb36a3a8c15b68d44fe3815842880fd6f4a5c43ce41445ac6289229289053aa04705e9eddef159f51a3147b3fa47589a5628b6f3353d3d2e8ce421a3c19ba8c60695eef2837c9c7f61ff89adaa570e9348789b885f3bb8bc03032ede47f9a62d8bf1f1800d5819371ca25508a6cfde6092ec7d35c03533baa38a05909aa3ec555fe5e5a54f0adb1162d3db1b13728fc35a048ef03b5e4c6d3747c079cdbd8700e4dae4c8b0a450833de4f275713d9a149acce69ea516845eb8020240ea8edd008ce04754393442f16a0a81c862d14961fba3d5829735cc76c5cb3606a0781403155028b8fd9de1944342c91f79f1f7db6824b94dbec983a635d6a4f9f854ccfe61e6e8f84f44fa0d91ed3cfa4cba6a1072991857d7e2857e9a315911fb385fe7aa314bf0eb6de5703cd784ed8ea6f0c9924ced37e2e2e45546870151ae0693bb148ee7166fae934d7bef795094e1cae623f82bbefb3a5fb21e4ae553bc80532655c780a7f8e938f7bcd8d243efd834f45c1dd0dbb31f7e44ea9c9e94ea825cd2ac4890a79039377d81bf72cbdf6f7a84445334ba32d4dd3d0a84571dca37ee4b55d01d7938b07ad9f76a716222a17a06eb33c4de35c02519122cc65bbab9c013dad2db981bc9f64df644c76e467798489f76621b6454f769149abea8ef528d04fa160c91447dbf2db0202e374c7a0cbe19928fbf86d570308e508245d7387c36592a327774c71ea67e722d8b60c691e7a03bcfa4296d665c2d96ab8459475b1e46b0f95632a8617d458b651a8eaec8ce888baa9d66c6816a8bfacc3fc0d4a7a59ee645bfcbd3342133a851ff0ce5a8b1b1ff35ac0e8b455252911be99373d9df2f3e6d224407c266cd27959784852d6434e08d392ac325accd4ccb4112607bce3adbe51669923d315fd751291ff6307480c73c04e043483fb93a31b4dee29719149c87f6659d2a886baf877bb8f9dd6d3c50647455f7eb8d1f4094158585f9893c2512b7e497e8c28cc2690c0691da2ee244dd43bec5f72c9a0557abb51a50c0bc52a6e934643a43751626401c2e1d71968648ed978bf002e1f8e47c116681e9f3e7523aaaaa55fa1ba1654b127500f99013c72f7d8b6fc3129d96e796a3ba02064693fcebec815dd942beaa7e63e9f0a7c67063ecde4526249b54c3c1f59b2b77046223b1ab29d442a887a7a68262a89a2c19cf7adfa9d7ff32a91269f48ca08a804c80f7717b655a323ac8efa8ef615cb3ce8c0bade7130d5803c25314d2e6f75a832a32a717b9b7e6f28c519884c8de841e1f5f350bd823a67064e4a438a7c73f80299dd06f3df3ea150e4cfc66f242256361cb7e05c79260379e265c3dbf7b123c2d4104f92fdb23dccc849cde0073a5cdf76723dd156389e8b629abcb6319d1e485d05ea325962e7017bc1e76d30bf18c3ce7c8bcecd67f9630262a78423d6d38462422ef89663af878d480f3b2e58aa62a9bf36df4734d7cfdd379069838c16bf0726a125a46694435eb5de4524bd2b1c08c405613742be752eb2c982095e4d2f42f9404f4cb281cf6f495a495e314bed3f62f81f547abc21d4b119d5371639d9d93f52ba0c89265cb988c1325ba4042a01089b41033f7074fa5e5e6b3472a6bb3522a134bcfc1dbeb44b43dd41df63df1ccc891ee6ff420709b7ba54c9b2fecb881fec5fc2958e8b83730a48ffa6cbc253890b1d7b41e12d3ba1314bd702d090e18ea001eef3834834a8e4988bf1bd7cfefc508fb3c2f5ebed65bed8d75787611656e197830622a02b53d95d18d6449b19ffec128832a89a0f51c356040b18d11e592aa98d96fc2924095c1c5cdd38c741e0f6cd1f59677f74f9b4cd27b39be556b5e106e4e56eb1eec0b35193139b360fe1da23261b5287c77f6729d934928bc2e79fde0d307e00354b8582a337b239fb2c155dc11c5a107095466178fb7f55dfa4024a459f8425b56b92515ca56db9065e26a611fa2669c28d653c8a2cd2a6d80f29a577457e5c5d62cfbb16159c9a28f4ad180447531587440921f1792200911b83ff4ded6d5188350822b8722a6c2ae2c8d22c3bcdac5685086c7fd2b3a111e97feee5327bb2f7e788f88f1f741fed1c5eb8d8e5dfdaf610e0f04b1f6616a3e5fab6c4f40623dab17b7ec05c445ac433234f65a715a383a636156e4a41c395ca880dcb9d916defc806621ef0642ec08650feb3071f76b1e165e6219e16fa61cf5fee78f9fd7e25eb3b63acc921adcc6c8d6a7a757a41f14e589a56e0f0db902f36fc70fab4540e08c6548047692c714eb41d2363b88fbbb5584379a33ff893cc4860f234ef4af7d09e7f6689330cdd85449c27d1b2ca618486b26f7361e86de0a6c7983e4a6ef69e75a11cf7ebbf7557cf4ecd21e81ccb102fd73e1240e381aa492cd7acea4fac8f1486d6efa2f03d24ee9a617a0b70e145fb0f259259a00f11f7bdc35f9026b427ba4db4f7a9be2c2671f455d51ca715355a2f2b63c4497323e18f7480762080abd00f0d19790cbbbb080ee4458bdecd97717dff047ebdff477c678aad0f6bbee65ad26134f4b51e6adc8d27e73b98f6286275e432d09a38fd78c1a66333fb07f05d0e248a54dbe7ea7172a6039f782e1791512e1ffa00e8053b11297b2976d7cc9046ad555f1836d5b0cdc02256dcab59986e227c4451f6b23e53f6442ff38db66657fdabb2c72eed52e422e1ee418234cb64eb44864dc345961503e792f8c1c182ae0381baa15b33ce566ada31bf648b48a952bd37cb9e79cb917a5a334e8a62c6e809ba9f58704d1688964075db8efcef174eca6b8f83e0e5b74f41bd73b21b0735b42d8d31eb4f7aba9be8f8f586442a27d1aaad493167c93ad1cee20fec2b545530614e394b51a808179557344e93ea159f0ceb1f3fe07a9d107e607a9ecd4da8944695f2be144219dcba978a738f7a63bbb33ee20087c7d66b9ee6711a1534f1f3befbbb343e6057918cefdd6831be06ea483ac19b04889b8639a2ad0a477808a8a1043b1d3839718bb5b18aaee4b568338d781460b04c40982da7c364f2f48c64d374f9c483b138bff5a4a47292a0ff0978da969707279445684bda94f05ff68753b5e17b85b9b1f2a0dd95794722154bc348b765c40489a1f5325de0e1470559c1d63b0e535b1ff0d7b63de2b989c0d349901260100b3427f17ae5d0df1cac5f832a57724a50d09ce56e86ed9316144fc36d54aa2b3fa818eb40dd9e5af230f6db3b8917d424e9dd3189203f5fd636a6f545b1b3757ded612a6018b2c2f54a5cea68d5347596051e3a5948cf1134ad4dca060e8e463eecd2ceab25e93875803600dcec0624b5fd587164ccc8fe7d3badc3370e68c6d7745f1e88bde8bf93b0b3374ad73033a7dc97997ac01b286e1c312224ee897171b65e5f6970198824dee9c13221c5501ff036e54fd2d5c40845af627c59c071581b9eeec631224e4524ceed1978cf1204a5534274f8c88a449cf02475b6ec91bf1869c2e478614eee4cedf7f6c6cea0de8f4a58c0f67229e141d6f2dcef43db8155bac4b724afe20e42a57e0ef690bef8782a47cb3ae76f5d358333b49e4f7f076da6fd553071dc69fdedcd51731ca5af3727a2b03024c27ec89d456b2f3c73ac7e6e021150a92906174a5d4dcabb6a12b1e04c372415a2fcbead5ab6a8b1947fca7a0e1666f5d57693fe614cd5e2862030eb9ebee0e68a27e75b4ad4049c0a5c97d6d69d50f4dc8125a041634f53b7170a049f536a1a04c76dd2547bd96d450d8d7995cb1eb35b68b66b0c9177c32c0c57e9dfe5982748610d5d4452f5edcd3c3d4ed6fb5c443da436232b7acd12c479b42049733d93f793b7b1b7882b7eb85e6ac2d2bd92861f88955601d6f391634f038a94bb1e693eea8b4fb7ee1cf48b15faef18dee6777757086f3c0c1ef459f86964d297b31a2cf3cb173256f2743553c5c0e1ffaa907b37f1e49d25b6f879ac4f87411ed2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
