<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ceb4734b5f795e1b5476c010ff4aa70f7d3e5f177dc35ed5d514fcb131f85eb109cf90bfa8b7c0e376d6ddcfb8d69279187a10e8b5b75f552225669c2f410c0a3ac018b2debc47095a6a9f0e0822e85fbb48f28c25398b0e7c69b5b60563ffa3a08132db6b02484064f561ec528b7069febe69f916c4108ce48906f8bbb6001de9b441e67ea877cf76332b090f56564e03dfc8f8c567b75cd13383297ff0f1d4b6b5571f5fa487251e6b71a8cac9cd254ccef3279efed70ba6ce0cb4e64d47c19f7a52137dbe8b9173dae1f774e5fc18a90f8ce5e1125bc76c42719ec5ee4cb4642a928f1a76d2a4999f11a6b5c29b07aec13d9b9c02f2d908ebc3493198f40d69abdd606985b885a2c0c41f8252af720dd1c5417f471b13d9b8e49292b1fddba527ac09e26e9ab8b80b728d0ff69c7d8b376fd683f39b464d48db8e12c78b9c69cf6cb447fbe3c6ea11d569c222c96576b183b1154327c4bd09c74ffae7aa1c06eb3a8bb97fa2e5cbb8235461ff573ef48c6425b6c0d25712df37d1e877c8d567baa5608d8237642079714240ec30dd8163979055da9a40c754c7edae82128972c2064626a22345bf7d696ec0a13732691951fd529224f9a513b3ec56cb42cfa299321e5d9b2dbb39bfe336a84ad401e189d5c8b02bb536a7c9bac1fa83e2e6d221d086ced9530135996f1b4fe82c7ab24548efbfc049359ff23b8e8f3ed167ab47841b5918283f182afd9667727946b0d1d0feeccc08a5254400aa3deedcf6ae0b78ce740c4d58945bcf1101b2aea41c6cf68455cbd17b1ca7c6f0bd7abb2e48059f8423e1721ae6e964c55e8da268a105b7c5bc272ee089bdf776d4e6638cec4a416516c59580e47b75376f5c46a96ed85f76733417548b0dbf142de86d5fcd20d91c45a6dd4c91fef3198dae3252b5bfade4a6de8af81eed52d882e6fc00ae118957a81f6fcbb5ab2f6d23077b554b122959aaa84f0eb2f807fa90d42608576e6f56a14a66d0bc5996871f93b13c5563a861851f074b8258fea0998258498eef67b61ee0411d149960618a6094ef4bd9a0eaed7c03fed31aa9ea7a6c6535f0e4f6e6f8ef0924c0fa867b4d486f6ebbd43d021122eee7c6c421095344c0e6571b595ffc73da8cd9b461e4b9fa0dfd6559930e9fff11fdb1ef8c51a7a92c3418357bbf854a017d678c5fb2a450ce15c687fd5efa7b0f7b35e373480d498dab3da6af4b3c14d6aa7a795bd2be805aae0a29382073a60e217214a7a0acca6f72f8721547f66bf7af8b2e75ae245b5db3a2de24445c4b0bd0f70ac1a4d79091580a8d7c4767e6395b6c989288c63cfcf358c891dab330cbc0298260321dd14f1849f2342801a30b943ecdae4a51467ed68f42c9dce91f49d44b0a2ed8e3914040d18f68c6073ef1a38aa3438ae02bb459ab3901395b0efed16fa5460ca56d9328e71944d24f29468dc9eb113952fdbedae5c764a43b3702d3fbd6694fcbcb4bd9a4e805a8740d60dbece4adb9e4e12fcf41a49b23cc7a383572b438e8aa410217acad60bb1424035c73aee61be11435861b57262df126936730f5f9a40c3a9d7113dde2fae767c4ccd48fa3567a28f111958130744bbfad6681319a20d28c90d2e1b281c0fabf092906ebc5b4d3e90b92e995ace2cfeac09b02e9a4d5cf710fae497508732556ebb062e91a65e7e5fcb9d14612a60a101b97678f43f08f32675c115f3fa45e5fd19a37ac0597665f3f5c2117c370a4d97e7f3221acb2ff82c0c88642078e4bc339b93ad3d6d857eb839f449a09ff9db155bbffeb6a77ac3928ecd785dceaf46f0c496fa54a50fed1639cc06a010c9ac9c4919181c4dcb6c31ef82c416e206d3d46b3927cbae962a53031026852c3d7db607169caf2a56f8a07c8435c5f6c681c7737c0619b2868f41f6d2bae7fa4c6952c95efcda50c39439cd97bf42259eaf191f60265cb23de9f33515f6d492bb5c6dd3eae1403a724f189853d17df6f4b2470ec5a18bcf74e7ca48159365b651df48100b5bb1a0981702f2c0e6f1f217270dec073d2c1e29596cb7fa63c11ba86a7653e5257c8faea112efc4787de1bbf7d783ec3f89d1cc8c418d184227b5919ff775028b0658afcc1aa7a8b7d8447bfdf03eba8c5a6797724c3ac4d19c40e9a511c8b211840bfad8cdf4fe81b16595d41125300e6a81ada13ef136ee43edb3d673c4a2c6680ae519d938f0e581ef1f2872ce3a084af6d3a6c37e5048a0a503513693002cf7a9e4081ba8092f26172d09ca3087c8075ea85e693187cb4628394c1496c92f32ed953b8ad82a56344ccb426f508914e07c0ca10ce5ea9f80334669144fe5444121d2ce4468a74793022fba1d2784752d12eae317bc27c75a2230185e96f492849425d3c7329b2154bf65840009651c3fa835188e005e4733f230327c60033bcfebb6b8d4bc08c3eea76a88e33970e27de2a532c3c94e74a5a34aa2b6952ba385bf370fa32e6f2ced1b0d8a806e79894321e2b1e8af8097402ce876febfec44cb55889476efcdf64db4e7c1943554aa3dcad4304bac01464039a902dbe0ccb777a16341212d2041a5094c865d6280cc362d54487cde7f1fa3cbdfa205013f2c52087d0f56a2bc5e1082057f5650b3dfe0c2905fda9e99bc495eb67a966ad574a9c0dace4ae8f9ad3730ed4612eb978be94eab7f4859163bed90ea08c3fecc5c89013ee913b121e454064f34ce0c76a582c8d96f5445ebeed5d3bb716864d9e5bb4868661e35a89ce4404cba5586061ae67527d3a61ce94dc36bcbabcfd0b098bf547674a73d733c7b91d266c7947f3c5b34d2ccb42999374ee320786163707598ae5470aa41f1eeed72420e842ca537688796ce488d99e79623bb2dc4d130629aef44152fda0924489c3a7c286ad59f9bc17d4b5d29ef9da9b677e6ac0006ba23e35a44c696d041ff2cc8605622c9729547eb7f91bc4e8bfb24d5ac17c1c8cc6bc3be303213cb69968ad8bdb6648304bdd72a710c379e356c0cfab47974482fae0999eeb36b1953cd1771b812639d1c96a2b5f29c1e3e0ef46ce181fd32252fc78296a012fd020a032b49927d759fb924b16b36a1fe75ca718ca6353d97fa07878eec14e6c8ef06ac3d59f326b4364859421599c6f82aaea2c4bfbd7b9861ecd9cdb439d60cb111760e8dcef49393f0a11bbbda81c7a4985b5a03bb56f918ca32cf07344a2eef4322e89762d3261d14e1a381e7fc0dc6b6fb9d4eed164ff6ca713d3972d0e7ac48dfd739d5ccd901e20adc07d2f045177be8bf23e0036359500375f843dbf59ebadc26ce60dcec2fcf900d056f09bf5d366e4804f78abe9a2b70c15a1b2329b27336609c653f7a8cc58a3c461134581c1b6ac3a92bbb98f46d320e3d954b0cdb428f0a0faffc3f5853cddb2bba4fa4ba1ece24a9ea528dd0109b6194454dbe70c54e713ccbe149c77782e34831c405679197d444039c0d67fdd19a8ccdc85791f196a9f6790616248fb71fc38293e88d940f8df345ea6751240106b657cef8db8df0fe6c2aa36e9c87b86751ddfd4e5770decd38d68b9a8583a5139ae353ecb086550830fa4333692097007f0a4c4302de84770c4b8cc84ffa320cab4b6d46ab11c39000768e2c171b80ef57a8bc4da3cacc70e3c1471c4bc0acbbb3402128d1d8c89289ae63d961075fc87b33e910a8e505cd2994e805fdb4662729aa38848b4646ad85e822d10354e3f49e927bfa7b5e1624157bebdf19eeca629f14e8ebec39c3859ec1d7e7db85ee59d020a7ca3a8ea4585fdb26e6bb8fb51ff425af1236e04f7f402a1b5ebc2ab556f16e12406ecade7fe3812d24739e5bfa762d9b904fdd92599816b2372efaded0ffe47c9748bf2ab0602f06fa93239abfd757bc0333d4a644340bf8e49501bda2d2cf87dd9c34e5195e244a057f2b736438b5a34bdd813411410a3d91236a19c4df86e1a9d025086051730041e5a6206891490366dabe3ebb21eeaa19857d1187ab99d4b3554386f22664de5530f36980137c2680d7784a3a956cba731f65fbaacb72b1238d46028e86bfd431ffda6497c5ed610229e369f36e83f2397fb7be2c1b54ce0f60d9d31112e8dc220c314ba4bc55d366ec92f3c4f07b88b2ea53e57d322376adeae260c0c437a55193aa15396ba9ae70543a0909ac37c410a1390813826b378504001a0a57d8e01beff51ee9f738590277be14e049a03efaf09148ba440af9fbb36fc53110bc08b3fae3cae7ac2077e06fe0a10c4edc54071f171c6e70efba2787c9ef8f8e755e6600d90b7cdefceb15af5cbe20de3d8bb8de55ea50fd923a45b4b7e5ec0edc0d8e5314567592ea12bdf20793bfbe323abb7b28aa32f87c7de12f9f019dc2b37c670166117a8348d6986cadee4231be48f3e546c38581bafb62aa5b65b62fc4ae98953163e4985266bc8f1fed062946a88c7f87def1d08b8d0e43074a4dc3fc86ab3257a1320ac35f0767006700e7886bef4c313cfbed246f29b854ea1236432788bfee5bf3dd8dae4fb6f8809bcc7cf088866d8ed1b1c8dc3b29fb7ee85d362a2f5653c03b25ba7419a8ffd670527dd4c407a20e308e60414ed4f93ebddb50ee5bb05b5be2e4e0cacf8405f379ce62921b5074b0264745a342b666a5dd88a86e68c9a1a316e02a58e7f7ee5c33b384328e6f7a46b62bcb2a9e73cca89c0d1c872b0dfde3b878530412a1ae638e3b0873c37d9570d10c8a7c518e5672091578866aa8191098e8617fbee6cc66f160993e3fad9bbde56994e689c1d9d3084e746e03e012bcd745f8a819ff232508f6daf3a2455d3d59f00cf5547182bfb5eddb1f569850b8719046b95bf7b4eaa6629a82c6a911e3173b3bc1b91c4b041dae1d0a6f94f18d06305e5ecb7a5e44da6217e48003fbcf75290f8bdb9d844bde1ed59983a953fcf3c3085409e5b181cd723d6cc6c3e791d2b7264c66c9777dc26e35291c749e1718d8876852ebc9876f4365f8c4b5a6dd0f158409505666bb240f5f0bd9f964c22d46a4af370ec4b8ee90a12502cef09178528cdba6aa5be0cba68b8591346269211b70b55cab3e284d58901fb95d5c28f28d91096fa99fd4268d7abfdf6d948a4b60eaf7395a350e06ef2e5a2276d7a06fbabc97aa0906995b504122d454ca23899ad3d7c603f61e3ace8716792fa484cbb571656291b302f9de54f87b3d84a43778e967a82077b3f1f8839ffa14822aacc5f1c8588582c2bedb737f639f03a12f17161a8b8a046c458e652ca942a310c5c5ee4d92e81c25e45f5da51971b03e26909d007ef408290c9c38246ec4733571ad1d1d5ed71e7bbefe00d7e7134cc0daba21bd3452249ab08a9fc2bac3ff09429881a2e671570a5ce3dfdbe22331fc1ff50a797a98da92839571db286083b120e1fc450d396ef6c66da87e9b3aa85f00382001586a409fb506b8dea8b5f2bbbd5a53fb249a1e2a2c9484bf96ed282b01f7ec48e288b5ac3dd6ed9c9e09832d1fe07be1b09c9d4313003268067557c64c22e24be092be9e4a7d858852f96deb671a2c0915260ca04c84aa572c9a71a21265fbc4a0bf8fb0dd872d0a10c341a237c960e237256e19bd197dc476b41b5d28799cc53bc7c650d9e1d1b295172e4a0497fafbfabbd360b6f5d35c2c7cdc1be8a8fa64cbe8fd43561014f712911e2fd777907ac5b6ecbe62a91498fd26ce975bae9376f6f2fae76935221845ad59edec89be7628b4fa685a13d2e9731de66950cd1adb76f0c5953611c1c94e1dbe06b4ef6f9fc2a32861aaac445ce05e88103c2ceeb1fefd0610fdad7d5018346d1e25a8dbedaa2b2f209899a7decc216dd2770bf14672b4b75a221013c62cb6edb913930e2f2205713120592fa47bd250aabc25908659252da2c0079dbc26edf25cc1738a25d5e1ba64a8fb5b0db5e655b5e2026efde18b6c3752e09efd96052ffac54a0b721323e03c47b6a2f009898ef53fa211df7a43024c20f50cd0515f56e0d4fb962634603591cdcd7b8291d4a58402bf38745e4110c8a84d6ae284d0e1889028777104032aafc09c50326b1a39ca6b820c8d3a9645771dd585122fe702a8088b12c8eb39e04a6cca5e28813b5214a6e9ec1d8858a497b19903f12aa380117479242be15b8266fce83835f041aed932c07f2c256ac4db9e450031465f2c79cce413d8b966056886a791964812a23d5aecf46bd7c0654c04e73a96d28a9be58f42afd5d1fdd2822e424cad31dc28547be7c3c6beca21bf4d25d1c60faf35c5d9fea22f47115963e2bd23215f21d6f7cdb5ed0f469d5412d08b06cacaa27436a054c37ad8ee988cdc993258bede117a2aa1b00d886c5d245e05488f5eba7dd82ffc23b713e7e48b01d3fa12280a2115a5b5bce4992687f3192375cec1a7bb22a2606eca71958a258f61d952ff2a01214fc610806cbd66edb578186d56ca2b393832cdc6524360284b8247d546a1a704e212e5b79d0da67905066c53d8cc954d1911563cb3e4744240df8e4aebd2ccc2ebd944f7d07c6b51b1adf6c42472846992ffba661d93cb69ecc9075fc0c8d23616627dbb361e0823c8343fc68c34b83b3b401bcb8a090bcbc0cb51b77cb5472a9fee0d8d7ab75012e79033c48c1ee4526f4c923a5b9248515e842b4ffdf86ee2ee7b4260c655d3c5caa3184706d73e892610976681d9f2c8822b97420bf4412a27ec42604c346a298494bf988d76dae411f7cc87b5db5284919fbfa8ac06dd402f71edf69169e462fa6076e43f8accd81da9d701052b7d6592433ea5c70a64fb837af19f7e6617fcd9cd281daaec7d78d345c9586df16104bd70f7de14fd8eb76cc3b34e62529b7264ac62bb8e6e88d7cb46443e0d4c758d3dc5fdf1a6968a4fbc1412637e460e608d42d37406da4bba1d48991e02d3fe88b568bf53c39ba0cf54ac96f7b3be09938f8af60022456ec4876fc6e83c5c85cfb4d94fc588f35aa9081ec0eeda2cea8dbb7c06786843443ccac8da114251ef7bd43b15ecc6826387be09bf864b1d21c0fe6fcfc3622df7bca4d7e4fd8e0b565b61c5838656843600d2a7d1f49272fe9b0c6aaac9d05c6dd30976622c85f11fcf81187641f428782b1d07e70e2a0829249d56ff837d04703c70df2ea2dac8089ab898fd59023e93a8b6a1d4feb75e4e79c91daf9a6e9fe071316801c4a7f64f72791bd1d51a185c6c3f99501b6cc8f9657c6af0ad7c7048bef08c33a24295495fff6d9e02277aeb062c1634e181e690e0f0283d9e966a21540f5b663afd1fb36c77b1f89921508edf537b4138a69c7f4cd4ce6daee17f0ca8600ad41e0ab798e93e44dc635ad5db4a0aebbf6fb895df9cda4b948dcd40be975ee7268465713f4f965dd15c7a61e21ebb1a0dc7b168dee5d2463262d525bfcd3fd79f7ad47f2ed2c0665e5127d26844c73b22a5c9da390d6c1cff117bf266cc1f54f6ca22cbcff0ea836e0f9885f39286ac6e2948a8953886a4923e2bd8a2e97e55b14663ff26b5c060bfa5cac7f60bf242422ee3bf84dfa9db50d87a45e7698686e76bbcbbc13480aefcb1c9c1eb54b80d82b2c423aee3f8c9c7ae760962fe71435f7817281c246e8a1946ba8663ea16e2bb254df46ac0bea7c6ecdf8d93a2d3e866ea2f67fdfb05ea60fac3e64028c183f6cd3c95dadd4c5b295ad8fbca2f2c53b4f900d4199505cc879aba4f752a92c351ef4c9c503a1850154f83f7269c79a933f7199876902dae3497b3f14d2ae7028a09b0f2dadd2f6486017a5c99c14b4a852b8ba2a9b06e85dc9287887e63e6bfe123d6282cd4a4e5373fb67a475906413373f03be2ead494304eaeef2f10a8df86ee7574ee4552ca726d794bdf3d2d229d806a6ab147a5f46b13cb655bf68b751400cb0e927869b31307ec8ae320d8dd291976748a66a545d51a6eda5e932d8c3f0e3d952b6f34888d573287bd020d8e519e0f63868ab9322b4b4868fd99b73cb9809cdbee00c6dd792987b65e6c3f438c7fcc89b2675b68c78b31c227964b6b6fdf514ed4138feab19cb42fd8d01432d4f0a8ac2647a2d4dc887da1ff298f166f2ac692ef98c173a50b5eab4d949630195c027b7b4ff8c6c66b5554e61d45867910ce06c06a53219322a4b509416fc9f000265ae23671c17e893afb76a0a02f70aaea8b3807293383a043d81e9b94885469665d7f0ea5506b8fbdfbe2b9798f7a30480dc1e2fcb46ff0c3268d90c8c5736505fd858a5dc64bb9f5a009568b5c31f18273405d98e9842b9cf351646fed24d642feb9b4f10564c0085f4c29563480184755f4f8ad0c54156f1d10b7675c3705ee92c423a8a102426bc5690f700f41290af3243fb53fae1f9cdd4dcd9ce58f0f064e380e4d66365bad1ed8b39afed42af528b7376c98ca92d5ee1a298bb2035b4989cefce78986f9c06d8017c465e6c508e7ccdeb0eb66498e9b6cedf6be6e38812f45586cf8e203a7e0efa87254ceaf16edba3124856689a93db9f888985dc05e901e107ab4f711bf0deb32a4e5949cee816322c736c2ab9e7e486efcb4a345e2bfa4c17c675b41537823839432cea86dc3ee4bf3b9a4525100eeb3fccb65014ba1ea7fe7e0c5506cbf74ac09c464c593633490a7d5b09df2c92b7f12b876f722f451fce55b7452c2e300c723c08be0ca816aab1856fb5e4583fc278df7ab32fd30f62594ac67869052b409ac7171d9607b41f7905e03fb6aa7514823b1ba7e40276a7e50e4ff51d017db3b11cd19505c7bb66d45db406752ec488764399ead36631be570133134de6d6286967944ab3f3f390372a439ead199b8fd8e80c6d8da401e17269d4f9048e10dc98819c97d750df36b9c2f97249d6f6eb974e6d22ef93d7b4ce4e6676fb0ee75c1727899dd563aebac26055aa3ce1775156cb8e551145abd07873c44644ed8c262b70ee996f8654a18fcb6bf7bd32b23067c68598e2c2440950100e9e8da9ea1cd5b377079844fe7750ef8d0aa5ed45d7ae916fbc5faa1c51bf53b0b44ec4eda7385ba515af00c387e2f0b061452959129be179998bac4b142a598be051d4f7c6f144c634aa82e6c2abf2847c47969fd6248197dc5ca54b4ace869acd199885dde20cd6f0aad0586f7d8419924491c6c02e7925f29d8079b22467ca056f8bda3635981eec5ddaf1f179f60e74dd91c8ebc2ebeff500ed84f863ce8b41837f6824e34956215edbd38920cb0ce68af6e879683e05a8a813ea81c0cc27bc539c254363823271f39fa149c8f3b8bb94563ffbcb6429059917056836b16c83f22a588377a7e79a0e7011d8da01e8e3a1a4bcca58e185b649cccbcf919ba90ba42f61af47b9a965de678fd5d78647bf6dcf048303d3220374df7928bca6662be38eef41bc3ac025898c6b59754602a40d62bfb7b240f0944fa63ce93c6febcc1272c06ee0f017c7085544c5e97b501a11dae04a5c0349b40e7748d41876d3724c273f10c29e3d67c1d786c0088c8e828369900a3ff68d8c8b029536ce4739fcf20e36c635daa073539718f5f94eb2ce88ea9ef31f43183de5da9f3431617df8fa1024b196ea1c301b7691f977913ccf267e58235fe2085a0431cb0a794795389d3b3ccff3ef217346c4caae764869936718761814a97e71ba5d42571e98daf0098fca7552e0fce0b7c10cae77879caaab8a5faf2f2e69357808d0d01b3b5c52364b6f07617173114c29827967069428a94b9d51a821c0edee0f214ae2bb80339b35851202dbaaa38110119e2ff073378ff1147140ccb1c8e7b76c16dbddf7828a9234cba075dac47d5cfef5f0824b9fa19bd53a8981a90591186b6ad041b19a109783a101a99e95a260272755e0ca83a00c2d5c0dcada60fa4551f3ec746f0cd8863adf90eee9dda9e4f4bd8d9de89fcb3b472d0d24b5efc8d363b005940420637933ee0c62873c06eea86ab8456826f56e806dae8a64901d9565bce53e6ba7f7a9e19a3604bebc701e3203eb3b070f8c89bbe650be259e43a44eb26c4a3366d764600d9acd735c5334ae3136bafac33e639249aa4c3209385edb53875ae52bce1420963afb5d6068645a788d398d34918a7e6f62dc5481e6d63a909111d7d2a0d77b0772bca7e726a0983fae833592ac68231059850f51825b87bcb8964c51928fcc9d1fb0405c928d5530a0e82a13de14629106244220ac19e6c71a255bf1ee04f722b5bbe826fb454dde1118bc5ad7fc7bdadf274638113d9b658bbf41ca55e94a2e373a2fe95aabf69717a03a69a46ee4eba8d7efe5b5e2031d265a4097940cc4e995646ceda32db19aeb310526aea66588cddc6bd1b8d13efbbdc8e8b8e3de801526836bd1871043374545fd73dd82e266fc8854161fc54017848709f73fcc83ac94efc46d5f9b9db922fc9eb4bbd59b895529674020344a7e646644f0337ef0ec68c96b79bf0aa016901f8a60aab8b827e6844ee3783cd30625ef6b83c62e288ffc51ed01e1feb6ef659164789ecfbc56232d526c5b9fb1e2c5d3b46c372f459e637e555365f360558654db3106cdbea4571f8bd1c95bc42287ff7d0e02b067e46cafdd6a55233820bdeca7ca4cb9b51b04c1c94b7a797d1feb039e1cb07f2e8e776ebc729fba8b4730ad98ca008a9562a86317a69c0953a944ebf257f36887a1f963fe5edcf8e0cbbea6401e7465ebda8d749c66ddcd6ee91a7cd189679daa50def3b9ea337db5ebaf6fdb0e0544f55a618522e24a444a8ba32e74f7dedf585400e67b40018c91c2e08c1c9bc0e3eb36b463fc61b10cba07114793dc4945cd174a8ef280b6bb2e3634ba1c0c75e86e98879adc8dfb99d0b10696db0a4566235beda24c34ecb72cec8d6e0e3ae390625972a12229b800e1390b22fbaec490e91400c58f258e8741995ecce7f5845de1f1b59aa8fd057ca72dc480cea8a8bd281950e00dc281a6448fdb8c7409a03dbb12ec58aa8591bcb7515a1ba6b6e04ec76a2b3487a92bd85e625432535d4fbf1634f0fb54c3cc5adc80b7d4042a119ae295a922ae7d695df5bf477c906cd1684147a45538c0f4542e0b99f1151d3e2f05f54fa8efd5d7d30b4692223480acfec10b2dda8303bff28a709afadbe239c19242809e65f19a8131dafaeb4dc024ed6c5abd539dc5dd105a915db8d38ad317c328b80fb44f0c558ce7237485792b0a3f9adda0935389b0e80479b085e61c82b4f1680b60048d5f59e869a17f21629b88dd7c74a279dcdce342d4ab0048505775322dc9579c4c041baa35bffdc648dd52b8d03b75bede6c0fc227d3ae156b61830b452bc392b05b77126c09d10c1eeb8dc5e43068a5d1a56e0b365d0267dce6254c44ee914187647f94ff596b9adf079379f34bbdfca0563a05d0d4aa643c651fe54098cdabcc0b48ff2bf2468c05cb6911c36a2148f3e71073036f78871a67ea1332bcc3185db09401e5ec80a1f74c1fe32d4568e12d192b5d050104c26eeb39a22204f55f7b826f062aff6b1042f275895c9252c2e5d78f8256d8974dfa37ecefb46ed8b28f33b54cca30e329d3bf54152ca9f8bdda2ee02eb84444b88218bb540b3b2b721667146671ad793ae6f8f8f53fc738a9efd1b25e12e03ffc8a653247da72d9541fb16d65b53260dd7f51494adcb714a4603daaefb3b55249e198191dbc12f23b2a5abfeebd9428753118dfb0e8d71b168722c1645f66e00bdcb44e410bc1cd06ae620d8a9efd5f68fb773f4b78006789721d570288b4fefee10db27ab7222df30086755546f6a8c5199ef6e096d7e5501841ad0cb1b2c3aee5def312dda03ede3d50f7934b3b8b5b23e992ce5495af04ae06581e767105834c134ebe10cc0033fd573fb558de79d8c4fe248771d1e381e488cc5233381137ba79a677a0f8a3b96981066cd07d95abe3c27f4a439af92f895f2652e443c1b75669b41e2d73b0dbd86e6a0a4b1fd4cc5fea36c2bbfb1c7133fa276ebd7e27a2ab024d9897a2bfbe3b2481daf2f54ef3f8a0ab960d98555ef6679dfa3d52e4d4bdb23791c20caebca1f07c7f01fcefbb2e6e3d4c78065a0c95dc7155733d885100ef1809351130ba63ace07f9df481428304558cede264fbe0f10df32fc6332667f712e1d9bd249ae19c438bfa8fe9db20781fbb04ecf08dcf1356d85b23bccf5d4cc1974618fed5b1351f5abf50dad3696aed4b13ea83dc1f3dfc6f7c761a00f4b0fd8f52b6c28fe14c3de057b99ae000581ba14ee4da80b158220bbaae5d50e481387c0b0d49cb5a6b31d7d879360448b181f86bcf67225e6dc8fa74a77c7116ec9b9795b9a0dd00e07b263470e615018b82cd0e77bc2a24227a07e9b444f568900f4b6611d6ce82424b9b800afe75216934f6ef527993cd79c45b3ed8251b876155e92b7393680d5d5aa7da5d53f3e2568a29ab02ca594f507a364f172ea8a8df635689b7b68b3108291aed31035f84bb0ba3bf33c25d83e839fec0129b5525062782e5d8cbf9eb425174c1d1b916a9a6ce6442c9d9846eedabf7ebf98d51125518c817a0fbe5c7b74096d3b72a5b8684b638c055d0994d14718274b1bfa066dbef5873a1d5437ad2560dfa3b505bd5a6875ee5570e2118485d84f68e4c18e114607d1cd28ec47aa13f41f5515897f7240d121f0d49147c3a0fbe7df638f26dd357c732d845e24511702f2372fc1a28c4d71b2bddbfe9205e4203d221eb161bb67a1bb82a9c9449e95d0711b82a0de53045615d18429fdd15c56a564558f4115c4032db12177be93e4b115af34af81558b72abc792d2ae1933b3bfbccb9ae8eb23f9124a09564cfc13e9281677b61d216a524385d3d4a23653e8372deee184456a17744c34697c8d928c3ff8e3fed1c0c776a879dffbe45770b65a90c19667eb1daf4c3175460971f772503c4e9a1218fa0181e3867e83b987d4237e7fd241d59a6cb85090a80b6ff0ca7f378126feda8d7d77bf1636dfc600dc3e735a11d77c3c502259064ad230f80a752d55c3d424adce8b82c621b5c8183848d7cdaaedd40e8c43b8c64ce88cc94043c3dbb3328823598e9ad6d1fa0bb27626ea518824c0821f6146547e94649ad7ad69969df49a07106c50fb078522877b09ca494a84cef012a18eea60559beb9d4516573eeab6bfb0fb4eb0fb668c30ab60981a23b1a9093b722bd856b78105aa1da2558ee5d4f5f451bd1f6c1724737f6f775f39152c4ea1c8633cc3a99b75ba9dadd40f99d6c9ff4225773bf3164dce17f6258bd7579758308bbc93dec5e049511252d763fae08f0f78cfd9cd5418c500b2e78c86b72d399a3c17ae6417b553c863859606681ac5401a3b92fadef9abc2dcb76ad2552b096bf27acccd586ce9cf7c4a071251abc2e8164fdfc7303aefdbb3cddeb27cbe9ab552950392de81cb1c76f42aa2feae0ed5a0e55ff45aaf60236c3768908c93e903ffe126a5b08afb8ac35e80e586be2c476d9b4f3113586dd4507023dfefe8856591bbfa6c64a403e6d9e5f799e38334e0d5c8fc50168699c107793330ac713dc358fc41e016ff1e23d960bb11af2ec1f7cf65f30de19bc046559f17cae70979ca0252ea61dd221e0906040c22c89077dfffea17e664a926bd41a1fc84e96b21c14f819893f5896d7593818994992084d6482e56f73c966f63551d8db84313a2777a199eb94cb1db6db3a6d519d8e013dd836af475e2c45a83d641c3eb36dd14683014afe5f0683fe5e9adbbb262127b9447bf284f84c4009fb3dbfef85685077ca5161b552ab44859f6b87e8c18b832d10758206c79e846fbd7ad6810d413bdee1e070ea844a01738cdb82ed11f465bfecb6fe9a7f4880a95da5ea5da405d2eb548f0d3fbee4faaf2a0f062ccbe00b469c9fa85632954bfb21b11895d03daf0a0863f8cda524abbe0896c68f226b371d08bd821452f91008a41d6e1b6ce9b59f0ead683ca8ad411188af2b1335481fcd5ff75d3cb51a0a949dd2c876281c659c27fea764b7ae7f61d66bc919fb8f16c7b07c6030c556930259535e06bf24e2a5ee970a1249a3dbb49bd81806a172421948e8c8a140dc8d803667c6662c3a92563c57d24f4ad2089745af649200a9ebd16a6f386014c5eccf968fc62f327197a58c97fa7440ea19b1e881536f2a3d2ea181baa3baec262dcba0cca10d469d028cb0753ecab3e03e17db0153e55e25e9f6356a24ec2f8151d5884b8d40ff653eaa2b19344741497cb801746708e37ceaed6a39e16e2969f99405c77a04e69d9bc59f36f3fc68673df8dc11231868bae0667b99e4548278e74a38f5cd055e31d304732463cb346d3b8172a98d6f3bb3cd290e2c079b7c07266269600c9584ce706ba140c99471fecc8037c45376a814cab9d801211f72a8fd61e17c9e1e8831dc870e4b869b726aaf47761b5542b5d4d593b314d7842ad18ae21bf31f33e80f88f6ad1534c02c308c339ad101ed2c89c9461d8c837c9dc4fbc2da76030fd21a4e7ae15947efb431a00d43fd9dcd303db67821068cd10aa5148ea3a0811fd1e4cdd41c9bf7e9b4131da0aa4757e8ad6a25413d946fb3e68217a15c7656e905582ab22e86ff7c423e8e803755d0ffc064978f73a505064041546ca5f4074624d75995b31a3a96106cf75cfe5f1f22edcfade943e2e0f70cc8289a338a83442a27e25e31ae84791bfd7233b7cafb49ffd30d69b5ba4135dae07faae85e19f66b70b0574f84e1b696abfe0d376cb566ddcbc078c7adb6525a7e2a6572eea7e3d965683159d8c1f2b03abfdd4526e13077208bd8c9e5e75dba64d6691d6040edfcb8a3aafb7837ee2723a15ed46a7ecc7715ad26ec0762221a9054b8c3058b444c45b625f3c7ab6c377e376e824b420a334b7a0294fd6748546b7c333cefd19c38190335acfa9fc0dfec423fa178dbe9fff5e892959501e8a8ccb1793e287d851372abaa0417e0a18783bc354e08e591810bca304bd613b1319a58e4c67790a97ad6106a367bbdb9bcab21030c8e23eacededfb01030b96940a94c8631678f29f14a9a3e5900dd48c779953c54a2a8fed3a68c0a0eb735ceb539b29b1f3ddcbcafdec906d48de00ab201cd8ad408cfbae707efbe67e4faf6768c40b5e00d2fd3e1145d6cd50e14d86279d2a158a02fab36d2b1880e2421df8204899a91028393a26ecac93a84995c3549be0e72960871a840c54d3e6e7f1c81353e4b97e7f5661364d611dbcd4ac0a8cf379c0cffbb7514cbe8b9a6391b2fc927c34cf3aadd089f4ee3424f7302e5370ec974b45627d40ed535856b7e537115374769531d6e47ce11eb5f07eb5e6eca82e36754dc85aa21b6053d9a1353ea7afe23d79eae808638f0fa8388554f39e48409a46dfe66b0d7180d8ada68ce5cfcfc80a1eb631b902221a223a67c5c820ff58cebd7bf7137c9c4bf518c915b99e1c0c70f91557565973f0f9206ffa357f632488636cdb85262b8c935ebbff65ba6ce873e93823fbd54a10a9f04e552ae3bf259939509218364ae04a4e160362fb55ac8dbc67e6ac0965ce899fc5dee9f903e504d8ffabb4a3f92d2949a8d8a68f868b58ca8a31910f19ec5c6a7754bde47ba0e384e64ff21a1dec62e3bf6ffe1ac8536b3966a19b8f94a9b2a563895257f756ddc80f308444c813e282bed7e9f0e809d26c5a22c579fa42a5f629d8218e9bbb30d3c6e36ffb28ebf6468cefcfe358b8a38acce9393c7060fa27b24416bab72ce750646e4919b312fe484ec976091d3891ffb812aede3e7badbcec2eb4ad8095c0370b29ea5ddac734ca8380d69e433f8d1cbaa75ef6150ef235ea4d2d03bee47a1010ecfa8ff07a822adbc62ce50285550275159aedc464dd9a83fd75652fca8853ab3982e404307c2691b15a792ef591f4f79be0274d8dd53db3cbf067543ee1649dd2d97bcdf889bb9fd122d014a2733858251b33e251e5bddec4e9cce0253dacd7d5397196a77b62f188329a563f9bdcc9b7c14907877b310e0e88ec0b2b0c1b52bd1e41ad06542e785f5e2ae0f79a47b1769f5f4f95daf66cced9fda712634786a28ca3cb53fb575323f5c74f0983c5d140080ef64891ddd224e89499030ab2beefdca30aaeac682ea1339f37997f817a8ed5ab4eb5cfd42d6aa63e67aea97c87ae53e0d08004def2e4e72b8adafa4bdfa29ac9c2d437bb3b6d498b20dc9cbc819d7f0165b28d87ec95c02dd6dc9836b65c62cda55da9d64c4fad918bb90ddf75a8a96ffe4b607461a124b2f1b915deb397ee59fc3c769e064acbe98f3dd5122db8b285ab507bfd81b4e39fe3acc6713036e11633a63fa274ae68d4a70060452272daad41d5a21cf60a366e5c037aeb319346d682ba9ecc8bf01504b03100ab2c4468be86179151676c67b939edfdc7e59ac98452a9a285bc075bb7bbeacd957dac5fa82288312141b7c2aa8e3a9c1fcdc1b814db0b6b8bc24faf43993b9f5841cff75e58b1af3936ee02e50c107671d0dee2cfdfe6b168440e86b2e81bd2579282cfa32d9daf17481c63d673dd75886908d4e1b6d1a04310a3d5e7aa55c3b7af92d46c3fe32690401b76ab055a1a253295cef3b4ca3c2398bf6c4267d343d0cab5ab459201c9e6c1f670361ff936832a2a52434fccfed95b6bd6a37cf91527dcf16dc09b026207462853d1a086f4d101683c5ae16a65377b61c36370d440150b8543f288fc49d59d8387d43d20728ad20215cc8e79f032aa667151753fc1664cb68736d07c40cfa790f03c9fac214846514cec3bf3ccc15ee6b7372ce6b8c221a495bfac7aa0096d2b8b0aa51ef041d534a9822d47a3fc7d6f4fa0f1c9d30afc088e5f6c1d68448a8054834cb4a33565d3692d2ebf08e15fc9796c8a38c9782c366988770d11c570394fd1ee009c2d558cd2fa378ae7e2f977c3fa0261b68e244d6e58899b4cb7f7daca4e1a78908b83bf86f7bbefd9dc10ff8a15f4c5b418e2ef58fffd276f0449edeef6cfee961e22648e240a5c59cff94b8229a31d1d610aa2b4c3b958a9c65ef1c1e4cf19ebfb4569d285863773880e136be2ffc650218aaeee0b70bd083e573fd3bbe9df91b2ac634a020e422a4934d4e46a09f0e6cd1561abf5e03be0ee0fa93107ef6c4e5d341510b1748c8c55574e28e4d5f7bd8b20995b7abff19867405fc841a1c03cd0cc39cf69ae81d10767ccd671c0bf3612cc35d1e443d9914559be2c14591dba2ecd6da24a39ef9c13fed4454ff4959cb7ce3fb92ceadcdaeba79ff6a4e466ca6be07a9f3fc992d885942098e3923822f6db2942cb72da06b00c0332edaabf1ada468935ecf04887a10950959a1c3696b98e92c0545038f2230601fd2618799b6baa73e57ed16cd6e48de03a54297fa3adaa2f15c5b4341b7bc2a72be3e49fb4b3ac60c7c333a52ae7c2e7723ce1492b7a88ee6f402236317c19a9a60edf02a9e302d89f1d8dd6608b633399ebeba8ce6db78dc7ffdd04e1b26e48f8e2a3064ee5691feb71666e4f6e74e0911f4a6665e76bb187165653a39a3edae3d9b0a6a4bfe87c6e2f2cc0570e13659f043c2b195e593c2c4e670c21e8f35bcacb478385c184afd4b6ceba40cbe12d9fc8aaf32bebaaa169dacecf9150f738cf9634a02ae02d51fe7682362ccb8b5d8a8708f59046e644f7e85aa0327182af990d370bd9dd1a8a07f53ae8b4ed5671230222289dd5b708bab4fda6230a468b1a24083523760042e73056fcf317906354bb516cd3a3a5fc4a1df2a88cee40e11ecdabed70707b57f6dd3a556520fed59e3c90a261af4b815d4fa362c56a575b3649f6046bd49195002a4a3b43390e60df01d2569c56f8ea9951205ade3d5eb8e6fc3d8a3fa3774e7564e88c6768006f403c3871cfcf3567515aafd0c903b2c9344a9a13f8cf47c42e8773bebb59a438e611d7bfc5c6b20b8cafe491660aca299ce017b039d519052818cb2ad76fb8693b35a7f9577a0513501759e7b0dbf4e8528e161f2935bc9ed852d64e209013b267b13badf0c027da1daf774beeccd13e14598d8ac6c29b8a2c76a560a72108c7449093e5d794da86cf471bd36150cb81f0892a02e29173760569868e02741dc20ef2fd6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
