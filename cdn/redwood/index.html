<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a438c7b63cde6a5d0647f19deed2363537c03b69d3809b347064087a7e132bf98ca756f630cc938ab422ea42b81ef607ed87c590d1e40dc3c0bd746842f760641725b6178dd80b9ac81620f5a5e6da1fe6da8184ff54df24b2293237aa0d2fa9815863a73204bb4d6a53d1883e8a8b99174ee7861b0bafb34bcab4a64fdf50f0b490b5615af6aa90995cf669b6b793d03b6beede51ab5cfa202b23b60dbebcc5454bf712ac0c88b21c7c3a1f57bfec96801e41bd9c0a27e167f51fd85d3929dd7da4c0837ea53d985c307f66d883a7c33ff49ff5a4707ea8c47adda7eb61c60d180073b295e2cbe3989922b3cd3b791bcad6e335c185aa115d974f6884bcc82ae91cc436d139f37f4bc4ecae5a3d309bea1c1cdb2bb68b5ded7ef57b9179e3b5e779ebcc2ae7de6064e2a275789680600221fe43854e0bdc668b63e1f7a1fb8f2cae2b41129c6bcb83966eebe5c8fd7d77a2499c94b576be42aaedaf8e915e2bfe86cafcfd68bb00353b298fc9c5d81051c5b3c5ed5720c3de7d3948a21293d7c3ba1ed04cda93055c8e355b21baad4494e41589f1011beab5a8fc242979a99fca121650f2602beba547ab0e1d736d741108d4347c51868718ef315d09f961ee22004a673e36b4aad9a0b299d677dac075a68c548b345f25ff6fbab03fe4040124bfa840b60e4785fd1705596d480ba38ac9701d889c309a365091dee2dbeae8e0f821a379e3b37ab45d31d9e15e86423a772aae9a97821bfae2749f2d060be0aefe45a429c03ce2fdc2d870404dc12125cbc8dd5d4aec97560be3b3ee5108d6adc907dba75654fc7f50cc7ab5d852f2e2a2f127ccf0986e6e60134c1bc0c2f721325e0c69056c88fc59c57ba1188cc26d9aa2e44a1b1d03adec00bfa68292181fd9ac2d754fa971803b01e2244b0e7a2f4e0bde1f17b28138a2842ded7ba0a7f1d210e550ce2a904216c249ef33ae16b6bb3fcd7080be048c4951fe3fad33488263af7b057f9b1d4c968b9461b105c79bb4cb6b4e5f27c093115e7c5dc9f0cb1972f52b261238f774dab7e7fe15bfb61bd5ff0a60bcf776709bbe353ea94aed30f5a4a7215a5005c61ae25770a86991bd0d50b48f1782b8c2ada777b54153ff7bea8aa545561a33b984e6232a64f80ce3cd5ffae701a24d9ed52427755660b0a6ddfb5ae9df74d560905b099525d11f00345e0ca611f4e54289f4234eaf8c5bf0d4ea9fb290e85ac1227972bd968f3773f3cb9249456329c942f72eca7dccf2598f7adf3a8a8a17f52f4f93d495d52dd5ee904d5f92d6ba4ac82a5c3de3ce159927e6b294559411de79abec23c102d095dbc745f139e37f29fb642d870470794b94f601e045b5d0638ceb5282e42fd2847d0cff491170e24087aa90373e260f9e548b0a4cf8d9a9e6404e8a9fdcc05356de8e6e01a50206c94eeab4f8262d56b3c4a18c90aaeb5b63ff0a76a448da59879f7155881d72231b46c594260ceb6c26671793fa99f838187579f26f39157e893b50ecdd6c38bc147402af0562f65ec5a4615f6081e01d78e9d32523db5b6248bbbab9722ffaa09fa13c4e28a1a36530f0e8463ed81b7571feeb06b108a34d2f1d0d6862ebcaef059a55e99300df27e21b7b57beb966412abbb70df286c5b4af4bf78d56d77375ecd8e25a8bb66e0d33fbe93970efeb60418f076f536801663644bd23d0a4874f5041a1ad6ee9f1327962f78ff39bfedac1399ec1a62b3bc0adf3a0e034387f8f977e25fdbc5312db1d0c832080f8a1488b5cd5467aa269bbbeb61586425aef739e306ad39bd3c87eaa14391d90c272291f8ff100460a74f1f37b962fb453318057a645a98af550ddbb05a75f97221cd1c6093f8f28634df1fef5842a974f7b90eb5c0a72278efab76aac02f884dc19be298b4a2d5016582f4ac516e0db6ebbe37a52569b82ff67d4de1a8bb8d7e10bf97a8e25e53e9b3979ebe6801ca5a44bcab1b66385bee7424babca48d95f853400a40bf69e173f753f3480466efbca3ab41c553c280b7eaf476652d8ca13224fcedd901fe97b9fe025bce6cb95a9c5cec5ad439d38a1a4b7190f3e0b27f3a1df6d550849d7d36a5c2da80155a8263c329425da71159c18c50fd1d77538090211228a7f273c3dea1904c6c9cc9c2666100154f931083b67cedc1dcc21438362862343a8fb0878ddeef78515a25c750376710546221c306d3dde1f5171c8ebe6801c6806d2087ce0d46560238a7f66ba0649a3e1e180a4916c04999941f6f7a7973b3ae004507550ed5c28bc6ecc26a9c36ec7dff6003f513410c6da971b85bc1d478f00dca2969d38c72e63e821cae89855618b173dd6ec2cc607b29de3780ac6081be03ec2151d458073089de88cd1e681baf52f96a6c11566ab8c5a563b60c0f0b22ce4c431c5c2cba5e0db373add1dfd7c1f486a5605fe78b84387a424654aa374b5f592626fded7a2fee4520ecd6d8a4fe5f3570a940af9c7b3866a4e1e3e4c745ba05ba95280e8166054e1b189355766d13d72d6aaa5bd2448f74424b09e911ce8fd8ec51aa88b1f6487df14f459b6f3c454423ca703d22d32d12e7019dc3bd53d53b0616c75bb16a54d6c56625eebdeb7b00905e0f2a3da4312f5ef1bc29d9fa22411f14290f6f7ae52111757dc26763bfe0aa5271b7e6f3aaaaed256e2d2cc69004d5e5b6740dad17a52ddc3fc57936823c5d842895d0c9df168dca96cb918ce5a5003e0f198e067fac852073394e9ebc41966cc76a0b0dc75d4cbfeed57e611126cf9130430126a4e365a796ecc1eb93850c1ff6feb9dcf840ae424b4bb40c0494fd733f3bbe6a9e7db37919da05b1a407d0f300def5456b75dafd9b7fbbbdf6b68766354a555cdc583bb97e9a608cd8a8b11be233830a36167983bf8dd87df52f0d48abe986c2f8b082bb31f29bc5335e97c06346bca964699be4724a917686df3b5f9088c4dacdbd0899b9573e3f344f3c39feeb8c10cea952ab4deea40aa536cc1de3b9fadf58e635bc02038570f7a156925daf9ddf67c3153bb18a7746da76adf1ce349076e7c917223dfd45a21a0a2a2558868e9b76e446b1854f7ee15eb9423451eb4057f2f2ebcb5978f7885350e4365b64d303dca7cb523946a42b88d53f28093f51e4094b9f8f67a2ccf7bd3527bd7e5f61d3e52af43689b6b815875296efcb091aa0426f7cc9713bb1c04fee89ec5084f5587dc4e4c3b95ad83fc16e19443de882b4f519c5ffb4e1c374f6aae8bb014b249e25cf33661627c52be344e4ada3f5abe0d2f805285d7469ffa273bb47996d766500d86450e534a237835ebc7d7f36222a91225777b4fd1ac3b2ee59089e935f3871773ab3017e05972c58f001d196bad74f32a736e473bf4240d1cea4245c1bb7b8373d14e50008c6b3cf1529ca21b9b99b417488add91e84b4f6c74bf8e504561016d6ebd7ee64538d46f40a30aa9a9548c8aa53b0d738d2c352a0a1baf391b8adcb7c36336beb78640cb605aff76cdc598af1e548e6093f00c32732525d4a2b4d0881b9b5d24ae40ec0e99334a047ab37af9c0bf6a39527bca0745a9a42fdfeb9d24e256b646a59ea59029d5809075f39029690d103801e58323a872f31779ca5f5b76a5391e25b89891d03c5c182e17d5c6822f2085917b61b58ad1fc7eb2aa8d5fc002649ddc3501102a9f1eccdc8c00a6bc64788a194a420af75ea5b1e1dac4d9aeee3375a3dfefac119635c650300c4ba8e3406a86ee961b8b18c5b7ac562991c5a9045c2288e638de519f87e8259eaa4390158a610413703a25378cc6b7535a5cf2d070dc34a0f5a25e4d9efb38d69dc93aa925656ea1d1169d1cb95dcdbd69122b020e138f370ac085adef9668ce7b5927e47da4d0e9248f3669e3b2dfc68b31a6dab739976a764b96e1e6e0906229d84be79cae446481c41e8c582db6eaeb2792b701200edfca43ef8b12d0d7d9715d51ba4049a85ed22ff166f80f1747639706ae521fccc725502d906681d2be76fdf2b445b23a4bf93c8b8d03fdf031d547c62a82a7f7b547bdc83230e98cc453a5a1a57283506f2f150dd171cc69ec294ebf3be655bb6bbb5e58acbe705279cbb1ef9277ad7ac9fa6c12fcda7482e8759b0c1dd3d8607d3870f94465538c19342bc37ae07452f505002eee2c21ef0b9b43f835177cd0f037403bbc2a137b3edae394c69cb78c7decc39a36bd1e88b76eb8ea2633ea1e234e1a9b99f86156c72fdcc176b6b22d23bc1c9c3b87e0f68161e638d5a68c045f37ba8279bd8d9b946189f28926eb7707cacaf52a780072e1c9d6cb1320ce976a0052146b36c2d714a74ff300a1dcaabd8ff4834565bc3ba4be7b47301978557027a57c6a27079fe19badeef6f28a788b65fc9f6e57bf8be3ed15c67495307d4ddd284cf133c82f991a5a4a34e0e571ccb4ebbd676045644d35dfef25d024b9c850981c66e9d8b94a0c99a6af97a04b767feab8d23179d41396889ec1c9dfcaf97aeae0290b0dfc8c40fc98dbfa46eb54fd482178b6550d9388681b77a71985dab37232638f810e897a64da8593ab8c64876e737044f10fd2792ea0398acf75cfd57a14410d8797f8c75c40e42f2f517954f49617c39cb838f18ca6f8243d684def01339eb57f8062ccf6ac112556fe27c71b80320dc3d3f8ee3295c783471b3bca02c91e6b1f6c7a08719ba958fe4049217b90aacc21898a71bc4fde4a3df9b04019165bcc998d937e55c1773564d61ddafbe6f77d939c1134e93dbb8166703affb315f28f82283840af21c24b9e0efa2530718380d728f0e6577cde01611606d87a62cfcb3c7d03e87808c1c4a997a1b572de7ef6fb1684d4a0d585a64ea823924a0f06f27a63c393cca38a64bc3fd326b7d18dcada4f087c6e2b5ed51cfda9e4e84a375d2b7634a2ae3237a8d0ef4ccb815defc90d552f6edd5db5fee9a1e21892c40cc07639542148a993a527d6d39c0dd2760ffa138ba49cdbcce034a34c674ab94856601b633570607cb2284cc27867c79f6d97b1a1aa3758a6061be81bd0ee59c6b8d25e8e801ee507ecfbc7678cdd8dd376b856e8d4e388a313819685842d56cdb4669fd9ee87a6bcbca8cdcfcb01a4b00b633ac10a9dd619fd1d137742a7844418cd39f0e4f3f8985f4b2e0b23aa15e86eff547608fc26e35b7e4ef18f016e6c7fe2bf0c576ce596d4053f2ae20d008f3c378d6d787734809cc05cb51ffc9662fde07ec56a4eb859ec69a750c2663293ae45783e00d2f6b7f717309a97a05a4918e068c1b799c9b26a65d4284fa879eb24083f16fe239d3ce6a1641dc2c167b6cf58689c2e990d324654d4d5e726323a0005d7a72296bade5aa21f7ce34f47611d0d8ecc2487ac40f50488aec59e09e829b6c7c5b23e597f3c2df187388172f5f906a898c148397d6efe9e66f4065db5ab51c33f427df23ddfe7a342127a7096b890174dccb5c6f592453fc09caf830fdf60ab1b634176c6b877a234b7540261370dfc7177481797f11b68994c705f2b7f7bf0ef386a633e96365598b8f57d3f35c643bbbc698ca503fc2fb5847c5e5f462cdc31753fb3bdc375d40326196549143ba387550d06bbe67f2bbf775bbb1401e4c6eca9e706128e9d90d7a3d4a8e24aa50788c88243050c09c9ec372b657917f1a360e771aa0c788ba5beb4651a2aaf2e958d9788fdac60ec7d14a7cc2de7fbe1db6a55927af269f65d03d63fff4db56c4eeacda6eecbf0ebb1957e2247694f813a059de776b22ae518345ea72a63fe1e54a1c9a75e9f4a80960f33a1f6e070e965700ec965f9fc52dfb3ede8dfdfffdb264a64d4b78372444d2ae5b97e0a85776384021102a105b8658a1f1e198f0fdd28587f4f1917b7b04586c8052b8bc8e4f842dd9e72ce42397ef8f608092cf994d2e4aa066b4b3e354c8e870105e2e6b1fdde2aebce157803898182d7f4914af0e20db677c5cec1aca21208aef9b98c0fe794a2b345bd21f025591d9a6677e53cda65593a0389a1531e8b0458262c46e42e655a6458071495aa5e7e953032d55029a59bbf084947b08c6b23a0663566d491cf4869798f5d8a3cbaad4f40154860186c456a0d8fffaf74c430d920c61c08ca421f446e8b4a9375bdb145653c118e16e6ecbbce7519d9757903d4da1c50cfe967088937a5f5ac816a05b4c2eeef5547f7afc5b5865c0fdf127d329a986817fd9507f8819cfd8fc45f9146942f52e62c486a82a37873c2cd77e99f3a9f4e7502d15c5e8908c575cce196d2f0084b17abb223457d262778d1d69cf6e6e261615e6aeba0f6ca85e5f984ac070cf2cc5a7116929442ab338e40d5426d40b773270568f94b04f7291572552e38ee0a70e4a9d6ba13737939a7d8f2ceefcdaf19eb932d9b1de49b91f51be6352620b7c6cb21503d71925b8988219f04d48c73799c417ff5f27ad4d4a66e88482c98a15716ca14ea0708e2687f598eeca9d5aaba2f0af1b6e371800608a7e5133de740997c7db70516babd66a1ce72e1d0b44d4cc17bd657ae95658c64f871cfaf855f65ba5fc2adc01a8bd8c6e7bad838eea7bfae4b586bcd38c11c8350d4423fdc798575a32a737ba602a385ecb2cf5a19dc6c6e152f4ea09fd08313eea3608b5994828fa71a716353df87ed645ce458cd6ccb509d39de3a7b4932f12b84418cd68c5940243edfc6b14c869af4b80a1564d160fc908dc9de404a89d0453935e4c00a0c5a9cabc9c59de1574058c461a71ac3a7db3df729cdd1c3eb5e83f7704a67d62bc741c403732bcb70f9aec08e5eaa827c79b2344f057ec1bb2227504cc630acf15d98163ac9dd15bdda6a4e667b7339e67e6f11acf63845da95d4967c23b6d42093fba8de33c6fac015fa16b957f2d2489c65b3c7d17616b9c9eaa48404a2c3066833004cef62b77d4cd24bcb2d647142521d66551b2c806e21458dd4a7dc728364271300b8aabe0ae5da416b1ff2551b16c3c83ef523f33624ca4ede5a81daa23b8e76f44da3be9b104875c59f4ff77a796663e2b2907f65c672e284c5e8b43eefb6a271b01ebd4f82da3d53fa726cf8fc83daf2eca5e3cbf7495bfa3e8d0cc12471bb7baa98777a5e84ae8cf428a12bdd2792f1373ef2de9b762126d889bc21cde91d72e329b6a255066c38ab5f95c47325a1623745a3ccfffb3275ac424403e8c56685b651c8672f1532969543f191b08017ec7382c7a56aed235314781c5e8c0743ef82eb34110563bf674f86835e6a88e436a764bfa404e7745e97b67d41de3fd3f17d5ad9b2ee971443e7b12cf02fc3993d16397287b0f94328376dbe405f018faa42093840ed032d47e7ed116671e3a6c0231440bedb90b743f31c2566999fc247da11edf6189effd7f09e8c055367bce5b72025126bdcdadac391b1926a948fc551bf0dbae145faee2448c446497d6b54e56cbd2770012d556ef8d827d2d75d3928b68f7f5297e4ead427352b79ffcbcb3ca98e15fa88cd0737fd113c0f8823a5978bf20a9441975cbff0446cd62395d6034fb33ca193879b10191c993cc92cfdaa9f893d4c4ca347a38bd8749cf3c3da87796742731ca1d29f9e9e2e86bd8e56800e7130a05f146b794164aa12e0d701b8b0119111a9f24fe48c5b35f8af6a0bc87cc46fb4e1888807b92ae95f36d78eac98a7fb69a192e9f2b3a3707da58a94f9630089d629d07c94a35c38533d2194e602d238ab46c14015cf33158b8e8eedbdac90c9274625993b6af5cbd7ebb673f832b1fe57bf754b993e6ed9c62aa019539cad04a10c7ac95993e6c52cd3d0616b3ef9f973eeca505653705d8674020bd83cb03c161f93c98f3d61b904fc13e4e7bd32e5f68bfe6dddbbf899df7f4f751a6b33f8a08eebb500cee16ae84e3909e5b3e611d38e689b3029f97dbc0c9fee40abded692933f230239a0b2d797b458bd202a5962a4cb66d6d0c4fa2bba9fd86eda7ef95fc046d7dff0e68b00fbe2da449832f6d6f03582f2e284b143a2ffe78abab4558496ce3774a50e5eb2ef740cc4479d016a690de45bf7254b205c4cdbf123946e51a313ac5b61efe1ccbe720c3245cb58e22116abe7e5b5a136ac466654abbb439cdffdbd0c7152334b53fed0107576feb5b6cb18f402867d5a5e28868961ad6253022acb7910031008aa864b1253c329bf7bf8d585fc3380ec9883d40add0b84f71bfbe8a44fc78ad331b3ddfdbf32bfc2c66c7d6454cddbbfc10eed71a5cc77ceb7c85cdef4223ba3d5471f41ac901b1931f82d8cf8cf792daac1da3a6f67bdfe192a9cade11f7c63a8d66c3cf25c374414880193faf8be9acffd24096c7cc9eb6a645316a81b3791880803369b0467a9d7feed0f10993df3257bc3763eaf6fb2d989b65741ef50e88e25a5552783da00811de702e84bb0da8724f7617c8865e48732a22b8c7fda63452f386bfd7c4c339e7ac7e91a780c4e0801fb135567964075ccc3884fedf1506abe5e7ded535155d6d801b909921b34ca2846d4a07e3054ab58ba4203415da4ba25678436634e67ee867eaf9d6a9b99787fd00c7fce03b944805046e0a00a8edeea42237f282d6cdc67147b8fab892e381b21bff8c2213ad8302cf5aa55075973176273f4c3c118c981507580d4a824da19362a5515c4495753d7f49b855952f23cd5036eac9cc5e067e79419b22ca7d820a195631dd38e22bac8b334e37774279ab95eacbc346796f8c57245fa4a28bb7d56aecf7bba00c375a06035d407f6184c545352faf68efd324486222ed24efef1d5a83837029b1a38b9f6a6638841ada88742f9ebdc5e626c6432746167f6a80c6b9358ed1d7277be2ccd4c3835a7b8038c3321df90a42c1f7dff6551a433f2957bdc334612044d86334664632c14d5c6e608d8b4155233672da0dc6309ebae7fe56f62dd7a94d8e231ed891969d7e9b6f956f5cd28731a63f4870473fb4c77fedb474f1d398b1a1976fd88521c7a223180739491f4339cda543cfe73c278cb93b47e538585efa987c6f3548c22f4815e3748e38ad244b4275e6480279d596e21aa623d44523e8d3036863d6ac6fe7f24f2f3cc12a475984b976d53120683dc6259783ae9553dda36cdcaeb14188b8025e677ac4bcf48b62b83fefa898a3da7c41a2c8e1547d9eb02f08dcac96dceb610b0526e9218f5deb430a7933d92f3dc422f7259f31c2c8467f3b65a691399624498ceebbda9e0b74856a37262c18c68503648d768efe60c70b72d82edef4b7fbc0265d0821151ce78571bc6f1485bb56e09377d02a856a5b2d8f7c8f948b9d37a74b95bae5e42003972ff7f6f46882aa244b997f1ad18a0789781cd82bb0676e2c55285f9a1619e134261feb8a13009f3df491d3319f33d8506e46d798fb61a4363724f594c92a214279b738e14744a57656e4def0192a7bd1838602c3b1348f5096de735728d4488ef2d51d64c3051a6c8403780c94fcc9df2de9889d3929133bf525bdd9d8bb3d5b3c8de8126e2b744f8ec65ef2e4b1b9f055231fa247d979ab4b19854f77919e635f468855a0eecf53a8bfca329657c53bd5a832355364725c024e3b53490aa51b22f34ba755b42a2654286d8772814ff92b3e161990406f4981812fecae16285dd1111ca6e4481c7b913715bd65803639ecf528a11c773e458254a9ea6723618591a6b3d5df30380ab4f911dbb732bb7b28f76217cea9810a92f5a24f6cc5df015bc2298768d5f6ab12eda830e011b829417bfe2d1020bfd7dad9651f4d556dccf3bbc15f1ed0fcfe43cf63ea97f2c7352bdacab5282d6e6b6e9842504a07b6fe2410499ceab20510852d06bb821ef8356d155b9355a5c849206a69db54210e9bc9f6df3043ff3ff6bd17bfbd9b283ee45aaea41faf50f6d0898016b17e41b6c94732697a12fdb14c7d3d2384659e6c15af1d7e203f802817f8a1e63b4534636ea9f319dfa23aafcc4020878560c6d3981976c4c26ac7864ba5d4b55d73c4c4555157416c0c539ad6f70ab1431d0dd74e58ec9bda964a2e2e0c89b4652738341eba50f861540ad2f0f1906c21e6b67590b575f6d5865afb2420271867db61bd42db52d055dca05e54447fc8616ae5d7eaab3c96e72560ea022b0039265cb07caeccbe38ca989f5f65377437c7fea6c03a10dcb191004a4e0456dc1b38b2106820ddfc9244f4aea95a93fbe20f601a9070103b0ec41c49fc3c2588c5c1976c555b114707104156cc3012564272d7530424a1918d58126d7eca3273f188c2e2a79420390772bafbd61588b042bcc6fa05d5d32a8b0216ed212a19b6c79c4c28d68cc1bb1165dce92aac08fb92131795fb4f2d2f99ebe6852a7e14d911efea04b07ddeb172378c78487b0638c2ec83fc6ed38ad84b03e0646de971670f839ebe260a1556ff40722630c93f1fd7d7f407d4509b4ae1e7157c5a4839586d4e576f62c0ec9ef3590dbd9e7d872d223e86eb9a2187d541ef94998ccab50d9778c65ba8002215d34edcc9508fe121eb2b577d95d48a69010f58d49a95be0fab077c2f516b01e5e4d3fef2be81db2191efbabcae12a98db3159813f6be9b43384a404d8d3f2969808efe0a4ca8a7aa2ca33634dfec3d9723e0baf440d963d5065420d182d5ff0502c51587a0d66964a21a87d22d5edb88b2a0814463db039ff4599e6906318972d9e129a17e32325a798f333393caf7eb5ac6d16dac393350d473eb7a33fb7f3ae5792f032c67b83818ae11c0c3b79499eb22459301776573ad8a3094d720bc35797eb5076728add20a15e4e2f551570f3785421e46bf2df2a03903b27bd5deead792ddac4761759473cc8e36580011d54d7b1463270506703ec976dfd1b59b6201aedcea4fd1990cf8ff5bdb91663ba87ddc4749007d65db8035cef65f9943cfc8e188379954c9f75761dd2966e7f3b6c0e659a509e9f55ab5ed473b913e7f1787daa3eda85e2f264bad24d42ed6badc8f1a88d6b78cd98116481348c4b0e00220e6a92eb444dd1ef100e31b3ac66c3da9da2c2985a13b6827071e6a52b046b88516abd0fb39f0356d3a8e95c73efbeb37cbbcd9457bfe62b371e4eb47d8a9abbf6ded84de830efa2893d9b5ced1170eaf41f2fa7a9dfe916c6b89f16a9dda09489ea0786898610b7d74cabfb05a58774f4bc0e61e1aae0e33a8f35d70efba1ddf372eea689f5c9db71424fd23d994f0ff6a2451aca4c0fe9e92ea5ff69f3ca3d50f31370ecb98e9f110a797ad4327f4e9b432e99ad7bcd5a4d1f340feefbdb0baf34011c0053e12f53c5fa2bdbf6c8d16741c7c39baabd052984c479bd9c0fefc38fa9ee808bda0ff8b213a30f28ba7235134cf82770c12b81011192860578820eb7ff2445303ccc8afb2f510742586e45f79778f46fe536ca8a2c7b4aacc81ccddb1501d170ceb00f46ce0caffefd3f1d1c614765b16d63bbe986bdbaa5dc665ed69c341a27520fe2f19ebeb36516648886f3f04d7cf3109dadf37aaad1d44b1dd721066091f4e18c3d277711fc43a5d90d0fc90dc2671c8f8b2ae491889b86a37ccdbd5c2b13f84284b679a783f81baad6b644a5f7719bcbfe7df48a744a5f6b68dc872439eda9a814239a31516224d216b6ea24c677f197e324f9598d0ebeb1da42ad5de356a324db74323a94e6054401d818ee8ae23d2cd0fbff88665f45df9a4a94b1a339ef5536391090ef14b9131478c90a7848a42286d978dc893126c42c4e46b601712d867343a4ebf883e945766c3d7191c04eabc6a3fa2a82f3f3a8794b8900530687277cd578250be26aab07000aee50b932385eb2e12ca752b568774bbfeb42ad3d76e9bfc66496281442860947e433793bae4794558646c832056c535e2ab90b6ab50fb844223e3edf2daef36b60663e586e65a6f15d1403dfab6f0d2dc984294d48cfb08889a85250b10ec3c1534378c761cfe0d82f58fb443f8a02db5a57721ab2be46f77174980c5ed6a81fb83923aa088568dc6985c5fc8fbc8bbaf310fb0ce82ca1fd36f60428012206db157c7ac0aa37770b15986db62746ff12ea35696fdca48c84013716424f28f22c4cb95d41a947cfe0aee17db15baf7afb93497747bacad2ea96b2ed4eb8394cef872ce1cbbda39465602bb320f8d0e5ef2d009ea81f2ac53e8349739edbf7528f2c013bb9fb0e6ad3fb4d3983829de68053357df699527b94db676200e7fe8b69c2e6149c2823ad73682cdaca41bea3621d1d87cb993628ae0b8acdc609bfb98d79fe3bf4426f3f10a932e822da8608347110a1522a4b1814a4b3e59298929cbe9c38d4e03f2051f02334e63236295a177ae6e949d2e8022c83f888e96863f5161a3e41547a5bf7e7851111acd3c8f0f1eae4845bd5842927cf809ff3c691c5561f9b588436f2fc4aae64292c3db019237b0243b42b0fa68c9c02c0a3f3c19a520b30bb607c617f1c42bbdb9868435bc599c79f6bb00a46c4ba0e4b5edb3f490e58be58cf475f61c9a4a76befdf18ed5588f8d361592db2cf96c8d6536c393f49b7b1bd8d8c70b245c61789ae4daa5e62e6d4202dbdead6f029156c17b85705710e3bfa82a019f725a4ac79be06af3c6551e66997041e6a4c499abe50a6494564af0c92fb510fd069982f7a7787b6997e1df9c954dc9ca6f445212dcf84e442d977d282b31bc3019273fb30e58706681100b74d663b6e92f0a46e6ae761f02707e36f0d3f1556a6fa99c28e79732acbde05a33004367622bd51a27660cbde2192a30ceee92bcda594d5a39ba7bda05e0c99a286c85270787fe0120d9ea2caaf47ef080e9540d55405c3c5fab2541b2e03503efe9b5a4838d5c0d14561d8a68da6fb29d7f5e607bf1fc4bb7f36a47fe493f07793c6c7b50460d1949a48ce87eebe836d8796aeb050fd87e1e2b83207a52c0ad2f52048c3bf94368a20ad9e1ba43aaea7c1b92515df47c1274ab3128bad9f48f3a21466b48c0ad6871b020ab5cb85374488ae181e1ebb2675e5bf009197d674ee62b2be81836849c7b96f7aeadec40a96ffba24d602779be7e22bc4ab4a1545b6486196f1a6f1783992de50fae201ad6a3f2fa4c12d2c999d7b91599bcfe61a17c2dccc93e405aef039b2524b52221660a50048afaf437f4fa7d0cf379beaa0ab91a5d2717e0339a8cdfc4206f21c8e1e4451319da34605bdf462e5cf166558d1fdfef7f810685f14200a79b84a80c1cbd23c986192c43a2aa480ec5656151c463e31460e5c203cf23f74af954c6f9c125f3fbe8f02f8948f25c8c959cdc52e694a5a635894e48132fa16bd78d0a8eaeb3b23166afc8bf3bd111ae3fe005f70c3f551d5a3e94c507aac5ceae91f50c614a150a36f8023c459482b121d128a7ede589435ee3e21835fb2dbdf17163c09c5d585113b7a8a4d90b6e0ffa2dbb94144bc386f28560f413ad5894579ecf317026ae2add9cef9c88b9aa75594f472160b00e8ae0778bb7cc7235d3ab5d2fa494db463eb40c6e75e927eb4c3bde753e4386b081fde7098041e900f7962fbc5accaa7258109f640983996d50befe78e7bb4a3f80fc3f07891ff9421e39aaec52a02dfe78601c33bf5a76461e69dc7f939d29aa1b18a6d6396878300d43c6cc13f4db56771eb1226d4f4ff5e0a01f58af535696e6ff362849cdb68309578b782038d4f1b5a4fb4005cf6e22e5337aae4f261bdd8ca242c10cdf9888d000cba2ca00ed6f38b5f861a21a917810cbe37ee007df16064bdbc173bb3369c05025e4912be0adfd6b727acbb45bce5a5df156e8969d9c41372b3c91ebf6ae10e20ee95aed2606165a40415363f6d8cc818e613addce8e5893b9da2353b1e49d37b37602c8839349f9b8f6fc17dca2349f9756f0f08c18123d49d9808479a267b2710b6847aa695ed2a29fe9bdbb5b3f1b11dfbd43d5ff2aaaa75d81ed8fa62580e72a8ca471dcc08ab072f170db76a1b7a47c949a8f984c90308fcbc9d1044b2d5706d03e6936c0a8a52aa7a36d595cc902fb0b88207c0621231eb008f09fbd50573597762d273da2e659daa13333f46cbfe2eeec459e9e0f6931110d7a39e661ce932658715119ffdd9585d7c9818fe098bfaafef815d1e2a0aae50690ef3ac6284b5081ce1d6d787c615f1c64a8a51cab4ecb33a770760805e4f429b3eea63a499a13fce241500e748bde6e4dd7a0595db393edd24b882d5db297e4b38ed6379c58f2950f7c4bae599918f41b87009f137e2e1fa1d9bc203e6a8838be7c67c8e7bbeef50c4e4062c7e28a5fa35c0ea8eb3059912a8fadc6e961443b9b0d129f37be8d100c403fe7066d871bd105e06ac3cbb90d0e72eb49fa5067d00b8d5549adb67ce68db71581bd2d133c501a8f3609e0ff9200e09f37b4c44da6f6b70d5025c81341d8cbc8afbfe86f6aefd6ee12e239e676b499a2c98781a7c90fde69ebed617d3e53d2e553b32cd23034c79a1ba948969b958597c02b4d1d44c69c2a2b4c7a0180816900a3e2be1e5c0996a1b68c24c1d23b8019e184f0e3f28c80d3dd772b281d5acbe0657ae873e476fc9bacd7a7d30fd9e9a70ef10dc0e0d99cfd6f575bd7927e06500a486ed448cc838054c8ac305505d32a110111809a05660fa0932cb242d4fe34ece98f0fc2f9e8dcea3288a745107beb2dd8fb7043c87a0ea647eea81d9cee88181cf59f6c1b495f173fd68fd6d1ad3b2724812f3ef17b6b6406a8a33e47c7c29ca9b8e18f4a46b7e747e9a62cf659a0d4790e4ada097e9e722734d5e9c499c025cf6237afb549c06815759509b56a50037ddc96cfa0ee895c4e3370f1b8cd4325e6d4793e1c8c89ca5057cd346475573da7fd2ecc07a728210549b52273e5231c3070f9875ef7c3a2e6152876deccd809d73085980e2e36019e388cc96b0ca0f29357a06d610c8ed4cf757955b29d4ba94c12f1f4e5587de47ddb4af952bd167b436b84c96dd26cf58555b73fb6db4ecad6fc5a68ff91fdc434884376cbec37ea434f78f9da0264ff14f1b4d7344aaeb707b7d43deb09eb98ac6c9ed5a86c52dbd38a652a51e87087b903dfb47eb5b358c3c93a021e921b087d07bc81991a3ce1afa8ea5c41cc1fbbb056dba34498a237ad164a0224b8cd0714d6d744c895dc6902fc2a5cddf6d170cdcacf66361ce5ae6732739b6417965496b9ad1a325e494fc6c3ee7368e0c133274c599661df58766ef1771a40e977c701b15b3e77110006e3c8290bc383c12a4af004475a218756c684e536098d09dfd4084552abb84d66f1081c9806594def735dc6c7678fb879a7b311972ccedf21b6d2b02067126763c7b5810f9c8310d6cc20c3ff3b063e7a2808c7012497b092a4eadb3ef85167d5d09309c8a5f32cb731285122012933ec2e3ad3c85d3647d128d87927cf517f2bc6604d8638441d14b0eb3d401b1029cf355520b5d713da098cb976894dc549e84cd525abaa2abf8ddc6f1a147abd1a6894efac18fed8c7326794caca228523532b8e944ec4096fd0049d009f2e638375b9bafb67eb057d7cb5fcebcce7ee5f27274c47d07d6bb51f90d27c444e51aa969f3c3cbbda35855c26169b875b1315865672ae9464a1638ca7c0b947dbee7ac5c6364e6610842fd0cca6766b9d7495e2885dc1d80acd852c740f0492e2df42f9841f2abd3c88ffef2e306762fad1d4eae4ff6d705603bb6fea215ccb3947da8e5d5e3ca620279fc28ff7e209b474f79628c3a3bf53b68c5e19423c1473bac771b9ddfe35696710b38588dcd6112c208554892b0a69c23a0f023bc10abbca6791c45e402c2d89542ec38acaa625f65fd69154ddec49f635282837cf7210bbdccf9bbd9a402fa599328e341d6ba5ffc9581f267c436d081580b472da767ce436fe1a3e898966d9bb55f05623d68e22bbf5d338eeeebeae3aa1e22ba07392f3668cbd8e958e0d910b375fcf8d364684aea0f1f9b9d926d8e0ba6fc5259228a62e974b7d99d3c1d9a2b69d8dc17a457bb77b9812ed84284b68ec874c23f5f2751f872e527c4c2eef154f419a7653ca08e65f95f660897a566103557f246d44eb209f69f98b3d367b803a64391ccfb016b76285ef17ff6d33d36a72b973c796a90fcfa176417bad15d7b68160391049b57f2eab4ccfa50cf89e312aa603818f3cc111ec34a1ff67ca42df5054a4a413fd43031bedaaeee913718aa5752301b97fe3f9a5c1ebd5a836363e6448676092fa873c4223fc3fae8663bb83b312143e7a4fe72500deea86a31fe413ecb12b86dd9c52351298486a8afd69a849dec9c1993f51003d1cadb211668edf75d0686b047b5cdf4566e0e7df456921b93d9a8d2c2dc5da9e71600e9d721f020424da2a93395d54dbf06ae46a647e4c3fe267f95ddaf733b4f4cd3f9c77c8180d1c189dcaa8c66b7e493a6cac86a8792ba28889d07d6f47a8fe897a1a06a27b389e78418b11c2434b1744cecfafd05676f231695cc0026446c50a11d2916da4d1bab39040c0b02720003d1e5d8f4ef4184a71685eff10eb9b723ac684bc9fff565ad0f2ab73d87f05e7fdc70bdd991bbbd3a71ee93a41e59651197d2c8f4ee98a03e8fb12b0deb8cea2d88074ad6df476388bcbeeeef670a2155922e0bbf413bad480637182fe4b1139088eca0a655a002a527a443f56dad486b206be0f1727eb964c6d21928ef372d172382965f45a1e622abef9c8479ad033ed0d7e3f130d3817bcc8a8cb60cdc309732452e5de9c6036fd8dda55241f155b8e1877dbeb430d44b96027b59e9b9bf8c420f7aef3f2155e9c068ed535601bbfb074705170aabe77d9bbad7f7d7236fcb7c30c4562da52a72d64844eb364e66dde599b8bf724da2d1530b4bb8864196070bf272e91d9774041f71a26f04a6d1f12e8846b87aebc1a084dc5cd83187ff9c77c081efec18fe7dd564d8eb9a93d6bb8a8cbace7e653b0107b893b8af285a5affafe4d85b2c39add1366a47f23659375c6be54c2fea6003ce1a837667b95d285947e4931b17b73e914c988ec3b2114d5fe1081c2a9e48861c46b49b44dbf91c9a4116b3057a5dc34b2c1dad1812ba5b8f44e7520b8568fa89735da74dd5e8a99865bec150b70967899785c36ff965a330d946df7f9b5fb5f97346b73650c06f3d31b51dbef8db71be50b529a8ccf59273a71876bc7b0328828bbc55648f8913de137c4cc3030fd4512ca77b3b0947fe1d30d26247b9b18a663a9dc5ef0ca0e76252970cc366d00ef21b31a6e4d1a2ca2dd3e73a2558e52296a9c95d240ea4b9fcdf65059ff50702a96eab1c8d096c6dc1bf8e8fe0c4c376efd1c5f299d9c239aa5bfbe6286925c437c68fa512a7b9098bb56a6cdadc3e1ddc131c9416a49f6a0978ab97efb49819f0ed7ead68e05cafef832692bb658ef7e5d95e417d0ce8069173a3ba217544795a35bfda43c4c92774cc7b1468c78957ace7d9387062bc3064f960c6ad8708c3a8b7d7fae8d06f63a8920370fa57977f5375d3c731c97e4fa480fe94fbd98f5a5aca733124fa6dd97af0c3d92fd6b45e63d5d4e743a847a005b325d2e3215706abceb832ac384ff31704ee9311d4b6efb4c6b7e5bec756dc6cd6a03eed1c280e6f473404b0b430d240cad55023b9a52d83d3941a17dedae93d5e3079af1e31412711def96a9d3165b2e7fa20fd13873e0507d6f1db8a53d5f7f16998edb23d09f11bbe49a4c77ed5d65ebd7ec6dd1519da87f2da9a7a35fac646b444e47b72812e73ec381112493c2a2b3fdb813274ac59b6568b9d413d5b9011492ecdd6e07b55ece7f80c21264db2beb682107de7426e5ecb062817991f470d94d0897d90a1d9c5df5b9e23d1d2312d38d701ce4c9c7dfc5560c50002a0af239b106d658c5fa4ee86029a84520acede1b5edceb415dcbc20676d1eda4409d9a6836d2e99b0d594eeb1a0b82620e7ed94c1e685175b91fc90c3a0a5b0404eac7b5df9491852cd7b941bbd1611b7976d049f706e88e33ad9e3109394563da0ea57477e71426da6296c969d2291ab3136b350bce8bc69db5eeade02e528744cc85b8c7e7854735df97b723439baaa6f773173ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
