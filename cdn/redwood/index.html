<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a6e89aa1a5a1b45ec2b52eb962884a8107948cf7eea2bc909248f63878ae52e9b74849facff9f5f8a88c7d299716fccca6f341a9c119695689c2d32060b7eb0c8ab1f0282ae67852fce290af4d063bd2f374e4cff577f337aaf14fb5cac62155c755cadf2c543cacb8e63ef2b02cbb424d700f21a99318663dffac1d0f6f35707eb6bdff2f7a439b6a9d2801599b4d0d91839772fee746317f29502bbae1b69bb7e642b7f7d5cfcdbae6b5486501971ef0e2d62743ea6c4a949ab4fef326627892d6c2e323d4cbeff66591759d11c5a62974ab07427f5fc4ade853f398d07be6c12e002744a6871ca48f085fa724b1396eb5eab5807b3b81eb1878c7c5860d9dbf7e0068b294b3d3130a633a530a198352be64faf35cee8219b60cc4b5a48725d51554fbe75db088c5769f1a90cf5c4dc8118844cadfc96997a8b40ebdc673842c3b60d7224cbe78bcff5fa8a2f8c3d9497e4c2e198e5465d881100f7277b37fecfe206bd9985b93cf959dba37a25ef1d837ba0353d990d24bb94cf64a83d61cef46790beb0e15928ecddc91a462f43f34f655273eb82a4616fd56737b2d153eb22c09ba23d0818e1fbc0793622396ff3e6ac044a62938c6470b18bea06ed029fe9ef6952478cd108b2fa00b1d3d4fc2f39f01e373c34e72cfe5d86505c5de52203a16edf6c9ab01eb3ad688e2285051e7921089606257f0cfdf4af2032557ce3835b185ebd0cdbd7da741a190abe8d8dd5221df8fe075d6105fb90ff7ba09d662a3ea2adb1b53da5aad057c34babf4de7e93a173daa3ad512d7a3dc27fe5868d9be0016437594e6dd845693080859eb111972c8cb409527d7c68a8c5d9315326e48b3ef9261fe83484b6bbd46dcc557c0b68cd9e5650c1fe361d9dd7c766f234e0dcaa574c4bb9ed68e5938197ff6cdaea68ff2ac414fbed439510c942084af97b4e60ad187cb3e51347a32fdabf529f0a2f1a817407c6c68b0b2dc69490f881f9ffaf1dc248d9d841e99551514f678215e2e88ddff435fde70974feda7685d3d02b5c4d388952d94727646e673b31016ab96ee490cd5a71c5cd08dd6a6718c36e8fa3391fccfdc9ef1cd3b55e229b96a3405a551a0739777c36809be2eed9cdf74a1f16f98b8937294459e1dfd81e185cb0a4d5b6015010ae518630719666361383efe489e84718fde65f62d155861fac52e9ccb09da1040a23257bafa3c21dd2aa8ad17285aa9aed3969e85a35a73c7a383f7a042df01f1526f3eb02b4fda3565f065c524b724660fab106575565dfefd3d93b025f3979e6961123b8527c231a07706e7d26743065d10ea141a49be6ba4f80fcc88a83fd47d93c3bf9c8e9c544d1c227c4b56297b2daf8960d69c44008c94e5fbbcd175d663e437bcd564da1edd2297b5ed3e7f1badda342da19fe314904dfef17a5b332153209b21aa3ec5b43c4a1d97036a4aa3c8ff186e1e478652bef19a7f9915ae031e3f7b2cf4b294dcfe18844d3b730eddd25950b2f5270860f7c41764906ae61d3afa8b5fe14e76615283a9c55655db9d59c93618245266b9b8ceb71a998c7313ec40b89f7ead962afb75043bcca0f944caa3fe3874f41eae944920aee3b06f847fcafbb6d09ea8f8cb75af588c4a18d45a522b2b73de2ca549dd7c119a28d804a04016f31775c8d06b524c3c273ec6c3145326d4e3291d68966d3f97dfe775962753741f645d8886715c1a26ad8f3926b827ef5601ce4884a52a3e3af1c7f7624c2b0cf647309df0f87c3b34e7c6e6d9bbb33e68e3f4da6fd38a700e060e1dc96103c18bc3d01cc779f4510dcaf3580907015120297ad15e23111c4bf50da2cdc826d907c496ce41db507932e2f10cd43a43c2171bba1cdc4e421682bd60fb81f2ac57d4b226788b7b1ec7e46baa5ae498dfcaa56e26d347f4def2c1a94c42839d540b52ea61530bf5f3590c03abac745e293d9f15b24a8f701b8ba85c96b0f3b4a8d9c138c58e6778db3cd0666e3870e5ca14490a4701b004a7c79d3533c1d328d143262d9b23b051cb3c04ef30319a9b1e4678d5f379ea10c4d424f18557b878b925b9f091ae9cb187ce6ec1997198d1c6bca66b245c83558b6cb7777d4159def901ad17e3bbac482d2cc5d5f51a045be888d151d7f4ce520faee62874fbc47d582d43b13254d55483e9fff593624f73b4f9c8aadb8e552b5f2cd831ae1b1d969dfe3eb622ec373cda5a1af2959aa3fdf9200605358c97fedff243e67da1f0f45157b077618b88815854d086ef46bbbf56635fd8b1d11a5f0a259556ec54a415e8f68e6be943169c23fedeb7f53a214d7970f9b5d7e307a217d237f2853e030e8f08c7f05125d02f5b576e6e0692f1d8af6cda30ebebb23e0c2eff39f34823cc07acc9c2c42db9e588819060f3a0ccc0d3802f33affb822d9776e526fcb10e8886861140cd51a8ebcb7e3dc4a8b55e6f91f85f32e7e0e0479d052ad0411025340d34907431f4bca20df3ec1f36eab18aade42353c9291eaa9513d133b9ade5a4605fe36eee3df902ce586600b12f1f1debd30a3294d684128cddc3a18ff7441401b8abfcde3a2c3458be5357aea9efd410f734ebb804796b2aab04b00eca2df8e554478c2c67818d873759f9c71fbc93703c0f7b0a42fcb0e148ae2b3127e1bd5628d98f805a76b941bf195b7d46c7c6c231bf0573005ac5c69c00216809ce1a1476db800c6aeebd9f714c43f91b7d19bd6977f0188c3e6a06c9c0437dcae1795410723e0fbaaacb9ca1d20af9cb2a283dd5c606c3e27d448a56dce6a675c11a78dd5e33498f3521f569df01341358fb01f7f31999a993af131b572fb972c58cd9cc78450a64cd5b2b140431e5fe7815ce02cc1f45f12b3160a587bbb6e89ec3dc6c5973744a58907f9b35a6ad26f96ad9eb649c63b289d78c4936c13825f442d766e0292a8485ea4699efa8820160ecbf23737f47edccd3a053a5cb1970c0d2745bff8c84de3184f6b770b48ad955939b85a20fcaeed0982f120657500ad148244f8bf33596035aa904b4933bf5d0bbd486e7660891fdaf5430367446602f59583bae5d1a85217675df76133dcd5bdf141ae0481f52dfe8a61caea37937c5d334709d9554e4bb35acbc0a46d3aa043041cfb779ab89b921d4a51634dc691c7fce2b6bfc0b9e467fbf3db9a63b573f46d282aae55b4176bd4ae191f869c50922d3334b8faf408b3a07f5ee49fba781d32b0722b55de72a6fce851c110558a7667925d9596d962e872ca724e31e213ccce5d209fc82a3adc82c7e281439a6ada0c4387228d15711a221df73d418381efad52b8e9d46451cf57509c77010f5067902b83501bba11a051a2202354b87b36a50677101c6d1a00b5825bcf5891ffdf6d1b8656029993eeaee06c76c39a0670852e93d8a6e70a2e5da279bb5e9bc232b98f74528e1e6cad520d8ca8d5774f61f96b2b4e7741edba47ed81ce84d6d389dd6133ebb2854aa5a18bbb91c01125e99db8530a365d4f1fde4b25c12a96df2cd796cb8c706d37465dc0817f6a6587bd88e73b01346ad01a0079a06fad6fc26c2cfd58f038efe93d24df76ecda48e55c5bd85fb4c46899f093fa30a84ef868aad103385478f4a80f8481919137006e27eee34b4a8c3fb8fba146060ed4c4a869d1c36ea9697716a90ae6e70ec957dbbb36c58d60a15b1e7893e7db69c6829fd375cd8dfbcfb55ef5c63a1f4178f05fb075c9963f76f0f0ae19346e406241acce77354324309a37bb4f97c7017930affb2abe2d85d060b6cd44142aedf99b8c5af0e75d204853be313521370468c654794db5ef6fa170b9456208c913f903bd66b7c1100d37769f0f988f938d2e6614d6290310ecd906d192aa391c8adc5c04eb6aa2c8ecf40e8f1120023a99cd7ce5020992ee7752b95ebd32ae192c8d72c69db1c4fdce95f4e05c62fcddf54a22910593aa8517df13d29308377643348792c147c2b19725b90fa7a9ad59d1e8818c94b75516feae24aad48c9f54bdc52fed11827444b03f985debbea0cf67d8c29a9edcce784e4e42d26a624ef9a91fad5a663fa49f2986075c5ad7b385157e8462be7c9e26514e2b63a4c9fee3c3647f34b626f545b2fed228532b784f8c59d4be399c97c05064c1c559bc3c28d03ef301f54009903c7ee57b8f3f2ce75990d83bcf29bd8b254dec2c79c757a9d9031040019ee5bb30dd32113d3b92b9cb3b1465e130b69f38f1b0dfd9a1de3bf590ef4a0e5ac68ff92e73fd01e6ec3bd4843ca469bb987781c7a66376231a02819a6cf7ac2957fe04536e0e0b8b0187037aa6b0d9df9e073352731049e7a1ae4b9bc1f6c6b16e481725c69c9bf65a7335d247c005fb4f77ab4a68cb4239bced48b4fd2ec8a236f12ce862a6204d1c6689bb2aed727abea02d0b6110e41937a8475ad49931a0c9ee797d4bb31b0cea462a0e736eec9bd6ae9af7ab2280065a7c7dd7823876731845cdf68a91537b3e1418c900538c0c613cd82ce66b4840bf47d8a006f97e97e128e631e00faa2b9994311d5c895928771d0f2a134748b8d722f9bda68bb10e69920758a882858bfcca2173ab9184ef26f7fd3d9f5cd7dc7876176071212600e9d4bbcb285309697f762b78657ca0772ac0491a64fb61e96bcc0684d9d97eb04a2ce7c50139e48e13d3bf6be3bd390a7187bea4312e5ee765ef91d9be819330699d9f3d8319980a5ca938e58d40b0565c534f1f1fca7dcba4f98fd90fdf9a3e0f6c6c289d91d3c082223cb16caefa03684e2ffeb054ca1208d7e482dec591a043ba4b3a9d45a1742a438575aac63226a33fb9d4f60f39384d27b3c6437aa1321ddbd841e52401c2a201b9054844270a37cad3509181cb1a47b690f28536578ec6e8139b172ace012c699b5c8a0798a98eb8230479ce9a8539874ab0cb2804b765dc6c632287874c02357c0bb6ff49e6c692ddba55ab3301fa9cd23c2e006446b95015e7aadc767be6f82f514da0fc1773fc762023248fc5381555064ee7c27b9eb9721da107b22a8c0c0b7b289740aededa07b6e23b3c26db6055028359efbc8562e6058c8f79d9fb5f079e7b4313fa8f70ec7cd761f82c0d0bf9ab04c36a536c4b0e7c8c35f73deb615a8aff18375473e28d427f380d82e7c3cebe9ae21abff7ef6382a8e9d9c53aa14f46eab8611c614c5b53a34f142129d88022845a7cc1d15992fb350d8f80fd32f9639f8627a9cb82f2462c690422cf59fb50c9f0656a38096fc6d38c8788b30b8b819af17c672f99344cb4b81b5a94d958ff6a18658a503194b095dc764296d19331e0276e0d5f9b04909cfe902e0ec8e61a5ca87f7e95a25bde475109c868b97f39c0fb3737110ab9dfca7a49c51ee2ab392a5f1a2a9677931d4acbf6d9bfae1ffd94f7bfdde4dad675a7bb90941facce7b7582fdd95eb9f3f3087e98633ea60d935a8e4344f7239223852cb367f9ae1c3ae0e1aa9e97b392c1ea6ce8753b4a2b3fb46cce3385033d2e5378760b7a6bb00da23e2a29acb3eae98f6e6d1b794e703b64c3945d198e69afbadc1c209ea1b095f023c8edd835950bb21634d5754f7057b6bc76431a08fb76f4a2686c341ee7bc34c558ce73b8b256a9976794a9d1be1f62422d28675aeea3dca586c23b067dc01ebfaef70d716313e1fc28a8996bcdfc520f4c85ca87694a55e8fcc2c22f45f5bfbaaf516fe38f8138380565bd36bb6fe40493e6c6e01975d8079a611f0a0a509d327a931781be60b36c0c9e6eeb24d0d083f12e380eeb82e94bc6ff6d0c29afa2df69ebd6ebdd8206ad05eb207f64cb377aea2eb2afb07b54aa38c7d41e23c7598e491a6857dd32a2f250a977e9692e5306a69eb02ecc1357437dcb7ad86f0f5734a712a839c0abef02f152e004354fbf8637dc64768812855e3f958776d47beea5ebeb4e6af5125c45929197427c026dc6451cd2083e842b755bd432a92bf338229efc2841b37937dd5997b38a87fb9f16318f2c494c7e6da943a846835f5ee0d19d8fec36d38635892c908d844691a9666a5426820d2d2ffc22741562cc674a512cb180410a8f7f4a9c05bfa3554e128d736a9cc7df94074b9f2c4dff4a61343f626c7e7786e223d8fb1fa05cdaf736ea25cb151af87a55b005cdd7eca6117e934f513a949ed53c638bf5247812ac6e3d457832695b189202b027726903d255f444b2bad77cf75675a8b0619510357bd8ec176e17f4c3ee77691210618b085b1751d61af155e815fe321ecc385055b8d0669fb327a02f8141874c7dee9cc19a44b26f9535dffcd184a797cdcbbf8442c0b70bbf27625597687d1fe6c8ac180e0a15c4d8fbc48acc12602e763a822ab7e99051782df5fc3d930928765f86a91d0a643ec20bcf6230645c5d156dbe0384ac94f8b3f702268c85c003dca559695886a3bfd2f21cb5e973e23dc9269aa22c948c7cbcb7fc8e01b3be56c4d6777edb0c8f711bf4637b5da9d133a72f84e982079befc72bd9e693047c6874bee98428992339bb154b7c141afcbdb9120038caebba5f0a563b6e1c1db72c6e5adc4eab9a158c7b448d1426b9bb7545a102a68f4ca33f9c108bbe7112416b96a186acef65c69b4253190e69adab8c3594cc9f6fa7e059a3b82f976cd73929ead407eba9eb9ae98f8304d51256bfe432d6cdc6217958a45dfdaa623265e3ac48176d0ebd5798b2c2600a27bf261693898f34b22cb8547f9de78e4403d5eb9dc815ec403d4fc928034a6fda91e4a07506b0f06ae8be0164b608da770c3e48db022ad01cdd3e41ca69ae3886e5473550d06ce6d6f831e8243876fe0c53976e4cfe7461419d8fb18ba14f7b0fc5504a45075595e04caffff5628b43b2fa7512c8c4c17e7991bee8764810cfb3e133a3078e29b1bb9172eac09bb91829c8f7e6f5c523de0bd69e33920dec96f80afd12e76ad27bab1598493797eb75eeacb384fcfa73c56b007045de9de0b0f3fc7d9506f5a2b960df280abb9e439e6ca6a1da595b4a9097bef6a3544edb950d13e7b139beb1403cc49dd095e4b9e85b8b1ca6345a4db5f737bd298f042f5b13a736352f433f0bd1b7e5b7c250acdf4f549eabeb13fde9861a5eb12d7dc62516264de8bbea37293297b5230a2ca6c44ada46ac29b14c9d76dccda46403bc43c62f4e6946c5a5093e098d4a9545965601d3b75ba6f29a2a68a634da9476866a89bf741c6b69b03e9a9f3175c54f237e0a69379e109c1fe15dfcf186124c48ab2f7f8af1a77428e0bd22581ba97396a9fb9083f1a9aa6f97e5ed5d8ebee976157f114c585e157997177202ad1eaf338a5ee5c4004e15efec6add07f55c21b48cfe3a678364f52b7e17b040b55a1a1ceb5ad036dcc4b68a86baab7c5db982cf1b2fced1a5bb61c80b31a3986b12c666927b9126333ed1d24a23be800e475a6fa0bdb292a05f44b0ca9930ac5d9778604a42c8dc04d65b84a82267963a448ff2f261f0d8e5513c1f3da0604ba5e28069f0870713395eed11e46816af288c94302bb1fbaedd3ae0e272713127d87212e06db3dc5015d256454d91145330e860eadb7e331ca667f0ff8bf970329330cc6893c0b61a91872048dde4f13cf6600496006df899a81caa39790a1b421ecd6025175b0fde7bee0fd4543aab2fc41ebd557a5472f31a4585f79a8c3bc83abe0fb326d1b8c625bd4bbcb5011421a94d6b6c921669a8c4d4cc778568059be131d78dffbc5c7dbbc40b0306a0186303e45000a6ef28d7036883cb8a22c985918a33abac5d39af8a4de5a1e76ffad33ef836fcec9f8a40fc3b607ca39f55feecba79e1d01c5ed528942f04691449642378530c71e309c054cb22ef57877a3ac8e41716b291a06d9a7c52777aa72aca449a1069b21d03cc8ac4bcba92c0bd68b577be58c8a2499226da1b81bf69410c3ddbfcb468b383326905762cec9530eb23399024fc977e3f50dc90d2451cd85aef10f7cd00073375425d7caea5d00e02837219d4309eb08cb5f0e29aa57b38d047ef9c3d09a76c8a2862916e91e12c6babff604fc6fdee883e207282401bbc3c7fcebfa6d33e0c3ba407fad8c12f85c53e9966e7ca9fcf09de9e445893bdf39f3a028325e4699a6ff7a4ca3ad412c8277a368687957c77bb96163f685175749263814f0ec5f0f41bea1cccabbac91bb428a9a5c8f44de08665e5339954253749f92f0b4c84bada8e37099c76f033b14583ec9af169edc8b62412fe2390480efde8b5fcfb7acef29b1330efa6082680e4c08842ad6a505e274165918e05d2ba164a254e1cde9233f9fe156668c6f01214816d852c8b337e6d97b23e8545ee1678068e67003eb779d2cc2b6ec0e495295222a93daf7829db842845ee69ea57554823da64eebc9483bb8e4f2489969c2cb0534d1ce4b50405127e8fb3f80d0ee3f5b54d3bee5bcca0e85d92b5cf424c63707cdd3b90c4d86441bf8340a0b482bc5454e5b7efc845be4186771435de27b54df7d150b73ba11c625f6bc8bc68a23553aba0b1936edd0523928c8edaa9988da1edaacb350d3f68e0feffb251f9e701e5961a82f4070c70a2a465a9616eab67043687d483721420e9f7457a7acf5a200c51ef340b0849175a03d0647421889c06472f108c412c0974526a934e17a7150ee74375afbcd03a32489ca1bdf1994c829edbdd26b3cfa017ab61ec0325e0df58a5adacf5b12d0e916f67fc7f1f4083cdcf439e947310af7e6e3347e0046dc788f8661238d8fd1867a385c6f38c073889302d7269d48ddfdd8a402ce9c5dd8e8c9596fab5ab19ee4e188d1fd171d07d6824e41c2d8039210e9b1f841de846b7458a07cc49f0685ca397d8cea5c4fc38598afcb67e641ac29531cd29d31d21c8e151780988cd6fda8690ec26eb5907c096b3bbbf77f681e96b5e6359b8c6e744c7e265f8949eabad7e2979b92dcf248e5af01450dfe8b970797ddaa48c36f773680a22c361c0e1bac43c2ed491583b29005d13dae0141ea1d7ea35521910553ed5b22680c460163108c6b61b0b1aa1586df5ddd264930b0cdabdd3cf2856977297df6508e6717ee5a67a867facda61d364aada3fd9e130299c453d117c8c40892597497d6457f3d82c177defe2069bc92a2272a9b870daaeba7e43f651ad4babc9f05cac70eaad99947c37114bab9bdf1ee1f124783ea6b980901653fadd2d7ddef7f607e54f7dbb7f62797af50aab0daca4648507dca1a7d7f1ca35d1babcc11111b8de4fa8e16682d2e8930e32cfa96e168f0d192b0abdafbf9a4ea42b792adcbd2aef0405741b2ba46219a623e5934d0b0a4f3f42bb640bf859d7aa1473f213a412e382beddbb4608836b92ada27d5e25f41314adcdd35a9180070d86f2e546cdbcb4952f6da51d1c63825f530f2857a1107d09a56f8a2c82adc27985091f465068d9568237e7ad6b401e93c42eea725359346068beafbaaacf17ed07aa5a88af44532db70b8362884779daa523288bf978a39176d4623fe88dd5613ddc9796baba8eb9ffca56c7ae12b2424f794069e5d6525cc37f5d3eaa74488db9bcdae47b6c070496c709c19b0392a0f532776749db1598d3715a633f84f43b8cff4e258cfaf9ae9355a8edd3e6563bdf095c2fc689e29b00b15716fc5d4527b4aa81763ac60206e9985679ce1be273e2a20b8a073b97aa18e6abed247c504ac5dcf17d7f2a697498ae173c0e7118ef82c816fa7cdb528bf2a08b7888aa1bb93532fabf85614f222e906d9e000e87bad095841ee0e1727bddf72111afa097cf127d4268dba570cd4e104e235805f80518f5ab1616197b30913eb40ac2f4aab23b0f3b5e220cfe048b3f0a4fa64c27848efc4dca824095ed7dc0dd88b5f4d6a5533b6d696c6a576fbccbd192c5839cf36058ba84f22aef858efc065ac8d047e5ea920e38a560c634763f7a65abd146511e638cd238009282a02bec0abcad320eb4b2db422e19ca7f79e5fad3fbf32a918c513dfd2e483cb00e64ea7ad39f1ff2464c42003897060b94801a889cd820d4e4a3f1cfeef091d8ce1297511ad3afeee35722f96ed30cf452adc4c218e4080b470bbc3e6e6e7e4a7a5f429e0424bdea3964a4de2a732b0356fbd782995e52b19606c914af67b00a1b5b7d1d92372d126af1da43844984925b2bca2d3bbc66946a8e025ff5944763a751bfd4b4fe4e704c33336499c255ebeffc54dec77bc4e5855d6bd8740e51f4d9227992881ecac90db72748ef017199a9b189112e8d1431091c1206c18ac35fe20082919e1b222690c807c02e21de1e1ffdfd0cbc01391a8b97bd6f74364fa0381fb8fca6017e1cedc00adbb35648bb9694176248114fe002dda97282f10004cb6e035599b4b474a743a83e02ba99dfc81610b8217f3cdee8029f4d99db411dcd931d69aa93e4850ded5959655d47d631e3537def6d64e879953517775d5cfbe234e03832d7bb0a30f802a0cd0dfc3d6b3214d7b01b54e5e489c63a32c82924918ae249832c7d4c75589e36217dedb5b36e1104ceabed5c47a7bd6594f0e8b2da800dabeb8413c59d02088f355d7b098d622559c7675f2caf87dbeb734e4fae4fc896f05a76e2da7afc6282a07ac8418b814fbf589ff9d175d318793686c9d5dc87133a941983ed79946a31c6d3cdd293088329bc064d82721add45a02cedf4bee95b62cc7e98304ab33b20a14f0f22287352e3982f6d7d26f60483374ef8ad07e410827aa82973e3c4b6d3bab55536beab63923d325c18c63ea8ee5b13d7200f0c8e259a86e3ca9cbd65471b1b2f44b089c6968d5d03c60e5df34e7fdb12cc41459370267a9636e870a0d8a21cb14212c6db4332790da59eb1473d3c9033db8273e2447bd778e0a4d5e51acad435ff4beb52f2eaccae7a0436824cdc1bbdbdd9e9ccf8968d43e9883c811444903d988db92a416c0ebdc65d8ef762817a4a9ef2ec3ceb6f8a8a48b88040a869462219dd530be564390f73eb49068af1e458a86e0349a273c1117f8ae42a4aeb685d08f20bbc8b2bcd4b1cc2d5b3c3ae674b5b65b5f788744fb95ffd6b2f72dfa692ce814601b2fc297cc18c9d81752fbb3f3ed059004b9edca4c43012581c2d393cf647448359744c8db7d9b311f7eaa9508dc6fade68fa4bb86769cd57ce003dad66f28c6993ce35728707fc1ef0d8111a68034c4ed9e429df5e68938d8300529c5183999b54de46511a5f01a6030702945f372a8a85acec17a952769f711525453044258f591f4071b45ba8deedf541f137451b0335f5d25f283a7e2e9c51fcf215a6a8f1f5ddd863b5d406b7f1b9e9c88e5ef3646a99bd38fcd5f92faced1d749c630a2b474e93e5714f97e666117ebf24caa87ddb9e0c184d57d5a414ec4359fac95bf7ed143b45439d75d4e179c5559f87d6578e8c55d42e35bf06227135ff33bdc621905e0d91939dcfe3d92ba48e3a6f67928d56a1d31c6b06f9d93d6a206a8ef9d348317a5341e89e33c147045d4190f5c9d760932b14f1003c552c9ba46b0551a6228a9fa6bede223307dd51d186b47316dc50a1103e45009b0a992510abc9eb5f77a177e1bce2933d07725437ed4de7a09989c8ec9edd3fc844065bc6bede5f30754c700bbc892012e4e0cc8fbc18490f661f7c1e023e54da64f28ea606a27dd973257bcdb82887e12230bcff1d2e03e2b3ee7e6e4ee88eecd8b6b09b5562756129735e6d09b525aae02ff161dee0490b145885936392c021d03bf2c9550b9f010f5cb7ebe00a5c7460ea246d0b97ca86e4ae9ba15122b158818c162e7f0e286c6b16512819253dfaf7ef27a1de493cf2a963692c7b280b557d31c3606dd07947dbb4acfe2d7b6175bdc7d0a22525460167c0d8d30106632b54894780896ff19f4434409551c4469ed948ad53990d331d3cd2a47fecc02d058666ddb153c98657c368bcd6563b8e91dbb4cdcf8de0cab5ec6e8522db6e31328deff02d3df295819fc5d4294efdf98caf6d795868d1ae165738ff314e989cc1406d22183c2ff838c5f6b673f8b24dc90bf79fc6e9562ea628ff508cf7447ff256f27d55c760ff89776eaa269cda85ebcb0ea618e628005913addd34d19a0457e37fa1423c0dbaf944453b603310e410aca12273345902ac009f31244dc7afbd4f83e7f5012126a2cb36503f1d5cd53caf7a61a8142dd6099fdf4f8d54d5cd5b3947a34d8f521958cd7e971c7d3e025d8063c65365e59e79f52368efdc7b3f8b40081277eb703af5d66eb1d1db99b04f2f5e841a047100f472a20ef2c03ced35608c733ba69470c437025ac6aa9b3da1f70d48e31be3541fa39d8e1d5c453e1c39a046148d2c9f5d1bfa8fa436ae7e3cb5ca140028a99192d9552999925446ec0be6f9c7514498d2b54ea143160569fd4cd691874083559c989149506beb4490b2e5cf0dde261676b0bc930e08a4fb859c2cbab0ea8d66c902700d633744a9384393b90065448415526a248f078ad76bad7c9d318c5000d2db128de184ad4198a707142c86eea6ad2b624d18b3f38c07af54468377ba886e2057c8b8cfba8706ee994f9637159a24be22e67173ea66f0d31e778fd0d6878b29a9137289541fe196c89762cdbc98aeeb529177a7a99736762181f49215671c0e6df336c501f09cbada00cd4a188cde1ff159b7c68543c070f3c6d77bd1391341a8484b7668c810e622b71c4a59ab271dc2242c866a7851b3a36b6f690e9079836f9d5f6d083bb59898a7dcea6020d25e0c4b87aa86836c5524c7358d3cb51ca832458c638beb04b56b1a49c73429e447c82101f08242f0c2c3a035c9a42c117503a806c4c0633844d618a3984ca238b4012af950c88f57f0222e976d41caa824237eadab8fb538e2600590e6df8b63fc66c0fa7ec856456a5ea74ceea2e63fd35acbb85e370c497169add43961974be27653955f9eaaa96836d56c23be34ecbbdfee610510d5e41416b9700da7dda5c7bd36ba03896ae1ee6fab500e293c5beb44bc0742e837ef359480adeb9540b52a9709bb01e5fb0e9263291902f9c7db5196eda92aa8d18c6d0755585eece0ff87c86f6b6e91e7dc575f944a2452c2fa0058e3b671ccb568c4a937174adf2b18aa757c8dce59f95698b807f03449ab55bb97888b033cd530db6f264a8c5973e192550567296073e689631ed7eb569e082f0911bdf2a6ffc07c6769f5a3cce5e522c0dbec227c4a2a92bcc827b056ef87a6ff98982b8448bea01438d8f39fb3515490cb1037698cce25ef3c3be1b4713648406114c2d4c4efc75c074c6f5d630db3f345b0bbe636169971d4d8274f9fb43b0cdf42e60953984010657884092f14f421971a5e21e76f8765f9865f7f9ace913375c74a30d49bcdeb9e28d95dadd33cd0ae2892f6667d75be7fd46df8bc31d888b6a9c19ad89cbe65344f98e3c09ea0b6a1ae339dba5b204ad16b25d9cc0d0880fbcd5717550a183cca5606c59d23719c4cbfa2271a8cdadf4cee13b0742e491c2e67d2e85dff131a45a5a5541f70bb5e5ba3983de35a2e01567723b60fe840aa57831c6d5a5d133640cee423c3a6f2dd063086729c3fd7b1ade9dd25ef36bb15c78053b35ee089df21cc879a734be6150b88ecae611b8a03ebcf33d435621acb6e57604367c622f52d23e2fcc6c0e610db4cb6b49075452493c4333bbd5d52d5014f4a67955437d72f924f50c123eee9a88583eccad3c4231a5c6187adb553e09c0e19875d36bfff65abdef2ebe939c4e921b930562316a6342af134f39642120b37c5ed4f7fad0d0f5bc537b498c28e55e5cf87ba88d94b7a0a4ddabec3b27aa999b5a7f8bc6f9d26b51411345e28c0f463ce04d63d6aaf2964309584637b684e6044531d6d94168867366c8bb43e4babef504cd12f7404453f00b4ecf7ac9f50303431faefede51734832ce9359bc51fc6a47f9c9cd8e3e00f38efb700535228f970329216b9ec27bdbd00be962969ffe27fea061d6e2d84e75f6cc1c98d2f5760d28a12b2f9b27a5774900129d8d73d21e12a459cae05728fecab9dd51dd264b6bd561a476adb879cae964bbcd36abf862eefc41c144cf89e51ae203de413f393984ab68b4d5323881b1b450a906d7b7ead12aac8cfa0a36bee15cac275007aaeb221c0f1a5897fad1bf9498034285014697f1f250f2964891b23f8c363c2c351ccf2f1d7b509715fc8e67c6bac7176c8af5066feaef89389980fa94a99186bba428cd6458e5e0b6e34edabdb224a87a6cb9788f8fd7ab7fed13aed13c4c5876b2ee9a46b5efd2b37b2710decc7b1cf77491c40f27bf9c6516cc11ab96d77d502f575609639ac7b20f30d8e9b329d78d1cd3921f49bae46de952b700b866d8159494aca45508626d639c40d9c536197626338c3a47ef8ae87413141913d3eef7c2908385103f613bcb84406c223f1e632d6d9193a7711409b04e6f3d78ccf8f5b51c6ef930c0c87ddcd8e1832d6ce0c1d8decb2d946e5c6a03089e986d4fe5a3346439bb9984a10fa7ee9b34eda86316248683b02ae71ead4b94b52d5e8bfbea7e6ee7e2be003320704a1eeaa6565d505678d45d9083d39082742f0da3f4e3696ba66f459c71763b0c817d1733d331a2255306dd87454bfcb70a1dc69b105c7ae05200076df3d44f9802e5bd2987d16e197a35dac9906c2e62615f83c7e24b1b8958fa2775ac475762166aa10947b766fcfa2eb269cd3c57ebd55891d6dc47d76e5d9ff6765b09d7725177e09d6541028bd2b8541b84f7a8904b97b073bf1a694d0d252dc87002f48de660f9561a2df0ef9a27dcd5b09a2939a5cb848a594eed938dfc070b234b6e6fc2963ca7fa61986bbb313ea6d2d21aac4650f709ae067259c0184c85f704c02755f0deda18f137d3322cf414e82c658c22ead76e8ce292ce26751bdbbd0013253066776e84e06e54d39f30a328b3d5b24b5b35b7df2d384923cb59d20a14b6442cc712349ed70ddb4622d3c2d3a3050baabc73ee4517ce1f4dcffe7a05f9f294b10c3f8eed5d4dd7e2496572265cf9d2d0a2d78de4c910e596174365deeffe10a00e2e0f98980a936c07753b409c5020f9812a48d93e8eb3309d24a3264e081529ea45de8986d93279d1edc99fb94447dd8e7aacce87feb0f7f04b6569caeebb7893b0df75c438aec23bd82e5031d2ed219aebe6eaf301db65794fce9f1b351e2122179866d803b84b1965e421a40a67b178affcee0956105259c3419f063a811ebe83fd33fffcf9dbb02d2b3c3b22f1e4e77dd7ba9ad7a18e877553c6fc256095991675089a53b97841f25de9dd3cd0aa253109a22c528a6c952cc01c76020f5ad987c248ef7057b5db9ce8776273ad6029ff4fd19fa486abe7ca6f6bc1889ab6a9dae4ac1f0ea965f3399857dda53b4bc33b5aafcc20336ade270d1269e9a11c0b5ff3ec653c1fa4d45ef0d00929ad4870c8a181631a630efb8fa4b7d6af83b6ef263f91e68441943d6ff74997a3915fd9f461f337994b3f7e2544cf4f160727143a0595cb99c29a4df3ec5311306ca7b90278e06c070de0cdffc1f3c56e79c5fcbe7fc01e3baf76968990b3dad5b11f0f9ab2a78528603d3b432681462b39fb1b2c3fa62fb8179afcb0f82bb4df6a54a40bd8ed11d6631086e696dfdac7d0a594fd2da5ddc05d406e500ffdc87874575e4e7929ccb1d3881b17214ba66b0ff37835797228630c1e630b776fb4bcd54d084a172bb44a2d5515797eb292401a2945c2317bdf4bae465d09cf78e049cec129b586e9d4e7db084ee4a6e8567535eca2efc881d43d8ad77c2ec553c72704a100310a0e6418f8feaaeaf472a7c7301b8fefae02e0a9f62afd127790377a45adc7e969d293c895a55d10f6922e4b81c1adcf0777c88f46da346072e49b44e400a96fc7f60499af09334a278cb0a3cd4a5c23940dc276a8786845f18b6c08ff802a3cf406311679b595561085966fc1bf05b5a6804d79c9e0f9a8f6af25350954f4a0933be1d621702a290ecb4940bd530f17f6e926839cb2ceea3409a33eec55792978ea8f9860e2ec612fd55e48c08da9a6e0c977fb9161150ec96ae59ef00fc08a9813de5525422e7becd4fd7600945985062c24591e76da4e49ccd9ebb8fd4d2bec73f0032a11833401fa48432cd67292a004fc40998a24ba5bd2fb69b9c1bfa9669b17a6c37b99cd99a271ea7e418964f1246290244dd6541c116e596b1a8a5ef5766f7fbfbcc5a1ccb60432abd61d72d306b34da8d43dd93ec469fc943ce93f5204e3d190b2266ddfaad63cc90dc9bbc1a590fc2f7273db659e4c3d2e7ef3b900b83cb9aceeb62e9ee0f198097c10621a15cdb176196515ba6cd9b29157cfd1007712fffd989a5d8e1ea7e63877dd167ec8c86fc9ac6db86fa94c5e52552387a1eb96711f3d95d8228b3fdc7cac3d96faefc1a84b839bad47833fc196e3f45d6facb9a7246956b09303e28483f31ac8556dd85ecd395684608376bd3631c6edb4fdfd74caec0454a468e2b2699c98937a31b497c63f3caa51d83d3b17a63323318aceaf9d36e33f4b9b5fa36866a6244ad97e97a793714b811da19302c591990132963d9b23d034347f69163140c8a7d11aca09c5170a6877487f6883ea2bb0217794e0eef98d8f1e6a42d4b3a5d20b1bc66bf8b2166f23d57d32ef442de6edd198173b174a8b911f6116ccd851fa059fd913ec3da726bc9ba2bfad33de5f87c08afc181acc5d14a943b361bc9973d5d32943dd7fda83b46423c22c4e106deb5f0ae19bcff5e00f8e2115ed1188588f506493d7e177639822f461774a11002bb30aa538da119d8631646e61e907776fc1af78826ef2246add0eeaf4f895d5f90f5f5415bd40191aa4504449914e55a8b1718013979a6eb0229fa225fdc67cbdd7bc20a22d60d99c7d1d13a7d91dfe983dd45278ec9a5abf1fb2ed848bba58d19a9945975a4a6f3b706a51c8bb098da5cb9663765674759f27e4cd040eeedd902fe7c00dd4aacf1fdeb5d60e460debda586bf531fb69a15c8da001c61cc78896971c602ad321b45853f935941f52244ccc8166d4f877f56a7e0da015ea6a51b6fb50c16b4dd26671be13d5bafe0ff7ce888e45e3c4029d32b49bf1e22e3275af8a9ee95470a54e04fc6ad178dfac66d876ef9b5c8e96d4882029b32cc5b5b648a5390bd07dc07eb1aaeccd05d937cde4b984a18a1692605933c7f78c1b976e333f23bf46153c21486941bb91e1a3c7cf5709c1ae82f265bbbbd4c6e60662210345f204777c893cfc22bb8a285d99d2de038438d3d28532551fd01b9819829a31c6f1b6d91d595abf765684d332ae0cbc1be1450f031fde1b615eb0c993d3cd8a817824940dccc6cb250d23e088e326b48874b56a04a7724adc2729150deccd7b3daec4d928f8e7249def2afa68f3f9e6f7079eccde60024f091426a9ab7b98cf47df24f107389277f6621b41d6554aa5e4d2dfa62215421ac4a8189134e84708d304dd205828d154c5beeb41473c7d10a3060b1651569758b0f09177289464651fe68860037bc7090e7c169554781dd570b6694f679cf65dbbd81780eee19938f67621aa7f69d570b307d84f221837b1edf9ab8f0835ee43032e5cc7c92a324a21f528efc8684640c74bca4b16401a20fd0dd8de774e6021102cecd61d56f86a0f648e8a8f6c7ad4780f91110b9f84ab05ff33589dac1e30f6163b617ca507c111d57e409842ce972d4c84accb3fc933419922216b82ad10cf3f0960d4c60b508645df89ca5c4abc5f91fea67c8aba9a6d00b3e86f983b61c489b1f218fac895d4aaa07a88fc8d45fd16925e25fff2935012ba5e6dea4232a13d92e649c2b35e9dc58d97b85a33e15920c63fbd3e297c906ee6d738a6a7ae446078e31f43aebbbc7e30671a857a238eccc60428c334d402491e63ebf4819d28d1758629e2a8b767a62b5e9436c8448dc3fd88bd88bfbee1a35c1dd24e69d7bfc7601c51921890d96342295c04e75f73988558a632c080f22bcbaee4660e522404ccfd725c0ca82db749f5b675a037771e7f01acdadd5d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
