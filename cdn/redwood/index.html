<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"45794b3f6aa29823654a9b7174b4c91fb29097712f0bb802224fa826947742c4a0d84e1092bdf7a515fcd8f8969390a64a803a6acdb6a3e60acf34b0497aea4c3dc63570447094e203713c66ec5ac782933b0c444fc127522a1957a3b008064c4edd067bbcc39e9a1d8c398df3183fac45a9bc1d9d67ccd661ff046f9d4825799bafbb6c32fe8f5103bdd683bbf1a6b049fd5350a95d4917fbc67b44e7e937ac48a8bebb24d9c39c91ff8866dbe08b6b3a61ae6012a1121a1affc9c2ff02dc2b364b4cfd322fa6bfc606379a1f8cbb67d14f71dada5a108030c95b1f98e6805ca4654e0dd9039b2679a02c78f3e7c23e824daeef20511e3bcdcb27a5f29b67f5af7d558a356fc381be54ddbaaa1f4e6401933725cf134a43d765e94cbe707c68c49ee637c292cc5aebf3cd1fbfc55d2f3f1bdb594a3402c55c394e956ebf69719a92c4b051cfb4fb34db765766caff7b341c53ae62e8429be7b4d2e8a42ba9fff065d3ceec799cc49b06b1ad7edb746216e457b8ee41bf470e3d15c0e21a187fe2f0b9f7e10959e1cc45ff73110f39626810a030822ac278f7a744f7df42d14c91232b7c0a8fd2284040e4c46b9e4e0e8aee43e3d7958a28f4ef91cc78f2137535124e68ffe849e0dd33caf89b6d52c7b0b67e561dcf9818aa187e36ef6ee3b05ca62f8e2b7e703b0052c57d983cd555d4e1071e201be99c663a5cf2e408bbebb4533a264507ab3441ca09c0a71fd4e67e8b7ca1f58275f872892212bf5cb1365db3f1064f04f4cfe343fed243c737011ce8a11c4baa6eaccb741169a9caa9ed0bb8e4117cb725b48e0a0b7d2e317148fdc04c6e6aab3dacbf696ffbe35dd302ad4aa23b277fa81847cd2e86b568a77403e46def23fa60de8de5ba3a92b73cecae819bc8421401b3110919ba13cb717dcf811d815f050b86bca224d5d00b8be08f9d22ad2e6eeb5898785a983246c7e6d2d9162f6dc61a88d275986f7e9f82ab5e55bf96480cfe176915f0d3ea4a7cd44ed4cf915cd5968031b1a1c53d68fb9445f334837f5c8045b8ecf908b776b56efce5908eda8b000dae9306989271a01d5927d6cc3dfee2253f48180ab5cdda3c40d6c81a80bf13ba3a75f2a93d471c56d308bdcce3c4b2681d58f76ce97f2456090eb3f50545af1647fe06d5fc9aed1d816cd11adfb37519e5409209dd5674e63fc3c65d51fcaf288e246aace52f7e99bbb1efac468fe43e421baf8c7d01012a91f0a9dbbc78a4f3b6f4e71e493cfeeaf0dc3b6be2314a4a5514e85de9d82131df5da61b0102a96fd760a12b67e6947da0f5e0aeb632e823454e58aa84c9b206dfa05ac51e32d44842a4e766396b94224c483c34a7b3e9da5527ef2619c80491f030e574048e83073bb7d49e7533a067c0f6cf41ec4019d81d9c4b5961851a31424be39a56dfa6a5186ce1e53f355fda2c183ca830ff6e2c8cf00e46abcd804957d9b69dfca67509648867754fea7bff748c35d0d0a4d05d1addf848fae853aceff1b39555ee61471e8b079c65ad9b7c8c2655c8c6e93acff5981cb77e907f8e67656919692a0c7db080f53c4e9822b15fb64636d3ab4bbe0e7453d6f63f288f79aa28adc30599827ca840917b6152fc1c83fa0a66521c336ba0407651895db28b0973f85445e982a8ac88dac97fd171e96cb1c84145daecd95e99efebc8986772e2cb0e38696f5782dad59b95a255eb84885b1f2d0fcb95172f1e906d6027bb2eaba06a7b569403b336e1d7965fed9389e2fed2a1e37b3bef1d9d05706ec29f0b6305286e4c91905b230d8416de94f4432137a173b0df9e2b445088a1429114ad49b134c2372984251acb6254ee910e2f46db46913f5d55d0a0269172e21dd0a700cb27747087af586f52f3ced31928907bd1eb92dc8324034e7b12cec3d1641fa319e0a427e75d2a4237f46b97138f8c5e47ab75545e8690df9be702b0b7121f2a8cc2adef38b1d02da1ef36060f60859c77c94a4dbd9212d0ec9041e611627b4a88101d627160c2593f7084b3cb7c9513ddefe6b072fff8abdc0a49fb1cce81fea36c926d744afb44f42e0a8807519a6eef964b12ff48658bd40785d1f24be7357202176c1701a9a70f0dc359cbb9b943db67a65db647fb60af40c2b8ab575e4a48997b0104514fd30a4e469974c13b9812b5c90793974dccc09fc6a58dd3c8447e736f0c5c5bf709da619187d6579808c9e6b8e9556d4b41fd260f32399fb8bd591221006f89c2e19fd07af44316be7e827c4ca43ca190933fc06f83f6f94b1731e2ed4e989812de86fbe7a627e8f2f9222c1bef65cb58cd59ae35a0e9a63b64b771ac0e30bc5a5fb05891ac459cfcb7335ade9be2f2100a60c1a5c42524f6fedb7e0cdea392972f07aa2dca7def081d1a2a263f40b030437157af26f4fcf6e67a04436c43c3b9e8b2fadb93193e27267c1dcbaf17c907b6b5c02878256011bd5a517d2cbe45a924f06472c910e9859ec224244eba31118ba736431c06aac8e2b115e3e52d725b807b347319f0c8b85887b663d699512d1d8c8f52d012c1b7fa0bc4a2d9e4f4e39760bd3cebcce34207a8c497287cf00331f36bddef8dc3f7671324f4e5ec8cc07b787d8876d80975f9e2124766c3aded32f53f193464c55d55330af62018c6c9c2274fbc317e56617e9e00033e6b751dce2b42c0a1791578fcddfb8a2a33beef58878f8baaca6bee38d59ea1ce52479153103150b971896ef0c9c3d719d63f47910c80976febdfa3ccc7249a2a1c5c799493b073d9bd9fbd6274cdd31b6677323db6769674792d155b41d59fd34d720e3ffe0fe7b2d6509aea43dd6a785831cd5bd2820346be642f78293f251dd4ee08fb2371d0bd1e92284b9428ebe1f56b69d1d335d553b8f1482626cc12593eb6c5f7b3d4394f6adfe6052aaf200a6ab1ee230664cbfee8ba6a3ed105bb7fda1b8743a355267b3cedf1799ac9f0ec8238060c9d278eef9e3883e52aaeb119f47f03a3d1fbb004fb26ad91e85fc07818c24ae061bc40dc54e8ef114cd82ac4b72c78778916d4527cf90c8722908f54b601c94c661d4047f6b0b569026f93ae814fd1e22fe296346de483d3c6e4e21621a64230fc6719773d0883df7656185e52be8afe6a5d1f6e5c9ef0762b1b1510d329f7e729b2a189d3ff4153692ee3a7cbd9ab99f496d0f47f2336f4b9058d2c2da9d9a4f197a463121b65726b7510cdbbba7830a088e72d1b4c89167d5bc861bd3dfb966bb70416cc966af71f914b62bed6be7a94f30243ebb3dc41a0d5fed664d88c3789dca4f4ce2c9b72172864af6f3348c40b3128053cfdd245a71724034d5a2391e5ef4e537193d8c1b580b55e87fd6c964b7c56159a2052848c9997933711f4fff5eff8d7c482f5a07ffced5d48918eb44d850dc0bd86dd515f156d6f7000715f701a53c5d2c20a7e1f5214e5589426c908dcf9db2d95f3cdfb0d575dd4afe53bf2d2a934db33f66e4910ada79cba1fb3c841c477ae9057e9970caf26dfd28059c6ff427f84acd496f152d0062f7029e81196089d165935857d8dc4736c8184dfa8c5ad2d0ee3b9eea470ea209c52789ecfaecd79f20db0a0d270f6b553bad5b30eab7b6b9a7024edcd60c8c66dcaa060cb81cc57c54a3eaf4fcc5eac8f432b2f88f57de6d4bb5697182d3c37300c884c1c8aa5c26187aa232fa590ac4a761c9771187e8074eaec82bea2294051616ef2ea298c09dfbea419f54e9664e77ad301956ec5be7d23a39e8a70004410c3e0617057f89795cf202516ac94f897b18d6304bc4dccc6cc9c517170ce335d4e646d8154262103c35be90c83bf76d1d11b2f6df31aee7e34983f03bace62ff1475bc0df67ebd9b4a64220a854eedbd607a598966af4b2e0d5f95d4028ba16425c71d66cb995248af3e4dae2573a04dbf66d508e5ae379731d0ca122a172a89a4406047d24ca46cec248d69b250ddd6e02ad05abc9625537fdb32bace30cabcd647c1e0109e1e7058e3e497c3a9f9efede552ff9cb65313fe252449ee2009ec26e0a8e4b2a60e034b2095734219318df560b55a709ccaf9c49cd05c19134881b255c1bae5ea4fa628d7db6cf5bf03f3bebf05014b295540b57c26a44d52718b9587424c16c99970994194c3c32d03650230005bbc951c45b371ff89712b56c15d2cb99aa50fd6a07c954371da53b90d14e35ddb2c9caf395fe92e8fd3e2f4e8c29952af978bd80e233b1c1d034389bc524901ce04f7d07f9e9a5a9e1c9644f35de3cd588346866839aa0a3d576fbf473fca55aee2eeb62a491d52cdb8d3ee9896eae4755f6bb08c7c4ddafc737b928772a7eb6f4b5b154832fd8a31e92e8a2b539f180ce6cefdbe76df94c18bf878b979ce062d86eb054e07c7efc908262f240ce3f34e2068c1c66e1b314ee83512e6b4ca11973e5e37923723b79f6cbb451589d41bdac4680e3727c2bf695470c8697cfb70e5b599f2c37687d1957e5e415a0417388c16000a067b2da215b83add912f5a19e8f150712da8fdc48825789510dfb0ed8d86a03e07af0ab9c7a1aa67a77e0d2c430e1542d2d042996b20e1b5d9d6cb94848626f9c7968c8f345d3d311b3b568539704338b70bdd23e4d83655e904c6525a8b383401dc1168b426e496af6f89c7b771233ed682e38ad11887adbde658579ddfe49b198ec8ebced0762e58ddb224411457db3a663e66b5c0d6d77cb8a28bc1ef58a45ef85eb6378332a9080fcb91a2456c66e97feee06a6eb1ba73ccfa8e8eaacb541dbabdb84f5d9c0fb82d9debd9fcd43df7ea761fcae8435c5d15efc7b99b6ddf69f0611319460aa263ec7b606cd9e4db9efd0e101e711b29a213a2e40d6ccf1e98006cecb36e497a8c064761b65a82740a0c35d129628f318059a77600be8975af4975e2068988cfb217bb575c93203c2121002ff27f06968b14c0cb52eb38bc8cfa02d236d9304ebbab09d3fac329e26671366f480158b6f1248a01caea05ec8c43117c9f6d6152b830ee032b784f8bac025b4c85a46eb31905c53fa953899118579584ee7d794ebc53b7a55c76f489179d434d46ad8ca63d0f2312fde35875194c716dba78dddc430ca392f0e5cdae72b00724417226b30b7757c0d08b36bea676ff5d9eee9a4f1bd5622b7eb2f05fcebfc312195eaf190b23e58ccb3ad8f3043179747004bc618c171959f8a093c73f7ab5a43b47ef71224704abedee9e50e2b2d9eda2c91a485f7c4c56bc000fc6d1b2dc8a4303478bb881c9bbe56dda39caf0eb2355b3db4de61211bd5144cebd468c017a37ffe5f526a05faa13afc56231009c6136ebed68fc370e01082bf25e2e62b9a6c5d0e3188bed1cd3f1762ac8bf37a93a2a703eb135635b9a2a183c645b6be427cc9374108193eec2560e6fc4b183df5b1fe9765204b09bf2c3e3702643d8fae5274b4bea06c6970428c20e3ca898836904a24494fcb59843ea1452436cb306cecbdce13f922380999c49b13b538c399dcd81ce03884f62ad3c8c3401e15c9f308e90a05b3f794d1ddad3d896c037bc411b3d2633b9f5e3632a951c29b863ee90ad8f9c3c3c35a1ecfd15bbb140ca649f68ac422c6878a03e94622a366cfda5fca5391c9b0bacf5ceb8ce87a71f67e150bdc41d327a215e45102f110008fbad2a9a9ed56871be6ab94eb6d7b42259ff05d06fa106aa633302e4b560da1830036cdcbd6d68675c9e53099b96d215bb839de24cdac8ebbbfbc02bd6358899524f337abd560317338ea71fd38b3c9ca08bf8eb94fbb38f97ea6a417867e40ac0f403c496d00b36131e9aea29384e037919352036db739c0d11c614957356a57592ceb572e4e1d69cf12c068add319f05fa34e4ce2ea05789823a1f373d07293d467cb5938ee661434b38c6fe72a32a76c12c9ee468c9253f738896f24f0f59c141730e8c0d007e661e6dd0e9f4aa4a68b6dd535285a35e346685e464542a2a9ee15b0dd339b8de9fd2489278215288706deee8b8c3cf60cc717930602c4f7d652eac882e2b0ea6048ac47e15f7d795a165a9e79880f4b902f0343d78f651d59feed08c65254bdd65409d201698e1ee056221e66f65653f08a0543d1cd106c817b8274175f77620540c71d2d74f2396be39904238a310c1c6f599e785bcbc0e946b1a72654e980025143e6a5246453a523bdd78635949dcbc86871eeac0ce9abcb6cb629acf0e9c7c5c037d8bdbd13982525521afb5c21902b879d0212b38120701cd77b60acfe11f30395d197171fa52b633b4b93eb9cc18de78513b929af0c9d8cb0884f8929cf1869aedc9da68995c037460ffa93df26382cebf5e89d0ef6f12b0e6ea0e40ff09c9814b988d797bdc65a06cd870c064cddc148552498c16ab158225d1bdf9dd7f1ed9663ddafac06c13d837454160aaa9214660e3ac42b319cde30a2d6983813950975bcb370f03879661d018de1cf5bae440ebcf5e79d9093f42ba9f3f5970fc366082625aad67180d8718904bcf2046ff3f44b4eac5e3ce8791a7be5e92653bd8d60f6b916ed3b98b4b2a474ef3a6bed8ad8e83e3206723fd8c4057f3b8ce308d0946a73041fcdaaa8926317c3f4806980f221b3315d9de748926cd205be06246a33a8c8c4b98cfe991c0d61a3d56e0d534e8032ed76e03f1dd3d8e808f19d38e7b485d1d1f20b5d22c25b3f749941e173bca5b7d99eab9f3988930713a70197bf7632394446ec18e980f2c8f473bd48bac9c0a669c17d4dd7f4880203bb249a5b61dcad7811dbf83ccbc75324fb2873d698143d6d62422ca88c2c3eecaa2e45bfa0d03df889a115dbd5061aeabfc6fffbfbddd7a4d0462febb64e282eedf67837dffcf1e98b776f3e9aca4c482d90a819f55751a7684865e83f8696a8cb458bddcd000b62e4f8d7b4c3c64c92bb790d5a52981e0c79d52e092a744ac1acf86176278f058d6019788ef92c0a9af0d9a1763c6a805ea80de4e7188201e07827487a8e6c2a56e7625dd7c51b0c4fabc2e6890051d672040516032bb6628b3adb0fd115ef7869e3bbeef7db1f404c57aaff22f457c0614709b9bf4f61cf7145ace25fcff471cfdf855d9e048a0125f9e947a5bb847179f1c1d826712c6efab9c7f09b5e67c774e6070364f6f2664d41584b9b4503351391e51ac21615abdba84679cb1d40fcd5de6710b838fa573fb4fbbb1612e1aea372379e0367393d165453cea94942f390ac5a6a5f7366681a95f7978467529a8a32cd8e30ad8aa37dd796f5dd2cb35087bf3b29a8d58d2b01f8e227ebaad7c0a759695b6e10b81fb69bad1ad22dbe1cbea2caa71532f6de5caebc5da6b33b50ecf5d06953bb9c05de000ea2b82f825fa556f329df95483d8db9a2820e05802d5530dd79481b9a0d3c7cee25bccc700f808a5fbca473427f61cf586c0a59d4310e421b32556eb181f1dfe5b8767f595074b2e2a1380aaa4702bc834e048b5d21bfdddfe97791c9e4ea5ae45bd8f80365bb54a0a7d50a97a3b4bbc7bd3a3ed062536eae42bc58c581e0fd00fe30c17a3354805475c4941ad4cebbbf135be90f4fed8c3fd45ad7f5a0cf4a387b36c53c1ee50d78371de5830e6bc9c044c6de562e2d07671c26c1ddb59a34a894deaed8cbea2ab2c2859c080186ec932323013d959f15084d47ba8a01aff66d73d54ec60b0a7d97cd74989a13803a5eac96803b262760916e06d9e97fa16a498637f799b33e9442157403c20e155926a8f9e62e3f357250107e1c35b4aec27be257f2e73f024796f4074711e1a655fbcaba3a54458d7ffa600903ed716f927da6374164454cf181625d18ab8a659327940f12cd83b0b8a39acaff036d3c2374990c8e877e79315ce73ac67c0ab7294d067ae8a8bbec409e1d8d9755fc785f22948b35ea25d49b00d470bd2cb2aa04da05d7763cb7c10d33c5e2d57c3fc9215997aba7d01350c6b8c51a48f446eedf8492b5b0fb9b28aaaf181f8486aeba50c9592a8248c2afff61503d9699525c3f640cb5441934282b33318421dc74f3ec01f964c360118b0c90b9a12b6f17dd88f859794a994a67bec59cf6ef4338bf3edcf89a3f0414776f2dd84492e65e1d919dfcbca45b2392f55b527ebd7b0112f1cd284086ecb053c4a156b8f4723a2c8c675cd461751c9af958b49aed6cd56d9d9a20d7587886d92aba5dc8fdaa6d85e805f49a71a32278281999217ce4e4bbc2d7abaa8b3f1479cb2838ba6335430804a0ae7e422e67adcb0d839fc737dc0765ded3ae9926d951104e73db2fdbb091cf9e32d5d8bcbe99e25c49b07cf9345e4cdfe4a043e2e868033cafde231a94e6c20fe5f19c22bef25c4a407f5b96dffc3d9e649b61887b32ca315ef2679e06392714a3f738e4da2673e0f7874532cf2654f822b2978a41e7663575f6244c4e67d1cf568586efb6a19af7c74f4b16aa7896040454fe95c46a592877068139be705d73a6a31eccbd494793d8efb2926404ffa7baf39628ea4c90d5125c71c9f509fc90dba49b650f89250d7bc53f5bc188447fdb3720c0e2e1d346c0d1e2651bc4a05c42e919a328039029bce27a1675c1a9c474f0dbcda8d0e6cf1bf057de6a952b28529af0221b8014f2720ee34ae4214f548f7c15017f8e9577d4f49d5af789a9f9f8cd5f3f875cec32dd281130f4fc77ba6dcba9fc4199e2f9d1729f2880bc54373067f28fc39ac77ffcdf5c205116bc6082c974e87f1c012c696cd71d3c564d24ca284c186f1682ded88c674a4092e8d3524c1b6642af3f5533263dbbf95673ab443298a5d1c7d81355c7418834ad9c5c0e982ce45aa75446728ce6079b1afbf40ebdc3b171aec7a0afedcc49322c3d40b100525842d15a081321c64a13e34295c059fa522cfd721f5dfb555008a3d58e45421fb1775e06103813210cc74304c47e0b4a5a7eea1d75f71301bf18625450dc181029ed47c1115cfab913bd19708dc9a6ca3556805f394990a07811e3a046d47541b1fc80ba97f373f4b0524ef3af310a12a63c2153ac12002f8f75e4e7b1189f4e43e910e2c38ffaf4acaf92e04d4d24fdcdf2bc1a732254301ed4195141788fe8ed8c08f8b631fd184447590dfa2ef4d351823ca17d9f95c6ad40e9cf1da89ada6d2a75ab90cec7ca9b2405edc045c9233c2da8a7c70ee2a26b8e7ce7e8d27613ed2a58cb5188c9a4562267cda5d4b7544530cff356073c6ab58d704a6a13f1dda1fbf536fbcc964101186cc3faa4807a0c8fed4beccedf260eafa96a92b782a2125ffad3435772a028570269bbdb048bcf262c7dd6cef6a046a0210299f274fde4aca15de1c8c2fcbe9468e810579df2ab0ae146a01c1c1a8885029ec347d7b0b81e88822b0b604d129811c63f7329b0c7c21bed2557841f00f79bf757574d07e210658d04ffde6a3c3afc02401ce45a0940486ec1279675c54e8f1f1214daafd55b873bc24e7432dcfe4a7ddef6fd6123d383341db22cf933602a8f920c8857fa94066a2368a824d18e73645a6a787c1ccca59a93f827701af3597bbee368cce0bd3a8679748218c145e20aba78626156aea0aa68a354369a6f60353fd0a1c01462178bb5299b6f191f068c7e6d33032881cb905d2e9d8d352f11a3cde145c7aa9d46cb0ad7e2983752d8716cf1e0d25d3095223790f885d5ba142ebed6cf25db0937c4fbb7f5263a536d845b56a3a5e32ba387140794b32ee5d2f7424edc3b8611acef08d85bd0ff4e659e237e481a4455be15a444bfff5e8e918714c9cdc25a5f6101d1fa63159798b3696221b4f3eb1528cf9502a44ab660dec256bf0a9801331bfdc626d5858e57bc2db992368ea25aad71929dd01aa4302e9223f90deaeb65f5bc64eaf4300471582eaa546a3ade4d7aca3708923737f4374f54ee97f351bcb075d40b1a1ff27e210f09defc052b09bc9e862c8ccb52a67cf23efde1bf1e852c928af37737e47f622dc92f07f5c7dec59a8632eec4df2f83db6e420ed2ae8ccdc0b92dd2096d1f38ac328291732df66de269ba6e4d29d8d87caec5c3e138e08ef3951c61e27fb82cd5d2256bb7cc2383115bac72585fed493b33fb7e0ad43c23a1ba6db3ec2309ebd0277d531b3c322f48a3d8eb94837b18174d189b5f1b4df4c46d01e25c24a4885089b4a4f4df7266ad3ccc5f5fec1aa6c08e823b2b56ad19714af4cbb8964bc57e288f7a9a1699d1c3c70170b50b103780e95e1d0027a3f2a3b114de4155e48a2c99f744f9b605de5aa4fd4e143c7e10759e47d2fd321484b07dfb18917d0981fb646487d0ffde42c91489535f48daba20248c019353562d4dc2513198d5fd1d6729bde0099f84c5619ef60a7be716fe73ded58cf271ff0f6ca71744d183715a6f87af28a74839f4af1cae89afaf5b1064fe498a029f1f451dfe74e8986bc4e51cdb34311c1b2174ceab7489effbfbd3b21503d6618aa8fb43110781368b4722641ffbe9e82734c4e21c9d2eaab7d9d1046b72ef18d46d613e6b6ae776b71439c0335df4b01404d2c6249c621b3c0b893465c5d82aacaabf87044fae2d41b7514c56ce3c4c1307f14e5784e78dbc248c688f91808981f1d57578d07adea49233c769a596b3da5600c90d9d563f5a69fa1377372b35a2f7a37c7a76b08900194844493ba2286c15af09c090d6120aef71e30e4c2130286f7d87feb1725c0c08a11643e4dfbf98d808ccb0d95260fc7e6706f09ed74711fe41482c50cf01adf4bd736ca7f469276c8b8290b967090d3218b9ae2d991791e114af3b558ef858e2ab2d6a28dc6d3a97c9284607cf9a0c76d0912c2c2778175a27d5b9c2b85bf961d3de384c4f573f3a700ab8d77fa716ee3b3881d735e147dead575b095a6506f2171a2d7e77dece9352df4bdab47feecada963a11e05104c78415b5aa6b4bcc8fc13ea5388e1cbc96e9919abf1a8164c6d1cc09fd994a118b2bf80e6e97020c64306a7811cd2c109c380f604595d381c0992f0d9b8d533179078abca29697e84753a0983f881484c37248651bf049987120840b53ecdc0b59926b37040c54650f359904ca6ef619bffe0744c8fe916c9b8718e4a886bcbde068bf0228fcaf6cd48ee97aa0503b233141f90f45ea37e9d1ed78222fd5f19c0dd98d40c5e5d6378a5f0087c2fb3c954aaf7826dc6a24c64317af318452012120589909cc5d0bb0874d08f08c29dfb4cdb15418ba82a54dafa1bcd02b054afd3020b70636a0d10197304cbf95644a96fdb627037ec94921dcd31a902c1c01547876aebdd05b04830e31fea01398dd8c7a8a68fc2cd460b9340628e35c8dad420c3453baa54a77fd59a0cd3a3e202d5fd9c0517543dffa03e9587f33141ffa992a73e881dc89c37d35c205a3c2d8d723976c615c3f390c7251cb163411f0c5439f2c6e752c61260da6fddf62e0f74a711ee7cf474299b05143854503d53ba6da8dbee61f88785b7fc0c5f1e373dcf2cf7ae69a3e6cc7aef2e101ad7288d52858a90d25af9ee29ee8f68b792720560ccea4c5a2ffdd6e10d75e26b6416adf547f3dd23a2f2934a675354417e739349117d57e4be273f58d8f5b5319d7bb61184f722e2010d33c8f4bbf7d19892b38db9c476a2141102e88dc13dced85e0ab7668ff7f9267a051325f25cbb89dbc0e93589ed0a34bfd8d3ec6ba195f43b3de5f765bce6f0dd247ea9d391c15424c1755f5770272b77ad880eba1ad42ca4e82def148b9e03436619639552ce9e208bfc4ce14aef3552510296fe352c95ebc5189bbbf5f16153d4063c2c35a495f60c74556c7d8bd924c63064586be1b1c10c54c31c70e43bae42c5e2c08d22e972207bb542ebe0b78548e9b04576b68e34d4b6526173ea18eaada8012a8918fc43be2bb565b37d06a102afc4e1568ed29bfd67f2abcc283a98b494cb19e169759a5424f4f2750a9b6bf31174e0c4537407390ec7466221fe470d10d53721b08af7ca6d2812e4444a4770cd9dc14bdfc6436c3f92850a62af1de24b50afb1d30e2febb28fb21c5a89c118aec47d891809b54b65cd34e1af5c10e3507083194308b307a2267b8c9a04b0c2528b23b1c5bc9b4022844c6a78c2e48078d4925c88c48548c0e0f3c3f4f20cadef69cf39d6b5ce9fbf358cd8d5441de86098d688537ab73395ceaa350e7451248851029a9fe41ee356621bcbd7706a000b2418c12965ba8d60c1ab42cce7e3d0051b52240860358fc5404104927d8b57a4ac9c0ba08d63a79c9ab1807d4894ae0de31b05574e936dc3b6a8d95fd03f60edc891b663559da06bc01e13a37b21e29a9a5b06cc14a6ffd60b2aaad3c6546cf0fe30f359a2d12e69da4bb264c03e1440516643e9b898edc56f6ffed18aedd868cd98969717144cb494afd105da06643c49ca1aeedfcb3e8ce7c2e092003a009c8c14108f0ad983e54fbe300b61dadef4fe35662c337896b47fdb35639ebdee29f3635f40d0a3157472b1b11214616aa17eb2c191430a2b53b667310906d9b733d5e8495b4c88d6e0a9798b86822c0a578532a7859f279949c7a9238bb0199b49013f7606f8788e08f41c982f838ffb36887fbe092d2e324a410b2e15a47b0b9135b81a98c6356b234552d71b41b5068e3190edef60d59dd1dcb128fc7fb2dabe9a0a4ba40827d0f70af07051586873249b36ed9770ecfbff5be35f464cb62a280628371e3504302b2602c36998be68b764f7efa385f15213ffc49a6054cdc2712b313bff437a6351942a75d6cbd7f8a3395949c440d9fbe90dd48b079d1e1517638fb9b9d1c5bd551c7a26751afb830173f20f9f28832a8483fc1c6ed6fcdf46043162702bccf5e95294ac0474d6b04a14a51154dcf1f0fc8d5de4c6d9d3b593ecdac9ccbe2e80fac22d9f7d2934cb28736768bb211db40eec823285389b4d2ded651bab1296e7b6c69b267fd443e00195da50174bd23c7e06372ccda0dfedb943d14877422dd1f4b12e7967c84724e1a65da339e9a3dd0f88b54d60f5809361711e25505b1e8ea922b6b93b692b5b2858df37343cc67de4b0236e07f82b9aff16ecb7bc033841c6710d2d204cf8ab16344dd1b63228417036f6ddb1c3d73f77776a91e6ee739521587976a3b12eefda3a5e70df8a51692cef7a7c54b523f1d78cd24125ef003b0e34d8d41e030cd28d94c544bd76fbd4b094069a1c1757f507f2871f3661190439025c0b9159c850acb765f72ab23c71b88d1c34799815a7a62e696919aecb71f92f7a6ab488ce8cfcdddeeafa273aef83afa716f408738d8a2303998e43cb7c86c76a1fd7c0419b4184074a4a629b65c9ad30f082a53303f19a0c86b5a4e4a82433da8efb2a53b1cb79b3a4931c69924e81b1c1cb6f39401a3cb3d828eb284a8513fc6dbc46f611dc1454ba1a26fbd803fe973ebb7f4773176d96ed509fae77c8a3f04779f2972c97bf1939b805cddec801f28fc540801b7e7031186c6de59d48c424e345e9feef9cd16ebd076f7f1211583884d1141cac22737eb4f8b03a8e0d7200cd4db9a6b0548011da30e90c6981a1254be7f324213fc98c923b98eb92b70f49daa56b84d9e4612dd8aa97549ced6d3c69877f0155f0fed1700372c0cef53aa7d6ff7459e50845e4b43c73d879a859ab1975bf15ec95e8000d3256a0df4d0518ae61c5a0198b576465c9990b81079bf6d8e1a62b385e1b7cca7e8ceb8b5269f10243761a075916654647cca06f35258c86b6d7586753991f54618e962a09e850af61286b24e9c7924b8f6d06df9c023c67b622a747ef25366efe39348acdf9641745391852182e2f70a28d85a2bbaff38355d82bd2d8e871a05512645ff7cbb72fa73775d1c955480ca24bc5e97252229f40c986cd073473af305d1da85715f0090d86eface7c3524e70469174b1ba8e139e7cca6a9d65d02d67c1a9080f55cd4eaf209bb9d7c13add59ec39081d487f4f8fe78133efbd4a92213c17a373201d43a97d749b90e479bb52341983aaec11d1e74de4ff25fe5e46db7fee4924a2977b05bf6ab85424f1c94abda600c9a09f0b1c2d00bada4d448446c5287772acc7f333955e3f677ff4d2e175f8f747b0df6aa42f5db3eb56d8ff566ae3c6d0eb6101a15d276c3cd58b8988771ad3e7a0f36887298f053c4914837cb8b4b33ea333f140c5f6f50a98781b91c81d7614df1387837353c9b11278efabf1f9be6f65ea0d9fd95b17001880e3e6483f019e51c48dc85d809c7476b157f9f319aca7b4d2ab58991dbd3dbe3355397e76e1580b7c9613d295e2ffb4db94d169c20b1f9c7ae21e494833108f5f6423f791459a08db43a5dcb0cfa3477417346801ae2f0b154e4361f328bcbb2b3aade31bd131999fbdf1b97b499793fc1bcd496093ca9b918c3fdbc268eef49743c724eac7b6f3d15eddd641770dc8fe7d2d6ab748a60b7c2339e72fe167d9d2bcab7f2e1f2ebedf2ada937a56bd82a152c51af9f54541351d80d308a1620647b329f4a9db598c44cc1a8d4f549f421072543317745973ab1d18d1d08eaf59ad749483b8f2fc14e46ba7a29849579e35fa00342c996658a88442db2c1551f285f82bea820ea590ed30bda7230dae87d5473c2ff64c4bfa4d3243da2f1d1855480a80a06524a925035a900788a805697068ac0d63e89ec062d1b40c73c48d0245911295307e8720c89baa922ff52bd1a3fa88b0f643a3ac4fe6cf548705bcafcc875516339d35b489db885bf231b0d04788282607cc1a3536060d3d069082ee1ae44de0e191b4af54f92a68b6e6ca982da609955164420e231d440224a77f685838010e08d9883e7f22a628dcaa2e38d1cdbdd05c92b656497aef89dbd9ef1afb6f979f1932eed8ca5f0a58e8c1fb07446c5cfc6db7c342fbbd39375c05656e93c8f97dc54af94ef710e4f144fb60182309cee726375f24cf27757e06a86d815be8dc3ca5e366fca0a6043366ee6acf8336a279645fd29cc795f0846c82dada3861e1cbe8e24fcfd0b8138b523d8c5e3ccc4f0fa097e0d34fd6e25e8ac39442a4a633be3d82a1c2b244eebe79fbade18865d3e99ff579be402ffd416725511cdc8b75b933ba2e3529573297ae50ae7f7f59577894d094ee4e9f28d985c86b3bc3a34be3c8bf651a294e53254062a9f17218fb4da2415d8e3156272dc3c1afb28e6c60caa815576398fa408a6abd2154f417b9caa80bc649f263a6e39c164377e2b07bd3b02c18704dc1c34eab0ed8c54b146616829af4328d2bd66a5496c3d5ed4de67dfd81dc8b0d55789ff9f9cb6a8866b5d664a0a6fe78184ae65b121e74113b3d1b7b69516f4f7ea3dd39e70c67fcdf7dd5df255f6d3be8d7bc15f6df88462d58f2c796e37cf97270957fad70d5f169c32cefa49be0b09b53641312021b2674d92e91553dbd3aa0f161af8e5c4962300b18af974405067b59020cd4627abaa39ad3b56913d048f63db319325ef00e125fdcedd7329455c438635236cbd01472edce7b4cd0c7f8f754b714852a6eecbcc9af008c31cf2bdaf64969da7a0aa0a378743994643b95a4e20cb4be64bf51cddeb89cbd2ef5ab03822d935a9391ecde2a59455ca480707a2080f54a8e157b42ae2bab21ca2b474b045d663e101bcba8c312d62ba14c6a9ef26114246832393089813ecfe09571697453321132cfdea8a866fa53d572d74e7294df5eb62d1c85b9129ab9f7c12466992626f1236e01ed2ea42e70e689350f758bffae228e1b8838825b5500d3fb35d5834ce4c3a777605c266fc6ca59b9fb4d35c5c7ec273504a020149dfba82a88d3eaf7df08fd2d1826439d57e1a90e63a059ffb0087b592db98be99b81ff48942f006c76e1ae36cdbf484fc49b3e36701ca1cb2b14f88a80330a6d294033c94bd077965167daeecf85c0eeb9e0e514f3ea1ceca3c3b509146e8b44d35c3e774da5252ee00ba97e13c4367f40e0c9f86e4e26b6c5d5389033fbdabfc08d63b20c459589d4b761edce1f7dd1cb2b7e35a572e5f72dbdd546e80be4ab01bca77124e3aec0f57de7f91d43fbe9ea89cc4b8fe6fa4c36b40a0ec48f9ee0675e652ae2d46132fe55474b110da3a6f70db0fa79480746e51b569899573d03c0543d9b5f9b30e7a03ba4300083fca59287709e093f08aa7c1ba2463a000749e60c89f2d296f855132c953685eeff738134272bc78ac53157d0f0e09dc31e146c647b0c1857803e90f0a321c64a3e925bb8d227293edf038f2e84ff1f71de2cf8b4930c7223732e8072b77d23233cf4656bdcc4415b6a5c1d8aaf68e5569027c1691a1dda193ecb6a5b12b25af3bb70f01376f95ed7f640e500f9e578ff2fae0fa6d945d283a7ff06cc26f54f5bc7b8d70dbe91e2b6d9a04a2a3b030a67c604fec637cec496f06c33e439ca2fe9d4f26a0bf6e428402e93c3663bbc759a6a832ad09f0fa4f636be74e296e5dad8dfee0463a24c65380f196badf9b9315c9a7f108b6e8af4dd2dfce1dabc523d3c7b379700b0d61c19426e8338bf6107d5eb8feab85481b5136c4b661b8a49157b940c3e171e93960635ae504ab4f31304209ab586dd1d1099fa3ec5ac615cc36b91871c4aaabc5d829db582b656825e73e2364cf89bc5e6ac2ba20a3c81c649445f4f9f00697f949b5d37fad9c81c3b593bdb759d8948f0258d50c04bfaa0e69da30b00f366f71cb3f395856b4adfd85a2f63afd90cb3f2620c80c26bde409efe8e83453bea36e97ce87eefd8c049a9cabb448c2fb291bfc2ab7c3a12252b3e47d48cd1e5e67d97543fedd2faea1ed8ae76423a807342a9999ee4908960579dfdeacabe6653be3308a687f5f1866f332f0314c10896bfd63da0ca6fa5425dad9de9089ec9818ba1ffd704c4f3621ead77998764d069e54be7842b1506cfde35b79bc2a412a337112631139d8ef7306afbc50b7e474e828849924070c28a4e9ee8a11ce66e01d007e5c89c2c63cdb6dd51bb84881a2a4ff3fca2c81a2979192adb2685e291c3fd4ca7924dbeae31a67742e9e408747e3c5c21ab73850047049c85cf9cddafff235a1c93caa3c96861d2c5741aba9e8a38e9f5e5901204d17e9a0eb74ac39b9ac9ccec5cd3511cdee467e6e30539a6e3fa34f8a60fc147eb722518c6d29e92d1b8c7a99602d91334328c765cc9a2d91661dcc5b67b956490db30561d5c0f9225c787afb03ebc0f529453e54b2cc82008fbf51b53d7dd98af73896ccf570f2b98034374aecaf68e415763ff7971d092bb589b9687faec7a4ba89c677adf7b9ae7f0cc00ca12d64efd820ab0dc5313214debe29eff79bc96ed6e33ebf6038cf7b9da3296859465b7d3615f18dffe52ebf8023b44b49ccef65ab451dc6c6fb9ba0e7da4e8ac9ffa9c0698c991d35583c4f284aacf49b9ee96db58fe171c81b10199086c6378b6d244ef7edbee56a9e78236f82289fbb016f88679fd2f907ca56f252a15c8636c32f130399cad9e20419265d236c2d2612b5b795429d461af9f0b6e56ee5ebfa38e73b88291afec85d45e701968951541e72c8f20a5df0959b72b98fe7885a47926d437fd020170a3c2ac83a0613140b6ea0f416f1cfc1b7f762cad43d5c67cb2373c1517d6423f8887f070e74766b5d526defad8958d0b3f71a6239bd1eb51a6f4884a1d2f3704b0b8f56a974083d689fc67ee95dbf031d9e368f02f96d7b1f182a8708a383a715bd29ccba22918ef233045eb45b09fac10d972c964d280e2b8208de7a5ae5c881c1ca724a5708ccbb9cb080531be9a00c21113a411843418f9a769400196615f7907ca2c1df12b98a5625b2193d654c12d231793f479054fd13824c365a2a66946e6503090ab7da6d912d21018dc836fc8d2198cde3ae2f4e82370f7811cb8a08d0e9fe39ccb3a238899c5c2669736366d749cac42d9562ec0216802ae7ab52788576767ce75e20ec990d5bd64c7591c00a4364f66ab69de039b5bad4180069be270ae72206a6a77f84d9bafd98273a27ba58f82183a7372bb1a95d33aa7ac5a33bed9b824032c9b82a242eb959a47b2c8560cdaba50a2c364ba50d7e8763aab6e4748b4e688257949","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
