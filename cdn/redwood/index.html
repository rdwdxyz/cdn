<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0df89ba4531b6f9760d2b12f677acde7732169142de6fa749089e9c99e670470568ce21f482ef7d3588c6cad1e3b82566fe9ec0d498cb6d04a2536e9b2e3a33599436141cce6a84978d5f82fbcbecf5f52f6134d13c8e7a3decaf69e9d4a3f492ff83303c81a12c941dcfaf34e1715889ba7da2fddbddee41e49ec46dc358a2e21b78cf1cbb9a6c70e37ef431bdf94b17954763f2d89bf5248771283b72b8e54baeb4cab9d32cd4f69bd60f6687650246ecb6660092a3354326e7849937dea55afc82a0547e6ac6c45047c599e140dbd22f94181bded07857c9fc1452fae3d2e074b970dd90bb3bdb98db6f83f6636a7502534e9ba39b08392d277bfe5eb08ac748c7f9c7be9ffc7d2e4c942630995934a6ea3edd220d24a0cb9f5b20f049c7d956cdaceb0f68370ca8f52469c5cd26a94989941510788cbe5a70cc12d649cc2206662777f444b3e4fcce3953e09e491ba715ca085a01d88cdf51e3f48e814a2d3353d6a1039d510bb6433f16639f24f7def5e8a322c621d7a84abd18f05add39c6432fc8f98bcd32c6a236710140ef0e94bdfa609d810c720ff6567e70528e3b71d353814a60b3d77bb291eaa0a1ad234c48b6f81880e6aa6c3a8496d91b8cb264418b4838c9241c66e05d958c237f1ed166e2779bb9c176a9f65157e65a91d67157048bdff3dbca176126edd657de8f7bed02a2ddc0dce5d29f7ad0532da46b62d9bd640a6d370d2567a31a2c6c1a053baa504951aa280e295f00b4e7a443c4102b51c0351111fc07a4b6fbab8d870d26dfd81d0a3a3350b40f1fccf332fcb087b57364d665f2856e8729c797a6111c5ecbc1acd351dc8e4e90f3084cfaaef307c5864eae4cd093ce9fe34df8d90bfd1d44f1c025dd8b35661bf61b99d735f694476a7c908f38e593ca13081c0b3cdc431117bca5087ecb13c71b4982da36a8d1cf5860a2d15ba25ab66db61c7518a96a310cfd6b1d51677ca8b54854783c29bce574ba80fdce044add14571d98652168dbf55e3c5c36282c9a6f4dfcb9a22e77c7be8d01361e82a63a76872404273e0f3768f86c24c90620a5995a203e69f3b00b249e646ed6cf08a42f2c5af43d362ab2333aa89f643fe5b0a61eabe9dca22f65d9a6ca63d99a8293a837f07c8db41ea23d5942f1b118b83df995ba6e8370b2f718edfd2800a624bf8bd86b883f8617a8c8d633ef6673c8285339d4b3139915da99c92cc9ddd54d809a2c00ef919a8c19dabdff4e80cb2ceed6d66f9e1c28bba32c8f1b7e69078fb3bc09720970fe3db48c7b90e9f6da4d38eb9819de7f61bc9ef53f1aa2aa152f65a8589b58f9c17326ce823d2acd840448b6db95310d043715dced7c1541371fcd0c250931a08118ae8afb18143b29fa7582f0ae9ea8b08a093396b43fc2737405d6837a742d25238f66e5be3d513f1c7752f84f237f484a2bffa5868f8be3353b29f74110c946c3e472ecba3ef54dfed125457dd83ffd4738bbc6b1d432b8290c45280f2b8f9a325e3984fc655c7cfe0ee57fa71688cbb0f5084bc615efdd645d83d7b79def3fbf77c135f60fab4bac17268151bfdb2767c9f7660bd48f55f604bcba679bee5a6ec6302d1d6a64cbe065a38bdc61bcc5798bcce4c40068c1a64fa15c2777f00b3572b91c54ed13c772c6cd8db7ff49c7d4b5cfda82dc2888e7eeab61857eff30f7ef149de1577c54a1d7630080a83169202463a774fd2c27a753997881a4e4482ec3e690eafc09da0dca807b2e154830bc73ade0b4f1c722eaea242efe61c61e141eb09f5def500141a92535392ec79b1b88238e2cb04c02a0c93571bf573ade6ac26f776a5528bb468a0a069bac87fb180c6be8f4283fadb5cf759beba39d6de40e171743efe13b06d3b6a76a35416d2159b10360735cacaee34984fceb85f22ce47213534c36cdd17a491cd5b9e676e41fbea85e31c2130dedd13d91518517aa314976a6e4fb8ef094b10125b8f956a0f76bbd8c66db58e982dd8d845038756c09842419c8263160ed06f1b3e9c092dd33a9ad69c9ab6be7907d0c7725ec05c4c625fd4a8d744eaab672224ed8a92b4cebef7a78ac3912db650cb2496d3e54ba499425a6ff208fb67882b1638628273506fdb4bd9378cc63a8e4280bd5e23ffac2a50777ad01509c54aa25eb97e937d268e82275665a32950852ca03aef0456613185e4f5651a31f01c09f9de2562a0469f1cd8a87797273266a2c922db879dafa3c421d51eee1c870f973fba09eb267eed35199340e2703f3aa6a4387b776f1e2abfb190017d1155e005309292db6966c2e956792b900daa94119215108baae9e8ef45a4b67c0facc74042456739748aef4b1a922e384ffe0da02c5da8d37cd03cf32ee5085ef1317bc4881d1dba77dab3ba318d701eee61bff315952494922a8e9c717ba5a1a5c1facfec2feec421f36ca932e110c9d53af2e1af6af80c6c360c0dad0c0bd0abf187aea47c9e7d0e59cafd9184933f50dc9a8008e9dcb4d06269609cdec387bff4dd9c7549df80b70f1ac49bb4cdd25deeafc796a03d0122c65d9f92870e783d044ab0fa617157ee68800b8b395cfe71dda25e6130f9910e83f2b67d3ad7af64dc3492b765aa7dc1c20dc09d0bdfe159a28e494a4f2fde63acbb02fb741224c72ceca09cf3aecd2535949d5509d16eb71ba9d8ad27de48beb03c6cb132bf1422dc335bff7851d975aac5178c5948c81be21c70150fe4b73b50e3f9cda0784b22481beab7f91f6a1b496508ad7e48292889ac8292d60ee6e305c2456545de9b69542974c569f49b20644b4fa3843332fbb08150afbeb92a0c17cdd88d2f2d9d5f4784d6751122c0aee2332d06211622d4cfba015c49bb57dd831bd2b883e9f0d35810264cc2f4168d616157c8a336299672db76b9ac5348f8df4266cf6dcc2d3c635723d9fd437cd7acc3739626f9738b7532e51782951f90405a99f566d3e6cd1cd91724bed2da1246a4382e87f64f6d64705e454aeda6392be012a62a35f97485970a8db0fecd8ae3e1ab7702647facf42bea144b26e0627f70ee5b979004f42d720cff124c26b66ed6f7b08b5298486cfc4616a568e79caf8a628b68562f07730f877332ec90114e419d494ee01e05001b9e96f52586208f36c2dea833fb8f6e543489911e3370a91a09ab1e57c3695159eccb73a83209359c4e96bbb8d9e9f43f09eacf9e4eaee3a3db97673b900b016b59015d3f6f923f8c064a93cdf58cae996e9001578194221a8229f215344c07e8ffdff3db76d3c90d4491c4c957f4fa3d081785ac9fac9206e2b98a865a0102003ffeda29d1bae318bd0f2ab25ff9e6d88b868a05d64aa949aaea79346e84432e0cffa066ecb0aea269d01f8bb55b15b63a40c3df35a558751cda17f724feeec1669faee6c1f447ef06891647a6e53e84f6e3353296aaf847e28a020f5e14d8b31b9a764c664b77c0fcb63245355d0aad2223aa0400d820b5714a9e078d5acacb6b2651dbbd8f29424c6d195ae3445f6fdfd17d74f471e065df00189aafc54d0d7d0d1b91367b6bd14dc1bcb55d3089aae8b53ee178c597e06d07ee99f4d57b28ef1e331d7f204bc82754dad6091b38ffdd77dae9732ee6da6e1a229098d955864b444b6a45ba84cb2028c20823dbba157e128df9ce7b4d17bf92a68b0dcecf6b75060f06cdd208d542a1dc6365af7d75d5cf7bc7e1359a9299e0329acfc0ef064eb975d32cb313004764805b6b7ca905e7b198b7a510d6eb965dad1412107586ccc02424b34f74bc0dfea5a06129ab2143b4a2ef060db57f8d88f4d5ec097d246da12e75214a0c41559a9e33c329deb4921156159b56297187c63428c2d9251288ecdc52a1af01baf693ccfd229932a51938ff06174b68cf4f0b63d93b18d0b8282b765ce96b98c504113048724071f5d221642bb2c29812d9f77b2eef191359c7089e4b5a7d72a5cd204907d7bc2cf2f3546866964e40ac226bfce65b3dc51cdefe5961f931dfe09fcf3c0ab18b025064635a23f09f97ada82f883fb87ac61c83d7a715f8000a889bcad908d9b6d2f0fa2b5039835464bca272ae90a2983a6986f442053d3c386349237f92814fd817beb5aa87f314932b6b05047e4fc183ef16122f868db709908bbb33aca788d93b0e30f4d082b9c2802bafed43716390b6dff3b251e962f2bd01a9a54a80f2790fa0129265879ad4a327fe90fbf55c2523ab222fa5ace9b9a383ed8632bdbd56358cd10b41bd24f5a662301dd9e7e5cf5a28cbce4987bc79e25ad54795f49f999c9b064f2380694a49884399483428259a8d96b33a26e16ad4c9c45f25db8dbc763c72d6aebf1e8a41f7870cfa7c0e6ec40e70c67af9c27c381f021e6d5776974a844cd84f9e452819cfcb982cc5c99d60c47824f8dd6a915d741ebf7827a93e6246d207da8122fa7a06b46c8fab61143e230c85d398a0bda0e9b03e6e998aa47f14237437233688160ef2d03c3c3090c8d12fde8af485937e212115bea8399d71ed7001bc86c57630313431cde00709c9638d171fe263a6ae6e232f2a84865ec6c5ee488b296848fa9dd5c4e50b14d75bd4e33733359373457d18b8e0b6df58f4625cb3a1d893b65910f9767a8df5e7281b8dcb32a560e047421b02e0a47cbdab504ac491b45f835095563c89c3639387b4def5a91178532ae52c992758070778b01f66c8607b5e41aa4846926c96f9b52849fcb88754a09cabf63366cc5b118739cfcc05d42f9be3f320742bc7885f427e5736a32b5f95d9461e31b5708676bfedb1338a437740c6ba38a4b9c5c6461d4d470ec5f58fc6fee8503f0b2feefda8b850a9048823ce98e312bfad6dde055dc6a066d340f6b37c97e8c1c44420c05283227cf75e89888aa3ecd37879f23fd4e03b6055bbcaccf2c5aad2d70d9dd21da34a708d550a8555b9a65991341e911e59ffaf85f1eaffe899bbd027c452c547736bb05936fb916e372794e230b2d668c45e59eb23863d4f2c44bb3dcae365d506015be3ddeae25e233e04ff2c21a78c5130dd98f2a839e6b89eedca132a2383a455abed6bc3052e0a362bee0ed2a96e6409d9356de4c5b95bc23d7f32df88a5ba898b3321bf59821e30e6b0c5d74af48bf5f8bce4ac336f23974a7d549c88141e8c02090856001a8fd8094af088689d703a1326f2421a907b21130f4217f5dc3cb8606295a98f09e23733dc6a0c163fd21931605890e076a13d5ac8ad928080ba036d523ad1a6de4daa0676d13f9702b03b38c2c11f3b7ec5b0f4b7650b2b59b6d21051acfeb57f6deb4846eb5e7eab420deff3b0a0742848644cf52608a373c540419ac39c6d304ecc3c4b346e4a7f057b8ede8d868f4c4907f625a3f38c669cf13d2f79a72d0c73e62a63a53a7d389180efbb36c887be7b3c10f39d7d7136d46600d2234d7e3ef588b1b6e373695ed8cd0814acd2730e605fb9dc9a550f808e95bc5e0a059f9a2eab9450f42b1dcee8f78725107408e938fa8708ef317890404808e214c9281e602354e33b2f077341642636d140d63f34c4ef9a198de834833992e127146d7473930c5216482714642fae72892a94ecb2ef114be091bda5fa0e2474f09cf2c06dc74081b0ea43ca72b85f991d4278b73b88953ae2f3b65ffcead30c70edc7d4626d2699b01da0acac983757b1a50b5a93c18d8d2672cb3ad3a85d688651e058010c43585663861d62055b69270c12c25d315a1d509ff8796d85489d5e789d93222a1316ab622d5e422696385febab7b6f5a30e64ff146530818555a0f94de594a1720ffe3e77dadec237fadc50ce66d1834b37f296b963b616c9f602238a8030a85b3ea56aef1fbca4bce5bf9d026da086303b37db4d2c2ac7236106a5e1d57df775626e8f575813502cd8d30d6ed05c865561500977bf6df0ec632485b0ffdfde799d2f8cfc8d450c3bc1191078b88c28e65a1809a8001a7dfbe2413327dd0682e1a14ca227e3761ba22e8374270dfe405f6556aea4094068cd78d313e66397bf50754af1ab914373739165ca728a9fcd8a39038f5b8b2729ff63d7e422c63dc39a51b95e1a15abe32a7896bba391a474048e89a00fc51790da96ec876bdc3188edae5e434f83bceee276d7acad8bffa7bb1686b236724d62285efa74541aa8b5cfd3df72eb726d54e95eb9320e71aab3d23820c57ff1797d86bffbd88776d3ab55343819d63303a93620d06e0d3de422e8d5a04e75f06874d2c366953a6f8081d73b6b3c138e8307bc117ebbf6d27b692de106611da5838e57190c391cf4db79aa066a00e936224070f723dd765a33c0a0d9f654a2d43389b8a5c9b3748b11fe7d39d1aa8718c659d1592799e127c2a5f4bf26fc0a1f9e3c9032ef6d17728222b2fa33bd68e153d4884c169cf26c00b7599061cba993a7e4420e5b9bd9362bc680d530f1f523ed3aadeaeeec5f97fb53d79d601865a5a7d4e9aadddc0c06e08c2fee141c2ad55ffce6e7551b2315dc3cf955f6bbc957e0d094b9bb5b83e46dcfd43885dd3509acb21220c54d5e46284fbfeb2f522c7e2b4946d071cff4424693dcd8adce55f3d9186f4dfdfd035e9e1f144e3e961a0e013666931823aa54de4c70b814fb9213caa2f4b0328f3779c3e63662cffc5f10ab12d8134819cbc73a89ed46e21cebf624de47a03cd43cc6622830af9757b431cbd9d33f3b5f31b6b6e5ef88d9a33844683df8a3438c4782f97469758aef18d2c1ebcecc8afeac4ba9a08b0efd38021c69a6e6ba192f12a5a38d906cdee9858df0f4734f2e11658650c5fd34baf40cde10d18e4cee4166fe09713fc89576321e49c0c2423a0e5de017c30046f8884973527bb96c770e815bedad40156bd78802e8b3e97431eae0b2c840ff32c8fbb06ea458b18e867475fefeeef146c0d2d751c166872c3fe89160e2bef98537038c7bad4bca0748de209afac045e9e74714a66c6191778d869db71a740d905ca67a0dfb88884e07507c8a25edce8c81546a0fbd889ad58d79cbe5e19ae61c1e3088a8741bf487980bf8494f8a09092f55b89149a27f50e60905ea2eefed26918231520cabf56ea09809680f9edaaca9d82a030431a430da49176c07346e71d5e5e7fcaa61b5fc91bc457c930f572b0a19799d30aa512bdf5d6bf377f1f6706fab2fa56413508cba0f47c36d0c0807deee307353ab7ff64c453ab32a3823d654aebf4da447679d4f33f0beea35250107242f68185a6856460fd2d1adb7c182ec82c8c2c58a9e7462922d91771ff8c54bb201f6cfdaa7033c943edb1d52e65bc0e23bcd6fc35dec2546239bf0f0739c522beb620f0cf29100ffb60e313627fde8f47c6f955cd97f935ec70ed8fbfb0afc8a2e0f6aba19787960fb51125820fa96b040a5c757c3cb8609bad7c2621cc7061ffa892d8426ddc48c98cc4046257e37c165cbeea020262abc794280a743d8def73585005ac983cbe3e59fdd9c45291940782ae38a8727bcfa195a63f7a98478d50994ccac17c5b0a5a386001b0bba4f06304fc248c40ad320746035e48b1e92cb8f2b16470e14b45a5ef6b5393250e62dfeccb7409bcde5aa9e433b432a08e65fa3acc095dff55c1932495097c0812c8056a10e53f373c471b6837b116c95b033d78407e643fb5d4fa55ab15690487dfea4c2bf7acb4ad871261adf02474e134629557dfeb6696395a5335b55e29ff1dad55a4e649eabbb83d647dfd4d7583b95a64e35b9e50ac6afe174a540fd837021e8d38cd6dc17277c59d6e38a4e1a871f904edf3c2cb199459e867ed7224d08eabd3c58ff1fd625676e137f2ed69610fdeb5c56c0f5c262fb1650bb66a27eaf1074d971cb38215d7c6b98deb4cba87311bbec5e6ffb5614509f2c3b643a13fd740bbb29bd1b3c0cf65ce5d7e070e3eae015511e22540f0bc9b02c786822436dae08bad9a5619587cfcffd0f441f276c1601f26c6f04ff8e8ff117e294761767e83621e1a6b04bd9580fbdfd2838812a1def72bfa660f9e20fe250b0b6250a604b4c4ca64b328c923f325d42bea4533119e5c0b62721278bc63d73a5c693c97e4ced1105d883ecd9ccbca84bf743307044296d404463f5176bc4e4f6a25e3ac23733ed4b9cff16ce5d7239f1baa03e8b3da6ae45a2bd126db090ef496e4d46688ef15ae2d27f19f4be350f7d14a117d92e81562275e4384225bfc88f04768a1bbf0d37e58328ab81f09d20bd3825c8151ceae59a3ade40047d0d9009ab32c2c6fd387db5799e98b1b500bc1488fea73fbd1daa1bfe7655d850aeeceb08f59b1532e53726e746dc78fac7ce4d41ce2f0b144296219d4b39e986ec1af2f0ded84f425cf51ec65f88a747f37acfca7cd958c18618968bf84acfa73203ba9b3761741d149dc6beded55628a87e6d50a854358f92f406fc2baae49e40ecae30b015b1dbbc02ebcd65b825f92d7c112b2ecbc29ae2fbaf0e90dc39f30cbd62225bf7fa4248c9088085a03d6aba4eb57179fe7f861b9cb74791ab8bb3f433b8069f4ab76d47cc8a9d890358b187d83c30404edef81202ed575d25169f7a657c890d499631c8362ace493eec118cf31db49570ce197e6067af75e2c74d65d06233d7ec2f22e236843edcd96e49bacbb4bd863a849a6bd339ea42aa3103776f792125820fb6f468912ee52e13896f16c9b2769043d7103830a5dbf536793b1d54068838c54e3c3a6692eec7165140731daeed0e1756ea8ae1ff04bc73babe76813739c521acf920c04d351e420d4a525b5af5fd1ba9fe386479382ca99b2bc81b742ff64040dfecac8a2724419276234222600ed73fd7e0bc4f54cb40fdc8d4137ae460aecc0729b8eb52213d3dd4525efd14e2c3f583b55227155ff063417a54513c93011b0188a4854a029fd3de678affbd4cd3e550b67e9168a9543c245646605e386e44b33b71e9f48325f93c035f635fa8bde8e4f1f70137308a735faa683c35ddf8f1348434f4c9026378eb109292ac439e97008d9e6578eb5f0b6ca0cab63a7cc7220f7acd3c015ca17791ca7c244b830632a26d3211007596e9135f15a28b5b249e33f41cb008333866b6b9219f1c0294adc9098386d1ff0ec946e1671e51f03b237e94d376db870e932ba11adf144f2e74282ccf1aa5a90fae18fb93f05b432ef4d7bed289ef3827f2af976eb94313e362cd2f573c36dfaa6a8f1f22cfcbc68b09b6730ae71e72a7df2d7eb7903bea2c3853e42455ec0940dba5ad8dd8422c367dc41fcca7416edec79fb2ec47a2aec0f24edc07f0e050b527ffa94fa33f33634cd7cbf612c32cb76a88efa95f6db15f52f675836bd1eb4a350f7a378d7a9dcc72e1a17e96a72ba7fa3dfd72fdc09beca46ce216a6dd6a32b2277d58402fb92cd3e99aaf470c1aba83b9e8e4a9f9776d221afbb15ab67adb5e22981fbf4eeb15fbca976def1d57e01b424111663b2f6b24ae9fcc7f8c4e9a41844f1926c2eaeaa4a0ab61ed8e740dd7570c54ecfd97077a9d88e7c58d8951b50df68794328dcf6b363d3b6fb34b19255bb7faed27de01302004560dac3282b99251949da0d0fdae78ebaa6625d337227b9cd16625fbea9541b34263d6ea89587fe036a4425275e89b75e58eea28817e641672acf4568a39cfa555f244ed056d486ca170673fdeca640ad9f493cfcad15088aa1e9520b216c5b9bd90f4717f76d71148498379eccf791771e50a1b067723a7370879c7fd367f76d9924e33f567f6057fa04f38658c29a22646e8c64a59cd8dd7cc454c4189b2aef6f00019e5ba0b7a025220e658d5a54f4163deecd7df268a6d5190ba2a8b8577f48ea43a5e29d6b228d44c4b1d157dde4dfc860e2f0dc7077fff332025567a9a92ed820023e099c30f61c5616b4409bd73df31c3ab993e22ef897c3c1082074908d220e23d36a4e30af2f0001b268531fffc3484b9b74428975528e03a73fc42edcf6bd749a74c0f496fd7a818efbae98191ec720ac8a13021aafca2c40e18d37afc38dfff16b7f0c4f43dc2f3b799e7221fc16e2b3fe8b5bad3cae66a4c5c3206d136c159dc4c292ee43c5d64867d46532bd98454771764640ce1640c2a5d3c5399731bbe3520f7a91071ceb51dbca1cd5f72f23028488c956444ebe1bc9621bed484bd279fbdaa85919c9f94ba98933288dfc8555debe46f6d58ea18c7d1df763ef5cdda12b30004ac07424b4a21e0e0fb950e7cf1731e0d5143e4cae5733bca9eef1ebb83a746319d72f6049936214701993a93c15a48ab27b1d7ba7925ee4290b9a0b0c3c3336ab7b94cca02a11bfff2b9ec5079474a78b8dfbc584a63a83ebcd009443a9213d74e7b4cb3e6af05373b08c74bd8d9e49ff7a3b8adf54a59f140dabec383f6ec020e23d3510a76418326b85fdd47b428aa882fc6e5cccea8044c7739b0a9265c21198eff8e49dd4581b7a7ba3066c12622a82e254788c94b7c71611046f02222935d9409661e0475ccf37bb65814e302600ef27a1af1bb40ed1f0c4ce3a5e63f03dc9e79d1afe7f93835f93be371a405cf24b7e4d11c16dc65c1ff8727d12963d812fb43f2086a714a282c72c8e975ab478d12e5cb8a37ec19d162f5419cb2323fde449326b8269194820d8fd35645df433c21b53a94c0432ed57f44c993f4fb84629dd383071f1077f97589a76aef0863fd4ad46bc28112d0293eb93de28d68c4408529e4954c1cdd175668dbc6970134c1facb37498a677cc482404e1087a33b9626cc86989482b47b1489708aff74301f269cb57e84f8ab8f1ba780cf4fd306b711d91b8e8f67069c1fd2be32044ea433362b14f93e1e2ed291b6b0f69821250192a5150f6146805acf9490177384668408615f854d280fef598c0de88fd3ae849b34784b3777806957f0dcccf88530e839bdba09124c952e2cd393755538cbd57467a80ec307306fb43299aed1eafa831b1dc1285564ea34a3bfce4594751c9d645d579e2d75a85869d71a75d9eb6c6fa5264cf20d0045d843e90d5cc086ef3b5ab843bf786e93ee4555c395934be0d2349f3a1dc4415f9e433cf8356a8ad27187d018a2f408592a3961d9cf65f7afbaf9435a4186abbc01706d2b34788fb1a55e337689f1631efb1297eed33ff8c3d0b801a39eaf06e068967cbd5191392c268d8f80f6c2edc9c19fa951b01fe95fa27f318db2fb8e565f4b62297e41bde9837d565bbfee904e35e4620faa2e7a27c3b812a81ac8f184ef83a266cc16b79b425c39e5d049dec93e6046f8b6566d1e582b7a6b9b3eebaae062a41a201a594aa6f73c01d2121e2a510e8c234f43180ef7d043f3de928b2e7618c34c622e02c3f088cf4210f91718cecf58825f206a5ed32c11e52aa57a2c51bd7e3a8e90205396ad7d34277b5785bcd917c922f94bde92e7c8878a9df6acee6fe179dd05290b2d5b9e79b09fb8083d51b1a5cc9baf96551e43420cc6dd85f7ed320afe93131ff945e5902e5e8aab33857f9e1aa53f4548f8de277057319cbf1e278674c4de3a92822ecd9c2f934194dd888acd2a358edcd5e35282e83accd4e3f820b64cea9e0d3a6efdb85fc5007540c26610abc46bc14a451f759c2751b99ba7d1dbaa60ac6b7e688ebcb54b3bc490a1225d845a3c5323c88982f920179726c4eb2fa90a66422afc492d988f8356618893bfe104615cf4346f630f70ed587096d0a5847db3ebc09fc32eed3e4804219f4e71062385bb0693df3bc7fdaed27496cba9f648d547f8c690e5f411d281c2d139f185f825b101e93604c5b62ed018e15811208732d29c35a3ba88dd315e6a615cd3c12ae51be0a3675e1a41fabfa68b45b3cde9869615c8c2c67d8956738a926ddc31db9ee001f7fb3ffccf6381d06a087e0f9899bcc542625535cf1796bc1b72097bf3a317554058d47538fa780e11bdf19f49690e4d0c94a2e1a7153541179c14c808a880ccd3d8c08cd393fa9614311e1d9acf5eed08a6dcb859cb08c8149b7ee7379fe6f17779d5373e533372df3276beea1f0327474230f2c6b903b60b5aec5059ee35c9813f0be5066050f13f13b759c6379613c3565a7507ec11adbd00230e4d93b8ccfd5384b9b2955630519a470a6d5cdc81a0a576f3da38aec73adec64b9e1bf0f9fc4fcedb0f96ddada7303010def178e15d22dde6b20a2b0cf87bf4f4ceffe7afbc6f3759c6d089423a5dda97ae737684b4f26cb135e35fe208983c45f74aa9188010ac4ffc7fa8e597c8981a5d4ad70cde5fb99965050351ff1ecb2aabe40bbf52fe99e7554a36ddbc42e5d5315fed057fb29f9c77ccf8016af9ab203b28656edd61fed3612d6b4459e9065a030571e0fbfc7124683ab6a420f69c6d2102e88b87fc8d53b2c2ffd6f608fcb306c74a12fc1631ff7058a481e547d3593845c93cd85b887e1500671ab02df56f3541d3961adec8593e34e7d129feb05302d4c58dbb4be4de43747aec814a4b18434deafc4effb747a44b71394ed8ba499f381a7d217fd814fcd1f60f9e6e0ef6a5cee8490904470a0fd92bd3051424f09cc2d451eef17edcac356222f78f7613d5e08e03bc47952d94f8a91c446173c03e5601e887aefaa48e26abc76c341136525f6057cd65c5e97b85b2ae94cb7afd33c767817fc6df645794ab1241c2bce6bb048dea372303fd9b6857cb76a734a59574b1d5a01cb113ad132b202a959a400c0837f3e8f8a6197347e02a9cfd0a984c703af6173cd001880a7a14939883f4391632ded89dd3c692641748944fec3bbfa9c89146202c0c6a42562b27b66c7b85511dfad27f235f4ed3b7c88473665cc7991486630d978dba64e6cf06738d67ebc6f863825cc02949a572987e8d0186990758ff8659b9ff1fdbd25fcba07611203d25636caad52789c28f893ab560c0feb4d4acdd7d961d23dac080b81fa0eedf073fc4f273d052c85cd29025e94cc9fba4285705c3c51acfcd4170cc8d6c42a18308d8627204d4cec657cc386c9daa409303d52308a4cb674f641a00969e7ad3f7bb05e66ee7190e60a6ad42f513293340a53b8e3335aea8d92f6e63683b56681ec4609634248537a12c66d75465b8053c88639edff34c4550dee8693a3449ba8b58837bcaf12321512674b715ca50e69aecb90a301a9568c884c9dd47fab38f779e725bc05cb5547e89a235cf8dff3c32fd488042aa9fa05ce895b23689f2543f44bbee9931ed9e26117705bbfc9ce392ad96147c9321f2baf61e1f6b58b7e65ec4d4c7642fc3a3a871ef356052dbccc11a89c0e3db9e8a63920ac200a57457fe03ea7d3129228b134357c42622a072a61d8be0cc180be01066ffabbf8c6aae1eab25ff0065c1ee3732f52b7969f5f3550b39f267cb8e1b52ed8cd8c2d73c59df98dad02d9bddebce7adedbff878b4110a4b56744a745f23c0f22535df6002be22c8242d4264e4b6e7edad1b608fde5e6bc4517aaf199d55f6c243e3456e33c1b96cd658f01a01ff76460d2123c8a742fe0bd0a03269581364778d55871c0401d8b3ed762c9be4ec65d7070f8aaf1377cd5220892ba75d1e8d15bf036b79fd2c483c052321a34d19edfd7cdb2e26c1d989ce527c9cb00bc6c43dc52753be9a9329b43b84ae3bc37eb833d30d5508c61cac8d89bcb1243e869b4e42f8049491de8da3cd05aaf61b200d38a77072236594e78175aeee84c796ac536b82b4f7de90e86b1a7ac0d24fc357a46406d321e9ffc972489f4f4f470ae49909963637439963df550e40ce9036a379d8a053e35e6972f4b1b31bf2c4b4be3cca7d51a1917e2f30b2bfc0161676c257bb0a4053ec2d78bce609c79b289c14c6db07bc4016c67a1ae269c14db527d3fb2da2ab066eedeeb45c87fc959afcd0a796f1def1a1304e127b36db0e83b23d9a1b39b7b501ca429b6679d8fd9b9c9fdf0448857be02fdbf96d013f118ab2c40dca0bd567cc89697e0a681fdbe28344e93bf9e168b596786afca456a3a0a92058daff3b7137dc256495aa5e9197ddcaa337fd942c2fcb42a793561265533f8d1ab4e3faea97051186f65d0aa8b55688b8c3e828ca40e9da73602e031b516495a5887c4f883c0a222541b86682b9c5f9b5e5d72bc2168f46c2921bbd8179a48603efba6213dfbc6c727fe6edada4519c043db33d9595f46b8ef2e03d4ec7b80515805fb252ed102503ddc7d0948e0b855a985fe3b1a239cf0d48529399706c6dcf7ed36ecd07ed38de86d4afcda98f257c4f1255ae45d8cfeeb554d466c332e706d83c389a5a1daf126d54393ced8f75b95af010c24e62a7af9837ca6ad13a4b85999702161b815a5cb0a23183e7eb4e2a018beec67137f56382a5471b92fa756f0924e0b18e898de29af33f412d97c778b5b19ba27a25fadef55a610be99462d7e95f3a4c834e07f344e8465033d9791746b23ac8b9eb8d99a889c4072c3e263b192c9d7e2a3865a960ab7b90cc97d985745cd6271ce5b52034b410eb193b6a460187543cbe9fc95ec61933a9b52f4fe1675438309d5f655c43ebb97ab984a50551f33110819dd4de2fa7f90fd4648da93fc06ba1f3c6b3180bc1107633d919881f9b88220116b84b28ed5362be18e4e4281e329c61f5e514c1b4e2a595ccfe8aa7e3260cce55149390278e7d946422894f851ca890857c38dea4778e7f7e4721835e1b8e8ecd189a5241738eabc5fad20acae18fa85dbb46423fcd91ffc453cc1ce1a8431b8dd1e9fcec8d3f2cbed73e0096e40e3ecf874520459d52aae7a8b7b868d88e7335f7bd905734b14b7a213ce57d55beb80855175a5d2871810f7189b88118795b83bc437a0632822c7024cfe807e10bd67d669a26a10eb6e4e5ce47add1c6e6a853d146143c392b6e4fe7192ec2bacda459c86a10635e8c18503b90232e55992a378556767644fcba3dbe68278e8cf5e79d4816f7f3d1d6060de422969961591ff14327c0fc516c76756bb0aed82ef2ea90e66dccd7ef26671de10fda455275679c97d41b83af4e2a2923bc7eee46bb30bd5f2820fb5835289a16d9930f6a14343107fe18a3dabb99857066d30378a0dbf322eb0b1a393bcba0c80509afda1b7c7bd2436f0cd44f320a9da29c4240ccdb87871f6b9ef6d6d682fe7ebd20e746368c17d0004fb04ba501036ae25110351f499e94aa6f9d45febd6a48b8130e3ebb9818af08358e7f6fca5646646968fad01acced3e814f597d460ea4d51ad9166b5bcdcb8c0083883d6c9d8bc3a91d0aa1ede36585cf2ff8994f4b91a2407dc68a937883754aed0f0b19021e3b055c4e988fd28497e868ddce61469ec4c9dd0d4e918f2c93eebc0f61e19e4df0dc0a195dc94859dd818391d469a589e1f161648ebea290d60615f9b8c66175584ebc9b13fcd699303a93dbf6f0e241e5391d3df788e3ac322d1e9a29c2ff35ceef6a43462f4febd64c24b8b1679636fc3a4e04dee93b2bdb3e18e34eac611b2de27886078e21f9ed8f3959dd79535c4fcd98f8ac02179bb35ac3812a19d492f14cc2398d40bbb9e0fd962dc6b7c329bcdc49b902367dd6662c9d062b72c29557a4b49bdd3c9ec715fc295eb18f47f251dc0ffca9b40d802e001a2ced8eab15c5581b13d2a1ed25a5e44a0fdee420f80aefb0c04f27ca80c3b2f2009bacb0c8cc27d035549af76cc2220f5c4ddb9e906ad5bb65e494220c03c7e8fb5617060642b7f811fc712c425d7043a506d76654e304dcd596f3dd37b71cb488facb9188d4edffdafbca483b849d62939eacc9c3c58bbf14ee6bc9442a53fc72fef3b25d4aa06c99fe8fc943d89c64e15c26893a599fd45a55dde16d1968d29080d205842c79745a31b1b2f0a4c9e02f4412352f75b6fed6e8b8ea7f09fcecfc45a470735b67289b590ffc27f02c6ae8aaaeb34e914911a07693a5a794295ff775367a57bc8dab4210fa316d630c2e215c23ed2852eb64a033aae4c8291f052f1c0eecbc9cf22406815538fa7dfc1baf969e04c2699cd353ac2cd96b0629e92a2579718739ba6d2be6b3fd8f2a3a14b5ce7a2d1f48ce7f8144f388b1d7ccbb1745a9e4e2ae97b3183c1e5324f36f21521a6dfddcb6ebfe59447b4e6466aca12fb70929c3df131ad4e57491fb4791c6596cf225a7d060572b2ff1b42a98f3f34d3940ddec97b1821dc1085b59e332585c41862da82bbccf6ff302be6bf8704708b124dc637eaa5cca1c535c61363d29a539bc055038d2ee8db1361f71c0c29aef8e62754ea94931349ac688e565339884717880a1b8d29299ceb81f95c9c19e68bf0ac4a33d4e4f3465ece9ff2a4aed6e49f36c237a4d31596bfafb12d1f516769f62a07c788990a1e1fdbdaf1d2bd07d9f714445c9e3418db4c828769b139cf97caf79ea1d7eed0ca8506e63702be78343b30033e7de2c21fdaedd445597eb74d0869cc820d572318566398700ff640e063a332b18f924ff4945346928577fe907291e68235c372603f6c314b0164a6614316b6a1fa83d0b2de75912f7fb51cc4f8a87a0b69908a19863a84e754f2e3f5e29e3688132cc7884be344ff06d08c389fd3103dceebc9f47adf11fcc82b659a0d3f1f65e3bdde0df62c5b4427b985188542952779deb8f48c83a4404775cfd42974d14e0cc8050e28017383343cf36d404c6fa2e116eaa62b69d96caa8eec9dcf4040a2ef70f7ad61c8cb601c9f6bc8612167e92dcad0b248d1887bc7533409cfbde83c5da245708db7ebfd6f4d20d31b704118a97a3fc01e7a391bf02cd10ee537972247cd4d5365d7df3be61815494b47f57d06662f6484835dd4cce529f9f7edd29e7d6309450a862cc4a541ea429937f22f6ed3ef15156f5ea736f552ba6603c104e5a9adb2a20c406160d3865a710d328e869ac627dc720092d562c22e00ad44772f193884ba308b29dba7e5284f3f080879f59c5ed4873a55b84990e598af56f500e778810a0aea820ec7ffecf71af1f4e6fb07012d3f8fafaf4c09b10686da42f6b9a65ed73e75f5938a0ef612770dba56fc916b7e8d67d857ce3b2c7e645c4e48f5f2fd339ee782f6096a80e6603791e1d57d8284b55c4f4c52d36162734f6bcd7a5c50994841c10c17161d14d29cdbf71eb8d641c03aa9beb764ad2633027b442293b22dc4a7bea93a7b4bc18ccb80f625db757b29a63c34894fde959d3265b63d6f15911bcdd08eaa09e4de5ae2d23dd13b9136ae79da6a9df9640f327d96d5dfcb7cc2bf62a7179dfceccde656a7a1e17989fb296cf652347f57aaf18f6ca98f18c35fd280ae0c8ecf946a0154f9ed1375c2abfa1544f6e277e0796a9180fabd7c59062d375c1f614ecb7da426986f67834e06ba2a70ff2b37f956e1a29881e942953e82cba8160560fcc2bdb5287809d3fde97d100897c09ede71dacba0c9718c1cd61c478782cefb1d27a9d5f27e0942334163c0395e13f980c86d8bc43304e54b73a8ac25702b16cd1b83d016299fc0ff8349d6054cf7677fc6310ad7fc80443f4a2e4173f1f13dcf539d9ad3497529cd1e88ab8a0b99cac9deae127a9f0b74392cc32567b90a7b8cf5daaf6617ca5685aa64dcd2c76e300d738fc6ef2dc2e3c293580033b442183b77330dcddd448597e930e201781154a421f2eb170f7800d155fdcb58c21d5392b79bcd82eac631a2a4b89d2198bc877642a181640978051a2cba2ec5ff37ad606365d6ea46199edcf8d663c64abf8ab1809908a1f907715b99b8e1632f8662f214df6a49737445f8fe191e5129715c63b18a0d838c4814a5c9c92218e3fa601221e3e61cf6b0f28730646b738949832713430546d163726b63b815f1041af7ca59d7909c3eb90e3fb311322d8dcede3110afa4d9e4f1aa482e77d5a1004c19824d66a3b9c396ec640b9e9a1332f5d1aec60ab4269370f78dbed4c7f30941a8ebac9fe3c3fd409b3bd35bd8dfa3b819d371ae66ea04e1fb9d5be73a4b6c6d0a71b72a97b92353754fc176cdc771dc5cb8a186ff4aebb202db28b4b93c2b767b9bf4269fa3f9e127287414595beec7627c9f1e2fcfcb7790a04f06b836ade3104851b744beba4e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
