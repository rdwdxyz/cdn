<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9b6717c3b77b89a006d1eb956ab0a420a0ee286715c7eae8161d2c34d6d66a841cd77074df271a8311baecf55cb27d11e4b07953eee27b11afcd5b7527fa99491f0569270d6eec00205809f8587ba582c3a3ede194b25af748ceb0696c89a15e52334905591d197da357fe4af1fef1df6405676490edba7c9bafe7031d597675ea0f7a779cbc6c9ffac8e41fbebb2937a1596ed2332524160aaa3729cee981162a8dae03094f37312f10e7cea725b7f47f9ce0dbcbfa107fc99fa9a7362327dd66337683456605aa412f49963e5ac5c9c938b5afda9d1494f8105da771714affe7aae729db20d59807e4b374037908946b1e74b3a6b4f9152d17f6a4e688096c037f6ba6a88043b04d0d36cdb648553e3f04200f4d2eaa72dc7df405192403cae11ba6385ca13cf1dfb76401ecfc6de918f4d5c1cf5933f2f55a23ae3bb5baacbe5f84e02d6e688b557ade7eefbcd125954a4d64b565fdb6e9064c302753f0eaff6484e741411f675f3407b9aae485e88c147f5fa95d041480c87e84a5d0357ad1b1a4f00cff626c14a314e62d267ec23455ec9120400b5330c834f52241fd652ee50c42d0959c43c45c53fd35a4a0bab6150d7b5e7f0fdc0e826c1b61adc0f9f2898aa9e84d15f0b98a5448c36371f50a1d4f904563a9d10b42d2198dbde85a079c0acb25c1f3b8d064091c3b0a01ac5681da5c346b5664c0f0ce7bef1e2406b65aa48fb1eecbbd0b66eafa06e9cc6e44ae10b7417c0c7ca62240547333ed1c6d845ba7998e2fd4ade881288539d5b8ffaedb5acca1d8beff2845d84f0fb61fae68d36f310d5ab0571803a7be389bd1185f3443cec5599b31900cbbc45118b3c397421c98e094f536fe466f74b3179dd14e8f57a7a3174cbaef5170cda10b999883947bea1e06f9c976e83862dc5facdd7ef17e74bcf1a7e8165868ad385bb564f42c6523e76c3fd4452bc62b9c890a1bd913a7920f78d748b003dee1f634c2bdcfb8d61c980ba08701d257958ef2d0c96f3e34baa03798d72d959c46c0d0d9fab493ec392b59744d13242bc780218d083e8e0b173308dc4b11b04a8fd50f1208995142dbce7bd6d66063475c3ddfd48ec3417e5fd8b04f87c0bc818420016397f3202a5e7203e84b60724a66913216ea6b945228b2e2ee7bd82f0376aba235a138e19c637a6e776606c675391551d62e34e3d96b3e6e8336d1bd4803da0259af3c37b36aa603ff0ccb6c726c1f7ea0e4af8733016d59513cf1ab6ea4bc64151050f31738e9aec64620f516d6dc20b3645e6d55d6b33a60873bb94a6add9864295014c7b430414dd8890c5387cd2601b30c08e43c612860e2f99edde0054a639d2545b2ef9d2ba310ad3f7dc2834cc1a02b615c65debff569cf91ebaf2a753edaef4bf5643ae81d8c546fe33291fe53916f6278f472e4a83c4e511821254369b16c92d7e77c0aa1c6a754cfac305e4455c2f35d433302e91f0277104df6a6a0cc0d0376f286c02724364fdc695e28857f3d9262e410f196f54b96dfdf60e459f662fd8a73eab62be2b557a632fe10886413215e32a2cb0d5e9ff39784e31bb1b9797942609bd31fc41a352924ddc000676a54ea42a33e431dee6158de73365022f0053121f95d10493788275b29a58cdec6f8d2f9b5b4db118e2e8ab7d15b09b0e241974f883b1dba1fecaf40d455184c826dc23ef1ecc78f6310b480b35608834ba1943a54dbddddd9ae2c648b6999792ea246c79fb82d731652ecaa34a5da84d8fcc13fd4035c5fc6a135df194d52b99ac8f35b3755f00c6e3669842f4bf92fe47a5b9c7b2bbca698b029e82cf7597b362a662caf1ab454c8cdd3c7ff5b57f30673a6c6acd5feaeb26587d981edfb1211c36b9e05caf3a92ec7d6f72d81f31ffba05e00a60ab5720538dc04d2d981261090fc2b71fabc10f4465dd2560f41adc5d856ac1129e631790e6394279cc58e218246a6c39834062adcd42997140c67321025c0c291be11b26f757f43d3c28ea4047df5d35f656054e3e8af3110f72edea474f6b2ffc17d49f2be512680c548c2cae4479a7dfef1a5d71bef8fee387ddf14cd681830600f6286610efdbb734fbe219d9f4a805d1f67b3001665901e698d2a9f7fc06c9518c80adb2143e823f4005105d85d595750245f3b2658c268a2324e9058c165c1bfa62d70bc4d4cd6632bd7b944efeea6e38328429d0976757212d88389edfeae1d8e70cab3d93a631342bf897de89dec478c3e3ee9b1acc1102c9d09cb6e86bb37f1c9ece39ee37c0dc1731a00ae8cd820396dc619f6fdcd1b5ba90b7e2a753d888130af0c7bbcc4ee51d007408d5025e5a71752b65c354116e6f3349753f925b5a1830e1ad4f2ebc4feac26ff80059eeefcc1e630aa03c30c6d617227c891ae1d950bc320de881fc9ec0248c8c83f46cec6251411fa521095e658b1aa71a81f89deb788c4a16ef462d44f7370c67ad5ad9ed44ed57b9a328257fcd5332548cd92a20153c6086482ab8bc1f17a5d1be3e5246e98ab2848215e1ca4988d5fe2d094f371b014214bfad15126ad6d87f2926d33cf373f1baa473f61a660e60649ea70dfe8862b07dcd4055ff89b866fe59859d9a82203bee3b0893b39d29dfb82512916078f414fd6895d8120cc715264c5e0ad4ad17bbad61e1a5c90e4514f171b01bc722c9ce6ad9ad5aa6b79d572971e14fdb2468564315c3cdc5f594bb940cb02a84c2626868bc254e88750f1ff639b0460516806fd49bb30f7866b2472595df989ff9900e9ccdf4f01bfea4b7595ad045d3c200a3435b9256d9c7156495a260d3b91629f072f4b71c764b2c802e4bcce775d4440deb109636dd55750a721055939f41bf5d1a09d2c020fa9f0e6678af10f710e854f69f22253832bb01a907cabc390861f91473b5fb31434b23ccccb24f24c7065bc3767ecbf4717c5fb524eb8d1f98b9b8f86a6114a08dec71d3ce14d67749bdfc2fc4177bb0344012143a72374c228be06f8c3b056a99727d3ac725a1a08c14d3fde0d773109dda0b80ed06d26fce6a6315833d31583d7bf7cbc828c2e776a38f8ff972e46fc4a7bcf6511376d2496283aeec47db97a1af19d23e12b53d68cc55b58537fc6903dde29f05d42cdb3ff4b97d74fac0c6ec715a14fe508abd6835af5c8074e37bd54d6b02974bdb197b64d65682cf933aa33ee8976731c820eb817b555fc67c358382038c43e6c102b4c67067bfa46293f30484c13b95fb4627f0dd02981629d3c49439015271f0a892f5e19218262c54904bbd91fe51bf6065fb6ec98f90068ead39bbb3e390490a05e93a55411729b21e8f2f5245778a48bfe071445e03c8b414453493a5ccf9ed6f65f1e0752cb0c69d4e353ba4cd2e17061cb8760d1a934ea3acc0c79df1865dd3e019c46a867a62c5744ca2cabc973e8a17f4701ad0080f6f55848ec232df3f9c6e1900d82b5d88fef38d00aa745f8c3282a3ccf3ff8d6826ced998771691d77532838a82e962c4e0d8c03b1f2d69530d3206c1acc3f2d97349c07e525a74990b7055e5cb6403b8f67fa6f101db82c2a1513e77c2bf9300163d010bd30c8a50fed097ff73a3204c947e045ddef26deeef5c00d486dcb03b019b877a7cee454de63d4534c13c7bc389d123f800baea6f981de38e758e702a7da926a26bb1efe6084f473587dccfa6f9ccdbf9ed28a73a2ccbccc456fc0fdc1ef4fcde48b96fdb102bc63ab537200325be70218494ab7b15a1317f850e018a5ad716bf3aa9c381f3fc16676e7168dd0106882c8d9e6c9dedafd6a649a9341771b7cb3499a7cf1878355afb5fa26cc0359cd417ce8d1c94543db067131df45d663a763d0f54451826af2589ae387b9ac29ac19664d5abb420f102cb15651b8715cbca6d6dd0ed011b83b72068a3089e5e10bb217bda3551ee1618de8e06f4341bd296bffedf0374a4cee13e3771f6237deb2254a00694dc7c83b85ee930bad54734b6d538fdbb5001de08b2001ffccaa6938f46b1900406400b98a5819179f39f5738ee03bcad6e34a8b9ec4cfae7172984f63e4ae4aeacd991530625b7b1c115118c54b83f17705f6af23c4ca1828993daf9a5521c7b4e443dfb60fe319045f744b047d5c3ab261f18ba74e96074261fe1378b3e6c1e32a811d76d59cbdf479930138f9f52a7ac43148f0dd96d0831e1e63d4444db9fade33f0d99e23b34234dad97acb6dd2288f239dc3302d8f910b98af0724cda2268385523066e1b589469134be1547e1697c43d5bc9870fdb1c7f7557d3b4a57bb6aec41f043c9f13b25e4e19bc4ca232760496f963e9766c75350c0b93504ff5a3b3531035033940a592b2320de5a054faba4556f71b464071ec4d4ee21810ef5f7eb45da724673f8ca259617ac60bfc7733f5b438e99acaf2d507a8afb6e3ff3e2eb854cf80a568d711638e7954ef580a7479f967b217741aaf48a21160b4ed97dd270af6c1434429052241572a0cbd9efab8fe6d59557110bce7a8c7cd37e7fb5c2b75e420445a5fcc2aea00fafb8ababa91b5c852863fabc0fd5ba135987d0c12aa9595a222267cfba701712f6679e93d73d011d72f2539b5725f7da352f825abd9fe8757ba055908e25529d0c943ab9988d879684277775d4ffd6f768f78d09bdd0a34e64c9d7d1694a460aefe0b8c7f8344ec283890b4383d9de43514894e64a64dcec35f5dbea8588e19c2704de7365093b7c3f19f6097528daa68589d10fa1724c67a9cabdd041073fccbd2637513af8e15e0ae403e1ce4e5c7062b7e970ed660bbb220fdf7297a47bef9521f52cdab6bf28f94a43a932c33897fe661ae133c01eed5d828bbff6d5454e35bf4a031390ee8329648b00e280ec082338043eba1ea61f5762ccedd281c5c79e72ca8130f637e2aba724b480d733f2dba699b4274228298b587a3350be9af30e73415163e4361c27eaef7bbc8f2c0091e19e6d4b2d5d72b468caf04e3c3e873a781ff6aa232a2ad10a60ee4e1216aeb29168217173d141f81908206261f22d3846284b103b646eba7a308f84d62dfa5a9a4f10bf4aa7318ecf4ccda7b28d924f23705b68eab6fe9c746e5f68127bb27e54e2d1b8544303d24ce48851029a34f54a31f37a718884f306bfbf8e639fd0786fa9b136edb613366e297ca4181eed8cc3d468cb64daddcedc6027acaaccb7aaace84b69f85a8398b05a8aa0307d04551744d27513d5763528b2b8121c60ac01859dee9a42eb6557af21344648aa76cb61690b0dd88af31498abf76f99d5b8af4bcaa2bbf3ac79a67d035d6be73bc983a18ebffcef92f894a9163975657f8e1836769d24034d03dd4e4ccbb63c738408dda9cbf20c05357e4da64a680c07a2446b03020ab099992a9a9aee9b0f734720086ceba79ba8db3cfb9e1e48303dce22aa67d1dabf9873005d29214922174fc598a43d7dada53fef48f75c980f53f592dd8607dfc18a8a2c4cac46e3196e7c3ec20ef9f299ed3e60ad4f6b2c98c59fccc5ac25335fd38f3f86976a940d696da68dbbe4dceddf37b891ee0b763eb3b0740b0ce1dab14056aa0861962cfe23e8d5b579108335bb7bad7b6e3b3498e71b14db7130b7c465d4bea0d5772d6d0b5a445af29555527ed142051942b7639b7ccb57376d739ea4dd5a2d763a00172d8a3b781d18bcc086bd43008b4fffb13a59e30a2ec6c72d23748aff37f560e35ec4b32b2d120ff6b8bbf610e5751c89576b911ffdec6bcea3a0ce354940d2a35968ffda9b10b564ece6cc869953ccf06c8c467a72a2dbe5254d297c879621430693e326b5209e38ad840cf924501e36484fdd804449c36e58ab4a71dc28a65969af91210dd98632057b10a7b8e57d5d2027ed9c2fe5fb54492fab128052bed37ace5a481948127fcbf5f775275c676327bf4c8e50d8fa8676eff0dbe8eb17a8704656d558b73240b4a8aa76b5711e75679d41f32818a61c3b03a4258c8a725fadb22995e151c91c133082ff15d5be8001f9f4094223535cb8bdf176257bc4e75e38d69005a490dba07f20b30c84b44a10c5bc1e6e6899b11ed8c9a3d9abd12c0a89ace68509a2ae38a8c925f2d1d223599376482efe8df58d5421142e8c7b07d0f9a6e1269be5c96067d023802abf21caf605ad40eb7acb9333b305e1818db29e756e79f7c7853b16ec8766e7a8475ae6f5e4daa1e6ece3217362fe713176f74945007d6836cfd7e415f1ba8ae50c874a8a0a61dea7f30bf05bc253b28e7cb12ddc835b9e9e6653d943d351ee7ac56caed2b99ebfdbf3c927d86b266ba9d88cdba2292d217630d56d7e86fafcdc0e0f45b6bf859d3bee155c5f1b72071dab413172d62124c2e749bef76db24fd23eaae848f9dc2048c2168387519c88592d99ce4b7eecc1a0a03d2b521a4260e08c6d6f5988c301e894a5f1d6cf82de671896552962ac3672f0c132a55c6a777bf036e44e9e2c6149cc4b6d18b78f08e609c66975e71bf83364bf9cc706a5ca1b151bdb6964e8710e80f40df03c1d9e8e9fbaa1ea826b06e1d52694efae91bfde4948df1dbf2b2ee5f41def7f936b9298da14787e20980ce6ab8791de47de02fe72b76f62b397c000a33450787f33b04fff91b6d6e13bf26c787680307b437e1e6e3254dc07415e318bf7cff1b21c50e30bf66c3c3ed065ecaaf628bee22ea264dac2ee24b867aee765c11fbbc1301a9274a2275a8c888580630e7fdd3a86f5af0aa00fae727fdffd4b5011fb3f82552b13545f50d10303c786883adf459f90ca39b458f73b358e8bebf76ad98bf7ea7a513c6a422a43b49dc4aec10427b504cb06cbc3490374cb518d9bf8dde9e3e1a3cb88aa3b515c950797989d196fdca90937bd985045b1b3d07bd340dcd90e0d681ea5a8506cbc2379f408e299783af4d91707dd555829c57046e5ef21dd69e77a8a5035c11f94f9d0f833ef8ccf7dac90e01aed5ed85b3e9fd9d36a3300d0dc5f27209c24113e0c97d40b3712bc83cdc71b757746475bb4d89a3035620fe004d3a21094dbf08fad3f11c9f840c978cfd9245cbcefcfd492a5f29485ad0669ab6b1e7528443d211743cf64bd8f40b5f7bfe29622413caf91e1bd3619328e06a90cbed89a4f13d8c84bdd15f831cdebb1d4fb1bbad45555537e747f7a5fa2aaf6fe332b38e5d501bb1bbf547aa3974e486f7155abc59c5971bdf60acb86883454654ebcb882e151bbdcd07fb522e55762e22978ef327f96697f4bf11eb16c0bafe60656463d6abef47eefdef2ba1f94071a70143732f7f304269da7b66519ec6060fed719746c66b485249deafaf816ac6f616ddfaeac1905a6c4a45a29ac2b096a12c3e5ea2b82ad3eaa25a23eff669186872da93f6669e96df07bed23bef9ac9d451335b8955339624d36b61966abd5a7fe01d6d2a83c543ebbbb61d42f6fc56495dd6e108ed0487e79a951f6b6c215532aa8f0c0f20383a3e6b8478f992081a24124db083b1a534a81122278fd97f547ae69d89b26fe784890720e744e7374d056f3faa7c6e87eaf4b837e4ca88ee0b399b17c42203d4f32ac79b53b535bfaf836083a70f19211f9853c1a51a6ee3d6e22467676139f8fc3011cbf4ed554b59680ba09ed2ea2a0d7f067a6a4fe34f549b0c16ffdcaacfed920194054d26bcbd32b4fcc24f892b13423ee2f9e8e2535c73cc9b7e6da4a6048ad38970973a11ef23bc3009771b9171659a09cebd13621a563c3c0f5c21d32b676194ecbd1c6f0793f0a8532de2ff7686ee539bdfc1a03a3afede54f76e069f9d2fe0ade306872d67866fa08b2ce3e75177aec97808069fb63e79020b16168db4674d22748517cf4465dff9e2da0f9124d9466d0bde6b3bab778d8c9d6bece90f99b07fec157851ef608efa8e9fbece97040d44921cba90897ab5a0d25401288d592a54d2e974ee40b44985dea41bf00e5ad3b092d95c8e77d71916dccc61ad78010651accad4b231f7e1cd5b4f88125a7a0cef6d18a44569f7e111f6eca7e51432aa18c5365393c8a1d4a75d986d1b6d95d17e93d6f087efbb62b909468672150159c78b08e06d485916c5dbe6a890dbd38134087cdb21d1b585f2a72f4f4d0790343f21ebfb48923ed0c1d2892c51f28beeeaa25d142f3572a25043f4374c50ae9fa66afe605affd30f0c9b54ab05c6a287eb0f76eaf4e5c1b924cdcc872289ed01ca9f6641f03f58aa747d92aaee6944d39f00f68894e96bfbdd48a7f266e4ebb7a9ba48d98feeae87370481920966fdb4d13dd157349186a3d8c835db336d90275163151fb7d54918467453f510b2efe3d8f3415cd40cf7d4476738f520d714670d4b2512ea038d940955fb8fa7c138831897f9c06675c888f11fc5f77d64f3e06f8db241ce980aa40533fe7fc9f4c2b5883cb67ff02b8c58e32b45ea99d5e41b278eb4d2894a163ebae898b4dba8d5640b9d7a8a406bee59b54343a874d4f883bc98a48d1e6a755681833fd148505c97f5c17d70e1870a55f40541a3bc60db05447c7e659387eebea6c6c42779170c6d22cf983ada56169ab4d2304c50f2c7f3c06bd2da4c98f40f69fae55c19c5a242efe6cefad9dd9c40b12e76f9596c23bda48efb32e2765e442b99a70a155a1e6e8636f8b4f7dc3836bdea848ecb5f0c628eaae1c55242f165d619e7d111ea3e2b0b4b63b2cd7673dbaa767c38743508e9638f8f021d2e419acf7b587c65863bb770ffc31a112b3485aee135f880186fa086212666aff98203d2a51d613501f19ea2b84bff29f18505e89b27090818c98fc1c6f044da081519d33e9b041cc47a4e775d6d92aec41eba0047ae7e568523d618aefab2fac01f97c3a514a4eb2dbd4cafc0f4967015f2b526c7225c216abbce8c7aee0c3f50418001c15b5e45d6819973e686bd0ced183bbab7ef400465130d9d3b588fdaa759b2e23752ff6c4d9127c5dce15ad037e85efb76a59d7131b20b7ffa4f6e1432ef69481eec0060fc6d28845563574de532814d53aa1a81887e34216339cf695a529ae018ac8ed6f703e8c4c7d5bbc560c3facc8c473949d1106de61ae5734bef91967f6fa8e30bd12475b13ea8761502a60f7d45348b647dd0f5b6fcf2a02c807574cec624b69bad5d6a36abcbf437ec36bb5e4eb6d034990b409262358b82a62d877a488c53cf64a6ffb954904adaee300441694b70c240f8c7f75bdd10c9aa7a3ddd547eb8c030189f50d2fb35c5f257f0205a451072b2ee08068c5a3ce07acd25f2c9a567ba8ee0d9a8a4033abbb11b1ba0e8c44b28c2f99c85d406d075c892dc428983c8b1864cf3ef86f714cca9c17eeca085b954a601d65027e2644b32272cad3900d2374fe5ca987c532b39591ec8f6db2c39a9c4c90640bae736831e94d66f897643a7b025708b697da3f10429b1b76bb1e884abb355db787a1a26433dad0dea90d6731bf7360c7239b659a247ad16122c689933387da0c67cc296ce6512fc532645d2f0158d1f593590d9419459195b5e49a5702b83ce0807696f01527cc7596b86da894875404b85b9bfb72b3dfb03872391b95d41a352a81df759f3ab00b45f8b7d91cc5e6d1a09cb6a6dee7e062476324827528c9bef5797fd221bfb543188011041e6281cb44939fc74d48c19faea4fffcfa0213e884f712bd4cd3cd46cb874e4fdee863b94d0bf137bc31b8dac1b19f0652ce267a747be02600c29447fdbad714fdcf3660da058908f389b84bffc100e8b4229ed63429298e3ba66a3c9a0a21f99d8ea289ae41ee8b0f2b73df623b18229cb5c5243b52a50d61af431c24df48e88187950e6b0d60236ee72bafcf179070c3a56e8995edd089079633cefb3184f02507756dde0ecdb5daf03e05bd1b4bd5a46fee2f0e400c68797233d06b9f3538fc22d3671fa204d58c2a5263f78a8c8fea2d5aa2dda5df9a5106a3cb3d29d4095eb4b699b34af9d6d4b7d98763775848d1240c977404d8c9a5ceab119142b7ad75e177ab7168d40631a86ff550dacf979984fdeb3b7ef98de8c385f67b171771aa9e4ef89460f77eaff3c78240e91bf89433bec57cbbc4ebd112fe6aed9b98f963533b02fef89a967de345681089fa411c1ccc25e5a8293ea0837278bcfeff0c41716c94c7d50daedd0740b01884b168ec892c4844647d030cbc9fc5c8ea3bec4c45375d97756545d10a517dd536a130cba3d35eb00eda350dad5f488b5d674bd16a73925ee3ec6a5849c84c091d618b83681d2e87216d2deaa6b263e91b8033d296c85b3603c9b6bd056db96b8de2788a5ce48f7fcc7181b56c64299e1468c5c6b5c44cfa3842689ba170518fa39576103d36eef39ddb50bde0e83eaa415db63847a91cbe02c61a6b82c32d7bce8b30f17a1814e456f9122e8ded865e5615e6353b14a554b75007e12283c63d64264d63a3c86b45aa0097e85475efcc41576606ed6886ab71d32256ca908ef69b3e59021fde6692199de49fd31026c1b92e466c86bde6d70975e64dac93f956ed7f0f869ab05648a4d12144ebbe69e9f2dc0f028a6b8498450f77698eb617915745df4cacc143d3f53c4953873804ad4fe8f7e6ab9ef4f5dc06625ee9f455215a4a4cc002b395104e49d9274466198f49182870ceb3e685c607f4c447373229f996b8d3d074b74e35290b1e826268e878a09b593be176e5e25b3c809cdbf056b80dcf30f5312e46e4e4635e130df4a80725dc27d23aaf6e021f92796b8cd762e49604c668870e340d3540bf3adb0f5520a69d993baec63935cf7b8732f2de9f7944a20af8600d2ae97d2548d738771904bc93031b62cce2ae26d7e4e06b23930e46c0ecca72c7bb8cdd8b1fdee601bed58391f363f73e49d388df6ae05b18b17e26aa3e95ee0c4d2d25a7c06ec34451b9731674ed14ae1ad2b33d6ee977403937600dcd4663513e9fcdfa15d39520a97e47b54c46fd2655cdc8fd92f46f7f0c08bf7499b0e8eb861b3795690bea719c3986cb5b3d7fd1a3f9a473a206e31f20c751afde06f1d87b5b57ed98845a7830a3f56b1ea6cb6acef244570aae13b591fb5be9d8e3409a0e7f9f9da73f13ce3301b9faa12c2a2fccb0085870313324a5469795c49d4b4045e2e6a1c883834dfae46a6e7d3696199af13b4c5e6ed223cbbfd349caa8c16d62f29c2aec0ef1d91f6c71cf4828273b8e67d08456b8e32816e680a18c6d81646dbdc1787ae9ae7f71816197c9444bc265accaecaa16ced20ac1e9c2f4ee7acc5363dea7d73da8bd8aec271734962fce276d3a08025102b72b329e4a1f0eec2ce29a494a9c020ae5bda97969dcb40456a7feb945380b13008bf385859ae5491353d718b829adc3fd5509de42a06eef1ff53af1379c13eda6fb04625a0f738b3df84578727834cbf9efe627c82fbeab183073935e319db55eb4dc56faddecbf38712ce9b820984ca87633fd2b37e39c42e5b883da7b6ad95b22111977c71e0d00ba21e1480608881f24abaa3b2e836db891d21a4b867fc36cac75677fc5d69d0598db20056be6a61faf15174f6132683f28da4fd21322d3dda0b78fe41960f83fbdb6b9b7d95e8caf6b7b966cd6c4b233e804ea1198de54de26fd96a9f2196e553fa5b85a9daf1a028ab01fa30238f1f715c043266029e2bb543973576b0d7b841938b61672128e83c37818fa32f6f62dd009e5a31f191ea173bcd2c15b44c65b99f94ebf8372e4d1cd82e2acb162b1a9b9ade69516469e7db687df1ff2e9e77ab82e4f4adf4763f824c1f83f497d5d8aaaf7c38794c2ad9d2b68353ab17127d2a5bd8fb260e58e7d1c6098eea0ea593e802734a780b9cd71eb8b3a61c89e67d069fa68aaf4009cda6392c13993f43f0558587574fe6876866a358490ec4f88e6f4277a2eb276bd8bcb80878b1d64640a29e01d7366fee77e5ca7307d13e0568b1fa845ac2dc5e6312d53f84550535fcd411557ed3f4da79f7c800eebdd2e7a80f129ac331de9a53196e2268daa972feb230a056417744186148d8dbaa2a36f72d1b0806183c62cb1010dfb8c2264f4556bebd0140d494ac421250a5c772d1e334078fde170d08e887e11ddb7983eab74fe09fa5af9d9227fec18a357794c2f38ae2dfc2bebbad85af09eb332776a4bb68b1ca27a114412c2b7b19dbdf7f16d2ea909b372766ecbd0385cd6db44b29a52f44e7781b88473d494d7a74d46248c2eb44f5e8e4e0a0446be5d06e19d561b2c4b03d50b31621dd081fe2154753adb85d5868c71c9fec602701c5856d52018c29e13ff0f3c85650c729823ca2af15832c50f06877d695d19328ecff23d4f6bd1972063a542b4fa57b794c43eb2424fa0798211ee62c2373ce4b33b1336e8e70544c04041feb5616d9030eacd3feddfec56d4a4e7530f73cfb7e738501ea437ac9c8bc1ce7c184efcd072b678cf482a23ac8890372f307cbc9b031a9eb7b5f6f94237e4fdaa633468dd7864749e0b581982efe785e259e6e684ace47b16db5c182cc6d12c1c5c8e444bea092d1a3754174aaefba6ad10b93849b7b33386b401cb4e3b26e3a243168efe6168af441f7daa75930f6f982470858a8e8e486e384628339883ab076824bf2a376a92e345468966169d69695cef4571f038bca58826a838726ced9103a23f5911522efb401236e28f4ca79c73032eea5f18429066e297dd7d6ec35fa0f6f5898475be13aafc9ca00027d7f55ec8725e3da9571520f181cdb0745c59a03e84af124d69fc99771ec252d937839d227a515e228b422ebbc3230a74345b635eb7845ee4a1afc2d89863e0b9f0f9740bf44fe3722625b3ad1cc38fbafcbb9edddeb3d70d531d78432c1039f4b840d8bc8854e3c837e7a96ff45d4f6d48cc5292f7e02f5bf20721f067f29177acb355fe566eea9182ca1b0a4c6f01e6dcc99e664be0a4c135782246833ffdecb54129634ed1e513d43402467fe4a4d530bbd08a8dbb61ab728f5d8074c9e044710db99b40f5a0838688a60b4cb061b7b470d35422e06a09613d2df53f382fd09122d7b864e8432946f7f0660b6ecbbd411f4be876b4a95f90a6baad702b51fc3d99075a0c864072fdf00bcd5b30e14d6a6dd9c448daf6a309af44da2a2c6fc2fa5069b56ef9b249a02eb78cbf56fbf4a6aea8e71b12ad1f00a69eb3749c0a4e5ecb727242240ea91b19eb53fb700cdb86f3996296fd2ad37da886ed7538f343c2c2eb2324fb2f93586ca6691d14fa791251733f0c3bb344fe94b4ed566c0ede5165913e01b95d01cddf925d0fa389ac429ee8d3e3dbee15d5b7718f812dc8873a05d6147a54b2ffc48907fef6af7f8492e776d2f996ab0bb60b0c7658d18cdfdea52e964b4ee20898ee040abc2b862b8cbae3095e29509b41e70b0456eb7b8c95b25e2873ab41e289606e891d306ee0fc0121cb20accb55f05ba8bcc59a67d611b04053fa3ddba7403703a509f88fc531d0fe61690a4617ae2e3da65f614032b036cc0e733c8aedbef24667fa3ee38f5686b40301c02e3f0cee25344dc08c975e3ec71788fcf6d10de2dbbff4c81be42b2a20c59bb092d028e73ed0b1294fc3a88e2d924a22fcce112fa6e3d809055f923a5cb48c2dee798ad17b33080a049593a57de0d566df918390c889f4930ed169881395f1cfa3689fd740b34b9b0f7a4d0490615e5bdba845062aaefe0609bdf39a43fedd7a46ed65a9cfc0b39f80bd4fb6166c3cd9973d4fb238418316476ff576734a28143339c8ce76a74669fe79bf2f45211e433e29f0f4b3eb36a828e0fb85acb070cd6205541ef10e81d7c8caebbe313db5345093dd0ab9753e5ae6a87101c33fc06b44a05320b76f34bc5e7c430aebabc97ae5faca0d75c32fd16a7a111c2a27256c32ff7a28db8b65396ef486333f1f6a732c4d17a441e5ac140f6749abc8567adb9f87e9964776245f1267895b0a6d45b7c2ea45d04cab981c59f2eeceb4a424af135125e27951d336928b404fc1c7e5d5bed4e14c1e5cc62065988cb4aa3555c4018ab4fdac11e065da85eec6e81f812ff7a612713561f8afb920d2bb173a8e388da6e97cd8c5c71044f338c634e3fbd00da14e1501c9efc0d91cb795af86df3983069e046d526cf36449549bff500ec4f6c1bc37ffce41b79a337e6484690506b81d18b68db4478ef7a4f21295675cbeacb7047c909e172fee8ffd6ab6d832a6c8713312632dd78633ae9fb04e1684bb8d990078d9cfe2d84896a8fb0479170f09ead9be86bc0924d5363ae15a7ff1a70fef0e886a58eb9e4a3c97a398eafd14334c3af6b6a5aad59d68ec55e1c8cbb62f8f8882851ab11e1738e517e5d898d72debef9727e7fc79f9cb56f52343a1a6fa63df37dbe62776ac9446edd48d03a8ce24212f08e63374ce19fbd9645623bc4be95d58769ef5f887dfa60cc452ca2e8bf6f56396603416df2fe47d9de89430066788aebf10bbcddb1082c287ecff125d8a78fe338e6eb38898056841682c1d196d7c4b47137e86c4a936c6c2e09a93a148096a193db2c8e3bb0779c0c4812e59bd0a32b89b85992b8dffc717e72795df1ed6cc718c83f6b9024510aaba11272fc8150d3c8fced395bf870984d335f198abbe7554f676bf4d675674dcbfd3073944300edde22c07f0a2b83d7691e4dc40ea34d767af63025b3d5caea89ec850311eba0a7dd5711535498cec91c59f661381d8db983ed6f986d9734ab2c015376f12f601c368d84bb1c7ae6c7afad28f1b55e8b397c6fcb9487b2fe7932474d443f1b3cf035adb7dd7f869f3799fb6965c544a60c5495fdf5b15697f3fe3dfef0cba0acc83832e0d3b9f451562eb49c1375349dae7a5155226dc8b05ac444b457d132dd4c24d5b4f27c7d88cd6f0fdfc0cef320fa4e2eb88ffe75f159e4ceaf6b2d9ae6375b051675ffb89e09acc89e23f22d86e0cf9928beea1daf6a67d4ac19a2e53531e5fdb79c932aa4358eec69e38309f7c2cc7639b9c9d3cc345cc2f4375d5517ad06876658de915ee16ee17524ece7f00538c11e0fa3bee1a64b131cf1d2d2d4ebd3d096d609803181b8e695ee6e6aced53f012267b0ebb3073be66df5b9dfd0232c00c6a47b34472f61e568509922c4ddf1408885424a774e066102cc859c2cd1384d140593c84e483fc2b824bd36fde96a17b9a128dac8419d221c8b4fb7a4a5a6694f62066ee52c9a62d5e5468fb5e38d86bfc900c7d602c37f18a7ce17c677bc4ab5762679710dddc7139837633d0f1fbd303fa9c8730346bdb01007cd1d47ff7d152fe1981660c285b7a64ad8e943cd14c742ef4cb1bd334c88af79364dc97f2bbd245814b3bb176836d3ef2f7950032b00d1c390ac51805383842c863401088df9dd4097b590662dac1dfd4e1beb2b1a5ae284c90c620bea25d88195a2924b7b76db07da4b9f3ee42e07a10767dc877da035a6a8e9154c20b8c5eed9be5e15dfcf668d14e007e196adc1b512221c976cd79a086712b1d94919e5ffc1c369b4db73edf62e7bc0250c525acb3ba3b547814f6116361b70a3054c6286cd8f16155089817367f2df702ec8dfa50912d3a2c4bc3b1351f878b6376b95cc0dfad3f7b1d97e3486a561421a085882c6afea90396b284955c047141711768d3819de7bd1dbab022e5d00439a840d2d710f75cd5611b5ec0bf4007e018aa6c4bc89f5ea153ff3de2d222aa43addbbf2acac1be771cb6c94f34b437e9662de3ba6d6ef2075d62f52e9643e70db3f0e54e1f497d529373578bf0b8db1e6e8dc158735a18b228ac3a34d26ca358b1f85dae3647584eae046ef23a88f5d747ed2ac6556864d960211a8d2d0d0b6ed3520f55514b0342c00c383e04e07e900927713305cd7f80054fa4927c22af45b153c1d7c660f62854e523e50e3a6c73eef6d3c3a5829ee0c8e8114f314e9749d7dffad7ce46dc76d64d18577b48131f978b6f147096fb174323b69d79a2cb7098b7e107f3b05690d8c261b9572d20448aacbb09bdb8439ba479c27e01e2f3c7ef5c33f493cc6cd4642315612269d02bc88c20b3beaaeab4e2b56934fff53ecf7e1d653ca32a9551d66adaa147264a8761ffdbcb026817d12db0fc3f20e051355f4fd22586ec0333fc8446d6885bb780022707c1c7b5735ea91339eaeefb954f5f04e955404170e3ed2aafe8cfad789b762542bea72a5af61076994c76fd48f71640882f52ccc8d4ba61818c5848a72af818ab8b90591b98f677357783162b9414b9e151ed1f678fdeb0e10b117e574ae86425b2a4b88a7637e704f8b97054fcdd803d86666e1728eaaed82c081387f2fd22e8d97fa12c73be37267d942ed9089c38269c12d75aabea7bdaffabfaec8ca6c8e8c74410598a92731477ad64fdc0a046b489895ca69eb0df0374518eb1c59a8a6bc273ed1fac6148452e7e89e1b7e48a67d2a118d7e78e4d5aa6dfffb3c283e8316c7c7b6474d62867ddf55a7d468ca1b4acc7068223eb7781888900936d4bd7b999337219fd70ec19f9238ba1c65e6cd067348cbeda2d0cd313cc077203af93eb0645d80c46e6b9ebf24d41dc2bfc1b59610c5dfba24993c66cb4d69443fba06f895f81f4f2151d764ca4ae855b76c9eac1444938a9fb856edc1c0a27fec4833768b73def96a288f7758ab142cf11a82311b9d09b0474141baa85862f4b0a819898cc2e14994d0d791520750c57fbc2e64a440b948a65e75a33fea6b07d9ec84c99a1c04c127aad824533468af6a3f6c3bde0caba85820715b24ef76ef57c123bac165a1f2b60fc743d6ae5ed5d62c64630d9a87210ab5f0c99ebdf829b7233d7090cc8713dc8e5ecd410cfb64d5f9a4f1138ba3d47b51a3180bbf36ebc7f070103ee247cb9341579998c071562952b1035cc5a1c41ec8d7fd51c7ab3bcaf9ed13d4ebfae17bc59eef1d7220654078ef412faa2ee72484cf66277bac751bc6c1450b7031cf6b652e17333a27c843f51a7ae270b344ff6eac502e0619b927cb702f379ab13fb14f311e48a741d3ccefbf452b2643d53723a6be882c4bba48e1858ce10ca5a3f9904d8fb9b37a88fd60a6d46a894919af6d1f20dae4f6c26e3d172c81213b6d33189d325bfd49528e2e559f2b4c305c4f54e1eb0f4ce85dec30d64cbbe792f9f7ce48de2de0385dc5336fc802eb712b7dd9b680e0d714fb3c3dcb9c302131e4424260f7c55e3b36437cfa2c1ccc51a722fd6036ce00b2897fe6fc2350d974989ff583d90019b10ac2f6278e8364a8c85e31644a40e4929e10871c4295d597fc2a6592e20776f1eaf625d9bf7f62e24d952994a47d83246395953f4f489b6d65381abccd616064925c575aed62d4286bb9c4f843aba113cd09bb6faf3d9d1743878ab9de44bfaf805220fb1c0c340a276fd8e4c93f29610a7296fe4b9ebc855f40536abcc9c87faa7be6dd901cf0b82f04f8996614b2b9f6cbc4bad403ca27057001ee4ae243e63729e819517a9a7f545aff4a7f8146a95681c5c555d01912ca45995cbb254ddbb1800a32fc198468cd057d5883c18e5415e793a04a14cbea730b711e34bccfec8b51d5dfff91a453fb334c5e95472f8734036a1abb003fe852d8162f9c9b28ae0bdd2d9c7ded071a8f8bbb934a4758f3bdcb0cda08ae87b4a63c943f49b60e386fa469f17b1f975fb86696423fced19d91049d06033bdcbcf7877945fef9ee1cae66c28271bd393cbb929cb66de3554a5e84d6d0c3d25c5ada9fb1422ac621b0ec42a576140b9bd81d5da014b4e360cc71b2ad0ad942a87fa2ad8e1bf7ee77f4d758c44e15dc963edfe22c771e59ad46fde25c70579f3f3adf3b08753f52d66420c5111893658d2f0c11b05dbd623e071850ff4e6224c85e588104e99f0ba670aa788bef4824bdf8c6cb6dce365ff79e096dd2d1dd61ad9ecdf1e5cc7843261f56eb8726b40d1bb418723f8b2b3fc54dc26ea7307e133cf77935b347a4e9de7dfadc87086cf093907a4344bd5faaaadff481c737817e84f3fc04862225640215f63153292edcff86968896b7a78af96dc418faebaec4208428d376f9d88005e646019da2455ca2951f8cc8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
