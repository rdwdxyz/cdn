<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7570ac0a37f1b2e1ee6d401ae2ed69cff49600fbae16be61bc4e900ceacef04488973db52f54f53f5e506b0faf44cdfaf0b906007aa4fbf6ec539244ce9f1b6272f997dfaa7b2038a05aeab1bf31d2a369d5328f7123eea501bb5d674455dbd872ed5f5268d4580ba27bc675d92cb0477d0d699ca9f38ff88a6f50a60dd9c8a2c4d6da798ef1e3a10166ad6ece778a99d65299a1ff0e5cbba00766d3e3b932e19d2d9b26b78f390c1661bb6bcfce3941e2321f28fb5327221d76a17f970664ffc94daa6d1a6c661e284aa89b22fc55f01160afc8f72fb0ed8db3410dedf410d4bacbdfbec10245c0c75812249736dc2167651314bc8b96e74a2a11847a0fa14f0e3c3bc97b7ce325c97ce7bac37f8057fca965eaa545dd6ec84849b3ffa11ac1b44ccb33de42f6a79513a36794a0bd2a05d58d428dd25bc774c14af94983cc285fe6fcc200b6021b3cec3b2949824a8e23e161fc4564e5fcdd3bcc3029e8eb7a327186c25e494d98846aa8a539d42dd2f5298761a4b4631b4373a98f4f3e4a8c5c592ca4a9e1ee79f17bda9e4b15245ff0975c18109ae807826b9333a74a76248ba0270df2563df500a68ba4535193a09c2e736709ed4e0fc2bc0b9c54b5cb08f5c31f3010bb7abaf51388c06f9e7134a8cea96f63e46d833e898774758eef02069aefc0669ea5381ae3ff35e677f2b206bd71e80a7be8e3d21a76a3b162b90f108d1ab2403e910dbd5378fe4f08d528df220e25737e8139da50b6daed9ed313aa30d3fddcbd4a0289b621a3f5d9c7b6d8947e1b65fe2a0721ff14d0f9d0cc3ebf4930c6e4667d3cb1adde4ffbb4809a40539343579a42148db9ef967e03262641c9a531ffeef13baae82754e07616bddde25c48c9d1f5370f8eaf9df568be34f05e9b7cd50f9ebd54ad5ca09015767eee23f2d5f2a232ac503f33fc0ee90e385a7060c757c9d7c975e393adc6344558834956356a1798463455436e95276bfc06c4e532b270c0d2a9758514e07dca224b7d90fc63425418e9419b8fb36d597bdefdd7b0c0c18c90b594f3436f2d22949a983bc323fd579c7098a9cfb24632a0b664ed29d76883b82bbd851ce520f5d50a97bb9fd05d81a71dd97a90b12c45c5699a6a7809ef7318e53f7de2add3272f32c392b7957ec23a0d9de1f6148f1ab80f8b4025d87aa9ad1e4aa991dfa3a49d9ac6302113039ab8cb30314e999cd5ed5b2f1b75296f123ecc035275fa68d73649ce3424a2c0d3d650f4d8ccac4f07502013619dafcd0f9e6e7d1c5f8632ead8cf19ffb7bfcbf87af2eb8606758a32175fdf9060b7d02a384310552b61fecdffafc9cb69f86e34bd7286a433812fab4bbf37a27813cc8a6adebe12a43f82edab36552b47d763b8938bbb0713803ae889fdd044aa20d567e4ae7582434d70106675b8bf03fa371e005f6bda3df99328077b3fb1fd25c0f6606ff50f0d8f514cebebbf89223e2b04638f5260491010abb06bc58c6549d7aa3e2c54e11b720bca1c29641afd8a805e7aaadff8a74300aaf7902972df92750763a8407878231bcf91925615d3ffa8ceea089364fa8bf64cb436a21ad6a0b894fb6ce2213d06f0e9f6b7d5089a3ff4469bfe8de80802aa9a7520e606abb4b49fa8034353b22c40d250c39b53c46c6cb7d88c4ffc939d8dee3ade4d5704078b139684cdefcff8f51fd4d37ee6af2b2cc61d2dc510a8a6453efb00a05367a8baa6c7fb84c428d66fa01e21c339079a74eea5177b73efcb7fb3053b2eddb0d4238d72fed473948872af82718ab42221ae273927c1ea92669981d987e0f21fdd3ddd3242e5f5bc936849838fd412f396674cc92078f873fe067baf2a30eb6efa515149bc3c27ddb2c5482f1d6ab610464f6ebe037ef0964155760c9f8356aa1cfb94cbc2515e71b177a67924d189237aaf43e9e5705daf9fb18f2df5e74acf65fc3ea4af0f815aeb464b3cdeb5f0897943c134eb06e558f0ae4fcf93eca9541d8449b259cd2d279bb88e734775adf43e313b6dd1d942989ac04fef5b3e5426879138425a5085c9911810893ea29a26c25a3db8fec05f8b182d952c81573b912ca4e3cd763f036eac4f16d181489ee72648184557b13f60d35c99a013ea9ce5d407c7ffbe5fa8c017956e6c2c26e2b12ab65072402ff2b0978c45f908cb22f004ed8c2f9875ec3b641131ab2974c59b4a2d8f5b0f41e40d26dc811a37835380618b00442e4ff0bbd5366a1eed2b1cc1577d7b1a9c5b052483bbac2a94d9fd3dcdd56089cdcec002221ba8071876e76d0571123b4b8fb1ee7003f29d7d84ed611b2e8ed409c0d468ea6fc812c4d809ab6317ffa4acd4b4a2be257f94c152748835e8a8cf6b9cd1bc46c619e26431b6b435ce7ab4895c09c40d05cb3643ef2db08784fcd573b56480dd2daaf837588f4d7e4d3b17e5d473462ab662cb5085666dfccb0ca547d7640c77418bbec5c6cc47a5e8a63885220c7cc6f91dcdb0f573d640fe69f976aea8db22ae963b1fdf82debb7895bd1cfdbc687c3d55e1fa98a868b666531574e3a0f648272eb0d4c06c0f95d4bea180c8f0100e9c2579b3e164d8b88e7d57f7e6c4c67a521c74e35fce2418cdb3d0a546fa0d14a623f25daa6e4fc21c7d28a5e9d72152bce519f5df1a9c8ff7bf59135778babebbe1d747818cb7b2d370b3ff0bf8458fa05fdfc705fa84e689838317032bdbcdef16b28b27472d3994408b123897fcdb6ca55f504caac6cd81583e6df186fe4a8e2474a7fe4fdc279ad44c5959c0bf375b41bf3240de69d4da8bf2c74099f478c5fb7a8fc00a23765075dd398a79d423793662a9b48ec560fa895c4653490dee22aaa0e57a51fa4fbf37c39a4f107675927df7a33fbdd55d6f2132c3102f187d7e7b9f24d703fea4a257da50a2b8ceddbfc3ee8bf2985d5fddc39f636a51b5ca264db1d37ceadfae4ace2d66d10e602e1791f945d2423beceabe4d19c1838763aa476478705fae45ade3b320353d17329203a61e5a0dec90c34e689ccd1f0ed8abd1a0363fb9f464e087286838a46ac9c52be2021542b54de2db8ad79fe044729b267e939411064b0bf20d74c46d7d1de9b61a5d0017e6155b3747cba8ec5b41603d576fb127016e51bbe2ff346954cce339f0223fa30aac221450c2790f26f9882eaff8c00043c653bc183133fe480a9395272b9ad107f5304098a62514feb8cd5c34c265612d57b986de8f319617fd32ec36fffc9f21fdfe51f21c62e420c48799568f15d86e899c99dd74601fa57a81676aef983828a0f840ac5e837af454d54a7a7d8ada1302e651b5c50bd249942565fdc39820aefcd96f340be5739803443cebe174d94a2369de8b443ccc37e24de824cb8a08c9f8be95c43ce26b0f723bdb2085d1a9acfca0fc4060afa66745db686b1da9fa869d6030a46d388ffa3f29f8f321df2bf828b42fd0bdc679bfe0d63f5d1e622a8282362fb0f14863a1a3516eda5b32be37d45e7450bdfff353855aa05594103a4dc2aaceedd4aa9c7504739ff073ec1f72966342c7ffc2f3e3b960ee2c03911b90207a3e969a25dd53cdc859d75be4f2b5f5ed354ee2d53980f7923cd52a91218a669fefe4f687ff3cddaf41af2576abf8cab3498c0e44cfa95aa22b102fc6d16c38403704ec7abf25b006d2be2c560e9ab5c862b68925881e424cb13c429c37e4469d0fd53d41d2bdb3afe47a6394321cee6744b6f92cdf4019285e714ddebe7a88ad4ab7583c2629d239f1d24e193a2296c1cd8f7ecb00ef8c18d286358c51adebdc6e0c75d07885f4fdf428d85eb8551f3e34ff586d1122990087fe880a43f36bdcb1885b7de30912f87cdf13e8f5c52aa2e785d6e3923a87347502a0059c56e94ca0998677940100f72dfd57fc4fef8a418c4a8be64f3d484d941096052210eae6ecce941ff31e228cba7c95143a64ecdb0cc58f8a7d3adc2ef96e460085f626ce7ba6afd9c8620ef41af668b2c4c39407aed1a4b719c59d88a2313212667e882da24cf541d354de03df395ef5b008c392dd138ac09706189f8d68e5ad1a940e9fdda5008ae5f743c2f65312f10afd844150d6a51b56a24d26a6c4b2e05e0a9adb969db100e17105ccc0282dad1999273b1abbdb1f28d47476b44cb9685430333d3c61477ab030f25f07c9d58e8d0eee4205fd90bd98e1f40b7e71b8e6c16632212b72ed97292d8b1e655331aa393059947a80c6db8bc3dbc825a90fc557247c231628dd5f3a885ec12668c02f5adf9b0b2236cbf94f8d328c8944ece978213592952661732c5fd68b70ba534a02e1579f90daffc1bdf4d3caa5614c76c3417c07c36d902f059ff82a9cdac40a2483b0d109e272cb312be2c25267152bd35fe60c68cc789f924fe1788e751c126f266264fc58483ad85c2bc9c15e06f83ae9f8210f96d9ce586253ed5e97794dc5a84920f54925d0d361a2917a5d6d31d305a4e6a004ad30b206ccdc06496e07891dee16cbde48722ae34e1d8533d33093e57645798f978ee4a701cb26ca92d26469a2191c7f72fe799d95836c7e16695415e7c4c7713a827939c264cdbf1ad390c2a7089637bcda88c62f5a213e277bc0a31cf5decdd6ab7e8b429d15f0e3b70f48fe44c52961a97a1461c6a5c2128648014703cbbffb6bb921dc15e9398c26d34823c85e1ff50db351f28f950e08447120591d94da754c488d80ccf7730760d516812176ab26acdf4e5997ff2feca9874f8761a6eb66c751f191054e46db6cd6b0e4f78ad4800ac53105be97b1b047df8c512f8af5b7ead05ca708185f88092f99e238274c8133fd22ffc2822cb14c7740df2084632d1c275dfb303c0db7e28ea762ffe758d9892c08291d8ab7251dc768eacc86b204949b335431516786180818d9850c90b5bf7e130b85e57319c3b5931b8b9f9ccaf9d12bf0e5ecb453463a9702a93fb0f48eeffa8853ccb6b9651d75c55d3daa7ec8428ac3ee24bde8452c7badb28173ad7952f1f1540f36e77fa59e41eae577e3bdd21118f25e8bfe3313427b39b63a0fb61be38075c2f17491d1dd64efa9dd99c09ba6afa67565db5318d1ec6f5bb4f93b84be061850a38cfcc45c265d1687b391a7f9f9d3dcccbcb946e602d125d6f558812131ed7bb092141ea8ada95d11221960af2b2c779a5a1fd9753401d401d587c38bbbe6248a23f64d8d0939a2c68132e8a8856b3e3e22ed41a38ed9399a4fac4ed0a11b5153d178a55bb4d7c3cd745872f0cedca553aa1c2fbae9a5dbd789cd3d067947273d9a86132c83358419e8ad2254d0960db538e418de78bf1842689a7898bb06b5618655d629ec299abd379e54e15d8ef6362e663779ea1eb9b1df94bdcceeb53f022989c2e6fc61bb7ddb423187a998ee9af4e4ddeead88068d91f608428296d054dba0d7af33956bce7ca926d5fa234f720dcbde506384cb8655405342c5ee98237369701553166a47066d6aa55ca6a0ac7d0f5647553452f8fe7926bd4c3199eab39d6d2b855279db96d9def874b1052d7a06477b99b776c467e289e358b877540a760b155113b7ce2f4e0d671246904b1db4355ac9f037246336f08974790ba629d9409591a46e6c5a9e74a742b5b02dd556b89da3d4a8d6ceee68602f124e8af31e4c78e0afdf8c12775be035ae3a2c0d5be3dc814b53a07e25b33af9779e7c893ecea31bcc99224fc177f9e29cd58fbe1554217b7df11ab041771961f94cfd24f73ef0b158e4cde8549fa9eb9399434fa6ad69e1a57393b3c3e9ba5c61fc52aaf80703d1999cc04917b1ea5953b883896abe8a24664f6d094f6aa97ff2373b103e34e34bf6a7b3ea3cd0511c6177757babf89fbd6949f6a5f657ed02363ab69ac059fa9ca0a1e03f03f4777aff088378a55c617d41ff74b1b84c4982919bae97b6310f8f92e896050d02773117a0df8347304988e45dc589a2de318b8369c86f794758adfdabc0963da310832aad315a4a842e228747dcd927bc11007cf743d1b19412ee8e93fcd19bcd7bb2f46c183c4b14f867de1f5dc3e529812bd30daec8138098a66853467ad7a5083650a6dd2136268619b0026fc63ee8ab9e6661f14bc5d0d3229349d782c761a7ba9fb56cac5fa090fca5ebab33e2eca9696f36c94900432c49cf0d5310ff34e1571df14d53079ee70c2617c7f5f34efab49a488828bba0e911e061152fb104d1f782e673a061fcec7009418a5e52d3100253463d4353ceeb51660c615829c6c0f7ff85a0579b2adc85234ec20ba8081d30ddd6ac9093879d93e0492cb18f036b2744e8075e3a6f3c5ebcb2e1b127e172a648f0e9a726d9430c84eedadd9f89a1484f65801883214212f19bd990b13a66bd168b17691af54c623873c4616fffda340276bfc38d1b58b66a8599a89f7c97dce675c11344f79c846c2c2fc4a2e7c37a68f616ac7bd21a87a64039000f4c8905feb60d021b820bf6b3a9157055d6f37d980ecfdd127ce4f5ba3759f9a755e8e84e21c1b47dc9540fb3c6b1269b63e51ae5ccc3871f74c0c8fab8d41238e4a24bab3529f54dfde3fc91f75bcb72544d036bdae53bbbed884853639cd57216439cd07b4ae8cddebcde90001b3c07fd5653a33e790ef60fa293f1050cb642d9db687509655d8820edc528faf0ab1cfd3ccfcb079fe56009e5e6fab2553449a91428f81202b12dd4efc2f2884a3a890d23451150019e6387aec702aa69f52a8b21cf979d17b81684b899cba848ad4e89c5aeed3d1f74264a44931c3828805677c6177aaba013682c8f19203d0756e30210a233180ff4cd3ff454f4ca228b8c3db5d2f592c2aba668e02a0e83fb8e03a4a7efb2e2ea7dfdedf8945e9f37a7324a1a52bd129ea62acb7593c8dd8bbeefb513e73db6aa42115945e4a5979c3f6187ace0a6457258e37a113140f0c930790772695445d509f98eeb3557e9e23e7df4c06992c793fbb68fd340f6f99da95705b3b8bd0297e883c2c83b00baabdeaeec88fed68261fa75c5ba37a5c799d54b7bb8530c40530ecd1de44263b19f25046690a760a28d5fea71841eb0c635847103591791de493ab5390090e642d40f0288018edac438e64e59797ee4153f75324977900b1d905ad79d45a7fe516c9e33741618ed29f43282180bc7bdeca36f410c9531524141abcddadc8515476caa711cbd9e704836b77dfd3a5058b7c72fe13f357e868096921d827ffc694df7c2c661aac4c18c0a398ef6cf3a6082a63ee53f2e2c42c21532d125448c7a9d287523c50e65ceb421d3c1df6305831203a5a92200c3534681dee2e18004ce9b4c532cde5071c6eaa5c89048b973a1febbadbaee11476c99ec290d6d33fafca1a220f0f8c98cc89f24814e61d587560e01c5c01f6ac5c17db5c43d7379a07853292c510022d824d75a212465e9af4c73cde0e2f34644e73e960f0d3f76cb38ac883ef0e65b7dc8e956c123eeb3d23a744200ac23b056e5b9cab2380a4daff69de6f40ca49602e65692a5f5537c16b58cec4ce7a82776a778ef0957ebdcbac7f2a53b6ce69343231cf08cd24a30689ae2fc53fc024f5a63d812d3f2639b48253ab0da900bea07125c7bf842a5f9e67c2eca8aa345dadb20de523207f5ddadedcc8f8aade2377872d5845ae74da0b2176ca1d40eeced6bd58781b49032438d65d76e9f9bd04d039f76d9f14a0ead9d7a4ef296dfd88cd8285ff2fd3b3b52d361c08fc275b228a509d6a4f83fc254bef2e9611b784d3981d539e982245420a59fc4a4dd37506cfe717a6e37b186a00d18f19738beb640cbe06ca3f7ed93347292e3ed8ff297bbf5f5c33022927d9f78bc3fb79b44d9c1f6b9911b74011ad7cce9511982fc72390a5410970585b75e400b3229cde64c7d2a7d3fbb8942c29ee16a21622bebcbfc8e9ac126555be561430d2184ba37076418c6688af38e7a49f4294a90d18cfc3f61e5ce4407f23a88a8e79324b2242a5d2f718cb2d2f50521871fafcaf15ef6fddfd34cb67bba667c1a9ca6024ee630ca03837b06caec0dfe096e6a05fd8565e2fe8c5c77f05e709a15f099b7bee8bef922ac005c13537db97241af61826482b5930f8274480909431462983946d08bf293fb202376e8beb4f37293492fe0d74c3376e4a74b136bd477197bf4549de8ad3360164adad50e96e06ab6eeb1669596c802f05538a8f18cadfe9942344eb350c3d14d4bcdeb5338d1dcea16986ec691682689149871298a2ab7c08128514bd7f297f025da5fcf0983009861f93f52518383aea55e3fd9a0f85504abbb877837a7138fc3baf7d1ca3d4d01d2e72e187c20d8758de549b81ac4e173b0272a78f1769732d8fc8954f38dc52abe6e824b3eba3364374a1c195b9a55ca1dcf934e6076c2863baa07f5ca5b5b89dc5b37c187c63df962a346f11c37149ec0e7cd3f1adce5ab7ce879ce476d98dacd565656895e74707d212a82234cfca07d16855847c14cd0f67c55b1bf6dd9517d4fd69433bcebd24579d97da1af467b1cd71d8f12e9240985793bd7feb166556e6d0a99231c4d207c5eb0e63bcb6d65733ce490aa4711a2b96a611db521eda07257957904f8dfd9fcb8e0a49744aad9dd688806b27eca2619da61b49a8fe35c8047dfb9f8dd3ccf9c2d7429f5a66f7ec1aa1f12c8a9b386c8e3de57546f74629f09c34cd94b26bd3b11e073792d4a24d2466750ab4e264bf6fd8d1d97a68ead7287bbad665b7488583f8e8895ee37611ef980f780081cae00a51c36b315f884ef6a3a11fba0f98b589ea69f6729dbc6899ce6cb3e48ce66a361e1c782a3a5726134614b49380e789f0d4d9dc9427de8be5ec3826a872afc22c37656a5f85487a79b4b831d0313b774ef38d17ce13742c0fe5649a439447b245a34992d27dce88afe7c8d05e73000a52dda54d67a73be7a7147813c05998f3e6207d085428ed7af98b5429447bd45844f8a468ea3f51dc4e82f39fe576eeece2e54663ee2941bcb0c30b101fe3e69c79478cef8bed9d018cb867a1d8743fb2f45a6ed1ec82557772b488a5d7da04fcf789439f72965b008299c9bb4c218595a6aaa2f6213841f87eef248b9248c72bfd34f42ae97e9c0bfbef519ab92c9a6614e9fbefa6c3864f02cc1f9c82921837624222f0d08a620dbd2e414fa0527d50154823eb26c0e070417e8c1668a6e12b8ff95f637060fc653c5ea901ac13211413fb5f62939c89514c0cce597731dab3dd22243251cf308ed3095c9473e3891620319d84736418923b362a4cda4a0afc299f17e8aee6475467721f55c26585239e09f8ede76541f267c40b10fa80f5300810731925178b1563787107f47db8c93a993be1e15d877f35a8df1ad44ac1b976d691b92d215d89f83d6e3b5187816c55e31708c1bf7ea487fde96156bfb17d01007e0ada43e3c62bea71189ff11f50dc962a5b133c3deda3c9172728ef4f5fe77c93ef7413c22b2a146ba7e845647d5d151477386e337cfa2b479a565e27691ccb797ee9ce9c9f3734437da6ea6c4c54a4497e469f8f8bff5bd04321ee7ed0ffdaef730c5c427b9a1b8ecc7e8ed6bf33f8dce907279d3316a18e8a72776ac3cc0f2fe7257e7891b306fc60bc9f5323aafe66c3980039580118c3483a6e6a1712bea2614d7d52ef1441cef1a11c240ca4b7941b30d261a83ab4b59820f482090c16b0abb0380cdf76726e6d1c8023ff79d9910d2437055f577e100c9fa3c4a0cfe42316d7ddc9e574d1a259938f58f523a349d40ddd6de61726feb256634299a7c4be9f6318c3a563351010dda45f5330eab8ba52fc61a4e9894ea12b39d3461754ce62c2a53ffb259cc2fea1023c1c20ccdc23a35d93a368b4e778bba2ddc27372697c7100bc1e488626cad7a6b0c40196d4568421b10781f4ad59dcdced02d6c6436b20284f31fe9f46713ea0189eacb671983347431666d4e3b77921235d9cc084a7ee0f1df886d0be9ab3c0dbbdeaa13e17e206b98429ae729f4daca6ec9ffcd1b25e93da59640b6e9e0d9efc20b37453fdb81ca12ba7362eff4575d5f120ac16a205f2151e7dc5f782ed93797b03bd0ecd173dbcf25253247055bcd8213ad6e69e8d857c0d93fa16802267a76838ee3eb66b39e0661bf78d98a4a544218c656c03354e86c61c22c2d1cd6c7323e65ae8ff1f3682e1ea2318a04c7a449f339ef89e19e29bd86d2d99c35e725254c3006e6272db53c0fbeccc6eed4c13c76d5d399a6eb3ccfffe469001bc3835918d7757455d9a491c41b11cbd16e23abdb4cbcfb26f2f735d3b1a600f7bba7b2f1ece022f3dac2e60bd59ae62a44db39fd87117c57c036830d6e30c8e50c7658007e74ae663d345107b1d149ff05613a2a9e3e16686c343fafb7ae149e57634e39f2cbe5a712d82f17aab7557fa066de98c3b8aa208631628999a88eb7c6ce288d7e972bbf4ee78e6e1ea4cda752a93c7fb23a263df3abd4f1814cc47672ddf6f83b4b18ab56663251b9fd4ad618b5d7fb39ab633ad53e5fa33bc378226c8e085570b4046ae8a8474d3314fe887207147f4bb0f4d898e8db79673a240fd0bf09a7f99f74dc76dcbdfcadc0b1a25c68bfa1d2a044a46558f638b293f0804a56833e345c518ba3a682c9850f99d1ada876fa2ef3e581816820116b573e844aef04b37a0d5b30d586a4beade85a0e3673c59e06b852b051e47aa6d2aa7e8eaee2d723e9510347fced3842af6384fd7c03e0cc08b1f8c569038a763988399b4080a33f9fee8288bde6c93d8ab48e3ca407f7b7237458513d6296cb1a04a9ee10ce6e3a7801875d949c2341a4c4e8450365b240177dee535a3c6b53aaf6d24976f040d8bd4e44e901ef5e2e47eaa21897e79d465980e7ef3e43d0c02372fb85932e841280273c383cc85ee6e032b8a017fc0198399e318fa01d0e4e7b078ac5d396898c7c775a21f032cae9ba0b51119c8ee66e3289c64b6465e7299d2eea578da6a3f66e9e0a461561c238e234cfba2b0626726a1845f445ffc55819f64b3c29dfcc43dde1fe0ab5e6fe9a55e101cc6f55a8a53a0b719f639c28d39134a4ab75a34034ebaf88c7f274959d0056f2da22f8810331eb4637a1bf04738b706013cc64c33af9534071f2f6b36e64dd62508f658335048b27146464843d51a22d57f281bc0d70f8761b18e666aacfac3fba436b8cf352192cd22895c31622dd66793e212e3d6b4445d233ad1ccf2ac7a6c8d74f04261f486e1b748ddbd63870414804b190728a7657de35d8cefc0cd393206beec0348edf88879e15174e841de49edf6eb96d1c4987066cdb49f9874b11b336a0cf03c534f4fdce0e8bd71512422be3df9f55679b39a5310b3640445c1314022012dd956b2669f0d1c2552bb88f029c9c3aa00ce39e8918454e1bb57058fc3e8bcf1add6cf86d1f675397601d3ca931fe30e590a96385191c845f299f05dd0375a406300515d6c7d1e554db1ed18a22926315dbb38ae3b7d07986c1b80a4890289748010a9294d4a6ff0eb621a4a53a685766cd67b88ea60d9faf34217d2c724e489d6960d79215da1e595b038c599b6e2650e780c3dda3f96be4a4088e4f8d0a0a1a82b821aa930a40c7991941547c22f8f81a879fae417351805dadcaae2c0bee560d16e04150c8725398ac3de219b3f62b0e5a411bb996dd15448889b5efcba61af9dce8d6f6c82a32c6e6232f00194139260cb420b64935396a74f57dd1e71e98ae3c8091fcfb3b21c6e77c085cc3afb98b00c13942e07b2e2c5852e05c3c9e32cf5a5f1accfa86d5084fe069ae6c83d64b9713aa616af0d4d9874bf7f985432c98c5b55beb92da1fb5ab379711c5803c44c56da05573cc5d653725198355a1bd6bde2569d357a619892dffc2bf44a92565491aa6512bdf6e83225f4b91c97191895a5255554e055f0811fdb0cdaa004642f354428e50304c6bb9e5ed457ab410625aadf48cee7dbc3cadbbadec94cbfa3d729f86417f5c3d5989b0ddbfd8ae9eeadab5080a63fff8d85fca7a3fd4fcd026b886a1e6ff4fcdc3fef8e0428a6316396363e621f8a2c4f2711f8e89415d27d9ade5291b31de9be354a8acb47abcf37fd5259bc4d126c79c844f68f985ff330cfd87ed7105d8610f7c6d1a8ddbc201e6ba57ef700065148f6ffa282bd62dabfe2eceb53b6413c41e6bc36f2b3c8c4cfea53f3abd00f4e8ebc59f58e02fb64f33a2b73239b23452d3a7cdd1b39ec9bfef70af2b1b2c7654e9b22409bd83b2d3d278ed91df0ce48ead5bb9a2971d43400cff030dad828787ca3140e691bddc3a31e976f081457cc3a1e9208ec59a63967f305368d9fa06dacb64c74cdabbf55651cc6d9aa34ca67a6430399db8a07144dda651c1ff240fa5d81bd5a91266684f90926a8bfc18e796bf5984fa574213a164f6433fbef97013a36c9675f5a1574306cb6d61cb3f2e7f54eaebefa947e93020b1774cfced3be33852630ebaa80d47934641529b29a3dc2f620aa0c1ef3ec1d9509d50c6f45e4482d9426ab5208a36cee493406738b348b764568757f164477a81e0acf4f7a5a518e61c7216c08d369f605472a76be2e5ff1500af27d9cd093401d078311fa84bc0e535c86df0b9ce9207f632d5b80f7b60269cd0c21f511f5297c40429f53407cdbd6f3d27bc24a74efc12bbb40e9a36d588e743911ceabfd66535fb3f9d49b5ac4f402da449e6ff5980d2563e650b38b1c5927cc558fb650d4ae6cbed11ed936ccc8c05b8b60659ce75caf59fc6e8fb1ec5b7f063144ce3d2d7224eba10b27bd15f273c3e9a8c53458cc509c4797660de537261737f5076d1fce1c4a5d4b5c1fef3ffc8bd268a70f7155b3dad30bae8ccc2fddbda5f8d799292b2e3c8ac910d3e39556045cc16970af3000ae49a8ee8ceeebfe7ab23adb8cb144aec4a06f913b7b97020f96b4f2371b8801816c42dbbc162b74b16980f869f18b06c06612f803ae543ff1e2c1ed415d3aaeab975ecfdff11af7cad5e2573801f08168a8b5d2f348ca1c87fa0bbd77f695cc7534b50c26525c9cd2415b263e510ceddc6c93eba81ff1162fb4038bc62659fa4573853996266cbee78cd30a8f9c2f48522775da4739eb6309ea02bc672da9170251d7e488c188734617f94fab379c71cf394fecf0f775aae29925703c6ffecc3a67ed7ac549363374f72584944a94484ecdc99dd422f9d389cbad5ee2537e47f1045f0293d9bbf78a3845c46cab724a78d74ca2ca24f16426af49962b3627a27da05bfc507b68e505a6f2fdd69f0875f11e03652bb1af682fa463ee5e76d62d3a65b6a2c9594b6e40b89bb49375b93f5d23f9a57dfa51dfa9f00a5f4d9132ff24eeaf424710ccb36c3d34e544c5592bd48144c3e26c31a41fc1f320c9ab681bef06dcf073ec6c87043e403767aec363192c26696861d541f8bb75f2e209ed0b9b3ea9f6487e9f0896bd33c1d660f3c340a5f8c2fcc2a64d79fea66a1b381a4a9a73cac26f003c7ecfdb0a2a279a90c7594fb114c1235e40b611aa133caf23af1b9dd4dc9de361508e1a4cbe51bb2c4e0e8a54ac7797098d60f1f52187e384792d17f4b3e82aad283d2931e95ace9f33d150743dcd820bb0999128f88da1c4b0e0d8ae5688fddc952a06769664aa3c99be806ba5460473d6b985edcba3d75b4fc35bf84d0464593a489ccdcfed9957e285a86e4de35756ef34781796a9ea909c9d98fa98bb761c5fc9633fbd6a4a85d60422d355f7551acf5efd3b108e7e66677bb471541bbc86d29134ba8e00f9d31e88edaaaabb884a034ace285a6001866ed36c077ce1dcef212e31be37fce274d855482d7910e1be23df633c22c89df93597fa75a2b3a5d54ec38e3dded674eb8678ed1a3aa1b8730a7ca5c375b2cf3f592e7e6075e5f4f0359951921834a34735c3fe169ccc01b37cab90c9033abac25a0a0137df22a72e9db3b930f1b64c7ff93f7373322d99b793b855b7ccdfe8fd9344a52b9e29025b1d86b124af4c5f51b4f479986874835bb4d6815ff136f2b8de2d3cca25b2dfb052deab758871e1587db3de60e6b606ad75bd63dc21c4a6dc4cb814bbcbc9b97c26fa065df5559de9e8c141a52f112b956048749267d26993ac1957eb68840f09700c9243702d0da78e9db48a4919326c3cc94b707136cac63f0f610194dab04332570b63d6fd11d472e3f8c82c2cc3a40c2397d4712c5150deddb40214a6bdaba96fde266ced57eb276166abda8e1b514a18825f49446386d16ef5596e8d3327082895986a8287aeff8475d2cdbd16323fcbb342db0d8018d6947b4bb07c83ebcf8e47ca450e487bd786be6f2d2b513f01e03498316f11133d35614fe68dc1a26db0efb728582ffd68bcd2a8cb480ed7036a59fce2f6d9f8c69537b74ac39debe45be35905e2132e7cb58d6401f90121720b6e7d7c775799282726b8e1a5530fa88ce8bd1c214b10f5920eb97b0fc3fed65cbd25c718a4eef54845a5a34c32e8c92d958ccf292760533a9ceb1dbf9ea24a60c4718e51d36edd626b02f9bec272919e2e78ec3ef2b95a156f87b0a42926036ff0ecc7c9a34bd5a1939448b0947df07508142bddb6e4005d4d29a2d0869e771773ae80a4593edfd136fe61cba05840efc0d12f446ff263b196f05513ada5ab79004fb544d7275e14f00a53ed5d9c701cd309e9bd20696ca3694a73887ac8829b3bf86b2e346c213d62440fc1c8bc68b6f21017f7028b19484effef609af2b58208ca1a0ac8c564beaa424e4374fd16c43c5a11b01b7bddccb5cae57807934bbdcf36d65077ff443ae1c0bbac5c1b2fa28fe7f92791436357eb82df4d177f03eae71d72040c3e7888fb1aa8c1c31270ff58d3ea79215b5f1efcb90021d1f5edf0be5e69fcf210cda6cb6d60eeb2b4b6593a9d706fab66816c851b2d6d58bf363d503492cf9ea25dc2caa009c06aa6a0a4f7cf5a38244ef5b8d063ddd0add467c1ce8827db556230bd467d2ffab836d69060d53ae6b865db5cacdc90f5c32e745b76fe4207185a2fb32de65be8d0fb4c5bfb594c6916c26fe7830b59395ba7d7cfbd0dcdcfb22b63753608e12324eb1df4bf875a3a4231b29ba1bb2cc04ebf14f6893ef4c000f85565ccbbf8ef7c2fb1f574898f0cdcdd1877d7febaaa33e2c750933a0a4d8e458225f4368a40e99e40bf798d4ede0e1ed3bb9fabe37df92536924131a35a2b8b33766b6e3f03e3974c5162a7f391abb9b2ba72385893169fb50d5fc422c452b95460c91934e2d1e85363620e209bef882b74e75f912b7f8563f0a81ad231b4d4e7b9708e72ce094ce9db7d5ba98d90cc034be08bcd050b2cdbfa59299e76d464097edd2b8a60867ffc596ecb8017785fdfe984049b091fa5f92fb671a4a43051cba6b2b2d9a885614a711e72b140bb1994d5a8c9ac81a1260bc854b2d583b9ee14886956bcb3b3f59eb0511979a6f061a487238c763c6e526ff04b5672c7dadb8c123d7da894119c8050d327edae7d0051f27a7b1b547923a4f153fe15fbcfb74146bd62b65095d3e19db25d20c91c720ec93b59bfa339693ce4f2419c5e933bf8dee3aa9eb2f8752d0d7e042c35fa1e03c485a4dba3bb20d287530bc6512244b78cff5be63436805a8da64d393e695652ee17cbb76d0a572e4b32cad6ea2aea5a9c4efe7a04b1a4670babe67dab150021045d835442d5a05e9ba39ce12e4feafd0ed26fd0898292eed73b2b8d3e6a86a7a462faef9ba9a40a06f7c1db6f972a60ff9f6f8745e23292e4e90606f6955b153ab82fdbdf803b886c5e925849775f3697a899560fc970ec59821bbb56069456817aa55c9c67f10095232a3bd1af7c30cb436b2ca83ff20842b7f46cc08374dafb24e33f36880434fe4aef1b90f7350322b861c24096b3dfcf1cd87c22ca066ddbfee4e0aebf15e1cc7d0df1cbed13d089c5c64823025339ec3bd1978baf355fc601d5486f7dae7ff26c330130e2cee684b6f59db11e830f30b27ddb689019ac99c512347f198dc29d254f6ce15b411cce6212ab34a46f5facb17944d829f6430b2a569b63247b1950c42349936f23a7b0072b649490d2dcdd441ef5ea817858872c754b6070634ebc1776b5ad0189d47ec84265efb2113db3523a32c338f827fa7906796703c34c2ddd9c5282c4f3f7d83422dde1cce011f1aa920e06d4a8566e24b4d18c41c6ea802f2835299ad70c2c1e22c063f2be0650d02edf1a9a88c7cee03a5f04de2bb182a570e6048a62f5370875fe9c3d916b022e4fda7ad4908ce9b306ee1a6de6abe2af877abb2e6e437eeffbe0d305c9e99e0adf1637dae00e8598f77983e8b620e1e8bf3c473ae647546b38abb9830dd49de8c94c31c20209cb6d522b96610efcbbbc9c08168254773047d12fc051ccc1e6b46804b172061791f7629293946c0b8aaaebcdd717edfb37a8cdee68e83df97a852cabf87dfdd3662d073f3a5e231f4d6557a4ac50e2adba320012bf06905ebccd59f01e26cd76cd4faa439eacf5e1217ff09e546ac4aac201e54b82864f8d65f8fc51335991fa84868cd7b74113e72ac3ba22034a789d836f97015c256abb3e791cba9e8ed4f030bb97ff8c5d20b07e643be3286fef41a48342ee140b4f7ae5fbc531ec0f24fda511e16fae4c19cb00cf6915a4084733a5644a384583f0822da841551849537b10e6daeec10e71b4782b0ebee0da8242c57190aebfddedd7c9c158507873f8d10e47130095b9d6d1991ac70985000775338d15588c2e469de9192ce5b53f5980528f829d15f74e039cc9e842785dae4b135b6e0315c99e2ce8005d4810d142e67e9e423576cf7232ffd587ae8d7e7c5bd4c19a2e9c1de094c08b3df0f143add43f887513a8ed465f49e69ad3a71ead138f9d45fef472e1a2476a63de2b13d738a229ae0074025ac4f7ccc1fd549b2a2d125a70d4c33ac7f879ec54aafaeef9f61ffdf7cb1bf9736b3e39eb6866d53129209d1610a2d4921db0ee0001c85a4e30e4ee350cd43bc4bea861e2e950c82dd5c5d0dd580a5479ac8271475a1bc4d070766e6b46fdd8570b1e8da71f25b9fc25c569123a55eec9d4336c69904feec53b6b4b302b9c97aefbbb453e47ae2e8ce9067ab56d3df5143d570adcd5968939d9f5831d0d2f2b861a9a3be7ca13b7201905bcdbab364ba29615f18e553deda738bdf9282b09d9746d02191af0b63c0e2f6312f2de1a6ba855cd85a584335e7bc2aa64a66024e75c697d9cf8113b18981b7b8a95e420338f737d8c796f36ae515847dd0c5656b9743fbb6962bd51dc58a59d21d185f9a5a718f6f187df6e4a33cae4aa947a4708d0c03aa28cf23af0962aeb998d5c103bf47261782ae1004a45850b212f24766b06dcdd3616789fe5feed358cd961aa18808af3cb18bd1f66528117585219fbe9be9120db1bd997f6c52fd4a58679d6e2338c85253543495e0937398460abc175fb2bc52437790a77eea070f79b420c13b45a45370619b0bdb1a812cbacbc45ae8975e12c2785b437714b454d5c16b739cdd88c4f689b3ae6eb7b366286cad6344ad57ca0b9a9ab2ecbb929bb57703ab7dd081d3522c2aeb893cc887270a11c94a2903a8302058538c5f39fa335e69c8c981638886e365f7e8f3a0b8da11bb91eb5d168fc5590c4f650310e8a3fb18fc0c0f88e1727ef4b0cb924f1e16fd537b6dc66be008b9d2270a5f351d2d2cfce0e5b63b33707ac10773b9a1dc8d9b5bbc22f372d36e0f759e32ade0de97ffcd0876972ab995d5bb6eb4252b56a3b2781505a6e87e208079ec4c1574421a8fee52ebab54a1d4168f8953f5d92aaecfbd9d2f145b253be4b406b7d1afdb3efb82b69715bb5a7a69dc61f1c530c86b5a4dc151b93d3ab9e3aa99dbae3359a1ab2eef3e4f727f8edd1a2ff7b906c7a41cc7216f0233c516e2e0590e3421075b59ade0a61254dbb8dbcdc305687222cb9601d7d59c2f56eccd3087e6c2ac1dc1bd2f9998c8625050e7cfa4598cb686f2bf9c314894a4e8361dbfc1c057c7e45b26ae8cc775622ba583ac6f191d4b39f5b1835feba66c3c2c2f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
