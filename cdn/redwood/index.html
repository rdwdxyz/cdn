<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9c8e7b879a195d3c35efeb5ba50e250526ee6d42c2207807463722b34f230fc7ea6eda9899c1ca225888854d1ef7a6c6aedc4325b2296467b9a2b1ebbbfc61525e57997878f946466c309ec0523862c6a3d6b831eeb9dc3ad3ce8ebecdffa325e2be86c00b1122690bfb4d80f8fe0e7189d8679125969fde902656cf0edf45f27556317f36ce9b22ec3cb8b57db249d9a38aa46484743463aa106e4b5365925349dd8f2ef53dc1c746fcb75e58c64dc9b83129a987fe80835cb7a8533f1c98e7a4c3d5fa1f4c74a7aafb53230d377b5b7dceff5754279542124d7e505025c9b8d8fd7b95540eb056f64d4edd02140a3e0b8db196a02de4afb6edf216d6752ec8cd93c65458a81791597117b909d5ec95c405ff2b023320313974030651062682edbe801ea438c29006548f76ec502370207a6a29c2d21a46cf6e33d3fe9e024245014dca1974fd83c3205094d344892733399cad429ded298cfd0ee07053a965d9ff3f9785b0c04d47178032431d6855a17c1368712c217ef164f611104493f5d0b7b3edaeff38502a6e0b40f18eaeeac6b2aba3ef3399958dd19d2d9224a641587c42b6b9c498044ff09aab7b9812b993d75276493742dc5ee6d9763cc44fec4d472e592ac461d15162dafaffdcb733a436621435f7fddedac5bd99f2e0e98e823632b1e84a7457799f5ed23fa03705c1273ef1ebaf018b90ee7142d720814683d122942072c5413c0b4420b352573bbfadcdea991d9ed5072f6c81d73951f5dbd5d960a168e7e759c8ae9f98c567630d7c88705e993e845013540f346d9f71f26afb727012e588ea2ed09f39e719572d71db60458931635431bc6c22c583ded346c3b034b2434b523ba83f76b812c94441b0e9c9237e7c70a6f6fc6256c112a20f69039c371fde10e2c9682d94896a9d74a52975278b4307658118975aa4cec783ef8ebf04182e4780234292ea0c84e66fcd8e6e16108dcd367cc11f94fb68d6560621bbf15db361f6b52b99535e7c4111751fd5c3ecd78ec54450b61d337234f5edd09379ccf187440c845c2921486f0fb5f31f277557aab4fc808682834289c3f179a5f9208b87eb6613e207340417f6aa77ecf5ba3bcfe5d98e833d0288fdd6e54b67f56fadd649456acce28b893fb85c2e6aa53fa36e021b5b527777533ad1173b8c864c103bd4f4404fdb3d95de9a3574ad05ed791046761b0d093f6a189089745aea95bb15a58e70332e1726177a246ad30fd39ee502f21555189ad98a25ba394cc4bfcbbcbbf6072899d6e2d7bc40f8498963cd9c81bf908c3d0074757cde7dfb38e2149d842f95fc793c93cfc873bfadfef0c81b1306874ee5e0c46526a2113511795b8f92b5fb06a42543a8d10b5841bf0e8b0096bd8fd1163082810cd9b17f80f91b0bbfdc759130d82daf9850e34cac4d0ac09f13869f2d206d845cf44ba0a485620c0fb8d14507245970cf0c7825b1457cba4ba77227f8ffd01ad956088f4aef17a8622005592747abadbe345928ce3c5873c966edeacc5716dff1a752180cce24c0673052ed210f419ee9f79d2b323c42d932e30734f37391833d8fe145281cc393b03aa314e7ee59d28a334e18a843d640ebd4f83aa751798e18cd136ee64397cc029cba0038fef12551dfa4149e9b394c219a5666c9858ce1fbbd3d770ffcfbf8156f7a8eefe81674c41bcd3290b244d9cd8abe556e2b491de2e673acfee6ddc6f51bd4d274393b95f8c7835de9bb6c56653cb25a335b684f544bdd1c72574209474e866e2acf5c16dd08db6e7ca25edff3b2375bac5229d8e3734321e766bf01731e03a04870780ed828bf8f0f506ea57ca7ee1b7d386d9c9079da4066577811ae4138b48888c21897121efb32350a858d27812beb72844c63221423a1f3413ac022338b6e18eac91faeef9c934b3e70de1c090d30ebd3bd2bce77a0d3a5fcafae0ab473fec74936267ca1ad7a85a6e7756b55e3b42d79f2c0e9b7a901fed8609874d409ebbeddcbf61370be622f319ed836773f8b482ef22022d87c9c7c5a796ff9a709f5bb664d03891c86a7239ab79ef95e164e996642a444ed721bc96af6850226659e658ca3697802a67c897c06b2cb98b5cb0d2208bfec0427172790227e8f8b52bd4aff641a7b7f10269ee46012cb1d317fce3c10ee0c0f3316f556f8b44e1d0fdca9bee87a496079d0773607e3e28119726edea48aff698ecc6a5ffe500444c210710edef56cdaa1edfc7cd07dd49c740581841539727a98bd728bc38dbbbae6759c352ab667c6599c0cb57fe33f24868364cedbd4baf52d7bda5b8456b935c8fdcfb248653b49755f033dd41845e793be64ffeb70d0ce4f8fb07fa1815234836f7486c43a1715d523f763f7ee9edddceb92d9e2289894be0b5d066f01fa8299cabf655001ea89c653a249eb2c213760d1724de914d07e475821f0c3660ee708694d5f1e865b17e09e26fcb365bcfa164efaf1582af7df9ceede1273be64756821c39e4affb18dc1754e4c0e8d4e21ce6b53ca826e71a46d30a59b63e3d6416a7d711ed5ca88fc41851335561546c74d261d8b854868b4b654443eba6466bd206baabd16dd557032d56d9ed6fffbea494d33a18e8644ab64d5f6acd51884fd73570a100bb7b5e1305a9e2c964b35da168a0f66bf9b1320edb38b5ea412b3d8040676ff61180e8582f7393c3193710609d567e75794bbe0d35bff6916f7e1ed8ab6fc76e33d45539cb0e36486331d751ff4b49f0d2fa4b39cf123f7fb1ef12a999975c26014e6cd8aca6bd80890b4cbdc13d6adfacfb9e0faa61001a61bf2a2f377347e3ce8a91ea597e986ca5e67c06e23e1cef90df8733ad85562b68924284e433d6fd55026be1fd503ecf582ff19602f8b8752a6859afac20b9f111132601801a0cf37daa2473823d388e44265868b8cb356abdf9531dcbf353510faec68d3acd2829f0039cfe904c0dcebdf89612b79d736dad829f40c7d913b7b0530041b15a1c8d43538888ac23fb68e1cc17521dab050f74d2c9bfec68cea01df5ad0f4f091e7166c5ba5d843633658ab8d05b16f35808eb45455b5a0854c198c2e32168a2ecf698208a195b5ad84cbc197af5a1bbb6f8823640e604538245dd289c6856fc7eeee2b349859ce2c28d52a0d7f201411f27910fd859873886f2643eca13db69a6a1092c52b35a91c419594a52734391c1ed27e3f43b918ddbe07d844b155dba95e2b43641af3101551a07397884ed303b6d7db1de298d5c3864fed03f7ca7266570bd09a8a4079886655c02872f544f87271eeb3091cd6322db3cf5814672b79a7f144ecdd2306362fa4b1016d0ee7c8e01c0e8bc6d0c33c68ffa97a7d13f19312790a8c67cd5c7689f0e2bfa52526397df3d84d7242a70f7ee7ffc86c96182811706bdabaa2ee8e6c65291e46632626ccc8f89660569fd88fb9f9b02f6aaa86acbd11cd9c62fba9dd6a22d03ba1b54abea82b088053ce4dec0f6eab6efe2b57c2cf060a1b2d4e3df0c155e2ca9153135aa34bc5441a63eedc6fea23d2eee10a58a23c6015c506b05a241863b20aed3f820a2ba05c54d475dd9b61e3eada0e9ba17287f05530792277a2676ed916ab486b139114e25e8507f03e938f3cfec1310f80da4139b8a6490db14a863d07025ccf8c0e216298bf38dc0b432be75e307e4509d950b6f85b4aa743fab10c021107f035387bdefd4a3daf9dbf12ff3f56e40ccf03473e490b51ef23250ac0e68a9ed95b81975d4529534bfea0fd184421bf48bd0d8d6c09b58463ad794084b56fada6ea2a0b6aa872bda2ac1d8d7f814df54a3992a77239058d58d0e1b8e58aac468ffedbc31836ab367998f2818d4b097909de59acfd492042cc4442ea9a75dddba874134c54eed871c5717441a4979c00d1884ed34316dfd6788df8a5f8e1adb3bd54e6a6caa0eca2ac60e4b5e23af9200e3ac77cbf9ed33c7e91f2bea3c4de3f9f5b7e35788c6f1a3d35634a41aad98649bc4432ba916159ee205ea098c95fdd69091e107b9a92803c03e600133b7c080097bf884c39c538b3b5f3325d1a1f769d5eee47d6d142a241f5657f04ce8680766bd00a76e42d4c918fb616b7f6e386f82fe561a172a130f631d3b4860bf4ef9f3390e097fe0f3cb83017b9679fc13854dd8496d39d2370cfb4ef3d2b4b27884343ad58b203729447ac6db259940bf11adfe5e7d2b1016c8302e1ed6eba94dffac88444d4c642e5b757510a966d13ed9e9f98c0c21527407ee0e1d6beb536f833359842aff70f2786290ef7c6873d1406698aae475cb9256b3fec2b9845f0aaa9a667f31086dc67a48b5e2670831649f4fd46d3f11421ce1b6568bee58674b53368fb36bf285011700ac6eee8afe0bb83e81c25be6c9011634db7a178c9469eb63a0bb3ed54a4b5e7b619ffb3c58a5322c85d8b7889d2bf431a5490bbc4a89ee8307a51991260b068144085e6b7c062dcaa89820b7e1f260877c30e5696d15111658368396eeba3870b324c740bc83c13cdc63f20a0ff6d4978f6caffb8c66c48908d914ac3c5874a0f9523bbf0e1fca02c8e64f3fa96be8a10fcc772eef96fcbd9f080de8812537adb90354531beea833f2dd2f10eceaa2bc31b7366866bc0ed1cefa1b56f95d228e46f1c0b299e468d7d4464d191017280e4766b92e421cf1ab28087af63b756647c38bc53d6fceadf3feb4dc49f94775afe35224d2a997d72f9ae6e4a43ac6e19930bfb57b45e5cead7087bbbb8db52999f9149d552729df22cd770c8b1bae50caea89cad7d397a3e6194ac1346d19e1b390610bff0d36bdca7cdfcb2d4c4e75a7472b2b260aaae82713900d8ffcc170bff9f5d4179e861fec5a75ede253094ba6631cdeeebf71e6ad894e69bfd38a59acc39e48afaffbda3aaa64a48bbf3277f9adcba7fbf644b2413f936d3d6943131ecd6fd0b1093bc0b4ff17882122b8b0333d34bc64db697f0180c48e4f48ddbfe96f4ed4182060598bfe6e06964f4c6cb2d54eef598c61462d61a66896de804cb7dfde28dc9e5d35f1b827f5901b905c8ce37a5b30a2b5eed7ec0ffb02b8d45f242aae3e89eb50257b587b8cfec07fec027f8957d0b6f089fea048a6e612704087eadc73ad32089164867b841bd108026203487fbc0bdb2d351a24f96563e8c581d3b3360d214bd6711439f2f872c1f505143934c182f251e953f24013874c71fedaf8ae00d1c0076c169fb3af235c4d96fc1624e1e00d7d4a5b4b1d25e6020500687ede8a28ace0353891740fc126c3ee862be65a778b9cb660a0923070c69ada992dd2c3b26a9ae03f232265b830b5e47ed4c066e889aa0d886307d3ee3d6187cfb3e66e7cd807f84ea04ac356a7991a14061fb42949a85c1f030e42774ef68859faaf443738db8b43137b68b0f790821a23352495b41ccd4fe8d45d064f1925b5a33d98671a72ef2aa42c38640bc2a513d682ea31da8c0eb6b8c3a6c29cfdc51735f93fe29dc8d950cb26c72e1df03311c91ddc1fc9af691c33f124c98476560caba8788b69697893ff6c56b1a43f4c272918ec95c7d9b434dad1456e819c2402c413ed61b4360891f9d7323996e0a30fcd1294f76c5f5351f0b574747d7ed20c72b9776185dcc351e5c6fb957abb8d02606eaf78251ecfd73e281fea0500f3adab08fbf62c11e7a14a0fda4278bbe4c280b961f28bd228992e8697db5eb93dd1dbcc9e262ca6574ec108602f09175becd98a3cd8a6f18c1cce2e506e6ce5c90bf4e3c3b694a2699c86c24692bf988f0337dbd1452a6f17b63c231ddd9e26068f1dff0c2db10d539184cb49c3bd53dcfa6a980fe0c96a6fbae2bb4a823decd5f8837000d92a0ec091427fb29eb693f27007167c93e9c13c7de50c5a168fc1ee39c13b156d031785cd67a5b69df5421b07838f03e81a99f0a7915e2e10fd3858b67674caa49cc80a8a416ec0ccbeb7e1f49d6e99f0ece0b1f0d2e123e7c63d6b76cc2a1500eac50cee720957424c22ada80888b722b12d0687371c0a8a0374e8446c231795185ff8feed01f8157c30698c7c9e1ad1171c08c52474a7971541ef278acd6c750516c25d52040430a0dbe0df5a19e510c143727ff84f8889ca01ed62e882af323a96b068366eec2fe3202cbc7c667cfdfc47aa145b29f110923393ec51d1ee213e98b7f422a36899213611ebe2c8dfc4dc785e411ad19b9f314869a72589d292069aa67ef3a1631fedace20e7e93e840c69f4323cab948cdb3128a6344b63fcbc47b0530fa0e312bd47a314a51ddbc49fa72f50e08b4a10bad00c77637d0c7f94f609df393daa92dc9fb49dbd840bc3e558a441d811b0ac1992893ea5855bf1fd57dc5ef3c6f1417ec04796868fe4bff4695f4d46841388a3a38a0221804c6d1ac106a3bd9ae57fb5f1179634336eefe6364e3f6769d2867d953aa7577cbe9fd6cd62b1c1141f39ae46c07be2cf624a01164e01706145fe48552b5665ae2f593f00eecb95d7a6036b81b4f77f923ef57a7151a24496a21b181e6569aa5d5bc5aea526ee5bc768b4a042ee241e0b73e65f081f3f7d2b6be32443168ae75979e8bef768706b09184b356028c4079c06dc4f8dae1d45f64641d7869186950d95223f9e7306bb328c8a62286a468249bc3c3c5aaa262ac8cc777f359962354b60afb0e559295a61fac38ab4a01de36cb2fc0e4c8ce052b22bf61fa540fbdd237d0d41a31d21efb126908b48952ad411006438ffcd37c94631b62b8f6136fe922718e5f41a148ccbd22c3dd18aa1187a444e545e7612366e9dbdc88c5b3160ef36972c50acece223135f187d5f5af41402be24e50e0dbaca773236ce8f34cc20c11ea432ebdc8968d5106600de0b2bd843a3bc25ba0a0593c1083d90c8271f1c9196c9c8c3515a3128a354dea6938e890876e585f116e06fba6a0d75ab59b059469e01d71cc1461b1e0abe984b3cb9ee931344bf49fede4a6449501292cb4cbd304c3b1bf7cd3c037a140c574cd4839b8c71e8438b7547e1c095edfef09846655059835ba8288b562ea3c171cec56901b96be0356d632c80a3127b23f401cf589510e0042fa03ad54c50eec9957685b398d1d75f59a5fcbfdfbb275c23004024f063160cd2b149bea3830746e8c84fb063eb22571515d633bc1f8a6e32652f76a4b0fb3a4913e09e4a0369b0669beebccfef763bdd7d485596a235b9716fd933a2e694393559931ab314f989b5cc890a5fbd04f5415a1f9a327ebe0e6bb01f90fc6b68808a8f65012ad96576f3b7928f87680eda9a270debacab099f53ee605093b732eeadb4478f5ebb3582badd445a36810db3f89bccc8b3fe06a89f7fdae3b5b2d6057f961c91dfdd8a25212dffb924c886e452d549bd920f94d30ec27caf6606fbee19ef50a0a55004f3495e52b97212767f7bc42a5aa0a89a98d983965cea0bedd8e278588ee53f0d3aed1d2aab7cd5bbd72749ae83f5e8c911d8e5c5263551aa213fc693d9c4958e70fdb2476282a4bae54fbba06588d6e8aea780fdfb6d0d559b3df41498989d3566e91733ec972d3e4f5967c445c77c9e66ba0446223f1850923d7c5133d3afeb017505983a3990d42b3f3e0995320c27a9868cf2f64bcf63d7bb10c851491fe26204b8c4084082030efdc4e38a40e8ae8567dc6ff19086b7732f79aee76fba0b80fc5bd6022dd13c4da78fd510315b9eab9fd941118da6d29983c96dc973e5ee056ee599c3afc7bcd889aab13dd5ca1a12cf91bb0c6c824f754fe3ab9a45f19c8be8da9f88ad45266a84ccbed531055e5e707223af020bc137afebb6a4e79b7587c837ee1ef721182e50e6dd61a8c3c229a30056fa75e21c074a227851e8781942849fafeb79e02ba8863bcfa5d78bd853473298eb4f828285d49b46a1593ee9de8a6cc245ef32704161d15994cab19b2ff4c9d80bf277dcd7e4c184832133bf8fa1fc587a6a607fcd7d6bf1acb94bf679975cf3071df5eb0027ee91dace12ae5923e8aef08bd78ce38425e27d0bd2e21a141ca66c97ef24c3fe17c63159b4df87d660349b881c8f87dc6510d10b2e2349bb32668b16762a077907281e06bd8d4d0b0c3acdd92a9df20c84f57bc1617626c640d28d049964edf97fb506ba659b6a643e8f605b888fae71c16a4e427623bbd7544aea2a15199fc4f69de459dcb15433f22598d6a3d903e82384acfc5e2d789f6b53043adc07dcacfb4051f6c6afa0d7f00fc5d2bf789f064691a3303253233f2d563af6882d1fdc72ccd330feb051389909e091dfe10406a88b92fed420eddecc48c6a4850f156845ce8e0771a1c42121384f90b95bbd3108fd9bf62dcca26b75d411bbb806b16a4573884ddd1e2d4f6da3dc2b1c67179361297c633b7c77c3f4d49090adda62b525adc19cdb756bdd1ff7edd1e9dc79db8f5441af64a507719762a4e6f0e550ee2b5e850a73d5b592c3e84c6db61ea947ad6e8c0a91ca1d6e3d47818fa6e0ba5af47cc86c36ee94eded5a3d4dcdf8db6f652e361944029ab6cb3378d2c22f7d0c62f2fe53fdffcd4c238d257bd5936642e7a905ded14e9f95929ab2c8f12f9c70bfcda5ec4b4e5b7999a08baf60a7e2a692295d47248a90c1f230caa489bc8edd60b4e364b49bda345e5a886cf527a8d3619711fd7b0b04901b68370d623bc7d1b995a87941e2c2798e4188b535895c3e5a2ec37f6277b470bd3c56290db66d9d6bcd2c848e3cb22869e0bc16ee4c9ffdf49fd292d0edc947a6bd8f10a62f5b956cc5e5fce840401c43164afcc1ae2d028854a15079d27d3c2d93dbdede31eb118c4a57cd1b8bd3ca03361879d1297da069166e77e3a8c899f4a2cf709623ecad329167b4aa67a758a61c4db11b4e9dc39f07f051a99e9758eef4a1486daf3ae5dab542aebee8c46dcb477d2516d6c35ee720884ddbad73c90e1ae5c95ada38e5ac06ff432ef2d92c5b865bb53265ea4768669ebfb3cfec5e42f30aab52c2a0551287bfc4a53b6bc8276c1b352f1a4bfdc3c0e2887ddefb7064a347541e383b34408942f95f1539ba69b007981161c0e6455cf907d368c9707e8759ecb1a145a2bbf3b77d7a68b9458bba7b6e3d29d6afadd6970dc6033ca889ad37427d3f2f7f7b4f4e3215e3b83c26aaee96245128c469e7abc58bf5ebde6aff3cbf30fb42be566ad2395e55dce2bfa6196b768ec023460250247c1574aaeb8776ec96b0cd258d54bc25c67ddf74a78d01db1d6987711d3c8a3a0368eed1f7f0b73c973dd891b6a1f30ed0a508296e507698446f35809712120de91a3dfb25fc83be95b9a4745ff596543a6c88c5a40da64445aae6d84498d79642705e801b15402852d60b86c24af664b29816f2bb7cf6a6ba96133ac253292c33477afa76011bf8afd50afc5a523dbef8bfff3f8c2399da448590360b764ebf866fe7f2f1c184ed02ce9b4be2ddb19e81c6e367f67e9054ec66f79b9ff303ae45c17ccafdef41d1aefdfb4d530210b19c8f2b11fdee5fdc355ff953127bfd382c376d005401f2b48cafca403c1f45672ce2cea11fefd846a9dc165784bb1c02a66cf3566d26cec565c2d5049ae8a09207a1ad99dfaf9110c122896d4e325821baa470a37de61febd45d6ae4090c036336e09f97bdc1a15c4158c11fe7c4a96581a865ac50f2e1c6631d402dc19af35e3460dddb3eff3aca6eed7c7cb50bc357b520379f42e5777bff1bf74ca304afdc77e1b3397605f9ab5953dd56f2c10f4c8e1ac850b93200d793e64ac9bc81ddbc920adea7b281113ca7e2dc9d0fa9837cb7eaba1ed512452e8a41264c34b34031284adee2092f0bd10060f933184558bfb8a6fc1dc433ebdafacff6ea213289b07f43e73986401c257051fe8288379332b04e6a6784ce8ca07a8b2ea545ccd481ad97f0a4540dcec4411f594932fcefc284475c99fb6c101ad8505c00e781aaf948b5a794c4e49782762fdf86a62e3948f463e6813d792ced74c1cc02074aa2fe88d5f529ec2026490d281f19682df573ee4a3af34c06f051377665b371000a34368b8fadcf2df291a224732895247ecdbdd781fc9ef783c2a6c1b225b4dec155d81117285622d7ebad3821024f9071e8a2b8c7900e24f35b59ad9c6260bf63142793ec338176be87846fe8d5a5ea6b113d45aead19cab75d16b6870c65b7da007ec12a028d10cf66bfa1b690ff46dcfcb722b951a7eca75d7ab66329e561e303145b769b68f0cddd6c26eaa2e225fc4d62ef6f03f79870950641a788807a61f740742873becd36d70ba17ead7eda4d8dcd5a628cc3e44a65fec9ca06e6f6fb7171edb6cec6163c3281ae77ff7e289b702b57fc23949b7789c48cc4e1fa64d0f5ed926e0c3a8d78a1fb6ee84a81e77d99d901271e11464dbd78d3b02c5d7287131e26604adbed06df11ca3cccf9cfdd9ea0acf50f1546fb1baa8997715c9591ca59d27f0c3d4c0683b052ea902ee88bd2936d4a2d47379417c0e4cd232a4adb90660495f06b2b26f2f45ec0f2ace43eec626ce3a0ac4d6ccc578ebdf131c6afe28670130cba6e111c6a6afc0bdccb9c4400f797ab76a17b934241f4bd36f4de5f8ded29af6d5318d192af5d1674a6d2fe152e2c5b8a36016c51aa1b13434f2bcd56683c61a4b57e72a9c9c33481833e10503d879e292c26dd9ab7b65d77e38d8c46b6020baf4b2e6583dc73e9ace3f33afac170b97a79e89c09a08ddfb44a1dfae67df83505738d6f1ea4a154aed2f5be7d83d863106e4e0a6883adb4a8978b6c61fe5cff2b61a7a2dd62df75ee917d25be7fec6245271c94fd7c9015552d83fc0c3f26a605c4e45c46bcfbdf7a23f8b68978a26cf02be27fda4a4a44d72e4673c814f0876e5a101cdd3e5b922865710c5b0e7242265bd24a3466a7f8a721e729a41b61282b83d6d59460d6a7ebdea0c203e522fba280f40497beed4ecda8acad5cc8c654f16dac3cbd189adda1949d4b852d2cc0451e41eb43a2d9aad555ac37d8517acab02d35b2f353ffc1d307402070fbd240ee22767d8c67c763f5db019920594f0c493fefed2733fef098afde92a291034bbd580cc33f4c91b399373303cf60086524259a067c7f95f431f4f678f55cbe9fe0945764e10d58b759af9fa103da9c617be520535a2437197336efa626d9566b5102ba076516e233871d6fd3ba453aba0387e1e3c5ca2400461ca28dcd42724af3dd3f3f629492eddb0588014207ccf1cde1009858beb1b8d6a5077aa26d223fde02c7d767c0d1e50456e461d50fea4376d79ea6eaa9320343b7ce30d771242b260fa5da5dfc4ae615d6378bc22a35cce3cc54764fba016276392c0ade2a1933ab2dd64466a5b43880498866ff8468383cc566520a9bcdcd66e610bc0bccbdff25ec38bc5c5aa41ff965abde82b0f060c338869f3668d79dbc79b97cfb8a52b43e9285db38a2df7d5630c5f155b985cf62d14d2094546eec597fe1dd15560f76d54c7f9f3241b9fbc9539349309fa77ed8dce862c049ebeb84a67a3d34b4f146ac0b2a8a53e1b5a2e752e2b257d2b7006bf69fc4055692e21cc25818e5d83ae8d4080b382db8b234263b4f6240287a571fb75d9f510b9ca80996ac8ad236a90c6f0918766714cf990d9dc4787bfde60dca14c37f23d2cd6ab3596ad6794b0cf49643bc36edd0c56b57c793ed516e019cddadcacadaa9cfd224354f91519ce55e7bb4e23ffab233fd49af5dccdd0bfbedb3bc7e7c9f218168499e0b33060ccfb5865b7fe47534fd423fcbffd0622fa574d17c82775208748487413940696d2468ef926d21d644d3d019daebd3f5489abcac3770e59cc562f7e9db3e3a0bb0f6f3f932abcf4b47758925639eeff6b33a98d1a34a4b1ca68a09cc21904713c9c6c974b2a7694e74ca09e0f88a6a1ea1c6dc9ad6aa94e0f16804b9917006fc21bb2aa054153c8a37a19e87f5bb1840e6846384c9a89d0fddcc5b5717157a72f4f53823d5c2eb3a0bcded1526eb6bc83d731b5084cefa5fcd07ed5791d9cc22216efa0a5994cbdd305768a98de5e267577a4e09b52d194a6df944d40b0a4eb49fd3976715b09d63afe7afc49e657ee04a961b47814301c47375b9f49bbe3e679806183cf30cddfd79e8048e82f470e3602295eea14715b209e2bd3fd1d8d6e10592f8acea1ebf8fd5b7d3174fe1be7c4b0bf75afbc2b9e837df3dd84277c565c2ea8437fa298a39d2faccddf3850706b15961bf99a2cd61135d93e100fa45781ef016f95257c8620cf9951d4e351052334f178878e3f9a95a1763ae0f857a08c6b98f9b6e76b251b7669c741497342a89e11e5681414ea5a85974fe812853838468e1ea4027dd3ec8bcaf0eb63a33dea653ffb1add641c1f40ecc73032572b4aec91f935f2db3850e84f33dfb088f73f05af31d3b2c1e3407fc310b188e6134432ee787a1ec260cb186de36d7cc93fbe7cabf8e5cf7873ff01837fb2d56f6b8fea67f38733268e155caf034d293274229fb3ff7dbf33f77abe6d7e31c0de9f94f5980dfed393839d86c5f52fa9296825b0290bb127e22f33706a6f877f7b97a3b5bd277ec1df523e2d2b45392b18efd6f1c0154cda30a5dd2b304a9f926fa4cb15b7a5ece9dcdaef9c8fdfc446ab570553d810da7cd133ffbb79e5520a7704d850e7f6937bd795b58121c2de8760023036a163725eb12e3cae4e7c16ab1bde50a47200819e57958c7f79015bf7265ce44511ed17c1e80f9fc58780a38f8a9819f7b8a6bec20449981c512439938d51c30f8130852c42aeb85cc92dfd4bc7a6a431c6ef4c9d98ea398b954fec0e8ada3b97b654c1bb04b70f84b1ee80cdfb4bfb4c7d5f8b30cef15b3595ae58d67c8367025eb59eee882cf34798b2fa4df87054fa911a3290812c41411241526171836b0501df97baac5667411ae6cb48e2020f7286f4b2dc5addb08f6287d797d8abaac284da0c534fbe53b00a189ab71617dd13cc6a2672491042abf9bde5e8888ceb626145e0edcc5a1fe83bdb7dffbfafbbe7c2d4dd225cd1762024f36bdc9f316a9862fe755ccceeac2e74c5de127921ef93742f91ad725045c4f2f83504ed747424491e4d464d6cc3a29b9ef1939047cacbcf788868fc87ce5e9c4ffb11f6031ed6d518e9befe16bc8b28c45d1e42a03f8e54955eca14d2fbb9c020116775f160529c27f32ab31d6bfb6f5afd32ded45336b747cb9b73c3025fe129e1d472524e41a6c16cf842f18cd6845c6007cf6633357a8e949e0e23e62ac48b9aaa378e7e117929d8c0a71992914b6f73a0858458093dd315307f195f1b24ae1985ce68052e39546e39b031abe043dbf435ce8fb84bd35d471523b7d36dc0cb88bab68ef2b71c09b3dc75bf9a2b754bee815417384199a82b89345faa81d560ef3cfa1bed14a25200659ebf6f460b7d9405893760b6eb5a7c4d80ef35cbb25c0bfb7a55464ada4f2621f60fc13cc25db8fd0e287c9ffab257146bbfe9e58e2754d5230956c27302492bad0b4e77631a9f0e0099cd27116b415ee241081445cc55f821c957cf5ddc70e4e30cc1cffd16c9f6313f2a2672d27c2f96d1c2692a27ec380ce437eb3dccdd0a67a8e88c989918d2e8b0642ff566d63a7e544c7fd5f25755182854e745d3f2836f297eae4adb59fbdc65d029ab6a4bd1b45b3b5a74598fac7474466d4e2b55651795e942909fec4718076a913e5c0cc023d8a9ba1e8cc84daae66d0f9cf754b7ef277b5b663d04370ebd36748288551b5af9e44358ca346261c342a76ed2965bf1d393868347855287c5bb401931d959ca38ba16a2aa720a745128c0a2db5724b992ef495f6da454d1cec2ede4438a93b33123927a8a52079525bb736c9d39806ed625301701b234d599e862271fb55b30b2e5b03d3157590cb3ae2e55fffe096f3329a96e5b06a8e15585f21a30309b9e567439ce7f7ac274a0d79a5ec813a0c074c9c19684715a84485a2b1dec52704849f2b426eae64a10f141d220b45d561eb7946ceb27e21292e0fb80aa2f8f7a2c6fa1bd1b2afcf7f632386e558cc4539355919c11b6eb9a21c890e0d24a20ee533aaa4d9114906c08f00e1b38bafd8d4e70668d956332260eec2bdd37a215298480cfe07f261e290ad8c7016a4df42268d2abb810e97f1d907104453f2bfaea0fe75f78102e569ad35c1de097ec15b78268e85f954366b858b0544ef0b96e600a602119728a5cdb21b314950804c22a1d153a28c982c32e26fb8b8b8a62f1486ec47739139416f43707d40d31f585c32b23a6cce6ee8c58284118dfb1255d2297fd0d573b6d27fe75cef9122b80a0a4488f88473877633380d85eb06091257f9f73317b6d730df611788c12a902b2ed8753717a20b2d830d046adecb94d1cc649298497b65c52b06128408f4a6c48c27e4f19d07337a7befed5d593bcb5096d783287df5811189dffba95cca52bf83043d7ecfd63690a6f5efcb039589c4324413f93310d055174e92cbe3d69f2adb729654b310ca6e19312ba42ace7d8d5a6e32a8b4afbe379188e6588ddc2c3762d799fdd2205d9a588ea9e80b44f5d4a56c12c6a89af56ba9cce11f655c71466b13c26dcca0090ab996e8042fb256afb9d23631395409956a0906311b244e63df27902e8b317674700d59343818c08242e07f2544a76175c10c5c93fb87004475dda6be8eb706b4a67f6b6773970ca5997be2bba5f697338a0a82e52722fbdcb009b938ce1ca4a4bb66bacaa09fd79aa49c987f5a59a9dc1c77d321f2475ad6c36abe2e58479b940b374aaec58547c22cef575d1568297b6bb9bfee6f3083ebfac181b4c3c3843fc742a38e37881f7cea6657b16bbf0a67bb84bfb1b08634211245f43a05da96c896bc62be5b69ba168226782b1e9a3ab95da148aff7f57e7346a71bb2c578527e62b04ad73bd68bb245a794fb6b2c7486d542ca4abc04cdba03d17741a5d1bb6ff15ca01a4354b286aa8f4f8039f49eed0405f15d9bba3022cb4f60f7b61cf8ce1b3610c7618f220a77879824334f0aa8c347d538776d3649d3bf60204ca284d85dc88c7cc354b23b07d7bc113fc304f918b8f34c4c829a8cda54745c9729d477cadab439a7ef333c3b5c5b86fa5185e269228370e4e26845d405e5c4007f7b90dc817feb4502b7035d8dca852f9b7640c096bdaee51bf560a07ac89cd2b8df0473c5f0d83a8fa831e8a64cdff0a5cf6067e71fed1c3935861dc9c70ec1eb61d092178814791fb69f1bce6868af4ea8ba91578812ccab8e9db6b2ab03a91d3d6a9cd439899589c07d25d5d7bda01955ccebf3b9f9ec38b87b34e4769ef64294042d4657489fd03a3dfb23e600665a238322234b11a4d91b1a6c0434910608c6101b1e3b755d45548dde439f39323e622ff07546cb24777c436a40e7a902a69e2976834d34601a3b641888c09c21fd2cc7bb45a71dc2f7f67d999e303f420354bac2129e823434608b17b62a10a0ecbdacb15a489a114373bbcbf546b4011982c544a5577c6cdd1b77bc74b28080cc118e9cd46629f4522bbf58fad75599795ad6f7dae5368039cfb1ff5882db2b943d7521ab1a1039ccb19d5dcf4d50dc9f3c9722644b0239c981bb01b1c81e99e5a47d2819a9414ecba25301f2f3352ecb340c7054d1a78789f27fd9096bc9d54b3019b1bd7cc8755e063c13508747ba527e332199847c8d77563da0f8901b1ae59da1f9a53683154cb0a7359da26d703dd9c7b36017392b7400af7028246377f92c8f6d856e74aecce0d6067f1f2fd155266b89efcee29434c3c7794db0c987f9818dea637c5a3f1fafc7d4538554794508a4ec9e11b31ea11f367077c469c6e06c4e3171888953adb97a6881cef2b9982dfed63d74470b7943306fa0ff07691048284a3e883bb5e98027514c419580fa474241f3c3a385a24be31efc3f0bd8b12817cff8d4b6142d6742148fa3b0922684062270fb838bff826afa1660bdc54b98d01d564a699641b741a6b71ceb494935e71eacd190d9a73e5f3fd688a152861617f0c4e966a5de977f5be09b94d44f686b315d0672a542ce86d753307936ea61b9333553a495f0900b3ba421d2e9657a1921e1cad9172df215e2be8c2b2667c6ad96bdb5bac79134d5c45bb6514bf387f130e7064c62a9f48375e29f2f878996dc4c497caaafdcf1fb9c4045cf888b248382ca215f826ed06884c4bddd69932643c6360af3087347c25b2d9e49c918babb37031cf3d53051168786021dafc3858a35938aa2139e0325901aea02dbd2f5805cd7b1d431b708f701f1551705d96dbff806929f565adbd646b38798ef1f61e6032fcc51db0bdcec0aa4a6b4ffe3f064df292e350f8dbd7ccc9824f7d2d4a4a8406bf23f1b354b865cd12acfb63202782f77b2136ce0e838d013aff2028cb88c17dfc54f62c6461ab9f1097f80641eb9e842a6994b7b419636e56125305281b5332c76b47b0c8bad9b39986b768d37e7ae7ee77f56aaa95556f507a05fdc17cc8f51fefa3729658a295e8aa82cc8bc0e19e9a4a3bd2617a1b292aef660e13b8596ee74b4aa4586da6c2ddcb03afaf0c5dd19de9e1825496b29cc266ce79f8f6ff9050695d37aa3a32b463eda5ac07e3f444ddeb6ad228dc72a2663924421a44b773380be09a51279991566fc25a9ce50259ddf2f63ebb1334167fbca80ff4153f6a6a42b12971853b8be38bea200fdc95717f14c9ede1d73a602180680abfc93e96b75b65db68af9e8128d6ec5e1f613170514ef630133c616e8d4b28d0e93959fbae66115c8a8ff87862334e892d13321f8aa705d60a60c8a0654743a4c0776510c34146c69213abe287d6a9ceb289891ccc01577475b3444d819ee099878073147063dc2601e402026cc97414cff51a7ae1ea9aed8cf84880053a56141029904f4f1db4960fa831045521ccfca5196f4d40995f0dcba0e0272c2771e956a33e104743761a4f27feb5251c6a24c5e6183d9f09c085b5e1054403c9a8255ac8de55c2d76c802d5898c43dc3988a132c08b469988bc6652136cdbc765cbe722440ffc88b4a7d18dde01a74264a4e1e56de5e62cbf99627dc4b70649fe61e810f604ca782f4956a54c0af6da7eb3b1b83013914162936a96263206d60108762f4191850940f3fd5194ce14c852449fa6bed8f8d0591f0168e99a5ae19603b19ab11a5f737b5cb6e956e0cd15301f06104d30a24f589106318e6ea26a27c30feb9a190fa5a11c1ba4166887bafaf43e4ea749e5d7e488afbc9c03536ce9b8dedce3d086178bd12c536d354a13e352fa4e2815b94ac3d9cd535429b1138af5cd52a50f0f4f12abc2ba9e2e98ac7e549e01f2d93b610d6ec237618feb16e7a686425e6493bc3a6e9dbdb89d3e0885d82df439e1103cd26d310212633500f3fd145ecb880718b75c1ef217bdcb63fa8d8c3c1945ba7fcfe567399de5afdfd636c25c2042892f33c681aa75d1975f66d1ecb7bdb58dec1dfadfd211e2b2831d1264103c792413d36663fcf230be582ee7831c683b4e9a69a5b2fef8dc4a9da52b47c11263e1386703a1eaee47d5838b8773ef12d63c5844ea21a356a66d2824039c8cd598defd9bdc364c300e7567b8e14e7abc5583b8d76d106416aca14c29878bb3d7acc803d60c0df50f3b509b773aef9fdb5ba936979201fb9d56453db58659442428d1183f899d985c01260c3aa4e5326b6fcb2a2ea2de14a89c154d25e3822cc7f674131e91944dc89702f7600bf218510f2791bfd045923af8b53253fe626038e7248bd1ef8a0956a78af8d49c24072ae32a66664a85ec95737814bbde4cbfaecc0b71f0a752d6117638ec093eec252b5b08d5d513fada083148d702665224564501ae6a331b4d574cf95a9539688d35fba7be3a46d8694deb1661d8a55a2ea7e441392ca4cded2667da5820faeec309b12469163690b3ca9c8523da7a81eda4db1bb5dbacf1af3f2ac40b74586719aaa0f60fa112be6b46b66b0380cdd57fe4ec3fe9ed3b52c0ac2e6d5bb44f77b5b6203a59915fc2e17469053214c2f75","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
