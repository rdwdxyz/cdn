<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"618b5137b981ac1a8f349029e1bad849f00132c688adc2f485064c5e635be39303ce7554b9b22259808c178fee23c67fc2197cda477f3589c02fc91e89f9bec76944f51300f31d91d5d8ad6344525e302dd4fea7d5cfd7c296a65d2fc99bafd5b48da7b08fbfa535a01bb3131ce0cd2c5633b7816b62f1ffc4a4448e605e2e6e73dceb482b39f016b8f32d69db962173d0348a4874c70c0bc092b2b9ade2110f161c7433ce7e5f8f6b8f95539f1398ef70fbff4f8c0cd23efb611ab1ee1b1bb3b4a2d98dca5aa4c9558e1147e213062515fb83722f8438c0ec8dac300b85e847bfda6b56f2fd23eac3dc6bb748999202adb76687afa08be887eb0e5d37a27fabe92b0ef1ed8875c3fd3afcf334d6033d8f99574af4695de8c66908bf549f7568d7b7485f86e95ea96a6edde1647014f19cbf02dec304a9b4f9b462111c2c0dad54c995a04ffede234965ac17b159a9d700529244878590f9c437c535f865a0e6c06d9b60e685d320a16ec777500d0760c67705fe5cc9fdf1ca7272d1b6109a44757c1c6c05ec7c846f067462a70f8a46b52b769973ff1d4c6c5a477d7e03843665189b8dd6c0a04504de81b2644fd6eb74b5d1215967ebff7dce830302075b0483fabdde3f2e8f302d2d2964a0acd55da6b0d00b80f522828f7c9e09c047ee659c00f034a50fbc1d46104114748c83d5b95bca8441deddc0e3dab37087c8be3c728e3edd3e1597a06fcca18997fc5878cccc93b06dcdefa9c6e3cc2ff19bf561f8b7d9cc44e4a5d26df3492c9302d30b82964f1f8ce6731029419abaa50d5c200c4047d27b0d6519c5fbb94d88c4501bdcf4df11e7453c0d95e890567b7fa8b68aae1b58e84ef5dcf39c81e703f4d404ed3b59290a3aa138f3b5564979b2e4c90790b7619b99ec38e55490cc8756d141123f5234d9a541e9fc0d7315dfad5daf1b94d472b494b2df5694f89c593108b76716d10e6a2bb136723b4ca4c4412aed5fe184bc7ee4d95ac604883d46c55cad0a797d6b5366c3ecbe2adb3a955be2a7b29f208332d0606dc0974b082f3c109b8b2cfc9ea5cc9f4bdc49e55c54969ec0eb72807f9bff0557cc24341b4b990f33cc3831286b459e69891abc7399df8685d960b631da6f34abc6332bba0ce3dfc9ae969b0288c63f8c0049f9d217772247c996f05d958fc531eb50a92743d85930f7428e10d038e7be4e7d0c7d03080a01d987f757b98a891323422486661bd3e0966b9c29f1da0d4b878da2e01bfbc5eb4799468227b2e8c791c65a2279812de7f4b925f646d12ba6dd05475ec496902475b182bdfb793742dd1fca35ac96cb6004f09ef3f9d58f0279b2382a40d81d6a2a988c238c8c0aeb64d22d8f74f06f49274c336a36d4287522a87c2ed23cdad375524944fcbae4dab8d6fdfe125e6259ad33b9a1238ea7774f1eb1971e79b9644eff597ee282544b25c957e6813310bbfe40fa56c16b6ba1ddbd075f6c9a4254d6dc0af214f3e50a1e84804285e77fabab2890695c4de4ad0de76379f2ae78768abf70e9a4e6a4269c7b62ef8df2649cbeb19052518e06cb5aa61de860910bb01d07d21c02e72195e4deda12edf7b3a71e9c271c43d9a2a61e3704ca523ed987ed06358124f44b4256b851aa4f47c74f20e3f4a54b3a5d1d3b5df7015a8f94c53bbce65b8dfb9da95c738d5ec32f8a2d6c514fac2efd71e53571912c7619f170e0c3e6b582adf2bae4e99567dd08d54c90cd20aabe4f9d0f04eb736aea454c7cbc078c19bc3407a8df9b4ad9f027af84f8d819d82798954ad3bd239a8859a84633fff4b2c466f186230ae68cecb3bba844e91931c35872c73eeb84f1fcba861627ad974ce8309454b7768915b808c199b6b458e4e262764f3755b60f947f1076e4329c127b85f23b6e174d648649f93822a4a45f93906d3110a504ee62fd2caaa68e6fb5c83f91f65b5255f73d669a44707f96fda8c6d2ac39bb372ddcb4f8eca8ed5a961258d6074618cb5b064afc8290317bc400f68dfee7ee2c87053b9edfe14bffc4120af8ddcf0d5733c50d0c0c06a7e1f9a1101d02f6c693f83acbdb06d70091d54f130d65f2c1ef3d8704781bb11397e7583ecd1efad1f223411b1166a21f1aa294a23b8aa4145435e92b866be8ce86b3b2572e2ba4734cac8444be0438ced90319922085c8abb0354a02dd3db2507f29f6545f53e82d8e4e00944acd14d41f26a1b9f32125eb987a157511a348c4b083392a08bbf9f36ea6a1d7ca39174ba73c1768c7355f63be299b9bb20ef9ba4f979420b10e924be90861f4df240b34d639ab95de7f089c1427f2a6f2c26fb12d196d0c4bd888ec0dc40c12449b940dd1373255a10d3719a8b29c82289af55c9827cecc06085fe1ec7b79ee9c92abfc0d99b23ee5434c150f7aa9699f00b9559ffdb5738b734dbe5e9c2d6e94bc77affe68283c91c019e08ca6d43b658164ad2fa02095b357fabd871927cd329160be6f5e0e317c702468dc4e3b842272d6ff39ac0ed30aaee23f9f331c4ae0b512b6fb57ba0e26f6a729fc81a620af21a43ac90999b5f57331568613526e50434eea2caa02bbca32a79aac0c9f1a281b3ac343464d99f66cd2dc9b978a84ea54dfd19e7672f2c2552579b05f83625cacf5d3c20cbadc911f09df128e02cd3656c9536327f3a8a624273831dbfe19b7bf1ee71692f6dae8414da9b65180fbe0faa1c273d88ed007061c2021a9badae4fdc1f72c89201dca38d73e787d52058d78455a046406b438166b15affacc03fc376a1d46ec93a7863367ba4c204297de614dba82189e5f8230f29fb233c2b9eb3f6279a898088ced32075ce833f453984c520b56e5bd3a5ec6db8e7b14d09b5f35b6664f4a80b5ee4d2ab546ba0963d1430c717d1ce19575ae7f8f636a247a7ba6a39992c93153d3f9766d08bfe04c6a2e6cddc71b39539f8b960cd2aa66e91626f00316261ab5c692aa511fa06cb2afbbba2916f344ccb3092743f14f4d5098c88577a2b752022fe5b44a74cea4718a1907ecf111ef7cc40c32bcca45db5c9f9280b6ce8ffcc538f7c339aa05fb80776d69001a95f8466d01674610c36035fa012a68dbd0072670c88cd931b2f6a68275ec7fa9ca5cb22a7651e81975b8f4082b991c540fff20a58109e941893705f3f1f9e69bca38c881740853461ccbf1eed9e7316612b9c65c720f29adcbb016fb4f348d238ef182cd37a65683141626c40f42c0412baaab91151fd8fe81b14d050a9fd82a3a82eff21460b05bd6037282fc6d163f77093e3984b9ddc231516c019fc140ebcb172de814a9f1f275c6e5ee8913be1f02a12466982217213b0f175f3371027d4039bec6d069d9a539f2e3445e3535b99bf29e07b2bc780d0d7466e84ceb2b12b324bb2a1fae6d4632485292ffe2dd1d9d6ff12842c5f89e6df2a7b0de3770f632c3449d99c173380828c9dd41898ba27cbfe9fe752495a5c422572c13182ac557ab8145c93bdf3e7338b257da04688bfc3f6d0e5664fda95aa110947459deaaf347b9619c32e7aaf779dc82013d78455d6749d95e44738500d329524daad9dc28419168e5fce3c901885874b9cb5f0a702de1f58bc9b9c74884dbd0f3f4fa2ec18d357dc436632069ac6d55466a55ba880d320bd4f9b4c259655135276b962bbf2d9ddf145f714acf4040673d8590a425ae78489915889ac32259dd31b3519e04d971ac7d092bf146855ea2a1d74adc8206674c265235a2fd292f87a718c08d7239b2ed2918218483479488aad3e5639a35ef23a5e1b44707af02892bed33b19e30f1b4ea39cc1d4adf1db113665f6d0d43d882e9592369b08b86a1c5d71a96a21ef6faa43fb79066984fbd93dded65099c44633b3961727d85e17cbcf5572b66c143d55bb5c8e3485bdc7a0e509607f1c62fa29fcf21525e86351318183b00245ec5fa7a075d4e61228a23a7a226dcdbb9c74a5e201507fe4ccddbf5470b8575289cf714ce8a427975ed2212974399a82a1e628c9f4b00b675c13d8f888f3cbf5b3b0a9ace75aa5caa474deada5a1579b5d1f1ee5946040448cadc07c3ea41e8165b7ccfdcf9c1008e80e33323e929987c7e70c4217411d279f5c768420fcec4518f66f831979031bd02fd95de794d9f7d1e60ff52fd5c894a21cab28f4321f6d8aa5bde2bf3b9e01b1986c6634579a960954e5112b0724d40dd206ba352ee1b72d73b35b98b02d460040b8aa49a2c78a43047fa5762addb01b06e2bfa23fd14687841d823849c71fbfd42145b792c64f803f5f7fabd97d01dd662b7968981e7626fef56be205b472670ac751fa058c3803e1aec5dd8f7b18e724216c7cfe411362249821ae8370f17d2fe1f40c841ad0d1f6ce2442d97ff285cdd55e5a2c27ef99f4a129c8e94d9cefaf3b809a5508a34ad7b7772f721f56b5a98507f8128fa816f657c9bad9b20e61e0f2d157c7d31cd4c369372563ade7bd66ab9c4103801e468be3833ad09b7ec3abed5c5d9350b6b8578bef864fd27b850964114173800d1b4cb6e994049f546fd988a55d79c49bcfe165e163c5c02d7aa00c371faac00bb775be0e5bab953ef62249676eb153ce000ebd2d49aec824467cdd2b4194721176fd61b226011ffdbb7cbaec55b4dcda2b67209161422a2ced29e2dba433a35369a362b39d97baf0773ac2a9c3a8a4279a3b04f6fc99fc142c62f9b05b2ac54f6a97a16aff94b2360d0700022ae92d262637895643cbb4b7459d695ef3d3ed4b5f17d18677e22129b208f425153fdb1b0062a59d235af6cbe0213f6dd2af8c7b294fb28fbf454d3b0a3b1149a3d23ee28db6805751dc49f16f35d5c397d8680dc3f0ab35e576754aa45756696c96c4b814f91fab98a1fc8d46d6cca949947fa6c823d84a3b48687ae9de2a5d67220cfe6848aab31ca771cf7abd6177b917e2d478ca2ec5193db4b99e040760e6b7fc933859bddab5f025ead7dca60f4a186977335f42b061d0e3af9cdcfcfb8a86fee18e4fc7883b6492bb41dc26d25d582fe4c032bd2d40082268b3f930ddf09e56e12be9139015e58463266709b3be475e2a32579b3b0930f3eca9025a1b91d131add389a98979f5f10eba4fb6fc60fc9145a3d269cb72136a5a872204d9875f0fa5dfe0fc20fd3599d34b255838e13b16281e1d3c9b0a5a85835df8fd788771ef7e6e16d7d3360ed2d3028e26435013ace854cd31dfe7b2e8bff5263d44feca57b0555dd511c64fcc3f8a4435ef79d351b66b1e4bf71ef05a561d43e53a0bec5a04ffd4cb8474a5aaf237d266ea73fb865c0392342325394c19d45d28a206b3f522f5e2c8ac03afe407a296c51b03234e9a6b562c4859ab8ddd1e46d42bfeb981d7d69455bd23102e686bee9f9dddb7af701cc6c6b31a6122de5beef48cf6f511d639bbaaaca629295a65a1048c87f00e446d7a4cbc268a939ddce9ddf8de3e00bbfa0c8cd58ad0577649c134c6a54e57172faafe773ed70da0010b7efbe404eab75bab5f39b4efe80e9fe6bb00c7c390912256296ab81cf38dda893b2683c20bb73c50ed7b6d9ef6327870a8d9f1b7ba956ab5d9e214266ad7b09be3360661b13e5c13c1fa0b361d30c51d5fb983d10a86a471469155d1fa17bd70c3bd4ad5dcf2b7d1b2161cdf43a87f48f43105155a26a5be8979d183c1fd694c87d4acc3ce5080f66a52397f22f15396ab94f24674f4e08f13a20d0e121d21647ad9e122bc4e60e8fc2d42a02f33aff04422bab2596804fbe97146eaae8a1f5c837299b9cb8161c914f94884006c136576c3888d079af3c2deac569671fac85fb2b5655c15e83ea8cfdc11be7d4e7a4f1c13a4822af6bc9f9143d5f75a9f14dab2b4ffa7032d6d1e5d6af0658318dd89afc7af28dd57174bff31c5af70a9e7ce473f73a5bbcb65c68919a3686b43189ffa6567506e037b26d1ce847d5c5233d8e0325b0a0c2ba209167bc334f4fc5ee2ca372f4deb030caafcc42dadd8a1309facfa8221fba2e4258253ca2b1a410fbe081625edeac4fc1c5e67049a3f2453485c999cb169ae11640bc5769dbbb1f5492a531c05c22bba34621182ecb885db445480af2997225ee04568fa259c8f3d658011389601195af0a6697e35dcc59cc39edba0aef1ae52f835e240d28c66f56737f96d5fa863c0382558e03017484c17ffb0d19057d10ba22751c8c0a980071f7f54270c03fc0d8718e6f8b30d23021ddfaa6e219e0d35e7ef70eb2aa79b0dfb3c51c830d33b8b6fe07bda21ce612353753a25d5de15df76e7cc7bc18635722d26f24300351f557707b914008960f61c7125806fd2553dae0ad8cd6a947050945a23310b390573cef60426db642ea8db8492d6155405a02b8bda245d636a689482ee53a76167801ccde24004896a84a55e0cdbae27ccb40f617210627eb259f004da7a842411063ac2544efd3f5d02cdd05ab6c7af16c1d8fe6d50a9e0e57cd09f4931455f086f037127b9e484dd3f576620657e039fb029e68a437335dfdca60ae12553838b193b3ad49b962f9ee2ef0378054f217c23617cf365d737e3f10c55921a2336f393efabd824b579356d5197b2208d653463866c02383d1cbfc853483b73e74c778fd52e4a4c22c1c5f2dc3b769b1a7920b93611759ac2af977d992a2b65421f91bfbf4b78eb598a5c35e3989fbe97d601fdc909ad31b3716d317a93637f0455cdde2e6dd56e1afad35a770f5d43099019b3505bec179daa77db1b376e5bd4b84184ddedb9bc64865703ba1e1f94cb7a0737af957dfdc5e4af34afb8ea48adf4fa97159a3e862aa6bf0e4b1bd46e18991bf26c78f3a1d95764820dc57f1722e5565352a7b16679b68370d257490b2d38b2251917324fee3fa3ed2c8bbdcd9fafd2f028a081cbeb431e7d9825fc69f0d064ecc50af8c50b583f62531bea85863a4193f8d6777a999e7e6dd7e84a57bdb3e574dc03c1b0c6cd986581b1dc007c8e3edd829ea2e69dd533fdf49de22209871e1dce9c236789acd8f5ab04162ee900197fd1cb2662a80c35eea107cbbd157e6dcb5cc1cfae740c1aeece8823606a27a83f424c02cf611fdc5831dc2270cdc8d643a7ab8c40493aae9799780a377bc0de7420d711ebe93a7de2fb7819794cdd398b50e2803c2dfe24e5153d69be1dd24694a18ad12278812d97df35a2bbb581e7965944ab1cf581b80688cd1df9980b857883eb0c7858a1d244c957de06494af61d4f02c96b70f3ea517ac48546cbe35681408618f2a7f024502c03280d745d76dcd8ea5fab430b747dc7dedc86b4285c084deff92cfb0c24b6e93a555e74a8884e682bff49fbb2bdcd9bbb7fba517e9cc9dd59a41aa11bd7b23744f07be180a08f2a8cc5542d3983d85570ad22748c6b85d6d53bfd9393ac0b4eb162ffd57cebb12087fd0bfbc54cca5550dcd2ff150550f20217e63a65733dbdd8c051b05a2f70374c20092b60e39658e37e7bd3b14ceaaa1ced0083101f17c95022396728ea2b0e337237766766e6f8c6ea6f28f22da695e3f9a176e06c0fd79fcf263e902d84806a1c5025d313c00bc4ecbd9d3148c0fb152870e7fe364fa913f91ca831daaac0c0622198cdec5141ab8d5205d6811c5db948a78f91ad1b89094c39b557694cb3ae344cc5acde199ec60cf58dc72b6ed44197583873073d1eb661db52ee76560f041eb2f63cf3a9f3fa961c9d18cd94f3f4556494f55b136c4dd02a02e357e5826f7b3c2315a2ba1e33bba4c37727e1dc8702ebc0808d13c31cbccc1100f11a3507cb29d8d2c16a8977929ef46eb15e5603771f200eaf1829b6037d95563e82cd2eb824fe18a2d2aa155d9485a6dddb48298a183847947df4162062cce57d3d6d9e1704d1339d56990ecadf72a6ad89047261e18b1219b64426214743ac8c115cf45d4e1c96792193a7a8f5762b471a4694ec898e02e646d1b028c554c8a3e5db424318877c875d8edd7b67007a876c1310f24bb63437bfc31bcc6857095918c9916b66c766e8e3cd43a2a97bf453a55b6abac49b96ca6be96370f92654a888e95ae1a4bc9109e99175b5f28ca8f30d19131414a160bcd00a3fe93929ee44cd910684005fec42e4c7efe28d51f78b36fb71e423f855df9f1e835770f7dd417ae8a1073b7bb70035d4390e197f0550f1543ad037863d936f1377813d6ea9d5a5034bdb1f67c2251e7b0a6c00bcd2be80b802e6676d78299ab16b7346cc0e5112d458bf9bd4828467ea6c57a2bf6734ecaa28d7f0696acb116bce2e3ffe209cda514aefbff8ebc8fe305a05ae7744bd8af8456e26ebf361d17d127d8bc8a766a88237562007f50f4dbea2db13849f2c93adef1899e3b9763f8b2805167bbcd6a29693327438be8e6b214f0d0cfe51b539071361e4f93e51d8052d9dc922dc5eb8153f4998560ef847f4bb564e64fbb45aa6ac0ec1cdd985c64103724167ffcda31e19bfe3c43c87f8222a59fbe97c1f7838b10a3fb57927e3f2ec902bbd66c3f80ae5b1e69e1b16145d8f607ceee9d95a1ee300a3a224b48f29fb515323fb3fdcff56f4e35c6ddd8f4afe4f37550074c533ce254d85704898d31dee05886de8c43c6b7e6c9690861cee59ec2c0a1824280500291e1a2677cbf99e391b8564dbc7c4fd4ee0c57ca275f1bb5f55eadeae450f294efe89a24552bdc310d72405a7138a59437cf2f0743c36189ef7c2e7ff02d00c980bd7c237c6b59e9b8f834c051a11e10702915556ea27027becb83a23a329c1ebae340e4a0418dd4377b9796d9b7ff9010b42472e629c43ed4817306b9709849ad812c0645007d5aa51d32d41e535b77fdc8bdb9d12d8f48390a9d24937ccb2cac99865918197156b13ff93a872d2372b00087377705e904b9194454ed6a743a84172f39aa967ab16e7805ee4847417ff74a2c9a6fa0caabcfaab4edf3ce53842d8021b320d82c5ad9afdbb4b731a9c9ccaf423391062361a1552393f80df435c385eb2ebdd9283c8db0650280af4cbf93851ceff3d00069feb40d16b17f78574e938390e5ead613577cdf2d6c79166832fb0c318b6887b222ea33e4cc18c2b8e0483698358b93a5b9e24ed3af2826b61aeacb7526aef063259b6da9e1603973aef97c3bde4b35100dccba2355a67f3dddcb27d010db44da4f8dc8d59ed3f9234e1e0a9ddd670e8fb1af23f9c1235da199d1de01607b01b2883c835aced477c970111fcbfc0b36bacc794fde2c08f1b5c66d418cd2ae49db47059730f32a0b570e8785a5db60a9bbd4d7107415411adf15f3812813d88c1c1039d02273f5e9e10a370a41f86c9a42945980c8a00fe4b0b3792b51af3e3d5649996a3a9321cbe36294ef8ee0872ac841d707bcc0a145c7a837c8a0d4e21db722de42e61900bb1e1fd0952bdaf15ddaed16a4b3fba746593af7e02eb49bac5bc86028e33a90c2330fa2e20d1b64734418940171ce5683913ff5827f82af30e0849be361b5890cf86504f91dfe969785ad00edfe4cb1d2d7478cc4e874239a13e7348d5e6698f2bd94dca762de1a57c40d2d1ab96b87c6036547a17ceadfd23b7310c40833bf2c40d503e38089d7dd89998f464fe573dda2cd51faee558d9e28286560716101d8f81137e208ce654043b20af7c31c2e4d9f1f1d975c9927b3ede9ad20fc29df60d4b14a01a153cb4eca1d67124d2f1a78621f2461b451943afbdb645ca7cb2868351afa50414deb01bed98003d3612af5a684e2453630ceb56402e3c2ef7c56a9c452722b7bb3f5b1a740d8fca12e9eb61356b9491fc788aa7813b735999395e83b2bf97587379791299c71564ca1aa5e783a6378b36c2c3f81b9e73981147cb473f816a8c3f0ade34a338c62c3eb8635a0a71325dae6344db554b387557d566b060711af65891206ea488f5311dceaa326b8a028cf0c03d239b2767e3356f6b687828e9eda0278a9476ecd7c9ef252b543f08da7f8e61bdde5b297a1715faff90e152e7e189a4c593f3aaf613a1cd58e07792e58041fc51e17a7a9e4cbab425c546e7d7eeb79616b91b1b845b82c5db069229525447011cf6b41f8d9cf9eadb9f2001af9acccb34231e8fe48f6b13c29476af4b6b2179ac472aee2fb50153362697fac6ce5a21da81719c9089e2421465a6275445ed6f6d3b449129b658021adf356f74fff39647a0889ce2ea85aa1a3d00ae795df92824ec3ddd5789cfa03793075b788eab10858643570a13be4ea20cfbe9f70fcb5058a0e5efff2d58762c59765e673a081a588669220d69603a304572cc1c7b28aa0aad39e34637d7ad72d8774a3bf0066a748f250b8ce74c6553acd8adb1efc65d9422ecf6369d6b79080b66da4314f86c1adb9d53270f01cb9e834d74d8cf172de910d973b98b4d78bd2d1a925b282038b4061cf750c7e4543cdfdcd961c73c23f99077e7cbf4967ab7a187c8c508d9fdcd9ab14323fca27c3cd8365ca08f1fee4b1b9fcaa498ea36c5c1df640af761c5e3b360a4ee9b01b44bfcdc6c2461f649bda7b035d0db1f03bd0b8b1bb6d7e86cdce47075da5a9cfbfc06e12768976d7374f5f0bda8fa138e52a93e600da3754e5beb8ecb0a6eac4fada1f7e319083c2d4fb2d3051c0d188a918b21e238c1d0c123e9c76089d0edaeb9c0ca8f43efe41f850ee9388e5bfd3bf81dad5bf108223d6f0c910b2ccfa93dd7a798aac5379f46b3a3fc3dbbfbabc1e0119879dd76a19e65af90cee1d052a16766e12382afd1665a7595cd182a40ddaebfc7afb2e1c18347fd66730f6f69f8851a0f350af1bd5fd7c6c2c4483300779a99c8929c4ad95e8f2a69d0c573fa74dfe57adaf385cf7469d6d6ef85f025e1ca41e329cb206a03ed2cff9dfd70a86a65423a8484c678e4ceeecb2be9749e126ebbf5afcfd8d59805f821f647fa7373bdac714768e4a165adff04786106721fc0d58cf7781d7c89a85db8229323852cd90cc64f89cb11bee756452412e812180e8c8892c64343938bbae5cd4bd629b65693a8fc42b825c472982b42ca500c2dd2f28d8d4035ef8290c436b40265effa3b12fca48cef81aef0e7517a1eebbcb255fb50e9a24144904f980cad7b9c5f3d4a0d1c4d91aa45e7a6da3a54f51e7f9fd5eb57bfcc998e36a2af599ff2531f8e121fe25318b988c4a7357fe2914a708392ce26086a92cb86699802c98706caf9a9e8e15a86cacfdd36a296f81508dc93532c6e5d7ce65bfed44d1523dddab51eb0b29f69c90343bac54455bb1dcce5a84e42d4e876c9027870e8f219980302343855b0c4b7854d2772c3c48b604e6dbc167c1b7237a94dc907146c722bf901a8b852bf2f6f8cb0458cb543bbdbf9ade73f36d52b56863bed28b51c6b5a9edf1ddf7db064d8909d7285482ed5173190365457317b63eba3c429a5e969ca49f4dfd5deb50e1790d58268c1fa4bea83e84347c1dea870f67ac5e5694b2f80f188dd99dadfa80f950c03ba4302e060dd02719882477d91c7553e9d1f4c363f1e350c5ccb38d7ff7802aede66028fca50ecd7b85158f094842975ba948290b8d0fe6aea9366823453dec8b2b0ef9c10d7bdc9e7bc0749dd50cf7f8a28b06842835402f971c49761e57f74d48fabdc8202955992c7d842ae935ae718dad7c5e67b3f982a2ed6109deec7f004fb86908d246176ae02b002b07867acbbe1856941db2ec380f38e67f140f87e9e88caf4b8901231911901aee5ed141763f69ca0aafd5d602f4eb0a49563524de860d3ca9203489af11250f92fff2fa0e9d9ba0f50acf8f3bd7e3f6b52e25c69507dcb8993485cf95af5d1fe490dfd52067af33d5d6c0ac07a024ebf87edc3dcb5014783bcd3f37d718acfcfe5944d1ba21cad3577e1fe385b5374a122dd21e5a3d5ca2f5b9eec9c321933a8ab47dd2b283ff58edea655baebd465956c8e2be845d4fd0b9ac2ba67a76e60cab18c0d857ee63800489f9f38afd6963739ee17a7334eead5cfff303e1e8bb7e5120eca50eb012ed742dc632287896b9920fc2fc927c7e87d21bb3361d8fe43e4d0a95690837e701152f2be626639127b02365eef4ac246623d553ca7bc68f8fb9b86ece2c485f83f9419ad75a545279b45254c7f0b3a508c47e3a10d929d6710a6779417971d1a8a3731d23869dcebc436b4382629cc4c3bcbb81780af232d4233701631064f842d9c78d159bc7937998d97d8ffcc2a2390f824d30ddfa79d131041d75cd18a7cd09c731d0b8eb0559134af94bf45be5062d0eadaa5ff0b4cea014f864d1985f484e3cf1284733c5a56bab235c274329fe195ccf5f94f13b5146eee1a8b2ff4a8cd4e428bd9c22eba799b0eb3d9e44926448d08645b940bd2ad3113af5015cbaf662d231b2d7d941a94f6b1d3fc5d280fd1df818f64eef897823ca343ed2472a965aeab701d4c1a73b4319bf6ba1c7e4e0638b13d631fe65724bbc4a5e5d48ff0a08b216f8d09e07646189bf13ee04ed65e1cfe6479460bf83048f60edb9d38f59ecdd7050af42ba6405b5ca3cd15c518d4a149ba602b47fd44ec5e5abedad465d79be825b24dda246b108d79e5fe61feacd98ac51be64a8072b8369ae9f20d44c888f3c9c6612bfd896400357339d39308cd01749ee3791b0d2578432a317a924f3e588d09ba93bee9dfddcf4f8894c5c40db475e36537ad2788e203951086d7c7a8f2f134dff95572d42d6e2228018412c134971c34b6e5c73b22190746983974459b0486deae2bb79caa10e9811650714b4fcc2093455791b7706dbf3d92d3d0003c7e30ee8365597babe62e9c357f55d1c0424de0459367037dbeb321e959be7c35c249f00ac8192bc6b16b428f6d771781f734da10a7949650441ba3645302cae800e9fb5ffa94f6b006c7830a559d551d928b3411dce4bc1131cacaeb38ee44c802e0317f880d120594b57932b54656cee990d7d688e5b2298696b64fa062487be6bd5e225e8303da5b9a21f22cb17a5dfb7e0885a26203a00b9bf523007387c11c7d343323864aeaa09bbb0e384cfe386adec8523c20acd1e7b44935c98e17e43f0667af2b5dd9ed38b3ccf453bd4029b1032141f6f70fddbb2ccec2799cb509ef48dd4f7391d83bc26ba5041d9701a1ab20875437b276b8d575760b40e8fa6e21667b81a71d26c394def8ec3e1c963ac0dccab2289c34a34d394b648b94822bce2aa5bf499ba9a335c15f719b2f518a8c35aef9d243d846f60a6d5d91666c6f36afa38b0e98da5b6ae5b9ee6107f4c8f0d8ae1bc7cad94b7c08b39e177e6c9364b67889b95058da216bcf47160a4375ed4bf2db43a1b28466807ec194a0945534b1f31246c54c2e6116d34419a887d05acc18e51baa35547a50b7a21e92de3c7f8da1eaf7619910b5f894e06b8514c2d1ed3fb04c0b24280df909cb3f82315a046636b78e1576879daf51d4a196d456027975766651f7b941a6802f11ec616593fa38e936892ab2026ad59fab66e88a3257cc99b74a0abadc1cba8efbb2c7968ca9fe933793be95a2455d890a26d5cafe2a71d581f0385b27ca2a7ede21b81dad4d9200a1b1d40241ef9da757f302bb79f1e8ea7ad2e23b9348984b59eb2de100aa55f6b8b5f752cf6e439f35875d87b819db625518a276fdbc99fb30538429d1497685684c61d898136029ad7e1b3a2ada80d28c014aa5f7880e9af22fbaf1f8a9ad933404702586b10cf557af84b1e345a301c27d565a5854ec32403b2ec291058d60e712864135981ef6db026b894d50d1ec29b7a29923ae1f2ed6df56dceae569221aa00d946e979848212663a2509d8dfdbaab06b675f483ff989857f31c7df70ad15b89472a2de20174bfb54f93a16fc45c948ce51e491e11ee7fbb005aac9c6e3d7c45f8612afb2c049e1d6790595a5b64b174e6f9988b74f947970561accd18964fb22b1b371fca3384b179cca446b6d43b2b327474c774c03790e85a9b4b6ad829f668863f9b5dcf11e60ec1fcef1f5ac8def4a3edb84944838e804cd08de6392cd8eb9ab0c1e2aa774b5cc01380791f526ed6aaf86543e3bc75765bb94df2e5e7db84234eaa87baedcb8aed6f90774ca91929df6f6dd55e47b9afa9a7b440c20e6e36dcf48c7ef051f7f338c8424ce22347653fb365d8a2bc49247d46116ac90809c0448bad015bcfb8d777e3aeae7009d914324a8f16beb2afceae085da764657f14b61cec53444d057754864fe64040fced690311c47c5765ae76ec0514a8f02252187d69042f0ad5501bda424c1ad85b720dc45266c8f457f232a33304cce21cdac48a0279b33b68617e7638ea3feef0119cee763886b6e5ddcc21f94946a91ef0630f210f625b984e822fb603db20148bb8c518ab0aa5314df203291e7e7e2cd6f28c2b4b6cb210d778e432bd12927fb798a96b8ae0db3f9beed81112ee7a6d157dfc1a22c7bb4a54d6d3c9ca5191482de3474c8a4319ed79573a4d80a63dd09a54621dab7db2e4e8c73e093cec392d7af6a35b362fcd7494fa9f11292ccce8de1eae767afa5326193bd17495c62d25084af7e25d7e97b558d4741151c08ffa8ad02a66672b20f86db359f7ffb2c48ca4f64eecb381f9ab608bcf907ddbb88ae09e97378b6221966b8c8e0896c0652cbe2a107521dad0384cda34e825077828924db0dcc547ee165fd50c7693b91e0fa0eab90a97a91b7706c9c77d4f4f985bc32af04e0f141173a270c4de5d7aad18b148b9e870b1dd5cfba013b8743824d64e653a071de36da1b12cc8ab041f2b6f974f076904349eae1f15bae85d374514f2e1f254c53cef6d6e0ac3e743afa3fbb99466d54b54031e83435ca53e061dbe020ca7e4e1cf1522dbd8d2812718299b3ba860411d61e1e44ea3f1433f89b7f6b0084c0c6351777a08c365293431857905be26cb097b484ddb3d431bbada5d9909176df1749d6188fd49896fdd32257a4a43375a53ff35ed1e1a81a1bce07144d38374380fdc871331cb8fc25c43ab39ffb2afce8ad2bd2307508c38cd308528dff28e5a635752a32c78674955c6ccbc576c1cb0ef7a9dad8eaefcd94beadbb03ca3dd3b9403d677c91c79b4b0f222fe70f250a06faa5a02a001fd99ac56bd33b03b082feb2b30c39cce4e11c91c89d5009ea7706f3efff11c6b2de9eeb26b1a0194d1061943c48df810dc8da1232aa53c65be5683c0e179cd301efadf00170398e4c71059481f227e3296a19196127943716e04eda8ebdb59f41b5b021d92d1b10ec03935bcb4a6ced9f128a4da0d06d895bb6d0550299beaee1c640f4247f7c2c62669e8cfd9148836121a34b5c12f98c240002140c2ad18f15a8f4132937655ad96e8d59e731204b5fb28a58f6f5bd4bb8e8766f4f548a5047079951fa36b5527b10051ef1499c159d142ebda06330b659dd259efd988dcac366dae94b9ba2788bd49bedb9a313bc97da9e04038a1da3c23bfc3222eb83536eaee963ee6bad8e2ba90d743a41350da30ec664ab49d016cf7713e162f9407a3aa58ed3b400a57887066df8eec23007482e85cd0ea07aafe1341b3f7c7a11d8e6fd0bb237ae8ad0d9724dbf0fa36cc9ec5fef8f0e4c3b50d99549a3f61e28bec5943a7fc6db59e64bd2596c228daedfbb390799e248a85e6ca87286812f833c0d6563cd4df7c0856f455bf7f5494e8e57a429e0948c05158a9f01b0eb0d056cc51ac07558ef0828a59df00912e8be4b14cde6340ef01102aee8a6509e77c2667cb908374fa1d86425be42d23683d9480de70a21a0c6b1dc64771da5e0937bf31e79978609a4d307d4e3970665460798faa0a3da9e80567a1e32640a3db944e5fef4caaf59c4b814360945e298a72618398edea5454c23032775d6faa5bbe5e74d85dd097ac92781bef2a5586f6dfd86050a184cae0c760bc23eb370b102f93247169f814010b6f0e6f8f0502bad15ad91fbb30221ed9b4008a28b38d783e2a325f28c4299b6931fffdb017e075f76baa12f07c065b923f0c103f479b2311028c22966ad5966d5d034b77caf26b244404f90ba5fc3a74da3d398b9b7741ca7bf2e139dcd96e145e9ea08e2fa1ff1f9cc5f063dd31edc49fe7c78dc9b0b5932262e30015cd82fcd120bd5e22395a402991d45ff2f861bd6d2bc006c33e91be33cc258ff230bc2efe4efeca8a3f532f476a786bd6a55111792803399de615aa5f0f4e58404bbac6b88aaecb9bce5b7801e740e0c525850971b212e74df29f08c5a7aed976fe77bbe24c92bee8ce05ad14d04dccc0a7f06501f4c601425167840ca77135cd8f0671c62eec36d153ee6147026810f2049257d4b5fa4542dedc60286b99ed091bffbcede7db139aa4729c3fb059df73b69600b9f9b4b09f4f07826fb8846c4ec4955bbd994a09b38f6996f8b02fbf118f0fcb5e85ca2ff5788f0475af520d4e5c3d886e9ed3f0a3992152ae94fb8f89571cbdf410a432870006e2d6da38e562c2bed974d06e1046df45d29605cddc3c41878a262453605b73d78a3eb7c4889aa46731169f10a1afb81264f986f1dbbe5d70476619e1067940b33824b64a4712de7c724ef65413acedd184f8de4a22ddd557990d5c0aaf11f321f2e1236914117640a38aa3c55f37293a8f691c4a86d31e7bcd185103bdd01562d250c45a224716bdfd713ea4a6323f2d28da1be89a0a1ed33d865209502192d78cd177f1ac64269b2f1096b6cba5a4bfec345fd71691a794e30927fa181c0e2e1bd4c5efb2bddff150e1136e2b4557eb31a2af25fcffbd2b00e9c8b33ec41b7f6f3773a25685fb1dad0d884918d26014a8dc64a12b13e700ee57210191b8ca304d02268d6ffaab8d6e7f0c3ea1bd0e218566f7904c40174db4e19f77aafb556549c7acde41c35e1ee11f37a13173b5856b7892e01f63c86481a0e481c0c0525050186f15cbad3182128e3fb13ca40e27cac8c54455d90dd89058c338c3efa3f6710c84b3a08def8ae717ad5bb895b7b08d460dea8109c395eb873767952ca7bd90b1dbabb8a86918afd091b32c5513cf37ba47b6c17b254d67a8314cb0e8124c91f9f5846c1ece9dabe3582f19245f1265fe6eb08446ab4f3bd11534a58b6dd916f9d3b542cd6dbbcb014a913e8cc3d41142c7018135f49475ee4ef345ac318be29d343a741f0820c10fa75844052132108571ae8127ebc82c4ea78eebaf9835204b115ddb0d096ac01796dd1fd3f98546e23c3e1db9ad9c81fbc64552fdaa668de21878af178c382b3239972bf24a0c560285c3f142f08273716d328fd0c3de2ab899f85c18e067efcd4f4ca718279dba42fb75248e8397725b56d2018c01214f431cf4997b3580ba4d94cef26a90aa418e46aea7213a3231195513b44d924679c43a414fd1004ad844a71f4e54017877e4abbb9033b0a117a5ef712b403148d1dbbff4c6bbe55cebaac7ba0ca4e954c2b13722974948f708f2eb5e542323f5098186ccd2302b2ca9d8f154ecf94892535b21c1cb3110f11b03994c67fb2944bc445286c9bb5045e307867851d04e11e518f7fd3856b08ef86e5afc827bd81b4c0a8c6ca3cba16f974c7f2f603310e8b700b61a11da76605281227c30a4c62336a3d9b7153649de7499c1ee2dcb782009911534d87146a479f16024df8841014bd2da8175649a47f9f6239328f9d7050bd127273ca13b3e1148da3d9ecfe2326a251e559fabbfaceabb343eae928d2c0d827ed9a35eb09efbe588de2b7152353761aa164a77ffb664f75c581dd0621779dca7e2b166b38d4a6e26c33fdda3a43e369f9bf5bc110c328d9ead6da8cc52da630715bf3d645e52b3df77591fd89f2d3c4e816533f4df63f60125266da351e9f3f2ff80a9c4ce4bd3cd9d0ce0db2a4d8a6068648f1a3d4bf4191cc2c1b4c5a05260b0f55a90de8ee5d2304da2a02df8e64bebf8ee67aaa54af2130057f7e956b50d1bb9c1af7a72635607be79257539704f3c15ff97206a1fdbcb23778d8f3fe26a2d5d9ac5b0435f8fdffdd7bb92f6c5cbb536ddcbdf3320f164787857c65b4ac57eef37c0eed8a7078d04f7093b9667b228e0c6040ceaf7cfa65a934","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
