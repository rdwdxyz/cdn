<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"84c7e5f4a1828dd1e4c28f94654a00fcf455b876085c7f2ab6f355f75710d842aee602a319d60ee9aa78cc62ed6aaf0f3ab2639798f1a1c66f650ec8ffaa6ab7fead67fce42bf417d2b154f43348338b4faf118a21092a15bdde3286993afd6b96b5a4294080efe17c79a14a00a98103eecb8b8ed38c57094977640bb9237b2760ea74652d6d73514c341bf508f71e56ac0b77a02f50577adb7281ef6cfc73d3561e6542fd80225e8f2e706ea804aed68dd7fb711ede81a88c363b07ac8a47b86d7681febc37f1869f4f53b28d6da4a93bc787ccde3e8dee9d44284b3446555ae1150506d8a012bbb0bb5c8922103861b34b19b43ae34b0a234f73d61f2d2bc468da22fa016af4dbc94211694f01bfc72b3fa20aaab0c3124ed0f478389dbc8643162961cf94d9f827c91c81f9d90cdb0f54570bef25e5334eb230266372dee71edc6895530c18925c696b0fa35061b0b561806d2120d7eebc0c424d23c1f613f06edeb569b566a48f3fa58d18bc242671970a18100222cba30cf1fc7d0a04c5bab31eace446d4a92b0be37f2b9c175107739576b5c48c137e80dd16fd99a244a5edf1c234710ec32738c6d2190d10380fc9e1565e10faa361bd9a7ca2eb226c900206c8adb5c34400f6e501735ebb5472687f5d500ad7e5bf64766a1214bb847b6274b37cb47353e123aec6e2d82698843baab5dbac4198fb612a03bbdf8c0d7fe716821fa764e6448881bb62fcd70954872c7b9fb412220e97954b956142d819dc27b0438a9da298b52be8fed78083808d2b056f61dbd0830e1e517ae005b180e2ea06ade5c9ee1dc34e4eb3ddda222a45a771cc7c2bff3ec7109acf3d80d2ca46f4b562357e778fd80898c4b30ca763e762746949189bf6b8292e800e8d6280734b41a2e4edd8de8c24411983944dedf21639694e7da2fec90d9f9d973709e7f2eda2a32b5eea167fdb5ea50d687931f83670d77d2e8a8eaa3bddc08dd3a632d497de6649d26bc89d1602d2833045f8a98afb94e6dfd9b205ec4b8e62641ede5888efc56ce14bc03dd39affac5fbc19c318c4eba2236fac506bd0b821668779420f6d70a521075e324d90aeba1696bcb1ac1466078c6928c71894f6358f1790c8624b453f84c0a05749be0a3e3cf966525091573556c803e74e6851197566849abbbe3577778f1c0ce0c7d4f76ba12ebab14723659e7727404ccd68044d9162559f18192109fb00bd3331378d647811aa439a689fb956eba7a0b797446ee58d4ebbd5e704a482525f7c25c7fd9f809131151aa65ae831208042a26ebb33e44ef5f434f98f8cb822e4ae8ffdcccb36667cff426eb1e64a1044379704db5175ca7d5a33f0631704182be8e420c9c7dde086af4596671024e233f8aabbd6c7c8a360bd8734451780fa8aae3d86762a6135b4292c17b3e6cec05c008856d5101a1e6b2d1816f6369af40a6151be49b9813496ba1fefd39d870416bd5d5537c0c242b37eaba9e8762fc6a36d1ad04342ed45814d9daedfea47bdc35f8e245c5c16f779e917211d8112b8acbf78b08056c0d84b43ef48393928a063213d8bbbc0117ab3517711d0d27efac854296b1ccba28e51ab782d9a978bf9320a8214cd8f0806122db58e2fa9ff9844f4a7f3fcd49af11bece17266e01f57718d2f25ff2f9d9476b892407f49acb2c2d3919028bc98ff4b02bb5f6c460db637ee453ba5720ebed78a2f13e87894ae09f787b971b1ea47182ce76902c48b4784a37c50791a82537f3d51052c24782b0b40de0adce4f125d49cfcaf85f12676ed4b551ad9a842540f1defdb2c968ffda09de19410a3a5151058d40ef7855964cc7ec5b92d2330f254f85a2fd2d848b73ccb424b25c62cfa1d1e2558523c1a453fc0719585b61bbeb998f87e02cf1a1db2a8548fd7bae6377786db95e54e2efcb8f38b87845f7364d1bbb8719eb9ae2e6e9b30c5b78c49e92dfc495073f8ea4efacc8548e622c31f6cd68a2d11e71d34ada06f55688542d14a8a915d69b2d4df1eed97190b3b2188ac624bef8cc1fd780d912a32786f98af7380ac3f261b5f411f45c383dc6ec43f0fba9d69e40cbc2d17c400204589c99623a34daf28e17ece46869272d3beb7d3a611c8b0cbad2a6065df8a6c690f70d9fb4805e1d930069d6d29609a6d163dd3086ed86c32cd7457ab8a6af046c8b833a7ff6457640c764973d1854ee02d44a0ad889a40202de351dfc2a44608fac6cda44662f676bcc64a855484720a2d417caf67d7cefecf8b8ebbbd1ac73d42b4996186d39ea9aeacbacbfb8f0ec9d1476fb069cc457b55c253343b8644ffb480c852b5cdfad12b935421e6f06f76cbe3d9996aa7efab8fe14b7a4c7d49da882e2c091536eff0d2c48589a73aea20254fea1e3866b39a79d2460ab21b2ca9139a8e2c5a90a89a89438a364eb6f3afc72710cd8ee8f4d5ee86f4ef1145da40cdd7754d506242a8c1dc13133aaf178cfd578e6d6a88ccf5ee480e8dcd7fc168024f32dee190d2cafb99c7507577b91a17888bc391cdc0671da0872c18d05ab29acaa8cace38282f61f6339de3d672f007f42021f606eb249861a3ce7a0308d2ca2d4c59dd1ceaf2d29628b4dd4e909d0ff531c5a4eba1a23dff35d24d5f0e3c576b3d9c7685f2a1c2e127558617dd0ebd3a92e022bcfcf415a4f84b0c5f8fc27ac65de860515d43e62afd50a54825d1b68d23eae60eda7a177c0ab6f82ce937ff5a71ba3ccd128842d191141c683840cfaeeef8ed5276386ee2b48443d0e764d7c95d5f4d68f9ca7047aa133354303e6ed44f053e765770ad0bbb58f81afd96cdd6b39bdf5bacc26212f28970e435875a3cb4755d27f717a570b42d8ed6dd7bb870b6631e246e0e52edfad8d01854e2aeaf93a7007388f662d4db02803d2c5db29470ad01ac5e977a3774f67aee2fa7707b02b0d42bf2eb9f9f3f3946dd27a2b2e69ed73778269d91b93367b01946f7feb9dfef25fd5f357f1579c5a595a55aba0e6c75fa2859ddcb58ffa28e976405248394ca62d384744fbe72ac149bbf30affa0f18ab313d3ce9ca48c2a3c9aebc64df8f662380856ca4af7af4e634209dec2cd480b1767b7f2f9b6b0a73abb42458bb5e61a31be671762fb281e03c75b180f75efdfde561ce286026a5b7faaa2e3f3901d8625c55803b69c5b3158d17f4f70db8ccb2bacf845756d5ff25163dc8b7911b90bca8f002ee333c6ad5f4ef3907b073c4d0f60e8fb7b8dd934769b06341bb8de1b14baba490cc894901cff10664eae523c83cb20aded1319c6653865f6945f2a33bf2abc8d1f4517606635bf49632e849387d2dd195ed5ae52d0c554dfcc911c347fb4dc356ab8b8154aa6b45aaf092d30e6e71600acf2ca67cf56367ee3ff2203c273834fe149241d904a92090b8c45382bc2cede30df74d62ab5c45d8a9a9f3aef8137d2ea63cf8ed622a8dd171254edeb26b2383818c901bac92f91986913049f39d4fc6d28e241cb8b429d261df67fcd052ef9fc7385f7f0d6ad308fe626c63da1e8ab25bc3b9f8c31855442406bc6a0324f682ebbb7643492b0670a7c865215f99d1c202c7f2f84a85bf56449cd8602efd58cddac3a90b468ca266705191ad2beedadc7871ed4030577a5fee76b7f9834844c72bd38a171916be94bb22735f66515c7bc340216193e50456a7d3187cc89ba37b308d1c1e41dc43c3694d1a4b481b000f1cd7ddec8325e726f86ad6cfdbd3fba1886dadb2ddbd6773b0717ce6a6f494c4e4f7debb9dd26ecd42eeeea391825604499645dadca79380675a39b48d4038e46768a4245e05b18ed5fb62cd0c7d111a0cfe8122bc4947da76e66f620563e4f766a99133b1393dfcbb8ed5759dd409bc41187571ea0166a1aafdd76ada37d4b0680cca79363240ae271375b25cca9a500c9c4b8e4a8de67f3254a8e5652499de5c343b0239f4e16cddb0546c860848507d9ac0c05456f4724335092a8ad38e332600f52f5c311e4be9e384f347f5c371bf5a511ad835a21d65dfc2d824de4344b9007178195e47527a4023df8d2819a89cf71a5186bbbcb3b619583c01ccb11d7ef1e613b60a3fa54657291e223e23cd6652da5f642ec1e05091fef0caa1d971e50ea491033ada9f47ee2208aedc77a889a85a32ef9bd9dc3798ea36e087453fb80485a2dfb1c9655b55032030d043361244a064e02eb950d487eac33168b8c8e802d140322d23e74af839a5c6b25d7922288d29cfcfbca6d7ab286642130dcc964bc36ddf9f9ed7ed912ef29c451a21241653c7139ccfbb549da240e712e0df73fe505a604f25737f108637124a7472b2e77b4c721681d6ec478deb926397ba07ac157ebab99c9e2131f41bffcf3b3de865942a645384e9a37a5f1e4e2a41c883b0ef2f2ec80359343e7e73c981d4fc69d4d8e643c6df7c02a21b7adf5f12319e41a715a2d40ad3c06e5ea3dccd0f7584de729078ef623fedb4fb2e147fd6558e8e76a232c96ef36fc692b06679ea9842c3ea7a357a8d93fa6723bb2a40a5467ddfdbebb9b8096a5bff71578d472ef91f914e652866c09eacf4bca51b7803ffe6fbe4fb55fd65ff035663aa39a5733293d332f41945ecf7c9f890fff4e608fec51e868221ea1958643e3b4ba1596c4bef7a9bdd316227bd043d9844ba7cbde89d20b93d01db64c36ed9ffa12ee0d1a0adfe4bf9e670f5b215c6918da7a37e4e440582e767e9c1ced4de219fa6c7dd746c17cb2ae43341c628a87ae009e2fb6fb237c25c027b833c03247a8466b20e4c4f4c52d0d03995a9df4b9003ea55836ac74ee4d3638beed4c422b6dcd18e7ad3497b455c5b5b108480a3b0430a5f135e992fc4a8d09ca010b6571fe83eb78f77cd5bd5fb745aa9d378062aff55cafe998f6ce3eac55746b17e67857a78d57ddabf5310c1c4a0fadc3683dbcd94fb744d1b0f1f1fd2d8f16fb1a0f22572acdf88782c947a144cc5aa3f412f30fda106b414164c8829e603757f922fea1eb84e83e70c22ed649343f6fb0eea5aa5256114ad9790f9d7a1f5a4e87abd1c8731223024cbfd9db860bf2a1468a904693071a5be92117aaf1072756e013de0ddad846355b0dc5f9857d59dad6ab6fba0022aadff391ca7a7d18bbb358799c9d13ffb4f56ac3275de7181ae2dabd436d06b68331d1f67c4e1498116d8fccc60066d09de60e38cf838d780ae4e5ce4a0d2bc8d927543558ba9b493c7e5906c00437e23d08db4470e0fe74ca20c9a1b8dbc7ca2c933c4a045d62dabf7b158aba297e7fa4d61dc6657db13e6daaca8f12f2a527a4beb723a0b78eebfdce14e66bc8d08686efc1aa0a41c96e9230e36651cdb4e2f3d0fc23ad88282f525d3a0cd066e6f8f9b8a2d3b64ed854c175c9720e8f3d741c1a443fc28a74d925090b5fe39f6c1515364f61c0499a0baf64e1834b4bc31e69561b75acb12b49fddf05d5b7c6b9126e32b5a58f321a1543c8006966811fc3a98bda21acae93795ad1032d2601eb10a89c2d8ecfe88fcc503e8f29b6c4ac438a30337b94c36742c2883f24210582747a030edd62e7a1cba6bb45fb644b5ef8b895cd1538b3707fd0a549a31d27a400837df1102445c17167868e7ba975b7a0e7789e5fa94178b73fc0e4f7246744f1755110d56600fac10a912d70777cd8f68a112d16039ffef99b471e5c9da209f416468f1d0b8ad47cf3f1005e09f1a8e72a8953222812077e4a039481a89bfecf5958c153b9ab5040e2b9d8985170d83f5c433ca0246c3b71823374026955e99664fe4acb288995c298b47563bf083915b0b77bb77b33dddc14143fda40ad0ca5cfdfaa8bf3bab276e909afb795928448de4ea109f8a74ea7570636732fbee6558de682e5baee4e15e8865f84e49f990ffcbcc50bc526528c1a6c35d9958b0a5be58d27adac30aa6f5aa7bc2f5119182ab87ec9a19443dca2c84cb4d0cacfa78fa3f099a1b1aed25db84597fb32f13cf8590bee9ffd8836a44db9bcc7ded549c3225056915d3ce10458fc47c5990bf139dc08e81a42c681cf998990272e78f30ffa437ded0631e040924c154150ebf5e8078910fb981f915120dd3ca5ece74dae732ae57335bac76f4795741677f56f207496286b4cc5ec87dd7155662ef43bc58f938148416c51b2c2f25378eabd5f1e1ff1dcd211331640bdd52cc888275764e3e6fd9e440b50d7f21ac857d51cb657f611a691fb005f293e3453b85d33cf18e539f84f909b478317d3fed614fc8f6ed0c40da3394413a4f29f5332b031b01a18c0889b3bd3b0ed1b8089e69bd10a0dc65b42d64a526d012bb70a571e04b93a90ee4784051189f64354fead3322a3aca802e2dec13eaa6b70a434e5dcc8640d7b039b5ca13d5ef7e7a990bbe9e44eff5752e5c68e7d97ee7e948cf054692a8f0fc42e187d6cfeaa7853a9c7c3b5c4bba15488978f2bbdbf063d616b40612609be179114ba7cfdb524d6629c77117d8cb6977e5bc8177bc178a5551996070df2624f41dc72b5a47008d588523ec61815db388daf3fb6084869dd893874218f1cb7f707b5cc7aa17255b70437997660024e10ad115a34022b2799227cbd1eb18e583e98abc4538a1ef8f148503557a177445d8bdf28fbf0c950c79611fcdb9110901744a7ad50fc84eb0c7f291cd28c9d88fd031ebb589ed24814cc559ecda0808bc67c979a7a3ec2222dc7f04dd77ac4d51d14156b21175d3345b5b2bb354c950363bfe02e6a25489f9845e838c0f1cf608df0a46c5395254acdca7c41192f2f9537350182059f54e14f3524ded3ffa4f9c217b142f28424049010171cbb8019009b094194231db778b2912f1dcf3084460abcef7b87b8bad9376c851fab2cd3958f3cda56cabdc75ea7b464c7bc05713e4652f7c405f80e0e1094820747a7a8ef78250698597895c622a2b5bbbfd2dbcf2f2728ed4ee3752a39bdec9f97dee61eebdd0c46a9b4b68fc56f90b823a3bd025b09a73a57bcf9868f9afc5ba52c38a74cbbcc83cc1e97f20dc5550df3dc8156b97b0c01d7b3e3f3f70d8bb6f7519710507e3d804dd8dccf0cbcb13c4ef87a992b9e024108070264114910ce90911059b11eba9b048cf334467a074bfb0ddfe2792bd385a75e9aa68cf1fcbdef78cfd650044956215930c8e30724e01898a883fe7fc69c54fdecf99afb1ebabbfa1de74636415320be5fb75e694e2c3aa1658fe18f96de594e12b2b0c9098a3cbdbe79b5318b32b5158469046cd39bc40a4a167604728d73b3ace02db294b8fec46b2c154d719e46e6f04bfb982a0098e0d6a8c3b07c48f071b461921bcf6b62046ea6936f35c18d4ec5d7666d7b9b061648f27c9dd45e9245ec944ff50ac0f72584364160a21a923ff1cd33da824713b0d0879e7a2d87a81f2f0edbe6929d84f4266d4104360a4bf396701a987d543eec48091c26f40481c152f5bf50c1f72e7397cc87d3e16b6c9171d2b91b3dfb247592ea613eff6e236a7c3c8fb1fbbfaf451947bd63725f34a141df770813c965105f230ef8b6a10de17500101c6292f3796eb4b52f8ffa67261f23da8c7202fb54b3131eba062ee57d9dd8e5e4c6d95ef61b203803908b5d000a045c1d64b9ba67c71a3595e8bfac556529518ea5a7beaca7491de1fed0999a98334906e63d210a032b8ed5a2fda5d35db42513659f121609dd5be0ffd1e987d29bb13f1ce6e873036d7e1ae06116a42ba550b0d22bc8b0efdaf3eded13f6d5884581a399d5c9d34b38a49e37fb181577eeed40a0a86ee8cce0cfb49e7678787f53bee715d373515b690cd1036126747dca0ae681944ba4cbfec4fc317d2d97192107cad80e53a1a9c985d28d2b7ad2e9e424245a466d18040935695682896ac433dd39767fc2d1f73dff3a359ba0b7b7f13e5de2668499b699b53cc04aacf8eeda47aab161c09eeee8fee089114b93c66dc03b6fc5cd7f4cf2f57d335206b2ee2f39d9a99294dddce9ed511c82d5cf327bb1397bc10da0144e5b9c7b9f39d988de96b03605375a16b9aa29f3e47de8fc19739141f1384804ae3342c1afd18457e3afa967a1368023f5c2f62301d8bb3adeff06ed74a884eabebca07de0e0a7196b2b76671c3080254797edc7b6ed22da3ac5c7c188c18e07fe355237949f0fa49c1b339083398feda794d482311f6c551a5b874e73a398eb8eb328a8fc0fb30a5295b7378f0e7422faae0c2514ab775e0fbea2219ed46c27078701c75f5cb42dfceee1e122dce4e8d4ae652ec017359c7c4906e8d0da55b6120cfab1281d45550fa668a6f847a0932869f9f4e014498d7429ed8a0e1debe1d789a1e7be80b5da9fc1955b88df93ca45076c00b53a2a53bace98e6a962d3c274b05f4b26fc0e7a20009841fe97bf114ef8ac6097b9568b123f29dbc70035388df873e4321ca56cde17acca62d81b4d80b2c385909bbcaf0d92798f81e905950918e63168b25aa38077e6a6aff4c3afd5b185d0732a72ea7c74b151ed3015460c814809ea7ad113e53d17b6ace9643d8c8c1cfb3b217708ac22692701f63e3980b1393c6972b7a309d3a3cb0557a578c87af680e6c5800280571b29cb6d5cb05a832523acbbb97846902e570d2d889b2f863a2d9f139b95021519880c5def6dd92e982898ed5ba4cdb5bd93622c3e1b7d74a792aa9ed202884215a72031a687a6f37f6cb05f0fc215c11f41fb77dde75a72bb4e1bff4445b71118fa53b1059bd6ee5200ee2e8327942cfe8d40fe020ae94d2d752e5697cd8741e49b72fb1afe98cc1716d818a3e5f396a4aaec98c1e9ed6fea68a52d52600cbb9a15de6bd20ccd894b9f36d906f965793cdf4d1f24409759253b2cea08fd8671f0a95dcb616725476c28d5205d4eb90d29af40cc5e055abf27a8166f102bd3df6ff60d141330fb16a8804e603e341d86832b1a4875d009bd49d8b24ad9e53a1ab1cfcdea3fc70a506d1bdea467654da58b01ffe6b7015e0a04beb811fe1eedbe5cd944f8d6a3b89127c9bc39c394b1d71a70bfa8548877722f669f294e18b834351be3ba888676a9bd64a7481902f6ab5a98dcae4b6b4856937bd39ccdc55a661c33dea9afa63d0b830781e67c56d52f4b70b9223aea52235b611c9047875c75750d2768017003e547d1e19b6e8006aac416374fda02dd6af3898b9b60b64ca5ef1851b00d9bcd45e6c6f364ff6fc3fcf4d6c9d631f1a4e918a311549d87623c516152843836a63e886ae8b84be1597efa4c3d5f55649bc23d01bb2cecaf63b6e5e071f526392b19aef716ca9051fbbab2d9f74541308d68d3cafdb31fa7c8efc1eeca2ffeb58f0e6927215ea89b5f462906078766ab99fd43f88dc03a741a455cf5aa09ce37ec10d89a90a622ba0233b9c709377d960fc4e93b67461c46b568545e25ba09e514859bb675d324dd3b8a06641bd4b4b8d2b8257978f75e8b8088cee0a440c9dbcd6a06ced26f190ffcdbd90177369f9851bcffe84855d43b8169fddeaf30cc373d40dfa73de9e129caaae2aaa84b6680e3ad178eef420b1b72cbe66a1469fc6a118f90b7ce0542f84d2145992fe6933e605a119834bff9d5a540c568d3034b60a3bbe1db53c0074b3f2293b8ad8af5e82b98b05f98579fa05378bf7d2a102a19743d4eaab6de1467c673e440606fc8af605daedf639b88fb89ddbee9b69ff2ede0addd1cf9f5e25202b8026dbe314b6631a337ca70558ed228c7421e9fb6802f4b878a06bd2999abb96416ecf6265de7c3f391507da1377ad1597b1859c7f7a15f2107084ea573a73d10e3301bd4bc819f503a97f8fb2688fb93a3c05d4fc4ae23fe191e26a363a3ed8a590a977a0d0f914594a97956ea274469bfc75c56186e204e130a532edee0eaadb89ff97d551c395cc42daea1ebd639e6bbd3251bf77cbfe7169209547b45d16f30b88fb3e679b86c55560f60a234a5687cb2de895c9d50e0435b4ba417bad60f5de34866451437acc0a7f3d3caa2511bde29c7c05d05c543dceda92a5e4a39967a331edabf4e903f47a06663abbc798164c1699525c6b4e5035d3ba8e3540fe32faee4cfcda5d951968beab515a17199eb6d25282491c846f8b47fb1cc4d9a9d10a608191fba7b443f93d00162eb443f8f66352cd5e7deb2fd19066583d51e468df153ecf71ce50ecf3b22e680ee48a0afe3a2012a6585f9f91e64cb05a456ef6e4e11505197be9dac59bee4387ccd16ccf34e80aa669061b1099f631ab9c809e4f59a2d77b640f9143d1d495a305cb5ae7f3654b3b74d73f3caf1d7fb8b6d158c72c7610c048d57b8330d91f64c05bace8a8cc97fda0dac346296f8305f898d4272fb4dabf5048936ef0ac5f9212cab4ef589b5ae3f8dfb9dd8d559d8b1906863e1593ede93d912417049c3cff6d3f51a3aed35490650c97cc5975360690ef94ac9b99b3ede2a3c995d567dd494a29c4e9587f280de39b988eee36688d9027e11ccecc217b64c8c2aab64f20440704bf14bf8645755c80a57b844511a21c9b3ff46d8edafdad26018da39b10c2b9108c3868b93151ba757edaa01b0e356e3ebd14a83218684f2f2331bd0ffc0de4e85041dcf28c841958d45fbc2dd61016c1ac08b2f08951c1ee7df562668f9190cb79a371c57bf6aa7080623897ed1657242441e2bd85a3b81ba9746e273219a67cdffa1f975abe5a943e80cef1498533da11cf9bac13f8da848c8aa04e07bd498de8175f44f5cc8fca0cb3670a4d2e6170d1ee2f05ef16faac6f5a9d80e62fe467ec51e010a4043b1a7d76858f734bb4433c172a024319ab9a2a95df2569e1a1bf5f58fcd9f6f23ce53074fa54a4c235852f589cb84455b3979e6bd3f14cd0476b89b0b24e13cb3454ac44c09cc11d487e915c9cdfea5cf7150a8ac3c8e9a6b9c8aa266bf1b21f67d003d25453734cf8b2d10234c8fc8d5c965981b27412802ed76e090c5dce03ee05a751472cd88135747ddd0164addcd2a31335291160337ddebb8af3866eddc100a424ec1900f886d662dc73d06e02db2f110e7f6f3351ae53039c172f13ed4e845249800b5f144268ec483aa9b7f94ad62e402a5899bcac371a36d6274a6b74966f2c5986cd525a734978953a0e53472edaffe810a94330a6a1a6744eae9523c2f7e7045eaa935ad477dc0b1a5d1deb76fba621d2ab1b02cb215372708535065d46e7064bf0523877f54d12b0f69d4b69c6d7c37f37386e38aed3208beebd76e13be25d2ac09d0a5ca5a8840dfd17fe8e887755b455bbab1a746885922124ad53c2834c50040a4ca1fbeef25984d6100a72c14a66c10de1034d83a8a172f65c74a7b4a14e572805b965a50f9e3a22ab71c2fdbf1aa1d80d4f1e2af54177906b2e4860f58dbf108f43fb7664c870a0193b3feb80ae96e41ffedd3241be155a63a46df95f6a4ba578d1c87179b1d6f08d2e9d094df8ff0537f6d55d6c1dfa4ae93beceb86461930d426ed7b4be2d5ca7d2f8c58777d4a634b86bbed72b92e4fc58db318890308854610c28c24dee25cc2d7661d6acebee4f68f44b227f7068d429261348f8f0bcded4454790348b65eef46aad61f1ea5b19d73e865051080d03f8b8aa6c0307e765bd821283450e15bb5225b7c121f97584d4846ce00515a0cc6868f8f08edb57232a2a4764aaaf16a4d182898945b614004218a4c2b44e9f3e74e8ba0040dab5e9ea1b5085dab986aaeb1457429f86b74a564fa1772349795a4749da1fb681791ffec8b2f1e5f82ec37b6cf699c3c00e168de5c579bf463b061c83719b691f85a4d13b8b00fcad51b5072f883e727c7b8e33d89b7bbac805fb4b896a1efbd16a9bb72e838b872a0f3291ecdc6bfd171e547fd7a90440e3284fc5e12d6363274da9d2cd89ab0be6f5136ed4cc23314b31571011dc0249d49d7751b70983d3853b082cba0bfa8438c719a21cf7e7c9de20350aa7a2210dba495e9fd9c4c35674f8c6bbf086597e531d6f466a718084db4dc457ba42b0cb6ba47cc1c156543551179ab3ef57d0c384892aab39e1eb0e71c4c1c06c08961a393778c3978696ca97d6a1dbd010f48b4ab0e89337ebf2858e8ee8b40005824f70c629218f6e29aa6b600eeb2b4e8a2497767095ddfc17f3beb633354aed6d762d95b9feb6c391cf5e473aeef71c098b6d9f3af1d7816f95a432e5e0e638f1a0ab37002b12b4c7c29e5e666bce1ef871c9d836561e71d8fafc995020bb0433e053402d67a927a8f87f4c80364cf305bd042811e6a16ccf05d93febe1e486f4115ab5ac5136c61e2a5472ae79d71cba4e7c6bc0f32e1a0a3d05ec0f4a54e10f843f075f5221e8672e5b00f2f296953c96d749783fb52af292222bd0fbc0fba61587c5cdb1bee0df1dae427f4351d9c96b7cbff4e8fc10c80ec9038c444de67d704e3fadbe546a6bcc72dba08cd7caa48230256af71ede16a575493b2fafebb87f33de3baff0d0358f8d88801a302343ad1336fe9e1a90b4b437f1a67c674579e20cb400a40720ff9efec71b0ef340aed3a7f5ebeac0fefd2cfc583e69d0bdcd5debc7cb39f7d94ed13293eb16d16fffc40b7eb313edb601da97a8971b393cfcca7d7875142ede8ad5dd3fe77715a80926ae12a81df9432977f1f2a95939a4348a39f94e2895a9f15f73b873c758fbc49ff3199a37a2a45379ff483cce0cc063b9c5b48f3b55f8a3f60b77c271b2e5b04356efbccbf8dcdb9b3ec0a3a7eb4c32b69370c2c53723cf736cc36b9f0ef742606e8bb6c508630e5bf444b2a08fc4d28d3e489a5025cc2df8fdb695501232beb83bcf2ec806fa5f0074f964267030b0cedf3e97103e2bd916a57d2c5ee91bea0cd5cf0d1b9008ae182b4d3942772a353d3a5a5116e29db809b629857acbe773ca042aa4a3e2c60ae2017f4c822ded73945c7a9e0bd0287d40de592b5e75defadd8b1494a229a6c951348ab4c569ece399d8994c42c6f2bdc7ff91f725c19e71531599da4ac3dc4fce6ba199f64b3db57a15c49bf9713ba737dad5a1cd714e03f2685b5408986b8822faf506271b24c8ab64a8f9f1e44d92360e3ba0589943d96dfe37b7884ed2b4301318ba7565d65b967badb4fdc25de608b2d9e244e617811756ae9ac3e4562dcc032cc1b94dfa5339906e91d577b6bc123b8d19ffa4f5e1d6ce380f5a17f263e637004654524773b313b2329894a4752497618c28f403ed7e7572d5f23f6353b7ed2d64853333b4f9ada57347319cdab12112141af312be371665a0d03a5f05d5cb00411f50aa78544421abd4b1bf0046fba15130f14112a5a004b053559dcb314360ef44c2dbe28827bec23caa01f54987c3b2ac4bdc176fb950903bc6178df9d3b652e420242b98d6193fa21b6809aaf4cf2af409baa5e88f80c62eb6c200e7c9c0ff7972a03add54daa8046a5ada29cd9c980ca0a139274f43fbe9979734b8ffc5de30bf0f04db9a7711cec5f387831e3af7b70fdc4374910143462a3c89acf1cb71010754e5be1ef69f37681ea6ce2be15da034188e659fd76940e350fdbdd0c148a2faaa5872c9e486aa068976dbef50625d2b3fab2ad4ee19b770d84fa0dc4e0d28373bf77da0f69c1f431fcfee5cdb5b615543cf14363d1f430874f4f78470005f5e7f8cfd3c5938507289654225e61d8c2d032cb9c6245663d0a968805900500fd97d3562bd42f49fbd36330072c8147306d1048151daf10abf1c601e4a5d04dc2c8d893255ca046dea2b37ca0d32bd07a8921629d076bcf75f8eb5c42a019511c377c747c947d5aa010ced56f103f14de40f7ced0cb25009b339da86db2dd487ad7320b2cc001a87bde88e38fa7c888e77165241753ee9f1c41e6ecd26c93b42196482996a17d90a06a3d68e110202702e30af174afe8ca6ed7a258111b936f24a89cf0b4c5775f2aade6988e8136f1ce04acfb5bdd8c69b71143486b7a4619f59aac9815b8a91ef21dabca01abbc5e90b0459148c19e3e44b16cdc97df1d5234b6f3af3c7f759349f660e4d026729db4c37e829bcc79a366060485860a2eedce422be1184b7e0ba1c9cd117769455fd0b1ce83ac7c0c2cef4772d40d9defa7e07bc37513f73fce04e90a9bfb4275532f17d49e538c64aa8b84f750e7029c97ec10cbd9d8ef7b35723348e49f3099114da273451715e5785d54e90f0cdf6f5c2b4959c1f4e1b9485f39fe519790caa8c46fff1c7d66eedff4598c46f3bb8bc51271156ccc2dfe44088ae239108232dcf96bf86ed2599599c43c90a26afacd9632f5fb85b4e03afc96362b7b2ae02a9a56e10d89c72868875f37a47c319bba940a417882cd15cfa47116a86af9deb5c4732e42a2b8346ec70b2d77db0bd4b9861b64f71e4e6ab37ea92711d18429275c84cfc2c3e55c4ae686b2aae0e7165add62423ef0b4127ed5e6eec60ec0d5eaac11266fb1d35b4ca5e1c1e2be52df9d2cc338e2f5664642442d5809e2eae49ec1f8a7e2590311f19871d273ebd3584247a61b210c27d0efd0d44f05c04bd4a2056f15f8bc38556dee2e62a7bf1b01faa7fb873b9791895aa9583ffaa0fb56eec20bc292bb274d0e857554131ae28a6edac62f8e00dd669c2af58c0ec2b52608e17557fa364ffc87d0e759a3a194aef5c6eca4329aab495b56432c9606d109bb6dc61f3424cf68dadbe45c6c1d3f85100b6631c2150f62e4bcc42ed59cf4757d42c490128b247924b6701a6c8684b4b76cbdd21395f610ca68350723524b51709bf29c0dadd9dca7be383ebb143ecf0637ac25e54d8a55f10a1695617ffb828f14ffd9f2018bd440c4b02db9278695149f83abfc8090463022e93e2d9ed39ebaa71d2d8fdd941a224e624edd405898fc3405eab8db6712821b34890dcf7a94cdd92a81714828583a7b736a6295c0c233728c3276dd1be4a5ba5fb7c6e905d3a8f16f1b6aa190212aca5640eda7dfc71b94d37f2b845393cbe590f399046cdb0b2ac6584fbf143471dc21a8e5c59b311587e4375615d64ea99074f50cb5eceb38abd1c5c492919c0d02256478bcff04504a090236f8470c406425e773ec2947b19644386aaf13b8e0fad67d175056dafa5f50856814d831b70d5b28a9a50d97122a2534cf46ca4120de99c49469f6a64d02eefc8e9b91db74ca34049c40930999ff69d044b1345254d516764a8c5c8a3c252de9d32b0475aba204c982a6103e8b8ed56f153256871626d60fe91bbefb7b80169559be816b2c6e60d6bbdf7427c995c81d284feae693290d7ab413ca627ab5c202e564eb18f07cbde060fe4425340b8dfb7a925408f032aaaf4a3d1162fdc33db21264a8f75422ca80b572adf0ff9bfaff036a3c957a573153bdc20b83c9e67b4147ff4bcbe77ca88e4fa50809a534ae34531cc1e0278b2c52495af79e75f44553d705bb7fb282a2ae932fe5e0cd7fa5a7462fd90d0042e46ec612876fb52469285481843f9439376991f6b6a8800dda45b4da73152a961cbe98e4c0ce16f0c38bc805d56141a8d5aa329f289271964f73e4f01b20ff41b63caf570e5fcbb3b77d5984397605481679ce5bf1e8ba9a634434148e6d86431e29d6bfd3957ca719ac695ec0212fd0bd6039e9ac044926083688ff04f97830df9f6eed3c8517620f01b4262c8c43632d9efd097029901947aff2e33c73d8c249144de178237a0073d00bfe1e8353b0a2ed73eeb9a9d7a03a09c806a2ef46e26387b6c28c28c97160005c762e236ef4a019e3b2d9ca96fa060e2a231adbd45aa11984d697982bc18a40e83333f60b8bf6a35dc5b9b492ae7dd6f168991ed9642d6d056ccc0a03aba6788b468a49d2123d860097e066173cc21bc694f595c76e034e32c96849f81d5104b1d3591f752b5b57cac3860753792f52951024eac5e77964eb7170519ffe25ad27bfa0e2f68c5d29fa59be42ea6e2525d44fe24824918b71a811821dde70081770a1c4c132e9b9450ff8b745db9be5071adaf03c8b789c01b73f34e5def2ab04d84739184c0ca3c0e10ee664b887772a6ce63d865de1dcaff4de508d37832e9ae1df1ef996289f5032ad6ce009c806a7cf436a35f27a3c5353f25ba2a67c61e366bccdc34f63a3727e24b98d4685b4a15f58668ee97937918bfad883c272c84839c0f021ef1263c803bb6a35f4899af38c87964d15f1e09fb792e204a06631e24129c01e672b3a4b015dcdc7ded5b1757f02ebcae00027ad2518d88d06f030ea0649f50ae71a5f888e5ae5f5d8b51021946d720bcc9f5208664f2a079dfec335e27aaadd6cf918cc34392991270ca0facfd3c4304669edb600e601cf5602bc150da3dcdf3de2997865789a2328a4a930fd213238412cc3595929d2362104056ce26514e0e08ba723b675eafce35ad342baf947718688a0024a8bd34322c7951a530392a5319c587eee2dd012ac5c9f8b9af193d737fe7223c5e64c5f24795fb8cb81ff0305d6f51fdd16757145593c1189541582a12a088f7747bbc250d13766359eced83a44dae641b24ed423002ec168e57b874e0eda36517aeb9d3581edd35ed8966f7811fbc6c4eb6daa451010c14771df6ecb1ff9d83fb3c4984bfddd539f58802a398b06a23fbc68d92685766e70c0eb6418e6cab39e5d95f444fd1184441a113dcba7a5018db0560eee1ccf25008872ce97046cb868412fe9c16d0f72fc9d150b28b8c5a23968005cf1be4b91cadbdfe63b2799dcbe950f051e91f0515cb39c774fc5a73914432ab38852c3c6805039f44ffba5a62445876949679221fa5951937455566d67cd55ba30f5076b918ed2c501d8808deb8ad28a0b36e48259f502ecc34b6bd4f93d9cdc6a5625dae954e91d45b071dc73c244535fe92f3773ad22d8c7e2ba074c047f84efa588ca4b4d5c5b3c2175a03f902a8586b3c24599adfd168ebdbca2260bb8b8cad7eb4bddbc4126802831dc4cc834df75c36711467ef636769fb7b228ddab7b2dbe9a2f5065151703229d7a5cdf95d8174360c558acdcb7e0a39386062c421af6842eeb1722760dc8e9012d07508bb959894cdb2abecb6b141dfbf2c4b5710c98180a64a7d6cdc742ffb203ab5c817da71fb20f65799189d6517cdde8e26146bd11cad710e13b32ff4ead8e1630ff0d446f6880e5f1f0636a9fb8cef2070313453d90e140bcd76cc0d85e2927f7a1c215716b31618ff410d8bb2573d9a0aa6154fe46e54171c8a1c3bf90afc9ddab3c68f160d7e5de8e1a76d70a434f576ce78139adc78de76cfd53c0c4cc8a249f41ec643a16c563d004b6cea91e9c043ff95d5ce0b051b8adcc8bc2b27e7ae7d4085ae8cc4229a10ee073518586863a484f14f184083ca9eabfc9ddcafb31725feed95748c07e8167f5092202cb49185c07a8f6a071051b3a5909fadb6eeb81115586c4e897797bf0d19d050f02e6f09da3160deadfb24d2dea448c997cc0eea0c28f41833403df74afbcd70763b03a12a277b439a29ce36b5add415ebb02873e07208c41350b4c3284aba8b2ee51bfe70b538a600a8bb8d5dfb2b8d99fb45e96a3b75caee89bd923df113c32e0f174ae25f090cceba184d5f1bba32ca94a7f1e3009119abaf6958c3fe1703897bc78f9f176f1d2be3d264be1c0a80f930e5b9da9e26da5fcd95192f0390a30f81014feb581f01ffbb1f13688ad78f080b6b987b78d5125412869ab58da06abc212c48ef2488a5543da7c8ddd1a5dd48ba4ed2f56440d9fa202f9455bddeb2dff06736e2b4aa2f1e29870ad2ed868d50137ad81bd5b11cf6ce17b44ee13f2dbcf92fd5797220ed2d183e3b351b43248c72bead5a33a84d4f6279e52816e0b81a33ec50947cf5c6ab077bab9e698ba97496f39cd521b9d6aadedf9e58263ff6368cab1bfb22bbc4a26b003b9167baf9e9c6d8792dfa066129a7947457af9fdfa45513025dbf802fdef728285be2a7c9a65b0e8eee4436c98549c13bc8579a1d036a00d77889c200ba05d70c5e6c892ddcf67ee412ff07dc8234d537d641b0d8d161a3c43984d123c43530abf0f838d3c2682b92f23ca99973b1d825606486105dafc318fc0cadd70c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
