<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35116fad1e0bb7b9ad6dc421959f64a5f1e3fdb7df92300d7d33fdad6c93563159de0fac1272e6ac07872905d5172932770bfa9de2957200a16e861a6ff3a50fc19b4bca10a39b1e3276500290c2012443e78e385c1bff57d0e33cf45e79bb6875eaea9b08dd9b4c787bed151e5f4d4aa5ec04213aa0fdba9edcc33cf753716adc89f79a0e1860f2c02887759ff2f7f72e9c998a1982fef0f40b32a278df2339a5f963945fe4ce885194d82f95fb5a55305a67f03a6fe2b3ddbeb157ca3e82e993ee41e002436ac6ece8fc4c9fda49b807adc9ab0d90560a86b48d21df2d74bf7bd5b0e1b4b1f726a9e083e545c1ba3619979fcf371b68ae2018873fa1b67d19fd39876a9b58b7358a56113360c0acd55fa3ef7f8f50a489909b02fb400f63c0198e5415694a702530269d655b965759aff1218bf78c5f291fd680bda0d8d109caf1514d385cef930baf61a22bf6bd5bc02e66b3b4ffd2f0c76dd3fc8b297886dd690262a8d14be5799b901ab4e0d1a89d8d3bee05ab1411c0f9920119fed1dc0bbda221e50023a5dc6af3d121836ebe26e8046569974661dc150a4cb37e47a70696808dfcd74210db7559085b7132d887adc7fc968568f149a389bf76d7a37323ad5a2354c92d841f8b8e25851c5cbcd0ea129880c53b289215b8893cbc1cc01d890fc4f475563e4ebd0f992bc11038dcafe78557b5e79faead0afefeea2a3ed7f3b7f6b2229f3f0ca8c8f72bb1caf2cd6d0c08643b8aaf8d58f034e9ad9cf0847d678eb2723bfe69f74275deecc1db3e09efdf3f172a4c79778c5693b5732bb6241c9f1fcf3d0eec00c98d49f4e2cf4adbc30b39c9ff53986de2ae0a660697a3f41d05d83df9586668413c4eec9e961b43b53a694b7f68fa1ab077d6ed506667911e775f9b54820a2be5090a6d118b1868c60cc4f948427402ce2473d3afd1f688daa0a6f1916204f9d68591a4988b829f8eee1c14dd8af6534bcf41a6f761e5ebf5dac304ab2632bf981c8b0c14268e43e134b8d07830e783d5bf3c21e96ab0f202c808a6e592d7be8a6ca5951ba546bf378c22869f9115396cdec1134534b62c5e1bd877f8234dcd1154b63d44f26849cadd9ee58221002fc0f80441c497ffd958eb541be6ca05ac920c0ea882edeb93a6e20c2465091384238cde3e38e6dad0cfb53db74799d508fc9130631910a53f916c0240dab23c07b221d9ff57a557d2981e32631b8da082c378aa9147ef5ac6e63524c80a2778a7f42eced1a17f7ff932f3a2e06f3d92ca5dbef5883809f32cde28b2e8f8d978fa8dcbe99dcd55bcf6cda9ef66353c2d51d2dcae5ad2f33d06b4a6c2d08cc9f28a4410a0c740ab1902ff01ba3d9fd52f328047ab8705831ecf75046e55ccc5ebc70ad88a3eee73b4b53f54bf3171405e7cedcda544ca42e0f3d5fb58f9f5880bc17037de1f60542fcf60425b260ed249a6abfa9751a17a0e5d80b695c3758b9e6dd56e0fc95903022e0c39eb2762752f12d1884572743f1b504f3c6419f1a14e5c99f502cebf94cd9064a494a6fc98ef2f9ed2b5b039294657c364839eec6ffc8ce23bcb6e3bd9f2c89cbeaf5c076887f276b5285ff2c58753c225c735d71f48c27155f593ddfdf5e10136d214f3a55f575cf1af41cc3df7e93a459b3c243d51ef241f38a7186b480a27122cea2efb8aeee6f91bab039de154351bd3ac3a86c4ddf1c5251e82ea79e8c06512e32022a46ce13796807a09c22f00e81d45d55b909036d7f6516db403e893a906324f938109cb9db006700215128fedf5bcd066634f544eff86364eead6e9b15b0aec00e4f7603605f03ae0278c36d6e707d8fce68a3e1d59bcd5e4c64d88de047eb6483bae28743b555a5e624f8dc228e02dcffc867c01d59cbd3af5f7d655435a18f52875814c46ae909a3b508644e97f3d57c529a363dc32881a8d665ff15558197f98fc9f67be79250e40b782af079e6b1067201a10460f44fe36cc00eb1f5d934c0a711db2d3f9868d0aedddb044f6385e567694beb74118b548132bfa4e94049fcb32b7524fffca59ab2bc7535126242db5ee032d896a37c43b6e56d014fa198cf08c3f822386312b169ddcc28c1f80ef6a0a4c1807d920b8f8dec2941620f7213f1255cd2e6d2296de503f6dacdd6ec3d409b0ab02dbd368069b83e60ea867af755d52882b3f0c68bd51a18351793e0053acdb0343789630de49a4a2568ecf07b2b9ca206265e09812e651cacdb2965898d5be88478908895ca53a354defed1f17a81e2fd26e806281d485f6c225d99b67472ef7f45c0ab435cdc4d0d4bd759958093d0831f57421fca0b7999572188c87562375143f6e5f6d11f25a8c5cf918ecba782c1c58f134c76e08a814c69009bf48c1e6df3939d8d8049b9a65a7174edd92758eabe31f35ef5d81c3dfe489d1e54f3c8264a8ae01e04339b3b1e3cbc4cc15c3f1c4f81e76cfadd26dcbad98059e9c627872a2761ce27f331c48cca1825c7c7c34a39226695c94ca18431a535f7c45a5b63a8f2421ee7cb41d74ffb36a3b537ad069ff001ec2c6cf345f9f5e9da57d327b3fabb8ee91e154154505c0f74c4f00a8cc705fc0d8ec96874ea71bfdb8c0e8d00f4769cc6d86caa19238443244fa22bcbba67b256e015ce2a6dd32efa4ec63a7e7484b1790edfbc30d8b986733c4987427adc8de8880d9c20b0b4c073b8a0be5cbc78d2c45298064cf320b4dd1264f29c9d0b1c45ba179db0272bdfd80586b2453309f8acc05447fcba8c3a170137b49f5412a909e5823a17f5bb1b0bd0366245c1cb853bbb65a673c07449846f0733e558c47ebe3669c072d871bc94fd9cd57228dfbff06cfdc5d23e38aa8f97e171ef75e0faf576cc6cb2c40d7cf6c7c7f7dae4f32889823454dee2078554d0dad419be8f4342f7f42b2d1d7672492889dfcc4a596f541c44c23b2f51da722227cc34fb29334980ebddec89c9b781d869654de0b9e18a747c2beac3db8976dbf4879e4cfbe5e5bfcd237ad455757a458c04dd01abd2ec636a5959a08a58bf5177f9ac3876cf9ceb16d731b93b0cd1d3f6e800c7fa71ec733fec6cdea22974e65636d707503ec73c802034d5c9eb2cab2c64aa4032342d416fe0205b355fb5cc5a07022409b61504410426c457d01d25dc80051eeb55481a693f89e5ef5985c30505a3c8adddaa8acc8aa50aa2017060124981bfadf9c6cc27a695e9b3d564e27d254bd137b5d54e869cd9a7a5e19e88945c0acf1f45ff68df4ee0e665e25dc49503de36cfa71c57291e2bdd1d1c26eb52a79e890701b5d30eaf008775ba260785fddda64669a6a1c2af58c83b9e0ebad0181e21dd856341ee7d2c872c440fd035bf52f35a913f933a5f8c6a9b83e6484b37d09c6ca06fabad52a90748f0aed356fb5cb065d32cfd0a8c856a68d9a151e051f2eb49fabf5874a96362416cf7b7119c1847abac33a370cd9125c1db4c344fe97fa5d9cb62139e8bf93e0c32fa1bf9b753fbd240427f29c7907f8ef761295df3ba02f304e6ce309925a21178206b98af81876960c6895f66433b3633f17af073a1ae99627742261692dbacc179fae2f9d6a3e65750af3a7f0f07984771628f4153139854c27078cab56d7335ec3be453dec5371c009d5910b44d569ec6bed63adb3873d3d2edeebaa5d1c0a11574c732a00d8256a01d5ea8ddbfe0d97ef714c1e0fabdc4bec13abe87e51a24797fe46cb6da4c2b15b7c40bc863698beda78f6f63f7ccd62a84326b4fcbc13992f7f3adc01e7230e51f8f7f99fcbd78d80228ed86ec45ff757aede2e5359b5220c5784c123088bcbe292aa7e3f5cc14f34c07ce128cff5f8ded9075e8c1012b80075f06636a9159bd33bb513ca84d77788a6fa9496d69c19c94102a9978c9325a70a37d009c63794c5092847a6b3c54415b3331b5aa3381885b957df870325f966cc1cc9afae2e40713dc3d704c613b0d447e5aa3324eb82caf42d39b937c83b731ae95c5f642e1359f5e35934a183d4a9d3aaab3b96e8a59ebcfa17059287939d3bb897d897c1a38a10ead84ed5e35715417e352e43cdbe24c52ffa052cbe7c5ad35d18bd8d87f5ee49897ef56af9c3b0f517d297f3fd24bb7a80e0a9f5cdb0229723be6eb34bbc3b7ef313c534b552b23ab5ee08b3aa218a2b179d30a61fac90c3c6920b45928c93dead1ddcb61430958fded7e480068c3d7ac3a878223848791e0319a733545dda8f4081b9ab468c0627e98d34fb12bb255316a1c1812968e87ebc928b9be79f5c9f71acc4f17ddfe894b2732d320da73c298048ac87f111d05ae6899330083e24b8ebbafb9844821f8ad37aab6987003f5ca067e5300bca5c85e3b232e6f47118b41eac72f848702763ee21661049735583aa9bf08b1a4152375bf70190f92c02376c81fdb66a15892463abbfeddb8b7e547bfb2a8a1b6aa533e4e3a15b7026e97a64ed12edd285806013192f564d4db3bfe472dd0969e1dc55c141e12e50c781d678f1632468036499519332b84f89d362a4c89d2163d4f02a6399b25b8c2f3aca3f8233305b3dc9b1e150b68a1ef4b782f3df0e28a6922aee8552603ee4c529013e364812e698bcae19d6a75bb92d6276e6a2ec4a06dda594f996176ad66c2fe49605f66cbf4382904427a066ed16a701530bed61347044d617bb7a0efd37b2ae4d00f8515b9b3ddece77679f5d42e01ea98c0222da1ac02e5c1cbd2e91e7dfde851381afbd0a95540e5b5d10f8b6985436140894923e8d2bc4d9d843847fae7467d01eac8ee6a54fa87ac6e99fc8be0d24460e5bfdd1ef6a6a4e04f05ec0bd30c540f9fb6859d5842e82a0bcfbd56a2b1890bca4df39f97677a31d7e01cdae5da8d44405c926cceee2e6adbfb71220ed9d285325e91a761dc0ffce9ba726ad7bee29e0c5f61e6ee9869d5ca38abcad00899c6277afdb648435bdcfe0fe0e0513499acf2583ec8a7c25cb81075e32f1e84af4aa95ce4f684f7d3b157e2c6493ee9c0c02eceeae6d9bc91b79202e668cf5dfd9af40384d731c5734df0e7da65c698f1906e2c9f995d3b6a5f88a0841f6d8d833b970ced1a1ae94c3c32778b15ee581111261b256ddd5a96cd0e64d3ee9c660bc20dc550a8990f6f0d77e239cfaf232dbc1db3f8d8a987f4863234f8c5677c2c46228c724aeb4136cbe501e00633b96003f263c3f7a92ad669ae3f20f827dc7da99171fd12fb8606e38cab1a78864f02054579008762ff90a5d0afb707bba7c44e1ef34de73ccc051fd45de96e4f0347676801b7c17a2ebff528b9a7bc871426e352e482f75885f9f243345139d0363ced8504bf3b5b3493cf1915d2256952303fde64b3863642e0a8a29df0527736bd295ac3e5facccaff2f1fa89a56438344e32e7fcc849f635e9fab78687366057de349a4270629b3bbf3de485f4bcaefa9e31108ba9a89f69462dc0e0c85bfa16610e6aeb5f1a89c95828f33488002bb8d0b04031b1b4d6a65dedbcad531ef7b51d85bbf3a5252089592857c17544e0112710f55bef4dd5dc7daf88b31ab30e6332824e41f2afeba8dfc64e66c915e592a7fe2fc96b570aea21adc19f410fb668f6d76c796b416e4cc815068985f759f73e11ba60003c0247ee3255cd20257d183c53f4a5312a89a53f5feeb4fb0551690f13e5028ba412d225bae19e4475454088fef5ee7adbfba2261bbf9ee03f6f4287d442960273245c6c365a795dad4c80c180002f01e40f7ff5f9ed11f7c9787f3d1e760d55d4a3310d3cde3e41fb812b6497360b0642e8e0b87bac62027a7f6b00aa260afc7a0fc9d0864dd32b2c383a787aca697f3c08a6281f1f5ac79a2ac4be9fbd83428c9083e1fad76b6fc2379176f36ca4e32df9980cd77a64f86eba185fe0037a24f3883575ae9f4407e0cc880513fbda23643649cd3a1539a47f74271c69f94fa6bd4c4dd4d093b92f3f8ad670aa433b779387ada0516a665597a4bdf3abbdbd9de5e7846f17ba61ce0ffcb292831b8ee8bd383d3a2c4e4babaf2635ce9f93d4432053dca17ec357a8bbc804393fc0815f972b5835c5a204a465bf7b4561d0b32908b29abfa2517517d2f736a296a06dcccbfa889165f8638fd3d879de936db922c057694374eecfb7e79d639af2ed047d2e71ed90f505d91d9f0faf7c225e20e928b7d27efa0d1633741218326aa5788332323c801689d0c21ebc287b4bc7b5dfeeb8464a26c02597f4425b9832c3d6f538cb08cdd9599a8b4896039d93c748bec217bfa296da255da4c92c8a5dc4272d695692ceaa347d4ce6c2ebc5860396b5f6d2d9175db79322eb31ccfbdc4cfcd4d79b865cc6e69ee148e87ed847d15cc23baa8a5d81dbc8a36bd7bc690691c147b6212b6190f3ae0353a0932e020d6809475baa74a7ab8e3cfc2cd26d86e8874473ad4298efbb7fa2deeaf5478205cd6eb62de85021977df28aae202314f1b44d84fce59a1418685f7f90a1fc71cd10cd7eab33bbec01c1c4e25b39c5a9906038f5815057681e49805718a0366a5e5c63932f68e5bd5ac9e800504c291e2093ddd92320a42dd5a8a5aaab76599fee34ac224ee65e3761c531d1f61b8007ce4c21b5cc4680ef24e25e03cdcc25754890aa9db9081f8fd0abcf5e94f7383b19a1b08631b1e337537d82cdb69f28e6d76136c0b33979df71abe57fc8cc327c9f34ede5572302378649d3d2cfdbc0e88998fbe6e5a9e87cabb4e7e0a573c342fe9110f7a4e3d06e9d7b80f1ad1881a4fe1fe7e2295cdb92d01ad4258b286e81a7edb01dd98fa1281785d57184849ebf344efa410d2e37435969d2a842ea6ca01502ab8ed099a8008742639d032017f324fad89fdbe04fa586a6bf04c5273536535750b6c39d102ce3e084ce47689250ddcfe101604823dfe832b709dece5ba94d091fe176333f72ace1a54d7fed1579e202c2c6f5631306b0c7020df2b3f2d37965b7897150f81d2dbd9f944dac9590fc4ad361cc3a0f4fc281a65dc0a85fe281cd772d61752b6572156f04a5e1d128f5dd4316e4bf72fd5d8388123a1d4366009f1497049274abb3262f7bcfd738f546f1d5ce1df075735efdaf15d4fe7aa032a7dc2e2ed8468d6579505aff669ff1ffdc015e3627c958c8948878a0e493f8d0a617c025842372f66b01490e4602ba4f9ce434496ae85219a575fc9e3e69d3e010f585be9e9235201441544d86758f0413dcf100a0a4d6f2388837d49d6c5657765d87cb55f927ed3566c8b477a18d8ea188f897dfde48ac70562fb1908ed98132653ecfc0177cec81fd88e59384a96367ca849a0d47567ab4490e108537a2b5534a2772c8dc13b41574e1c0030a0a9b37cd4e66009e6fe0f66bd871acc8194e17a62f560972b6c5209f6a4a6c9b5316ac10434dacfd5c1d26b15319b13cc1731bf1ce91f57d8f3d7454d9c1667b657b8f49e365c6bd3f7a9c5be6f79759195844ea06ba96489f0edee9130450f9d87594ec6f21f6247cf370123c882e4f31ae31e82528f49884ef32fb07249cf1cdd9ab4e809519051fb386103ae409549eec4a9965bce2e5bd6fe948e06c92d8adfe1fe320b7330ca7ceccf6262c5525efc50e610d4ecf35486a8a79d02f4fc292da51327d31bc638a28583bfa13578a1ce071f3bfdc1d7299a44608e8c054c9e8d67359889c0bf85783500983cbcdafdcc4f7a81e28aac4178508ab53466843e378b6fc464ef01f19e4dc39ca355eb19ee89431c4d48c9f3d59f4eed9208899ef8e6b45ebd99da93615256adab62674cb99ffa5420554abefbcd15bea4b421004224706244fdb37ce834bd1bed0bca4329f863baad819913dcfbaa82189a6c3c9fefbe66d0e04aaf75ae11eda1d1293226e0aa8d10de736fd63e1a500f2cf7adbec6c0990699ebd30854165f5690286be5280a94dbf8f49c017f7603eb8ebfbc9e6c54975517a1e3070464a04938bc7a1ac4a097f70fb320c215448607239fcd49c6b779269e0273fe68f786b35677b37fb36f7646d1377fa3ca844e36489fb2f46791399c38ecaa0bfe6d4523f1fa5a6c53cee767ceda91f4aaf0744adc87507ff5317a96acb707e1a58e08c4aaef7673ef096338ad20fdfb330ab0f156b13fb557835b6596830b816c11e2ffd366a02875dcad3e9644b968e7159f8ffae4f678e8c6831ffef6b66ac4fab4789ec6910b4bd1dfb808bb45b1e7ff3a54a284fa351150a43ba3f6269cb8fe0bc36f8ea63468108adcce8a102e04321cfc8124808b54cdb6be76efc26d3be5d6a58bb7138ed243bb794c1eeed04a7f316d9988bab93b36b147bd4245b20fe2f9b98ab049d7b1dc48e63d6762e4183a33f1607aa9ac404f6e67bec54d0f390134a14872c7a56aea81bfe295e817dafadd72be3d9210348a3f8e501178a3ed5934b42ca0c1a069cfbcbf0b8b41f49e65c7d10dca0be33b71ed667cc4a9a8c620dbd47fbd2fb2da47037ac8538d0113c0773e7d6e85d385448ec2ddd8c026ee333ad4cfcff1cf01c07387be35950028b7dfa33fda64030a3451a4486f94c465bcd0aaab3d977a4837f7687dc10ec983e257211ace7b06508185f3788e65f569344e4fb4d6ea86f4ade768444177b79c5b043b4b3131d0feb2f569026b7cbf75fdb1a76f9dbd4cc1d201d0c526b982e83efb3ee40ce50d27fcbd13ab24e0d583bc92b0045450ea81f04dae427ae417783e427e3dd9307c5677719df7e24a61307f5af3999eb9e24b9fe17d1d3375cc2976d14a1a3296670ea2fecf698e41b7389376a4f94d6733b1d54a346c2e54e2d740cfb590f630b312c9d27ad94428676a089565eb1ec9f5e7a18374ce230335b823c1bad11fc9033c16f12d2c922be5bdd177fca601f0d12698b19068e4fe2fc0f589e01f59925884d2756631c5c56fe7a8f7528686691b646d6a3f926e7609e91b0cfc93f7c3e9ea4eb521bc1a36b9cbc5794e4e6f31b9f1c4a2124807cbb98a1efca6d0870f20725a6b87ee11ff5d67f745f6302b7648caa809bac328c06abd6122bdc1463f4310e32de3b3b7065f59f998e25e249eb05786db343461101181aad807a985216451d367c8a980c4ac39283ae32287fb9777073f1c5c6e21706b79fd49f872a26f372e344e6f18517cb3e3df4bb4a553d5c13e69ff1b16c7b819f2a7d4ac39c5cc09cbbd2fd26808a755084cdd87bef6bfa78e7841bb8af61eeabf3bfe659b98759a8c1787ee72413be574be7721258873e771a7d04ddfa588ebf085f3962238d9bafc69a80c6edc6e869768d83ac62770cf7a610ca02b48a9aeed8406658d008486a3d898ec303a08d1d3c342314d6e4bc3f2bf28e589f5363ee5fef41a9551a3531ed72f1154c536cb4713c923ffb27528412b54a984ac75e28440a077b1f24d0c802eec757e7ec9d7fcd991a70f29a34d16767475736900c9ab3167dd1cf515e3478a096bdf0e63a7bcbf262c69dfafa9b60992e16cf4e071443552b52acdde68f103bf340f8c1bca21b467fc1a6e8b3932513ffbb0268a8b012c0e5878a0a78baba4f9f3ddbdca95512c70161b2a1b7e307d6ab6df56aacf1294b198dde90fcf8884108351c94cef234f53473e876d9547f5ac8530ddbeb9b2dd95114c4eb678d64c24003f131756510da337e4b72abb0efeca934cc5be2e827c06123ab1df555d261730e002e6781fdfb6f7c9db22d926d3cb4b0dbd25de80a85627928c41021070383e512f72bbd13d5ac847a3bf5529b24e108d526cefb4f6ded3c45dfc286c793f1ffb6315cb27698064ac35fc62d1d61cf930a2d28877cb0413c0ba384d454a4a2d02ed15c8e50b82c427e7efba0dc19e3a7195a80f32f94d1da42e850d6afd570fc58c8322c70af70c92abfcabcbb010c14057bc122c8676e9aa2d6cd961d29633227770bc9af3598d08ebf47bf3798b90bccd8d49838570df315ccccabd013268ff467c89c8c9a2725a6d8dba95370bd26b055c1e57667118079517e52e3faf572d6ee5c094f126d4c04594b8c67cb4d153f55f9e69dcf5412c52c55e6619ecb9c5a8b0e64f71a67c927ce284c6fcd6edeeb8b787288b738f4009df8bb2105ba4c0f5b7811c1aeda3aeb899343c3c4f783187d0805e34cb10d8d1d8151ba177ca756c0d1c7de1b62cd4454aacb0348288d6983c4c2108f8594c2b1076e79d8383e4d1efb8944f9723488e72bae661f6ee3ece1a410a3ed757a57a85cac96616385c07c7dceca75180b49bf468f2595379480a0fab1341386f9ded10c997e6baae11579b6eaa06cf11584c421a4664b53787bc72c8ca5a46ac7f4636d14e2e6d205d3afee00b670b2fac22cba5a9e7ebadd4ed36d1ad3f446128593ababb7a82e29ae9530ced329ec3aef94f0c59cb7fe7b1f1afec715420a850f53ab70d15a4f0bbdc7fe7e5cbda7f4d6fffd7d4fcd7b22c287997e3e8a5533c070fafe6b6de43ee93741d6c1f8d18ffd3eb51f3f0353ce2f42d983e7928e4f317a80ca837daad7f2497615417924167421a809fd7af5c5e3aae5e0d2fd6454411b14106cc4af641c467fd703261573952d9a41a220771a6dd39ce682f4225c30103448e781bff5255753d7cdc24f6592e74f9bff4dadee81cfc44de9ae13124ff0c04cec6b0eaddf0fa46f3010b740dd7a54a85af5fbd3af0388dbdec25805b082a978e751a644bf7cb9c14fe076e4aebfc7fdecc633ab879e7f675087e374fcca151f0913ec5ab92d3fda73439022be70093a7c07e352a9573449fac1a0224385ac187e1d529e5b8b11181a72716ec3998cc0cb15669fa5e5b1aed71d252e05ee7f3f9b915e5a1465c66154f76bd338c3fe8a0d92f0d9acd5f668573ea887db81f283a5b0f7f3e2188c4267c092410274093c5024f17edb27f10dbc03e45fb2f167be95f7504a4e2954dfcd6b5da1c77e760af447b9b840782124946b057d01c76f8159fe193b2d82e547a26723e46ca6b7266bbfbe1dcf18eed222d804bc72f76709d16e344dda8c9cbcabb0eda9065901a8a17c193a9d5cd043961f0afb7bb694500eef5d719d27fd5cc9947ff7b1b9816c2384825efdfbbc1c34928b80d962eed1184ffa05f9e4b3beb694d0b2ec6bbe8c0f2bc8713887be6dc64b6dd2244c3baaa805bc62340e497e9be19fd5d34f0a6684ad8290fb8fef16702ef30f2810b6ebbde73537117e3e6c45dbecae2af1c9c861cf4348b022eaa6e30714cf70d978342d63d9b1fa1886200694011b4f0ec9a060fa49146e9aabfb5e024c394a274dbb20ccb00be97999e44fc01b75ee208bc0ab7a1ed95bd51fd1de0d58f723368f6874e37e2a469f40ed2bd5a68ace112b1b30b8298bb96e9736598e2ff5e8ea5a02a2c535657f0ec21b73467e94e7b91b95d4542420144dbbca74887fc3d537c2d1ced0e85684f7b4dbe8468baa5e69abbaae8948d5201ae27e85d464d178476c7dd6491a3eef500ecc86e44cab5556b7aa8bc34e0e83ccc889601579ff05e4c3180dccf9055a5f941a39908ab45a22362d917d44f972fa7f716cff022c6954ea86dd57c8db4a45fb00295669f47df01009d43395138c171dba7f5ff74dd7807642c162fe162a0a539f86d0ca6a2c6defc2ca377a2ce977bf0a614dee7aed1ca59980d1fb61a77ef809d6de800f78776e6fa74c23f68905147ca950b98e3da4a6986afd03fd74594ee38ff5804a6d08db972cc8c822beef654c452f3ebd00b0acedc7bf3049fa753097d7d3613b7af2c3780d86f6b08451a0a209a4bbf324c6fb67b28d77181baa84ecd7d76fa11bf776affe216255b176c225bd67d1777dac1f3a7d5483df7d5e40da4388dedbafa3ec1f714fb0551bd18e1e2703f7637d405a41dbb3b69f39c7f2fd6012a6d142cca9402bd16622ded98d48ffd9071e15dab41fb022617250001797797f5c764fa5a0b4b303c9f1095d8e2c4e855fb1f1f03c23b21af9dace7626ab3c2570cf9cb0df4f6db65db86e14381adc0cf36a1e7e6b5c2b96f7f14eb75b085dec60493f8bcc0547c69d4e6ee7a069f076f8830f64b07bbb53c59074cb37712cff26269baa2393939e3f49b434670d8dd1f4ebf4cee7ba7ad23db8b3c74f22b2b7a84e9b5f3d8c591540f1225b638c761e60d997413e2b1a3a66d6c092fca1a9498456ca02119eafa621778d3845a3b3adefc73a4c61507ca772a62dbde12f249cb3cfac6cbe501540a9d61b8ac3b19580c11959cfc5edacd6910e1080d71efbbb418a4bb74d9c77cdb034181ded7bbd3c3791d342a6e99d93359e15261a1e0551a96d781d6c29fa4691eb66549e1eee0a3581c0ec5627d046cfa0e00099e728419e2eba21b707cdc6a80750cc18c9c1a2c2a775edac02daf2e0873c354f5f7378b644fa24354e321da9cd1e5acd308b00b388d700d2f75c2803d024923ca3e7a1234e758e1b88c61541732bec541c842a5b9014e6e1a5350f772c52e6f38483c1a9cfe5028b4984ae57c152b7d3e7b3579e07deb815ec14a364e5863364573bd6642a077de803299722fb0823447f4f1a50fa91c593284bc1a3c59cacd51154c80d16e26cf7f114c6d245f010ab2c5202bc2f29de757d6c48229d4770455e26847ef904f1bdb7b52c08541267bd1e7d4cccad046c574c3f8d9550444cba7c32457b7f56d6ca65fd1b42687026666659b8b05dcd2daded40010aa8c22dbb44a90606008e28e934846e3bac9a92341c6b6a73112d8efa022e17a134f14085166b3723166d88078ee0e688a70a144cade3229c0557076f306875eba5d75aab0cb3c9b502208dbd432f74bf8566ba83967353a54b496f82997585e0f7412e86ce0aa3c98064ff76cc3136f4d7e45176fc8be0e867d304a370c11dbf61129059a7382512afa9e3b9d62337ae8ca7abf9ef58153692de6461934573a2ec277a13fb4aa565eed81103b22d7f005e00ece2ce2e0ec2b5c6544bbfc2c40ee605c5983e2ea519791b49a5d404c7d31aa7c37bfe636e2bafadbb51467105324ab541f4f2efb382693b7cee80d449f9d7393d40762b2d12cf3cf49ae80f5fa6ef4ecd89b3333f630579c308346f1e3c4af1094bf842e86e0d5cca59a99823ecae236661d8e459df9c4c906505eb1d9f23da092421af1a3b19f0d4409d82a7624c0b3562b36473ec70ad2d3dd39054a4928ad830ff05af20b756d843393c8ce31609aa46b42ecbebcb5974f2ca8239bad03035d9f4a2bf9a5fb090d7c8afa8c078b850ae4451a848a028705c7fd74ff93f2bd8902b7b0a88d38cabb114413559323e99923066483e13ab6a213133dee35e15ce6628ba13e7f822e2a641e419f4002a3772e9239015231410cc384cad957ad44dca60eebd64f18ff3d0c1fd6bd81ffadaef011b7e842a758af4105f2d9a66477ae6fb4fb60acd1fbf55a74b061e4e463c56b5430497fe68dc148417622b4dcd25b9261c09f867f6fd979ee426ddb4f967bc1a88a9ac570867c6da764ade5b9cb19bb02ba36b1e7fd9c597ed925a63cfd8a1b432df2e9fc1d3b85768817afed84467b774822e4b15ed541cdf10fe3c11a2f3deb0753399ddd5071e2a0f1bd132ad96c99decf9db526e74fd2891cd2d2b82076e8eddabcc534c1ac5ba0a72e12e84c43d1cb646d74d731a9446ead224bbb6547e7d20d7a7909eafaefecce8659b2c0873e98ecc821254dc1c36062a2caf6d279c6d7a4ac2e3145110ba68401e9588ba16ae746f44305b7361b6b838e1fc75ffb11699a544d55dd7b035879acbee7ca5945443ca0ecc78f017f7002fa4c91efa5e9ea62cb73063d8f08fccae563197c12bc80ba81123fc1843b59a5524fa408bb67a1c3ddf1621d3b8f417f219b447dd73affee900a8d0a2fff58008de32b3590d741c16d281dd3fe74f1b7d8c84cab38198afe88ac66744ec239d07d0c4b12e8893c512d2961e63b8d5838251ad34a88b3bbbd1257927eeb8a3dff9a0ee74cdfab5d320a5661bd142c1b9592a55b260de2fb80af488bfb729064e58d841b69bd76e6b3be5e535a31576c048525a417bf34596cb55b1bb36407efb95aab4013dac36c4ec4ccf7ae7bc7906af5d838c2fe56c0ac705e67fa8477ee530e8922a4c3f943695f1050c12af69a87fc17fbeb92e4f4c496756b432f39e11e3ac72afe7dae9111234549899c387bf935e0c40e726bc60c3a9bc849e9c8726d77a7103c4c03cd6de8618fb1a6aede59e02d4ffbb40321d1e7447fb2784970477c37771f94fbbed36dbd145ee7edb3903fac644aa7bef71351c95ee17db555166196913b0729bc8da330a155e27f8ed03f8a3d6cc437b5398e7d058cf26a8b6f24f43df2e0ecb2e6884ad4effd54a1b9b88166032fcbbefa758194972ccc7fe879bf19a30e20e989e077ab6afe953732d52fee3028d1996ab49134052a8d5604463b3de7c21656da55dd0e0ec3465e28ea0fb0e92ff85b4a0e1787f67467c535813cc19cc5cd5fa6df2d21073ca6616e119fbe4d6e31a79600eafd5ec443bef0325a0b3d203566c1b6540fe0c9b4082ab0bd04a070ad9e3d3b0bfc93ded157fcff7df99dd47a0227e77fd44a5c59049bbaf3159e527815a97d487f7245202660416e899e08e46b4e999f354edef0cb124d6f13c6be21e371cb6e5c1aba6adfc1a1d09919626c0210c12c5d42a0fff6e836a4c7daa80c0165937c51603a6896ae3ab9e266002a1427b9d0a7b0ebec631b511d3ed54b4fb3cbd3cc2626429f9cbfa8a2d61fd083c4197ce083f4506e9ffbff8886cbf884edf95814b6457b3dfaab86462259671acca395b2bf7ca1cdd2240ee89c4ee566e49f4600ac787957a7e403c78468175a16906f85f4e583844fe57189dca94551dae7664faa7087df0213b2e8fb5e627856f6ff3139500c50c11ca25bf9ad80944ea667047e591425a19e14f9458684ceb282d610f1259dbcdfe956ee7c6c5b542b60dfaf7d5940eb46584d5a3b71d616419313d192ab7f2caacd22c48492264d4dcfe1906ee57abf65b9e522bc7034906ddd21e22ce22f442d33fe8119e47c9afa9ce777d3bd7d91118ba7361a624a90c3472b67f855f264d3cb0ab9ab8e309c2d1409ef07971aabe88e8c05235428a04ee623fb96260c3b3224d26d4d8a534af06a9a33a87f004139f87d16b3dffc1c17abbaf77e46cba523c453973b0045cd4bb5e9247cea0686b241d4bb308fe3de97b3fa62ba0f5e5da53189d5fd87c7ec32e5de4b68e7b46649427f555dac17cb2afedc475c17d3f8cd3835aa2785b33d72971721fa5a9c80c2e8a698b185db4cf306647ef9d607c5d7d1f9d92e37e5151ed95234b6b54421fd47dd805845530f1d9c1f48ede5250cea336f3b3d6949c22f68f83e41307ae5dbcd1fbe49a0bf12e1c188eee165fea4634649f8adaa9421e6ee306b797affb3b818be9299a5b8065d26260cdb4e5edc683f4674641cc8c049bf1200a237dc136d2d6b48c3f7b5c98e0ee06655565c985261eb495878f23adfb8b33a818c971a203d95b6a6a5f7061744854b101c533510d2991148e721cfb6705e8ec1166c4f884b6d841be8f91464fc8c5cf06967ec77bea59ab40a5f046f6e97b46a03f35662912993f33a5bc36d948ad13af6fc6d76532198dc0684b94b0e96aa800b9720bbf1265fa0902e9fa84aa12df398b5c10b21a1da5a96ab1814e3e5a415ae80755999a839752475e3e6814a6b7c25f8fa8c535538393025b4196777267cbd4f7538085b540547b2493e5f99eb58c7145896a60c4122bc7881f53886c9d46bcb4d850b29ba67394ed1a0e7af4d2c26b3df5e62209019a2635e7a6065fa7bd0ea5488405dc9f1bef72be39994cdf26e376db825f586f7d37da9202af0cad494f31789cd1aca3a41a05d61c143fd8a27be0135d642bf1e05016fc091454f7624c3c64ff0cca1bd7633d4e4ddd8808bce3f3ac0cbb0d64d2fd15799992f79c059163cacef4763fcd130c3c35d1de5d842374779c6dc806d9fd7abe8f98f52b82e1f443c0095ab4efc94bb50bcd685d764ec51f51e4bd42a95850e18dd83d2181b4afd87d4511b71f7449f0b527b19ad763f2fd262f86c6cc90dbf1b6a497c912fe0215429ae878705855cbd5fd186b6948ad132fe2750345c013072f9b766c1d56413c99f024da824bf23acceac3101dea93abcc55b1a6732d69b590b8374af4f4affe0efe7ebbf7f53dc2acc737a20d41375d26a28f67d0b6a558a3dc9c6328f7492a81fa5bf49ed1a2c7c7fc215ee4f2391198bbd5212eccc16d194c7d8077a3da1f0a2e1aba9fe7e1b9a9b316503950334d6113a504aa1c66422413b1e19715b479e78ff2498d797901182913cacd90c6dfb19ba0158a257c579619f921e3d2527cba41765d8d2a90eb03c9eb3fbaf40c1cabd737b7c2c725962de8b0657e6dc51b05743ae2de5f157f898680bf86689435fa8f07c0f09ba3e1b75f8f949ef9c3df2d90148effe11b36c47718b35be790b6404f9cdcaa1ea8af03d58be957d41a7e82fb6f9eedeb214dd51551f723ba8f9b577da10b24c94c0ed5afc3eba11789656d50ab28453bc47af1e3b0ca769780930cfeeb80bb585c0869c6bdf81958543430b862eb69fa0909bcb380859bf3e847dec6c292748bd2b59cefc84852c09b4bae0581abc51e5332227a21e6c28e507a4ba5ce6ea4106af5a3e0de1b4fcae46667d91936f099d36d3254d54dfac37d92da6e2622820f7afb3a173234f99e854479823fae2a86d799cf043e89b46d10941debbe89c3fff4220390b5b3d800ba1b2f59000dbd9c8b1c2915fc7e8fee78d2f8ef840e34f669a00c786b200dd4b4d7ea16c73db578812d65a7ab82f374e0dfa73c4b4c2bed0ba89965c1e307378c1494e637ca78f5cf433f58930bf9b46e0d2673b5d83d961b8475ea4a1f141f5eaba4780d6348169c2f9a48ecb4365a41af1f7d8d1ebbacd78c4ace793b8521e607abe85b79d032e5fa70e35fbcc0abf73bcffffbf1144aed9244ef36f9b56459d2d60a9b5dc28875ae594cc2e9856f0639fb26934f76a671514de10977439f6e5fa1e52bec0486c8f11eede5acebd204a5269cd65a5fceddcae5450cfe95e4a9a35891379f7d5bea2de723fae3a37eaa1435e1aebc10594503040f4ca203bb1160a461239c4b61e1301ea6f4edc5b305e2a3d91655d96ad8644a041f31843f91cdbd9f917b24271dd3cbb948722c4e0afe340ba9b514989b5cf4654161938c32e303c98f090f86e81bf499164e5fb9ab599294f4a42625bbd4b2df9668e9d1d03cea7d8a37f24cbb7b209be483145233008ced9bd764edf2761e408b2040e6c97a820bb82b0a986c96170dbb1167291e2e637098660fa6ce8f12e2c458938d914ef52837f3a4bd8e7e6b19cb73151f53331cc2011e2e84743af28347fd3f9e750b738d52b1334b06a3e40c7560b979f030f3082147a9f4ce1cd1367abb118abd7a0d25e196299002b39a53cc59ae8deaf87dd078866f8b3b946cd5a1ced09a43104f75650058fdd293bfcb7d4343c6436ae1838027187599772f90d6b9f76547655dcd59bd05b4c29e75541a730f2b005967782d43790b78fcfc5709a80c751d65e531c0c135c2a54e1e654d3fcfba60f90c7d98b905feb57c55a7cdcdb92db86deb2db1464c5470c0a9effe9accb6582a3796dee552339968f75bf95bbd825d98b7379fd757b602328d4407bc779c5f406ed321fc47f2f3ac78432f06aac58d6d9e0a02ce8df6564b63783f4022883673bcfadcedcfc5b141c592b799bb5f91a2df8bf120683c438d4e494b6fe5db8c7893cc99abce9e17cc6ba2a58b7afdbd70cc2f5f2ac4945e5b830dd449caa95b6445dd7b8d96dcaa1e087f5d9099595f452874eea49dc2dd83937549a1b2a317bc16fbb32b56cb9fe36e2bc36397e1bd26b73cf43fc3b7b6b6ad8e5dcbc85e81dc18cbe0ffc3bf150185c7c7ecaa142fc2cb04c51f1e343def75f6e47f372e7dd815972f53100986eaed92fa05815d97db01bb25198029692be39a12a749e36192a5a62fad81d12d44c2cc04a16eca826f316800374bc5206d2489805aec3905e71f2ed01e1df409ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
