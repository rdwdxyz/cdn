<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6d4f7860606e063a2c4323bccd67e7e1e6c1afcc24b1aa0f8ed8cfcb3d7cd2323335233eaccf13ab47d62838361ab080905116102e7255434b9915db3c047439a2946d51e5f3e073a910fbbc644d1fb82497a7a771394572661da14780fb15f37d500ddc7711d82030a07e3bc68a754b83693d9a8cd91a6b9c918c0906000579ffc12fd4f7cb77ffc4d37809e321be1f445bcc2224f0d033f4e23c89919cc993d98d6278ac1fcb4dba96984995d94bde91aae23bca21bf377ab8f0277db59e96e3de5a11c93836e8421bb59e4038aa8b845c07b14e8925262bf9510b9a6b6dda9adaad46434179a3d2cfd8f9fead8202003d849bc404dcf579a93a9c9b2080db7015c4fdf6fe76f4d50c840a635d71d2921388a6183bf67bea3fd9c90edff3805561d985890db3f79ca372682b363d4734c016e2456e0ad0f3fae9d8d88d9f45ea8f356e6cd8f0a0386387303862c56ac4dbb471894c148d948779fc1aab80b7b996a698ea94ce085547ff1aea15616ff9ca36ebcad8946481933befda66f88c34247c1c1a538b01bd6c02a40ccedcab8ec80f7d0ea0c97cf87bd4e4cdc92336b32ef1f1462c94350a3c755f40d120e787d0cb10ca413862c631a502b47713767ff5662fe068c24aa3b6861d4bc938c1315838cc1b8a7b07b838514b435ab683b9d087c0475b05caffbf2c75e720077bfcdb583ccdc5689cd891d2b9a01feb641b7f9465825fbe45d504f6d12ed80b1ba77b5ab1912c90f1fdd243cc692d7b5bc9621dc874455156323168656151f78a6eb171914f64f7efa399a2ae9eb785e13eb1f6e47816b1b594bc637c621fb9300a8eb27efd2515fed25aecf1a1e8e82fcae1525a79ebd3dcdd48b3eab13e1e76aa63e6d54e23487c4079670c181912c0f15252ec0141e7304c9090fef7d88233126e09a13e47a3916b2d0b109544c9f11deb415528f34eae9d8f649ab295860a921aa5820d6553d70debc38738b0e2e3143e85977bb325403e388be396d95d41701e621cf2358a71b37c81298e7c525d761ae5025c2d67bdb634182521a9c8ec2f6594f570d4347eb506f6dea6419a10c40ed056cfbcc7fdc3830c5feb2f0580f76c67868df9bce1df08f341feb7d5e8eb3c28485adbd592b07ce27a7479c7e7d5cacfdb9fe3aa012c4e130cc3d026f4e018c5a685d93cdfa5cfe70c3fc11ad9c35fb85a6729f61590aaabca352b29221f901bbe91e6e970f73ec454ebfddeaaf00b591d6c74d0ad7e2916a315b1023aa621a5f3569327de4b5bcdc5c5c13d2d4e57a839a3a773f4cb21dc29f24f7e74eac32197ecf0e6ef263b573693ae96a70c2352e1eb44ae9606ad39e977388bb5ad0e7e2cd6d06262180a942024affc1c75a7d04f850cce9456467dd676f187fa584219e67ce417da984cb7e8c72b4740f781117e2e2462f0d881f504de9808d6cff4c996264662f4d729f1923b40358ccc3b632ff8642d9815e141b9f8398aa0be99f1788b8327c2245d723c40c3aecb7a14aa1244ef50ef299a0b190dff42472202820ecaf8e4928845b66f125a40f343f1eb5916709351b8345bf067ad52fefb10ba065c365a711d3a7a2e91911f9bd8a6319f24d1dcae7f2456d00018e7f61bb12e1139539201123062e5663b44735bf6cbfdcb5544c2651a1e37063b0b5d53ac3fa4b8c1c9e3a420944165c2fc81dcedc61a77657e6ca24f8461d8bb0db2eb6529ed6aa49e54fc5a2ecfd5846f2d875aca03d6bae8cfff70692f56e0c217c1ab10cfc8edb64143a061bcff42af546b4bd8337d0ca798fed326b41beb86e9c1bd1cbf99f0986211a08268de144691367e462752cb4bc259603478b0fbad7bee2fc585d51e4a6e379e7306b501eeb3166a827b7e526bccd1ff213840eda7a1320348b6af69977851a1a3d7d68232a55e50c620ea69fd2daae18f1c70329748e61852f0c0dfd7a005a68c2b73a90b6407da138cfc6331db9b917cbb5caed208b53ecf6de82b1088006c16f4ffaef5e844d5d5fe99d5095c0d0f9f8a07e13d076d66401605ba17687f5ad8463ca88c34aaec20819ff2c6236d73a012c248f6350f5267159662ea50b7216a1cd8183defe35d5303c5b550df58616e280700af2524b7f4f35c0d48a53bcc3db9765cf9fecee2f66bbe56898843ec461150e65d5ebe7a64e99ce39b9f08d8bb8301166c7a8e1b2f35ab93dc401c0c7c84526a6ad0332aca3cf5b8a36181dbe24bcb9c3eb16d893d28f055225ba4da69f4863958b6e6f38007dbf6afa3a2cc4c4f61b9ad09b935f0e3191a0f64226a34c246f9ade57f83b9f6ae11522243ae5227d6db59de86b7c3bd531e3ed132c2fef1a570e67fb941742c07d8f88a2f8989aa94325ea7c7ea72b9e17dd0d49b74c8b252cc64eb55c903c580f0348d514a830a46f954847077519a7f5eca687496e2bea4fd346e2b7f1dc3370882883f980124a216788eb128a58e4d54752e2b9c2ffbfee79dd341d199d8554eb831db66f94995eb09942c0cf564a47bdd40c98c403321774b9a73f0462b794e82e4d6d800f6ebc061b296f7a0b66c484fbfa90e23db79daa5ce1393386a2b947f6bde9620bb6f0bed90468bd200bd5589070f281462f9d542ce187451487bdf80824264be7885cbf2d1949a2810e6e021b6eddbdc27e3369b2b4f46acd5c8fba15baa254a9239bb3fac27a16ed5d3f9f60b7dec9f06bd33a69c5fb14a773ccd6cec5193ed08f52f6a001a8abddebb781a0d94521bf42a6b5f1904a30fdbd0bf1cd3e1d092db7fb7903b43284d38997160cc09bad767667505535c05097d537bce2c888d165a87aa4b1f2a82c037723a703232ce9c33597a8b8d3dafd0af0c26e96065f8dd555653933af5c8170fed907fe9fea206f51aa0d3d3674ce13b45205fb5c953ae738220442401e048f3280c4ee5e66c2eb5f0ee8567583cd31708c9ac0a9180786db0c236bffd14afbd7a4bee60cdb38503650bc87f9bb68e1c38c61a307fc06217a89ef0c2cc8eb04d7ea32fe25dac08b10cafb6f29ddca40353a677fc2c8fd989d616c43cb53d76c4b5673f0eaee0175cc2e1b0386f486e3656c5f43b1ab89b4c30e25f649b2321e9bd3bc7ea9917fbe1f740b304414afb61cf5c15c2d976a6d5a4307a270e8dc20de5cf222eb1582a07d0026984e37bdde56213dbb4f2f4196cfeb902d717c0351d7ad7749e66b35380ee2dd06b2c486d529f59291f25a3bf86a5ef1fd1dd6e139084ffcce9fc7ed41f71ad6cc213f3dd2b7a9f78df720db24b9886fc48b8405031ca764f95da601b1a5d2be2eab671b46d1215780c56a8b0eb5a0c61ef2c8dbdf28aa71d038319a9fb50eb47623d3cd8c1b701ee7d0ee063a3f0e2d70a334fcb099e7ec47c9f58b4bdf373e10b75415f128bbae39023989f1513279a0bbf5297487de879ca1dec8e621bbb0ebf0bd28306e3b07d703beaf096019b96cbb10b9476c3eedca857d5ecce46f7c6836569015b6b92a9663c7c669a0318ce90d6b96f15b941e6e0952a0fe3c38ad958aec4129189a007358e65762f6b121d114d6fb37b0b2fade4f994a9400f1c338786cc1141d7bdd9380db42ec1ea20fd356f184a8ba32ac4423ba076939deea5d75efea361dbf499a7efe26ba544bdf07f924ffc6002fc203de9d040169b2599f2aac88b3a35707fa0fd5ea12e8912eeed1a676b34c2c8c37a2af6ad3688c1effe616139ab4cc210156e23a82e12d3896104ed10f3b9946c230cf8688ef381a6fc232f6c8b324d1ecf830ac1c25f8d1402a73b09261de78cba1265e8d39602f95d636a3bc25eeae01ad432e2db5fdc5f9ec2d317fd377d89d75305ea3aa335020c0a0a448fb44f056efa64be983108384b42e4454f5cf9eeb5712b2f68280a57d6db147fb0031d7477facb38f6bcef6eef0e9ba96caeb0906514e5e7e1906508b2b0869fd85c94575217d0f6278798d30383025a780e633615b438fe1dbd2d31a3318e118fe23ec3df90ae853b58a491e108c0eb56eb9328dd8d78727f40284120f707adddca2e992bd55b4346a1f4437e5c7b446c67d23d993ab0415be3471db819025fa1e2f56a4dad6fa72c706c9ab9aea100f0fe38f0ca888d19106766ef10d27ce87ce5efc05b889c0aeb3234d65cd447f52038e0f8a382fbb0b4f6502d961a26d1fde4aedba33b3c175c2709fc22063374df96c0f522355243c408f846125c871c779fa5e1c48d19f32b38f679497b54d996abdbc4d646cd6de302fc30393fee04124706ae36e50f706f43f3f4eec68dbee2579435f2de2617c9d01242c86319201a2233eee669a923d1d4c129f8f3487d64422450721470328b530b199a57c5a75d90c0d7e2628e6ea960cc7e16b5525455d3a7c8f6187e100f0112eb0fb1363ac0b73ca36e8be2127c93ac4701d655c80fc6e7fb6852c7d16cd31e2890ce03936ee5d2589c0a9a10ebe511ec606672ddd69ef0ed714cba16161689952bfbbbac519ef9c7f1ef4a43779fc7c1b9d523769b19e85fafdbb3cb13ad38d473debe1e8f1efdaa916480b94de7b9308c18f27c679ed93708d44113d0a6ebaf57f96093e365991d376669434278ab24ecd8232e4a9a93ee053d9343955c56871e5934e53563f9ccb863ae784d9f6b280919c6daad9b3c5ce26dfa758023d4974a78d2dc0824a72a7f38d5a1b480da7edb193aa5a6db2894ee6efeb2ea523010d311a62aa2620477eb8f64c205e07144b6b15fc8c01d3206dc5669d7dd5b7fe497c7c49131f920d6d74b464c7c11e49e2fcaf2a8fc9825949ebfa479029adfd9369390a8bec70ba6f2dcc0d9c63ef10b8250a59d793717ead7d5415435ac85422ec595b2d3397539ceb598300e969f93ba9188580bf95a93f44ff3761f7794feca8d93d3893342221ca76840b3c14246b1ac15f3168b21d6026ab7938fa0eb2c43be5683a37b204721245636bd8eee526ddbe4a775a407042a4a233ea321dfa4b536a66ecde033116686d0ebbb62de0b7a7df813ce3eb002c1930fadaaf4f174669e68332c3a1510acb07b0253ebc854b879dc6f07947e90f593173c51b20eda2159d8ac77b0745cf9bc84017b58cfd66f3619d174d8e39d5483876727c43e24d47c43cc04c13c322aaa1030b22dd1db9ddac6c38f4ec703055c0be234bb744be9c3a7671835a0ae12c6ffa00ba3d0b94715467d97916f09da67053d8847afdb58d4cacbbb765fe70ff5658e7885d62ca15a2c9d07177075e040ff5c867d16aebb8890c612d1e48027f6cae68e02c4fd99c0ab2630103e0f70669e6f1a43cde18dd24b61bc2ce8a5adf4784c470c0ec55b4fac0cc2975e20a5b8de0083834dc4b4eb8d4446f4456a8d16d789ec6257d6a267fca9fdc1cad25aad697846058cfaf915e474ff1e4bca11573801b71d7e67936a84d282919bc1cc11e0679b28d9b1b3e9dba14d9da951ada2990d189dcb3dbac40a659940a2605f75debcc227e7bb4514daedaa80489ac4e4db96ca2734e0e39a4dbfb24908c2a302a7ed82a134b2d889b5e8f67a2b3548e7a9391b0dcd8aed1a1789f81459eb13d893e8675c34be6c67e24642b463f99919dfda795556f583e49c5b6545ed36da4e25c6fe8d044262a187a03f51dac74527269dc36134b6b8297fb4ff3328b91a76ce89a45c6f197955698bb6d854f52311371a33ef3d48243279ec1e1ff020343a1d90e45b0ce54401e36c67234762e5c95c562cef8be89a3bdb503b8f3ec95a007fd5c4fd2efe30892d09f1c6368e6191753228662b60cf691f20253b4578ef5bf04224c8d5f188d642db57093e7d0d41210b34be353583d80d8de579a233be5c9e37630a5595b7c8e41d73a373e18373ae8ec50758d296650481cf6b13ffe5020337aa70ab7afea968918bb03e0ebae8724ce32e50b64da22d360786c9ee7f41e9629c0f96a80d88acc5e341ce7915f997da564feccdf6086f959a489a2b5a25415703d5c16102598e963c219f8b3e8194396e561973a6932870d0383cdb5386912b020fb580a1c51062017eb7683e67d71b49ef1bf93627572187f913655258d73349b5446fe24f50ecba488286747ee19950dc24f66d4daea5f174c06b5b826e4bc9f85746734caf3b29189df7f9c3ea05ee71bf2e99fc4f2db0f7c64eeb8cd829f83a02c8d96cba6551148466503c43654ea11dc9f82e8fed8adb2af8011f58bc0b1d651a2701f6cf73caff6dbfa600f5ae3933536ead2d8fbb5e4033bd3f38db3332179eea8d5678cc71355161bc76e92e2a077901058c9f7cd98ff86b9cb8fd8b0b17baca14b0a7520aa429c57c8cbdce73738c5ddd4a30c64df1022a3f261a4d903bf116e95d9f0e4d1422db3be26cff67e31c38cbf53345769eda49d45fb3f41fcdf204129784c80b1d823a5645dac84c96782dcc4c983e83e2e743df1122b1f1bb21780d4a30b5df0837c0d5b17a5be4909cacf2ed40dffeb54ed0eef4ec62089b30391020ec6982656dcd90893fdf91fbc83c99842114bb6de7a14d09068739ad1fed1a169ce6386a79ab8eb145b3563f349baa587b3418f07d8269dc940d3cdae9b26949889f1b9bb1a1e31d61c9a3a9f4db0d5fbbfcaf66dd3c89a2681ac27525c07c61cdd09f15fc68a87f7882c76827e8b29bbe2f11878f7bec5d422b9ffab819eadf6df24594476d123caea8df6dc67f3dc1f5eeec2a9b2ea8ad34ca387d6bdfb2e7574497eee9c8fa07c41de02f5cdf2d1f81fac1bf82a7826aa8d6a1ab5f108f2b898eaf1fee6abc4747acb1e1e76630047b94c34538cd9f76caf48b302fa2d6cf2b10d5421ca8316a3e1aa0e7756ba3cd0f528370024c054b1851477d5bc5f0cf9bc67495056e5a122bdb1bc021375a100a8f685b7c0499df7c3d7da537d019f9127ca48f78124b31f7188fc9fc52bafdc2977d05cdd935bc4cce3cc44ebd925763e39891b59f36e78e58912c0235498de8f664add72b27140a01c7d5a8d038609e7c3356b24500e98c16b6fa7000aee07f08d6772d1efb391055274a55ff518464167ae43a82ea9576d12aabac0cc2af291763f414354f866802c7a38e96449cf2c283b94060212cb9b77a9ec5d300727f15ee9059bca1e4b7996f2c716feb84064d5309b3cb670da5c3b3a6ddcce7a6669c44d9e8dfa75a67f3cadc34689b76a9bc4dbe38274ad148d82585aff1aa7e9694c12a3b02d2a93676e46ac8168244af84b3b9ffd553b7e4948c3f41c4e768341baa207997eb1b8fef4e4de82402943e9ac4d8675ffe5413343756ecaa8a9761d894da41a4167ac1d34acff0cabf09e330b0766eb82e7c6a41a637c87f5442420b61d705f46ad59b430cbd0aead65e3320982b1f5da39a9e0569abfb16fd0673589bdaeb588cc9984536498102d32f6e1cacb38046ff3d118733361a180c24f591008dcdfe288366a3ad95931eccce1e9272c45d790c35da7535ff1e53c840eb367298a74f4f3e6ebbf4f63cdc269fc1b656e38d2a7375a51c92f9ca22b407b874eb6791cb3e089b485c4663b77c0423104d4f0544e5c29ad32a17ba1b977b24f57dfa9bf541c1fa49cc428d8fe6510caccacbedc3c4a40b2250850d5d88565a9ad5cc711b44bea99efadd94f692328648c1e8e55dc12ac2cfe28f0f24e2db80d50ceb25cb27e98ced45c204fc22fcf3855129d74b563a4ae8bbd8d55cb89b703be3c07447c25d60a1a532cdc7a8296209a59cfc92421c000352d199ee63631f65a45cf1abe70686c855cb872c0171654b477fbfb4e9996953a36178e0d93ee2f95d4865cee6a13e67720098b00f50b1ee10ccf677ab68349ff8338174da7b36b886b828c29a6ef35983c749296eab05510603d2cff232996cc6e4bce3be14f77046b83f2e1a9d142ba54e201ff04a793579fa7b9a5fc5a6119bf0651216bfdd42469e0abb44cf39148b8b1e0db14f34f3d4db8a83ca011873ba63e3b773acd0e570e7deea82e355e0ffc137a6d7b1e14860d3124ca69ce75578847597138f27a3bed1cba992c93715952aef3a68a9d40fa66fc08a7c9c9cc4200233a3b185bc1d6fa7f20aae720b457f43f91ee32f3f9664e73b98faeb3e4214e40fd9563ef57272f78039cabbdc43beb2b9009ed43ac17b1c204f971d41708a024040d9d76fed1a734d906d0bb93360dda02dc4e17c170f100aede94b75d45d0e1a3a8fdf683cf326a56f2c625e9481ddae119b2ccd15924f299eb8cb7a61877c608099649bade207fa20f6d383f1ae894f1ae7c62f4da6d3a7afd65c813dc9ba5448fd19bfa69c2628a384c9bcb62254add7a67413786feeca73bdbfd3c1acf58cbfd50da0ebc8beabe7a8389bf98da936f8973af8f3255a1a834b6623d4bc85125d72670becdd9bb7b85a35e6b7e807c888242fffa758ae401288c2bfe5c79fc2b5479873363ecf5b13ef2b4829e5485d470a89631af7b9c8e9fb773f42f8ab5ee43d38a5c93bf6e405535cf3b7a5cc07b6b52fcf5fe9dfdd728692688365f8bc9d08b9c1aad2cc580928d6ab3158802d94e57e9c25b6f4e37a9982c9387aa9a5f1f81cdbacf7c9c1cdcab6d06008606ed329b3373fa2f647388c488861f240f8c4295da14de6505567037e5c881cbcb697965b57a625a5cf8fa010ed68b71ec0c33247238a6738752fc253a2b5de7a296146b2f7b853263a5a8ad7d1019f4661706827e17f50adcdc4e48a29045dc6e5fc855209b831652dd92657853a3d0f4a411029c3fe42530f40162f7967f9576db93c02214f3ddf1fd75889255c1d75c77fef5e7abc9db65bebadecb1de0a9f13e80e4eaf54fc7f8679e4f57df4df5a9e810e484c0dccd6912e926d585b35dba5a86047787ae1dfe96c7a426f0cba8ab0d1cf431aff455bc80121acad4d63b1f2a1824292370c9e29836a0324d3827da0b6006adc68941d9b270f26ebbb50436a7e76342d46e0b8db05b2f3620958e254c7c4336a873e9aca4f28a2180afe3e875843537bcb03736a48b95f45e68082cc269ad3e3f02a3a2d086b35ae2461d41ed8f9d640f24d3c62d342aae180961e5acb5ea116c069765bcb7e6ee45f084bfc727000c6816db0126a47e97336513c6e7b65908213059582ea54fb306edd0663a0959fea4fafa2c6b1d49bb21fefc0c4c10af0fd6ef9937efb6df56db3cf2d86984b053c1ccab9ecd862e64c2b7b9f6c0e518f956b2c9e091f1b0baacf1b64d39e694790b538066e75bfa2858eddf2acbfdb0d73a3bbee7eec5790a557d6f8a13909e73c4a934ef69e8347b9633f0d9936c4a25dd3042b3446414cb5b17c81c0327104f86b55e0cd4b4fc61afe499ba7a598ad4c7daaf105a6194139107349630bec8984e2361fff85d89b738fadefd322e5a65aedc9120952c3dd99ba48749ff276e73ff35e7be5d3b19531b5cc25db35beadd29df7a2e570fdd5f5c087aaa4502c65e497aaf3358d984d266383829429596b37a9bb4a5003f2858696ef50c9cc2bcd0b5f361c33c489baab78bcbfea38f35f130e59c42daa318625c2e2c1f46d00e18eeeb17de2731400fcb7241f77f6a83e22279f7abf27f428a94106ee38a8a7f0b2ff383ef62ccfeaf1ed180bfc4ccc5cd894b9360820757f83228e740b5f07f8f5c90fa3a657e1062a4d51b43417e7085d73852f4481002af86681d936db72a8bbb12fbfbc9a2a6457df57260c30aba1d1adcc380639f3f9b3fa78e29b5583e9c3ecc179aa2756e1e1136f0ea16a30c3d61e51ac27b5e1eeea974be8d2046d8d29fe2957a224fb6f07ab69a5bf31c143ea0007f9e0a2d370f555495f9a67359845099c5611f31c7e4deed42fd6520cbbe1e20fce4442f9b3d9de8ee4d8efd2d420af362c2059401aa7d6f2068ee51c3c24621427ec6aa83e1df341c3b2088583aea678c92a377f7aa228304f48ccc6e842663de4faaac814620f42113b14df7de33b0230596da1d35096b6d47f8d28873954a3cdc0204d2cb1e0612aa76166aa2554ecc0284c89c1b8d6a2c84c64382e921d7a89a3aa0c27dc5ab12a3a81c0eb567cafc896f33ee0f46ebc210aa97a7ef7dc040c27f9b6fc1ea8ec8a1a0b9686bb7e48ba47fc7f0c5ea7ec3645d7657f16aaf6eea349a104557d564f524b751ad912369a36083af1f849aaa9686d99eb6797366c57e5d2bb1c35c1c4b035ae74507ff480709da7ec8b1c5473426b0667c38a60b7b080ae4e5554873e3ebbedbc5dfd7b35bdbed09a3497b23e2cf07383d22188b44ddef7d335b455afd578c49d74d2960c17cec9e6ee299d66f6bc96a5dea35cf53e45d37bf15702cee52abcf27705309b3e43727b7a7480ede6d6434ec71ee8e305bf6b1c7deeb56c2ffd9ff11456e5984e4dd996a686e326896e57a46cb8a1abfdbcf10fe599a06c9fccbad3493248239a1b3ff781af8a5532cb747fbff87715403a2c7de794d4d774eebe202b69e95d6a6a6c71381f92e812d28a3845ad895d49edcd6b423bd68d9efd3ab3e3a1fa386af1cc3010553a7970efcd2bb5831eaa3020e2f83b7d28bf143e6bff07d80c57577090fd44eef684ddc571b2135a752bd3be4fc878b721941e0dd427079dd03bcd172056f1924773ef85c251d6d36d448cd753db0973fefeb6ac58ed37ff13b37d9a8a3b54f5ec58ad1985a3f4f1a2032da97ecd36a078634603f8c3e80a966f7371628b1f471cd259d1102446cedccbbe9252a892b259c7b8de21f3d98d49aca1bdb68ae17d90df4d2d1d49cfba6124decae8eb4cab587a43ae6ff723d3a04c55d9d8a360d738f1d65154f10ced10b6d17612db333aa2d00bc10e112c6a4b5c6270674f8529235c736d083c9d0a658e2d11d8f61201d9eee3afabeb78c9c2d54dee42f6d0e6815c70d6791fdf193e7aad81d92851c833bc5444d94545d26ba680909d8b5352dfb54a5d76b0872aeac78373a297b46991efc7c301a8d74da788cdbd598ecf6434c5fcacd819aeae2951318b57421446c1db93838e6e176a497725d5901848ecba35f6a62ea99f90e1884a7a82ba55779f4d74d727f975659877835f0ca04054534252d16dbc491d0fff8833d0d5ab550a4c19b8f72611fc8a436b138bb68a7faff952cc3739a1f04aca42489be46a3f703050d9c33cfe5e6cff2be04e760bb14b6e4a35e46fda87209d16e48121b5c52c530b540359a3fa4545308475f1a31db6a1164be64ed6a06945dfa91c9e65acfe942bc4a2a18fe026bd0f8f960bbbbc099f82d3db2619947053d37fbefc237f08d23b17a09e3a6a16e07a2de82214c9617060696e59fffdb5453baf50944ba696c8c100621e86ca8624a6cc7e6d3f8ced7e2dc7a6dc9da99de0d0b80b808be77a4d230cd05b0f3998e3d5cfbe9fa7a5ca1064ce289b67d6da8c9df3660fd30f84416636073a5edb5a043bd737307f3ed1ff6301ef2e08600a24e6b5fbbc085ec6a2df530b0e922b595ec2d28e4db14bcc52e01c72ae31f5c37978cf3c969c946bac16af5ecdc4bfe941dcecc5b6e4b3b015c6cd48d0bca2f90a12111ff22075dfc5101fef24a3353a130e7d63055ecb23be5b1ff19ab8aa718068e54ecd9c849f5d9ea30db97f477e7e3d9daeab6c47de7b01b7064e43e2d5dca0d5affb1858a8b80fa1f0f55c1c56bedfec3f19077133acb225ca703b2a5000f7b0f76b759c87ad52f83ae960db2f9b051ca8704dbdb45dab4e88577a6ec432d4e7fc4a56e01792c0c9f05c38f7b9a28969d9ca67cc381e82886dacd0e4916583ba1d852c702ed097b962be3fedc3549543e8bd059ec3ddae05135efdd214ccf32700fd80d3df3e81212fd93b15755087f56560ebf491fb336fba6010c290d2659a3d34847e556d46ede69fb826ad204928fa0fc70af2db3d5e036a0a2774065ef5d23f749704edf691eb17b6bce838a4ce146e4a3640904f21179e976825f5184f1d471921402b2a67c65d4225af61d473d26dd552cd4083601b20944b58f4578b9c2bc2602592c373a758f19744ed3d11e71745a4a804a2fb8813adcb2897aed7939f2ecd29ca7672f5564341c96fceb844b2fc14c88bb67c9291cd8cbcf3c54f04c467de51a7898b18ded9ae9a83ac37b340fb4db9ae841c9bffafd4ce0dbf691b555da9c5b54a0105df61ba2842f56a56f1a9efbf0365506a6103f5ac7e609067ec6ea865d97d09c9cdde3751c4f92a73523bc7a3030a5f986efd11c03e4ae30882cab5041058633ac377fa607344b9420bd52b8f36f67aa77e6d5cf35285f103188293e5ba1157c1753b7e0ce7a44622d19d7df6356463143f40ab627300c2a53badbe2c99d063852fd1c4a675df07316d43488a12ca3f063c3f60fab7e31709a42b197b9bbdc1448c0182780240465c2c669983763379d33f192dde2dc691bd94fa0604d46c671b6d87855d09ac053d96cac57849eb1ffd05f3d4f8265673448fdf207f11ed5dd26445708f80ee7975807f47b35a64fa6752af9a360682bd6583a6e07ce063a0a38b2095cb6ee1db3f966168b4559b03e5bbc9bcd12e754b3c1051831ab0b07af1e4d62fbfcf16903d940e5dc5a561444973c69b48d3013c6bf2523aea2d741b709d3f0f915ade35321b761ed16f73b069ffe6c55c78e470e9f481bd0b5dc3a4ff5d1b18ce8952f2a6b66f605bab7c2da51eb2ff98b03cb6af33411960e8c78218c8779153266eaa13a61689a7434ece2f2c5779291c898e7cfaa5536815773d8125dd84b26f2075687b64d30d60dfa37e46cb3c62f71644896dca296e12f0192b1db25fb71274febc2adcc84e8e222b4ed31ec18932d7d8333ef10465951a1205d14220b5ed8aebde3bf29a59e5730e96697c9466101b69da748495492d7367a376552d35479c4340425b7fe6b5dca7e3d343d75901c54fed71351675a9012c70b58c27426c1ba7662e05696389ad04c7ccde362e889edf16c7643fa4702ea118379acb27d45ca082b33afcfbb8657321bb27328e5755f333a290ec88c075abecef06a933a8c86e11be06134f97a8016e7a8629cb4c2aee63cfa4d26216446c47d737dfb7c3f94360b77205b18d286998444919eeebdd1bb8b616e011f705a7d07cd27e0c6c0bc6ad8707b69f12149e43dfa32d56c94a354012699f69df94f4a88bf933bfe68fbeeb17e13d5c39d0a1f5941487418d3f7610ca7f09f43224a7148a9e4ca4cdc77beb5807e0c15c2a5c5d183cf468dd53110ec97c0d55c50949b5c3e3759352d2cb3cd58ef5b35d9f1d5b5b44e37b481fa6e5ff6cd65eba77b068c6a2c1dc36c94d4cd7fae8d659c74368198466e2fcc673ae26ebeb5ee30dea1234a94d8b896e7ed05d1b727dabdd823bd583c82dc5dfc4ce45e6b7d05492394ef322216687fd51706bf0edc8d4a7e40cc49b4927b9e8c2b2e7e2cbb5acb8034df0fefacda20999b87a61a073fc04768ac28cdebcaf21c83cc84ea102df3badcf22e990f9a2cdeb71f1c1759a30705adf48a68e90a842af641dcb09337aeb7ad9d361eba91d20474df9a4c15b301cd31330fd512a29c438c475fa28d3b0926777eb7be0adb53a6f7a47df11ebf2113945f937b96a298a7817e3e50de99f3e557587a7fe4d0cfd262481a48b1069dbd82a7d5ef6235c73d77489153f76ec475f4eb378e91d4943e2edd3de898fd70e3885346a050678fe5ba2a711719ee48652ea7c31f1e2aa9cf65896b7ef4656e7a4f7dcf44fb426ab6e9b3cde1eca864ddd56379dffc7808c4f2f126742bf8633388115f22c4471680cfc9afbd36b00faded4601943e943a7d69aedfb31168e86991d99cdad5ad27d0c2d306c3c1a2719d7725131338d42c79d9c1b2a021c5a138c96a050fa26369b9ba2d8e691474f29c4ef395d978fbaf79eb8b39f99be0b79bb73edd0c4f4575b123612367534db0b509d2c54d93fef32f938ea04d69116cf7be18c4f257a5dc363d084d03bc2a07ea9280c8e38870c8571dae23132509be4bbf690f1ea1301cf6304750ae6f5ab4682e22428d27586f47f0de42f7e16964771db656639727ab0bbf11867e9c6000ec7cf458bf85acb33e0edbbf4cee4007b9680de2275f2cc9ba4aac28c5f919cedc879b784a8c830bda9e638ca138c6526f1b4c95c3e0c4b391c9674e5be7e5ee9f0c442c13e43059d4ea89d3e7d0f7c1a01b724ed22295f97433f023d0e6d6ca5d277791fe6cd3c26e0828da904e015a504fb20a7099878c37595fbf8b97bb549e520533c6f08514a29743b8e109c253d64ddd679d4507f13b5c473c03fcacf848c4ff396f848c8aaa72fef887667985dbee9db5e669b99414e683a99ed5a6d9170f14edc1f599880711daaedf45f3da5e0313bd2a69cb2d68b8307819f297b2212cf514d131a20df44ca4af3c2c9133c8c72bf0cae4eac539156e9d2549fd0153ae7bf1ff9ecd2a87a32b6fca26992e0be2482dd17e920ac8f79253c211a34db176b53de3dc58aaa29c03cd6aa518cc1a41fab2dc464d2e64f85541bc836237c1426dac1d00406a671972fa6c100bb5193417c5d4afe33eead90c22e28b6d59beb0bb08f4b520664a64a8e4e46039ac363f04dfeecc6b396d7084c292f733008a833bfba8c92035693954c3ca285cf58eeb63ded28b77eed7edca0b94cc0499e9b6d5c091e1de5ad806d21c3a0e7efada87281aeb3664f32fa96eea534e50b0e02d78d1656036a3a8de0f037842ad526bbea9cc98d5ba596fd34ba41011af28e136d204dd3c2f76691919dbcae54f633ea17da67c0dacaee3fbb4b0475d5704b999028149a505d882254ecdca3c6ae7a102abe081292ad12f0f5b6db64d071b68be7c11f7aa06c11a8a6023f09fe67bb4bb77dfd665f684d0b5a7940ab780ae3ec519704e44bd8ffea2bf953fb35874bba55986fa0fb37c65d1fab026e1beecdae2a3f6a62e4d1cb88dc952e8383faafd3dbbe40f3e38c274331951c95777f2ee04fb75f15b3dd6d4563f364b5f9bc5654a55ec096b78b986c9839323c79ed64e7c422fcd9511101e2531a3652f1999d75584304f55a4bc22c2351169c023303cd249e2e65e65d374ddbc4f1790d294fe6f9d4d1ab37e360875e7ee7226835bf98dde412c34c95d53d4eee7edc5a69cd8564d1f0f963778daa388097ff8b5c29d492d4206243dff354384a1173a65f7431f98e787cb1ef3499cd380fba37ef21f444d33be0bf0f686e64f25dbac42b80f57b1cf481cab16a7d450bc537b0e7d584e54f319aabbcbed077392a9ba3e2f18c97b21396d1bb0d2fdca952bc0aa02afe3fbd218f299f6cb8f1cd3b4f903ed266affaddc3247428bb495c26d039b457ffab9027475a3b3d085e1c2f854813dca2405ac6b890a5b4f93a612c90feb765ce16c481a828f92ff97f3309bcc6625bab768d079bb2d1470ab936b1374bd6dbc85bd6f8a6fa4d68d0a0747efbb1d4a7c6f85281372cb28228ce158414a70eeec4111cbdce61a0c40f3e6aa0f7f775ba6be913ce0728acfa00277827ca83b9c78531747de448e1f7e7c7cb7012a2aa7732769a82b7aa0510677e10bb68c7b3a8ccda84a36c78516289222944eae4fb9eeb7b9be72e3998ce6ddc5746b8c58c5787550bb697ce40919d1b97f253150167cfa18bc9311fdca802895dd20d08d01f134f9ff67c55b230bf26cd6c69d642ad6b47afff3025bc85096b489a0e80d7b5017e5ea0072e9e0f04d41211c58792c875c1ace0a8b74f80c63bbeb0ae117921b3fb66a9d95bdaea537a5c5f389e754b5a6437b096b830f2df0f396906bedaf86d79d79b942f31ffe272f931940d2f82f61b7abb382f41912c4168fe224107cd6a42c29533d9cad9413ade841af2aa52978f09a24900c430980e449b4a20bc8ffe21155ef028535d8a2e7d98094595a95eaff9a6dc2afe52e0cddecceab813c31a30271c1e86ddf646e70c3779bbe63c904d91c0ab936277fcb8e37e113fe36aea2b857b0b9f507f2a7f315c79b92ee762bf75e3ad755792f8ab3dc9f86baa764f747f03046158feac7c1406ba098b2dcd9f86403afff5431717e9914453a29ec9f26c9825fb6c31c981909d66b67a04e01065ef97dafe41a8a4d81d94b615608c2ff20b6315586b59a0231f32961a55b4abe9209305cb852bd863c941dfe0414b24fabfbf4b820d17dc1afe924b3ca7740b2aad5dcb2183d420170ac1b3e2a3c7c11ae92dbc08002ca663a6bba7911f22ddcbdadfd514efac4634d16dd60f1bcab7d55cbd0e15842a43ce064e6a96c06da458b00dfb47a4cbe5dace3eccc7cab0f00a913e15121829f3f153d54e16cfc2b725238962d0a05b9c9b116120e9f0522e82d343b831aa00efe7e893e4d622bf6fe0227adc418afc41c68425ea260162bd168e5e29cd9a4982ef4a9e7f9337eda96e4bd36ffc6281198d479b7d11c8acf9c0e04b12a09553429c10acce2f432378628d9d7799ff273543af5d8725d303552ba92914333554a944f95814d8f88cba1c99feef4ea03030974ce82fe4176af51e6678f5bff9c36a7701a4770f7e031ad3e7cb221708a73d10b5e2d433d26c35334653a5732c24d0ced5413d694d353e4027a6f3817c542ece81bb45b2e8c3509d714ae048f55e57e37fb200cbb8db9c693b62c908c47e11b8693011f72fba63299348f9a65b4e8dcc0a5123a7eb9d36d48b1cf90e0db9514404b3745733da047b39208559ccfd0911c95b939e8ce14793ed20136d8d75fe3b8ae5e30a136a7bd7b5ba7e3978796ab677113fcd12e2f6b41be56a9773de41d5cfe809fb54504ee955c6a73e82fdb9e56aec725dc01ea6c988f0bb7d1ed07df6ae918d3692dd424a5eef8eb6c5a4b1dbc246b5a8a34037f8a0621bb1407efd53a9c769ccff8d7c5029831b6bd2b6d8eafd061b2d7593e82f73674a4834abac799604e3d70f09bcf1814d70f298dc6f04fdc4754381f7cd14862512c7dfffcf4daa0a50bb7663ed82554046da70f9459955ef6865592d99aff526785bdc73c478e655e1e56d8401296492c5afde3d4b5c75263c0c84a92a866c87ed33866b3803802ac44f35115ef11a0c12b80162595abe1ecf30bfa4335c2829e65ca5a064b3eed54d160fb626737e6df13c51a85be95e83f2c4ca82532a3cd203545a9500c0fb4ad46895f7e120282b854f4fd9c64c47a7d7675ff4f6ce73b842ad2c6fe42f7b909f775b24231fb8b88f82d15b0d5098aa28d4465c70d0d30e4cf8ec3910aeacee14a1c5f7ce95fac45414ac317f292003ab2444e7423cc5115ad4d8566e50adebbe1600446457b645c2debc4250c21774ab017a94dcd7b4e6b1332623852116669c92e6aae86a79de1725e9e1d028290acb93e1d872fe1627625d63b1daef15ce855c8cb6ff6444bd62f47aecc608f2e59ce2873612453baf3a3d800d0d1c5fd5a2edd6a63bd3113f4db027fbb09361dc0b27c3dae8ea47ea3e9257fb5eb36ab1c9b6b95885410ee482cd1fef744669b8ed7d3e75347c802c9b21676bda77952567b9b7c4426cae92d689e27ba66b5d57c48f64151e247d27eaa9610691f8414163cf99ab2d06d7b68f7850af23a88fee77c8685466668e20bcd35fa4c1b2b9a3a4a2aa00dbf5914ab575ad253e414835fd334611b561c8e45523016e974b60714addb66835910acc0d28060bccdb760e1996e7311c93545f385b6639030930e140bda93c9a9f63f6c4fac5aa8f06ab8f0fcc9b7e6a99ee9d1a9e1ae4bd85406930d7643854d22d4de57127f61dea5bd74ca895801cc89fda44578ff133afd3fbd8f8ac7eb72350b5e22d6e35a7d7e9c1f849befb1787c2a5e38bebe5bbf2e74c4b64e430df56e7e5ba275e76868cb77c836cf24ecf3c734be2cc2b0fc4dac9f6784f847ef82feb33d39f3c9d57eae41f2ed01ba95930fae74983d1f8a8745575261a28742c4a7753e83bd11958cc7ddffe639a55dd17cf63acce49c67165f3a697e2e47f4006b09a46aafbe190b2054b0ec1da272ecac0e0860ad83adcb3d76b72ececec35da257682535d2fa0df54e4e3f63e11a188c5020e313b42fb60b0be13b1e01446db553af9c3a36376e99664a8d16eb858adbc0e64799f2b36faa2e7cebf605","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
