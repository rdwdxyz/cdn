<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34e353c4c9a58d1e9aceac8b13a12b67c9cfd98da217c385072866026cb390a6d26f00855b382662a1a5f499636e1587409c26987048919569ab4789e5dc0e907d704ca235f709f386c3239a8abb9afa92e4607c9a432ad62aa4ad8d4a2587dd7edd23d502f0e0e0513dcc589ffccf2147084b5ff64e7a56b3622def465b954555f49141f259c0fb3f77e7fd698c1cdf0a7bbf069c1c72b3ddfa1c277a936d9e802291567256d1bfcdd084655d3b3f4446ff1e17e8f4ac126c7d88413123cf7126e77a9b39af1f89e770fd3bf8be1093cddac25b928b99b4e21c185672b6ac63edd6b94a99bf38c399b00cc96a8787cdf17024b4f9b67fb363444c0d88bbb67efc40473ce20fef1202ffd400c41853b574999d20762f033487b72d95ca5ef961255cee9160db6f275744b91eadfaead9c4919f775f7f4e03652a3ed17fbfbb4332dc85b3ab7e085e0f0d573c83bf5c92738fa874e43b23a1d9cf81ee033d726002eafa3cb1c21c51bd736d6dcb5b5e64ae4e41d781c274631aab77ac5bc5380acfc631878866895aa7eae9fe5554d736f4933172ed2ef1e5a49fe0f80a384779d3269a01dcaef837ab73dd8ee8b3dcbb4bdd7b634246d5ee1eb3c5a6480f905e27ba952b998ccbfdd95d92a6cf281fc4d8a188c9d2027518475591ae951233bb9759efcf0513e14e3c2482e4aef37be06c658d9f308bc917568c6c70dadd363c1bffdf1fb45511d7958f4aa29a7acf3c7785bfddb3bd8afe506d55564f23abfb3db6d696bc55c8aad076a322cac3d0b326d37c356edc9739370a550d8933df5cfffa8f4363d72ed86754dead5129b850e53099d2808f35d1c9647222968f7e07a116e7da279532a19730f2ea1c7f5ad0cde31e1f4ef20f3e8737579632e7ff4b944f8fbfe692d676bd7cf3a968df237d74c64cefa2ce92c3547216ff2578a357742fcc0d88f61745583237d6f903ec284fe6dc6de47582232f831a2ee265ef00cd8155e5a70f1fd9d9bc5164dc2ba379bf47c04abbf3b8c4819bd38246229c9fe634f55f5e6114e709274c8b7b88724cb41ca0e820182cbc98b9ab85eba0ea2cbda5db9a45276d8418083d6d5a32e9267d98f152b3a42d5537b3d614555221526251db93fa5380e8a4e426e4a0c6a9d991e8a540435ab38a81d9d40ae16dd4562e5a368e6132e9ad99e798b353d232234bb9c17216e1694ded762eef8f2082320779cd0f88b600ebc30a4ab356bbebfa6eb3995bd4599c33fd7ae6e57bcbcf6bdf5a3b324abfa2cd1166ec67174e38bef20a7206d9f1558c3e7d32ab865e6dc45d3bda02ced865ccae6e9bd1c23c6b99eb3cc46b33f77d85902cc2f87075406d04dd782b907c6fc7cdb1ec88014906c2deea14a4572db1f8299dfc988cced50c301763b12f3091421e6073393b71c1663f855de31923cad00378361143404b808fe12d7de924e282ce7bbfe40d798e94e102fa3d6066d6a55f9bbb5abcc89e10bf5665054aa871cb0f7de718db27ba14c878e2fea355d13f5602cc3476efd8d5e7b6878870f1afa3b59965097d1c043b4862882c94e904a5e8e2c64a57ed87d4061c29600663df01ff6bc09f798703f340cc32415b0fd98a5ee0b9ed7685305824be8911e08afeaddf4c9ae17cb7f9c049abdf8f2df4814a749d225e01b1c104e76a1d0b7a5301c39ffb08466521ea0b11bf3fda680053df01f14a2c261689544c9f0b3ac8f7b74be4cd757e1802af9caa440d458c2fa33047d273a7c91a861aeb2747a1b3b1687393d5029b70df0a23835178d250f975dd625fa197c0d270f46f008cf06a697ff06e6ed54ac66aace9aa7e27cdc33877e7a77569749a8c26f753217056058630f25fa6bca3454a701689e89170344a7e1bce751ba2a7b5470585908d5ed8e1d046f8a0aec0f59e273724cf394d6deb6ec7d3232dcc8bc72060462b0732c964278c2cf2f976a58ba51910df56db92b1089491c411ad166a225c9054be4d9346c46759d4c305f1b02e32fd3194c018ef33615081f893a902a4f1afc81a187268e072ceb64cc61531eb0973e0e97a6d422b5b1df68775b21f01e6fee96173c3dd3d470d6d026ac8bf4703b887000e6035dcb347a521a2489eda20ce3aa7e7a532f12946bf660887a42d171e1fe37c966a71a00da29a2b70b161efd017da7018ef4ab030acac943b310acab9e981e83f598043d809a267ac340ec7ac2360dd2b023734e90ac99570afeb6ab2e6bc85fed8a5cb2125f0cd316a9015bf26fbb2e44e9c569fc017363ff17f55629c0e5f4bee1a4afb279b67675144d740396b989ec8952e282be814f1e1b272cca734bc152450cc34c47a5ff5d1f7bb3b67427321353ba476e78404aa2d7db32b573c257613cbc84876c400432ae6a2899d1d3f8b8306b1cbd7f2dd6615989b258d595e1685ab414c1f811a257f79821a727facbd84fadf5bac8a0333134ea63e6a3972293276c83a7e04ff94ebc3ed7dbb9808b71fdd830c39f0d77b3c63f8bdaef9a15fa23b200006fad1fafd665ccaebcbe046ca1b931b977c3e390dd19a22f4a7aca2dfe7576eca0a3612694f13df6b5ef4563fc19710c55a0e568ac5281a8d099cd1df677e596fec6a5df5fbefd7e5216148d5c7e4ef0429e6f8db090d37d10116d9ae7ab604a89f1c46b04c6c5b3cf81015f06c8eb3192a7dba950818eab0e839799f3c9f7fa9fffb6fa433f2dd0ec36e37e5acc98dba9259a28e826fe2c0f698a6fb956b82f58ab27dbe288d78d09d6e6be01254a32a5c62676444fa1906f8885586e6cccf9a7e777ae1cc94d8d10b66c0f7e9f9eab776d4a95aa5bd7ddd3f6c4326ed73354a8a3c975b77966649915d74707e6ebe0a84caa0d976617eca886180672b3930dc8e7b5c35676ea3cb4a8f7f143868a765e6ea9052acdda89ba9180110648ed222d99cc3b0d40d538e650bb472c5206fd6656b662dce0772310852169d71e327f3553644c53c4c484638fe9eadcf224ac781dba3af765c5cca43701d4a68b8ff65340d029f432c11572cc3c579b6010c45d8f79e759f31a6878762075e3bb32a40e1dbe1c2fecaf8d6c43918a2311de5386a12d0bfa1f11ccca183c171c7bc85396fcf30317a3be1ee1f71030e2db54ad2b08ba3b287ad6fbc4139134908d88aac9b1378c834411338ab64cd37036370ed023b24954371a35f86d517924059e319977772e6fb094c8e00399b670a9e63fe5884cdafe23c27b9efbe4c78eb7498b9d8aba944a70ae67dd07f6b5b7acc0fff2685019731c001ec884e2e1182e28fe4e681c46548827cb01dab3ff41ea7bfdc286930a9fa9a7c0045fbf275e8fd31bf0c02e964eb2d50957f9a43be8c151ef837a762a99d6d9e92f6c845d1d71e4e588bcbb423addca1c0995f057c4a1ecb297e084f0a23e9584a416923c0f433c123b47f373b139dab8cc2169037e6e3500570be3ec68ffb9889147bea7de1e589c738f13e32749483944dcfe18168ab5e022cacd7ba89ac144641aba0a6ea156c41ca7d42bd7cd240082b8e4e196c5e95ad0221687060dd512ad74b419d6752af1430f15a5cc4e7780f8b8593fcb608085a51412f2bfe9c18c2f1e9a2525314332418b9ba76d6e1c678f2bb239a5dda15f01047520b9d7b176b0e75e3c027eb494e373e62693f6ae6b0c1f52e9830731901d9698271f92ed917c9ef626b6826cc0e776add172368254d6b86fabf5b45995b86cbb61c4e0c837a3c25e80eae99a68df865c637e2ac4d2774d9acdd22a945d7bec379b2721b80e224c93d33b0f9d59a6013f64310988a5f8895f5a9860af10f293d6424c0577961bbe7a942acd7660f45090feb42b0508a30447e40d50330a3c8437f5c24c13a03af00c9f4664f8d61cbf53a485714b1f994a9cf9f97c18eaa18a0ba4e078baa993167fc7aeedd62b1455bcb030e54a37645c1c54cc85e5cf70b7dc2ae1dd062b2c54c34267acd9c36a0c49a5e1facabd298d84ba3d81f2f1d1b8eb404da7e05e27a0e09704871026156395687f741eb4e25a10a31a10e757569521c2e0b60fbbf931321ab4f9e8a1deb19b274169bc4f73a85538cf8839defc214a44f66f17badfb5ecad08ab21386ef63884a9552e355eb1d5e01cf23f946ea72895d5c4d32397d38facc9c60ffd07cd2299fe88be344e7fb61d4e23fc4c026641c052606e4c55d82f3635af01b0a3d440ac0babd023eb21bcbb751b86066c806c9b4c57383c765b5a3541f652aab73756581f77649515f3a909fd9f831f0960318ff5582429f9b16a44e9742e9e0d0f9a42cee7bfbf4548f01e46c8815d8b8faec8488f54b965b933e082a881595b73624e02f087de949b407051309b38992f2758dee57533fd82c1ca883c257578472d66cf0ecdab40b5c77948efbcaf9e2516028c89972d64f771c1c72bfeb47af00f1b9d45ed8799243500fd732de07ba6460d265fa195e0ebf5a34d355f167996b54184144252d40a4e6a7b36cba049c6113c01bddb5523c609c17e537b9b9bbbb1892c899f676da1f1c71a01b04bab05ca5bbdaa67eee27954e7ecdb58154cb93c1114b4bdd43615a1c0f7826bd962401e0350adad3a579150310fb829fe73286059c228c0f7b2969b10442ff79c77e9029d0eb18e35f8f35389e53a7c3809b9cb8df18505b926e683c2cfb52855d705025cefd04f82bd49e192e991f2343b105ae0e11849ac9e4faead7018f42f1463b9dbb242fe99db9d48cd9fa32c962a3f05a753c491a4acee7ba6a66e36d9acf1a65b543f08501293a46e53a2b0a20a7320961b10cea0dd0cead91d2f2a5f3369d816e255c47b49ab124a219c37485999263be00f18b3265324500ae802392528555a16c60685a625610cdee973c3d2ab1357f658c7bf11a6a258cd8bc20c26f6a330a03206c300982b4c499e51a3faea4f339c378209ddb76f8aa7b5f30a31690b141a700a7510578c84aba9ada39be7dd6e9633c746d57c24cb34f7ddc95feca9c19da2d5d05893ec96459f86e5b20bc32320ba7c8bc207afb9243864415953d29f76c878602e5225bb8eda1369054b7703a8dbdbe6be8f1356feb8488327ed6a90963de36e7993fb54211922ec7b0e7b86bc21581db6fd2194edeef0dbf18753bbd88b5ff90c305e465cb2f52a2447901ca78bb270b2e30ee4e7496de18fc1ff353fb396d281e096a9f2ff89810972696e5bb93bd13fedaf104bf58be7b6859df97ccbb945880e08806e7327707d261f64eb9338561372137f0df3bfb14630617bd26ed8f19b62d7bab4e548805735189ef2e3d7d26de510d07d1a004d8c310e2ae53e59f7bce9475b0a3466efd99741bbbf3ced4f70f5c9ccb4fd8bd64e621f8f09839a06ed277f74c1ca568478322d9f0f457cd310d1bf3f73e9cea5656f5b6b0b22fdb1ef02adb462c81929ca20fe8d4b330f9af281a86c37c3e44d7277a6be0c53a5d21bc59e1183f3c92e8e863dc4730feff3e034678399a29bb9c2f1b150ace9c4d8da78716aafb22727c41f5ba1ebda6d9a10ce3ace0d4fcaf139e19cefae456fdb300e6841aca2d841b8262b7362d6f9d80686545c260baae093827219b3020e9c0756955d5660052b7a03e8c64bbaac8e0c8332ba3647615092bf64a3b3e846d0c8c948378cc02fc745be206d3554088788de341025b05feab79609893a251cbc314f3b5bb0cfabec2d2e6b342b755c48278cba1b2fa8f2e2b31d937d750957ac6def8d0b1b4c50155ac31c3ad6b911b3627790ae0861a282e21add2089663638cffc77411948ca9258338c3cd3b1bc90ff6d86a7a50ca698c1d0590d9933cb3fe55b320ae7c3e7098059d6d8fb31c1e3c14f25ef5ac9ba21fd7034fb323c519da2987d9126fe9abb22545d6733c8a31f14cffaace6e185796214fc5462c1fd6e958d667fc24b393054d41055f3d818979e6e87947b9362fdafdfc9f92abe6cf3e53767a54af04f10fd5c10693d52d8caec28f34875e9f3924183a8b92a0c9ccd93aba9e26a680c6dc4b56f9ae5ca3d417092daa66cf70dd71665427b4b1c0351e9e580988833a188d8a4cca3a28404a6a490a394fd0006eafc4c9485485a82ac6efcbf9d7198daf7749f5dabd73607bea1d6df0b785c59d44a8d82bdbe863ea37dacbe521002650de5f4f6df7723037f760e99e79d750a33a227139838292811c642f53152ec49a4cde32e4216ab4dbb128b7c41851d79433b8f1c9fb70432371b60a3953316a12242b718d5e4f5aab651779fae23f322e22f982160b8af850b6a972ded1ddd657ae4bd8a8e93b1afd00a04922740c5aded36ff9d2ea8bead4ce3307bae1ce5e4fc32955d29e38ba2723d9b73f0688dbfdb43a77b9b99e7304f63891d2cbc4e9657104007b64d5dbd870ed1ed263ac5c9c12b8d679ce61b0ac561447839d66c3afc7794196c325a7d766869773c48da57c7cbec5b75637b4766eaa05e699ecd14646aeaeeaeb02f7132ef93190550c400861201ef174a401e4ffe488100d138df17f9479057bfb3eabe5a7990aea0212c0c2e6437aa0321ee26375a56efcbfe2d1098dc466d391447235d1002c7f9404b3c627c7ebe0af9c51a8f8652416317a2df585d7e80a79b3431267f9695a36b8fe57528db0daf75f5697a7840742ff1d081213db535e1a372e473116331a0e00d936f801df7743da04fa2d1cea50fb9990e6d457cd0e9044700ad1096f1e96b399c4f5ec60dda232e52352274f8d9b51974b7f2f9ad0338d120915bcfcbb4ffb71042af6ccb004dbba2d3ae45d1c9c39e2f1606790c7b4f9d6fe3ed96aa2f8640a7ccf7341801eec56b89b0eb7e0c184b78a3422c20fb0917693fdeda25cdbbd7ed6efa7f3b0452b98dc4cb26d71113f5f66c9f77c6f1fb8371daca98913e846c44f6909a224b7bdb4f919bdbf4f886d47a015dbb25c5de6a85223d321077cafa7be1898c480eed110b002bcdfce3e0586f1459e1c18aedb64c42afed9c79bdb28d65d7b3074b8182e6e90a3732fb2f04eaae796b0bad8259a3d8cb69ecb99ada9f1cee618d35a0ea1b2a0e91fb1c3e0b2e6ba79fb977794d1ef28e09118bd9c3897ab2d1f8412018f61cf692389fb8d556d8e611c1e0f9d87d86a8dab55ab77e5a808a968008baa0488f8e2a1926ca1c2fd4b1e73377f4a0d487bbe9a80ce6d8d0ce6966394d80375aecdcddd9e2a468659b3c1554b32a270dd0fbe0ac1ce6d6b1f6b7b10f9af219615c50561e685873540e5d90744e7fd98054ba0b0a78cd3907e74349b276d358f8b86d38f45839ada6c6da3169bd2cb956b376c1c656da8bd9784b5fe1105cc29dc8155a9c63bc4c6dbbee643010b9b4d1fcef36334c5c1d5993d346540f333b7576411b8a5d4aac2d7cb4c8b3168c96d64fee195d8adce594a4a5a6f2fd40103281a30c68edae3e790cbebe4c06d658c009593ec0e79a5dbfac485853f4a1b4e2723b1dd4679a4eb69461abe4cfac00ca8f6f66c43c7ac2664c3f4e1e44149ab1144bf6832c0ad43beace33e81280458f79b53295b08dc3a91be7829e545d6f51d9fcbb131125c329a3cb292043e96d86521dd0af5258f6ca22e6057e1dce377888d64976b3bcf5f0178bbec3c26babfc7620d98bc8356ed4a6c44288a21398d7416821095312c44bace3c5bbe1765fd5fc5408a8440808ea4667a8c97a60dd3834ddbebd814196508097ad54141eae7fbdd0462b938082b65e50cec8fb72ea158a8b7b0e730dfef071cc23db53df95572d9df91e24e47b52105acb205aa590f63fbfe3bc770dedff8dfb6150e5c0db6d2bb0ba718c339d5bf8f3572945b87c7d5700b4b807e8809ee6a2ad7586bdbd31f9e3e269194d1f9715f64154421de5e9adc1628c46f994bda6498228f9d1e61e9c935e2053e6b769cb84a3e7efdf2288f701d39f36c9cee8ff4b2750338a33297a2cf49fbefa90668a4591660b7148b4262572531f4e218bd8b81b05424e64f9723e011194a70b8a919aa2a31e788cfee33c0be4b6ccfa4de3129ce1c99595aee43c55ff43b36a473038568dfd03b52c20998468864f3abf90c1977efffcc0835292b671b39773be2a5297c5689d832a53c05bc68c6f387aa94185924b48b5d6eb2370c973c92d03f6fda473f742c611b66579737422aa0220f6598d702bc3d9c7a0e6633c9bb2c7a43db1b091ed1cac7eaea6fb37a04e7cb4e531bfccc60334d6201fa88c6259e6e8e4d1d0d75bc76afb97f5f3a0919fd2b6ade81025045c500e40aaf54610a5fa3d146c6d8fee0bc005cfbaab6dbdbf3168ebf92e7c0c4502afc0c21d0a3936ba2bb81aa551883fa16b5c0eea8aae75ab0d120030e23fae74e86e0066a97031da5af6c1cb89f729619c8be63402d8e2d2c4c5a993511fe6c8e5865bb21a9ba8e20319a12d661d5c1f40be9e73d7feaab3ba3b0b2db32798d8e67f4140c175243279310f78770fb73615b6c600d0463faddbc1a7b823b7feedbb8e849ae93afd2bdf1f0394853ded8cbaa8d86efae50cd7cb9747b27b19d477109ec25f0cd2e7b1f8139cc33fef57b2948f015afaf81f8afc8ca9e2aff74aba2844ab27b0d9f883ee30d74c992aa3b74560ed28e572cfaa63bcd6e5a2ea1ac670d57b963c682bfa3790cacabbc0c2bcb971374666c4af6f7b26e811d388f4e89ebeadb994de49df27ac0769633b914d2985d5468ed74e2ad368f9f1d86e7c9b6d71b6ce01813b22bb733c43b7295a9a6585e45d2d4ffe0dd0e17b321a044d9246f6b8d022b6bb54a7f8e41d828b702dace127ecadd7074c686fb022b5ecdafbc212331016b169f878ee55e355596f210c40fed7ecafa7d9a8b2f413d937a5fc337471b86ff6c5661b669e75fec801475feff87dbdecfabbcf8e8b0c131947804741856237277d9aa9e3e5f1165467d3dc799ec08d4b2c53d51b08093b1aab637b0262f9554566154bc63cf3d01cc01208bdafda254d5a893423f8c28799fd2fe013f13bf03b825331076b43348669847c5ef12ed33bb75fe21d030d73e021e58b7857ec328fd284553ac0b31d03987a90063b17f33821bfaf9dd5f8642195d48d0cd709447e3afee12fc869f0332f5f5a0f72b178135f6d3919f9cafa5fe4b40938c68ca1a3a33b71bb81e14c5e725ca43b661496847b03cdb325210a7a5132b5bed5015c7caa93781a15c228e780ff2386fc22b07b264544d92187604f8e234fe9c83be6d98474b1f141083e4a98086e253fea62809a871fe1bb8b0cd48d2f4127efe04a0e89b69fe277f191ce20f102633bea1fc94133ac3789f397704bdde140671bc0e603a69304a5b61df4f851c2e57d3e3a3640215842226e8a286f16911adea16b61ef877fab1a17fcbd5c2e39650403bc1f5ad27cac2f38a80aa0b430ce63abd1c5b4dd80a426f22227ab3719417c4843ad382522da2d24f8f24d4aff39ac6f0fa1cf296d318b51b5217231ddb9209d70a6a74cc1c780b7e9ece68ea038266ad95c542e271d125c4295121e925a0c7f54b231bc0f361f3f8415e40c918dd851f450709a53e699bb86ee182175c0dadb7959fcc6e9e4e2f2f57c1000421fa7072b3795469b26ee6765cfada12b6e7589449777d82f283e64a31459547cc45038d22f006abc6b04c30d95c5d7d18476787ade45aeb5836ea6bae0456af18c2213a176c814e99de76f6bb8439c470c0d6bfdfcc50ecd25c57d913b78f40cc01a8a873d2c55eee516d3fce6f3684d9426eab0814ffad74601aafed18859b84a9b881865f8adf5586802ba029f016dab90e5d0704529c797c295d7a46026933a2761dfc313120316f8aa6a111707f7a2d0a95b25aa2b9a60b1600af91ca32353398d5323dadc04dcb92e524689c13aba445936ed6046476601e1a83f82f07cab481ed579388d0293e8eb5d1e47ce58d1c85607c00d273893b96f70703b1cdbe9345bf3887aea753ba26ec4a64e14ec2113bc121ef60f9bc76d674bfe9c2b38e49710b6ba9d556826e888bcf493d045dbbffded2fa694c475cc6ade4b62d9254fa01413e3c33dd39983a464cd2701f4c14a729753ba6ccb22ecc2dfe76640fe99cb02a0dba4e1288bb3a5e3efa1e91d3828520398ea2d73d4f4cd9394f039b3c0dcdac1bb8b03c2c4623a7d3e970b18aec72d3ecd7ec9ce68d4c6a36296898973e2917319002db1f44e26b9b5d5f602e7f85e44141fb8f1411ff0975840bb4fc61795bc00c7fc28107745efc0e6fa2015f7eded48d965022d19c2ede708d85fa2c37a6f3596bad8dc943f30b1fbbfe9eee9375a90c381220dc26751bf6dff2f6992fda83db58351e6f75dbd514531db46769adfd2610587b2a05ad20c19db641ee1a059364ce586106bfab330def46befe46b53f672dbe1ba589a0430d37544b911d0cf65b224ff5d61f530a8fc7ae535c1fe0b358dc751a289d05d43e46d2af611696fb2284e01f971ffb8ec4fde5ba949cc6afe15527d93440f1b56850778bc80b74134ab37cabc7393fdceda9abc1653e0bc26614896496aae998caaa4a0e4b05745491314fa24596e0806310a9429c9c340f0af1e5ff43390eed2e6a4e39bb8bf22459e72b38e72ecb7f044c225c7381ad9682643884bbd48e00f57d2a7e22ec1ecebd034c45fb9b6c5cbc43780ee89fa47def0c9ed43a6e18bb2f068b6aae41f2f13bd5d606a1906b3f6506cbd4a8daae14dc02b85a71ebf512f2d7618fd06db56d489e87b138c7f999bf1c3eb8869c923cc7a7c1df467996c8cd545c12262572061ab9d2c3e0348a434ba9d32fcdef7119bf18c52a84576bbbc87fc557fd99678b57c1ea64aa8a99467c276ed18b0a73b85649ba6aa0c6b6b2666538e566c4d4812030ef831cd10abc93fcc4ec244abc431b4577613749ba0d9f5dc4eb80d89060faef192def62c08aee58b49388ac37a5656f030cb31fcb81204db1745b5f624b7731c4d293dc77c9f6eed4a7a1e0eec19f58b434a91a6eceab70ca99e12fe0b0792673bf270a8d85455577ebe535b0b5eb1aa317013bd3bb85053becd95e6242a5f40c7dfea1de2865e1ee1cf6af2993bacd1a22b8ba1f6fb79c4baaf832ed1d06c9fd9445295b50eff11463ed85c6ea794f6d5f97988fe18c759b14073675c37a6c20ac6ab66c3d82c13519e6a55dbd35071d22cd61d1b9740fa416e59644fb99782b8aca3d3fb841c0bdd440991d0b07e09d6b085fbd2ee0d8c63c57a0574ce9d6e200b8da27aba7ab1911fb1bebb6c46efe0b74c85a7b249248902c7c5d221750f4a317faa8b614a7547b0b9b4e5ad591132301653ff940d24193d97e53bfbce1e6783769c237e109cd4ee5f1bb35fb83bec8ae365ec983a6d7b6a48fd05563623259f7ba91dc7fd81cd4dfc387f786c5c37c3f9041389b5da5518b492d845356679eafc46565d064f5c42eb47f7f4926af7270d3809d81955f589d241dbb350807cce078dfb081388e57cdb5ee8bf7149006795f0cbde43bdf593b1124edc89f9a981fc3bda310413d50bbeb68b1e045eeb1e84751f994d2536a93df684f6724e9b4ed754b4c706cf06eb6b1c7bb0af4fc7ed719e91bd5ca8cde94d742884f683f3b4fb49de7ffa391660006718d2ec92e35814479bbd20f889397a7775413b562291a6e5df0fe131aadfb2260a831b15f322ea58e66d63e1666b90bae45f45f7f62e1dc5c233c20ae0c5933965dbe9bbe7e1e3bfe3ec209b73fc1f87db2f70beee6dd3b2e5dd6b1b5cd06dd9f2c26628f22fb81a0c6e1ed30b1adffd605f709463b525ad162ad901fe01d5bd25683185be169ed061404a392c47dcab66f634cbe94cac0247cc9e8a8f97f896044debf18cef2c831e52fa81b5067abf1baeb10c37c95ed683cc59bfefda74f5674be338c2c7ff830740156ce8919e7574aebfddc7fe5569b4bc8312f50ab8cf6594a9d2ec2fe6a98449096d4a6c9cee52dc50fc23d65a9d4617d1bf667ad80b2aa7f847251fee25748440866e016d1b1e9cc18ef5c393abbf5642e987d8e9ccceefa5b356c49f9676825b104f709df82897c2ed4dcdcc51de8d382c651874839b82e3c0338af7ec4cde6fdc16562190ac3b8652e75580aa8a78670989dd280162e7ba7a1be41b98949610edfaefa0842af3988555048dd862ce13975263470c8c8684c1a469dfb001a67b4ad5c6a3cdea387e473259ffb08f8f0966f03e16f1f10aa54ee2093c2ee293f99b4de24119ddedc3ba2d1c7003713e4b669641a2955406c5fc76ca7a1f1ee3a2679c38d5d882d30ef36f1d997151dda3b9082a5c19272da63e944e2d690d0cb0fb9482cf63cf5528bdcc551c1c9747c1c67c156dd37fbddd44a553876213d2968e11e0ba27fa8f3352cd6966f4ac4c7cf25824a2df75788e417b0964e54d4dfbc8211f967d32e50a18244506335b390cb77b5e5a6934b52a5bc87be27ceacb7c492d46dc3a8b5576ef296048fbbdd6f7a7955dc9c6fadbdb266563d62d3c43971bba39ea5e43d27ad1229c26a82dad6640b8f46b58b7805c221fee0928c7c24010ce1bcad44291303a4e8ea2a9077f272430cb720a219e1ce875b45eec36d96c13ef6b8c2b5d325688aa2a53f9007ad814a866648efd5ab2c96931e39e422ee8e1a6d2a1cab2ee31aeb2e3aafde07664c43e0945564e51bdb6803a7e811b460fb5e11c0744e0d00dcf547b51b1ae099a50f3383cb91ac76798f50c5f548f82b821f5ddd7393a70d1ce52364d36fbd1e1b6fbdcf7b2ae326b3c86dba1110e1d418e15393f38eeefce775f2f96032304c0695b8ecc43c2a03a7586a3c88b81d38690ed177e5dec3b854f0a84a48217fa153d600fa76cc9f7c44e167d193226c53ae3550fb7cf434acf275c4fa828adeba03e037f6f509baadaced7d01bfe3d67074465d8494c30a9f2174cb30b4360a119b2abb94e2db2a738b270e6d667acfda54025896e6d6cc7fdfd906155598ed195b2a884fed52458b08fb38efbebe829c411f48483143557dbdfe59bc9db5060db1ea40d2edc5d2d783775571fd52794d53cd2ed00183bc57fbf2f75498cbf52546c6c52e519fe40e82eb2b35d51d62529cb9b232f020f8fbbfbf6f7d19dc305eafdbf115a4fe11284541481a618b718dbb03114591fe4bfd224d5c248048bb2ee4c2dff2fc97479a8621c9119f685b908056045836c95673d1ecb44faead788f902a7514ccd1e5e726fdfe793cf70fb1d0fe0b160f380ad0439df9498a5f9009764618be1418793a9e30d7454fe9e932f451688c2ecbf9cce5c84621c4d695c978c0df5f458e381de96003362450540450b120d29350f956f6956e95bd07366bf0be77d1b109734295b6a6b46253cd3aebd2ac1c48dd40dda1c281891006ffc8726c344d4540a715264f3670c636a6ecd185d646ce610f83fc09445cb9c7f455bd061878b3549304db9b125874c8ffb1f187cb15867bacaf5e91a2228e47f8c5b5032f03f2ac08668ae3e0558bc413f78143f3e29d80947e99c430b86e4e4adde17850870dc25ff5e6026031e4e22bfeeaac9d53605ea39d6af706d7f26b104cb3ab737ca5639ae5ee6921744fe4128c42f1a8990ba92e9ec001ec91d38f49178a2e42bd042524351be6f0159293f74c479d9b43860f7c61304b6f87147cafe2e660b55a83b052d9d12b033a45985b9f7a3e590c9f4bcfb86dd449083d465f68c31f69c74ff71193797c9006e972b0c77e421a593a1382bddc3f749b486160ec6d46ee27065d16670a62ae2ccfefd88adbbd21c4e7efef3711affd315f3ee60a9c837dee225b6366595a267f0a6ffb81cc73950fccbaa687c4cd5f59bf4457e581f4bb1a48e0cbef5b01796860bdbe052d7238dcaf254e4c02b6ef13fb4edca0e278573c40c7b27bd481e74891c90a6e0e188b016c10f541fe5a985c6711ffe991bc1822cf7b5b82d0a7274a13bab53b31fdf8e32f83f01e608ec5213fd1ff45d58c6a7a8e7dfc77c0a582cfecd5e79f05695504ac5b208906d20ed95d4bb2108d924f6aedb64b925fb922b283c722fd6bd98adcf965a54b93777b9e9a962d2f1f925c772794a43df6c136742eff5a09826fb5e481237976491d3fdcf457bfc8893fd7cea294a2b095a94a8f2da6b6f985d6a2ab3e7111836e6e168b84fb1b5d156a0ad66f78400906fb2a0af117ccd83f6013f5007f617d64f91ed0d3ee6c76b2afc0f465e3bad9f5f0e73b9dff501ca443dfb2073f737c082c8002cf8b15d6b5cdc501d7e10722eed428d6e9879815924db350b708d00b87d0b0d4def1dbbb9e777c9c6c8de11f65a2c2cea480d537ee911f57bdcc92c340a92b553dcce7426f43cf0c6ecfd2578bcfa79bc440a0d85af377f46e8a8bd01268c23646488f45f01610da86428e876461c8be5f732cce1497743e273a7e4d48c4888b49a873cbf6d0b7bb87f5cf5b9c6a9a997a1f0452ca3f7853b30f7a3fb6fca9ac611df9d6e996d929b0cc16cab2240d0dea98bc29743237c31c980aa12e02841df2abf4bc193b1e03f67b39fd09f94dc93048f819ef932563316814ec32c10196b7d0bb5afc2378e4db6ddec294095b308b2075073ac62fe1e47893eb0daea762a9cf00ec94cab259c815d2e596bb2c260b4ce42ad47f680a326c99068fe5548aae77f85f2719630b11a81d2b2e607d12c8736b453f468abb285fee937b44e39bbb6a446a1250c871c94ae2c2e6ffc42798e390642312e739716559d0ee6f3ee6b39bd19ff0dd30e38dddb0272a33555fa41aa1c4b0c1a1fea18dc1fe76272a63f47f87cd3b29815b7523d1deb44b1434feaa4c4fa215a59db32336799163464918e3152b495a0733dc304ae12dff6649b636abf28afc9a23e75a29a4ad58ae3233deba847b17cd549f5a494cad841fdb649bf2c8cf1a97476061701d3cb849dc219b50b6edd56f4548f8bf4b614e701c0abcfd4f78d9cc2338bcb9555f26a15d9de80a1d8d10fcb9a6dcb95d7404a4c067f82e2d7ed52070c33857d238927e5ca686b9ac3590ee19c5b6f6131d99aa3eb4e4584a57fe27b800b81fb4b93ef35b11460c88ea19bf0b39d9ded2010df988c192bdaee084c118d6d9a5a295400dde75595cbbf1cf2fdd24238a2ec00a7d1f44c1e8fbb5caf1ba688131fda87eac7540e63340666be5d664b3f5e562baebc34d009c4105ab5b86edfca9879a03a315f1c70a051219125b33b842f2787c8c610583788a221e41fb4622b49156b8de83014ceec94b5cca9a349de91370ec14c2fee73a2440b091ceeb7596424fcfb055c70fdf050d7ee76c2d3ba5f5e63cccd57b46a30a6fa4c2872a6b37003de11ed581810192e26ce5dce7e3dd2fb91cf592d8e09bd1599a1f0134ff4a0e7e093ef5c29548f383051559af3d753fdd0e94622a49e05e87ea15c855a2a835b9eb5403c4840efedf503ce6d48d1535051435c45ed7688783c5ba4fa7eb05cac2fa3ad027e58e26fa31bfdbec61d4fc66cb6c7fb05cee7ce04440615e852bb96bf1597735c8ed3f28991316897df4405af18b7d19030ccae86a4af6234baa965270769d07c52ae375223835cab8186e63d9f17926f9c0f960b6302c84b3b243f51ac7cf950bd1aeb9994ec581ab75e5158e441ed5c4f4f764db71d2cd9e27097545e31cf933748db37226e90b3121c19c3ef4b4d5003d420ca1f2df75a7bdeaeacf2ede91bc3b60cd3ad2f351d9bfa3e923acb5039ca30a344c1d16f8a5af2b795e1d4fae8094168ecc27c1d38fd7f5f7a7140cafd53e70c0267c4a00aeacf126e15251d749b340c4f4e604a800e45b599c21a0f6c6132550c8dab43f09fa03832fb8c26c7c2d7ac0d065832b293bdf438ac4e79170aaf96db5d3daf704115d99162624d449867100e92789222869e8c2deffc11341852f7601b9907b0fec13d88c411bfbafc494f71c26fae2c0961b10361625cdc1aa2cb4c24f504e4c9c79977452145ce4471fff726e441a24403efeda9b711a57cb0e2e0724ffa91faa8f1ccdd0984562cda8a3848ed1a0a221dd4eb38bfbe1e7f7f41ad76e1a9c9ef0b69b67a46c3d24c19db911d46f44187e6b0a5273876f84cdfb68af9309fb97631bd653ed667f9665a04f08fc5098af21504a9447935690f49fc12b099a099c6895843fc44c294603da5ef9f803c37392d452939ab3fd07dc2c20a902d01526a3da2c6192a0842373abe649aa40d643dd64ae774f5964a8a39bef4abca01f0ef2851c32de61e9291300b1dc3642f43444fe4c3ed68dfd90f60b090019d790a140a738c2c647695947287590467d59f244af71b110bfeb92574485aee01c5e3462ee62f571ecbdf01a8e40a2dd09814a30c713657ad1acc724e2d44d286a4ba71d0a05db9cfd973a75b8050ae9efd3b1ba812508aaa10bcdef3ae909d0a4fd94fb13131ab588fe66c457973a6bbb32c88209c25f8592036e6a00776c969ef87f737acf12a263e67abff85deef4fac3bdbdf904aca448fea2ae70d4368b115c092a006833e4abcac8a7c78e5b2a18a2b8055551d7786cf61e88b7e6d6b6bdc04664b091389140062aad009c0704ba66aa9cfe715ff8c2c9c2ad415a8d20849fc3a52868e32a188943da903e899843db827cb43cd5e1f2269ca5495c7b27b58f72eadb5d2625ddd1c06096e0b81c5a33467c82f5fc8d5b82bd4d2943c448bc853c304cc4837693cf7e2e0ff057b94a1261e5c20f5bf77f5277924803bdeb2c4a447e6e0e4fc2f5ea96d5d56143ca79139f82b0cf49c3d244de84348c87c7ef7c4569b8eae54c4b27184db0953cfc0dd729930539fbba86d346e6ce6959450a051c915a899ac8289e3d04eb655516d5ca04b25a0f16adc233079c8b2baf2a81b8d5cc2fc414b0fe3a9785c9afb97d7d609e64cb4fb7e9020ec1c1d8f6d93279e50a52639ba97b296e1980ea00a970d98ae1c1c5e45dbbad5f1a422402e3e4e520662e54a15ab3554ec98c80597589546140422282b6888f791b92d8ef309dd9533ba65d27f3a47eac71ad1e7cd91e4f1428b81fc19726c661bc2a75b68ac426c7c6fa8ae74f3b86c55f67056db7655ba61c66528c959122fd860fef5e527e50c3566e61993f3bda399deba9558fa6467c636bacd48ac91fb2a996821d3308766f77ec61b5d22d7d9c4a1781d24a22a54f9a2879327d24d15d3619006b3a93a10417debeff7bf9dbbb0b1a7ee6440a3077d97f8be03a441418eabd79582d4726a894f9e928b43bad42da730916717bd9d27f08aae0660370e78e411ba36a97c83a8d6c616ac48f125f0d089acc9806e6c5acc3f4920314fe2eb6372f8ac2ac30d7ede1f021090244c17c82f740176c84ee4164f090621448f81de0f833f3be32932f3249cef968fe882e49471058026dce12ee2072c0ed3aed873202735c11b216b60db5eab352c8824dc00dcf6854b4b719b0a22b5dde66048645bf8bd039acb3ad001b645e17ce8b45c1ab93ac1910e43cea954440ed9a57e38fecf3f826aabd81bd34e08912adb4c0371b72295c5fcfcfea841c7b5383168cec4da52fef9b8419f3f7da26fe0b18d9920b9e8b753f0f9fa79df4ce03d218c4624911a41b13c38222ea0c79442dcbe4a6fae71ef7c55c8631ccc893b4b8443251f7912d0324226e32f28c4ed1329197fabfe3089d1ba3ce6d5edb88f7ca88aeb88e9194cf77c5c934da8ff04a04e810ed77d61d04793f4c7d76b1aace4298931b5222e1ac98f08d3c69ae8acf4c6ff45176d6690adc1cdc070ac609fe078a029ed41108ae8261dd3ad2e7b63b2faaa6e2ee1ad3d700d87c66acfe4d3b6b32ec1629d5519677fdc075452d0144608b8c888a85edc686fe12aaef3ed3a890fd4ed7297813ff4a8195a20394098cf980bf4720f3d900db6bf6c66f2b43baba01c5c814a0f9e8c25269c417ac799600af4d9e3515d9aa40545801493fe712a968c5328edf1a78cbb36487acfc54f4265cb51d18c75279fb54bfde30ce209320502fd6614ef4bf4cc60a706f55c97a4bae931a60c6e29dda23c201a984717ecdf57eeb349c1e54289076f9088a0ad643f3e4fc3fd828638c06d302cee35e658f8bbeffe4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
