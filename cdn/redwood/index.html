<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"67cb15ad2f6feba8efce5f5d1b93f7a0354f1a3e3408b5df342982a51d238cace12783521a2e18840992dc19646770bb026913458b45af1fc7004aa497fe7749d6b6cb2979e3b97ebe1019925f8d073de068e3edcdc86c2d60e379291179bfd1f63929ceeef33d606841bb58e147f9b7732f2196dcd420f88ae3eca32c7648d349c19afddc7a4c543a9e575429927294dcfb0eb025bdd5b6570084808d11041a9a237319ddbc6f96dff27ca360f48391178d02f2592a317849fabf4e2629f3addd4d42a29def1c0330383222fe1b5d171f6669a227c44f9e132685b3e318ea56a84381451013802fe1ef5159f393d03aa45169df1bab15fdaead1643c82c17f3427451106dcbf3b1621a4ece2fbd5ba1665540fe5394d048e584797bdd67da2620348c3bb13b23c457b72cb20d3b77f6d37ee5a14ed0343b48ce6d19f5777e8c5a64cf35fcc189dfbf92dce666fa871f8f96fab4dc356f188ca5381aa50a92b4f8c279226010b0c379e4331f6631e733bb3339bf561c53e7a0a77a802bb4d90465ecf86fa4e1f8250e4e2fc6346d9f54dc7fb53b5d80da777d685e3bbbb4be4ebf80519311638ee2adfd1bdc326ff006b77d0b47d9390d929f6bc7f1e542a99162f210e5ea4dafce69e057c5e1a060f548781329afdc62322219f1e46d21b02c1c928c42cfeeb652b01fd6fcb27cb34d6f59fda3148610aebff9f15844aecf61fcce3b738e04b3110808f168f8147777080a78ab7e40c1e2061e62cae0e3a13b514bbf74e11059f42ca99551e78ae4ff6c7163979051f439b5931b74912c8e32656b813be827d6a8e513bc81314c34edd8a18ee6a65d72eaa3561d36286643973b6f6c1f9248f76c18210a8722315d4edd8e643a2be39da224adfe4e0bb069f8bb3301f92ee3396dd8466400868412692a6d801ec5d8a9b464a7e217880c9e6d335607c865dff0eb4b04f75b489d89efa0048fde00c551d4ffd9b4d52173bd60dbb57c70350499bbce763309b2b468a3064a7563614607f38143001add8c60084e6602dbf3445ac3b31bec7c960e7c7601d947738d15ab725d9a727e3655a4f5a7074de9d47c9224a1d6aa43347fe9a9db29ccc9d633e386cf70903a06055119464f361e53946759411effc48c591208eec35305776ee0c5f23ccd3c2733049acbc8f14cf0357898da06c7d5b0844ae2ebc91ee3dd6fd048ba478285c7701d998f4d36286b19cd8ad9f32ada1c5fc61bd849a95f75eb758c4147ddb7f3f785bac493ea00b0d82cd5b66bd6eb866fd826b8589af32b86daccaef1ff1ff24dcd7f3c2a5174aa9adf6c2df97d88274fbd995e012458f5de3d8be9f72429332ed20c51d13d8fc18e82980de01603bd8731d3d0872e0fc3da6d3746078e293c9895bcf0cf1949ca843522ef476abe6d2dcc0374b93071f7f27a811a371ae8d2f99aedc70a7b2c0b43f5933af4b04aa7ade9f794daa1a02def39e7150cb73a1061ac4cd53732467860406af6095d4fb59f01e0450479983fad8dd838687da2041c02ce84e9046f6e172638bdec6040a037bf842b511ac60037bc69f359c710a28e22348f3bc67377c9ad442bc4953bc24f68b52c5c4f009bf0ddbbca5b11ecd23b434556caf3dbc871d7e084c2e99c51406fa362de31f1d4444f5093961df31f6bfe7d2402d8fa7824d60f75139d4ddd5c8ec8c9e83518213474d8ef30b95fd194b4c82b0890e0d15aa3817873a237a5322823f70025142f62be7d6ceffdda6b1885bb7232bc4691002ed3e7e4e4b503f42a159d3d0f3e072bf959c1fbcb35453a6dc86fc35e9d7eedba3191ef2865be14e73cfa9f3da580f1dea8e460b51d01c1d840105e3953eacf21cfaaae94895cb841790e8e2d4f0057e283c88abd71dc8dc6e017954cefd47a3c91b996f7c7ac8065059584c0edfe7440ddd62b0d68f778d87569990e8cab22eee85d9f415aefba9a7b8403db88374f0fbb88f62bade945448e31b80181a20079e975835fadce4491eacfbd797b5fec9a81b444a681f851e9aeed6a32a32437ad0bef5be846ebdf6119be9ec14efb82017b97065c52ef559fae940b0717d08036c94c9cdb5d4464703c612106bbe63523100723256bb71bb2963678eec9468f4558c4b26d91d39ac4243b8432b56ced3b7ed267ec5c38ad71e9adca658b776849126ce4701da3e7c48a0b8e494ae40670ae444e80dce5a21863d93edf1182a7316e6107f066607513670340c41bad479066962f264d9a31969155b8ba1e359807ff4f316289de6b77a9f3eed7f9f20901a2acfb83110c3ac70af1b0d399238f9cffab6f9be82236fb5636a8fa4bd26a31280f76af150678ec68b8471ad2e5b915898d1091c19e0c1b741e5862c7166f20861e4f24120eb6cbe2722b1b6b30bc7da35c76d53384fb3840ebc0895a70fb6172f9336dc9f3c01822afa01ddc005ecc6d304cfe5ccc9a1fd4f2c27a620ef972ce13b2064ceccbd81b7d6794950f6c857d4fea9248f513718aae6b16047ea112ceeca992edb950f9560df4fd7df3bee84d3f318b6304b8252bd3aab9a7ee476fd8ce9a4dd2d0c16cc3ea7cae79dec81b6008a8bb3899b2ffb19ee4f5a76a05f5c0d68c0002099d7fbb219b2b97a551c6b2d80a6136724d696e5a9ac02b32fb5d8c493ca2b7bec6d6373cf23cf3699eeb0ed20b04ccc1fb1e9e9b2956db3e313e95f19260b9728321b903eb6d10069d10b16320d6160762f288c1e3b2a90e29d1f2d8e0f0163dbe44fcc6a919ff0d5c04c94d0914cc8f6625ed7a45f1f13cd147c320a97c342943c6c05b8254e0c7cb41e9df24a5063ac4222f0df983851f5a771aea80f16bcb3187645da3cfa35e86189c75aa9502399a2e21128ad12e234a72e2ef1913d40b135292a23f45807bc29e87ab08c73d7dcd9239181b74b627a8744bf9b1cff075b6fb90a9fee6e6ffc6972c1a1c1bcdff3eb230fef2aca8ef039d7ff041eab947da8d9fa26f1d86462d5182d7219db99c820173d9896ce7c5d08e5ce4f1bf8e2960c6858ca3ebe6a3284cae6a06ef8325ccba48deb4cec77fea26b62b963c45367e01de445496ac58194aace9a46ab56c6a58d06b6c15b62ed0e15a56ef694f9cfce9d53947c45bf414ee99f33065f80d51b5ca16a8a6c7fffa8ebd0eddb0fea19b821d0d7bd3fca82c38b098a02f7394fd6b98ec00a282a5ae7e741739f4049feb6df02f66dff897afb831fccac743a8285cb8b81ad21fcc764805529f8e79d256d0601f3235b52302931d4356c3a25f4f2c76ce3807460f3210bf18fdf65d452729c3f68485a1613d63697a46b3f2f9cb70b7d092cda40356704a467e321b05c3570d9c156e1038a3c1cdb43d48fd87b9e57a2d0ff6540d26d5b3a97c7387d25c00f68cbbd68c2ecdca9fe9110872bc29b35ff215121f9e6ab54a4d074ce1052851e4df0b9cfc5c61fd077e316e8271527e9fadbac104d24b3bb86a5d2c1a95b280fae5f5a1424f3a544722d84d2c3620ce0d274087d5337fd8f3b5312e5b1e9b6b77f4e79e1903b1c8b5eb8643e1579efeff64563e7eb94df2c9486d4a6d0654aa8cb4dc5bdd326f0f2f8592e1f084494dda4adb6947af3ce7abdaf752ef379951ef3c55f5fbcd33e39314e5c2887aaff46b22cbbd4a489282f1ce6423fab655e1b90c4ac275c5630bb6cef925eb1001702628e27cb382a8e6412b046a9f7ffc460c46d655b33704f38247374ca3ec6900a05395e1d6db2f7eb0313f81c42ee34ba5f13879c6569b1931f76b8632943dd2f316b4585219d93ff8a0e22d40b45e4f41b2caa537762082c3cee6e605e907b14a6503cf0288c38303db06bbf84103a478e962ef841a44df83f616e95b950b2e70c258c0988296720d2fc4363a8e5add84175198d15c97c8db35ef7e993ab6cbd758e8e37dcb2a95d92625bd69c3e76113e15e0ebedc601dbf9fafa1dc6c7c74274fdec754823ffcf1ea9701d8681b5a5ce067787e5bd55d7cf3f57a927dda7c84c56a98e9bd40503d75418ef7727b0766355dfc8ce889fdde5f21a28234e01bb1262f398daa999e41b4d6fc9eda72ce73713059433a695eb3ca93eb665ebf97045ddabe19e28871b7bdfc1e1b30860b059c988b0a63735694b8b86629d8ebd899c6fad809117430367873e9f5a06764c436f7848a84edef699cadc20ccaf918b4886a033e2c4cdc5c630ea6bfc6dbb48835c72620455c10ba43de2e424a4dad300e1aff3c3f7868e313db570520ab5b01f5d9baad3e21da6e5f30871a9caee2085be32a0e9064ccfa327d947be26aa92e55552bd0591340eaadf808cd5b9bb2876a5e11b1adf912dd747e9467ff1c27d0e743c3fa3ee351d35309ab679db10c23eeea9bf447ccb0e4c2c6b46b5826f610f914b34ee6f7ad3b8cb8fb7c3c786845a3aa269be0cb28320b4eadec97a62bda396dfdc1f2869fc9455eb3eedf433dbc4beaf0ce4bd50759d34d089435a26f19ce2d7754f63b8c10d15dbf2d6832e5f5660a57e0236e5230cbe02219d0dbc5aaa27733dfe566a3a4e855c0cf0ee3bb4fe3a81f49921886d702a818d8b597b415a947bea665f2b7657c79a189e102c823bf0527506689be107085d5f95a9de395f8f117f24409fada96403097a5a52d1d188faf3bd2a2ce54244f24b96cf1e86a5debac43dc5deb4363079184bb5458d42a16e84611fff08cd054baf180b7428911057c932821c3d966f602705bb050f23b5731775b42cc2264c3af20179649b101477b081439822a878d102b67e1f3c0493d584a01b64f8c69033786ad5cc695b315b1a6f43b48711e19684ffcb7644fc0b443b7034b4fcab0a580b0d2aeebf85bb3ad0071364b44a45a9f1b57ec0843caeb6f7890d47dcf1db98a969a5d2aa6ac22537eae6f544c9bfb4b3ee13e4d0f3fe56dc711f8ad442e46b4a134710e8fc0d5dad7d98eb6ac57abde9516c8b3ab03ba8a9c7065baa3ba0912eddb18f46699c709f94aef752407d6d0ca0418076dcfe432f980064bd58ee34deb0e9abd2c3b8d6d8228e3516f26ff084de23456275315e3c15139010314fa616cf3ba188b7957617f721e6fa26c585d0cc1545974d4e65804ff7281d7b857c9e918e091e8b1f5870e2c9c26c06a6bb272b5d07b29966ebe44a7a5b7eeaad8f2e369e03e1f846e54fc2798ce3e8ce4f5df7d50f4c14ba3ecdf7e303df59522531ade0a926f336540798c67813ecda678e914651801b6b31678a8f90b1a68fef557b4c148912bdfd266df9fe757c925192fe1cd27bcbcbe9dd6ea2ab6a6badde2a430e5c46bb237c500cbcdea484e421cb5ea5366d62590f5e1ce6a04907452f8eecec7c82ba5b226988e5849c7df126b451a9aeb8b767b80395e50e55384255f69f39dd49ad9fd8374c22e251e9e5ea6eb904c9beef38ef0540e97aac1a347d0ef6aefc41ae09631d2b932dd474f5ac832a43c3a06189030e6874223b33296cb89984411ddec666e2cd79bb78419b7419fc43a108316c40a8084fbcd4a74c963121889dc22f47f6e6fc9de587df9272c77085f62f77722bcba44befb7e9a33d4312c16e53b85734fd0294546b4d11ced99b1f6bf2b9c7484e5f3b00a201658bed94b8de67133c98ea3427ed46e827f974e1410bd08a8d6818ce8fe29a060e28e6709035008029b115d5ade9e3d770b7a69f2574085219c0e47f340012ce363ac92446415649091b7011175fb8e11db5a518a746684c764013cdf906429ed82d858a12b5afc9edfc35c11b9cdef129a2144a90a3e5296b5d9c0307863a47f3792ec56c690ebdbe87f51739a74b47c08cc95f6e940b43556863567d06834103884363054f95d0600c800f211599c952387b716ce0295375a407da3b9522f8eb7a7735dc943ed09356a220780f7cee703e18225cf28569ff0fefaf4e40183955774eea7901795959efdbc3b1fd7fca7e92934acfc235b79c967517b3d4bb5e5672098ce4d25fd5e428e3ac8b999af06b05419837cc75b34812f7042c9eacf60e1f5d9b7b2b0156c153d8825d82e38d165dcc9b7e8519da80afdb5fe37c954346ec738d114d7e1f5ed183e0e4ff7e94780e96b481d0db0bcc787fdc10ee6c02dc41d0e1780a0f3c91eb4f9d27c3a35a404722d173b030932dd7b66f9815fe3b0da4c2dd8ae15350b3c13482b0e129c887d4d4c5561a6ffd544be4ef7fe5220b94b0bdd29e19ca063708f1181baa85cc93625cf342fa50ec36ba5598c9c5da8d4211c6adc6b5dfa5452cddbbf503a00335bf51a50085c2daa45cb8b47cab42f20b7a638c16fc4773ea2dd620f6e2e3e737e7903406c81df434d61a4abdece557f4838c8b02688580b50a1d5845ae21ab68696825636d6486d92d9019472758ed89b9a4b61532fcaeb5a68e26602af44e2cf91d673a8b14cac7903f92e973b58ce6226170b0652de8ddbe4814d40061e31ff95ab90b47fec257be46fb152bb1120d38364fd4bbf0065683069a7581569a3fdebde4f9110a4a11b1d3f2e2b04d6c121820e434b04467e90fe29ec87350f7935fed4433d435580b0e2c2a3b0c380b6c006d8d91438aae15229471e6e1f131b40a0606378fd3aabcf44629860bdfce8c4b50d46cc822f4d5d03a6b3ad5ad48029c04bbc26b2b94c2e5b92ff6b020ed4ffe1144b6424820dce1818214a2216cddf672ff90292574403d58ef0999c7ab83280225d44c85a3c38aa455a5f3415c10f1a7ad4faf9e5188f531d89fb7f46183242f43348cf18acae048cdc862002b3ee1a991f636e98cdcd38e1a7ab05b859e2b016b1db608f55260c2973a1e7f89495fbe926a05929d5b6d69f7848515ca2037420ca4ce67942631e126c679c401deff91cfc68ab56a99753ca5977a8046a704fe4caa26a5ca6b0edd04ce13038dc2214f1ee70380498355247c38202715f37a91e897aa1a5eb3cc78f3e8a6c5bed5f5cf6a3d1732775236c52917516ef2beda5754138f61bcb9f3539928c21fb5d0cbdb49101cc13a0dcecac1fe68e0b5ad38de1a0b4086081318c7b1c7bad5034db657bac16af0de9c7d619533873f1fe52722b94d2cffe6cb2f2418045c2dd53fc30222eef17db6cd516479294ad08057b38d4bd05a6224ecc58f1751379b5d761920768c4f7d0c6bcbacf27dffe1a62c06d17518afcf2efbedd63ef3e8bb44fae6f69e2b847ea0537cb245a1dea6c9ae920cfcc97d54ffcd86b38d3a2d2bf68e87712296ddde2392c186ddcd1f10ffaff8826bc6b17ff4a1cdd55aca2b3d07661b4fd473dde9594f88501a9fc653fbc145c34c3fa5abd95aea64cf671efaccf67f2f36e5fa0568c8c13c9ddd7148b6ff4ca49ca18bd61cbf904c567fab50fe3da588c2b424fbac06050e64a4c0fc6e3f4a156ee6b8e511267f13bcab87448d89fe087ca579917c05fffca5c2fe45ea6b0516ed710168f615226d3865a674d427c2551df4a0faded7c49ddb508d75bfdafe87bac5be2c5fceb1cb0872c9ac5ba18765cb2eeec0deedf86fbe5b018f196e6bfa41e7b85e91b6b96d248f31bb140364ae703bfc9a68068738f1daf8638ac06659a0246809cb67a9aa3b00bcdc450f1bd5ae558a7f46dc747d1bbdfefaff45a790492a2cf062082ae939879b30d1bd65026d9c296bc3e7624990ad70a72924bb19ee44182ed23d594aa0c19ec2092e0c89d59d4b6042202b577f8794c24447de3e15bc95cb342d87431417340307bf196ab3f2dda2c3f4b808c253ce42b7c2905085f22375408b40aaa0e3437521ee737c75945fc9f0ada5cc5f31795f07847a5453cb6538603e89c2344ae6760c6dfedca33ac43850e87389034e33529260d6d38f37dc0e228bacbd8fa4d54e753bb9315f8f66e49f7dded60800007125378157a21280412f069a991cc9d06df1d0ec1d1b1772d6712496df670ac55f1a619248601b357e7cd10ef00add43397a9ed6c0b054ea92b6bdab0b316403b02d1587e5e795e924ebeeb123dd9338db8749b82f98f9c7d04f04059b0acaf155f95caada52cecfac1dc3d1fc08f6a828e9f3a640889678f70e808eb3a177cdb8736f75e601c494f60c2837ea614e921f2e0d83241efc314c7764833eea7d7adba9d2ee7eb57f51bd113a98fae51a871a6e320bb16a857383ec86d58f3620de71b5d4bf55fb07f20b59a0c0521820c4fd9e7703976d58627416a79d9ce59fc7937818d8f2ce5a772c4163cf3f76730a3aa7d47350fc687e2aedbc941b81d4e516b56a01629e02edc82ebddc3ce7b25240fd0be9dc758f031c5f94d50514f4861ae50b12579fa4d8800187d43ec2e5267db11d09e208c7c38a8baaf600f1796b2d380da7ef6eee0792e4e672d878aeb530cb71a7849cdae0190e1ad9df3db4d699ad4f9501970f5eb3a015826329cb0cba1da4085ce48f460aa11d397a32da438deb443899e788fc631d7df0f11949c91af5763fac4ba965f7e96c4b3f4b1dae8e778ff7bd45d320d752149c4a203159d96be5f3744fac24e6274686f2c129a36bd95cc179759dcaca609273dff7551553fc8e6809308ecfaac069f77d1dee62ccde660a758b14e6a3aa906dcb2ec902ae0729e17525b139bf6658473189273de37e32dff245baaf72a15f157514d1477bf9f6c5161a0e489ab39d41befa889ae1334122a89d5eea5687f18277a1c4a69ba988f1b265bb9d2a1d2e0a4c275758f2c6992ca99e48fbe8d5e7c0cc13631c2bd6561d0d5e6abf0927eb691e1659f8b29c4dee686d1644e991c6cb615f201e0862680d91b6a39a68b7e52d68a78e53bf0048402a9301089ef7b048007f25894d9ad9e10f03bb9836dcb33159ecc830726bb97d37ed4ad22d60bea4afc92211b66497e542b8198677ad8862c1036c902019d1be7543ff83fa6baae21368f6dc788c3c79911aaf01db159d1c07e7ef3e443967a8917097eddef04a0cbe3ef75764630bb131e7a4bfd2aa05413c6e54793648ce1adc6b41b571eb2d94460bafeb18d89c8f68010fdd77ee53ab48304273b03fa213404b396fcb15bd172a4e0fac5cb3150ca10aa48a3592e8dfff838f080d8bed24dbe4cff7c4616a4b6c7024f11a1b2a5875bfb49d0c41346bba97c4adb5b6b54bac0fb749b5583f76ee3bd998257f3ee4cc32c7d3e0d689393215c38770d6ee46d2c6f94d9031a5067d5467fc7fe4415540792146061d9bfe81f6aef1d14938963c3922788cd01a3333a4c53f2cbede0d9a99a03ea7b942dc7b6bbfd71acf503f0b9a36f0de96dd8baa0c71b4b0e84f3f1bd70d6433e5e2a4723ae1a8bd999d489c7fb36951a322c8754ca7685f06f927f28526211e9f5291b67e3e9b2699b317f940afae9d5c3a5bf6b2845abbf21e955430cd5d6b86488c81f74adadf537f9eeb67e06e164f303e0afb3310c71bb251a53955e540b15803e49e3219000edef40fdb40e1c92bee01090e3d66c962f3e53c509c5a4e52f10b51d24da1e5cbad31da8d87633139120c416e0c5fe19d1fa5a6863f203db380727f8bb83b8c79137e7515fbfa433bfa581e823518a686bf11bb87d450307c1e5b7c010ad22320bb2eff1aa11bd814f6c105e54ec51828df55ec9112600dda55b5957b0687a3778274115fcfd14dd9e6eea43f840813b485393b5988cc24b45a200bede1a65af9bbe47a17cf99cab43e0f599aaa07e8c4cb6ba4ea33085721bd0fb9827588e2ae7b55c75c20cc46beef60d5e52e9f6d749b30858c80fce61d1198eb8fac89228be05d621a9018b2db6522a1152543e79df3028fa78d5f48581eb79b243167dcb9ef23210cb04da1c372dee7b756f80e8d31f7b086e3ea90d6c1109889718b1dc3f25c4cfa1b874808ba7e2d635c24d58260d7787a20f4ea1573db14163ee5ee964f56b8c1961fe52729ea24a7ca6263bca6cd9d2a589b4c9d4d03c15925c7d819b8e760e22acc45e3ff2a95f98ea847546daf75266d8a4082fe9698a5bab461ee5d5630e9d46e301ec9844f735f501306cdba9cc546a022909a22912190b78007a2664778cc591a113e904d98569c38db13c45cc4d8a9b40b22ef88c3112c9e0f4a2b128f37cf4402674187c5551f11267187e0226e804c8caf9057c7ea8b4555013505498d443bba3a5ec51b970a01688253415103da3b1f61fed449a11e84efa5e819fe97322caeba1c0ce0305bf51fdab7181fef4482b07a6dfa96e0f26567a4c800559a0986262458c04c7a27fe70114b7316d11bab5a5aae246fb91140e964f9056ab8ace4dfb3f67f5eba4eda1a8beaa8c5dfc5d1693ff99dbf502dc17f8eec39fede8c3f241af98ee3793838f84f77a1a24ea4cdf1be663c5c1db7cf010583f8c0efece88780ac6f95a647d6a7d74cfe6a013d255320ee39a2ad8fd5285aa7803818c0c08f748c27c67e546f654c0c526a31a85fbd0a59c77782e252994e0c59d466a87db7bfc77ac7efcb4e133daea055de91f159ac634744d2a49ef63b96f0b0a93bb7dee77f83c721774fdf2bb7f311ed289dfe898d26927010787ad60a4a27965ebb7718d85594fce3bb9d108c133281f1b4c49f2648f439a401bb6498fa5c2e9ca4515c85aaa60f0310cbeeeef84f615621f4415901ab83eae097802f7f8929d40e2567e09b1eec9b6ee527dc9a11b5769bf8dcba9695229b585463b52cd60aee6119e5cd6a355355a924c84282f380347ad9436274b195e7d68f2b8bccd53bf23417ca62c83b56710624f01c513f7f5f001f44204a569db512bf4d2880bec5a9c505daeb445b0fad8e738b7c9ec92612fae75277fe9d75ee787a91c74f8905e25fc86a40b818924790fc2f3216665928ddcb2a33a18728c082a80380f6715baf80962d650be5991f176473457261c5519a208735b80511144f679b11e634b1973494e5aef2741153ae73ce8a21647c82d0bebedc7f87850c6c93ee3654f7668b4608c075ed1b1b7ed56301a7fff4208dc2170b3b08cda68a783e1f0a1402007656f6d6bc18c0f359807abe7ac4fa5258ea742ad8c3999110919b9cf272e0d9b0158085989709ca8a1a0984128a71eaba91e659271b7d09b0c2816bfc6388558dc51795579b9cc48435d19bf148d2011e790214137c74e235a83bc0823f125873176f29d759a81029609f39bb6e9c179496ee1ed368d2ef36c6446334ca0916d04966ac63da4d988e8ef51761301f30e0501c5ce044de5088e967c4052a43fec0b36620ad3db875c87437dfb2d1f4f87859eae4b608607895708bf9b87eb741009fa11c0cfb3949c9152786f60a0b09d77ec8225d8d22ce3f589201ccebbb138bc39fa4145073d6d4246d841799463d0c7e0e5b1cd5c26ce5d4242e8b000876c0731823b7f825374a6b10740a1f00936fd6e46565f039b6a7f76a472a9bb4914d4f5fc2945b221b7cd66e4c22b27680b3c7dcf8081e339a00da6af4e60031c2d1c4b88a438648563abf40e5f19b40c03694af2aa89153019d09142e7481d6454eaa40fc7fd132207c94a91d75322fcfb48d624ac284152721545d0fd68bf1635e30769e9713e7cef91c353099c871caaaced33a556dbe9e153eecfb5ac24d47b36b5c3d2cca4d20335342eacf24adcda7a8475875abf0df9c3edcf92ebe10e5c02ec5a64bab9807c83a520247b06e97f7455c37f9b00337bd4e2c287f56688b786e1ddb0df28fbc84e47ac890af252f6d0ae27cfb86f629884e5f45abdf217d424f4c7780b25938acfea7629dde0c50e6df09a3dc7d0f126f175f7c59a7b7b8fa05a6367584fa0f721734a92779c421916532682b5c1fec57992f1537d19fd7c6bced99b22ebe1029119ece9b17af0ec6558da934c29bbc6fc39e59fc313a2fcd2842b4d98c934bf8337d24c1dfd497c25353b54195d52d593fd495a05261b8076d915274b24db8a195d37939073f1f7058b57d50d4e9513a15b3ccc50de1ca50de8c25db53b6d7fac39b2ab281973d677cb7ebbf8c19740ad1d2bc5089874408b906e2692ac49e9b4247233a31f3c44691d43658c187e213ec036a91c778b5e162efb61feb243365a7a2881dda40d91c52d566b393424ad1ac5094fdf2bded6f6331aae7a30605bfbeaa07c0532fb8fb026a529115018c9443f6457ddbea38f69d216118739dc16cbb2efd702c97d9f7fa2f47892512c287995761febbf647cd930c2f665a0c9a5e8c2f7a3f1c2df00e9eba8394789bd7c1fa4c2ea9e5518cebc88b1f4cae95ced18092b4c9e73278a72717c10eff0ec644e03ddef29d42b9312f44d519c2630f4adc00c96127d9099e7fb239ab931b474c4e1646d5be9e3312613887dc0f42aee3779c2302309b329ab9a60a9caf1efde076c01a5a0ec1fb6f2ad1e12c8235e5e88bebe646de1d738b6be169ca40a2f69fff0abe16a63cc3ceaca973cfc710a6c10f447ddfcc298a4eabad599e72458b2440bf81860c9da9056924f803935fa860f5a2c2a0b7ff55f4c9ba4cf031a54bbfc1b9cf402d1c4a75a02ea846bc82bd89fa2b392a134ff72c895949dbad3e4c81cca626b643f2dd805efb818a45d9158ae1d2043c364851ab0d648e09d8c9c16e28181431a09e08a4513338f02e12bb53d2d285fa29ec64463acaca3a8b21d5ab939ad1f9f971ac337c84a3fe99987728527178f5fb4c8de9fbb295d0b4b712fa3e179dc331f1310b5b37a9ef32a46cc68a5f91f6ec912d4500991a60a875ca4f04d3dc3b854092ae914f5c6f180b92d97ab837ea51d34671156842b440bfc28c5d462362dcd491c461eb033b476c290f9ded119d03a62ccec6c9cebcb49d20c4aff113818857c0522c18457f47eca016fcaab9bf6dc456fd8efec98d65ca9c68e98f8a9a2d89f9b4dcd0316c993455cd358c5fa7f847209f9266ffe11a306579e14abd49ccf9dca5deb7753348b05f62a6f774c0e9a12a5bd05a3d456260fe2db9aa20a4766272b62262830880df5764e5d8e77e5722c6f50606155e0215cdc32b8207bb0fb829f3b93398b5b3651f7ee4c301ea11a65841bc17648032ffca5ffe1d1c5805c3a1900db301a76f53c7ff6f2d9a663acffb98d07abfc3081d47bbbf703ad30698167df5bea2bbf8dc131d8e73875f5a57ad2b92639af5764a754a2661f2fd4134b8f3adf50e14edaa94a4d1b7ffe06b8a7c69d0a274d266d2d7ab3b02c65755b03bd01045cf3346207caa9af85269c34da363c58635ec9ff643b60e1c44c4aa6cbb76b1530f756eaa676f330a964d94c6741cc1d6c624901f6f5d1017307d3d258c5b79c588a8fdc58b89de5d5e5c82cd8152b878931b990e7a9a9684f3c76aa4b91a2988de6c077f3beab25333c11387ba506575e7b808755cfd3ed5c5234a0ce7f7977142315dea2cf72bee5456507e3a06fb19d745dd268d6d3004868219f290388f986b57b770ef7e9704a1c677328668f5670211743f55b4c4cdeb9f02b14a8abf958191ba9cad533c77502f60f2dced896881d46f3dde8888eed0c24d2618f5861a8fbd86cc5c29845818dd2c2de26ba4bf5bdcf13e0086654c82d592779acaf9476572632a4acc7c2ff447487a3d1331659d8bb72d46b2ff6ecb9ef04bd2edf7871517a6b9c348fda2c2460b64ea175400b282fcf778a1fa5dbbda48a7df1f92849a428e35ea47bc1b60496eb9de37eb4e7cf33dd365b7558dda5b2aab8a752ed44f9027170ab1025cabcbd73701f031da6eee5b106dca222b28757795df1c4df644880d7fb3a431af5a589ab7912a8cfbcb4e7d7076da66d5a9301be5920c650a1ca63736ec9537de66921fb4ba9d4add18dfa5dc3b371596ea819d8ea43ab07a45207e5ef58392177e84e0385fb328dd31fc22de0a3514a94308027271a9a7c061500ed59d01c0c1bb6c3646737ace7799f33a81e97a34927d763b78b879aa4c23a50a6171d7b8b9461f7a47b3a0c96bf8b57df849ab89c30e9934baec8152da88c3f550c8889d7af67f80e19962dd194b5452fc15cccf7a2fb919c46046a5ecc6da332aa01d3aa5adcfa28fecb85807ce677ef4bf927f4f37abf61503f6a71f5f3a8cd881226b5620c78295ac419a01c68b53259a5cd2e3957bfd4d91d7cf448940bdd6a9332a3610fce79638825badadad65a2b72cf67c678097a5c0ed6e50b26ae3a960646d859481477e32bc19d4d240b3a602d5f78f6862e24954933c0d593e6ded570853082eb04bb9af75da943dfae3b9aecdf92a80890c2425aba26d7407615bae79e7b8d53201e83e5a33ef84d6af950de48bfc4282ffe22d66405ade66be5e126a4be9fd6143e417c747b681e4dc66ceed6b768508dfdfb172ebfd4650feca3fc497235efb3d0659cd0381aff588bf5bc46741bc421ec0cb9b388dea4169444b5d90d73d30912bbdb3cf4ee9fdfce60141960cfab6cc9747d47f219d06c692e018dded73917e5ceb5e7a0d49d01c63e01e7e14308ac5e9a6fd3dab6bedfdaae15d28e057cf21ce5310fb4f471f52c629ea48b040dd7d5e4c8e5888de22a6ecd9b2f902e32f95da94b7344f9208579e13fbe9b6514f3f8333807291403e476eebe8869ea154896565bb9de6adec0cdfe9a6fd97d4d9e45941d7ab8a4ea199d02e25b2c46bc33adb39182fd9ad46d3bc370474c4baccaaf2b0d4d15e3dabffac8b420cd599382409c7e8cce9666f842f053f6ff08517283cf1709c10ea1b4afa1bb098eb18d55d980d4f826c00891861124ae02ac0e534f044ba99e2ab17bc9d9e10b80f55519aba49cf100edd1db2eee2e465384809982ae5f68a637a1764dc7c9cdfb4581b9c0c7ff7cefb495548afae081bca95354b29a7adf7757811aaa8a373a2dcbb3360fea9de54ed0effb9492e8f9b5688e6a8e7b18a7cf45ef732bd378512aeb5a947a8e5d2a4843f487d201fb7b5edc6d6d3677a6e8597226d71a726054f84ebd3454a531bd1c97237e2468e9ab7ecc81b885bc18794e278b71e42b085d4fdfdb575bb6dd4b1a6ad68d91a4de5c54b36acd0ffb586cd9e8a0351391c34e19938c736063f6c0d6d37f926d7f83984b8bca7f8ca044520b7736e6a0f37515d633bcfd22277fd554cf60de40d37a714de5c5e7728002e44d84b02f608fd78c9c3c4057f96e774e4b50fa4ee9c9a5252c531c0521223ec275821f30bb5a5a9dde38aff09df3fbefc2576f355eb0abaf81f452203f6489ac9f1523e943a0b7d3ab8fd87b98c3a0d58bb03c1b111f4528e680d09f505cbe7d258740fb36c39aecaf8440ee63e1ce5da707b86e9637e6afaedbff344445f497e1b0848152bd8eb4e0f8b262e25d80cbcd722806b2d5fc64cf16d433643a479c6b25731ea0cf02c76deeaf241505d3880e418af4e978947897b0fc332bbdf533c63ec8b7c1a64d349a31fceffbc44b78abd5f4b2ad1d35422fc311ab06153995b59b69e8ba9de9216ada6ea7eccb900eda21825673b21fe9929adf98df7ff95c20a91d8d2db47334aebe0b9d03052d007a858031735c413623c8194967df7882fa173722d1d8b602668f519ccc3d9c79fa9719355b43e2fd02762a3071245f42baad27c8c5bcf4080abaaeccc1ad6fae2f52b4e55353f74c78c55cf1dba1c1c139e415f32ae67fd689f3a4dc145ff844f27be2092f7afb773613900165add7ba0d2369a431853e8e94b8388bd2b2d1200ff5c8d421eec3a05f4e3502d0d4eda86f87ac397f0395ef04469b3c7daa7812c23d06509048f3a8e64cbb7e5a136ec58382b0398f0bbfb57afe475abc44c81102c32c527e65fbeb51ab8a3f037e5250dbbbb562a5a23cb580b6d51792a3a8e2ec45c972543ac477a017c79cc2e590d3a95baf59371bb1d1cfd5770aae6f1ade2b801e06f4598de16796f38373fb5135e9cc28cbab346a0425c0d826c5159376e0295eadef349a6d886561c0251f3e9266f81d64776d080dd8fd71d495378071070ed9622cfd4bd385959593d8f34c85e4922dbe8ea11b60b5dbd924aa4bd69d9ddfc70e22d57965426ce3eb33635fe2912622c8984ef0c88d57c0957abbe217b3839ce472b0ca4cec761b5c7ff71c0c56974c2b010c6127f2861b93f18bbbe5f878c1cdede82d7e318e6b4499729a926c013b1dc0bdcc21aa9f6695dfab870e6be8cd21eedf716dd78824a87a6c11b59bb076a2494d56293ced86d59892230fd2db0942a3fa18b8f35f08ac32ab285a9ac559d2d999fe6aeebf1c755545a7eb1cef0c21182601fe1a2350cecfbfd6d0d950599391c9c2a14051d67ade04b496f43b195de540b84a46d692fdcb463bd67726875770e98855e1f978d14156def4662c77748e5748c3474934c2dec9badf7797db00c8e0c1fa0f63759a539721cdd1cc1d5b49a499901c0ffa3f2b978e9d017a7069f6b45f941c1936f3511e4e8a253a006994e8638937ad861e086092ca2d33d336a0adfedc30302a65b9bfc83d7bcd2ff0154e299dae0aa29297cff911ba61d8768f96688b345ef8cd534ea07eadbcac27cab356cfb71273b016a8e25963f00d3bfea67a06e0a7ed9478ebec8f4bfa66729e68aa39971a9893a32f90e462f169d3ddbe73b44f3a5f1694f1461c0a5a5de25288409a17e69f07f06d77da6faea893117d7f552961ba19bc126ca5db0c9921fc7cff9e657b44f613da45fe5a944fb7d71874b1186dcaef297fc46d03b22177278c6da56504a888d284e06ba249464fb2ae6758c805fe18ba41724a694ae574982c964d9b4ec629c55bac965f616ed0a8f2c7e5ccf5d485feee5a9e8513aea99ffdf762532451f42fec661d08bdacb1ffa76b234a75c9e6521f9132ae0e9ad211540639b1e1b16d251f34910cf72cc175dea531f95881e3aa79382de41b8520e3987bb998aea00e2b9dd288f4285cb4e5a1855514e9789de6c54ca401baae6be8523bcc0bdeea4d65f9e29dcb8e1c24c2c36088a5a42d30043018b2bb45929e1b7ee8e38fb2b5164e96dc3ecd3b76abdc9b3df2ce2c00adbde8a04649df00663f02806b59e54a7a213cf5bee9e846323b109fb98343562f700f8d3d525f5c9da918a473226f64ccf5d5ce61efef8189179b1d5566317a5b4fe5e9d95bf05a1affe9e9cb1e890e7439dff14b7ab8f660c48af6504bef490ade15be3e603fd33984b30f83b1844e28f3ab54eaf3e803a197f5d1aff4e9dd23f925959d0802e42956eb5e1c621e4fdd80f15ea7669649fd238e30f8d09b5c7d00da85284ed9946729affd2cf00bba9cc91d00b8159ce752251830d4c7057e8ebe47ad68db63f075755faf034645b3682db70597c32386c98cba70bbdb2576038612b3d5f2303e920e66c3dd9d86c29fcb4f2a26f059c69d70d0bd6668572b9d3c54f8d9437e1ab71ed649f03045931a9f91ec049fa51cc57f81ec4c43ac5c2963fde85a1b736847d1325c27f1eb4ba8ca59af0406e7bcbfb83a0fe4507acc75e46845e3ab82321d74856371f52b0056296fb79393b0216ef577eae2b99770c22319c896bbf0b6ddfd8e7276d60cf33603c24969643529d264a047cfa21a1eee047f28976d89bd1a742f16ff9b9da875ac6d05379a356a656adfa9b07e5ac021ce3910f4576549029c391bdff8999553ff3a7f309a2b93548ba8dc657d38f2090f758fb62fc6ce3c70bce54a75bf1ae05598606e6ceb1c414944831323544c48d48c11fb44601aa6dff7ca56d20f006cc49c81de8d3bb9de12b6d63ed8952fd77fd123849517c6cb6cc2d606e347cfedff284c776a946cdd157694d23b566bc9b5df726f38139539e7d7e93451a5667f67d3c8ebb414f30d5e51b91591c63f59a4e007c7943ff529d118dc3d2b4dd507ca4e11a07c9878beab7d66ae6df10ff41555a418867acc583e0c386dd4bd10eba5dda88abd37b379fac6faebce61efa3bd8577fd437c5b5a8ebbac9f56f4917b0ad53dfada3f922f904b0bfe894cab5e5232075bd947f30aacf2400c71fc2c580697920e8060fdd7fed30f1f602ec16a0d16290bedf02bfde037a95ac7d97f604ff79c2c38147eade5505621d92a15a4a0a3ed996eef329a4f6a9adcdf24a0685b96184af84352f954c47db4aaddfb2d829b1b84eb718885023f3efd184a76c9f123fe1573","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
