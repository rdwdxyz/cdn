<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4c72ba886e05ffd977fcd04d9c656220ed008990abb098077a8f91b9e672e8b055773ab926b7620f509baac53718a10a84307be78ae7122dd62aa8412c11d429494a18b0dc1d2d86427d2ffd2d49767a1916ed013119fc64894cf3924a579cd6a23ecaa5c7f02e62b24c6f26b87e39fa6b09ea11fda81c6fe04403c8c22bac2f48521c0f5bb2ece127fbab065e302328f75a87201c53651fc941c9583c7d7551cb9b705919d8524b2dda9347683f5377793099e1b65b85dfac091856f900a6efecfc24bac862326f7e86185056e2d5aceb2a8cbe7b60b642598dadb046c241e94e30e130bedfb29f3b89a0a00a83789fcf80aa970b58e7730f79f0aca9f621e81052d779e530c75a90107a42ee2f98c5157639aaf2d6d223ec4e7d467c66944870532b6a93bff0d358e75a42ba6356ec30fdf0e68bc021c1046e33801e1e5eaf64042afceaec4cd7e0613f18c9d11779f9126f5b793dff21590616f117aa86cb6e319c7fd1d59519ff7e5a4546d9c16a71e15086dbf7c8f3722565775b85ae6db356ff3524f2412167e2bf3f251d7d487ac94bc92dcbfe90909cac14b9b97d0452d00973e15d40dc6f6dfc83a79232034cdeb0b2a79daba9b8e7e13ab14669520d7d7bfd522aa00626d69d191ac18374d5a03d949d608db1fd70eef719f992252df68639e0bf479c9a3b77184f0470aeb028e7ed5904e488a60f1daaba6fe10737b8563cf6a05729d9cf64559d2a44962a7f7dd00921fc5d03c3b7987802e82a5906350f7aacd4f866a5d666ee1b8ae7bb93244c0a088a52a2ff0de91b36e486b9fd0d6617ec7600b579813d357d7e8fb8b2ac8044528b670b8b0cceb36a1ff887b2698309c45e5b9a4e3367fa03272cecc2e4dcf94ec29426d7adbe4984a0c9c98c820ece1d77a4cb2a7d015f6383b61852ef2c03593e74f92ece8613569b7d893d8b1469ec2ad8775cdb16b709d3a9c8a53e8c3460c4e0ba1449917501beb24cfafd4d54e8a0ee516cc84380e8478edaacab3aedf94d6cc5fa7fe9ebd2b9b62afb5b6acf4ef623dea3a3b2b070c81b01dcdc2dbd0680e8f2baae9c2b28914c6e6d99db588630dbd37cc93eaa1ff194fd6b7f8aae00cb4813ace3f60724961e4479bcd18e8d9fbb441d898613b9b93cd45b1b6e2f1c2bcb9805d9291fb5e35a8289c51b6d2859f402d3cd18355f8e483e23d68f7db0e672d38befd15164cbe5bfcbe4fe4eba038280969a20246423e2078604cd038936e5e058802be6f8c816b4b402eae7250e74ab9985d5e33c91af5c98407214b1f390093c6572f4e8b5310447f6b87b90242dd40d39c5281bd069eee98241b791817d466472bfd7be8bbd384dafc8b923cf5932dcc903a9c7f2e3dd50a62f5ea37ac678e8d2c6c4a389928dde053e5ce37ff70efec8712afd401fc6e7d80f6eededb2ac7422bee98ff9965c57435cd4d2043c778b73120bc1b7b28b3bfd3585e98ded84186d0fcbd36dab0ab962457c9a19cf1d9f1f65107d86c4738dc8a7780763bda2e70bb368d8d4788f70e93fcb02c93f95e388ee99bcbccb8c96121db61a7e4086f72061436ddb28d684a7d7ef710ce8f109f5f4fda3364e16ab70fc4c906c473aa2e7700cc4809a8da8379d94b61023cbe7171a619ea8823e88c5f4f1f1b0c366b2033d07d62726303d4152054489625b5d19c49080827c863451649a81e8d0e000812753706d2a13a8b8d056d212389db5de3f3381f2a75c436137b23c5a8e6d84c0dccd7a92912e81228a0264f990acbccbec295552e115cdc745a929a87cf02d073a6efb09a6cea543cc4429e45a4e93c6b118c0b2ba20f5866d69ed309d12b5e85193cd3c050c10484d1c47aed845c2e47920c4ee37801859e25797c348956ab46194896bfaff6a6975f6a6261eff36b85a02d7bbf345006b41cf8f591a6dabe1f6735f993168ba4f91ea9c295c22c694a4760665c3aa48b948c92edfcab2355ab7bfaf35b8f811e0ef7bf1b8bf3adb72572c6570147d3e135113d253038213098914c5d67394099da3e2b31ff65131fae6c2f6ae35ec9c3f398e14328d72af8063b3487fca64b59688c559c334f680f070a4cff70993d37c3ce9efc9029b1ac4fdc25d75a4efa08a25ee18dabd182191d6c1c5d5bb3f1dddc63dadd32b6507dcbee2cd3a0711e85f2d0d0f4ff4bb841c074c0f7646eee943c5480b22ed4246736ea23cea194736c55166bbe8219659326fad5b0f575a5fedccb5ed048bb92ea1efce719d5c9ef368508cc556e8ab4d9a0db996995c2092338657c3229a47aed2d85e2cc0ed64715fc6b04ae0d2c0a364f2f62b35f06dd0d95377e8796c24a680edd3597a58efdda56682313715f6351819c5255455d9a5d8bbb24b4758d2de84d8d78287174d91b99c48e2c2f0ee286d0d025b76b5df493822ef1c11739abd6c46436f535913e89468497e48ad3ab9ff5833e847946d5b16067736d82571a50ff45552e28556a73afcbe83799869a0994393b81ae67b962ca87778a06d10081f20dd4d946c8d3936f55c9dc78d753b05874879a839a2a0663139006d1941b4285dbb730342dcd83c958b23e4c11bc772db3083a61e452a8f419aea6d98c3aaeef5bce92920a390fc597188b4c2c0cc663964288f19b708ce1cfc3923cd608d375ffb5b8967480579cc423d17d8b49acaa8e1d9824bfa6d6702520872fd32eb6c8bc5447703bf815d91e3e2484a75213943c0d12e5c0a653fbb5fb2f1e3835aa535a6de5f8052709dcba178fc960a9b6f8e821023c2ac2baeff83ac2ae089fcfde72f9e38ce8b43abb1f300a59d55e655e5f41a4bb5d2ca190d704029c51df8b21f653fbf973b84e89c4f6d02edf2cc626723dbedad0a0d1501cd3ff265aa993414d7d65a4a4046d8218b1ea8568d860fef0bb08188ef3086762aa6504f16b8c58434967051b2d6dfb2c8766b5439ea98c1c263f64c848a65d0bceaa1132f55738929a9f38013d19d14686acedc0f4b2655283164d9d540492d7561a0e644551d5eefb46ce6c3d68a14ad4ed3c59169d8180bed2e6620489fff6840e1009fa4b5f76759d0ca66d1b38e02e209599512cf8ae5748c2eee0d766dbd1026c4da133558fb656f053b72488d8d7952cd973c9e232100790ed2e31b6f521f97ae531276a8badb0080cfe239b16208bc1972e2550ec0043b6bd98ddbf9ec9c151e2fc21993ea090964f18f4a9f0092d7d3debc69b8f5316eee257899afe364d206c64716e29f2b4977248d78c5a6aff7e6a802d2c35c218c0bca833a488ff39a557ec039defd407cdb7cd432b89dcac6617db241dded963bdcb45643107a8bbdef20811c270d3ffab61c2fb9776107290fb2ac00ba33a942a56cdf54c34833a90c57dccd090a2a34d5fe2a1ccb559ee11bc1e96d5ac08d4276467099e193490c864f83cd9a6e2b880288a3d6f2637f8038d7270754d2babb9243071f90ee6cf725b98513fa3f431174ee206dba033e0e03f7030761aa49023c52bf7386dfd2664bf761478f63ccfcd9922b90b079ca90f34fbc380fe03a043f35117e3396ee3e30cf3a0c849fb8bd3fa79d1853456ed3f6600132b800af1a719f88637c2f391af5043221442bd588bcb2fc833030dc5b016484689ea651ce17b318c833ddbba2842e016bf7bd71668c947f3802014ee0214a6aaf30962537fba45f675c714b501d3e2e16bf27dda81f08492666c4368d1e2e24a2a9c41f8b9da263071f39d80de3043605beac12acde3a322017ef6567ce543f6d366507ecee367bd8213e18deaf4d2596f96d105a1c3b36ee390309c11512f6c90a364a1076753e611a1289d2edef96a2ed058869ef1c064084d7f1302b850127bb4a7728b8d8f216c0fdfc693d3ff4e788019e7cb31f5ad536dc070d4c21ff144ed34165426032d4fb3bb0bcd81d03d5cc9810f4937b4b4dde9f2583d1b8a7a1b9abe24129f85457c61b0707dece3566fd0ff5f002a6970aefad5e6c0acc0b18add74f153f5fa63f3f9fe72a2fee15a1cdc2863acbbae83a380b074416792d673b72a88a26083b896a21d0efb73ecf1bf8014a746f89c880a150594211f5530484101cdd9e8a4b13a3a82cf05e68e05551c0029efe6293002e45c47d7af19f993ab5e05e071a68e82d4aad3326f81d0644c23dc5130c197e155fd3e991e696e7ac7381ad82a5b9a67a88284503365a39c7e4f9e64e8651e7ce2645a0554c551f40f0f7bd706697c8fe6327721fd46391d8bea6bf8c0f3c01ae53b490ed73276ced4fe348dc7b09008a456572248259525234b0e00c296bbfa9688c701eef4c734dbac95f145ac44f0cc1bf796d7a0c67a50ae357aa884f292b6c0e94b7bf3367cff09c258bc75d12607bf6c2d2895ce54fb1723ad0f55e630d5d0b5853b76fbef47ab2569ea5a5b26d2f9959853426ecd1ecc281dd94fc92c8b6f8e2a48c8d480e4e5901b5629b7a414d24b288594a52dd00c71c73c8e6b6c38aa2fbd8df05c304acc470b40340f59863c8721920892ea6364fd9e50e2404ca1cf9fed48bb8e7f532cc17d7d43a79fc68a39630425186ac32a69265fa530dca7354013da983117c92a92a633d6f546ad0f9890987c7f360372cfd3f63ecba08db7ee479b2578e49a17cc5b2bb0ea6f1854ea492a14a9f9677db9ae13376fdede7692fd9acbcf2a80bfdbfc9231c9b962a050ccc8972f8a92a6d4f9c92f5b891f550566248e548f5f60758128abaca6d76885c1da3d22697c8628a3bc918d38ddde08a4b46db781f4d7ed9031af0a1443df24408a15edc673600cd8871245308ab1292f8b6fed4296628435e00ad930874820a7303dce26b6faf0bb9a4bd4bfc15f5b88a39b7727268a6eb93bc59fff4a90f327a1e80f8ef0785782e06e9b956df1f414e31b16fb8c31c18a09516d7fdd8c16b4229584cbd5c43c03f7d9614ca1cf6d05c4f9a4fabc8ab9b43f11750128bc5e9e8673e6edfa40f6a307d2f0dbb2cccdb0058d9870587950da6e793c8fa71d36686a05000e077d12d354c9a7391b5c0c116a854066fa84f0da7fa04e1b082e4499d08baeb0cb5f6b15b39a05f7905740496fac181797e3a6a9b834de0242038c5feb91aa57c088e1af79cca2a61c09791d18262ab7aef66377f414453e66b243a5cc0dd8fbffcba8941f128363675fba0a06f6e6394d05e2d36bf0c8833e801dd39aadcfa0ce79334d91124339b929437f9ae0b120c546c710851a33897144208f762794d84f932e90888cd84f2633a2ca86c82c022c6819e5e4407acf0131434dd5573f8586628e1c853b8368456fc2b5d050afc15baff669eea2e0686fc980e8b0e9aaf2872482ade634477de00cc9cea7c396876a0e6be7557141363e80c2c9647e07a9fd5a73955bb6accbf8f0ba7e44c4f7f8fb207d74eaf7ffb58afdb9230e152000b1231de1ac06af39e165e5aa0f30690ddacf50fe5871d7eb62e12c2b30e028f7cda731c30e3afb111e5444cadf4e8bd440978f4ff139044681ffe7212c0db796f8ae07f330741f016391d7e0491665f5f6e77951417a379f25a068c47902fcb5563476eafe48091d7f0ff73badca57674b4a60cc4be8435ec612abd4e58ce2b4f6e75faf39e638360f54fb254865ad65b1b3ad34a295083d09d3fbb46d8e2a6b97936c28483ca0667f25f6baf667036838cc5ecf0a8cb712fa447425409cd0db891b19092edca1170b00933843d829a75da960f98bf26ebae5345020c6844cc3ebe9f3fd20eff4fb3164b7a9f02a083da3b92aecde577dcf322733bf5593665b20dc1b1ab8b103281809cefca362d238a3a2a48c1a62ddda15eee16bd0c80ad649455d79244d06e1a62c15594f388eb253bd571765de96ad9545a43d325ae50b70a32f19d565e8877e2c871f0fb0be7b95ce3a1e896d3c7cc5e1ca00934f8f9353b165bf8996961192237103c4e14db08499a9bc3e1f52e64f590345ac550a90f0a5898828b6b9ce7aaf486d8b3f64fdd815a0cd59fc0d0c690422067f7ab698a289c117c3d3583318e4685457a727476284e8214cd15bb8517146ee4f7eb674d8574a589df088b7c5f3a3f41e2190c48478adb06b2ac761ffb8b1b34addf07461cf0cee230272f1a6cd774ea09b1dede9b241fb603d3541c7ce4a6908c12a1a3be4f4b0f132bc0a9b00351a7163e55140c84610538f3983bdc68876a1fbe63042db7b3c00bf703aa5c6d287e6f4334b917df77dfd871fbb155e2f8b29add5f01b2e35551326b6ee9f02f76886d73fbcb454c389e564f87e0972c5079c33622ee63a43816038d22f3fe4c6611edc4d5ce9130dad828a74e09ad85b1c94fd1bd6995c756fe86e610ae0e77b31cf0ce029ac2e19040abe66b0033027d31661a29a2680e97f6f4a85d5e34bdc22b298be60c79e9cf86f88754f6da6b3f9ffd9132b65a254bae723cc8feff283588c49a2eb92066a85cc2ba80666ec4de4480f9bb3440e7b6b43a76ea60af7559b79c32566f986702f35cfb78b54b98cff55199b7570e68ec9254ac5a2354456425b9c792cc21d72eae614531d2f2dd5e84490129637adab180593dff14ec383c39e38331f0142175bb57cd9eb4c09de578473c7396d6c344c18bde4e1c3dd660c69cc3efa743c4f6741a3e03fabedb9d3c6f0c34c348a1e33ce677eb73e1cb1e96a18929301436bf36859f0f235517d4224c9c3e969bf028a5eade43c13eeec04f9a2e9be7a9bcd075cf3eaef59868c799627c5db168197ff3e5a01de5029fb1f0b4c6199ee740dfec81ed71f765505989d6c70af562847e364a556885cf16950016d3131131a29b71ffd4b826300a1a4314c8d716038ec13bd9ed3017a756c3477f208f96f072f15b76f36170a275a71e0466ae97201ea08ac27a2407a0b685412cde5239de70641c37c2d2bdabf9681ffbcc518e4cf116b401fbaef376e793e206472f944382097a1a468837e6640cfe9aa3a53ebe54539651b625c58d329942af8f65190dfe5ef8f34cc76148ff63da84a4b1ccb426c1c402861c7203b81cba2ec48d8fc9538a5734cb70009c0d312d13c28bddb1117d91976c31da4d98fe4da11ade7bd75857a0f64cb9b2df98e854aeb4618a54d6900e5f75c268fb19cc417bead3dcb4a2651e0c0f7b1bb90290ab61fdf244b2deefdc780b0d83840af7dc264a09c41a08c271d16d853d84ceee6241b2151e89c212fc2c48ed3db0fef840a5440367192b009f76b872ca600c163b3687fad18a89ad88440d0180fcbe1a63367340c56a964fdc3fc6e8f66d5f09efad2309a71ae3a813528cee3a57846c8a22884d77125ff778ea779ef19bdfb635fea61b4068f3cbcf678fbd354f036b7134c9cf2f7f79764c0cb38f3ef8ad6cd1b2d965b9ef901193fc1499ea88fbf4db20ef1b862fd7a6ac629ca3a0438f3229f8fdb14981b29a26866ece2a04b0553a493fa2873a9445235f255829a1feea4cdaa3affbca0328cf70cc55eb3c61d5c59de4ac43889b4a9f8b082c4cfb29b27c331d19f6616e5d6c0573b1b6ceccbbe88ec385945d83d5849b15662c073f54e413dc5625c7b5e27e5524e29c934948b68c7c557f40ef544d59770ce5022c5b26a2198435458137c970ca3a6e69792821802f913036e3a0dd7a5571e3bbfe10dc953f00317f7d94127f8750d6b378da2203b75415601503f3b005584fac39e4beb77d843f86039fcb1322579798101d275fff2ec8ffb7135951514da17192cc38960a722fe537496fd62af035020bd790f44cb2b7c30f8492c1803707742f1876dd438152ac497ec233a463cfefca56b9d159bd2373bd46ef7c7a606f91b4461a280d48c7bf546c4d10765512e55fa5e7fadefc1487660606c08eb507a993b088d9be7f8b55eb1fd94d2b716ad73331de6bfa98fbf3cd31c019e2fed1f7f27487414eddb41750ca4469b319cfedc0e65844ccc24275647d9d450224b6a3f7e3e7d12c9965df4186eb186ddbeb18b02d3028fe1f14764b719a0262b581677c2f60ef6b2a373f623ce67818e9afcb3656b97cf5ec32c4d492af408929aa7c84f415bf392c0dfd8b64bf60b6e7b6093d608503d38b31d4a465a08e68525898257adca5077e6c78d9767a9cbf56674563bae4389bbf8fc4e34129c64371eefb3da1a770cb88a8c1cae1d09b028e6f3fc7a3fe783a3a542e51c533a7526396e9a7c5dcccef052ac2ae4490f8a56c3b69a564819d6dd3bce98160a85ec13f1ede5edaa994aa057cc889db49bc5c5ed6a7d4095bf3f287e0765f21a1cde2d4147948c1241841487a0970cf2751c980336a3c9fa3886a1b4ba03cf7c1ffffcd4fc0e2924f830215fe540119eebfb7703f23529c627c96f627d8f40e357a8156a1b7314d0242e0929486862c36f77b1bf99a9a5b40d28f74eee3922790b123472ef518d3061ca7c0c77dff5ebf123dc30fdb4c2b63a453c49cc465b54d3def3b360b56e830e8da2810c3002a518312bce0be92110d9a974619356115a0795d29342f006f1ae03edd2894eb8a3e19962ca14226ae3f1b3d20fa1fcf714eb2e10990a474d10738113d1ee25d6fb376b48b17f4b88e503a17ed9bc46136d0ca12032dcf8a489d77c8e4c776e04393a5c700eeb7183293dfdf4e89a3656a3009b5dcfa491b79cff26f0cbf767034877e0d280ac78afb3212a76ce30d5b46d454c5fb84fe8d6032a6a39a4809f0df612f0f38ce09d17f68732a60dfd371a2e5e96fe3e0551459bc90b14dbc097ccd4f8bc83fd76878426ae2552625cdae7dbee38e262203333290e68f762dc30807244be4d136c19c8c1d609c3e81170c56c24de693da46980fe4f2f7b60019fef7b89a7ae95cf7806dda32d90eee13e46b08004979369d1676e61ee62622864c6dede7cab7c37b072cbf3d8769fedfef4ab36a98d820584ea29a7404e8fcbaf369904a462128155a554772a765f4d196f13860acc786d67b2916b041247e50ee05d1eb31d9e6d5efcb65ffc8a3af1dd2866d0790d23bdcd4ff5bb678966fe9d2a5b63f99afaaa205601013899058617936926521e23b970b9b188512fafbfaeb880d2648edb95df44b979be76e8b4bea427832e31e6a9f457ec37a8f3fe0127dff072d065e98bf7cf3a0159ee223e620137ec906c8e93ddf61279e2487ef49f9f9019ece8dde524284d2104d5d4923f70d44dcbc367b7022d27c987d080d1d10e0c9eb16c26e8648aeeced5982a75ece817b3d66323ccb29c33bde24d57eaba355a58251541e2f4880419bbf97d62e5aa0b4fb4c9a63abee237423408afc0c1084d41ada9427d8b07fa18dec92b2f1f9d6580f2d40adbc850a6171eaabdd25480521207121494e9a6540232201064ba99c06c1b14e6b12b69c0a1e6af94628e65ba515c4fca6dc6c50a1a25c1053ecac036934f690bdd2b7cb5e51c2c429e144958f1700895b4ddd9a0338c6bd45e9b547303bb8af879b06feeb8c809e40344806c53746ccf1c5b6f05cfce26b27225f53203340f83c06d8b6eb9806fd22d6611d21834db89caa966f03d3f3808d23e055225264e374799a6246f57fa0f9cd74301538fbfa3433808c1cc02cc564aa8c696ec3dc6d1d04ed4c55b4ab2196f19e2c75deef7f2cd3dbefd93dfb0f1fc8421f8fdd9d73703e35f70ab10b22bb1e0117367688affd8437dfd4870631944e34d4318e0ef700abf5d2ab8a0905114e80eddd1fab1ad456d16ad4d7f87a7389d7b1fcfd2212f0d759d42d65e779aaa0b0b057fc0afd8c76b87b3a97d546728fc517731801dfb39c3d287b281c35e87c24e66fa18b050e15308623c208f063495ae11bf9b543161ad30bbaff1ce2d4e60aae571660993b756bf21f72283e17bb1529711a82d8d8c6a92ca7db03e882589bd02561ec70f1061d88dd9acd769134138aaf02f29e40199fadde7463a4201b9a5995883bdb9a7e8c74e2da73def3e7263102a8318041c8734befdaf5e4aefc821be2d7fd691af77fce8d715462c2730281da61b1b3f8d625a4952e6557170ae53bb344f20ec5cf58b6044fb96acc64bb7220e061d0b01a88982cef60803122182519ec9d5cea3c2c1a8b5bb3520a81df8536a11c5b7178ccb4b91215ade3ac7ebcd9aa33da46eb7a7ea8ade67ce29817a7e91a4535f83fec5d3197728c227ab89a03a4a7358520a99c88a8dbe4a5e56881c284b1a6f07f7c64e503360ee8d24c526a3d3d2c890c4930b6bea9859db0cb5b8fa4e31de098e805bad7104efe756b247c4f18cf045406ab594133e027bfc9ca0db2c0521a2085cdfe2e3cdf72f3f7e85cc1d2dfabc43da9f0de47a28498ee01088bb0b09a06d42e4086a0f1ba0240e0048a1bdee70d00c500698c2e2e2ca636de15889203d6ab884c51a1dd071b93bfd13778d640769b8cac756e9c9c1dfc1224f1219b9f0d41ab5598c514fd810bd97dd0675233fbcf149cf040fadf6bdc33fa78c5c1de945b656e3b581e27a13c9b1c64b56d1114155b4ff15866947cffc89e2d3d26001402c779e5cee1a54f0a3b7544de73577145c26c3150ff48d8e8a1f835a1d773f817857dbf6626479318f22d92abaeb11d45a4ff0b00d58a36f2a63a2e5f798fabfd384062c71676325618ded39a704e3c20d92f06904b804ef8bd38f8fe710f746cb7d09a9b0a2c3e3fadda78f20aa791a6134ac327894bf53e91638c24b48a10c3e110cae248e44e170f1ae8dacff20670623cf6c4d8acc4a4f93c62f2270cc66ee9effe77d531cadc2fd526b9d058807650e2c1af41ae55bf1473a5fa1ea3df0a801fceff056f37c35901e00aa5eebc2271f1bb1d063ad1edfd1e6ca3ab20becd1d3ce0ef0192556d9451ba84628f99af4c459f0a7a1e275889995d77c0a6097c92f7f018d0e92318a429fb42c7e10f6be74ea8780682f2ac40a9f1961ddfdc727522db7606fc91abab70336b5a86945dc070859e0a7e619362fa90b12f0fa281445083b0729ba2f4d757b63b1b59f4b96843dcc87cabb12803cdb137dfd32d182ea672bc491aedf2c9c67a8651ceb134f4feac296121afb11155bcea2294581e8e092e26edc177f6743708993972f66435088f441025b014202f44d3b747efa018e3707d53e48cd8eb3b773a4a27ac5fbd20cd3528ce774403149fcb03435e371cff21684d90093b11c954587061465dce7217874c1cc6baa03a570f6bb1a13030321aab3480f6fed8b476bd4e98cc7db2dcd79bbd9c203c79c35a0c773a8eba125c6760d8a4dbbd6f14c292b1b2e7bbd896eb67a6e13db78ac69a3e8b530bab5947292b062d322c68f7d627b4228218e37ddd2c9b80e3a2978cefe45da50bc20d6c9d7b3f7a1ded260239ee2ab793027e6f760b6ea3d8fb0f245f8faf521f03605872638a1ccff0def2384c85007beb1df49e20619e2152a3a5a5870f413f0c931aa14c91836a0d7df56aa882c22cf2519c97f0657ccef4b83c16fcdf7e89fa8a16154c068e685d5d59cb1b53ef87b87ea2bc1880029ddfda75e962ab5d08b68dd1565da76bc3b4e35a6065263362f92665b7144657753da1b97f4294d65d14e000219073a0aa089121065f937853ef675b4775ba1c92eeef85e92418c70cb7b73ee4351d88e34b6163814d1ad120ae7ca994eafd7e3ca0c2b59ba86d0af357e8fed10095518a76fb91eadb69450558ea05b372758162ed327c5477c8577a449ff106ce1b3fb5c916e364c57540f98ff9658e3e816cca608c87e912fb0efaabb9d8a0675f6503ad9e89b46d3000715cf0503bc9456bf3a02d5c1732b1e5ae8b1ee7e3f1359a72b6eaf97975a0b3212ac85643bc094bee877ccfa6ea3d172d282867a7848895128f20d05ac470dccea961d8823e6203b4aa195857868de23d6dbfbf0de059699b7b30f5a0d7e4d27e19590c8b8cc59a4ccb5eeb4c3abdb917a326d38038f7390c524289ad63fe127a1465b48168d3c3f59b5005ad58d834a8c402fb95d1c45f485f57bbd4c1bc3ee615a060e1a4b300519524d4b990ec4130589c347882bfaab8f58d0cc5a47d13e1a09674d63f03e5d96cec467ed41e4e19f34dcfaf53362f0bf307c6efdfedf32d0b4869b085b9becce4a888fe59df0a07567a2c70dd598f9d0a030129f8dac310ad83a7fd82fcc07e821ec6fd9a6a68e6ea825fcb8878ecc1349b9e8ab85b1660a7a7047c99e242ee1afdd86c68e7bb80bf3db81055de1b27e2acb28def32f329a4d2cafef0062969bac1139633f24f5b4b00aa5fc458106444129bfe6c057ac0506f6a5f8cfa1ad32fed11fe75592503a63a06a86a53fdaa0dc75ff4f98226e362b9d1a32891281d6e43355523a9700fa3123bf77f28ed44cd3155c0bc7eabfbac72d02d18c4675affe888fb2c3dc798ff65f5b663efda7e3dc9ebf14c6e3b51839fae3016e058e988fa29c5c441a6a036228fc7b21f6112e67bba5f2df61a36ef75da1e2a1f5b12a89a71ec5b584b283c5f60d063c993dc8d92dd74c3e58d478aae6c84db540530a9d2fdb44eccbf8bb56c002c065348ac1621d7e6d945dadd3a35098056a0c10ce074cf17342b9f680521ce595fd069ba161a2f72cfed63ea9db531fe0b3b0e555553c471e9ad97b93c55057329eee63a3710ca8be0f766dba7de765a1b1ce4bf5933b5a28bc1d339353c8e5b0db5ba846ced2c5f56a9a8a74311998ac44228f8d0a0ea46a41f0619ef059db924c8a46dc6411d91161fb94bbcbf39369443f3fce1766934e499a4cf08ae8db20c2d3d488e9096f46f9c57dda3a1573613573f1b4cb3b8f6c3e15382d401aee1ba356bb55bd12335b73cbb5f4ee9e466a24f0979e03423f959752d19739b570680815c6f168f8c606cf4c389606eabec265402d89d66efa426a7450db4ef5918e363142b7c416901a04027aaa1ea036d32ba17e0235970a8f122afe035af3e76f9f0ed04392bbdd67185515a0b4cea0614d781734100a472d19de3af81e67ea2ea0fecc70b6ddf4aea7948729aec20ea9ca6d10fa73eeca59614d6f6b9e0bc3fdd731594d966bb3b36ace5c83bece0c7300d23f154c1b032008d597b737a7ab8b173c69f7325f5187cb6b5d0975e07aef5b4a85992e4460998aabe82b85061a50d753eebfaf9dd213e0f193b1cb3db447babba7a710001ddb1916c1457e06c4ca600702dfa32087d03dec1d6f211454a9b361c6e0e2b89ffe9453326688b53a28da024d0ef374d25c2a05aa5c74e5ae5ce37e66bd2da9d03a56e5e7477ebfc9ef54045fb0a966f050c7a34c160df7ad11c04293367e3a1a0294cb6043bb9da6ffa703ab689711910f6ef067cd11398f3aa6333d12667a1aaf9652bf2c222faae65491cb58be65d42fcaec11a3c6938ec717af86757064ee7626ef565a8ca9c7d3b8cda1fb2ec7580bcc645e0aba589eb49eab2120bb44bdd0bd0a0b0136f3f493a04b75455f937e79802080a3bbebd144e88ba40d414434f6635e98d5578bea20ec89847be2f0e3799fd9314153f0039bc47061f59ff5c027449cb9480f532886328d370bd3591ae2b3ad8a2eeac68ebe5a1134f55711190ce56da1d680b38441a80bbc0cf1ddb4bab407bc90cbb07654f989d882b1e00670f360333b204b331703e3e01b65e03dd9692f53a8e8d151effd7c3f77c567276dbcb575f8a86eff67e446ba13bfbcead85744647d7ff8259dcbee7da8d23b1d3749e8f9756ea35951b44b7d75f48f8edb8a2560c10bd7007e309a0498b99f96c6abff38b3da528d810db5da16ca8d0b1f22b78329817defb4b1ea5a4eaf78e0fb5c0da141b43847e03928cbd39be213ff9e69a8b7be288fea960a8d1cf8f737caa7c4f16d31e0ae68fc682333d8357b115dedc9be9a143305e9b6f0afc642812df5e4149a58187035d7b2871b93ca2059b469e04e9ab00768dd96a5801dc5f5db1c3e57f76670ba2f40417c190d929f2073f42f0810911cb40a43e927770a00f19cfe1c86ce9bde4645b916f94e3d69b369d1aba0441a03efa050d79b0e1f8b48468528e7770749cd8e82750885c45665b1de993ebf10142af6f3cddd8c594076d84b89a96c6fff9eaaae5b1f8903047242be43988c8d15a9390fcef1ee4c9012f92e309c876b5effe531dc0a10b7d61a577b8af86a940b47b9313c1beb146210839df492bd185d664bac22eb04cb556c48fbe0ba2d1880afb8a956b08c5b537670f2576ae7aa1cefbc7f5192a50eb00c76d653fb2f92dd711b98e74848ea4f285445da54bea3938e07f4eeeba7743b49041b4b07d895f58edd5365eec98d732a8866c7f455717cc5a0636a56c2615b531bbc8767f45273a7b58872871fac5c97c951052403ef260b25e45ae8018f7e42f56f16d9b2e67cdd455a55d3c2790c3293e9418b7cf9e51b35f95f33d453fbb1f053c7bdb76d977008d1fbfbd3dff7cbaf01fed1bdef618798fe6de09123370af7ca10c45a83936b39145883247ce260877b138fc84f8b8043c97b83013dad8245cd2a00fc27d520956900d2251f236efac061ffb41f38dbfa9892c6206110fea4ef37770e36e99bb21d42e0de22eeefea7eb58749138a253005860b6370138f7db03413c5c3a9fa92e7f0b912a910079c512322dc9d71e8107078ea3460183585af2db36e37d8396118b442b8cd3f31011deef4e218920010ffe556f7348ee6c5207c20e1bdd6cc2ed730f069573c34b25385a2ffd92de429e9ae8a46e10746b2bddc2dccca429a41c3122c98c1962e14fa7b307c5eec8541c49332538408ea9c3be0555ee662ed03877e1e0aab776872217bf9c51e012e86f96938d3de29007aad3f0e2a3b3ac06726d71556ae36de14f8d8235380be4e8a81735dee60d502b7a3f1f6bcc0cfbbae73fb43ed24412ea063b1aa619319e16cee86093faa612e7a9808e57d1f7bec35b6a37b72e035b8dba89c8166565fadc49e13ded11791c9568587fd53d6fa537aefdf40d834af05c528115e797c2734ae8b714f91e99a8ba1d76cd400de57c41d2e0df154b26666e3234e6d0a693b5b82785af60bc177e96c3f392e18c462ab6381ac8cae010617a0129bc8b4519ecfd1a978271f7203ca80e7a0e70c4351917988dfc1a581c89fa76ad13fd2b4f034ac75c85ea7a3abc01a04b7b6ed6be8d574c6390752fd9fb807b20c5467eafa895ef37719879e2b5cdd1f952314f5c2d8fb5a82efabd6c85d13ce69af90434029323bebbe6968c44e698eb940dc31d74dbef7227d6d2d6c934e039f82d426a8c62339e196adfff4c1a805a0b3d12be2e9b6c6c2b74c21f2457a7aef8d129b45bdf851ad0883a33b7f36e9b7b49647aa85c1ff831fa34e6030991132045c016fb07f65dd31d49b9038087d2ece52226d6fa3f2f9bc5084a3a88839f1c8ae6f53201c2de8abedefea8d3e7ae1f364c4fb93be944bf95edc0d68036fcb3f6f18bda870af8a618cf7affc1e51c2e69ec5a2828cead12ddd3f393e82f6e2cedabcb1a49745de5f220a80b206927511a6e66c5d1de2cbd325fee28d50548cdc2ec5f4230fe53be0aef049bc56c9d48049258b3ce5e80baf261a1befe5879dfc14bae7f89cd86285578355d92c771003d2c86f4ee863bc6b0b8d771fa699f82bf7ec60ab29def9106b63a5d727386979526cb20f7bfe5d2c0a474cd9d93beba2475167ae5530fe532fb665dba530fe5998f83a34a02e34b1f9fe63ad4fbfc8bc1b765172af91ae3e158f2a9feca9f8778ca7583cab128e34c6b1328a5e383831a8a7f89a49c85afd2067d93fc7cd61da4a31dc28eba78d623dc152c434a1db0e0fcc116c201373281c3651b539e087656a74b029cc37520851840fe4cbce8bcf55642c2d76f82d094e32c62791eb2cae1494960993d327083ac515841ed736dd97d29e951b828bb6d277d7e251ec54d1f2bd470de0df8bcc90a5ade852d95eaa5251498cc173bacc0a9c8a49914eb9df4801e74e634be68bbbc48a2124d11e986fd375b543dfb4f30719bed44365ceb8c20ece8cc8a37c42af6bd81d1280c111bb9dc5ce15c5c98b99fdb00c7e99f5eb75b5fef737f357863d64e3fbdad4e8a08acdd1362a0cbfc607db8c723430b2e96de98fc4dcc301d145ce2739b7496cfd2636404997bd8a10da6002ca95b0ca30eea25a93e308d59a55d9dadccccb7211798f3bb80b649db5c1fcba0e30e8e9d5b5ade290b1a939fcf7527aff6da8f8c3f6f39e6f327176514e1c5602c42c5f02e864cc7ae6e44507720c9a2b3368b6ec172f669f1b8b95ed50c65e73c992d3aa2f6590cd0d2a374b8b1aa4615150df4e912fd224bcf015814ef01e67b181ed1667c8182fec67d406cf7f27080b33dedc1d9c2d6e70b5e3f5400fda1d973195e99153095a9216031f54e9df775996bd5a20c7df8049dad4972ea0345c543ac98ccd48610a18b3c76e7b53ae4e7026ac1e5d122fb7a28ae36545425cc32c92332c446eb4019ad14ade04c46f6f00ce47fa386658fc07b21d8a62c57736e34b4f265e4bdcbe553b78705950e7d700479bc52c4776b8d5cf34f1945f171442ee76a74f1c2dbcea2939013d9fa140177d7c2ba175f6a6afbe2ac027bff2efd2466395a670c493f9bb7b9945db33c8b198ccedafbb9d008aadd3e089e0c8bf8fb8d208d9707333bf6fdbb69f74ec18fe3f36ed3e7f901f025c841c60bf2f1f09f8070e3e347a62e7532bc4a90e0a5417629502c062a973e6ad82b4c0c27f3a87524b6c203c1e79911138b076a4a5f27035f6f5a7a5c3fa92d8e8e6991b5bf4baa1d9d345624be7a80d0a096d4c79969dab69ba8de4c3ee4c198ec9888a541aadce433584475e4025405e1245689270bf9d5fb684a302ace990d49d36cd7b2c87df861329c26f540e847d4f35e307ec0616257393087aacb4be5c0370ec6df51ec3d5e6f51d4ee193165d1d666873304642487ee1dfc28c3e67e0a19bd92fd87962cd54efab34235b2069de493f09de6da29380e29b5fdc4fabf3f17ccda790fb5e6fd08e7e96a3546e8b801ecdc1e6614ab9f9aa9c141c6acf7ff94810b160a6528f240faa3b0d85aa4be957a42e8fcbd72c3d8f710615b8953eab2736bf44abe86cd7bb6fab8a16c21ebc78ebd0e970ad796faad97bb11bdfdec2205b4a622947e79ee6004aafa4c167831fdc13fd0b261143150cfca8d08db35fd94ff90adf41ed22cd04a8bddd86881a342b8f2d303d7c23cbdbd7cd5c4f7033aaa0adca8951934a8ee384e80928565be90480a09e57c3f27edf0d8dbcb49e1cc0204ef76b4adae8282200acd1d34523e8c72a0f97503c36596cc21503d01be66ad156651d2b803aa30eee3d51df4346674f6332df42aa9d174fdd07ab63a7329309c215252ae60e35c8b0bf940eef04e25bdc38e9996b4f00dfab01bcd2e7726d34762180e166179d5e0e4272f63768aff230905af12d02d1ac7ab61659f3febb493b204bb9fa227a14467f763d401d255cf9badc517f2bc2e479f3f8b64bb472c1f1e3d25de5e160f321e8ce95706aa92f6a6bf3dccc2199a387f969e2dcf6edfd3747178a74cdf394579f098389455855253c2f5e6dcee5bba3a10fd4daec5c85bd9ffe7e49d8b298c731c2e960ddd45ac3d3f8f84d1c04044821e57b2d402313ab28d9fcd7a4b31f25c586fbb625242095f61465ac39fe5db5d37130ab7d73e2497a660968671f8fce6079b1bb32d35c9c71cddf4592e47794f9bc797bbb8c2ba44b4b0f907265e5dd5abd20f1f3bfd1cd1183a7c1bf1eea395497903aa796a7aa7a70225ef02cfd751a6dbb6e333775029c5525fad9f4effec4576cb09134a5ad8f746d9c2a5822e551dcaf82a377778de4bf3285f486aecf8ac3cc248aa6193a35b88eae57f9c4b8ffbeb52203b49fe0f6659759b3a8a16ec9202f8e9a5bf8c43d21d312f3f2781ee8893d71f69d177dbd090c82c0a942cde091b8d593c875f92a6c0ae7522719a98d6603e60099cdd69aa09d3553839e7446d7e1a6ecfe91694f15f10f5d44d1ad892fc43981e29288d5f8ce722c0f25826c850830019dd4a9a5649cd1e70621fd68f8f1478cdfd7f5d2f15ea7e03c64ff4eedeccd3ca4125","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
