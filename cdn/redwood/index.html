<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bdb8663f281e49564550ae921e79d3cf773e364da0e69cba15ca2cce6a75fb120ce4a5517a327a271b272123d0ac66422da9cb6ca93452175ac0c84d1f3ac88456f25da1c9e51766e1f8204230b6f0f02fcba30fa860db769b0d45a9a111fb40352bdfa9f0d34e2151ed66dc1461b76dc95bdfff116c878308d81a8a3e1e99309905d57d935703bcd3b1a5c45f583336e689f82de563b5fe17ae0aea46f2dac111ecfa4be3039778ba3ebc5addf376280eba96df876a6f546c44627e6e1bd06d54778b64924aecc04271f64fd1fc005cf8a87a37e3a04b59a605ab18fbcec7a54c50e9d66415acf936f75070db60ddd6dcce8752b1bdc4e705e98e1ba3575c14855785de969a0aad7e630497f57a203f1067d8c0085a2a6c37b25a9206bbffbdd977fc7230354c6ed990cdfeb427ef4cb68a6a4bc4faa8614011ef5a7d7f90fb8ffcb5070803fe797c3d1d05ec5097f1af2aa5392b5ee9c6419830b9dc667f080bed36945670caf0a538e490b7224ae4589e792a2f4ae14ebbb59cf3c3660e0580cade1af4cdbf6d09f62b5c0d16911098f4fa218b5a8dce74c97544a8671694a6a3466a3e8538cafa0cd805dae87dd0069ed6e86be54cdd60acf1e325c4bfb06e3a46b6938d2f8b1c3b0f8fab688c6d0606530948a37de7736a51e3ce5957c86086cb4b69e5ea39dcf4883439d18fdc7e840c0aa173b93063d3385db0e101c0d504b582d2fde0f7e30669f24252f3d8f77e1331aadce6dee9e14dd4e140dbc43a8ab41f8ac061d760dfca1fbdda1acbcfc08e2b2cac729bf78958f9a51103dc0ccf445e99ed300bbbffba279e817f1aba08b9f0b7627ec25e62be68d83e107e2b6642fa0e7b81690b2731e6c40042ff67b2463bb5d8581dfab5a212a74f26c0d321b05dda555bb6dfd1777c1047534fd6e1b688ac3e1e095531e61c531145521bd04bfa34e3620a3fb13190ae8437362d05c2719c870b53e0b29247cafe7619fc08bf54518242af4d80a0743b9bf3f9ddbdba6534f523c616c7b7d3b0909ec90198d20bd05c7ba6954c7d5c3817c750e72a978f442210ba3cc79b176886cd58ca815641ff0f18a7e8a9b8ecaaa1778a102abe0ec25bcc4c7c8f6c8bf616d89376a19295df04292d459f6ee350f2c052dc309fcd8c52d0830c8bea745ccb77c1827b371c2af5c218a1d628a4618c8042f58de35168a9f305074527974a70c1be76f2294923e8b8e0eaa45a3c482d79e3fb9a2640d8e2835f16b63b31c14bb15544a6248c1b42a43ab8858922e90406792deefbec43627980db260492ed15a18baf9954649a6970bf4cb4306469eae7460f939760d50a8f5aca00eebe670c386615ceaf7ef2ef14b02f1d546154f4248024750dac3b2ad6fb4b3c9087bbf41f324eabd0bd1aae085f9b15fc6d1199674ebf7fcd412a2781ae9b9d0f41e64f244ab2ad9a9491edea7673c2ff9eedbc526cff836952c69a02dca92e64685cca25d51a539db8765362e4d3e481cb2b8ece4762dd41a072b911d9412426c102ac809c7d221355840b26116d56e5c7e2d22079e518b8f0715e0a08d3c341014a0fbe93183eb76ac250951eae6168a9f1cb58df8ac287af41ae93e8f84df0ab493c417a37468f8ffcf8ae53e0f7b47621c0fcaaaf975a5ddb4fee56af5b7710b4375f5c5d6e448cdc4f0c56b6ae991ac266d89691be0ad8a250d1d9a0042d6b391cb9bd8d5db0423f4d1e5603f731b632a3347a158ae3c8f8e610541205b9d2500703acfdff57e4e715f884eb16eae97c93d0f6cd9ff7d8c2b4962544214efe562d8fdddd9bf42d26be3aadaa42e8b3e8cfb14b8e29453e21b41abc7792deb1734c16b1ed95d86ea034bb52e6afaf95bb4b543271ce265920246be45be4673bbe8c2c9db366ff210bf5a2142086756906968b9e5cc1eb21edfe07630f16d97cf64cac8a25df6be4cad80c2804e8d010b65d127c53f1095c10455f0ed72901c241d99098c6bfcac930abe5de3d3ddefc7985307fa5aaff4ae532732699f0f7cfc620674943ea211b8078ede8312bc3108a8cc9a7b39e2d330751e387e86d04eb6696c4ba7ae04701bf4e88246fb7f80e47b0902a190ca1c1457a030767909ffae8ce2eb38f29facd362965649024a6b89ae808617bf78edd70bd5f260d38c2572709f30930f9752040e50e92e917ed1f384c8ace7c94bf1e8ff0deaf632232a5f5ef3f3854a1e415a7e370de2ebc740184d26aa76b3b9cd0ed62d14ba9d98fe402879fafa81f6527a9f76fd66a9eae215457c1ae28b8e84417ef04d7095b07a2fe9ef27a89df3f956d3be44a1b03cdac3415846827b1bb25c5cad1373eae7f3f3a8a980cf407b4dd657d17d7c1fb6f3fef278d2349a7ed3fd07b5a8fcce15974ce4461b038b498ac2d47c68f97e5d745a21c2cc1b981af6e2af2afbd346dc9e10fcabcd3b32e1d4f3f915f96c25ff4dfa038f6bd34646e25015bf21b9321f328d68faae319842a196b210fd4c1d8a7b7aa06146ac852b2bceda889619e3bca000e235ec10b74ddcc98925a8ea8970ef535784f198970db3fd629abdeebe52b2ebe4675ff8158f11b57937588b8c7319fd8a28883113612d789b3782e7ca2c262e4e335f4bd41e9bc6daf0898cecccb4b75921a0f7af37966afe7b52b72475de61ee59324da0c07c4d43f24e1ab8ba925392e79544c32b19a2d7491df05ea498366a1e174fdce8908e764c86af87244b59cf6962b4a5c5abdbb6de7df9591d40c0b7da985e83cfcb7d338d303401befcc9a1f06d097e7b566a553cc40a8e69b268128334261e43babd7a9c41fe719824e110860b80aa1dd30bbf59a95597a7ab7fe5530eebefce41cb958926f64852087a6527766c15fd64ccb554ca0ff73ac7063911019a7e7fae3769e4f5f4453e38d01af79f3aa8739b13e319def7e49353e2ddece2b2a701371552a038505f3ae7082c8462d23118fca1f89e96ab1a2b3bcffabb67117f417c7d5a61cda6eb363748174e5cb8291fa5cb7c47c6b8bce5a5f739c6b81efd56630e77fe7f26f349f43cd3be01ac600f98629875bc4b60390850f4504b94d558a00763ad64c8e23a6a817ad0eb624904381470299ffa68824a221d16ef13fdabc12f2686d3d6156b5913ff37e47bccbe1fe4ca93f80c8ab7fd5d6d68770ef9b75c33a981b75b535d8808dbf1a8debe8ec77594271d9440ec0a2329caa8b6563faa6e1f917ea97cb9b655eaf06fb09b05a05c71634668f953a8b9b98c1de5f2383464b65b3e7e6f7cdb566956fec5c0ab2f23dcc0ebfe5183f303c19232253533b2da73ce8be2071d40c4d5005e7d31c2a1685e34641d7d49a2dec7a05a90872ba4f0aa5f00decfad78ecfcf97da7f6b6e2a59332c3eaf0b2c89a87b5222eeb2237b544b7ec98111e0e9c259be8ed2e7e61021d1f0a46e489563a23601ad8c2f124b37ce08a30266e94f754a20becaf5fbb52df1e34294d590c03af4c82bd0f814a6e5639803bda1deb0b0908ca487509dfb92d1e6eb0a100dd5f88b1ad1632bd99ddfd9c07e76b35abcfda0af2473949712119d3f154fe0b380afcec0a8c52339cf8249d86329124227aa53843ab333c76dbbc184c33be5eee71a573c094f3ac0a35889b04077122d0366df3405cbacc3aa6a0552f4c8dde60d0b589efa43110d3608c9425cf333dc3a9ee3bf4ad23ebed778d11299ebc963d04df9e7f5d2b68ff1c80e569d9d807141bcd76051d766ff594001345fd15ebe57757b59c909f2d27c351acad8624cbbcb4799a714b1b53652777f1725e2f57f7862e5fb2b4388f1421729efa2c70d9fa554f093b98f41bb611d8170648a08676a91b07de44bd72ad43a68225a2509026c5bc90ac159d9e83bd1f59061890f3aef72c279a76674cddf9b2f165366e031332f86e4c39538a4ba63751560a2676c55cd1a6289ff4159dd48feafc4d7f285c1bad2bf143381afcf912c07e2729cede81e6d4c9a27160381f997a6e435c85b720d9f0274666dcc18ea1982f54117c8b44ef3ae0df46e0dbf084adbe21457f50ae65f2c8d81a6afc6d7756016a48e82678e490c88e4b7f4f7d09d93ebbe3e73723fecdae245f183fc72719e057cb7d441ff194e251ba71a20702b599a464e76396bf7bbf656e7fac83d07c089dd0c28959db4aee9c01e71e3daeb9c95b3d619962af3ce947c5f4e6558320707294b0cab0bff49495c151b5038176d0369cbd264d03835470d14b9a8faa61f71747d8caf39a7abfaa2f63c11bc417612edf8d88d40281bb87a32c2f99087efa62f8a05503a9e89c53e80d56adb0369c81bb429681ac4d01f37c87c332b981bfa82fa6425a9a19753350e0e7741ba31a336cecb0bcea87cdff313fb0fa87102c39d4b91deb00577819897cae779884747043865fe7baf6c19592004249624c3a4432dbb1e7f18f082c995c6a2bcd2009af87ddd109c593c7eab6ebab9fde2eb82766c4f3bcdbda905597c5d1606dc065fbfe940c7dac4fb462c4f8e5d8fd4a23e44837588d12d14a6f919a0d6b6a860b35091612c6a36e9da035897d073d242ec2f8c03f8c3a2aaad7107842d290085ab14a9e78db7a5b05c0475d1f5174012a66e620fb17756b64987f7ad25285281950142738216ff87ff836c0f48292833d0915d404c21190487008ba12d5ce427b17f1ecd288dd6761610c49cb9283e6e38bec646fbfc1773e67f71f5edccb2c038c3daab0ee28ebf709ab7bb181ae7b21a4cf3b9033cef07b353053f6e9c22b7434ae983481392f9aea6d4de8ed3b5db620f95ea4ee47dc034677d8b7bdf0b71f492889b7eb84bf58e0a9193d2a069e799683e7fbf2488585821ca3f0d4226c79e88ee41498ac817681b6ddbf00aee8871a902af3bf728b4538b7634b2958f90e3c7ab59eafd06df6a40482e8ca4eccb75b952825ed91a22b8b967094abe301954ac0a7ae62466221828925d2c8653784c97b8c2942e6ac40ad86c31eab4707b1315ee1c450afbd7165f25987540e21adbc4d0f2cc3a3b6ca244d69948a7b81c8c83ea0947c576b8f13ef35937751e1b1e942bab2a0a71aa9cfdcbfa9b4a3907050452f6c7d25f4df835c803d3a6b9fa787f59c05f58aa52baf1e9053359be647e485f56a0fd26e12f961a8c8666e50e68beeb7a17c4de0eb6088245507925cf52a9f4c678fddf7c5d856d4d0e66417b1f73a4798069d383b8d352e2400ba155e0a03b06eb3850362b72151502e0be82e24579f59b2ad39937df44faec3cfe71ad9da95faf6b28c16841944a6878cddec944a40f5df8a435c77c8d62b83d249bcb8e31c939003a800f2be6cb0cff1efc6a2552e3b1ef0e7e17b41cb61fa33ad06a33f1cf378e378a3498bcfd7d504454977ce51be00eff7fc694b3b92854e653278ce33d6ebb7ddcffe5dd6e474e1ffaa795906868ad299203c8b2c19419f280bb0fdc71bb3f73f16533bac67a66063b46f75e79442807ef4b96cb01ccd072160bfb6e41c528d9c8d0499fda0ed2c32c50179959b9c10c81fe19ca296597a05906019f10d8c210756f1d314d26625a97355bdf5308736e2ac823edae260626b82829bf1dd5f03726553db96d890c54cb716460ceda001f4be54a3b9a57ba26802aa4a00b0f1bcd22ed11effd6b3647bfbed53626be245258ebdad03fcc4d4521f13b310694bfb8aa550a22d4f494ac6eeeafb3ed43f4179c7710c2996006973f112aba84a4d50498afd513ec65d1d4511b356f49ae00498f28ff8a8ba8ba3afc81ca6e28896fc064db3da81deaa842dc212b54e5ef7128f6d42f86b132b64d714a4d8e829e1d43775eac4ef938231a4aa6521cdbf4e8b5e5fe8f91acd54e7643370d20da1928a3a93aac3227e3377f28c7d348e643b57924a4924d4b80c0ee0566238229e7b7f0a044bdb35cc501de1b9172add0c38346501d215ee083a47d9506aa31523ae5bc5c44f557aa8ea34e808dadcedaa2781a3854447ac5ed3409daad46ce9217496dbadcb479e68e6cc4c2bdaa8a4c10160c4395e20dba5c6ebeebb7c0499580990a514ace7b6dfda46e362a05c02eb8802885ca47435434e5d2d36326ead212508fa90ad7a29801eb0350c7ead140b0fbc0cf15a42278e5602ef12bd2e498d1b242a9566d5731b015376820e0cf997a0c8f356702cbdb100ab696bfb80ba41f9dd6ac10080a9e6e2d38b1b2992f7944e28f08c8f62ce8b1309575f93c76b5b6472359ffeebd90e9b0b7225afcf85ffa72dd03fddbc367f9e4794ef7f55f18c1f4194d8de0e26a3221107cebbb4e2e6b6ea7fe4d563141fe0c43b7b6c85a5061cacc29e251f0fd547b9fab8de4a8e5780544163d2a317df7d1d69a22003d5229c30e05501e9f79b92abe028661c46acd7653f0434b2662afd02cc8a25a1854d0953c0ca5c455b07fc3aa1c3464556793fe3724dc041ced3447c9541de6ba1a5c27588ab3a4e6d1530c13ceb426320c803c41b31c71c75098a14c838d489a3fe34786bbcf6246e080c107bca50ad04936d5874e73aa606d5053a6e9da03f746f5b7522e9f065781710d4ac8cea060466822513de5435f7d9d8b25ff384bcd5585d113e91490731a6fac73375ba3ef4159f424fadcc1aacfac940f1d4cac7663fe52836cac5de0d34f6ae5eaefa1e2f9224e279dfc92c4ee1a348e1df50661b81568646dab268ae8054cda419486e70687168f161102b9fdd81059718555830bf0ad960bb3969a17ddddaf9e12c1a73a290a45920a5474b216af33f20d86fc8fe259a6cee5619f4b96197f823c116607287313c3340822b8d53e1b51b2950abb8d50a3a178a0572409af479e39e1d496eba25ec48db30f3774803b21b8940b35fc66abea3dd04315b824b1d8bfd4746fa32abbb93b2f959eb07504019bccb5d64297e30d4143017a16640ec842a177778182e06b6abe0a8ba474beea1529fcc5bfb3ead80dd4f250a85c5f18e335df8dc77da06b1afef54d24c42de4b5da9ff32bff0fd6b1681be921e0ec4e9637b32320ee79c3be88f623c73a5ef6dda30ead13d6eb8718efac2ca464985e7fc734cc6bda8246f0754209491163e5e9353867e7559b4852069c0061fc2659f2efba45ed337ce0386a4a8db4f1338265d64aed7fd886b697a2e95c61f26df0405a33705fde649a0d62b5e02cb0211594d35ebf496868376c9888c7e632c4caac10a04fda0913c2fdff3af998984338fdfb2e57d4d897a7bfa0291a363956154ec9c44035dd08675c20bb15612d5540d72baa8ffb675c76435aab2f716124ba75a14bb68e68fb3a07352191780fbf61b86713f0273973238179ca1812c1a9449383e4ce76a2372cf823a1287156c11cbe9f6dbdc7382d9cd47a005ff46c12d7828007574b7770826762307d2575d7f1c8f9d27f88bc06c80f9c72c5091af1b5240d67b2c8a597ceba005a12d6cc131f8a7078e8f647f336ac86ee458a32cd06f8ebd96d04726f230f1952ac58c6051bb02dee59efad086e9c9bb817a87b6aec380e09b450ba75a3d4e95f53228823f4407c44599173229dd96030670c0e3538ecb9ec3c0c83cf0cc2442fee39195ace1fd588ca0d3de67c6a1ba892cf096b8af6f3d7c4cd025e61d5928a1d672c824a53fd14c772cc27bc8617dd54246b9400a74bdfa69f66dfb38d802c80e6c50bfeef33476deadbb46ff1c12acfda8d4ec027a1388139178783b4b468785d60e0a730dac4bacfdb52063ee7cfc042bac2b0b288e48e6888808949702bc5644a8c73bd3236e49f8c8f4f9b995bf0088f9f59ffd5b75db1f231a21fc9b42dd1fd737245ef2dec4786423c5f7ffd9d632f9a869d24fdfc475749831cd00b5c4d43e1ae324e787e0a82e0e9c45a95ad17dbe0ee40d7745a2807b392efdd34247d92a968a2393bed0c763c248d16fe03e469aae58a78dbc88fc06c8fac57e23427e37aad3ef1dcab24611239e61962fcf406fd8c56eda88ac71d93e0fc7498baea49e3c9463a9b423508d2e99de497dbb432fc518fdd4439039d3bd992a50c7cf3f26b2c0a8ad5f4feb46e2b6fe78e25dea15c30b8606630cd8e6373ccd800b7c8a3d0782f945b811f4b505c08759ea0c2182a2c01de838d165326333875dd26d4bfafcf5fe84270c40d357b34655939715c2145ad83ef921b0c5324a17b3885ea5bf0689f4a15d9bf21227be6742ba1855e11312fa6b53593a4ebc7d176cdb2bd49066893837dbc8ee052545b6d2624ffdaf34b13d04b8f94043c437b857df2f052a505879dc8f713332498d0aae1b0da0bb7ce64b70c4a4722e2b92b80cf4cc6d527ccdd89c351e387e8819bea46d24fc900f2182ae2db205e49e9af6057d0e0dc8ee59ab1f0b588d013752a8e0ecb81a0255925288f1fb3f8628eac1967c9ab2a1c666d1afae4d49116576e846eb66eb3ad241b7098e32ae6b8c9614fcdc31647ae80c61c341db491686dabedf181092d7644ca3b7cb1442ee9ebb653c9a98d35796bba8ebb6103112254bcc1dbdca7ce305006a37f89eb76021ebeb87e2dd99710ad0224cafe5ca7b6510f67fe65afaf2fbcd6dcc185792c98174532cd4290ae630ae1443759ff43424dfb46d7755b0bdb973d802efbff71fc0c0c9fc1c172f335503b377dce61afd6ecc4ce782b7a90d4c583f9c8a6c63c933cbe1ad2144287efc818498601aa1bf4ae4703c30f9c5f2047c525e657cd29c2d845e38044c6eea6a2a6c53d968c7abf4f4c56f9d4593081ffa437140cbef2f1b1d113119ff0d1a165aa54ad00338aa7ba7e07ba10dd1d44579ecf656ef81a50d776b396a285345d07b1d57e6c7a6330ecb4a59f2fc5ae407306f07a4211fac3bed13c6b521045c8be19eee71552223428e163b9c841ececf3bc0e200c53e5da8f499641b9aa6d90a2ac4241af6664a823081bd8f067ac89a7661852d1741ddf9e9d6bb25ba5d256098579c80a50199a81dd7c9face6e61e87b0ce28290e35be81daef5233572d20dd110fb1ee1e6941b31eacaf838487f99bb2388781b72e751554109e9e312b47c234654a510c96b20db8da4c165e42c03a07d0b5df55759dd6aa0362f073568fa000457b663d8410b8fe617cd844977824adb981583ffbbf72947cdfe21aadeba5d7355867dec5334aef81f196f8e56a779c278775bea9aad57862a451269f2b50392f8c25aa873847628b10ffbe1d21eba3a45fb192a97b5bfed0f1acbec0b65d3e743c43d32dfa33735ab263923fe4fc77159bc3f3bfb1ca5429ee5fe3a41274f3027a2353cce1cc75ee2dd20a73192665a5293bd00a936d9fa91b75aa2c1bc0268c0ea9037cc750cdf4bbf651521e9244265a28aed166ba93563767266d76d6054101d51dc677004fdb57a8f0969a673294e382f65253e4f459edf805c9e72cdc0a80aaa114ee00608e25ed20ce0bc1ae9be65e6677182513f2926bf72deba2f73534a9c200a4524f5e6de0aaebdf05172bfbfc55ae74c86601fa8008398e793c57ea35d2fc006e364e2d9f05bfbae2e604fed2975c2d14b29f1fb3d9d48231b817b75182888a5d7e7151b247e32aad068def2f13ee7e6b3d13e04f2c2d74503188b608ec902e53a38b456438e900465308824606b4ef53a9bccf2c1aadfb735e4838dbb2f4cdd7a5dc937f06430960e98c975f456da9a2badd95651a603dd82d1d53a2a745e42bc652eca1d104695a0b135935482e4115d2b4e15fbf571c8a3626e1f54dd130b79b35f1347a81ebfad6e0ba0b2dea9b312de66267fbaa214b5ba284586f2e3c7feee77144e6c61d2d0302830f4cb0b4e742faca115cb6e7cb434b4dd0c2250d02596924d5c1e67324b2efc8e0a6baeff2b0a10b95691e1fbe2a14a0f3724e8cea2856558fe66ca2cfcbfe02851773fcf7961461ecd0091e412b83b131823e67f561c925091413e3c93b6fc23b5b0013be6d241cd5a04c9d018105c143567e7ceef12291d681b840d9034c7c0b84e5fed473404963b74883398b741641948e3951f62aa016bb8904391709baa0a839897b1856bb62e6abd1776e5569742d7b5c1dd13191c0ce27187236f4a2c10180b55e8819fd753b535d6ee70b88da2994de76520321614aba5bff33c5e57b1a67764e7fc171e39c7d4c5e7cab2abe268afdb56cdf726b7b129af5e9dd2dc4e1b8ffcede517aa469c004f843f9f2c21fa0dce9da824f9d9ab3c6440cd34a1ccaaa3053c2cfb1f30651cb9150dc1c5d99fed8954f8bd86e00565d91fd8c89dac2a6edbf704ffa5d76dd88c4de3a1e43a7a9e7ab949a4dd110c2354fa3b5fc8c37bf4d54d38f7c1dff7d0f2fb887a0e7e8034f1d663a21d3325a702e527e5fada6f383e55787a552c3c52360b25761bd42767941e7931dd445fdea7eccb887b53c6967fc10ab288f8eb1e7996964efa4f2f37ed6a2cdbf40742dde936a5ae141a10b692c9cbfd961169e4a3a5a968607425341e3dbcdbd2f92ba4d410d53b7c038c84454f0eb7dd7f2b559ba8c4960aae4d30df3621eb4f76c89bd11db21a9264a9f3f1f4b022a83dedd9dc862962bda9978e0a09665cdfb57e4730d5ead39c2b4bc2298d8aead3cfc12dc4e262b5d653fc4749058c8297cf2159eaa4fff1a228761e3d2035d2ba46e5e348946ae02e55d7fb29bf8979de913c40f47023ce40f8e43c5f701d294c838bb6833d781581c6854563d00c7d289d1e58d44eb2e9b0968ad10b01bca89111e27493e64c15ec74856cb621a8df567e224df895cc9146885282b49b80547da36fa1d8939f33a17a52d94b9637d61f46d422feecee9ea032cd0dda316dd9ed8f4555b1460103519f5411c63c703f9e646b38570446363078e8f6d725830013e10233127a71fe5b8d0123670e0a9a0271ccd0ffe78fc0dc87b9f3c126cff79784c22e9ad60f58d3e99021c35df2f1e59f157ab8c382faf266f03ed78cbdcb73c06ea85eebc7c86a68a7c2c9ce551e819456cc55155c79c03627ee99dce23933dcbce9188f366d3221026ab4d936fef8087fdf83df6153d289d294ab1c0759ebefc328692809574c9b642aeca6ea718b207c2fe1a01b5faac715cd3398feb6dcedbb687b61e9f48373560eb850263179846741420e6a81fdb143a31b37d879ad440e9b2aa8e88fc1836ecc24f01611170146725081b084a0d3876e5b998260dcddb4e3f439c200a3256181a2ddf38242637246f76edf61f51ec53ef5a16f238e17327294da22ff2f76a934d963777736a2b4df25a248d7a5cec87fbc4cf83a69b61cae8db75cd0519bd1dfc71bf64bfd5cc32a204327576c04e76c17ce4b3ffb3a854e643c7c769a4f21b93aa1868ecbf68a551af8464f516c7cca28af708bebcc2c235043ef9e6475bd28358081a85dd639c9ec4af266d3eacdf51cfc061333697183c54ff5307bb38037a44835f47b99758d95338fad5a706e77b37470034c8ebb3bc6306630f6644c9960bcffe76d8f18fec7853a989591443dbcc46100274103acff9d626c0cd9ab437f8604f8765d47b8609e99816a673d2d2a94e6bed556202f985ebe6e00e2a9bf6282a3bcce290fb0e22d6e4e5aa42d7b99f1d3687b6a3c06d9eca894edda3e2f62e5a55bd66ff167b8de4c2c8ffc235b2f0ce58336321c825d23ae8cfea4ac93d4114abbda429764c37a52873b24ae311baaebbfda10e27a05daf9da233f5493f8d9c39726f816aa8cde04387132e515c7b39daffd8c07537ffbf19308f8bcb056edd8981683d2701404209fed296ce3894dfa0ebf1431fb7d867a28190c580477da9d9d0db560428631fce0dc6fffb011be4cc2d0645a27f933f2fa8cb9567412855169da13df7e0742aa930942989b6ac012eaffa5e518950fc2b7d93248ddb35543327ba821654cb36c11143c9ff031bccf3c833886b7e4f2181ada1dbcb4905ad83598051665fe09a98375cec38226f33bea75786d4b6e8eefc724e605c3c5c9b555b0c8b23c9d3589b2ec71a522d7cc16ee6b90411de7c35419949efed8e0f43cb1987acd56ae01c2ab1899224fda76473554bbe28da6ba30a9b24706ef1e5e09b791a065703d3ee70fc7b5c38de7fb79ff8127d439d5704841778d663ae0667a220cf1d0f58b85dcc7419d0e85a5c5f93fcd99ee0761f9ce935e4ba7a1c9a76b312ed7a75dd4d07c18e318dad634b742bb4e44d8bb907ccfd7aec9f7ac91868f51498a922e86f282582bdd3129fc283903b028d6220971f8b41e1c09acce209d7a034f589db549e2dbfc472d5b51b5918cc86fd38311bfbf06e14e11dd2ae752c451b67cff776319a64f947077ab3a9b9f66b274d2305f7ea9a5a1c3ddabd0172c3fcf8c274b8d4025ba8bdb86d574976581174b7ae1a26e38c65e843234e7a745bd62b979eb8f7296ff606095cfb89b48b1c1109e5a9d8367acacb809f2905864fd013948e4dfb745a32017e5d554c468cce498212e0c36d3392bbcc6cbede8e0849393c2ea74e76c0973f73dcc4d4e9bd6fe62a934f1fea34928441aadb79a21ee81c08149d6e4aa3bd379ad96689d7132f178e5b1c8c2c313b203884058cceff8ad089ddfb705a288d92a28a1ecf9083d2d667e282796a86a9f3785a36921a5f535b69eff8e6c7247b0f1085b3093bdeef17341498a4e58c16622be3383e6d47b1bee9503894dc28053fee30dd074a8de31493ad35c254c3f14485a8744fad0e7cea4093d8fd69c7055ebb1f548f9da04dd56b86d22a4a9c55e9b9d7260928f257d77ade41f4822f21ac64698e685053cf55583a6590754d0d45c1cb0708a57d0477fad5cc35d63c7b89b5d09ab1907fb8ae3d0fa5a2a55b12d2b454296492bb25403cb4b4b47fb015c5e3ea2dc0df6e22a7a41d0e813ffbdda7ae878342a91e54a07ad959f9e96adfa1e60857cb37d3695ada51e80ce87bceaad801cec09287e834f417fc730822cc624bd4611a750f963edb2ea2f0c0d3fa26b46b346573a45615e40ef353f724654a35ea2e5e7cb65a6bc285c93c57998ba018cfbea9d974ff1c7984d4219637dbd45d21fb2629d21518188b0f77d2f33e884843ba600d21122e1e45e498181bb35a235c59eeae16a8b99e554f5cfca31bcae41f46ec335a387bdeb8a0bdab24349b745e3da45574f3c1e4562bf6acfb30a090bf17dbef5ef0c7f5dd8df61e53c5c873b4c41ad44225804fddc6ac100f1647bf1567f81d295d5e6703e7b1bb3c9501fc5e7f5abc1e4ad85c12458b593131f257c6cf734f81d2ec8220460a0149dcd80e08ad09da2978c492ec076a87923c68a06424f26a2a18895d27e48ad9c5390977a37875358b171ba15b2b34a98c0c33f70fb569f70bd2d5354aa4d9e8654c69caf4c712d8e0f326e1f970df197c8a0d3eb43c732cd2edd08f35e3865c2b0c87c9a50decc22c81b0de1cd418611e599648ad881ffd070ad9b1221186816b5398ce171ace9dd6a3fa9b2a778f0b51fa00160c0a36e1419c1eb34a2779b4235880e9475958783c246c47a374a8ba778501e769d1f453519aa2d20e398060c165c642eacad867138bcf8c4431031fa01fd3fecd59f0919e59ac77f90cee3467212e17ea078b67207558056e58b7609cd2a7487976be713f5ef0364adc431ce816543fda125104d129e895bd017d33420d16c94dc721b934fca9952c1889c8053bcf335851e1d837eedbdb9753f8e644875d65e3ed9f031cfe0f8d727517844bb0ebfc4bfb067af0d592eea173ef9c14d8420bb9f9d085c18d7604ae3f82e2c9a8bbeff7452a61d5cecea08560b8cf57eedf22bf17ec70c7bf81e63cc0bd7c3a265df7772e2c3e68e84a17c2a3e3b7741ed88c9eb1e148700f0cb78d9c2faa324d7c687d0655d30b9b689cbb0af6b94a6459d4408173198e1c9090a182e51e7288645b467471958690fecfaae0dd5748be7ae96122be3edef1896f439b939aef7e1e5edb8bf91d02db926ebac4cc1889d320b04e8cbb5c038a59881fce814197dddcb9140aed4fe565cb8e171e80904e08a601acef843c0691d5143d095e6bf66528730bf54d7fc3e4ca77047000ea7a459e77e10738bd3a6c42310c2f747fba45a9972b715c710182434fed6b678229bf85e9525e652591d899fafd53f7f0320b0e77ddf8864552f058c713e21d1aca224f9fe60bde3bc101cc0734317635b0269f51182df1b1029b5dcde181b628537c3b136816ce3dec2f720d7bdce36e978803d6121704cb27d2d79d868eb78d7a098e80c97cb990fb8630ebf1d1ba07c79d71b2e6f41fa8469b2da2fb8c6cb6a5db0d52c911da36dc8f4b12797febc34584f6bf502cdcc3789371bb3fde9ed672d9cb58379ea1b1c7137bf3f2b92f3c25f5518328743b700a6fbbe8d447c9a764ec5e8f6f39fdbb7fe9b97c955d10c1fe785a5ff86f24191deda77a01e1a15ac542a41dafc5b406ff9d1b58df8222b36ec8ea3df8063e9ce07bfacad65cb2b6227cd548efca6ebb548ee60eae6dd16b715931b1ae24642017b45fc2848a57fc7cb271663d8412b8558231678b228ef81f9af4dbfc7e022538a23c16b2e96eb2a84b744ffe78e13e39f4cac8aeeb256011984afec8ebe40a4f9ae42a7ecaceec4a5480150b1efd1c027d8923043d75f1411468191a70e2c3967a4d8e08ce72f80ed851515851b01b00779a8832772d041453910d46aed8863d2748ebf5d8735625e3a6230224ad369474ec6cf0b83d182b5eed06a5c9c848f97dbfbb5ae94d3aa2581e26f1905a85fd4c63b677a4a762cb871f95c6a126a5fd57bab422618df085ef03f99cc3f32c8663f753f5c8db1f1b52c253ac78f8e0defbbdffa7e93cad2b600bda6779abfc04f0dc3a5272a979fdb93fefee1df8a6a645e9bd104b298bab2f019a1b07f9c90cda08f790941b030d3a7bfd8b6441496d833150b95be2dc6daac206d081b7d0ea5def035bd4e983dcbae9dea6a056d14d3821d86cc18010a418f1fc239ee8ac69abf243bf8b35c8555b9d9711231a96f3099a35d7d29e535c8f3228dc0e3877a41ef3a5e9053ec63aa627d7e509eded8464d3377d9c00d1402d32436bfbebd028191c5153cd754b67e5618c17c5afd5a1cdcaa3e062aaa531439b2ded4ac5fdd9329f7bf1cffbda3f60d45e18688feb07548651b1b3c06d0234e994f98adaff900034dd217239bd8b7902ebe206cc8c35dd66afef27e4c32467344aec2c55a6a5c44fb42c6baa732551d41cf8731b638c839392df80982d59e04c87d475e96788caaf4d9c116776fc223ee85474763cd426f487250d95bd95516d523274e579be40ed1ec93387c88e226546473a94adff2844da18a8999cb299490b9c55a9066465687a905010f74076c5c15585a5c73610f19d1bb108eb377e12f3c6cdac36cba1c17ce04c578f26827fd4c1bdbbe55db6b0e13b212446498eaa9726339097156efa397a7f8ef1db48d04a9d9bd6ad8b14e329c6ad2f183ac22549d930043113630e3b5f0b368a312b7b4cc99ed6490f54c87da268f6c4b4408d397ec5fd9b9c0f157623eb6bac2a8404931a0f9a2e608053e9c6cd28018c4d2136fde038db3f24262ebbfbb68f41d4384a93a3e691776c73b9bf0c3589ec353cb7b322310c0a860e005e7fcad04f17ca564f4df1b91ff4201c3001aad8bc2fb2bd5afe385f162a305959e41c0b99c9ccf142d94f696526d61c78aac8a1d15392c1682989579c512959e0936ddaa4e5e7aa62de00745757ea65880f3cf7dc599e4361854f0cb899a26c3a835964fd395b44a1a7ed2f5b5c0fc34e9c66aedf2575a3ea74df3bc399b301d7eb8d888b5341d3e0b776cb90769128888e54f8e95c81ab2cfc1bc0123e6978d7c4eb93865b723168c0fda7f97f30c8c573cd7787180a5b8d3d3acbe34f8a8b3cd046812761e24f623ae461afaf2f46f10b680a147d0be4f138f8880724f14260079216d73ca7db401b9ee44776a423ef35023bef1769896e4be6088735cc07e4959225b0f737ce96b309917e02e418333d278fd81b54275ed886b4b7637e0cdfdaeef6f14229650d0eb43fcb61328c6109c1b7a36bb2236804f99a4c76f3ed4458f7d75ae5448f3538d3f581f3aea2dc5789815e5365ff5ab6f95de554ba5da3f750fbbde89f76d7d851b0e66a04fab1876b3f753935cc58ed387f590d16e5263d49a9f76f4f8aebddb09a1bb25fe7d3af6829aa697aac73ed580515156490f7ba049afd3bb9786c358f9a5972242eab470fd710275aa54d66191417b27ddab9dd6824c1f4b3035a235e59691be48e8ab3d3deede032b89b3ff6d5fe77822a80890c59977041babc2b0436a1ceb3733a88b2550358ba8593be2ef0a54aa9ea11897d97d216a4329a9e7d32082dbb3d32505eda2e578cff291b1292cfa6e2bc7b36407b01b9200f9f70d42d47f325dde622950bfcb3f83916de0125383894b4deccd04314f4a4933abb96d60e577804a991aa79a2c1e1abb04dc1123207e1595b7eae66fc4489cb38b6556149053687bcabff1957e327d57078a1decece1b9a1d692c2899b25689ee97779022ca1220fa58c6c3afe309a1a17f05be10e0ea4a7ff3225ac6ee2eeef1a14b9a16865b5de1e046d206b8a4d7585340e88bb94a1922f255ca9db019d8fb9431ec43a7d42b652c61784c557a5fbbe9deaa043ae816e24ccc6465a0099850a258841182a2591834a4d6e54427efd578da3af430cc334052f6ffbb331d6ca87710613be46c8177e8099071461a8251a9910564b5585e96e8dcc3065cfcfb75ba1422d2c5e8eba6e9a17486c763dab8c859226236127c108d499f41567c751f9986d3f2e2790e7067ea83314d9dffbbf324a7d587b932f874204516902030ac986b7b33cbce82f3181058feea5a032917e380ff044099988ac1f5e118dc2d2a11f96feb5b74a1015ed8755798efcbb83a11340cf7559338b6ff6ee1af7795082b6d2a66c07db35d537a80643e19559b9ee3fba8993851f332d42f8485539298a81478b2ef18ef551bab5012eac944bb4521d138c4f44331eda70b138037cea05839faf64a2f05ddbfbfb517dd18ac56ea7b1d59cc521f5cc1b1e860a568ee208ab9ea7a1649076d83ba8a166db84fa6b8a15ed123fd058d08e3ae43b99a26b5a6555ff47f72960e658d7c6274593bd2bfd8f3db18769d3a4a01a7a013502c53f635696e64e81792ab0ec3c5e3e880a83be3defda54f02accaf7a70620906100b5c35ecf2140740dc303ab2ab6f802e620bf57719386bb8392b895504116e3b59bbe7efe194af83faa9c61108c337288418f7719dbd5f5db7cfa518f4c853da38d8bd7498eb5a737975dbd7bdb1806d2d0fe6316de39176cbe3b6798451094dbd9d37de8c463047f4d7dcb03eae828b4cfa15507c5b643922ab543b469e0385560d49bd3a505c48a2d4a4fe613d645fc5d846776ffaaaff2d6bf3dbc6a197987596893e9fecf21f42d6d201f4cc5a05a61d00bd40ffc93b501c1c33094a0eb5ae441b2e45eb968dd6e8b3a6f7b8dd5f04f66b9d2eef5ac368d76462c29faa154ed6065110a7f9d0907c3c0e3b5e6a75ed4ae8cc9fc6f12220bb032dc5f0ac392d8672e2624f025530e642d23ebbff2ee958b577e445efc6403ce390cb434878c1884f2e6ceb0e85d428ed7303354c290f8395d3c3608246b82427ad83c0f731000f48f6c16bc4f6094b7fc9e7c4603b2f0d226228f301abfed206b6cac915154ca4bc15225c28510b80a00d52d94c781b8387ba750e9494bdfb3cb950fd92d25664d07b2f0f91de7b72b4826376751f2a320068b6643348b1d9a8b58851722bed3bfc346fce92485d84f7110df264e146b46d12fca212b44c13ad51eea626f7612a74373ceae48c5cffb4daad6c776cf1633f9ce7a197241d957c6675ec0f7606d657ce17eb0f21e4239c47bda7e64a02c4ed7d4a23cb188f5f6332c6392d9877259c02c43f68dced2f289a4b498f2f0254535fed38a6f7b04b8bdedd5b13534b5b591353f3e08de61fc98a898e524b64f17441dd038cf418da27465334e4b869797621a28e22582c97d788a23de187a4de3e38098afd5bf4484889fe14ac8963134","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
