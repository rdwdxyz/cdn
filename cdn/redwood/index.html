<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f90a293d88057a57b05a369b6c50db413a7ffa0c9b46e11830d864df6e27775d57c7838a8e4174eb4edbfec441e1729b8c4fae3af9253fa741ea30c518f04d2abe8da0d9f414503b38eba549119236f28dd62db1b32598e8d93e83bedf97733238700e22e460fe64b38ce72c3f3d79a419d3a39cb168f0edeb4377c065e2cae55e97f9cef4c98327a9053788d43def299675eab234c467a0ff871232821dddc967ebd31862e83d9686d90da5fd23b08eba1bd73583a17598aa9390da8fd8b1e20d5ad20125f5319b2148c1d83302d7c8ce77706a8e0decfad1fdff9cfdb5032ec2805cfdda4b04ebf4a3156458dd11c15b0d116e91328f5a54e441e5fd2e252f7eb3b4be0565075121a803fb3904a37444ba7b51b5ef4766d7594d13382ded0eb025819ddc2c1a5400a6554a96bf3e50165913f0d89dbbe28b42856df4cf1d6040d5d0af30386afad50be5fbd145fd289a6eec3fa131535eaf4291f9f39c3526b09ead99b642e3a2173f86d58ca1022a38562c05c829c44e0609b5514057401fda347d9d03622cd060b5508eb27af495a3cb230c3155f75d9f023674bdbe40ae143a358b4f06be9d0e72387f823b9e6f6e3b0c1df813e27843b78aba55899d602acbc554275cd84bd0ef118a44cdba56a6df551d30ca500b2e9b5034d4d8e1772e0679d6222ca86e74a4ed30f6a66a493d3ddf9fdea5852677fde1c44b5374f2a41f75545dc7b7656b285cae7c95072d293405ede3bbe0ed911ce756ca58bb513536e2bea1ff2293962b00777c6a8253cab3f041dfea9083aa27fa826d07f2eabdea729e65b6aa285d16d0ee195eabb733ffc365dec36173818b3b5d8ad4ef5b9fd687a858e5b4d1ec897e4eba52fbdd02491ed93b57be40efd56b23c773a51c25db60ef489c78b1fc1a1e2440d408a7bbc18314af35bb528c1068ced7775c26b51c89d603c9916ae1369189ba768649c38efa426f2a01ef90d53bc270edcc54fa9bbe446b645ca2b3f577b9c0d7c4657bc6330b756f123d5d22ee2f3f945ebe58df640338f7f956e7977b32ab51e73a7c548377122468eb4d33f65159feb7c9857a68ebed4d8e7e204f96c5440258bb64ac2c830bb166b4426fc9e45dcfc28d1799d73ed60fe6e800360feeb8f25f0f10568f1a46a1bfd17738ff6a50aea75d249a191cb70658d32f1a1ee3ba95fc707c1fc8ca52f88052ca460804705112473cc1e71adee2ed73ffa032edf53d4f14cb5859d1b934306f150cb301bc03da8e41ecff3df608c34bfc34ce069d9fcf8c1c77dbc0994be9d9dc43384beb8e815299d329804da32f92311c4af169efbb6d7226c7c1593716aeef128a1e5ef214b270aeeb9dae2defce47aa813414378c18f46e865682288742e4e52d90df1f7bb842c24c6add6c52bdfd41ae5f7afd583727db098ce794570e78db92652f90e3b0257dd6095f2fad2577dcd01dbfb6135a6cd8975603198b00eb35458cbc4ed184274c1d2b6615ca0d31a77cef3902f5fc392bd4a03cde5702203276c62bf0fc0766856298ed6ce3b6381646d01a0a0ed406a642b136852450ac41c74ad1265d103aab5355d814f70c001689c58710db836b37694ec86379546d84b99a1997be134080dc4158a60ec197f2cb3e62d549baf179d940bf726564730462edb0c221c4fe96485ba31e0a56167f6bf2ceb92cd9f32f16b8512c40582b4781290fce807897fbcd1bddfd98b7652cefe8e1d02ac3e513a7d7d449ae8b180348ba006e44ab887f4c3fec6240008039c9ec91c1de5b6347b647423c43e714ff0fa92f24f64192870d614ee3b7515970eb0396d49d54d7950810895795d02c348df860a32eb0d49f736ae47d774243e3ab226a89905bf9336e4ce8afc76a09821b92d2f71aa08db232e7443770ebffa1b3178979ed88af822a7c6ebcd1ad788379d5c62fffacaae3ff36f172445b2752cd03e649375df2e5ddd2f1bdfc8e9de3365a7417de85c04216d659dd30e7954fb9257fcb881547a4197d8c48a74f593239a985c1af0e0e1eb04f5dbcf7c2c2ed947741d115b08f319260541f53e54133a3af23f62c020efc79fc9ba4f446b377db26e1ddb23f17c12d431fcee824fc86520e83c7d548a8d4e34f444281a6c8788675e763f949c447a525b616e5a5c787e1fe6766c3155b6b5857bf7df282abaa1b35b76c5aed90c8525603cdf381d069465fe928bc718664a1c301ec51c0130feaf2d9bc5c488b4a463441616572a9083487a4a73084d12e3997e9241dbbdaac680c7b0d27948ed97fe3af9ae7dddea42c5945c37defdb7d2c688789ad538dd5cb7add7ef1962bd63852e29bb804d401c98b695727a172d31685712921632223e09833f2d182aa169eb3fbbe1548de7cc6cc727c94fdb730ed470e700485f7bc080837f06f2b84c06d5cb84a428fe6bf291f058461363c5e69bef9a452ac88fd4dcae4421b74feda47d9e63c10be9a3a1ce4276a6733326f1f4edf755d9bb9f6ee32fe0ed28fdbeb6b57cb45b6e9eb4f05a2875f25ded6b8d43da2ecae8eab6671c52056ecf284b064f4e094c550726797e8ff3f3ac74f85629ac5bfa2fc9a65d12bd46c67fca668954f7bfca8a757cddf4995c4f19e0bbd718cd18aecb01ffeb81e53a222d3b23ac792545dde829d8f2b1560c76f980141f110fa56ae1212f933dd676de42d284d8d433605d859cd253a4080e03c97d2a26d0d6f0c92299c47213af093611851c53bdf22096c23668cd9e99e6f0dbb95261b00657a5ddb8a3959152f50c7d87ff0922b37b5dfb9ffc5e58177976dbbe29378dc967231d24afd83ae691fef4109a46772b71c65f762284f599ec4118d1273b1c635a158079f9402785600cf1533f3882b1f4b2a5c98ef850fc34297d8fdae44ddad33e4a3f0a3659044dc9eebd099316898b27186bfe9b31b531bd59c9ca35ecf1e83d40509e2f3f1f2da5b09d041232c438197fa0fc850bd6f31c5d9a6b635958cee4a631c689b6bb4d3e9f8f99a2f9a567e72292f10e0bd38a86cdfe4fc11a367d4adf8fe3a3be1f1d9059ff129148b59be445469147d78c26985697aa97fb413a5fc385ed2e30609c084473036bba64f87ed9ff708684d045002b4498a99493343cd4a30f499f08931ba8e9239a50531b5ef6d96812f20b1521a25c2a508221732230f3fee0e6523c1579e65ccd1057c6b17fd74852a29beedb45dda0b1f37669f1fb40ebadbb50843e14f3a287ede19f6fa36ced3cf39b2e77543deeccdeb6ad4729f5aab49fd8a200a8edcf19395f47c17844670780542903bcc51d688c9a9c4e139958f60b58791e3e953e41ea7b10a819640885ee66d3cc53ce83391c5a959160364112f913e93079f17d70c13b1102b17c375281df1aa1d5251c5de6423c45b4c3ac80fb5872da3f05a4d3dea7dbae56c81aea34b172ddbf57efd1ae26722cba1a3e4691c1b219e638015de6da950c1721402013fadff68180f7138360096fef91119f2abd3efc87f82675e40b59d40ff6795a846850fed9461a895695470c1c6e0521e9dea29787e4cec2c9a8bdc78374bb99bb2c699fad9bb2263e2212ae7be99ff8e4f8575452da5b2a8fa23ef0562b6b87be66943b0580c6e309b87276cbd82cacc14d4f01f601c371a8610b0e9fab71fe906c129a78690acc75b067c4418b9e5f9a2c732cff4ffacfd8625feafb515936f08cf92192f57e571bd52a01fb199c0b6477d82a6625c5ed3bff7dc86bfec145016511364af1ee3c66b93b15b1979247fd8d1ba29a3bd3dc9bf4d18cd78bbe5328ac1cd966c01d3aba5770d2b2ff4fd671d1ee0fae10971a1ab9c58b6180c6faa3b42863dd046c535ceaa56b3b46a9454bc3f24bb7bc2f1374f436d4ab6f4c32e98fdfbe84a72a337ff2c7531939cc1cfc681b085ad3ec4f88f82544eb278632413822eb5f9aeb7b8719672c5fd2b4f414a1898f58c7c93bd89ce6a402633a777c0c26e53ca5c56119b25c7b0d99f7409158fef6a6267d5d456af62af223fd3f7652d93cc681913227c848bbaf503022937e48f5b348cf99ce016e404af38eb91bfd8af3e399fc3f536df46cd55349f6f52c8a0f45c64e132460930566373f5eb536c2117f129abf0db262238fdddf95cfbaf94c5cc0a146e649464107674ea952ada3186d128c31d56bfe8f9d8ca179e0060fdbea706af3ae48fa2d5f93f57b8f092e77a6bd92cbb03c6de6c5c7ad4b81b93aef39f7b98bca51c4c1acc9ab74f4096eb1e392271a66333cb9b8341fef8d677bee6de7d843190129a61b6035b22e26ac94093d734fda0654edd47afdcdbe0132c157c72c5ce37148c0d96b7288497f0eafd75ea60eabf14e66103fa01f8b140411b787042b4f28a7cae644369463814370a0ceeb48042471ae9dcf296bd59a0573eca6517a3cead9a53abca3f7e1e5b0a90f0247067be22576173c0f934bd6a07250a8cb424d52f487e0a585b548608620e7962f6ad9d41184c7306e7479d64978d244d458e23cda32521ae57381d494d5eddb7d8cc8ad13b8d10be739e8702a424a23e43ce55278368ee5dd26b9fa8d2b496619828f5899f2d420089bd243f1ccada9775253e438a4e1a741c5656d313f02993bcbef43144e835f098a8854c041a088a55f6d84198b6a4a88bc69e9789d766ffccc19ada277656639c02c37829c26445ec6822a33e84834d1c2c13d44c13fb8fc451c6c643a8004284e962cfdcb7dc41171af712e9215f64cd8e60481b0a4982a40edd6670a5e26dc2c673a74592c0ad77487a51aa7437b6e4d22ed6448453a0e4135494bc6f638532adb17aa1ee6b12ee10ec8c21d5eea47643e7abc982822b7e5e04da9b7e6bc74c6f17e9cd2c7a9a0635a3588082d23936bc34ad87031c1dffd454feee6a1e4843b66c7463bd2863516748be0915d6e98216c680f27e539083f55c8b5bbf69a5dce897b4876004481bc3421bf470bbeae4cb5bec59ac3ccbf25f6714b3f0c5507cde975be092bb3fed47ecc52b982d42a51ae37cab556bbb9263c4682387273b30906741e1adecdd6f0a70f30fa34923dc9386cd34a9008b79afa0b6f0286076bd6b87755a5df9a2c8b24988952ee5ea6b31285cf5aeffe1f9ff443a61790a9b4c71b5a1b38b56721ce4da9aff4e31944594dd80390e3d139da26b64ab6ce2498dcc5f18887aeb6974ce546dbf0661e3431515ff54ea620821aaca90b07f2a8b49ee368df09d4e5b793324f10f9b974b7dc6b7ea7a3151406142dfa5e32fa60f5d2c2ac74fa950542e8d4782e78dc888b49fa14497452788ed6eb5fc0feb3a4b8fe35ff07310025f1f339910ade3bc3cba09f9071f4dfabe6ed8a47e22b4f79765cc52e3190f93125884a3b28020e34dbacba51e1c022d3a9324d94ec12b187b0eb8e17cdea2bd92ef568d83e9c6b706b7d3d2a06d43410fd234c8c88b897638a7935cedd1daa6dad8ecc634018305876feb28bdb94758a3eadec21ccfc7075abfd5cb04165f76743c7a1b38347983fdbf4d6b611769180e902d528179fd3199b15b1864e7c16c886838d38c5cf358b4a95a73487ba898a07175b85f1978e4c21530230c5debd4adb11bfa6938fea6f4135bf72da22fb4fc7868d6bfd26e839343a4ff29940d4119aa91e268f42e0707d02dcd550da017b17081ec61eb0db1cbb67e816db063505a28e366dc0affce2fe3cf144ca175681d2006e4439193ef206319bf7e8e9cf66aed39bb72877232a045357b249740338c754cfd077ac0e9873d0498c75acadc97e06a4b5a47b17c788d02d2f4d0a23affec430b3a7d5dae93fb8ed478f8e82671269276bfbd29645bc8aef24a3ca6ac7707f4eda1a448cd5713782849135be8f88969a755dbd0d18e574666f853b40e29ce2c24e02c7b33e0afae540745beff3facdb50722e890df6841882a42543c4125b71fa5e347bcaa6e9d3445c38ec38c4996b839fc920f7e4bb65eafe90166b1699df51618209fa45f8b04cbbcfbeed7b4acf96ea8422094b7cdb35c938105ed6e7f187c46b4380c0da87a61daad17a57966f2d9c2cc55b33ffe509fea443c5c97877f6bbd551a66f30adbbbeeb867a6fdd9315689a81c1aef7ccd37623b7f0362ed39443dd9a83dc3117f03922383bbc68950fb482c86dc6c5284a2abcb65c13db2e834f4fb208544b57bc4477adc9219a3c30682b7fa99e25861fcdb6f2445c47b9a0050a5a6a8292d99dfb1684aff07642f318d646c1bce0041d43770573c91a9a4fb5f2ff735c30b008f5e8c148ea4286645aa708f92b15bd43f9ad8d6e487d11e25076fb05a9d0bb5e45f461cb6c3fd1db50d684a47fbb91f90b6c6a70c3d479ad84b9130b01828c8a61c6779f3f295c14c7ee3964322994453b662f3194b3837841b661ef452f462d308931d96672a81c0dd426c086a1639ad53d08c4d32c33d1a3782dbebc4bd2ea58a7fb9e50c33d01e492a054b7f8faf8521d51ae71c12c1936c1ad8b1280e4f7fd799634537163bff6791d1e1607a1f598d240a4888d909ddd0c85235caa464a0598d6854d00f2d5165bce169dcc92e561ed45c58102b92b05e4e63a7c7a5289d6b6413bc8ee3b9eefd3420d7ad76f6710dfe612c90ed1f87a4d9103af00c9b695b17eba6b2126dc12513ca08a606c8ade4602a19bfc33bc81ae35641c687b74b11026a7eaadbbe9373b9f261700d9ff8ed1d80e12b9046cc48bd505aad1d7574c3698a3a72bc9b35d90761cbc2b2ae6a92345da048c11456c132f40dd242412c49c1caf75f339bc6079811d8644bf40ceeaa6b7da85dbef809cf10bbbe6094034923b8ceb9d3aba02c5380c11ae9c96b1166f87f04d99d78c4349d7f7129a646b85fb75a8c0712dd04a7ae4769b20e0bfa8fa15421fae5509478a681f37158c3e897667230e1e7ad29ca209f458fa246088204fb453f192634fa5feaa1c72be169071082e82e7cb088fbc17d57f1252c207c96fc5f4b35d1d9112a16b4a95b7e18edef5b9d61d2f79cb40c8e1d7f06a6ffdb0f3954f696b43cb5abb00b8967f64674bfa57bd2bd7494864c8b264baecce0df279db22a7d446f8d3cbe9de8d23f8fdd7b98126e614631790e56e47e76c3213ebc57cfb40ccc30f27860e42d11120d829b532bd6d1329565cd846dce79ea8407566efcde00bb78c4590d2ad6bb13a4e3aa07c21dc03849cff264c49499631b8cd191f04443e18716dc263c0a305714d5716686f5822e03ef8933d9e32cc6c09c0b3592fbaa647460f4f842e3591875c0b7a277a6d736c78f9eeb70bcc7dcc14657339d570f86e67f1cb0cf5f543a9fabe30263efc4700ad7166c0cbd56d93f537383c0028d91fb7393e52709fd933d68a213dc08286804337268a801d928d4bea53b62a0b88fc905975d4c3dc6a3c2f99ff8dae681a8fa35e205c1bbbd133df99ba743a8d148fdbb524b15c4e778e3246d32933b7c174daf6b367a2e8b37db5be94f1446bd2d78a500c397f5fc99ee18e532547793c02fedc149998f64c99a277fda1c1aafe631bbf4c22bb12035195c93f06b89db1fd0f59694ba71786e22a6aae5cb3823c0337244ad257a125c902c394129d20b6c9b5980218af6c785e3bb2ebc5677bb960fff58ed52da28f7cee72a2d79a52feeec8668857cf57d0d82412af1f60d39e30a29632aff98af60d65ac53f8a32f6acdc123b5b8d4ec5ec3ed56f77d26d22c8ea04169acd00aaae4c53cf4b3abd4c0bba8fbb18169322d1339b792c7c147616a890758228c098a968b78b8b3b47325d798994f25a514dc3fc3973352ade79f9eaeaa8b86cb699d638ded381baa6491aea395cabbe20cb262345a5e1e02dc5dc449fcb8dc6f6f491adb6ad68764c503ed793e0868a4a73bf682ef5f7f8bd74dfe0c9415853e27ad2d69028e58ef65e0e6dad762c52f2fdc59b88d1e1f3b537a1a3d0cd514876b00f6b649ce7729b6970eb5e35d72d5a7cd3a38431ea7b17a56427ce4e98847d29ae342539e181e27026f477e60c6175101c2c2bfb6046954236b0af9bb97d2a1c29b5e32d047e2b5bb787305c549de1e820eb4fe7ca60681cc842df62d5650b1b035ae24da1fa58b2a1fe5192d7365655d76e3a5e6714697aba6614a8fbef78a709627ff5c1da7190133ec95b339f2901c54c0646fdeadc09234b64eacddd74ed1254198c9189e601797962d0f442d8713806fd6664182d915ffd9daf1dfe3623176525ff1e92f9fc0e5dd77d4f1895ca4c8d6fbd4be194dee1ff7f991b9fa693b68bec730d8ea6963931081391a9ab1e4ec00f8d2ab5c1bf353daaa7dd4201e388dd2f1fc35a46370b17252b0bd25e94826dc0c8bc972bb42f295f16f73eb22eea8d31174f15862b4f05283f42e8220ca5fae18e592d637162a1d73a244bfe338bff77f93065e592629298fba3c0776991fdf80e3305c3c3a671305fb1b58a14ea6f384417108726f735499fab958229911a3e9b3ebf4eeb30a2d5d7eb0386d2be733decd819549dcef6238a4fc92b27eec0834e37a7c7d4b3102c5530ba3925b081eb350304abc7ed6c0723d270d554f9e8804a863766bafe07128b2eb366482143986d9c9f0ae1a24d171f158e450a414517b4032a6e5c7f5ffe70dee620784976b30e0498cdfed5193cd24d41e2ff52bc7bf4f4238960a9d5deed895c6175c0a03d504c9e71c75256b17a411cfd786f45f02e281b16fbc047fd25c43792cb484ea06949e975ede3a521a931a2d4e4b66c17974c2b0d9337132dbf86b5d8149cecc28beabab4c5cc0d0592a01bcfba61155deff176d679956b179db7ec451051663b4a8096e7e6b917ec5614f8e850253eb0ef25055efefc9af4ff59607a5f6d64d16b4d89fecc8c2b70d08483ad5bb26a9fb39d9d9cde1a94a0f68fd592ef65a941a40f88bf608de93894985f75a6d2af28f37b6b285ca6157c35414fd8d061233a1bf0df7e1b284d6585d50de19548699cb962cac6afe7ac0ebbdac3ed517d6085282331ec3d0221f2a5a24760f6b34e3a8d9fb77bc4835458d43cc29be3330dd9fc947324a76bd533756cadf6048b4a573c85332c31cc2cfa03c6bc503c10490186b8bd2a9150e70b73fd0fa8be7bcff01da4c3bf72b560bafea321b9d7c0fde217fcd87b4ef741c2e8edbd33eff2c9c84d382c0bd2f9beb0d2b35f6787161f4118f9c9f99df36420e528796d3077842dc6d3bb4fea43e0d8cfa851ef5f65852513576f592e4e47488385902e34061d561d3262c8a0db80b0200224dbb0c1b92bf8736d00b4d388999c2815b740ea29ae6d1366c1f287bdc912d380c64d31e666893228ebeae4e8df8715cd84df4425366ce2c8a60d36917fe012274a69544b2e1b6ef933ac8126813c42ce381df05414a8928a96815319b4d221c253bd8e2c5e1fd199084b4b247894d3a97609cd8009c075abd57465d6eb4ff61cb0becf6290a72e4d27b5b0e6a43a4accff70d2da2693205aaa8395b559162c93e4116d056ceaeacb55c9b0dc651c3d896d1b6e19fcec0237d5960c464dd4376f6e93aa6e7e90eb02e4e1a0a8dbfac2652b5eabdcd202a9ef88de951aba797d22a78064adc3549e6820ac011cc1d5520ec90d88f6639117afe942aa906410e5e0757849bbe90253f4779894f9438d3ac7b0b2fddd5afc02f45af60000e8bb797596dc6f24682ea0a1ca094fc99f459bb2f2847e045178654377cd7832ebe90235399d8f6cbf30ff0002f82c9d97e2cfeb6fa25e641dc17fda67eb27538423470cb804eb6f01ec8128c49eaf31b5e8c13f32c60bf6afcf60535f9b196feabf3ab80db614218bae61bdd5f9dbd1a6172804425a221dd8564535ce67fa965a9d5c1795196f7b763b51920c06832f7fa7f5d9149f4f897294636e051f8da0ecec9aa898e8b00300a51cf164cb133ec044da5ff9915155a840c1329ca0dbe00a95c4c3368e8d004fd60ae2cc4a05f7f83e4daa84deead9fb2115c3782afb90b7a17dc24a9147ff39b803d58dd369bc6392bbe1cf85bfa7e8b9f737e42b97afa5678c7e8d9eb4a6d5995cc7e5003d0d02ccade972983af20fce21a21581296ca7212546369a3efbf710d0f78ffb386005e4dac8de83bf5e082666ef20a724ffbc68baf06c647cd0fbb333611e00daf63ee3752a79323b80d65134bb824102feaa372aee0e9b9cfdaab74406fcff0c038df13337bae79ef192accc1db7d7581c782097d159fb7c6a2bbc5b8f31735883d7f24ea131e69f7cc09285f47523a29c3eaa23bf42c3e50e43ab723fd659ad7705b316a0ebba9bd5543f834a7edb72d94a62bc3d2729f028dbabfdc478e9e40207a02dfef6fb7702aea63920e2fef7d995b39bde2e6aaa5ae5a097831df1b433e8f3ab60530dd4b426dc4ffa88eb3abd131ab806cd8436125a773ff750f1fd43226ea02c3504704e71ae6e53e6310e14fd6327a3b331cec5b900bfd5c841e57fda79a705a526f36b924ba994e43b308fb5c57b90c9679a80fc553a7650254f85746cde1987e0f170d56336f7ef4c291ce36da785224fc98f7b0ebf9d462cdca9f85d50a0c257f9574c97cd75c22d9cb4db54b9d1bf609e72970c8648f545321554c4885238d783a0585649590e6f1f72793a2494e70b2fce8d5ad56c2f0313c8242355c43fcb614fc14385794bcefc041f49768eb587ee097fe633d8857bf42744554c6c789c005acfc04620dc78a2344803395668e762ad4252f67675e5131be667f8cc0d78c8a205ef6aceb06ac49c9e169ef840f95bdab84ce0e07cf0c85f04670131f7665e378f4e1262cd400d683ead38020bcc83515051ecb333933d17d83036f4174bace845ae7dc8124f7559e120a6a17e220601f6b446fb1161a1d9f90af5440a7f07aecba3c22d6488fbca3d2b9551738e2034e7ef528a7c7c8c0fe75fe54a20a30b624d28430e2a15359ee7b0e259806d9ee093f1b0f3814cd63df0389536aa7bee615564d1a494eee0660b3c5d26d1d5bb4247591897f97870fefb667f48de8f435dc3615ffa3f041ff59cb2aa93a6e5f8171d64682c54c9f6ac48d1648cfb95d37481c265ca87a0d8aeb37a0afa2677e91a439c3d8e8e837e8f0bf0301084ee8452b4e36b38fd3544c977f278865d20bac371cf75c766d8136d793260d3113b26b4c252f3990832de9f95d45c05bda263e3118069d8c89c081235c6a3068a3abf7ec23877eedaee0e3f671b3cd492571994487be27cbc362405304714c3745ac28c3986ef60009cf8bda95d8a404e297ae674f95070cd7a058c3a11f9295a9f4cf7442decc8d5b606b2eb7ef071f0d2fd95919d29393947bca0347289fecc3713e3dc5d69db8e11297311add87e78477c607117db814a8d77ca6c3e2681606ce6987e08a8ed763db22b282b824f42b45df47e50c0e725900873b821e55a769cc96e4381c1aa20b3cd8438bcdd63f20294bbae541221b50198c6fda92925ae2d77f368417593c3a279fed997f2fb57cb95adbb05b28af8bda8162d978e966cd23e7fe726f9402903ec14a78ee6aa4360b78c220e387aeb4967b0d0fc95e839577a7ee2479eafd351dd0889268e9d0ca51d92f294a3bf847edc51b1541159aa6247dd0fc3ade8d1e1d7099e3d1e48dc97a936c9201f1f097e8add02aef0b4e0a82fbec83d80adf56674c9951ae7748111f968ffd96570a843394642c60cc9be9cf1dde9fd87585c38819ad1ffccbd1844a68a488a5d1c1ea08661dc065dabcefe1eb182421243d5e08ba2964b3cad42dc94586c0c56435baa0657aba4ea30328831978569d373794aa27299a8caca44a54acb1bd63a58d55298e821961270cbcca1aa5804ab64dd9f612e6ec218f68df6ec0527fdbc53d1e4a89a26dba85f2c5fb8f0381be3089a682693985f700bdd1ded44e0163d450faa18ba1af98ee79668c3c99d62a49be3253c239c154c1d462ea2c055ec2b39761d7a4627dca18af47948cb92f2ff34ce6a36850d71439b0d8601d0d76d235084c10baa41be6e304a11a87ef9d66bc5ba36ebbce001025263e141fbba8426b842d0e46f8437afbad0dfaf7d6ee230ebb46bc332138d6977d3450d58180c7746603c9ff85044c1406e83ae61503c39d0144f2cedee9fb6b73c1edbb244fc9c160d05740cacb22b7fa272fff383ae02f88a9bc3124f8a90bd437aa43cc40380c04a2685f454efafe8921c90cebac36d1153758d81315dac0b224c2866b18c501c9acce22efe7a14225f2a5c7d3ea4f452fd5e2fdb68ef1769dd6eb54f5593d58d7172768e5465ce9bc3ecaf7788a44f5892b6bbedf115c553f07dbcc578820b16afdbc39aaf1a9de9991287a4f217d295a34d79ff1cd431ad17403c65c10344d5a3fdc4d22eb8653fba9fe2f89d7242ec9962ddc652b9e314fff388404fedee5e2b8b64709b08d1815a2f155a8e35e85e27ec5772937cbff418614fdfe03b402a2e3a6a85ca77bb4fe5fdd69fba880d9afcd4bfc7233e3393bfd6d665a77647e27a8b3339b5f3da0099263f048cb446eaddce03dbefe7facfcee39f52974e083688102471932e18ebee9fdc24a3613bccab64a86021e6decb21e4ae2f942f980780f7d2bd3f62e94a7aa04d911e0f0ebf827e3f2cc3dca6af2ed1f01f718497ae280255272d760a5410837b8308357cd85ff0442f2240f8846bf6cc940b4eddb2d996fbac986028d064332954a7105c24f045ad98a960577ff759e7dbafec235b3ad7083b8d35f41e5e81abda136e534b4573c2a6b0bbe04f19e5f88d98150309d67d6f48b92cc7e38f369daa517a61a9227f408802d1237f420b1bbf7a1d700d5b5a7a2744c1dc7543a1426fd58d509ca4d4756174abac3d5bf983533537bb2518e5611cfdd52c78a5db00a8565aa1559ec443fab7f31a615b81e936e8f4056220d0995957d04a49ef5ab91fbbffda9282a4f3f61619d23fddaaa91b53401fff9e8d00324c368c3c0f39b006ecd4ed712cb2bcf95efb54d1486087e71ac609cd1ceacf2dfd6c6cfc784fd25df58425d98fee18790ed419348a579257211c52fd6b60578592cea2e7316e7b9701479cdd42bae84a0f153ac8afc1845e681cae4dc174e816e7e1bc24170f596e520c35ad65ba7c7cf5cc44a460f9a8a04195f488acd821a03563e4adcb1855eca8ce5d0e0e7dba3370c1150728dce1e689352988b4b4fcbba7764dd6798af9e40b4808e839ec05a2ea6dcd362d6b29891130e6d10de713d6bd2ac425b58a4a5d98281f0b5eca8462d61c86f81aefebfc821dc8ad161845d3a7ebac44052cea55f3d675d4f8c4016090ea19e450003e81eba08b6cd67883c0709b8da3693cc0302ae42f03eab254d28a39335b4fc833ec49c7bc63fce95c9892f87fd14da260eb623f08db296dc3a3c70e31807ada6c6ba42dafbbb66a10eb1f143b0213fb2e208125e6d50a9b2a252e04b2fa17ad8e2309e438bdd90924f6414de8e77b4c64dcfc95402518f6ee6d76058f807ab22b9439fe00a30a2d1acace6d535ef679675a49a1d3478ce97bc866eac4d80b38b9f5d88453ab60561dc67eb1b41519836882faba4024c3f3f95c276b433ec927de23506b8e1870946df23d5abf77de789708560f19ed0c773d76f40ea49c34d99f29f1cecb518bf19fcf7bb252ad720202467c022a4400894ed6ae9dc59ab418f7b4a6470eff546044b5fba8c1e3d126b49cf44857c9239fa6fae15de344e6b92fb126f3d61360a25d9fe1018c623089b9ff689388438f9467ed339800873182c9196f260e699de1f2cef4a41f514298bca16ca9c92358875adb6357c2611a2a463821dabad85725eaed3398b325447e6cd9a3b9bb05e9440a3980f4e9e9659820886ee6ec9fb9a36e5f135b9aac5abd335c94d2af822e1b9e9e6ad30846313715b4e2672ec8c8394c895f441575132f6a7a496c1d0709e970d11a573dd0abf73c0e2fa3b4791f7f7ba2624d45c102565a18cd4e3c49e2d3aa18e1182e7212d59d9e8df38f62727aa39697676a57b34178af6d9672081b38b12f8042834138f4e3814a1c8013d43a40da524f1b0e2c4ca2b57f0882b4752205c15c474ba26da35452c7ca690a4b15492ff4cd34f3d82c209389ad296faa842a2077873a790847f82341992b726fa7b0a820f8e5cdd1ca1c7b6afb5d126d9caa01c53c0d7802b868a23fb2b90e6f087f14578deec7c4c224d192171f167e10b3a5921138ca6472b225ec7a14039f34cdb2227f056440d7c90ad63dc940a2d0570857d15ba82cd5e463d9f9c26b80556d46d49ab623f2d4cf7e6a9448459c96894cc046d48d62d48f5b833b3bc34f5e4301db2750ad299749c748d35770cfb555fb239faa4acdf03314dabccff3bc33a50e19621d21972f2fccb60ec02f9d66f69878ab7ab12e83acf9a140e0bc907eaaa9d345d43f2540d85e2d7e05bd079950fd8c638d5a28ee2d31d5ba028ff6cf47488db88e674052053eb76e712788b57d1518fbd518631e4c7813f37d75d190ef2d199016b94e4c8d06155a65c46e1a57a0ec9705498fce636df527740144a33bdce1e2952874f02d1937b13b2fac7cf63df268d77dffdbb410df4ab3fb271541a1eb3b3f912f15dfd6180b5dba34efb9e208a0d15a9da4249201feb59f9939c1d223c6c70bc0906adcdc4032e48bc4214f1e59253951edd1dc15681cd2ccf84c2dae68cebe6001009147f0d29bf05076a1b24bb1ca2b5e5fad83b6c1370d2f5722496ade4a9d2d6cf594dacfd1a499b77fc315cd06f39f99066cba2ced91b5c909bf99be80d08556f9b59474caa78baa584caf3c368c7ca3ce94d2410eff13197d84bed250eae7183e232d8c5e38fd7e854d5cdb57fb42cd6875219c414ed1c659f7b0e3227d22abc0111670c37614f1409ee0793acd6672f457a0967560f6983285062cb2bd70a4b40841c2b01580b26fa10e7455b7a687b6503bdecea1e2780391cc602acd7e2220a5d3a9be7dfdfcc3da541c1c802ff415289975c0e98eaada97e62498c789ad1b3582428da46d4a755fce583896c68d7eee6d4803eaec7b53719a54d0a91f171d126083a20327a77c03f89843b61404b0734f1a359934a708e47252b0df84c85308043aaedd29c398c61908f75c57f0425be77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
