<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51afd3e2f70c6359786d57c83bc3786a97761656cf9840801eb75ab9812b4bf2beec5a243c6c3a734803380aea99b54503277bfa5098ccb7633edd0a9bd8c8cba4b7ea80a7f07f126c9587fcb9cceef765820b7408ff4c832eefb4329954683de0648b6db43882b1e54bf163d9a68d7054ed134a405c8c22b19558d963b6252df9a288dcf740a02f9d31afb6e04d4d5bf4b0634340e742f5c2384d2e273e23ebf8c8d7cd83cca8c4dbaf388c2cc1113ef685b0527ec8174c7c4d75f39fa12c62c30b79ee39a1b04f67d33b4d20b9453865c253205dd80e529c27723b217a910b1f53cc92cc6700937f444ab7e973f529d9405452f8d6baf287cc41c187c4fd7be0f184af508c54363435cb9bd48fb4a284193df90da5ef3be854e0130d31734569ccdf7b662b3ee59ae3bcfdd50ba76fe3806d34df37e11c8686d60c0c2036cdf43592fc2c97bc78a5f93a41bf8967b224eae2f279e26fda806745db6704e1cb2e7c19c638a4fec9edc3f58d3dbafac3be5dd28a5932ec59c7c9c5f36f23632285533d44ad2ee4d132722a0e5e8a7aee09435c93cab09827724f6c89097ad0585af298cb91d3dc5617961038605ed565b5625f7749d5af06d8f17c2305e66d2be870a325b92aabb29f76ce19eade8e5a5ed0a22f2a1e1b619ae1d227a44f524fb9dc85e195717115c2b2e213f1dfe39230efbf31639c68dd36ce3c79047f4297792806f05931b4c3db57116cfa6bd7794b2884ffab8e37c920798c7f1d04180feea57f80a97a8cc076ce1bf6d7f0acdd24e6f7348649b056318b37a41bd599dc7d0d7f3d79103aa074ab794bfda90417651128f780cd5666dae72927628103aa70d5007ea4408dea9ddc0403261108384ffc8d948e0ebe5e65427c5217de46df7f287924cabfece92dde0ba132bf2adcbceb976b8678ba35d58e6b48e65d81f6738da2abb2d5106d33b6513ad74e899630ca362d030062383257a723ef673abca41065daf2cb1cb0429b0ffacdb9beae0cd3240954a173473337abda0b66217540fb1302392e8159db32d2fa503c2863207944ef3cc0d377e53740e174b46b86704ae553d27cda4ab8761e990659ed2cef51665aa7dcbc74ea8ed34d6b4c16edd8295897ec5bc744929d30f6e645dbf424834e6188e78c1e0bcc83a6011c41797e05c268daf30322ac735deb0938f684521d67154544e9641cbd244770280d881dfd761ff4b1fae136a760d081fdcd30df6622f1366ddf4f3a9905738e41708fed44ea3c1dfb14729d8ef80b12df08a2f14a54d56b4fd5f9693768ffae63d4cfa73b156630d6e5e4d9b04220cb28ca736651940e69654bb3fa0e426f0707287f2ee097c697e0a01a0f5ef070342b5ae0a09c6a844d8e4f942458de97615ea59e4db3bf5aa6de0cad546e2731e5b087eadfbfd412a07cfc8c97ff3da6c04bbddf4579c8c93079ab82cfbdca88752db14812cb1bab4770a3ea2cd5cc58811e9f6e5db0c4ca0d79441fe4efa0a161d6559d5b56caa047e8c21750e1872a47f477f8f87ed815679461051caa99633f70a5203a673d25ab55df3afd051cd5ccf0a0e224b6020fa28ebcfadaa096eee7b283db66347eb625cdc1f70cc1ec5bbc943c529a4db2810a32d5c80c492cfe2ffeac3851f021968a9e400a5dbb4552eea878223b983e5b15d70e74ac04d27a92a8abd2d0366b0846486fe6c095cb9535e6368f758bc436372286b27ace4a60abb5a9d3f19d15b831e2b90cb328b54008acd429f250ed00b622512ff09a1dfa67467853864c8a2b6a58c9426089d3fae055a1c3defc2f1b3e2120ac2dbc884ae9dee73f40873f3d0fe89b1f572a478821dc6ce6a0e8f3d799e46a818ca1ae2a1687f5a9b778b592f61947dcbf26f23f422af58dd2cb0cca0d362072536e279661e0f73450b3890bde3f69e59136e9509de5207fd88544b3534b2f9887ed0ce9d7c4e8bc54efab088859dddfb2def437b5baf4f347c959633af69e14dc956b2bc44a9fcb6dc568c09e44a2be0039666abf87185d57090f22599aa18e097a36aac2a2945d8dd1730741d685b7c2441a445d7616559a23e4e5dc939a27f68e5bf81b2747f55ab6eb211ec77b2069ee9cf36d175012aa0e9567cee9558b5ef6d1b4deff0a68d76a8f67ca3893541c23965f31f52c456c09ab4d36dbad34a9d53098023cc9dd777d420ed57046eb98abacef531cb63cda9e6f8f8df4c84837d420b1eb2c9d652815d1bee3fca179351dce8d1bbe51584dc8d70b6679921cd0ee9a4aab50deb656104a0ec2f614ba10f8aa7e86eadf4e8225b329097129edce33ce89a3e74a561194b0e2371ffa917a79fed066b8b5e20634587464d60573ee9e1fd8e6fae756e478d154a966a3295199ce04991079d1f5fd23193b22b84c1d511420d225142eaaf3f467f0cdd717e0744ba5e7249c979dc76cab0f9f3a0eaf3cd1caee401a5c1b9124838db1af12c5ad67f84d4a3cde2e8cf44a7c942ba5223319be3b1f1714b2792d524c4baae5e1a4398980c50ebf7b14e2d0f7a24fee679585e676b9e607cb3162e26a6510c4936802b0105b90f9fe638699ade59a8442169a33b7517e76b9c38c303d976002c28496051c16867d5880e87d2cdf7de4a132cb7df8380cbe7b00991b35a12c321f311328dbdf7deb8d5bb4d23335528658cd8843927b35206cc3ef639751087dd7fba4116e4ab801828fc28181e54bc0f018e811a57ed5405f6f570b080eb4a7d68bee75351cf69ebcc945de19511f58b25be087bd2868d536fe33b4954b794dbc90a8aec08822081481978324e6b69f21d4cf6410581230b809f6bb778194f8cbec09ffee6b601a0446e0463519d66ea385755aa8dbef341f3f9ce010ace16d3cf43c52d0f85fcfc7bdd0e885826d181cbf4c9ac0cde9fa8217006e57a8d708f706d11b99da060e515c8257f9948c229c6c549b4941de10338a266f36fabbb602cb0f08be09760e0861fa119b37a9b5a9ef6b7201846b58df92300bc0f6261ee911a2a1f379ace700783661660f74be5ddacfa91e1a49f2e9ad6018c764312eff8caeeee8215e842145705f9313a5bd2844b244c9171eebf233405f4c779b0b14674d63749f8d7f41a9f9a9b4654d8ff0c8f2b2be9f9d864be07e7e08e102765137b22baee8fb42ea4c667efc1fc91ae9eb388058adb1092fb11051f658f7bfb55ddc5ba3e4f1cfb1fef0423e0654bb88e830f0e65093c4946795648bfd352082d7939aef79d9249cf9f907e35ad121cf332624768de775de1a8c23d3d99c12e8225f19e78df444880ce378490b123795c79d45d2dbba40784f11a857ebfa55af8b6e10960299336c915dbee70e2711d5e420dce410f066c3a452cbd7db396bf4f6dac7d8da0e92f82ce7ab7d191f36df995a362c9e4d883f08ce72f22613b41005ecfbb5375958271fa695a49189fd8aa7a368ee3833a5a14442982ec7918b081aa6a0a2689c1d244eed891eb7fab1721170513478499780b6be3032056abb4b42039e46e4fe1c997008161ffb7bb793d4163da057786708571080e78d7b90fa347c2c14da5b6a984658c6b9602c8d95dab4d886af0a2deb0256404f7e0668095ebf820f398564a489faceffb1c04c257306ea446da914b5f915fa58ef338dcac10261a11b4962f7b662e85a11113dbe49b3ec13766684508bb0af756ee503f73bfd4971a3093d2e281a741e83b1acbd4890cac9a7fbae5cbf5420292e6e5883b05925da2a7d370658bcd94b0198abc9201064fda5a0e8012b8f36439f2366f670bb0f24e577f551e8c6666f814124fce1e4c41e30653a38ff41aaabfac12dcf3a8fa83f7714706182568322b20db78fb456efb91b2d0d693c725d854b02ae2a347724c8668fe6d5a3f6c201fb6f17a35f533c5a5b35f522a9ea81f0497723e09ebd51e56dbd097a346cf1f0e9d60c00a98336d71efdbe866da71319b98f47c48e2333ab80981695f4ccdd9bb760dec94ed069b8bb238098c286f409776d62f75f68707d1f1362fa1114b5b0cbee6042de781023d61b94658536275379e22856d34336287d419f093785471678f6a69a3d4ad0c78b896c5971c20ba18f2375c17fa52e830e0d47bf23d6a3ea074cc7a87873872dbd516e25a55905036e717caf60b352e539ddb11814fa482de4db50d813a1f4082f851a1d874bd37aa0382b244ea7067743b00f9ba81b2fb8275bd7aac3c6999de2888943513f30e15eb64cb0b988ce71ae6b2340092e824d5459854cebefc27fc567ac9c77331539b778912ac698acc9296b71764d8615935c052a65ced12641bd135b1aa78e009cc98e18442c0d4468d7237062ef0da8dfac4c75b47e4cc4c646d7740943514893c5d3027307e3e60941feecceec9a5b5f1468a84fbed12d3f11351a5482eee3bee53fbd3ad73dfa87498c4573dc774c9ec1d94cca3561b6c1e281a58aa806092ac9c094ffc7f33d6bc94f45726f1b77c90b5bbecb920d4f64978562cefab802cb60dff3631478365e94d4988d755a7ac2be3d672f72a5098dc631d7eebee66e07dc4aadefbdcf67ff846271c4821466a907c0688963e3b519056183a7216af8b47d737a104dab1eb71fdc2a6d72011149b20970a386c5bca10cf5bd3387321a978707f94d8a556595d8c5e529f7c012fb10c37672e558851338300dbf77fbc18dc8e836a77fd7ab055f108d55a31a971589e12432a91c17633b13f5ebebc51ca78efa143b3cd24ef50ec525609d385feb55abd37006439b2f6441067d8b469c5b01365458f52b3f260aecb080cb83735169b8d14a9ee019ce471359c51bc33e4a908576aa70a07e0e3545e3435b961c0a822eb07ffddc0b06aed766c4a910045153134760a13d306aafb0579a62a07beb61b80d88994230aead29d274d463dd11a7f8c53fcf2fc3c6579b9a75b17a0aef575e60df73f96042f95fd15c146e403052373be1729d31bc821690ba82f4b9f90924e6b8aafd8c5ad3f4188d69746f5a2b05904b5bba45e918f169842eefadb478a28036c2e02b47b4e45cc08d8aa23f2366264e5a72feb87bcaa4cf0b2f73431b37de1c2ee6058b175f4bd4a0555a87f1f9a677d1bf151eaa990a2182a1e2ca4f17be2098472bfa9f13664bb2e9e9f491ae29762331432dc9c36090c6ee25206178194c742c32e7b81e40bc08accbda7a621b41cedcb4b4e28098fdbf4dd05455a74507037aedf5c51cdbe3599a445a836659676569b5240d65ff44124736bd6c250036511f32bb8df9bd523675d98a9851d32cc6a17be397703e1c4720c24539631b7367e81a78acab397cb7543f40515ee61ad2fc36a53c67eda8b7ce00f34761fe2f7f06853fa5a6d57882dba544772e44b758a5cba46b81ef63ca7a80750231a90ffd8bae61bb967665dd295127a6b63b21c6905ded81f564073bea7edfde914e878849029f297cf7f9b2888f45f02d33f3bddf317fd8f9287caab7a22f4095d0cdfec4423a6fc3a71d19f96660c7de0939ce29ef0b1381a071ce4810dcea4074c4e499721974d66f5bda5d3a79eb0ea9350582baf6b285c68e4c96d69bac4a2e2ffd979509fa68f8059605ca520ff481bfd1c5317def15a1bd65c5dded09b01ca8dae59046e94bca06d09f991e0d18dac65bdafd4f10b7d633e2e2f3790806708985734f58e37ff04e2c11dedfce8013197e961b8fa40d4990d62efac32eed3db1db5900a645e770782fa131cf14146e50a74c15bc4bdc191a91aef76c12fef623345d44e205db96022ddd52bdd7054f6d54f084b62cd7020532dd04d097cd713c39d270d0ab44ee26ab27c2daa81a376cd61f602e673901314cf19576575f39a95cb067c50d5d1ef11036d388f11964ba9bc396433cb28bf4e70ffd93c67e6e4437de93fa41a58350aefe1d61b83f249ed356d15df2edd5ee3c5099ac557d22082737ee59195f77ffa3c9c22c818a7b0019697c4cf116f6578185e99d7df755cb0838f179a74b595b7dcb8a982e16667058481ec9ddd0b7f557fc2e4b39204ac1bc21352143804785ae3149cc8ee99e67c7df024019ff0261dd6d7115e354131b0ee5290ca814cae0fff6fbd5c791df657a5deb8150dfaa84ab494e5ac51a81f6bbcdfbc72e72cf5ba0a7a35a09b4a8f60466519484815d4152c47157700a68ff9c8252b83c886cb233a0ff49c6edcb983800cf3ab291c9ae699be3f831cfc1128dc241bdaea5848d28cb96bfbde3ea62624d1e6e76054b7ade20741f5816cb5f825fcf4760e3b9f559270b79b48137b43f80f826e35c662e66ba4d711976684f8416586eb09d236f188baefd20e7a4acb658db4334370d5ef7b1ed376895822e3f75640c306230abfe145d454c004b9b9b0dc3945e5cdbf0c799d48cbd060bf10bd77bb4dea510e23eaacabede2926c73a984a89dc66247f47d2863e662fcb5008734161fc3e9764c711bc1e740d3eee8eec58f4eb4c38f6e4b42d8522688039bab496d8b1fa213a85c5fe18141da6e23fc86a56f642954a4da40070eed44c1cfb55c10fb69c27c1fbd39d9368720a3859aba60512a1c43abdacb87c98a6f2494a53f471ae548c32a3ab071ffff268dccad9c81f4933b3757febc1f7db0fc3d1f4392e32a069108d0764ac204018f0502f5a3939b3e30082002f064d781d7980124acd98303e1c7aee66f3289aab228fba34a8bfe89d56af54459d31c86b1f86fc677e9c978e79608feb31ede1eb663f746211975d0f58fd39b68388914db752107d35442fe56a6a54cd81a41a638cfc869b6ec13a86a77e6ce981b0c88b753974b5290ed3993261c8e0cd94127c4c60d4114e3051a9ac388b47504e85288fdea2fa11af18358a534cf3f683af025ab0cea8c9f541e713893312636b4ccd00af5db9f1826a29998f0f83ec2f7bb4ffc3162b8badab00801c7649bdabbff6af1b33317de220d54e8391bf9f60bd50171781bef1b60839b50fbe5f60afe69257becc9ed3e0496fe701474acb44c5869d6557d0903db33be7e9d3115f06fb6060676bad16aeeb17cd5101c54da4abf62539a975d5e3bc28ff49fa5161fb22e310d887d178c14e1f2cf85920ecf3bd692015d1c601ba46a562262f49802c1226fdf8b69833660802915eb8d19783583855d0b92a6f2c501a09deb5e0c7e8cb7430d4707005cf4493f656d3b05bbd5493782ac8558a2e22ecc17735ce1836e62e1c5d52374f5e4a8c7113cc0c7146d05d6c97086e18a1efd22196d407c28d73c0997f1eb72dfcf442cf7f05bb707ecdff78bece7b404974a96e28eb458a12a735b128e49ca17056564228708a776d2e2c50b69b4c175240b8f36fe75c884bf7175dea8418150fc6cbd033ba9db751568293724a6a9202a9df660859fa3618aad907af598013b023c7dd7a810139b0d627aae7905aeb8269ea7f93015746639cc5d48e7140abcc3b50aa0b0db5cb7b16eb6a2efa1cb90c0b85ed6f10c8f3ff55712d925ec9520ea11d50bb1afa36dfc52b34d7a9b7044af5c1d62952f992ddfd9409279eb27726d68a9f6809682d33f06bee2469eb9b2f5b4cdb56cd3f9dec30076de63d7e715f6affa5b9a6a6e5f9339546e90c08af451f2cd4c9859bb0dbd558705ab65054e5c46e224182637b7b98bf6892d17910f81782eae928db280a7d6fdab60dd9cea9ad4515a9c9ed4251dad72def9e4c65d205b0512546b9f48fb20923b2ed90105e654dee84940f681e49df9fa9442525bfb0b1fe6a33cb64d76a704439ef47c2d42642768b4407ca900920368cf325a606d1ea53c035f9a9f322cdebc29d5ccc60508be5260260b1086b7f7def1449ea68a6509bcd22109e8d54866b273de1b3ea13f2c509768e99bfe63414a0165294b8faf7d0031df3cf075fc2124bbeee94030b036788e61ba5a779072d15f15f77ed375aef5ab8a51288167169bc3d38989fd4e5c1fdbd0768312b6b3269e6f21fdd253f9634dd1965857cfbaf1d5eabe460855080dc0bd917b59b94e60310266afebde051e3b58bf9494b73f19e394df5c74994c8e205160f4737997713db2d0ccad06f1689382ee720a2503bb9a85f90a8166afb2adb2c76878a6ac52bf60b4c00a51d063dc8b06c48bf53c32466d4c4f1b1401a26f5a27caeaa7f4220e7b3e20a4be6bcdeb2e6ef5b1cfedf6d65f1a5188e3e7c439cf4ae0c358ec0ee81a69d092295563272ac102b383c58d23cac17dceac59dfcc749ba0a2cd839410f868f3daffdfc6bb9d3840de853111b5f3828ab61e3234d759f2c5c60403eba3df1be0a407df5c6bf8849fb66d2f46109fb5c789cb7afe143903ab2cab04a53a0fc695d43b18a539f39c481c844aac6ac926978c4917e2d7f61fd1795ab42eeb226b05a670d77456ac74e054b2b7b4e54431884adcb5ac49080116ca7623e0a4f5d3b4135eedf98d78909e4a8ad8570fa1ec7ff073b6419d648a6ad948ea62e5adf7a2b3ef2d54b56f25855ea1c4a2ae637e909cca7ce9cc4477c20be717ec77b7ace29a0e474d0c0415a71e7c2eac0e2c83e2ef84a49d27c6995c13a70476fbcdd830120801726394ef137eb94a8a76eff99d8326405475417d2dfb113c0866b90e6b9314ab78ef8ffd3b8000243ec0726f2c6d2375e78d58e8c54279231121b8d222cd1c684ecf8adf549b90dc0db2af127b775c7e84d115f9d538013c92445f3d9dd7bc08a719e949407b6989b02b893d8a823443e9d2ddbbc6d2fdcff40bb19b55381f1b50613336301f98985303f293fc0ccb3354051c15774f7199eeff5492d7abe464bf6c9c7a1fdecc0ab4284415a81b456f13c208b9d35e8484e50a00c1b46c072ba9bad46f57f31a55e257ff9cfb3c303bb4cc923dba909ca7dc4e7fcd4b63e135bd919eb5b4ecd9862c0c50e37855825f9571248b55d03715a2d022f92f5b4d57c2b62b2b5795f4cfa5150c19516b5b2aff71485d6dcabfc0b31e40c6f108805c1a3566c3229c1a18155da2230ebc87ff497dc7c59dfbf8e40668e9da09af012ebcd890112c07d5b2ff96067bf27ce99e2b8081b91ccecbab923d3341bc7a951b05680c4096da1837da0e5b9f7a3f1ac71a8d3ec25e080a57fd4c1e07080a18e82fa49d2f6db267db11dbc84e7c0b2991fd114369d8c9d83761bb02fe362013ab48a566dadc799118618832ddc601a53850c859fbb3af7cc31f1151b4c7f30f090704265717ab6220671c5cadcf7c97c923ae32b4b56991002c5eb128ffd94942d627c94b9b215c4f86bcd2de48a681bd143f0354e67bd845104d9a5e3fd112cb4914d04a6a9d12e89be217a9408e8f566468341ec061d53e90511a2e3a3b39ce9daa10e6dacb2661fae9a1e4221408a985f78da9802122285e600abb2f541307a2b2594be4b9ae30a01b19782f0b02ff44da1446da79c3c6fa2359d11917f2beebaf6239ad56178edbc61e3adb4c15042819e144948b1d3c5f86e91fa10b86b3ac69d5edf8218cc64bfca8a6634ab36f50e6396757c6e71648ec9d6cd318a6bfd5e0ed3a3411b1040b35356c11d02f15869c5fd49c291186bea11969c85af5d7d54b61c37195417c3ad31fb527d0807054dddbe0af4f95d4d968cf6a324bb5ee79ffb50a815287229e2bc36bb212066f3ab63bf3977fd61cf123acee6d322ce90257e90909099de51320cf95658f1da838366785e9ebecc30b77cefc8220906585ded20ccd3a6525e52664e2286b6ed7dc4770030e28417e5003cd2d910f2120d2054fa673b2f3dc84f3be8008702db2b6f0d580d6b3251abadff0eb40950f06799f3585e69622e4acc764c3b216be8267f685de19f2976412c4ac71a3a43882bbfdfa5f88211015330076a1150a052bd40b15e64cccf3103bf4cfc457a7d58e677e9200b6988690991b5026d27afb233619ed83281682d30c979b11a5045f6571b67f78edceebcd81b62ce4ebe3b98d0520b216c89b7a66c8412ced5a919e11d264a787257e0b21ea32ba09616c7c1e233997f093198ec9241b66675dca20825bb5b00301d19a21f0bc7740808747e8449f6e86e7e9dc24e4e500c8f4f620d382c620e8e9428e8fedec3e74b119ed5d53585803104bdefe215b1c3b9a3f7ca72f6e2e5158602bf1c1f091920ac824efd40018374fbb17a8a8c07780e97fe60723831617f444ff8fa5ecb6b7d4ad187e5eb0ee18522d32b353c3e8b7f01d415378e762c0508853abdfcf7f70a6731416da9f025689bbd6dd241ee21d3609e38c82d1a285745c55755f40e0475810b852bdef5b5e17b2240ede432fb88c38b27a984b4b011b6db6327f992c4deb4cb712bd62e4df6c8f9e9ecbb1e29d6c7f35397c8da3364eaafd0dc2d901a9c968ae5c218c7488fb35d3a27f19cce4ea6adf473b3047e10d2806a6fa277dbe8a4122482269f7c661efffd38e49482eef83358b6fc7807d41639a98a679226ecc7c3aa61d45489d1a1a9a22bc88c991e0893b91edfccca3733487fc41aeb7c936d81d889de8e75917432aa4f32636d34577f92f879104c73e37d413eda8d2ac0d55a164693165dc8b954e09d183ab1e2d487098becdfc4d5503a92f15351948d4b0d8899f107b99a65def0908a376a3e473ef79fb085021607dc696bfba26eb6ad39a0aa8c3a6b68b2fa60a71ab92d16b1c455bd71b286eee60f31b4fcb960207c3a9719d0fdf7dfbf7eddac5c9bd7cc0e3f8f9aa08f4f2daeab67c224c44c09b5c136ace5008120ebe29b9a5e33feeeb846d6d64e6e32ee5b8ffd5d1921792d0672fa7560bf7d43d971f603c42ca3099142fb9ffbc4522ddd7ec126db2fc8083032f28612c771c66d879938bb2fb19ea0acae70b907b60ef9dbdd300d8d68900a263f971639121521fce893ec783a5a7760a404d86065c6c6a375b7b23eba1cd27559bd4044a637c2843640b8f745e9375aaf4a0afdd48459f7e47f5f054c806a6e5fc224c946d8383ad8b8ead7d723c619f1559ea88e7d97b8cfa46005cde0baefb6f3150809fe77c733f22b1c2070e623d16dfdabdbf7a9b1b2e670fd0de96d1961476786b64c8e5856da30644ea395624bb94f55d8ca6776c8cc3382ef951389c89348ef7333a7a3c179989a79d8e757e8a7f775044e5ac433d5ba8e2ddbfce487f51de58fdcfaf2634e64e561712f554bb4e6f9015102ce4ca4dc74bce9cc28e61d3c34e4875e5cabcf77dfd505144905122fd81733642ca4bddb91abd455418b7d5f45f30a82a0c2471995a62c99cf137462fc519667fc0210d4d5afb321ef36d9c60f2294b179fe48e134b11244f98c09969097ce5de45db41fabe1a5ce643a21b7d0b5606302add4fac6b1c039aeebd6b6065466784d7c925c7aadae21be0a96c6cc2585e85e3648355f9491c023966b3384192ac59d1055647c2cea7030e04800e33546f3db80d9d94729bcbe25d47968e71e3e72d25281dce9e867a059a41eef43ef3468df54a95c228a0fc175e563954781923d77501516a3f6b68bcd0b478b8f1e9a1aeec8743f026da28696100ef71d24523e59199f3003c7f9472cb878b7a1a5ffa8e70cdb7413064785d3bd5085fd9a72062d61596e82e4e042e9cb4a6f326a31d16b042d0959c51d7ee22ab0e32c0d6fdf752ab7f04238e2360bcbb205c6fbdfa1134fa2e683e65fc2be5872d872f5b5b8af8ff1b5bf70dc9e3ecdafdf53d3cc470f47873f4a566fb4cbaf52d2506d0dc1ca324d5b0b30c475dcde5a63bce0e3862fa485a9775ba3cb4d5fa38321f34d401f8bb05bd17b53ae98f83f3c5600c7900ac5bdd594bb9fdaacdbed4d0d85cce6d17dc8178dac27100803700dbe626ae211624022d232d09dd4816605b6c39683b58834114b6364c2dc7e7c862a68d6dc40845c8f5d9c35dcfb34b5cadf781734e8ab0b1936b0eba0b98d2c8a63ac47e041f5387280d426655ea87908e86d1af80f3bba0c271426ed37f236c5c076ee0f6abadbc9893a4ba480464243e286701cebede5c05fabac4476c1d2843505562dd0f28a6cec1fec96753f807f2de6cd926b395772c05223a9dda17a99e1ea8d7812c720af8bb92b1aee14b23f53e24329bb0736b2577013c5e300ba42d0428b538e2f33217aaf238513e5f1b457a649191b86373a1cdfe3583f2bfde124db667cc109f5dc80e4e8b7ae8a8236b26fe81a747b846b36dae2dbaa7b8070c0d982642cd54825d1f071fa36ddd1e23bd013f70905204b381d008dbe7a16e6531a91abab717335386d7480c30081aa81e41db00621ae1fa49ffac913fae12ebf849526ac08ee99d2b8ce8bfca8d632bc834c90e1c9bee7b0d52a963ae0a3a7c129d83a4038c52ed06aaacc9cdbdee31a03b8a482c72d648c3bcd00f11e4ec57d21ec982956c20d07c0ddd12f60cf495e247c40516a91fbe0c5546cc8b56015da9cab7a85da59ac50a4e00df8e0c40c4c9919ac0de90994b9a1bb115bb463ec955bcd817fcae39a5610b80a2accb531828476fccc5142d507ed303d17d241750a2b8d5d2e80c2dc687c22998d552125c9c836b433e50846c27f8cba7678b1d87c66ba00cb1b598e5546230fdce9b4ce158c5642c0ade850126b74998f861e21121c0e68a75a38fd342a55fdbeb97c5a1383a6e6158d0ba6c1bd46bf2008cb7319d3cffbd0f4fabd0c58b0e4491c7e22fb7c6e462039c8b533360461bb87138ba3af9bc1b3508d45942586082afa7f361d636f61614c25f2de056c80bbd4220899ae456bcc04ff3fc65ee96264a83c9269a197b91dfd5e5b68544c239eb66be5bef276d403a0236709a4f53268c1983b57ed5f4eeb8b97205bc24067b892466a11b223c2d7fd372884f891326db2cde31197c13eda5d9f77e13c1fff3d4033c6c8660616d2282c33fb6ed2c6199d7cd5efd098885a14775c9f3d7b0e909004054b4701598aac1d068c926544b653b468aedaaf0a18077d963932e1323533c74224aad770d6458e6c23cf76b7212d71eefbde346c770dc96d28f0f9f5c04b11ca3496ea08719c8bc5eeb1d7045bc490d9c30c66075287acc2f93c9e39d80171141cc4d053220bcba0f423526b496e15ef60be9eebbf82283c478084619c76b62b30cb11714ce8cbd27cc961d41e2db1845da3b7c176986c9f13a20e999c69c5f9244f93355a55ce54713a18618170380d31f903525017cf29b8f415ab968326fbefd01ead55f4cf8a216a4537a3d562a64ee56e579255080a6f0ec04b157dd394477642797a71c79dbec5e002ba5a58b0e950d1e9a215794b1298fd50a588deec9c170613dc94090c8841d5b0e814bac6f4ed1d36a0fe233a49c1673467815ce4ddee7dd55a26f43ee5973fd72b0bf425777e51c6a0f47b56e316eda12ccbae759174437332f9718552b6216d908e42eb5a15d3aa910776729de5b5443a4b0da0dd76815a0420ab3be11e3a81b7cd4649c12ae68f314f3576cb525ed32199702baad622e1797d8d5320b9b545aa791dfe1871ac6ecaad0fd85de9c5f2277c1eb92db70081e2c869fbd8bbb7486030dbb0168ab3378510ce4e45b35b2cfb26533babd857ae5743dc92d43aac5247b19348b4dabb899f2b4e25f2677eb6a2713aed4693a22d31822a999d231aed43f2803bf5a93d0cc45b7098b3dac2bb30eea9d51aca66de9636e3f0643831a2037ff94030c95a9a637ed6f97b37031d417703b4d8b364467267b6fb85b1601cf12f8a064b717ac63ba0ed06628c17a3b14d0a917679e9ecfa3228035fdda802781c776c0b9474ceaf80c7c8c7b5a8d28e66bb19d39c6be1fdb7d11cb95e8fa7274feca14b94369496ba8cb2979c2e94364e24849e9adace234a0e6e755ead360f85f22f5c54bb4416ff0679bbba152bd29e71087f1d4015b11bffdded30ec3b02a9e33070f21e5b4c922eff361b1219b53ffddbe0e2e79b5286534fec016c0e85daaee7c27a81f3f9ad29c7c045c871cfdd0c09fe58581309370c73593d4e618831e0acd5283a79894acaf684e7ef4c2fd6657c556bcf88ceb732c6a4263e1a2644821a2512b2e845e07fc544653d4b965ce06dd53e88ca597038bc73b838930959e70bd0cbc6ebb91c1dc40dd2fd548717e34e858d5cc3cd759dc408c21ab1eb80a757aebf854385f4148ad44d2183a364ea1e1d294f29fa01813cc124f8b4e5abb47f60bb6de2cf835166625e279521d7ff3213b4f5667075d8d68ebca4c6fd70534b4b74e7b6e0378e3269dcd1b5e5d6aab8f156622709c544925bae968b8af80554cf4d50c60c19979ae8e39d4f9e368e40649ead31a3cfe1ffc121473eb7b9548c605062cd9093eb4df79bbe4135d82c95f72b0057f953c87c06ffc3e264941e41074915a910989a0750b163711bd16dfc4b2499cc9a391efceee3cb4ba3e5eb447813f25a51c16b90d214ef819ead800bf34ab418b60e336829327f834f33fd9e4006abeb9c9f6b9da2601272a4dd17442da00ed69012fb00688a3d839cb1e6ad4db7a0f270d31db992907073a3aa39fb4f5bf7db231fb45df62d2b3f4c10b696c7d699202821b162466fac1dbc7cf4c705f66292016fce7f44f03e32ab841f2b254fada8ecd32ae5d0c1baa1ea107ada84cd8fe60c1db80942d14e7b63a99b806fd37cadd33cc4aecfc29ef1ed0c6b573e96f3ce5d4c7fa2b38b2d88619eb4fa026c0149586c3b53092051cfe44269a3b3eeee07e65ecbd5d66185fa3d77af9f4bae5653fef501411f78e64e91ae4894a3f080de708f89ed1f9b917ada260b2abd6e15024cbf7cae7dbf4b8f035f55417eeaa0ed35bb17d7af3c096826669560e9c4d4972df80831367f09324db88ff9fcb119ac5ac5238b8d4798cdec7c0e0649f746d9688a1e98f7cde6e0f7e7103c86a8c1a156caca722319dff5ea6a962f2281865dd6c8f2a1ac16faaa552b06c1aaee286011f65eeaadeca855626db631cdbe3edcbabb584032c0bf19e8bf55a58ba3acb16c256d32aff22b491c84178d4bb5b9f9c789c95b1c58c0baba96db772c9d563c3648e89f3ad9212c53d808226888397973711259185334d24d1ffe1179db14a18919957ab145cb3d2a55284c78e2349a24b155b3ea6706599d5d9dfa3dbbc9157342ab9e98d9725853bf22de130f8d48da4475feb472b06c159a05817e10407cf972e445ad7113cff281b3fe4d480e6db0d224b025a6f73c0a7f75e4d6e5a5d66382ec1a5ba9a52cdc71b0f85733dc4efff6c8a370ed8bf3166df66cb3c697505e4d1ba2777617379b6934c85f8474ed03b6b2e2698cefe95fd870a0976556e92a75ab5196d200061a080b256069fc46128d65b4c2cba59b948a961d6fa0471011032b36816a343ae46a1c4224bd1b57821d62e65ce0ea6651b5ddf39f6820076b7eeb5a45b1db53acb2f31c2117370aa1e7a03728c7ab506480049a25d2252449de9120c9037bb77da8e753635ff71fb36cdba8625910826dca206252eb2278e15e4a2505ef62a13431ea035071d0f2910612cc2e41fc36c5a89b497c8e2ee82d964a429b57ed70597293b973bccad27294e6c70694c13910d06b7df0ab7b9d01ba0615f0bde086d5a170ca1b7f1ff9805fef278ab5dd010242f0e49d163d394ecb161577ca3d2c414959853d32de89e8ea8105b3084c936b5bee57979f37cecae3b1167977288964f62b6ce0eac563d7e5293d44a3622de02a7c4885ba2914146ae168bdb61654448734c55cd69aefc03ee534d5dad2c36db0b9a5337d4a579c6702474978f265a64b9352915b89b1e46ab85cabbb2497c14ecdf2557ccfe8eef97f1f883b8b8c4ae2fce162b88f49e60d841e01090d30ceaed15eee9824ba6149058341c3fcb1c097c0aa2e59febd548c1d641c2f3fb68bcda99e623198cdcef8eddeba4476da0c0f09f4d964788c145a8d9fad44036b4d302148e7a10247055b57e6c72eec9a588fb83bbea1edcab5bdfe8553e4c3e3c8d8ab3d17fb617aeb1840dc0374b187cb793c2334afa5af2b9f4afbb85f581bcf91b84d2e1ed3e4d257ee27c5d49a224252a46d7cfd55a3f5687c0934f21c178f6f538b948b82cc6570c34a8707033590822a10e6b1c1870a79e4a32f7813d7d339257bcf4e121102cceec80af3fb60f104a7f2d9bf7381e8e390020ccba4a68a883360e15421d39bb2e32946c89b5a67f2f1ba2d8c66ab0a0cacdcd76fab3c7ebbc4e66025480b67f6ee2a593c9b7a1d718ea70661c2cc6129e30f0b2e87cf68d2c9f27e30815d750c990d2fd3f850d1575baa0e5d33c18e965d310be69e55bfef885dd7be56a240b3dd38c82644fb58c3d31f5bc7c2790af2c9a2a5c62425b20449398a796831431a7cd2f630c8d0b8006f00bb04a551c1687a6af829a00eec3b1b4e96a3f2f8b42c05b34aebc805fe1f7f5848d8c4528f2bbc0c56284af43b02863b834cb1f2b4a0d338715cd6c68d3373dfcaf9cf1b13be021b0baa197b5ddd0273aed7fea0692187db36f5da2e8d8922286c68e8e828d4a831cdfd0a940701445d0bc510cf12189a6851ee0a998d2b5e246a9c0246dfac7be65c99bd810f5e77a30d7373004f64d3b5481cc07e86775f9f4f434fdbb067bb929153e16ccda992bd382b56f30086245d9963243388b6d351d349df8be817aad9bd4611bd5930f7ca0bcc920e4d59bb54c48688ea71fc143317119ba14285042d790ab33945eea0955e430430247c5fdab28b89f7f8a83dca851ab9599150ec0954b798a2687f8e1d19c1b4f129fdc654aedfaf89ea701f20e30d4ab4dbd21c9514882c90e27750e477791152a418bc2cd79d89ddd307f08a4e7751c76e49397e15752d15439185a3b582153e74d5c401e2a75755c1dc2a0e72a389eb1be272d6037b99b8cd94a1c2b5a192f7f23cacd421c70685a495e4d9beca9129a83a995d484b845231f7be6168d9f191f4212b09a78c1fb9fd27e6f6e381ddd9eaa159d95147edf39a5e98255bb9991934f9cc6509639337786fc97d85dae582bcbc652d107e28bab2cb662e14297b0d05332404a2c8cec03d7096e0dd25382b806ece0d5c278966978d8aba856af0d516058bd6041dba8c9b39f8ba1866ceb2c00ccdc10786faece44b3eb888cd6412700e536ffb5d567c499879e85ad480a082d6fee01769b7e5266379396fce3bdccb6185756267d3aae0091272963f2d1e13b8e452fc5433193571d916c208d9a3cbfbc6a0ff9468e3c2bc587174c51e2a34adf6d56913ca1b6bb99396281ef6fa105643d4dbe667d38dfb7da2f4f400a105e3f72ee35c5d22127bd2a28117dddbe42604408000b12a4acda0779dc8fd5a4b1a5fa16224011e6a18f0b3eaed07c4bc6188132e673658c45d347275acec6955790196f342215eb829c4dd852bb24b7e9e3af79b214ca755b629698baeb73d127b8295ffa2c7f48e266b8dc429e9f6b2aa0cc97933fee143d25b5beba7c7e29731ddfd6d4f3c3c84f737177c8733db7581c0aae4a718cf7be6c50d77d63e56c18396a8c72fd5f1480aa990bc7cf30682326e4c4c8a152c84327961a3b9eda93a1693fcf71bd1260045bd5ace942ff5db9772aa6046b9fbb8e89b5e426f24f7218e5b17094ea4ebf85a56a23f2c5e66e7721fbbd45db603bf41ecc61d47ac3219b4ea042408eaeaa16733cea33f619a81c4fb147c1ec16b73ba81432da09e7c9999e98fb34f6d4243417c739ec101f812a89faaae235a1c04edb0d50619c018e483efdbf13dd96c2d067ce112e0478f9724fe273a164b598d7bc3c3aa7c8cdc84796f4dc7a55ce70f3a2e48e61ad8d5d460098c5b3345a3b784affe7b3369e1266d0e6cdf2537d714699a88f2ca7da1be7c169f5793607ee9a052efdaea2a5a1896551db260d8725134c303da65e4a587ec226ec96fe2b2f193ed37602dd70fc4e0709e4f7ba49c692845ca1219b6d81245cb3b12c0f89bd23621cb5f4c7b084852c90010fe28ce57cf56322324799a6e6ce5886c82f7fc57830214a4a28f9d0fa625275b91ae2ab0544fa5db85c53dc38ab305bfad193196f79417ad96ddb6d0a0f0053dfa3a909e59f4b426c701cf0888bdd60cedb55b79593a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
