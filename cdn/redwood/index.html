<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"434a77e15de369285ebc25590c25b70443f1ed42a6a4e5c22eef5cab8bddc64e712ee9051f3e674f6be598a5134b7b2f4b37a77c26c41b90479373ef6c6979646aed8b8c60e036c9c542fced8aeec336790db2be4a5edc83e4e32706a577d8ab1848b3b5b152ed6413ba64f14091f35b5c6dde5769fcf5703ce8a9f96d23d61c4164410518a486cc6a86d7bf8f6ef50dfb0455a259dfd8fdc19487f6e621778254e2b6347aafce2b7df6e1417d81e995c2725fcc0d60a567e26d3fe7147d37fe2d2083fa59642a7528992a9634bc9637e1a071e311240fd92c136f668284fba6202ecb924c007006978e5b9fc0af6bc8fd638ec6709a96a6e44c1deae09dacf95ea631316f3b9083e797f0ed0f0854171175484bd1a8aa5bc1e7f90a1f9648f7cc4aa790b6f6e9bab40a35e6de9a03817eaa8e3f4f693b3b00a9ab716a1d4f443581a4652d1c770b78d75c93a9c6c6ebd8774da90e9af282d7edf3a5da161360a01f2b8cdf2d91a451292b947a5822f598b87f3977ce391293f47a47b43a4c673da4d042580ddd806a9e2b1f4458c2b9e0eeefcbe3a5eb718a6d1a2f9824deaaa800ad31088a8305673b30bd8ddff56d7cde3892c0c9f16305328cb37b622a76380a7aad431bf327aeefd1953fbfe2f8ade81dcbec0582e7863832b9a05465dc3b10e89ac82a899a7c3c03b79ce1bb24c08eafeec8ecb1ace6ec4cd9c024132a7d5b4c024ebebc535b0b4723939f9ee2ed620850c17d619bd45cada9ec7a5b03f1abc1b437b1f097d8f8bcd6e65b9b9991027857963ecd41662ecff64913fa9982c56f998245fa5ccb05cc840047fd69016790e84770a888df2fa7d251f78d3be9afc1997a92a784ef88cea9bf3043bc429f861b47fa1462232efb4cf9f4fbff4a7984cc8fcadf1e6e01a998447b208dec722efd2e6cbaf7b30166988a4043936470ee5fe455797287fe038c2456bfbff042e204b74a14a17430626e0a5d7be4939204e80e6be293452c9132ca5651797dccfd3d9d02d550f46154a76e294b4146e3c12b5c733498965433af7a66ba86401f01229de8a3a54a18f13b8a15d479f1a896d7e9002d67f11122f23c514ff16d75834cf333be6df795127e546d22a1487c8a696ab7b98a73fbc81dc08d2e418757bc81c2b3c41d51367068c26c3cf79287abf65022def7730444e838378504fb39a1838eff5fb7ab2f523b8fe05914e414adbdf2044b2c2cdee8e29473f6ce3d822d8bc97a49a0ac398eb21c0b88139378a315eec34d11e48c2eb97fad15e360bd9d751b898c68a828a56dd9ab87779f114c9c97c169d446fe21f4d5f0b55b6b527c70ff4b93cf1db254dc03890149ceba74d80a439312d1f8309c681083c904f0a384a1c4b618499f6ce5a9704463e6ab218a49500f12f2c2c81e80ca7a90752ba57667e92538ae1c81d6cc0ad9688718cb8a7fe4072831bd1acf8668ed1a8e89f42ec21e86cb6196ce3bdaa99327ec5e4c3bc4fcf634eb501d9c58b32a81a8a3ea9cffe9671892dc4a72fb70439a29f7ca297ba9c086b8e7446c087e04b671568e4d8893e4b80c65b1743ffbb1d00085461fea072c441e935f05b40bb07a09cb1862e1a3bef7cef830432011e4d12d104950a818798dd92d3a0bce9c09e46753d1e40b08d3d0203e4926406b56e4dadcca6f4967310ec2b47f3065672bf095db008b2023ba1e331492515f3e6bdeb1243aec31de4c8722ec22c768cdeb1ba8c64fbaa4dc6d216bdf1c889be7243921d2ad4b4a011d50c7df303d8dd04daf0b1341e973aea4a6135f0b020354b5eccdf14a86ea92b9af5238c64770de91ff1aefb6a96df75f60a6eea90c265ca697b239fa45326ea3d36097031beddd2e0ae4570bd75553d592df2851ece00a10de0e32c851e99e932f95b91d0c071b79820d44ea2d52bcc3efa5b51c64fc8eadb7f5d4a6cc6229b91f6b378ac3bdb88c1bc7e3cc59144c20842721ada3c1b75d7cf02ed5a1469090af923eca52e4a052d7c4afbcaf80b9247964889df4ab9cbd1e2122cc9cced98a1b8ff19d8d901358c641155061f9606e14d2a5b813bcc183ac232ffbeae112e3c318346cf949e774c248826857ec7d53e4cea9bdd3d0ba868022d7c082e478b336bbe116bf3fc8e78e6a342d17723c2138f8b7ba3cbe78ec1f1ad4c46aca41c18553ba34f3902b418a460928ab068f1af2f107221ff124bb5727a90249b263c567c4afea4cff2b9d10594b1b95ecc61978c371251fbbe23545da8f06e668ba76fbfa4a2978ebaec5acd973b7d04baddbb50f1c9c44e14394efc066987999f202b88d02dd3af2c665efa7ad90b9c9b3d2066dbee489bd98b65492034c6bbebdcd462e23739fe889dc5916699b694a42eb21d074054d444cb8bcf507464609396ecb4c6c0d71a05851d40f671072d1004c6a99b9fb1acc12f48f4aae857fb39cdbe2a7ff8ef8e8a37a15772da06eb44e45436b3911200218ae27f03f2486e2aca609d31dc02ee8c8ac7c1871fb066d910905b019036d22a370162828740dcb82debb2ac613f222e7e9ba76a05d30f43483b5dd3354e99e3a84fccab5d55b35228d26ee3376d553cef4ffd7721523934217691d072fcd6d69eec768652766fc8e8ae220dfc144433e2aabd78219249e891928a0d3666b58b24c45801694f77ec81f15526e53f9dcd146cf87df78d7895bb6e61a236e4b9d66c36bbf3f20f16ee2358cbb1cd73632f61e6ba795dc009dc3ee12699b1d9be8ea0d0a2a3e8e5b4dd4460bc01424ffc9c314643ee5595777c1acf2d10b684892f1c82359c4f92f4abc1bbece223ddba5a1d3d40ad20d9a722b1ee7a4fb9d5398ebf21e6f6370a863816b99b16bb913227e5cfac697226b7a1230b35925b25c8f4d3f243c75549b64b32a6ee9ad3d9ef97caccfd65da76b83e8bb7651f609872bec54edf4a8ce70f2cf19be7c9d398367e2de267ffbe14e2b8da401beb9914e933bc3627e3432591fbaa2a742ce9980627299d659184ae4f03b9100c2538bbde391250ac41d4f14fb49ddab94d9486bf087d13a40cb77005a29c0ec55e5742e09c9385680a3298b0df96d9c6d8c0fb36215253b62674bb9ef8b13c2542d70f1b5dd02dfd3ad85fe25a8be9aa468cd7ee543c081b01e0a3570ef18cadd60bedf3eaa6305aa835180f2292e3419e6e85fd5a5cc37137747e977531e8fa0ce27f1afc260f20eeb3864dc6ad1ec0a631fb4c7f388d2fedb01352ce5c8bd819011ee459747fbb8bdca7124f48e38a0bd62e3887817aa4876e24833bdd8c5d76941d64203838bd3a446eae31278dc42dcac0c3a7382d8aa2d321688e38cbeb7c2874c47716b8a4e3e6db0471d749728a67045b06bdb7771566d2765850366869fd546ff0af31123d44a99188ec0513b4db167ecc6824e0d35f6cc3340ddcfeb96440a0046631e36715697ec75f2272fa06f4258a859a0a37bcf5dfe4f66e926e22256cfdb9659d19f938f759f2a920b6b8b92534ba32f2f79fe7505da2d6607a2af5fd117037fb9cbe55affb59d76b16eba9b7d5226f4bf08c9f96ce3d45396cb367340233b6a666b16f9843477a4b1ad588cb3b6d8d639438bffc7d4dc4c9043f2a11203e6724081f98a01a5c2bc7926b14c0820a55950fa93c83fb1dd96685ffeca7e3708375aecb9828d1b88b215bcf7f2fc280f94336c85feec149bc1a0d53ca85747c3b7fe54761ac1e05b85ce54d7fad9eb0ad0b0e119077be1759f9c4fc200043064ea4b25eba8debba6627a48561d46a39e050ba8e0a76354d606a8bcba1eb5805b4ed0ced1cfd2d4f4f5e64715f9be47fdd77c0fb6d075dade36b9ebe015ff38d2c7ae08a1f203bd44446663ff0cb24e775df37bb688405dd3f734cd28be2adb5d813ca9521ce8b96523c69d0e9a2f2bb31ff6aa6628909886f0df37f16535b3a711b7001f30b73bc0c2617d341ab5cad0934904908baf2890dec326e897401ee227957b5c55d29337f57a2004ffb3e81b56dac741468f513e819fe2eec790d98081cb3dd8769c09009ae1bde674e281c1bc7d0a1ae11d79433228321ca5645e35d9f06f5ef75024e4568c0abfdfb392d12495b56f6feec31b381cbc1608a0ef95b881213411356961185c4354a86b702f74344951d9dafa2388abd119ff8a5134befe41a46306b0b339469c782140c8a32b97ff3f02a9a7233df00e06b142c2cd911224656394616b5f20aea88e46b7af15e7f78e10b61f6835a33d55185d6eba93b7979ffad44472710db964761b224cefb1ebdeb8a9d0baddbd0b670c1a10d772157f624f5c03d0ed7c706d4a62029789b5753accb75ce8b1f5d47e002cc1685417679c8bf581c79a495d4cdee96dfad8e87777497876d268845b6d201e7fc3ca57e510aa4db9cef4643a9e6830c7308798710408b26f8e051068b5555921d060bd03d96cb4c4f8597c613d8344dbba2f0452e32bb75734e2db585ce0998cc814e07c96a83de4548ae6d0aa755d989f87c80f57ca682513d4cfc570fb66d803644f1a31a504b97e422afb18fe1f8326fe60cef0a89a850f4b1477aa87620e5537e269538dffb2946ffd119331db581b537231f73c12a45785c62caac8a88222f6081c2a02b3a7d8c1c5492ab3b6dd688b13b210b6f8b93366e002a3fef6f27708efd17e4e90532298f0c573eeda0ce04a422378c298bf3eeebbde81ab88d99a601a7db68af51554935274d8ff785b0b539f01f871c8762179b1c943948dc35509329e508b53b07c2d8a3513e5adaacd68012fc62314d9acde89f8f401ae5487e43444be0dc8a4f20a72ca2795457a369cc7269c50e19ad34f63beeb036f4a3783c55bc7b95977e47871c8f0a9366d58e4e3fb1cff716f49d456541a3be971920c8b388d6ef066b4e241ffa82c175b72950f32370dbc936f691abccf12dbe89da8107c32e2e3b89f82ea6a13f0159b2b416da4b4d548d54b9dd51f7f999bbb41b7d519afd77340a2a2f7426b5246bdf3497f542f849a3016992e0cfedd38439b2f751d1bdfa9f3fd3c417a39a0a21be3c739e00e8e3f2c8383681f5c6a9c3f018b484a23bf9b70967355e05ba8480cfef6b2579d4bb4dd92a1e9d505cdf3d88ec79723974de184aad5286297135f3c02554c9ba9156b894943624450fe75902cfe2a52fc2141c422b0c26214fca8175e4c64e47e0435a0b91f2e9eadef6bad4fb9339106ec83f71617efd8ed35fd1593bf3c08f8214a5a520ce968323f7107feca995fb6e84eb0e926168fcd768a54b49d4728bcd838e6ecb8c1a079b68921961ac9f1e18d924ec7136b239b611180a3dcf07995b7e0c6f0d1659e5faf0cd93f3604321cf61d505615646fe6632a2427a0f8b28429c6c9704caf795eb56a987112140f437de3d20a6a8a9072cb56d08b6a40f482a7dc79d6d34740c71e9e604eb9b4e1398a1f987435371e43fa9dce6bd77cd43b01044b3c307a6116e6ed2b29a89cf74a6d61c84c03b8269643bbc972fc5e2d2669b968e47814d06b5d209fd4f6275ef64b1572d298e4432d63ccdede337021b1eb3c2bf1bc19f65073362f19e89d33f780bf9eed81cbe47e10b40e74f6ca28cd5f1df42da1939cf057d4107f8bae0e43df6152578b20cda1a08debd1c953b1682f5fb0bb8d993facd59735aa67ea892c43733c0066144f87d94771f88ad8e8b077592534536f1a329d7e04903834880aed3032c157cb2648534a1a898692a1f101ef3b3b0268d425e99738dfc8ba26e438cc3e2aefd8ecbd10477cf807552d34c3c03e2da938bde122fda105e05ef9125cd38330fb6368294c8d79eaf8085fd73d91724ad67f294d0cc205f1eb585f5aa4947df1c983fb9565a8161610f3787f48c53c816e923bab46383de4f3e4dbd5165d43cb536c30aa6b95e47235705b78747daf6a949a26f9992eb30bcb241a029809b2f548966cdd68e279ce72b1f611ad784933124783b5b1bfaec057e2b12d024ce599cf7aed12bd35c493f550e1e2a8c8f17420be753be690e6a71db334ce8df7ad1ed591d3b0f3293f187ee409ce717ac9399525591a323ef31b013bb7c0497492ef452d7d18773ec17a8d51f88c213bb1cf75bfe381833a57e1763a439d8752e4e554fbf5e5e4c156dfdec429aa10c0e15e2a9918a61ecde6a7acd96c1a08f279e86c7616a963d4f3b76d0eac6fbf27607e699814c915e318eb5d1eb23864f07d577ffc5bedd7573e1ef4bf428c95659ffec0906ccfee0b6e2f2e15d169a7de53098af210d7244fa14b6022fa6f4adb2e79eb7146051e1be80f0e18a0c72e7547bc03f9bcc6691a3c46e9a5deccb5a4c222fbf663383728709c1cdf7d00fc76e17a4a74179fca35f5f102c3f481a39e811cd218b080f7e7010cf0a6890a1260fe829b250b882b41fd41c113a0ebfc66a17f121631948f752532994c9832a74322fafdd74b29ad6596ad87a35de296fad0227c3d2d1348fae71e7ba5d6b7bb16c649657bb06df2863db98cc5ded3422c8dc29e9a82c84fa300d62ebf8aee8aec0580f51dccc515c025e09fb77925a7dba5f3e7982a374262791a3f58e8a254109efac78f4a7a047a81ca0de1246ef4f858a39cf104a20db7f557261cc82103b359f0276d6b866fbb3f413b206be1ed2efd2b82afc0de1d89fd97e8497f15c3ee27814d3570ab7f475a8aa2419af3901413003756f9a2220856430004c2166530dd061186d10f41cfea7b45f4cf3fe65203d1ad38e622d42f92591e0c4df8e7afb6c8615a6c118dd7ebb0eab8c24f054f55e939547e9b9d27399faa4706a0b6ed37d3907deefec92d57fbb973ee292e692fa333d578df453dd431ae6bbaf8b36c6820ceac39e3dfe6237829e267609a81f6c1a6f4a219c35778e24b493870f74d82fe88668277d1dbcb75c3be98a6a6295b9e8475c444e9a929ae90346821a46ecb60ecaae2c63b7e7f2906189765d42973d9fd02f938b2c4254fa0b63a6058607e9c5f219758be0d5845de56f03ba45a6e194dd4ecd888f33b741650d0cd93ae2d876396fdb75ba432acf48190e8e4ae9e476f32836e49dbf56c29947676c2540d8be42c4198ff5b3671e563e97e22bbc2fe2467c10bb1947f0adf4351b7f0ef47f2872b234f8833533b645e195e1995244c87b82fdb3078986b202187b6fde9d12a611196d4d43625231b5f169cd5a3a1ed9bb1fa4a3d4ff8f5e0c9f5054e8a372554e0eb66a3a9ec3e1f02e91dbbed9fcec92bd3cd4540d7cb76f6fce5cafd189fae6ff10cb947c9926f1675cf02f8f1d2c4b9c996efea6cc0d02a4f1052f4ad9042e04869488de7f9398bb14a03313fa5be65bc020989ae5b11e7079031822be45b109feb9bcf6767fb632873153887f3f6d41eb211751cd83ed705c30d4c05026ef8b87fe87f73e6b61a4ca9ccb00c414a5b6bcbd3595f366d114512bae92ef481de26be205f57efbfa8a3d59864bc8ba204151cdd43230f3d1ba7a232f1f1215e84f83191a50f2153a884903bf2156ccded0f3245d95a32257cacba38938a227391e53d66bd9692a535447e789f5d4a5873f4aace03d5f78083c1d353b20cf8ea54cdf4f31649b5b5553bb4553fd0e2a6fb93c7c178e52524330a6c565b56e6fbf4a4763b8f6926fedab123f2a2fc6293f0f71850db1b83da6b21fd46758d3ad557e20e23648e488ef31625421886cfcedaaeb1b2ebe228c2cf9d81a586dfc93f6c355c42d97f1f0ec46005d4ce6dda221088f9de75e7b8d0cfd3c2fc82bde74a32a339e556724681a561cb2363e326a4a6bd4f543fd0b13a2e4e9715ef7517f3fb2afd764d5036a063bfd8dc97c7eab04bc6cbcba06897d3ac8286af2dc58521873193671c3f9387a58df60e1481f27c2ab4df988184c8d93573de59b31111d1d02250fd271d5516b461df0daab7b1eb4ae2c741ed5d620919c84f38a2c7e3265f3460ca3d9d9537c7e3c6e0ef86d1537aceff278a3a38cca4438e38416b837aee57e407503065043fd5c0c4b23314b59826146d4ad8d2106aaf02e403b930bf35fae0a27015c4a5a4882b1901c4bcfbfbce5e076a17eb977591f60aaac710e93773cacc234b51fdfb0d0e64ec766a8ee039278ed11e59f198f505c7a1e645690b38a7f60a74fa021f64482f3eaf87a9fcb08af0a09823f051ebbaf6821707819b51408e805d6c68d12786909957b67bd670134aba3378ef64b6bef4d8390aa6ace247f44592c9ec499a586b6e457bf9a2acf6af7181692e603980d32030835ce14d655936dd9d4175f228fb648b927640351d899a30fb31dd9d2b604a283e18d3bce8726cbd8a5d45c00d82022db9b819062e5a79ac50e9e2143725007ba7c5da6459b5dddae626f67eee5d4de467f768a7c38c0516bf5f6702c3cc9b811866476f78a92d2b1eb8d789e8f6e8917676b9926c141d53eb6dcd4185e00fe038dffb04599e99175945edce713becd1297e19d8ad6eb03520937bfef7283d1f62867d9d596b5a996c885fb1e5c0fa1f6b52b566d505840a42506b57ffe4db370561fa19ff1807336d13b858d36f2312aa4421c36dcf059f1bbdc6d4ae275cc6f8555038c400dcaf2e7b2754701c6139730cfa6d2b9b6e2b0df6699ca1534b1c61b0e998363028ba8e7ec6996c824e13af787c118e773cd7ad69c1b8be975d2dece14081ca0d9fa39cbe680ae8e17752f959d167848da912fe3447020a4c953271eeef98a92c158ceaedf3be85a15e2edc8040023a3ea187edd0c1b8d571d56a816f2e39395892344c78963b1fda8a4ec269f531a9490eafeb616e6611699715bce04232447f977278a77576f3c6ed0b9719ba47e90eb3b1fa213111ac285b4bfbf0be4abfea8e5bffc9163ae4e64654bd80f7ccbf2c0dee4f1a308e3fa0f2903802cd057d612309b8d349bdb9356e7c677f4a25cceb4b6a8359eb1efcadabf61682fdaa14753c8bc0e18bdd3be351759e52ded9bffdf17775d12a233427eebcd2e9848b99aeec777fde1ee3bd7d846eeb29a346be2fa8c48e732203ffc455317a0b244d26e288be47159dc69e651744b23937b6456444967e56c8bcc8d9682f658d6be7e47fc0c7e28c010fe2159d7015df0f96d82564b261ac5f4eac47e667b0f20988d529c65d77f85af21fd3c2eae2bd6c2214b440a7874337808c1b55cd3c71a48ef0e62065f8323ef09b38cd0577f79cf1c0b14199b50db75f01257de16603f6d36d01782b7a5466c58774cf5ba64c8fe2780ef3d62e4dfb27ddbe4a9a756cbfa07e0091d805c7ebc3b28ca2f1a39f3b58bf3f9408111731ad073e4b2166689cb3904bd30e722250c078ac79a123fec1c3dabb7a3f7d69a17b8047e43d5f03753f8f5a2ee5e75df4171ac2098b07db0a4b2e3b2abfd0d3150c28b7b43f1cd67edaf0b4f4ce970d191924b3c93a211ea6b9c7620ab714f4e673b49c125c2bb8bbdb4e01d84b3ff90f5f2f114fa64af414ced9cfcc422634bcd0f3f753bd332950be123f395bce3cecf858f51fdf86f7712dd6c8dab16f93e8d7836be38ac57ac1c53a61d5450471b8ad3ae57fa56685563229ef59e2287cfb5ffbfba6f9d153918e8dcfad3176fe70c89d394a5fe7ddc551be1a2d367ae08b7053d0a1e051bc73596e4e7ec396e4f4ae2842bc293f1ff1db3be48f2e48e7d00075e81262195dc791a1d80e2a47e458ddeb06b3441c21515ae37d06352fdde391bf5fd4e84dbc80bb9e9873094ce7f571342bd500b9cc7c20809a131043fec03af8948bf4304b276e16190a103da20422d1a0968967ccc58fac381b3772b59ba611c381eb398253777cc1151d335cab65bf20eeebd4d24674dac075471371d8b44d2454d68012a5a96614357a5f90d95c9fc5a80057c362bb4d9b54c9dd41ed81b5f2d35ef944ca07f7323655844423b55af95430a3083c4bc2f2b58a7fdcbb04614a488f7caea90b0a0109688537ff5376b37b8b2c3992b931f973e6f3640a9224a0b1c9fefaeba1d9c55379fddcba44fa478f3ec207883dcc856c889099d078bdce04aa5fa415444a75319d93222e474cb5013a216ebb63ed1471ea6a3ab079d7fb423eed2eda20aa916025f48081ef3a3a3b4b9bdceb92e2d2da48f27c1de7e6c8f5181c918a054b7714504786438a5f42acea2e9f0e1ebbad60282a0091a6069804cbb63f79149f9d93940d85e56ae65af8f0944402e922e4412d356504bcf847d4edb1ba4c3e3a9fe771bc8e6365219f153fdcc2d56508f727ebfba6bd60adf96efe2652d012bf5939b023bf3ab8a76afaedb0cabb1d26a5ae6e02ebaa20193fe0a287e2a035885c4b1f5361558bee9f12791b48e5eaf1808b5d6cc6af87ebf1a5a54d96291a747dff50b9e78be0ef0bde59a25c69a7b268dd4541bb744536b955eb2885019b23d34ca9ca2e30a47ca4c77aef574104ad5afab234ea516d12314a4b2b3f10753191a464a05b1d8c181eb7062c12cf3057621d5a5f8e179366dfd511df9e6c30a8c47dc9b9629a6ba1584666a443485907e2a8fa67fd1224c9ec0aef4d39b4e040ef1dc068d0a9be503358f77a5df88f60dc65fbc0722c24aa200bf7245865de9b5f78140dc3c689c2a96418bd68c5a18f194f02803979ae01d5b510a61a9b8d70e4f651d01d121edc4423a7b3b85bdf3505c9838dff805381c0a24d02403e3d232bcccba256234bf4b0565284a5fb71cacf3a04c8b349d6417dcad7018f294e2b003fa67ff79586063159d8b956a22bb1eae7f5438e65c6cf95035023dcd9f8c7c510099d19d7a560b9aa8794b2251af82a8082725326a8fdded5d11de74cc010c76ad76110710cf0f179fcc6113c04e63562509690802026fc7dfacb8eae52cf920481e8c7001d8f319e67d61f8be8c1819a4b481578885fd34a2cb3fa1ac322ebf92e202bbf265c0bae92c2bbe90ce7919aeef0958122f7f4d4195f6fa723486ec97013696e00cb0e738ee07c0ada50be37a0aa5f4b8f47a74836f0b82ca35dea34c60e4ae69ec428dfe9cbc1eb52382a8d606da5a2a68956fedc6b849215df7387af5f5a004ede1fb6098d827e886078db9fc3142bf0ee89c228799cd53b5d53595dd0369b43a571bec33f84aa92622fe0f71af94fe7558d55876ed0467046c7c9e9813167aa7852a1f9167ec25db209594b14ababb681a8ce049ceb490ea3ef1e1956bc95edecc453578f78d2b2e2cf97f1497942ef91ca290e68fd80f9c804cf86cb7a64d6902e69ed7e340839219d94a9b610b02affc339d4a960ab600729dcc6f0c4e4a15e419d23b803ecda55468bb4bf6a0944ce1ef09cf6b70b366d57b39dd0ebb7349a2895f7ba3385ae762824ecf5169424829655857d3388cd73ddb6b2876b10ef336bfbf9397bb725be8468b20f77f6435c14975388b1385c8f533341ce6e0297e01b7ccfb5603055955ab135b913f6e8c9421f821c83159fa9c66b2546cb6e875167e06d3f459bf046a89ca2a5a8616c1f1eddc01b60e587e2ffed464b8e1f696d8c20f11fb9004fc9c12a67674d9cbc6b9eb2f2ba990692644254a2b2cd525971802d0f7201495beaa066273bc8c3377980225cc1b18343d6259d43ccad2fffa840084c2f300dc3f81b44d4b95afc940fd59a3dcb1e597b7a1b687eec9fef3b39825c48c19377fe16f0faa28e5351d19630d18722c337a9ecf3f090e27aeaeef671ed7dfabc95bca46e80e99dfe2303e337ebca396781c7d841b18ed27729f435d28a0d1d0cf170a53b0a6789768ea309b88322e2ea45d6035d08de584e7449fed05f25231c2df1dd914c8314c35cfcf93337329879c9b4bdfd9460fa007db516d23b2d139bdc050b31a00f3ff0926cea2946312cba57093a9e754aeff0ba2fd3fafba52fd93021f3b9795135f7dbc1ef06a37ef6663a352cd4f0264c9d5b11f9300813a013568a6673908bbd541a73491098fd0581bf3c70ea46253f95e6f6a987e1635e2b8f1b9a14036c30fb0b70d40a2c573c627617ed6f46d0bfa15f9522dc9f4bb67b48318fd41dcd796713b8839fa1031f8d374ec13298bcf2aedc16ee171c527317560f600ea1cee8b704bb3e6ddb77c6617d3bf32ac41cbb714990c51464a6f030eeb793c423b0b46294ff1a2a65ef58954c1a3bf02b409f6e3eb94b07dc6a1683229bdb1e35e0f02e491f729ed1e312f360b0ecd8aad8bbf9e84251309e55da16c4283238006dbd85bf3fb20e967717bc438664fc63ebed37ec2451cd0a571515931cc1a813baa64d55e5f0f171911c35500ddd162fa050e8f040851cf8fc9e8212624e15694eaed491a62bc76a375bd65cbd865c127fe3ff13caacc3a9d938ca91850ffba9db5b04b8b0a243bd31ab0f92db40d33f6c7144ca2a8ddae0632101ce2bddf737b1eac6fb9a8efe6126822b8a85357ec04e90ebafc4f1e5ee0b8e01d6917df08fc4386c4871bc4b2bba743f82330bd557d4b5922bd7e2cee9588432dfdb00a77fb447e5af43ed166f447727226910da8c8937ac8ad337d49045bf4b0f57dfa45a190c77bc0595d2464a59c8150c06f8ddccbab8c7835581ae2c9d6976a059d347ffa77cc5bb65b6b68d3f16de2713938ac26d08666dd1a28f7e4e5a3bb50fac5e1a933a04315f9e2890f29b10e7a4fcae430eb640026ef1fdd32c6a0f603512d2dae24f08f0a1fc5d385dcd424bbe015b86716bf67d4ef3639c729566c5800b41409de5cf97e7759d582755444247cb9a3a6b877974907532322fdb68e5c8e95e1ebb835c246834212176128a36ca5f9208dc2f77644a4ed5603552f8d4c092e89efd7b4eba3c4a3599fdb68195d3581eb4041284c371af2bb43643e9084e58eba0a616e3f5dcdd41b9a42a09f3e977321879f07a8ec1581097164ed5bc2f18e5698248b92f94c0004b76d7d518e1538055085d314dc84ca71e2f365bbf697d0f8d21e880431c709074cf5c853e5579ac1f72186c7918114f5c73d7b85632c752418db6db88e77e5617a61c5a396b2ac17a0eb1f0df31f46c413cf8365ee62508071f19cd193338dd1563d1c239257a930372b0d5a2cba2d9a49b78b33bece940ac05eddc31aa0ac3ebb3486de0d8883ba9a10927354f597a1777f082fa8dafcb34269ff22ace3db31e08be0c641f2e2bf67a618d972cfc95b64d879da725ae14434d7d1f9bef9ad44ebe5dc9054cd567877ecfdd6f45eeeba489005b7fef6f51a7cbcf8a2c4d57f582817c4563971624b19c7604d915e2a00e630d0ca5661e369a75b7eb83d6a70b962799db432a41f99aef55e4ebb8cb12e8d383a4bf26c907a54ce56e74e647b58ecb7958e2b85ec39b51b298148a1fe19409cd1924cdb2e59f1678938a9799838d183c52d9ef6fe0ee35f2044a7544ebe89ba9fcc02b4159a38e358bbcb3780eb403ea41b16dff900bc2b9b427ac74f18a2ac9953f6b5654348af9f2da997692c8c436c8e3a82336ef17163185027a10afbd1963e8ab7611bf69830ca44acbc3e5b3f93fe3d86ba518d6f98ec8afba5d2835f7beadd2f02a7a9b51a74d0bbf74ed0482ff86c0d94834c072853e0a0e7ebc7f87296b3a87b561b34d714bc829f96fade936176001bc7cc5f27476a2f919309bc8f6e4293a435a60134040274ef8e69322858207b7355669a09502272e934b7fe28e7066de4e4271753f5a26f2d63611018b0849fdbad6fe6e5d3a769ef6be5958f8fe13c4e815dc06afee137a25fe327ec9b901784b276f70e38f4bd91c3aa2fe718d4d912dae0998b2687ecaa5737090eaf1418d5ab07672672c90d2d87435d64f621eb4a45f3589f3c5ee549e2ac80243a8ce633e9d05f632f24410b42ad824a1a3c836f306494507f3e8f2a1325a4a7e88a262d48808fb186f71aa5f05e3e8a6145a4da16e5a365977b58603759331e86d9e9a425a1d47e07c032538f20d0a688327d645113868163a168b8925282f5c08fb05a1a1472e6f20245c856394422d46e90f14b9f2d51c0f01d26f791e7148b978f1e5049bafb80aa5f982b95337f67ff27f125e4d22ae62f344b03d6462e44d8348475616ff8934a7de4069ab0f33339417ec94104f2366f7808c5456f1227a0756ff3ba5cb4bed331136fdc3f72167ecc9d8ec3d2bba9737d834b5f91607e4b51705e352bf229a375f0a2d5c5f5afcb11f8829fe25f47084cd14da38af41c27186c4a3106717a9b205453a8734968e283e5f1ee2bd92fe9de685bd2b45fdaca746456c3a7aaefe8829fda0253daaccd52702ebdece81ac3120d9cc49f19b7cb56903de38bfa227a56d294ce416a4a9f844ae217d15da6b40e3cffd0fca82ecb90b5cb6ae364a88fbc1d502974f06d16bc4c4c262f1ba767180dce78e64ee3d6bb984af6fff3970936da7af26ec8dd1240a6d9b9f5fd2cdb0c1a7d67efe5257a28821afbbed5a96f59015bbfeeca20027bd02a683a03d0f09a61a7db91572b8e0b98e56572265e45769939a4970cc1a68e281af1a55bb11767de8282d695cc4e1fc7a1754e8b478b76de49bb63ebfa8fed20e33daecb4ec02748a637b5d50595e513120849664a5d8dbaaa6eae90894876e82045347bce1c156f696e61e81acad311653fafa1ab9df0cd6ef97250a944f1b8682a112c559d1a93ae2b5fa33e270c221e0bab3a5b39e71557385823defee1edcc72f5f606af24a8c125ce5d782e614c07c075c23437fd4a451f83a3dd12aa8532571507d6e6ccb57886ce9c17b8a1192c188b5b4fa2df5b5309cd098fe2536a030bb1cae197f9f52dffeabb426a85e34cfce843ca5707460bf08b5f3106005ed6a0bc8e8d68520c9625380c259c7a246afc9d7a0c097597b94a6f31cfedd602318ed012790057f56fffb43ba11a6cd6e7ce659b09a0d7e70a1de15699717056989db08d913648b887e0b1c076800c981df506c4f7b0bb874fa9fee9fd99c2f31f5e16366dec8160e7610786b772a3e6d7ad2d9471f7745a474b225f4265375a160539a4abdb618cb85cbac36b9f93f578244007d8cbd0e91c1d2b548ad6df0d47ff045784caf86fc4bb092198f2a87c99045ef91d2a39abb29e28080fe0a7c2552f3c89cd529313e30489b76bbe7d48287fc8653c1f999564d39a9694a68c1617bdee0b393bff00b9e6695cb03e0dcb8b78f18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
