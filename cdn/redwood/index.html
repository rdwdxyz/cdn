<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"57aa71da75d9911b2f599c758d13051d23b833d5632cb318e128a17e4668b01f96c0fed339f4dbde8e4b0def92db60dababe25e1a79062b200d95f047e0fa82fb8c09681951599d115d9444d139b7376792c8988846f129186a59a653a1bc3da1b8fd6e33a8fa0945568a817d030c86bd2002eec3c14b1ce91d9c706232b99358b9d9eddb848dff67c64ce1d78ac0ebbf145b13150c131459175e381593b107040203ffbb29137ecf226f21475c5900815df24b64c9beba5a914fb7aa7fbb8bd0f19e43374598bcb3031090930e899e8d46a89b71ffd9c480f34d1f89a891678d75cdf63b4b9946d8da5433de9b8192a70b886a39c890d44d05e64db79759ea349f45d9e1b2b4c4a522f40e1a5a2148d501e717d7a4976bfecd555f8a63a52d51bf5220fd94bd9da818119628d7f3e545a7b338134cffb6223336a478bff5206f54f054017dc401b7d4c62b660c663b6eee3566eabe49e1eaa4d80e0cbd41166cca29fc67a50cca2fa0fac558dedf26b14fee8c017cf289d82503766e3af473da5d6659d15ba7780ad121f63e26fb7b49d546909005a92991dc37d5b49ad771264fb4fe2f560dbd3c92a05725b5b3cf402f14cce5bf36457908d0d28550733f190442f5ea6c697968ca975738d612f32b50624c434a157c384083cd2ac67f113a267a0a9caf3fcef93f4668bda713e34b6a46419a8b77b9dd4bc6ac45d42ad7056a5e3f37971a386b78545575c23c9cc8e0463328ac5f286f4021a0cc2455b575112c81d070a0150cd054544a73e1db4c937eb28fe7ff40bee93df5a1283ca0c0c17523538d2a8b9aaa208eb9b2345ed664508c4b07688b18c55d88cc2bc4eecdd8f8397424833b982ce2dfbfc18f44de7bdaa032fb5a01ec9fc9af3a11e67408b3571ebd6fd363ab5a72e51a736c7838855297590a541ce360b119f2c6f2947f031dff97b78ea3490bee4faf600f351a1c21236ae5eec5a01f69df6de0fa539124ddbe5cf4ad898ffc7bed04547e1834b46abbe98b4a928cb5322575afbfda9278931c2eefe2a2d32e91f589c8f2244944edce4997a17a9f832964569c3738b8b6f129a2cbed8e52d488e95b4808263a140a2bed19bbd64426014003ab06a613bc506415fe6ccb0e597972b9d3419fdffa16886426bd0589983de7df8f6ba699ff052cdafa3fcd79ea545edfe2a3c2c90b52454f5e68d3583a1590acb87cf2cf5a137e1c00dac25326ffb6639d0cb283e28b4ff7d5dd970a07f42d2fbcc9e8016cb69a07f9381a26b9cce2a8bb4bb53d4892b79035da84b95354e619fb5da57059f513d74ad0854d7ecf394e3365cb598780a180036df5f0f016ba48cbd525baf59a486a77cd3f64957287eb405008099ad2b0f9a32bfb7bb53af7794805f8ca1bfafc06c2c4b07997d5dcb9cbe0e27a02a91a472fa57ee2892e724c0a80bd40e9edb3dacde90338638dd340fee8a93ed6a136e350cd16ce7941ace00d70ccc5bfdedf4b9fb2328d269c066c18f25fb16600df9ef2505dc3d49c70534eb99378a033beec304eb1940bf4162aa479c58367dc78e3b3a54c552dcff9c255b37063870e705dff8a0c6379d46dabf854d6402837d32adeb69bc772e8775d85b24175732655bd8804dff25a63cd9a8afc04df092202937657b97ee0955e9b75741fbab63dca908f1bcdc817059d3a13bc0d80063a1eabd3c02af4c3811c28aa733680d96ad47ee7d80b88973b229794ad1e7d8cc75b3040dc8d19303e84aca977f6cdaf9a74a8231b00e49badf467f06dbdebb5b4894ef04dc5e2f6d25848744d69a982bd1034ca52b44de8f3ef1127a62e76d992b072e716b8d50131f2a11b11a4b2719d645aec20e7a9dcb0c663642dbcc3ff645e7c6479ef87d2960f773bb4659328e1d5051b5bde0ce901365db41c335b6bbd3dc87dcacf20a1c1803595817a39459407936a54b4585aaf331a05c543bf79d953f324fb8824a851e4cc9e9436a80744f84428bac26a3fb9326e817df01c4229aaa8d3fb487e60f77a2aab0682578dc0eb910d30e5ad71cda76a547446f6d4b6b3b66e7d1f3287f1891cc09b548296c7bc37330d2e8b55d0a9fdb687f24f02635ebdc44f165f4771f1927c3594b532b429e0f8f5f35f4bfae92ffb0dabb802c8185279bf90229ec8f655744e52ecd1dd9f398c5aab090895bf28f930f3f0dda82711cbb37a3c1743d099ec63bc11b5822259c8239ef4da810af7d6a8e658279c95282a1b25980656dc2ce299456645e5946014fa26aa1e0957475d968038a9f8c0c07042fc9c2594d17b5aaea4cd08cd1b1e5baa4f5bcba518a3086686650ca06002cbed5601628e0fab4b2f4739b16e947d11877ea0a78eb480d7ec92e3d7b148d02d8fdddbb4f9707a33687cb8a7dfea3d096b6b8afd7871f37ba4cf62aea4001e02379420925aef566886a5b2ea155aff6230273083a5a8846d9f7e344266983947ca6871d632acef81d7a6bb2d1e9395fb5c4db197c56b3b8bb357839ced7670c859bfc0a7dcdfd03ae0dbe339bb825c052ba3bdb16f0204ed8bc940cbd5f87290a92742b878e4fb0c654e0a2b1728284d06e5330566ae7107f23b945b91b1d9e264bdd0affd9188c753892ed19ec768dfc915e1e1a52c01ec083b75810ea9a94f4f0f6e8a68333cabcbc2134b2aaae6dd5657280076123835523de7b6024a074932a2ade6c02b347ebdbc48a1a136c9286c440af3c5b5d7911cf9f39ba99cc4d5c9e533ec38a1be1e87e22669ff3622b21343405745dd0f4e4d4702a50492a30c3b7e1e971e0c1b58da835028ec7fdd3e4f3fb802ec654c692e38479d1996738e8f2e67147c3621ef058a3bb2d421ff41e021df078323afaf4734941d48694cefd183148464957095b429cd0e7b77cd2104a9230e918d13305ae0bad0b080e18f82fef21eb70d18d9c762087bdbe347d8a55b5b78b540246c462d292f8f8438661a57761263cca2611ed98bcbbab84f3b6834a05c1f94c9cb0794b0a8e201e900fd3cc2d62085862b5285a91b301f1858efd372a545e7971d5d1c31cd7b5ebee70afd11f351313d40748a1170ea485ee414309713fc60367ec54b771224b601212b69e5cd40a43a3b521b37ed6fe6545d1b129dce1bce5dd0de0b726467b55471e0e68b80c2889b7fbbfdd96112e7552157dec66308bca96444eb22e9ce69a78447ce7aa3bb5b0fae4562aef09ace94efbf1fefdb6d81003320a7557be246794aa5dd4f2831eaddf60fed97acaefc05dae8375050849fbea06fac1954535f82d3d9c2b22385fb744b889191fdb22d7c89e4e7041a9d17cbc019f53fb071b08723c8e47b8b50ba8cd6fb8ea54909aaf48ca1ffd6892bd3aa9ec2b3ca5f6f71ab29d43aafc94898a5e709b26bbccd79f2a6ef03bd58a3f905d689a0387b12a6be9683706152511855e7e4bd35bd2996eb62f021c76f61985a7dabfa74607ac1a6eb45a0ad4880ada285bba3621d92167836ac60fadda2ca6379bb339497f032ad05cb535d9cf5dca37209bf7e96fa487598d65d89f44eb7529d6f3dc5cee44083b28eff9aa165046cb658e32c8efcf835d83ce0be1aceb0a5ed5b6831d8fb492de29ce1d697f562b87c144cbc295b0baf56cdcedfa7bf330a20f0b669fde8c73a4183c087526cf97b9c631402dcbf64649dc8f3959372abc8747702ed7175bd2144356be756f32ad7f3b09a96a838aef1b1747b69dec137a4a8b35124a9aaf054e23b1691757f244ac822f8c2d8aca39e56fea45b8b2ce7f4163001b35c7426705a1e32deaaf3580ec1581bd1e8aab62a1dbae87fcc77356552793a9d983ec491aaaf7972ca6df375fbb23b8ac6441f03a65d3c285c9b58f06196f71bed8bbb8e35f0359d7ab73045de04d2e0323b1e729a122d2fd2361f279c505c7583540a8979c7d476d81c86270e7f482b22db7e301b18242c109c3939b0757b59b1c22bc53c287b12c9b6bed556c7aaf8a4acbdc1cd3e87163ad415662d470c7ff73af39bf9d34eb7eb05a010f23b2b188e9dd5a8cc52a4dbb8f86a4dbdd839710723a7be043af172cacc3176e0f868f48796c7b96279eda99717a33dfc46a41d565fbcb5df77f84186e4d06cb6086045f4f7cad17cec27a57108accce74196a9468d6d2fb2e332928b8c88d742ca86ab4c892362f0b970141e34aa089d54b7cb77c20b5c8f42f47621e484a40bc88c2f1789cbc207f948954e366860df52c432fcd0e90611c1e35e9d40cab7e4e6f72f7e066c279667fb7ff026cfed57636d7595037d04397fff264d739061aea3cb80cbf607122b9e7f0c6e51da951c5dccfec36bdf17a5ca9867e63f1a5748fa0bd8e84b03d3e0720511eeb42ea1055f72d89f8bc77b6f4748e6509301072f978165c243e869efc15de4aff9606f41351d019e5df033c985dcdb3c1666eac912b958e75ab468e92e4f903791f472cae7154f4b825752f68ed9dce9f4b5f814d7f2f3c524c520908566947dcdda711001b0f3ad23e8cbe59d2e3358cd3eb9064dc08fbb435a3c7029db8918251837f16231344c779d095dc89afb0ce659f94299da48235ea4d860a7aa3a7d667b0df4bdd0934f32c7d245e95cb35960a4708c7dabaa80f548b66084d1333eca8c820a6bd035a03baa68a093cda946f805a4b80d22a45df0e2d4fa0fa7a942dcf4e232c690945576a185caa9c8e4560b51fa1ac8a6a0f154d4a165e58daef69cca911386e1f3b2eaa3d2febc2e101e58d48557ab6a5b62ef32c266435c4628ebaa3c84e34c91905b9a9a55e99169cd88e16f2f4d874d2bc8c3589d0e374a6b6395effdf4204dcc40ed207412fb9b952107051b7f2034691405e48ea2e071aaf8fb311fe04d181e475f354026b7ad6d1b63c3b4f2b4bd8fb9abb676610a682dda0fba8bb6290d16e51f7fb0c3dfd9396ca14ceb0ffb4c01dbf76c16ad02fb3f2d24a70284800eb72eaaf461d4f05b1a765efd7e309362599fe2358adaa299488b899a0b85d772c3e72928f411199598e970b7f19eb5633e4c9cb803231fcc80febf3e5db2b1767b869e85457c9f42eb3ec8d33c939d9bf69f2e7697c3f0f7bcd538564f22399e6bfd9cfa009cb09fe79a962c75399889cd150ab8379fa4b676dd586db3ed235cbea57c3e44c071f98d8013c25f9e593b98dd51c5fe6af5797972814753c8ca443ef66edcf95e2c7c1546cfa085b66865b2987558fd7c1b1e5ef4a9156cda42882b26690d7e84ec1d20e9bb49bb59ffb4a7b7a58d3ff1e088eace1d19fb23554221ada4d33c90f38d25694ea9ce82ae23f0432dc8583230c4c40d02af4bc6ea52fdfecff53687ccef69c1ab278db7dcdaa6c3532a18b58e6ea1602def4f12701a6a43229fc1588de4c88131a9f2350ce73188fe1c43918b4a905e58f330eb260edaf178298cc6736a7850688aa1fe383870d9e866b34d9bd04c561744224af7d1502c19e9b3331fe8b90c2efb67e7c4b3a2658cd628130e6083919d6c392d5d2871a14fef840d624b2621555c7236807f20cb1e547f98163537110bcc589858248739979627344557f289ab2589e15aa8742669f226762dbe43a2bc329578af5d6d6457c698bc1f1141628cfcd4ae15d3e564012c4e3e80988031ef98707e1b787a3b1ef5f0c09b6470201f40f97c97965cf2eadfae76a5e3b011a2c4fc0afbcd7846062e56cae798e7fe884922cf688b6e0696f09403db205adc2d5495e1fba63546a454737a510c02086edf24053d8296f3b4d5d45a96bddc490c6905c41aa767531d6c1214465d332ad16966e254d81cdb83f35c939d4704da15a9ff595bfd29fe9dca9be1111d04085426767e99b90467e00768bcb51d7d4abc342c7662c49fea67a115d673e6e9312d817cca1a7fdd4232024b1dc520c3870797b88c1f6cc9ca0f17f08cc3e509bb5791622c4424f147fd663d26a0d1f57cc30af8f428635079a15573d6f649dd37912fbd82ddc90eb901ee020b4aff85ecb91648d0067e757c9b7df2acf2cc3d9f0488b8f3d93d5417c5b14f345c652b5920b88abbe6af3c80196b08a3f88a5f52e3806450b02c8b20ecac6f39a77f1286d8c10ecb96c1d4d812822020a42f8f594f42d86c3f057dcdd70367058336bbf42833918fb8ee60bbc49ddff87b4f0886e95d965d2ab823f7a113c092fd227ac9498766ad1db1b85adf4d4080a154fe01722aadf4510e7d9c411e331c3269cafb66f2ed58d95a1f31362fb1f001aa1bfdb88f2f42ab412a7ad287219765c2d45e5ab8e0de162053f4cfbd97582f0c4ddb60be6ed0803206362e858c60c0678cf1edd583a1c73d0213391f9a61d9334408cca9e39813f31915316d64420fc8e7f6d424bf75391e8222f2fa520bdc5e6d2596ee13566d7dfb0d6ff5be297f5b93421b93e52c17a3e02624b934e87d8bb0346b47094981fdfbe6c5fa6b867abde24ce809798302b014961a25a2c2fba7a3ebdd89175ff2d19f5f2f090cb2318d37850ff3f6113ede31b1f9778a4b34844ac01459dad8eb3bcd8c027b749e520d7a0fa19af8ab92b5b3e31e4e8213124382ab05619da1c86126645daf233943b439feea081d3241da24057e85d5ff943dad78d80581e098576a515bca09f1d267256bade66d6297374c9f91178a61374077f5c0d39f9028f22a8afc6a0f55dc9ec613fddd26bff37efa107e7241111f4e98f715e33f6f87a6f5bb4715efa819f04589cb09b24876cf3f671da145523c127b31207dd53265bb5c24a5ca574c6fa5447eace5bc92eebd7ec0724c7b3e98a62d1496e0e4532728dc021fef610d67f2e487495638b7c6498f9982f0c49d5ec3d735dbfbf2e694d5604d67d80b3ec7abc175742081f367800824ef2bb5f79a006aee347e59a9786ccf1fcea613b25c0221890df0b14576fe3702088d47b4675598514806a4d30d9bd94e8dfb4776a2176aabe8671e2c5151d4733651b201f7b0b93e4709d0134dbd5c9eb64972e9fac9df7711a7e8f289aad6e21e834614638e221862ae820ca89f9d76c2c9c2c6453e8962547507073c52de41f384c41f87e817f64825f7deecf7b7933b533c73f345df9a8ed62334dcf46d10f28e2ca8d37203e3cf40f50ec655539526b5fbb6edc09b1648094124a8045a2d2921a6760cc4e0dfe86831a1f639d3d19cf1318bda4051edfbd9330d7c2f7b12063da40cd68b2db096a1c327c3fbadf72058c080aa7ae9604bb7d92caaedb223b0026fa1680e680d2e8e3fdf70844f18d89713dfef2e5fb17469a6aa80216a0e5babd55ab09b975f54f6c357049d29033d061a1033e654a842b23e7f493db42f570841801094bfa11e5a27927a73afac5e3a9cec9a83c49d36004c4fc8166b2b61fb12f3eb8c5a6389d223417ecfb068438cff0915f1c4680a531cf5cc16071257d73f4384a77107b1e31392f256bb4ce0950c589578ffb5c560cdad90efad02593044ff992bc77532c8c82f97931880240a941b8349636ab2f32b77516317d5dcb76eac965e54a01caf441bf23c7b0c81e9b41d75b8ecd6b534cfc94da389f3c284faf5bd21cdb2b9f75b9ff06f9cbc5bf39354d151106d4f577145ea20e96a5ea08827fa1b5813fb7e15d707ba0f01ea14b48f56a47561a77c55ded026fef8bdbd713ced726893e4c6deaa60f190ae574132b29292c5ff4e8a785f471937a61448c9a457a3757e30484a9563fbe9983a79803b0a0a22b9385bafbf20799082a44fa8971ecf22b6306c4b01b6b26acea0ddc52fd593865d12bd88aebe4df8d523000a469ae037c17945b26e3680f082ba8cf85a457cdb327c077b97a74bde8a3f257f78d71d31fc7822adfcfe89c43d8b919b0e1a96b98ada393f37a51bc62b04a0b50c37de06f6a505d0e44e2b61c3b3e7f7a3acd6fb11c7f779919fc11e39a284939822c6c52979605b3e680f971ee07fa8e5ec364f65fbf4018ef671aae99c04147d1f74d332bdaa2faecbfdd87699c3dd12aeba45dadfa8c5c1fc775b32e8b6756318c7f252c2fac38ba74ab7813bd6d8739e6c77d207c249b04239a7b4d93fde309467011228479a64bc05da2d36115c5fd7a270ca84bf4025aee2331eaa4343d72486fb66f59498708971dc8d8ad89e8d24f03f55262b47dbd5454b5408e0eb4e3e9f5a4faa1973da0866ee77b0d0269aa7394f62fded9d48c76a6ec8187314ec704ad72d309bdb3ef13b12e7e09ccc489b1af297638049c2a9f62ba6450803b8014404376cfa3a57734f65e745a9d9a82b65c652579496ab5763678ae0b343c621ef455366fdbe7877003b9797f3671fc41340388a19142489059f091dd6cab2b275b5087578846209842154840c136e0548ed6fee4e0dc85e835d4395b35d7759dac750b0bcbb9d081d95d593e931e7c9798643955870c115014e5407f006213714fea18d41d83743f6f47d3a655cc35b257be7a20d553b82e404709e01518600d8da6eb87c91bfcc52c206f1c960cc8e5e84176f17c5291913dd59ef51b3f4f2c1b1065600a911af96c8f7973adf30acff97a4144141f3974ec2ebc4a6be9c40a478595812d578d21603d7da656e8a0dc89a7eb2cfd1d1171bd24fb08f44c589cf80d79b60cca01dc02b8de26d26a645fd1efdbe1ea200987633c5d2effd4e8b9b2ecdea09f92c2bff6dd2386074b8988e8efd08199027e116932750a0f7324e8d18dffd9c6135b570e98383d677384544beb0ee5d4f969303fec24bdbbbca3ffff732541b9bfca418c8f6b6e59999c0c6c10f412cf85d5d2a4c1fc81e5591a7e3f3121a7844bc98180d60f31ba673a97568ce9162bc4856ab0e9817b3c1394465c25bb6dac5927475ecefc543296c76016df63c0d96f8df0e39770b2e13d093d13cb80429d4142dfb9e3c87b65b7a7d818ac0fc40a94bc0ad427b31e009d66c0422016be97aa7c40c424396716826d8f75f49d3796e82851bab16d7fd7937f0ba350d40770694b27e0a9466ab55617c567dbd8262ff19427f70d3e6c9b7e5e33787bb5dd5305d0490a2557f425e9406bd39f348d2796e3e13dc07a06c63752432ce19440ede454cbc65c3e986a6fce76f725c9d360c9a265b44875987290802745225580c1e10f138884e74f5782edc013ac17f25ddda0170b42f7e9a32d2c1bbd37c39006caf77ea4b6b6e145720b510a73c0f411db2df4295e2affc4d414f1f1eafd686f7f86f8d858a00bbce5fa4b80448ee5952a5831668b16a18b46c632d6d0f14efe8928b01857f0105e56b0157d100177a5480fd40419411513b152b390e83b76d131b2eaed866fc1e6484d60becb5e9390524dc39baa34500cbc5ced5689f3d89d4f67094335a2d6906d5b41622606e15bf0af143cb0bd491e9b1b9bff7cddaab97727a6d22f141cd288f2f3a0266f574ae657978e58e5e1ad3058543c2f05127e45673440953497e946830b12f0671c346aebb249829947061f367a10b0e761decd0b0e6e9a6069197ef70bf77c4b669fcf2ebaeee0a4e4fd8ce1f54bc5ff8dddaa942a66193f04fac1885fa1077673d4b7cfd3d7e0efbda99790c969ed0fda97e1473a50d374fab85699ae9a1286681d3178703063121c852b9ecd1a84df5faec66f54bb8e02a60335d468a98b80ac437ecb59f9856eb3b74e3c7aa27c0f67ba08082b758140860be8978ddfb82816d57655c0636196239edae1e11ee30807c7f47e08a5584e19dbf2d6beecc3f3b6b19e756639a0464ee050a55664f938e007fc76a91df94a817a7427d73b461dc1b605e1dffb9d26045e172395fc4fb47f6f804679c5cbbca867a426cded2836441d88df4d6258f333a2834365eaa8298fb10061cdedee946e8598f60ae503dfa541bf51689c45830f205e6ec1609c0071aad6a0e2dfd46930713397bfff00abf5d0bf0f04aad7b4deacd56d1175c9367b2ee4f3c79eb6d065cb56fb2e2309f3c2406c84ccb737cf77ed2e67d5484b787396e77c42585b2cfec6e1fed1794e76c5906ecf463133c0287acd43fe45c2abc479674cf4a419712afe27fe3eaf3fdbb19c510db47dc2149aa8ad9ded2de6662a657ded6366a292cf6cb07a31896fd8fa6f84fb99f84d1f4b7726b268201d75fb4e8e254f62ed6579760c2f59d491595c27cebd98d36318d8d99cf51c5a3e4c3dd8b8c4ac158340d8ef51d582f4f9af693f0aa3e8fa712c72c81c0b1d421d9e28e3c5bb102915c939f2d217cff72776f9d8c39a63d3b1cdfc057d9339db0817760beefa0805ca36c7c01e8c8232553da9fde7a0bb5abdbe5c356260a122f7ee4406384ad5f9bb13b9e004a2b42640f27e79ae3789f648a653370530a5275a761d811b040427da54016b4a2a1fb0614dbc057a21b52e9fb3c52a7cdd49f89a2c9cd8a50a472155995e3e8391eec9749003e1cfc73002cf3f0ca49c54affd44da37a2f4d51d7d44a63ff6031615f82f6387b72edf368c525cd662ee4784200de58e54b6994125bbb57c21f11ba1f3871ddc7f4215ecc0fe52b4cbdc2c0b52ea637508f073e12a376ae1d5ea466f823f677af5b2959d0e3c22ffe8d94473bb29e046ff1b87cf9840d182898643134cfcef2d22d8ff1d08746f2bfa32e33dca54c2a747c4f122e85b5a08eabef926f56349b7c805b394b1cbcf4bcaa1a74af88ff47000b517c324d82a533a2a0729964a8735826b568aac6424d059118fe668e65310b6da565a0812d5e0e5a3c08c9aaa74fc0df9f4a638c1235d6252ef5b20385acb5fc312d9b1805ce6243fa558d0f6fcec7400f3e7aeea0d8c4eec4f52eb7fe1639d89c1323a688b700d5bcf464fb68a3cfada21de612e4d54e814e7680cc7c7512d6e97d08258b5a0bf3266c507b3588e4deb0738a42e45f60cb13977abda58361ab1dea498cc2518ccd343d12f631dee83db10289dc89387b0f7a5c40a853cdc50ab55e04791d16e95896565f8c8e56ff414074a008182e699cbfd7a719567ee18dc55a02bab248242f3bc2dfb25a1a092630a4da3d907394c54a23cf85939031e4a189cdd5ca6c1d6b7a636d0dc8e1441e4e508df278f5e78ea6264c8666806e9f6f31da28370f1d605fb69513e7ac14a09fca8aee0b567fb314fe401ddb6b7376f4b25ea313d713227d117bd0315a95d27e2d19554e2cc4102f0b702b62a3ccc3c7822bfa37a538d7a18ecccc328d48c65dc9ee86d3a02f035409f45205d670569360f9e5b4a33e1aaf4478cc4b3b9dcec6660b8aaf87675f40dc27c5b77b869b17b091051603109113eb19a9a47ac0441cdb962fbeaa9aaa9bdacd947fc7a3b9f6d46f3636247aa222922effeff57440c9b3a844b416ce7556d807656d6774d55588f684306bc82d6d5c7d3b7a0284e6de1c95199f8bcdb5c9d0adad7804b71712e2606f932a59586f319e1ab7e31b3eead88a1d9c00d92f4b7ac3768e3de43f4e44fd712915be341d71adb5d18e8837d8de86219a45a27b902bd4ffcb335f6c5500edecab05c40bce279e411e05e19080a45b51d6b486744a0f54d5f49320541586485807aba91af0433bc2b983c0b7d91b1898d0cfbdc8fa4c56b8a73233b0a92baf043f24f5313ccb39f6a47fa4521443c9c4c0121414d92e9cc16d01215b4d39a76d9bf797383bf646a10274c153b05f034a87ce4684294077315103be2af77d56b31069c28b9311cc816346425fd74a58a907dee7b99a7a3c72a704e3309ba54f45f6a8408bfd7d41614577cae4b85f15004ba48cadc3755fe3803576a934f29524c19836f54dcc0e9ebfcbe0d9a9f35b4d9fa94c4500b280e966aa97772144e24fe22562f024c4821bfd6272c1463300d3be46947edff01767fbfd6fed5a388bf19aac7058e2b592017ae9101d06bf0d447898efafa9a7a032c4da9a66704f18ddf87dc1ec92fc3d08b5b5462325180eda0e753c99c450ae7cd52c4312e7c1220f2ece1fc02cbfda460fe27003a3ba7a623e086622e2b5353c0a6c4b588e154034f6845253d440244446e3dacb1cd65112e7f5f3477e1fa01b495d3a630528ef51a5282469b1e510d360f61e7c9cad6bfea25fc2df07ed116ec057332148da335fab59d63052c018fd882a9c80f167492b3e8b66506581a70810976be4e673301889509b7cfe3f992d6c6e414fb6c12a1e60d4132f759b21075501800ae2732b52b3f0c1b5ee7d168d9e236db4c6882b4f48f92c97aa1b2bc93a0dab2475561e24a4f7bedb102ce85d2874884be751d22576f5525af7203a8eae85aab6cc45e588ba2f927fb238d3a900b0944991206a405077755c96c90429e01e7eac06610e770af6558f50d4b97a411f74d58c2d679fa2526322f7e107df28b875532f1619777bf14511956a95136950243dd468e6c41be5ecd95d1004b626f35c06f2eea182e05817df8d330204435e20e91a268e1167bd98ba25c0059e7d200f8d8977d36efdcb49e263758d770aab7e06bc6b1bef02903ae80f9db00ebaf5afa17d31a229e6c0d92f50701cfa249338016fc9587cb400bef9c3c3440346c44833eb47d3b988c791728350e69a77c4c7067b5a69d06413e859cc64f46c97761db419981d364d151eea41723d8f10127f2bb33bc0667d8e652700a0c9dd9a68f0242967893e7cac2fd7dc92780e33b89988ff2c9a35e5b7c360ccda5c4430875036ee19dd8500ce1c1c951d78f423f5d00eba3efc815b13f617ffbf4e530971d063d1e35a8622c25bbc87c9d115230dcaa753791696ac9f2bc2f8b077ed626d0462205f4ca8e55f12fc5f017355fb2a2bdf4c48798af048909e7eeba80363da59d3738c7fbee222e9fb83f1ad1722c0a0c4bbad279098815db2ad8a9b699378e267f26528d859ed1d7f1822b8241c6dae27fd01c9e14f31ee42a8d9dcad307f9e45b218801d8862d81e9ec1b1a7dbfb268c060cbe13efe711b58509428df03bcd2adf4daea4c9a596efb315281bd39e05e3ea78a1fb8cad11dad46904185bf7cd868aa2f56077183b6371ea37881ebdd170bd25f596fce40d319858193a69343bc0d296c39793b8eada5a6339f10793b049fef009c32d397bfefed540b8181ac63e0f993af6bcc55200b79d3c5afea397d26cc95de0897e3ff40dd48257f6f6bf7bc813628e16c040616769ffc5c3b634b988ae37040726e6a2ad5c52dcd047ad97fe82b43fb6a0dd1310690cc4183221ca84d484c1c864da7559e5851aee57b236d0eb2952f0d3c2bcd367e22730013c5c403ee7a009f5a4005ee1a6740d120316d4ac2b082abb0e9dc049ce30510732503658ce3cb9419387e4de7f04d5ce0fd25965b9364f934a538a2a01ba129ee7df89960f986d3f360ab5fd2e0f51521c19d694f5a38ff88ea5580107ae6854ba42b07cd627aef9ff65fef52cc39dcb1e925c76ca81ff946644f65f41221faf9dba3c2eb0949890290efc4090be9fe5d3fae37888332b66a392dd7f889ee4ce0dacff8e12e3b5c8449495639a7bf0568d781a00ccbf11665fc5da29bd0c9f5088d93b80030d1719650dd41a38bed21985ff09e7bc6945490690f409c758d0d3b0b42ab3e6958f2e41641e602bb342308c8c03976b8314021a879ad917584eec9db1fc84074ca8c08d55ab40fc4ed1ecd218d752a9bf5dc4bdae48e502d2eb7c1d447cc17f104c5f3cb78c95c992f69694b29cdb349b8e37b35d3a4ecfb63e9f5dbc482c316926425e974adc142f03d61a11374b29f2c32e7aefc62621ea43ab5774e898a563443793a012f3ccf2fd5aeadf5693eb7576d81bd2fdd76d14c84269fee9feec411216ce25e2d097c0ef70c1425f24fbeecd34c481fb7bd1dad414380eac3c32110c0e387d67748755f08397903c95ddb6a6811cfb1c42ab58d9e854359288f9e4b46f9b3afbaf23fe152766b18d6457bffaba083408513d01c2519a3b8e12c0c8ba792ac86678dba20ef94821477c615678699de22955c92f921b7a72ed314b8c038943b359812a02e52f732a58804fef3829429b1bbe8979f3bf6526e43789a8cfa22139df22b95f7c42e50b542f2913aacf8fec40dca9644a7558b876f354a43b9af8742f01ceca0f4c04919819d911a77b67df1105b178735c6c7d3c803e89797385bf2554f8f071513528349f05381f8e4707493637a43dfc19bf66806cd4d2e4b027750786d020caae0d564847e03777a890d221d42a8dba0380bf9761e5fec48e8b89937200b981862ebf0f100a0fbfdc3af4ea9815f42e4b6835196cb3078b5c62bb28568a2c2460b454940940a58183981b1c1a2e163a1d03499424064ee6470a995e80fc424a7939a1b93de15a059c325b79b8db3dfe698500dd777fa68a0b335e866b5f6d74069327880728e409c2b8a7ffdc4c6a80c361e2fb0dfbd27ca57a0d6bd6ac0e45b6f46fa6512219ced19186473c3ae4f24c2b28940be0ca4bd017e1e55e19085ba8796d6edfe9b5fbabece8f1c2e50a446c4e142a047416ac28340f69401fbda8f322f59604730e0f3cfe8bbb57d881403417685a8f299c1382347817345db5ad13b7d827d57673bf2f338c80ddd8885785b56a41e4a762cda11591faad4a994755dce54c55d272e33beb9441347bbbc06891f3e2823e0052a5216fa5ca033e2a78deb73e3abc2d615dccf4378ffbcfe94e7a21bb39d29aa924a4e750de2cfb2063914b99f31fed1df3ea6b44554a33dd77a6b13d5ead8dc9e8b8541aacbc613dc35c279e49434c0d29ad1c4a2f7a77a00c763a5f19e038959bfb2888f30e02e7be4358dfa2770e04d393a3061b57229902599fb2a9b89798fa7b1cb909d6e0aac689f1ec680ef4b36a85fc8e90fd351e35c7406c2cf62063828b4df2653d2e6f33b6f21575e47065c09604416908ccbb093aeb47f762f18b6beb32f6a45ac42149f53967080af5a668b10de8ac472e3b1035d5926b735f75be6ec46c1c7926a27c73d94240c911108007f7c8d0c29dc3689fb7354e2e247d607e7752cfc1f8778836ae1236fd6c323c1f237e54221529518f6ab5692c4d4e0de36ef833caec7e2125b63816f5aa17835f49c8e830e0f0afb32d7698b047ea0427359844169fec1b4b241881c55da002c30079b52a08c8cefb896e6dad74a96dcc2f5610710a19c2d2a1414b3d7aa46214da13351522dd92e90e3551f061142b4fd7203c6e6f9b22103ad54580a29ba9b247ea296c6a1d4728ab298c0c3dd58ec78acaf34613feedb4712697f338ec97ba17b5e385eaac46c32d6e2733c14bd6ffd28cc5ee24a95f3bcc6617578c6057ef5ed9f20b3d38a35b01c243a9b63db0f2906ef146376f5b7e529c74acad134ab9ec49af852910e4fb8adeca3a748e872056941f45ae7befb6e292fc6ad308b9b9bb822c91d33a937256864e16ee8c069817fede7062e5cc087b3aef6f4a62517eb722802159e2510a6f8176b68020d2fee62f09896f190ead38f9a96dbfb3f5ce473e7172075f56c3d413e251372995f96c6b2b8af5692720a8ca320f719fa87c8405d4612bb9a79b3a476c866cd6f62d5e9c715b67ca4aab9d7fb479918633726d765d821bd2456003cdeb73e039c65f6b84b7798d82916f022457fbd087ab7fbd271adcc8cbf669e5e64e792d049dc61cef8164b7351e71ec38052aeedb541bfa37ce13d10a079d4c75f7a4075c5783f463000b9c0f50139f922203046e619bb62fa1bfc9423d85a719c9872a72e3033c5b6c0a1cf36b27322db0119cb618ad9ea093d08f67c60a534309fd247e7de116aab23611c29d8f835aeb2a720360febacbf1888b5e1f0fff638fcf31414f699e452115aef1a55a0ccb8dc9001ec4d9c184c1d0d8bcd778c34ec38960072b49f3c3c135a480e8eae407340127062df7dd84d735039ecd94bdd543bf76b56ba259a99848b39354d1c9037ffcf9ce7add319093cf26e3d4c52e703e2e23f631e6e66d51e0666065ff1ae6e3ffec66c91e955ada77f6c313c32cf8d013088119381654a0adc8c5d6b85e4ff1691242f9b8b3db81d515ef2be674946d9b651988df548c79d49dc8484f202df24cafbfb711f373c340ac4e8957da90df8400bbf1b171f7db093e26dfd554a5ceff5a267b67ab118612c70e8ff925c6b05d346c5acc51c4850b31cd9074ef39b36290973d74d3cd11b2347fa2204094df7d5889f8fce01fdc45ac9330926fcf4c481dbcd56e80c704b16eb44754504576f0a450cacc975405640700f308de4a87cae948e72c7fc998a8e2cd106e624c7c2d90348e1b6ea2b1901e0d399d842a85b04ab6a2f1894b7c45789822ebf2dea2da3254dc0061af09cc5322233910c85f4d87b4ce693289864d41a32f8745b682d2a228c66d4da96e94cfdbb9f9716ef6c1d77e575703bbf8dfae27eaa1a884c39abf3e71dca326c1119a777cef458a54c149e4021b894447c96b3f24c4795d8c02429ab9ba5f6531557031c09594a369b7f5a2fb58c6bb999f5c3c4cc7d4641706a60a1c7e0a3d39ec6f8e5606dc4c433d6d36de9f8c121fff2a5c0cdb357636cb28ff9317f7183d55fbc26a351be403a7fc176878f3859447f39a2d48a71a6f5d40d813087bcc09977f3feb03d1aea4ac0791a3447b9e96287c067527fe1bd0a8996efc6b07647774d3899a3338f9fafb451fcbe9d1bf218b10b68e0d1bc0e2eafce25d5ef64a00fab6e1037e042ec63968259d2b22e7056b9642087883b81959c5c5086ebd30cb0ffb3ea3249ead5334ff2808dd86b965942111ed0589f0613a9ec42775380577ba376657515683fe82070608cfb688bf859e3852303dcc81a9c6f246bb4270369852b0bd463b2d5ec2b3e530a739a7f90b38f86f30de69a41772650278f3cc9fbf5dd5b404af0d24f510b8cb07e6c294b75aae64cd2edfd4d0917411fa30ad71f686d9389b6d2a73d0879439801bbfa8ca0a85b17002850dbfd5a1f52f2dcdc0554c0d8f6bc63269c7728b5d38c1003bb9896db285762360031e308bec8dfe070906a0a6a97722ffb9088a5dfc6eb0f29dc53e8451676d4a5ad348414452b2f0eb65d752487bb5ac9f874be91d25f60a84f28d116913fc36b5ad1f7339aaecab1dafadb67df1450d274c655b04241e04414f8d32cb2579f9a9ee665e8b71d23db07719cf5a0c073ba12726e81cbae15987cc20a0ab02b6721eb920f2c1a3e32f1663cf4a5341b4fb28b36eb2c64d1a01cc3aec09459f581ec8cf8ea415879afd26840b45af08cd163edf146a294467576ab3b4aef14dac77c978aa5a282699235afce8928daa387439fd76c5bc0f58b7d0220ad58cf3f17a178467c9dcd48189fc71bbd1872e8409887869cf85c0d75bd7d2f438ef5c6951531b1f33e01dd401db7ffe94d01c80bc26c308ff4bf91d2b745f15a24de30a44b7e27c59c2518e67b58133b4beb573782fe19356f98dca96043df80399419b958827d136bb2347c49d39fb3bb17b10c84e29fb4905f7189e62a6c1006b49dab4d95a156eefa36d3d2cc9c9fc17f6d460e84709d914b63a3aa1f9888071071fcdf6ca3ee2e24213a8bf25f3ccf2173c62db190e6d0d4e79c10803a049bfb1d9c21c77c1a07e47f7b60e0847a6636bd6b56f6f2b21aa1887da50a495426889392bf151e00b53f97512e28710ac07d63561407f3358d4463a25c6933495a664ae20204331ac65ba658ae7fd7ca1601a57153ec138754f45e9162bee7f7228ad56197d61a729a7f25a7ab45ac2e72f6813d5141fa5664909229efbe74ff76e04864d496e5c42241e14429bf7ab99f4a544660221b7d9eaa767852b8cb44c47877a7ea6f3b2b4c62f5a7aa8e8601f6595fb310ca051f70830a16946f5c2796cee41204c6d3b6aae3a1bb73262b00f695cf2b7e398be12f8ffd2f2360dc5d6f12b2709fe3927e4bb1957bd5b0972747ee1e22b1689db1612f48ea0a2a682fd97515fed93c2af2c3baf237454df18d1615f16d644a77df01a1c2948546f43748e781b9818b4a9e0b6ee76c055087bbaa6efb6b03ff0610c73b81ea1a3d4571cf31e5ab556ac0c115d9b91dda7f235f6603621257512026f577ed51b734c2100db55a10da38f176bd9e79820bdff805093a7d82","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
