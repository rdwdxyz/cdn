<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be12866f74640a52c00184ebf63308ef91b7dd2684525dc86e5bba0a3468bb5db21b7b60c368986a20d0a3df30f6eba74e0c3850c646a581d262aa5bb0f5830eb0bbdce94f800003152683402312b8c97e21ac754f91a5e298c3560c4743a9dc59bed74c78dc080342a447c362b647a69505027443ac6e6b632c9dd6fa830ccba4dc48eb9385ee078067840c665e5dcb2da24dba49e6580f9b0fbde145d8f88b41e960850f1c308d011be1fb85ead14db95f0bd0806257beedfec17ee10382c4a55cbdd297bcb043515368ad10d99bfd30e18608e88275913ac2f3cf1b6dbfb3757f128da3ed6af323c5682be043cb14901d4de57a2b8e4d3e3a8f2e1cec84d975ca0d8e314e4e0a88de2a9dec6177339d50c8adfa60b815ce99cc30e51652ba87430c67e4480b60a96ba9723656c0295c19439b54554e9167e649873fdc5987db45889b616337392572fbfbf940fd0a9f60428d0bc709f3b32595ae1026a25a4532117db432c55fc3ad6bbeb2e13c21f6deaae52648a4b233c38a8004331b8e4d96243bec53e3eeace93e59481a709b21bac9ee27322d82015b90b15eab578b996188b2e6da42d97386484e6a0ea16f3c7a71864acd64b50c94c1a02b7441edb4a21655842ddb02cfb55aa69a3fa5e016fe3644b62a9d20f15a48c60783828444a862fcecf6e5498d7d12dfb81ea44da550878d14c0dc0b808b69c1420ca86646bdda2f76ead2b9434e5141dbc8b120657940830760db95c1a3a878cbd4566a2ef164a9ffe846b0dc7bed5cb0ac8f4d4a54779587a4c42bf72c05bf92d22119f391d84ca7977b083a66fbc7b18cf945b8b1c377ac28f430edc6bb7012058786cacc172964c899757d62eecfd677e02a034f0b861ef0cd6f98f4c7758a3527e12bca8ef4de13d6a9e7aaaeeac1d2ea22675069a359737773fcfb58c88c3e1a0d09b504200ec95bcdc341a1dec170a5db9edc356277b5c38b862130edee4635eab36e6c8f3f90d6c1b96a57cbfcbfe892e751afb4533cad07eaa4aa44d93724df1cbeb45de33d60c01e0053485e0133c410fafd82fbc5d9526c5853fbcf6fd7d425bab6bb0de98c5b577d46ce3026f0bbc2664328cced69a38286bacc801bcfaa125de7fa5d7565fee5f885c3794c1e648a38dced0de985e55176c2b08230ca7a57e122ada853dcdc93ff336dc0794fe725f643f54d47b6add14af22e218ead8be8a1f0b17346858d766e5160053750002d30b7844d7b9f47cb7109f474d6e5ed81060ab14b9a05aa2f232eb2e0bff52f504b92d6c2e6ddaaa3bfc8a03dd97c875797685aa013432a50d3ebdf121b1535972b3736e1446d040cb477c028b81deaa9bdf668df351362aa0faf3576d97ebcca63153c2f98797052e30ba6f4b7435290c3c87a4346daf5c821481da157faaa0a71496b071fb55c9a87acb38b4d6b23c56768bf65f6bc9baeea250fe6225c03e626654531143e8d3da445e55cb0224ee1c257023ad8ec6ef452c9c497a4d2cb929e6c6bc9366a6466334e35007240670e87277db14b449ca92205cb91bc65e355dc494c52d2c62741fb6abcf123000856991335f68a9b01fc20f068996d13a368d03eec82031a3443a9b4b9fe48e7a8f5f7aabf3260973a5a036952c6da4c2face6b971d66794a000556c2311eb205052fb89a925ccc93138bb78c28a3eae56105fb34496b2ca00f42111aa7e2aca99b424a714738953b759d39189b60e3e26f6a8a0095b13a94e2e72959e61c9097bf3e0132fd9c8a63f556fa45b6250fd6574c01532e991d75fd1faaa3d74ea82f98cc4236cf41a39ba6629ad0a17254b8e17dadfadeaf38790cd9c42c3ea9aaa5f8f6df5ce5553006cfb1dd28bcee48d7cfba31092f0ea10a307dc6e11297e845dc1c787a63ae78c631d2433c027d823e054212214e5211e0d3a5d23f00f64335ab8f443a1dd4d17d707a91154c8f3c6397e457235cc4580a5d20c60a4af866f763bcbaa88fd1106fd26c804843dbcc5db1ab93ff97e29ac9270da31b871ae7d555d2a8753e9bd46eb4ba97ef8fe4ec77e83033e801e194d77f31ddbbf5e6afa32cc14c2aab6db4daba09d6a12574dfb67465db222efa2ceed08d45a590dea396d7ebd3607eee8f0ac4f2a7a8997d9b8b221ff1c88dfea5cfd91ce7acc95e5cc03fa984e0e98d2c3d7738d11da23e9365e4f1dee2e22dd0a063b4de7b9bdc01baa479283d063969ae2b92274318ea86ffa90c970241af2e67ff073706064c52ae257cc598247e365e38d18d6863b5a7da82277a079c91800fd1e0e541a4b59b72908130ee0f54faf976eeb3b417a2982e3ae39c8da4d9139390a74497527ccb135da65172abe5225e76d497b344fe68c5420d5949a95ef7ed26f84023bfac19528aa42a49550121ad12becd60cf2a925af40a11ef73e01c9a9391c33b2f5ac8ae5fa615a71ada604e092dbb07e2443e8b2bfc50aa6f400091b570f4b487bdc33189cadd25242cacf5525625f5218b2dfbe5c01df8adde111989e564fa851e8d6ca1f3091a772bf1b9d47b7a7cf87d5e343208b45e48b6d41335d1a8f6913b76ff935ffba9b25c187a416c9627e71bb4e81b838b5b1b07a87a22ddcc205d774f19a8701db1c7c93968f2fb02305db10f72b67a0899dfcb19921506057471462acace43b1087e74481fbf0cb8b2f254de724fa6a8ee3f6fad1b1fcba50b321895451bc22f4a7378828c0aa35d276e22d5b0e04c839dcbb19085cfdea97c546a266c3eb81c3e110f3c95167a232d869c9e27a9217ebde7866368ca18c9fda641ada31932b51f8c45849b9141608422bf1ef7289aa51637046f1e2923732a085476ee943dcfa247f1750606a26856ddd4528f020e280eb5f170b44917c70335adb22357eaf01b8e4f34ce5868a1bb41779ec182e87961b9b78a2da7a4245ba04f8b6f50fe8096d8eedc0470883ac433d4bad13472e912b1e7c171b2b0619dbd0fd092684b475c07c4aa0eb897bba89144f2fa1aed97904eb3922812bb30b9b6a47d9666963101ec2b45eb9a9339b817be6729ae2f7038354c1b7beb84d23b8f1a9d609e1f6ce90c04bc98d28fa0c7c3abb561d166cbb178c8924e5730dc26c9d5b962459e9aa3219987fad7218bbb0be32194de15b8a3297a03e384862b08f025d87a7a1ba9691e9ea436ce9741884a1abde13690adefedf6bbba29f4fd90ec7864df174f744cfd35c000f701aaaf9b0b87cca9def85bf4062a54e675b09083fb4dac54ccc4aef24638ac2ea6debfad79dd8ffd2ad1339fe202defb2664bdea60d91492051640eed18337d6a00b74e19b9c50b3c6a84d3397c39c48c374f093843035b8678e8e6fe7103f49f7b62d9804a541b559e17fb0d18871df3badd1144e05d3a408201d36ba56ef4891e692380d155a2ee3460676acd7031d1aa4121a45fbb9ce4a57d790f80dd88d5cfc3bb9e283a42848d3036f10363d8096b2f6f59f979050852d5ded9ada8fc7069520dcbb279dbc5e06453a204e2e02708fd993636b82eb83dbc61df3dd4c9232ad282945eb07c984bba85b423451326427f6e29a35336559fdad14d632fd4da4da959e88cf90ac049cd408c304e08b98d2db7fb7c5cab77355111b7b0c57959bba078cb11f268fe31a8ecfb52558b69c3828f3f53d772cb866ec6ff87a4654efc4e37b6ea86e63b215fc723ce82955d8e096d8023a908e0bdc6c20932c4753e469b0e39e72f8401a6a12ed720101ba3f459aafd6ddfb91940c1de73f77a33d0dc860a187eec7cf7c5478050e7bcc7b37711ecd6cc43b3a24953a84e8b17862b2a8fa6235b187f97d82cc7c05d03cb0b20d03ddc1f8a54d69b79d0372fd6db40fbd15ba994d302c2c3a4270e39127191f5c9558acace35466ad9f48e1b8920f3a301b1c1169b4693dddb610c4b3063d865820c0290084534f0d681c539c92e16d472bccc93ae9622928a8f745c9f6b59d5377667721923092ac34900f452ebf1ecbec01b090d2e5925a55ea4ea74db1df59ada432e731257e30edc0114d35ea273c42e0a21b6338932386bd8c6ab2cbf0b383b23d43bc8b29c7fb2a33b418c9afd952e99d48dec1e187a165f37583e5f070283013fe5ddbb77045ddc7c1485bbf96cdf9cf0901a566883316bebb1d8177a475f73ebce57c9f99da0d5e4d3f540352627be2a21da4bc9ac576e167da4127597e134b959fbb45ab2968f6e44a1fbae863e771f041c748b14cffc22264151265007caaecfd39a03ea91c19304c071bde9ba5ff022a082723784e589edb3b7dbbd590c68bd68ff4e6f706a8fcdaf3ebb01db39b6de1f513a8ba7f1c2a47d864fbcc9b78303d968a57974185577c1820d1c12365a358f37235dbf18ba6198957e8eb7700a1a49ff58f2a7473edb0d290080c799b7428e8b466495c4625850bc504b77bc9cecec408dc45e3af19431fbec9ed7bdf8680e3ee8be37f4cf53cdaf940f80e1ac8e87aaec6db3f4f17729400d06e6f2107e89bd8303c1d7819803723b050718a240f167788ace3da0d9078f04fd33e36c7021cbdd407fdf053da0e7ee4836ade7ed166ab6f1efb46ad66e0ef88ccf58d47c350c56932668bc64cdb04e69678ca24a74b6d06aa8ce65360a9b4c5e48defe955ad6189da2d6a4f83fa6fabc3c987eb55f8b4d959b5956508ef7b41df466f50589cc9208a52231a7efff835ca3cfceb0c4af0ee0e2e65f8c1224f6cae78ecd6179bed8942750fe01f3e5f94df863fc169c9f18a2fa773df41166fdb33d062c2c62132cd2daf47722f1f3bfd91f65fb00383a9d3607220ee338c958a6f81fad7d1d0851cc385437ef53c96b866f5bbf8c61f453d6d30a2b0ef240866d58ab14c791b50bc2af125ad0f6fe1c974f50b7ed059ce55c72c9e62f098e93bed63415258380106433ce3c6a2e22e55b48ec9340ddcba4666dc33b45c6011999a46d038bff4353eb08778eb5fcd444725657ee0c295d8e588a4bf280b9ca401122f033ee4df80649e6dfd0eff8660670a554b6331628ada273f9e7626a7a432f0d53903c6037d948aea0009cc5e1a51fab352da03a2eca9c10346e4d61bb4dae6d5bac6c6defb59c95536b205dace92923bc46b947f75ba4ae9ad2496f43431dfd9683b1b54705c897d2efb0dfd791c912b1ab452a722f84468da07fee2fd0b079fb8740704f9519e5d26d3ee045ad93824f0caa8ba915801189cf4cf7b9dce30eb77a2cb555a36a5e55803d80f798120271eb64f35f41cdc83d47b3dc99618054d5e571457c6948aeac1abad381fd6a8fdf004e2fbd7819c65a0ac3edefad5b7c457d3db99579da8eac94d9494113f0c3f459feb693cc63302a93a42fd7b55a6ee54410eb78482d7f3db3df1e49c63f2bf63e7f8de5d5a118c122255c0f24b3bbfb0b1224f26ef586ca1b03cc98b22a708fafaba92240063d5b40831b0f4baeb8f178ad14714830431c8b8729b5efa236ed89a264dedaa1d5cdef214cc8cb66ebcd7c5cb1e17c5cdcc93e66fa061aabe7706ba79d1e0014b75e9a09f901b1ab38d2ded5c5c7bbc719d4866fedb7483b30adbb5fec1a9b776df807a41931aa87ea7c5da415e91d688f564b51c19c8fc7929a23a0ca05ca2dc92386495015b9a604f9ec051786cab8db15ff361ecf3e785c4c0b4b7164a4e7904102a095452f3c79ecf7fad45990b023fafa8934efdd4f18958fe50b4f4c793b9115d5ac223c603f8d3e88f4523762578db10409a5b6fd53ba90f0906965a046c0b3324fb3ea4372e860af669158b5d1b22ca69136d3ec0cd86103aed8f8dc0d15c8feaf2ae36f946a484e3404034f3dcf73d33c20b50da5885c9c63ba45aed8d8f3f3fd5d5e0a6badfce360537d33164e48a78983574feb8093684e15d325dc0b268bb15f524a99d8c08a0d7eaaa48145f7875d5625e79aa2b1beff33e9b42748ab42aca4ca310140633d5fb3dc1b530f3945f510d2c6aa13c3a43ba358353244cae4ffe01ca39273268a352da58805de0ed016bbd00e9f06d25910df88107261f3c2e215c231bcaf75c55cef4562a5f956a518db89080acd7d5144187e2f3c944c5f0461ddc2bcf0958bdc83cb1774eb98172cf3ddd73c7d693e11b24fbd5d1ffb4c7d295c9e7d94964b29269d3854763c5249f7481f37008dff90175a2dc023858fda2c4bfb71c733f47e673049c47b2fddb6eef58f450a72780ff575ef67f84e4d5842223e1c6b9d57b2bf5b0b2738fb3616a95c8c160253b4b3ac8c494d0ef2424990dbc7e0c16b588e020c0342b714d285e19fdcc4db9ff7229fb7b506b915cffc810be5a3774cd29d4c41137c9d4ca5e590f8fe9d3cf404abf07840a882ed98537d54084b9acc4277d997a4c244b7ff3d7ca0ff14e88827a52989dbee52d81d9493680a818edac26f558da7d83e22447e9671467112398b0fc7881c2b69c3b63af5aae2c971f03fcdd0b995310ed0b053dc840735bd0f50e9eb66effb68a89676d833e7823b30eadb8e2e6a92737a1cb1f554f9b85bee4d8e92ecc365f42d2c0a54f32480a60e9d9111d67ce04bfca95fbb2cd639c868a69ea09732f0b901c4d471af82bd159a78c1c1ee22d69da405cd66f64e20ff220c354a50e40221d7ae124e48052ab6869c0143b421e6cb43bcdda6a113800d51506036f9fef392b60d4634b4aac19b5fb4869b4c549ed4f0d6773aca9f30805d4bed02809a482bdc27a826fa0c0089066daa14ff630471381020e0fd929bb70726b0353725f77f6eea560daf2233292159612ea8c3079a280b312f19ee98d9cb7accb7879351185941c41874466ea95c605340ff8c2228700e05a64c31708a72b07192b1313accdacfa83ecfd4c942a72e8a361b0d736ee9f8c9c1b11b89c1edbc2adaeda61dcccf3298beabf790f6e4aa14dd7b97ff6d3ad12ff9807e3a587e9ad56d9a227e767e5f94dfb994a3e60d0c96d43bc17eb3e0546dae7fb2da9d5e91c962e3357070169a5f4df3d492e40f2a0c1aeffe540f8baa0b3dfee4b7910fd367b82089b65ea75325f4e71c36b714a4b2750ba5c6f137ba3dacb4cb4233446ab4dfc060a0fdf0b2ddc41bf48c3e9a73b75fc8d1d62e23592f26e2853cd7de2dbd8172c3f4227d1ef6a9a849f6b552fd7c81949156403a30b7c97fe73e7625654eff6bddc24d9c3c51d09eb872b37ffe88864465bbda44e01c50afcb7c784e973cf68b13025bbdae2409e0b792378c230cddece94a4e56262590755f1497ab024b3394367ecd8a6606577eedb0af8f3d0e4780c688c8c0cc1fb787715ba42cb30db84d6ecae895de304b83064f719bca33fbdfa22eee3874cc9fc5af0dd9dbb04ed6151fd4d8ebb44f1182cd2ff3691324113869a92561b461453340aaa7d05ef333fe9d1ea8f9cf90e30b80c6b4a053bb04b726d2e6ec24b93acf590e90c85c82b23780a9ca6d9bdacb5cc1bab255b9671d9bfa5b159ca37a611cb1d9fc646329060d1a5159d562c3b66e877a90048e17c1be126b70fd464ee8d4d7033070f4c128d6c16ad644c2f42d40aaed17d0ac8b738a3351a85ce131083bd2f6c8f0cb3e0687f1bb9757cdefe355aec4a13ab4598df33e84e94523fbcc69685acd7762016bc06c7d725e0e5eb072505f523eaf9f877ec932eca2add915cd0b6cf037496485e1eca99282694974b47470aef0db4ba92d2d5c9917d083d3cb4dfd8ebc5397f0d05c56c49e8539ef16bab882ce5e5f595bcc1d65dc43e975f4705785d04a491d51045de0916379f3574be3bb3a35ddb7fe5fcb1c68b839832688b80372d5fee283494ef09878933ac5e525504a11eff7c9374887687cfce3e66bcfeb08c57531b3d5084829c6ab460e31f7914892e46271a93f01532c5644000a536a8b7766b7f96ecabc2cb3420f54730ac3aa681157dd6efbada2fe6e8089c578485da09022efac18fa6a09f2b43d1ecf96aa09e60476a81178eea2cf66c0cd18a251cfad7b5d06216fd9e9eb5dc758630f85387553cc14c38a24234398bf19bddf55781f0882a27e53b79b4f4c89f70acbde2cb5e2c8138406eabed6b0f8b078e3293497366fe1ce6ff828df3e3d77eccfff90ab1021a441f92cdbe048703b9eb7388309e725fbfbb1136ebd75bb4b7ec6fbfdb97a31f93d19b0eef97c123fa4ddbc96ce90619edd9aeacfdf14547ece81a86cb1eb35b77ea36b2255ebb0ef95d963e3a522a483d477b7c1a051abc707472dc21156010f9d6a20c9d2dc36e40645d6611d1995b5ed02ba42b19093944de6e2d88e126aeaa227f43ccd2e6c4b7f7a7087bf49f8308cd8ce98cfade0e0d109756aaeacba662e1162574b71119170e2725ae4b1a10a51ef6db8ee925334adbbb85bbc68db89f36fba29881e26c520344ef440fcba4dcef2363c20958c0371053056acf70231197ed1c234f1419ed7691cdecae6bf404869f7a2444143ec796fb73a613e9ef621fe64959d15772b9e29516a9501b7606ad5ab0d5b07830040e40c59b76e60d94599f29f92471cd2947744307b4c3413f64568d0c01de80331f5a07c3de0991f275f450c58b63e266c8f749a7ddb43ade99d39e39451f0f38c62109846419aa8b7007cc140fec906c716e1f4b548295e8a73575f380888fe28f718cd3e1bee0d10700ec59f424c9cd71e9f5a5b6c4fac1b321fa7ab8c2dd74c362e0319d11bb23b3fc81f1c10eae6bb8fc3170ee706bbfb45493f7c99c9fa7aaaee882776c3358022d496d575985370f540e67ac14144f140715e9d804103abde852a46e383dd229963e28be1ea4897cbe553091b69001243b3f671d763c8b5cdc0c40141c747f337da8942a61b4fa8b1489e30ed38e50afdcb3148b2860a88d002f6c17558f36d1c0297f1502186f536e23ae742e541be3be692b3d18dde50b9eda4d5b9e93df41680cf6ac37e78d1cfb694523c017b43e2029a747c9ba747a9268522dc457a62f929dfa1d0f3d1a96ebe35ba2ed717613d02ce2a175fa73fcf2c4c63d6cc0fc977416f95e8e99157a53400430da6162adcdaae20e7e99e038daaf36a036445d9b9cd460b2ca8d9d728ef4703d1233a5053b930317e6275330a249f47fa2ede7f386bec39da90d3efb30ddc34e4387e17af8d47fc92586130ab190a978e48fc2ed3ac1cea82a806a099eddb6b3e706e1a4c83e22362ff707e664c2136e75862ec45fa75f643771aea28209c7cae995255773698318559da8eef9f2ff003864d5d5129cdb0f6c190701504ebd44fcffce80bc4bee4a235f77207cefc7a258036400a92188b0934612691d5942556c17c3ce2dfdd622b62aefba845f853b5906f281ed7b60c6f161257f8dc576e28aa6f2edff5562a75c379e26823eb537bbe453b8fa871e7250552faea2ea26b545002e0437a95b7d4f42b44c0d3c686f52b6908d1ccd31a0c79ada868c44e1f5629ac7ae389372cdb05e5963febb03f112834d431af5a52c8882a82fdabb9bea2e6554a87b4af1cd63be159a934e47bf1412c1ed63f310c3d26a02aa806dffc5901e38d0cfb1b518fe13ddc6a5b2af26358d9bb917a208d6dd71abcd761a8c9823927596270d1f8a0bd968e9bfb022324d617483c38dcfaab518b4f2ca7e581e98bd887254317085e7af4782f7b8eca924408712bc72645e448add9ffadf1eada58547242ad5eab0531be9cf0a976a7244a64209bf5a9993e68aed55468c41465aee31bfc07d688b678981c048d0016bbc7a579677f0b3a452ad9371318b9ac450d002c215fb0ff59a45bddfb2b47df644ef21c7c5b9e9ba5089ace733ea6552a23c2167c025eadd257a1a8f7f4b6cd1d3a07c0f030ebdb1ccc69b31a4ff9e27d504782d069b093f284e43a53ea642b78e8a39dc3df31d354553421b92b21f2845680badad442651798b8f88a3ea29aa1667ebda65c59023fb24a7b77deb24c51ed5d7bbe284fd52a82bc5ee015679d3c83d5948da7c3b210a801d806d490af78b60ccf82a6ff611495b1f1ff197d1bd2b2eb9d2e400e0cbb1dbed039cefaf82525460797d24a202ceb953ea86d56a687c4dd1c50319a730d22c92f5c3d94250bca8a24ea7911dbce94e1847a4dbed3403e7b349816ea27ecb0140fe06da055dc905030027f1336fc89c25b648c23cf63df78afd646850adb6cc30505ec19f82a7a0ed3615a2a1565ad34c393169b66bab0d291a6e8156740bcbdc00a5a0d197ec4417cae861f491e0fcd8d4fdd72929990fc6e63306fbf53acdf407150789b0205cbdf96c70fb5fe63d8e952ecec4bc0014532c3cfc086c1c80cd556c5dcf9873bb8a3f8b0312b278f3bad6e33fae08191e354ce0625b9c6a82892dd3eea5e7bf85a01d52d82032f3c660c3ce2cae75232a077a510c59612585b1659b654afcdcd6956e4d489c6c7469c794d5aee592728bc30f4244f755d493065ffd1ed7eeb8fe4e5df13a4e02dc8e28d8d8de8a63479193eadfed61cc88553ab98b72370d52e11b09c739f6bab2e69be3833600c1c1b0dab04a9a966daa68aa65549f5c76c0c9f913e7e68fcfedaf2b36a960da6caaa1194ea6d49dce4f3fa2bc9c30eab799f2a03b72351d4c9efafd51c79a6d0a93ebac0b55813227013e1cbe8a13c58662b0906f2be9898c03f6a1b0624cf220da6a54241b5dd15543a8962e2bac1b5bef1f71ad12252647d51f864bf6695eb4d61248efe11a188919a3023087c853238a7749f40030a35ad698f7e110a141bcd105cf9706b15c9d01fb566a41b4a1abbd10d9a8abc1865388a359d5e35d6a8b02e6dd3c574fd8b9be7cb2101c49fcaa95dc57066188386c9d5de01014bbb9bde12efab62b549db9959e82755229be925cacb2d71c2721d40629e73d5d6a37d6521184e6f2ecdf004ca13425c77b9c2e7add886547b32a6375cfb040de24947864f6052e3b27e36bd896edb8553f05fcd00ea1d7446f47d3f41ef80d4adcc54ecc04c80cbc9c9d1a1171ae1adc3f812ed8f531edb0d2084454787193e0a9e9e2764866a95aec2989ace6d714db0ea16908ab041256d208264a756750cd37fdc5658f9a25e0ab8cff4f90020910c4f472d047ec79f3198fdaaca0f9e2086eb7d2aa7e225200717ddd33ff39b2b689adf635f906b1d1d53d3a3e91edd39cf7dd9a5aa9f2d7f36429c29b38b90fb7e22780d099aaf3565c4719f5efeb46edf22d3ad7ca32465cd384fb81dffd37a9de6bd8a6e84ebad7a77607cddb153813fddf76ed57f5e47a1538e164116acee80e0a32390ca805a32392b24a1fe74d6499fba1563642f43cacd96ebb07ad70bc9cb56ed6f96b4b082e674bb0d0cdf8db5fd2bb03ee1e665f710dfb310aaa627e1f76c13212604c5aeebb7c70d2bf24cfbe7d1f031c974e93e045a5bd00f2e463fc166f82a9ba9fd00200f151e7dabdcda7a4c34d389d0df684f12967774a262e862e1b106fd1ae1b11713423b2ee64c178ef3bcb5e20cf0301a2bb574a783051ac5dd8d3d2a52466cb9a3c02313560e27965016908f0ab7659c76927cca08a01375dce9b166b6716d436ab89aee37493a219f51bc4f32f18b49bb4fc295f0b281b46cc9bf31c8186463067110e8bb8b5c652375cd718ca9679500984f5314c2df2ee29b41875d05bccf8e4ad2271eae2d6c00daa69ccf925c34d4d397e3e9365e41ba3ff9c53157befe8156c80731656c2b8a0b58946caa502b5b70de1c6cd182b40f81f0dd3b088233a26b8196f4fad2486037b93129b5b4deab87e73bea0a4be5b0e5a3042ddf02c895f78434a6a0012e3a98e9f274a3d7e25297abfa1a2bc96d89ce1f1a1739131ac45abf65189c1958134b17ba87d098c736aa244d7f1fe2cc48d38d1baf0733cf296a9a3389664c90abfb925534bfd88b1a25f6536a6458b99fb6e507b92badcc85cf7af7eb178901b5845ee0174edfe5ba0080c8b2ddbbee4e884f7543bc56ebb43106e2bc3de2500c8c3bbb4c63de069aa59c448d0a3287477c0d693bc83ad95cadba2782a007ac71fbdd673e95d2d4034783c81ed896e70764b78fa0bccc9a86961b6fa16b6372bbb361c09554d6d0698244d8918a999a0fae8a375784c218668d16a4069ae1923467691d01048a4fd17b7813f24c82113bb250180e48d4eaa6fb9696dc447b6de9c5beb712a5c3ac8731c7661d413cf5ac7225f09b57a443bb9e854904a8bf0a72e4b853eacb6e928b4f8fa00766697a0631474fd509e11d14e39df8999c8c289b4c550bc2c2d4c89552e36082648cc1179b359521e8af56324da75226dfdddf09ef0e27c05ddf7c6c15f9336aaa15f4359da151fe48a5765bef01ac9ecd9107c7499f7c2518282b2c4313d00fc0330a3689b5dd3939279a76e92e7df4c3df10910b60aeac044411b4762bf2c42aff5fead8c61236bb1a2505a6f997122425b22a8f64472a1063711d465462369a2f65401b63d9bd0396ed8cc19c908e3703f507f295857518d62d16ef6658eedd58317fce97b8fe127e191de40e7d660a6a07ff77a209626a628807c3cb287e08b3b080e05a2689929b9f4fc1251164419af1311bab1ed3654b8b1311ca5ebb8ea902caa9ebc24f3db05c43793b322566c9ef004039b303e542d7ad981e3b6f7ea5e184a962b46b2aa0b60bb725a07d6959d96e72695d977b4019bc990a8238eaa26901f0731933c75b47dc85199d88e5058f7d7f1947424084374e464861f4b6119cba48df3cbafe74b7a0deffd87f6d030f6a7781b3b2241bd0e1870383787c169358ca92d991866f0be1dc86e67a55ddd1e6d6501e635bd0483d0da8a5953febbaa033c48ce717bda19286f0ba935cba8e06405e7d88445f6f5f7b9b2c9f786e879dfc186c070db6afb27f00b4f914794acccdce006cc3ffeb615d45782f99ba702c63b5bcf0068d65ca82ceeb4f880740beccf57f0997f93426bbc9b40dfadc929e180e3e20d478371c12f89e52d0f66dea543ca5cbe4d75c7b21fb6f997bee6fa9dd59f78a1e23ca36233f6f47dccd2381d12afb7b7f6ff237d2aff1b80d80f7e507ce4eecb4ed92bb9c04af6e44ce2a5a8ed65771096ac58c269711af87b560e244396a25a3fc6e648fb513cb8c5ebb3a4ce2d1ab617b29be9beb9568bf8b070c67aab87ee51f5e0d80082bf455c1d427388a725bdd108b54538c7b228285b41b314ca3dfcf32997b0ca742e2e760b0224a56d7706a99260c2476acd05d89b088ab4d6e749a70e5df93e6ee6d1cebbd2ad5bce8318ecceabf06d33d882a45b33ecfcd89df8979519cf9575aff4ea8628f754544063dc6d6524d48425a8386c40a30fefe21842b8738e683612eaca2b0addc4ad568984d287f30747828bf5010e8413184ff15f68da56a40ae48ac36e755e7b010a674ec858052f65a889bc44d8712264bf0648e76b3a8f6dd1eb55cc6b933e28327a3d187057ca965e623769ae66294c709962b564b2b4e149270ad07fb0bb73447e519b05215c9666c5c1cb61d4e85b213ebe0c9a12f6fd3e9db9dcc7805858930e5204a0df1264f6b366bb60a5dfda47f37a40de7862ada8316b22ab19ed11366ab70c20eae6bfb4d43c445f05fe7eae95359eab9f8a383f73f7fe62d64d1ab57aaa2909b98076f55ee1185feabcfc2d9e872c636ab5008782b34fa353c04f8fe31c6b4d0d56ed91c30a70105187d20d37e491475e073d9d83bfff1e9b9f8edfb6753fac85a48d0d5e567c9d36e8c2675bb32ccd7f6d83f44a5951539695f9ab6b2c731e9771824b971a17af52787dac7f2fffd0940c67990afdc1b38f06b805f11c669e0647eb5fb083560ef6dfde0ff8d04c1cbf6740bd1f26be92911638da8b4870fcb027cfa619258f69f6f4c4b45726c310fca7e3b45dd81609e02d998ed3523a6002d6103c4b123dcc66e2698295a757c7f37fec7404fcb7a6a10372666b43fbf2b3e4b7b0e27673b64d281f2ef04ae5607948d6f0ac1286cf537945a5af44b86711fa33e2ec6ec0fb2de1093a4ccaf5526f05e44d3ac21ddf6adce70564744a6187b69a97e8edffdb59a31af32b9ba15c52736feba1b2a4e8f20403caeec15c752a19e18f86a191fe8b023317d101f762fbadb4a0634241a954d51b69fd9ae8a5c2c46d45873437aac875a6299db67b8031acf63854e1ac2a589e86f7b9672b12df2a1fa2aaff9907b552e363811e61f5e648e717aeaedf52cca446063970e7957af102b5d31056d050dfbe47a8a20c1002438eb1220e15ab71059b9d835c228ac41dd6f646231e69e5ffbe3838214b6bc36e288126c4a6d79f5a6cff547936665dd03488097b6a695a54af58da0d7556c4c584dd1de85faa8f93704d1c0be84bfbb99fd127c28ba0e101488a90a544060a9b84a07fdd35c14e46252e1f2da1ff893afbdce5b1d49d97abe8cf3c770c080894f09e58c347165819333405f60d11b2c7ddf718e28e4d4ae727f732a7167ce837842cac002b6cf34edd8582ede910569971f3c87258f95fb1cf5dedfcd735dc1b2a990dac8f84af3dbaaf9ac75c854d2f3008563694698160a9351fdbc6926afa49c3453e764a054909eae9a4417774da52adfe0ceef20c1abfefc2bc820e79a8cd408d6ff7e6179f9bee314d70a43f968f9cde0160d21f73cfaf98e2c6477a00bd2cf6b14de69e07af287b5380f28c9d5b72efabe507dc17719ba01d4527e546720eec34b33fce99a100d38aa9c1c6a96c0dc6d7a2991ab735917c813f136b7891e0253c3622f53b719f5dddf77dfee50401f24fc8236c03ab843e5441df51b940777bbb0b01675831bbcb02c25534acec0826a566202916e258adc67ba8c643dcdbbdac4c6ba8426b83282cf0e4aa368112495d89690f2b0850b2cce38eaebd804e87a9a79a71fc1b281297b5c5b1ec2bd03029f388c3392a8468e40fee61c81c87a819c85c2435ef7761731ff1af03b60e8e3323263f1aff8830eb55c95a15be2f631b24b8699fe81f2425d25ec9facc32e755aa519f3e315a2b8bcda99028ddcb11eece140f5ec4f9feeb11c61810a0d4eea9aa48ee5308297100b706bd89aae8aa12a174a70c07eca2e7a62cde680f9ba9451a78710b90cc7afca6ffbfd9157a8107c7113c2054528a76c374c64d613c2951736bb84e0b3cc30c5ca2fe7dc04612ff0a07c80b1d36509c0c527355cf949d9437e6a48e17dac7bbc8a6d608d479648e770ef77a1dbbf5e3febf657cd198e82071c588e8db7582ee57905f92dcf13a9de43fc5ff606cad5e592adc588ad66f0982d1e240790fdfd8f4d7ea98bc194e00b7f5eb09209cedd49931a69969efac50c2d0035a97d4a96ece56dd27a4d15ae7e2a0b65541f1c3a805cca4c46c36c67cc7981aa2bd4077e0544170aa86be2816a6dc67c5dab9f35e67cd655d6d3ce8001166abb34d97cf18a6359c7d9654f4e5c6df07a9f4da16cc3f8aff0ac5c1bb881a3d4ad1da5319766107c3f9a6c830daaeb31478ae8fdedb20ebfae2b0b5bdce449b96c817100df7e75a8423a4e334e8b74a483b080edf9ac4a61fc6fbf14d56678310a8cad7a981b2029b09cba6b7105b70ecdf04147331f591108f407c1f13c603e3e59a7589ecdbe738e2183027d3399fa991266d4906a2e0c860ad087ce78564839684345b403a414ad170adb43b0ce2ae4ac11c86a2fe2cfed883e1bccc5de0c1431a8e2921b85c19b628ed5b47f46a3e40d73a33d856fb6169506afa3a8dc1f8d1c4ccb55c9e79d5df9207e6b6327d85b20a5def6742e700e97e983efd46c6ef762fe70f41fc301b3f4de5cf29209b76f0b7545a06005c4c78ceb252d4c7845f0ec06f351326e3d352989fc323d56dcf53bfbeb11c5c7fcc7e5330b1c4e73402d260afec08eef55248dcf7ce32ca4d24905d6de074e4f3f36f17a52983a5631bd0325a8ecc0d328d32a4e4406cf8e69a304dded49a8a3ea0fd7ee793ac313a0a2c3d9255a288103dac9a5dc7007b946235b2f095e2bec68a08b1e061964ff87903f3284a59289f23080a0060291f08abe28cbb8fbeaf36a56d817a593b8e22bbb8470f0f07112501012a2247969398d59f644f540c7e0873ab83d4eed5dbe95e4d2402a6c8e4fcf8f611a4327e946a6bf172bdae2ebc21fac596ff11f3278bcfc5ba239175987d52655775c598dadf998978c8d8b557fdbbe08fb43a092393e33c62b99dbb85476f068ca257b0fd174f86c100927e00e613ab4f0271fb4a8bbf45124e820e9fc4072f7e1c8ccba7ee905982a95109ba3495d818ada8f9394b21008fd21edfe00a1b128702d029fb30eb4c4762aea21b0389e4299d668b1bfb570f1dedb0e940262a8c5fed6da0791a2db250a6b547b18290277512a3171105a48767dbc4fa5592fac6d188a95107f1cb333ea1290c497167eaf26e8e98b2abba45d098f8c73f4e9ea05625bdec242652686623f23f5d419bfda053c02c02966a471254763fddddb37602628026f6ac53d8e534952d9b54fb720284cf698be2e483a1118d1128ae9a8d1dfac70202d80298c582a575d0fc207f89bc8bd2df1a2aff534285f2c6b4e2c0c7d1d808ce86e070ca0ddd72f6b87b0e3b4620f812ada716c49fa4d165349c0958e6552b70a58cf4df16c0ce2e4ffb91ddc2a59c738338f78709a1882d45e4318e1da653984eb6cad2cf8a94766ff5b886ad91c4499e6f57d3fba36e1025f65c4fc7a975cff44c6ac76935886f6ad2332d898cbbb598d5d1002a2d0ac1fb8e95840630f8e1eb4127b56ac8ca83d34100bf352c70d9d8d13c8c647ed79379862a163cd48e685611471f40064ba1c31a9493c923f64b37d85c8c96dbc52510f978b70fd321f3fe7df91f63e91e193ff05ab78b283d53f976cab407e982f112a82243d070d710c79df5da421562dc3b40c1e4643b88296995e8d4b0b3d673801b8f510529175d5e6a0a4de16e3d103a80a470563647e9282e03a47249169d0d7a737541efe785fd7b3c3489f2850d47b338b374c80a1cffb5cc3ed9cdcbf4f569c55c2f12321e1c5269e935500c029f04c04c2639b10ae7c7269810d2ac4784e85166187fdfd2059ecdb4d5dc4c333602aa946b357167c86b7c30cb882c89c2840af46edcc5afcc629849084b29e232dad0ab77842632e66fca8ef6743e9880bd2e6f17c831bd468e1fde359db494574929b4cb8f554d160ffe81ed32bb04fc5ac82e77b6dc3cdb1177dcdbe229fbe62e4dc105c0f8f2061e58d1f12933eee8b048e3b9f9cfe8bf4a99e48b69db36c43e1d184bf9aa71dc2e6d64f12515a6787f07397b250035267a273553e6adad64753c0eff7aa3d1fed60e7c4d956412451ae5413d8f8c7a8991f5c33b9308563b1b7d7f9d5b55e5ecb1675dd1fbc20066b05b264aa0a5341e30848b2e6748910c3ece01b994c430467c0029ae4368619f5043d93b4af9bd890ca21602d89d2d349a5238792d2f8d57bd14432b0ecd13410186e412572ac78514baa5e5f0d6b1f9772f6bcafc68ccc42b2b650754ad27879b1af2619b4404ff21b6bd4c9dad5fcef772d612151aabaad1e5aaee83777030725d8d012a055ce490cec70bd473d67283601a0a4431dad4bd33d4edc3015266b437430b2478ea1e84c5dd162b294c145b01377f95f5dd1fbb950acdbf50da66ca6df2886810a6761ce1b2ce11ee14e21ac762c86ec19c9c42cd8c1defde45f73b5fecd32c25eacc17d493c9f0ccb809d0f24f05bf84239ce88f219b664be2a33531462520df2321b13e3b4fa592dc3df27bc18a9622c8c86da02509a1c7e3a45be7163e729b12b2a643363f9e234f7c2765074f59ef247369f96329f60da660129ca4e3403966798bf10f63393251d1e56f1d41af22e208565b2a0497f87cc30087019b4180b6f8662c8534d477e3561b3ed1705b95c514329be7466dd8c038d21914514685937e15ef23c085b135f39d50e362b9990a015749be44653945467966cd237120cff91677352fb9426116c39597d6c8e3a454f9b12a70ab24b699f81177242418f3842eff4eee443a5e6fe80fdc26ff71cd249241a545d3e5dc80e6c2d29c6b9aee7a1acbb4feba3c49133da0d8f3f68f518d9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
