<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0f125c6fc92fee193b4f128b0211bc902edfb70fb80dbbe18d6b8907f96608dbc60665c665ca652eaa729f790f27ada9a43d203a957f32ed8c82244d9bbd5fef2f013c62d14eeb082f80bc8dc6c447a2c698c18ddffd102d816c921593b4d09b1462f42217f0c34da5807fc66d517a90bfebb7a3fafed284dc91cccfbe435ba5de607bf5c648457a0d20444eb9ed5ce10ae9a35fb5e48585fcbefe8db5758044c16ba3747fa964aa96fcb7069eece3dc0535c2f12bc13e4880334401740a625711f3ca72d9dfa99c8b6944398527cda307311a7ed81d3aa0dcfe85e634599133d302d02db4aa14e15534e78dc5aa87b971520dd58fec1bff29b60d821a9712d1cc44077fe671085faad714fad5fdb056a913580895e6488ba188628099bf17033ac368ef40aad36ff1360347c8d95b3e2ba7e0daa7ec91bc83317b0307be90a24b6a426ef36800c345d1e84cf5c5d94bdf02dc91b9d5203ddfc933f86d7ebf6127f711b1fe3a1353e27c199659cb77eb4cd0a871988838f86b060541f6e0bd655451bc0cd0f8fb5b2491a92e628a162ffb01a3586b2434e47c2b3b5761c6f57680373524744dfad6800f68b6598c47c89e0a9dbb718bd5bc13090a8cb30a8491e5ec405dcfa19c02a2cc2e273c991125089cba1f9cb13936575c037fdab8f49f2c5f2f0e31843ae3fad8286ecc5aa8983847cd19b747a588235b053c462cbeb56ad393f7144509f8398d5c4801b8f9d60595cceb70dfdebf05bffba76bebd51e47e1cbac14d1e672582c694f860140d1803f4474c3ef6e9c466a358ec6beab3eebddefdefa2dc34d091ac1fa81dfc48bcb3546638e6a569d937bbf0f3f5ac09a99c026d510b1c4213e67a0f48cc81fbb3a72798d7a00b177986ed06dac718a36b83c043780ae545cfef872d1a70507e313f715b2819efdfc6da0bc8acff98498a385ff19788304f8947f320af83cb9459f884c2c76fb3e4aa6ecef648307d92d0539c5903b8471aad406cf21d485dc7a66ca130a2e23d1d35987e2ee2cf185b150ca5c8c26e2d129e80f8b67be181bc8a20127d94654e468ad9d44b6625c94f06ea90c71904822a7f4cc97b15ed80759af2e465661638aa58fac54f5cdf387eefe860fcf4f5dff5be129adec02d524df618f2efeb31f1f500c49759269aa56300473b80322edde8cb540a46fdcbe5f96fb25ae6640961500bde11f9266339d61f944ed02a52e86ebbbb953ac9d26abf6ecbbc8020ff26b3c8e9d241685844c8c2e3b6d75f9bb30873c476441fa43f9ed7f45d21deed03ca1e9ff430444d6d5ac208ebef22020c7720f3dfc880fde2c7ad0af981e8aa855fc8e86d13c0af673c8addfaee19e4563e7c854d51b66b6eafec567323a95082a033288c5741915bcc3c089b4e56a63e57a9cf3ae87822653c08ea75b8ab801e2e9611c5b596389843d18ea7772e85b8cef963bef4579500faad2d12aa02068a9cdce214e50030c9d830a0314c1ce19085ec440765b2a5b4e861cbabc9711d7b4244384aeb049b63d208de5a0c2f5afec1759034c706fdb8f71a6e64b1367e7ec8011c7a682a3a072e8f7423baa5dbe0c3ad5be8a04afb112cb4b41f1b6684d895bb1080399250bb5903ae8c48da113a4250d4dd3379f27153adc5746b15bb3877b6aea7b77398fd0772f10b0ca5fabec6af401eae5b96f51d8c069323b07ee9bfbe8ac5585fc0c97c755dc2ebcc946d3b8844fa43d80bd1f7e42d7e7f19a28648ba2a2c3c10c78cd97206823ffe5257429e1aca22101ba6f106314ef7e23f586d9017a91297812238e22cbd1942b3cad4204468b0706d5c30d3ff93f0031fe8f3d04de7af979b2d4f7824736c8a76faf79102cc960890eb805e441c032da634fbcd52af2f237329942cc994843a6d8ae3605bbba736a33b9b4df3321aefe5486d998cd75bf5756df7015c12992e79aa8d9cd356e96ee887954b2ebcc3fc8ced9de7b33f306e1d11b88426742ace6de5be9bb473409beff4d5f65da3c33407b18981c896a6a845b04775909ebde8b3a8a0933ef43ff1c16b3488e1df37dee0da17c1a099a2a2531781a5e0921215b94debe1403f1b9cd98bb49a6524b8a4c8590d9ecb467b087ba3ec6323803013d621f56b0df46ae45d219fd4dda5db0582e3bf09054364fe44e4ae4a8bf50f243a98674e391455caf63a23990c5c55855f170f7db21ba9335bf4ff09a3671bc31334b31a724322dce1b3ca6ef96fec7e0c181ed3f6761c56408f799f037e6bcf2803d1d472ee0221ae25eba9ebf4212e8f0f2cce81b5cbafe4ef958e8fd89eda857bba077a3d3449ceee3f76ac487942761589bf913f0d8694eb8d92697c4e7d2224a91c55f69e15abe521213537981ec2fe2f61aa93e9e3da7825881b71cde74830807d1b7a54296e8053280a5bba310e5d03de86fdd3c98cf2de40c61631a8d7e17f607bdbb0503572b53fd53d27ca22986e552adf5e6149c82b879056c3bcf07d504980413daaa4158e165cb97698091002ba48c848a788ac29aa18bc14fcf2afaa58b4781e548ca5e53e657f5f77db92d1613b973622ceb0725653878755afa270474d32f0848cc36ccfb8d1049800df3bec6d616f907e7bd1034cf920954349b23425a2c24dd3a14a20c5f0287d5028840a5f5e6c3c1042dee1ba0fb4ec5aef0576c70ed222528fa0dc8f90a61586cd986a3dad8c9eabbe95675dabde6c7c8d3c3a9e4912111ad7515aa53513a81fa79ea7d6c478af8827327549f6e1985c67b60487a759ca343c6ad1ed27c458f7be62d28df2ba30f20c9d56f37a669978628876b5b594874b3fa2a54b6de443f23dc53f17ea6d9fbf9911092e57d63fbbe8c7e3b630f87c6b562a4e8e0093469975dc14185ac330f9888fc94c00c887deffcc856c0e44015d2292876cf5c9b5db9201979bbcda6cd39be0fe1a4a7c3ed5bbe035725c85a3dc7283b4c55368037585e2820ed1c0c54f49963d564d4b7b4e95681a6ab1cdd3f68ccc6ed9e724a8e21ac59101604d7b5ea778248285703992d32ea39cb81e28669d13b889484a3a9af8022adf3a1284821d6a3b9e193116b6d50d0f617604dc595f0d8091926a672012bbee247c9aef2436e589ec58b83131b1e26129e164c485d5239c9c9b0b94fc941ee5edaa2eed2b65c820aad7258c5f11a7623f308267667f993b9fe0dd20e2d6c14e136562383520ce2391484e81d6667451be564754e4c772c389a4546a2eceadb0f9e2efd6e3340cf430f013f6bad119f7321504b8edcd44035784cc1dc4c6e68f38fc7874313efe5c397cf376a2f0809603fd22e7557ba1734d1dc3d84c3762bffbabe8da3f43db7b26e32f5209f02d8a50c235676842e7d39d40f4802d70da53e91e52da077f290a0620ab3f7cbf30ee4c2e559b646852ac50d2d10212e93095615ac299363fc6c8db08b2eb59d5ab0e141b26a4dc8fdb872178bddb69327312682d2c941cec22ef6504fb383be8be7901643252d871bdda724517ca29142152f80ce721282570d925d9b9c24274218d2221d61a6d2934bcbe648b902d36a151a57587ece4aaac886a1bfb064ca327db3ac7bc4ae76bc57281671abd36764ae99f3a6d4bc8838112d0137e612e8766e2745a0e4d65da2e9d9ea8d1183c67627bb024c09a579f14e01cc8aa721216e9535f70ce9e839f620600a21ad319ac18c070e4361356710efc3a83bfd6d2c55ef1038bd04a084c4d2d70d6a2e56418fedf37f20a9d7167636a4f601ce043d89a77035aa66e1619253465d90af63ea5f4ac0d7590e4c10988b7a22e935b72f8ffc583885d636bf1f1b4fd57f773bebad5cb2787cbddd27c5f5ef87026f631ba152d6141688bbce76c5705191fb8297b279d1ce0c41d867fd2d788a22e34b6716f876712f5ec735c4608dd9256a697647182fad46bbf2da7b281caed307f8fbdc37218c1a81c7f3a29220e165bdf8e49df61d0c9dc8f5d03ea73e8c9566e67afa0ed588ee43d42002720c75da70b070ac304585b36ef8bfd1dcbf571a38e6e358c10c3738fbdaa73c74764d0cfdec44ef324ba56df389b5d57c73e8c20a0b116e66b98fcf9e306ebecd59a4f4410a5b94b884d9f757e62038884224cc05829a99421fd7233732ac47dab427ae72625d4d3b52eae0e4f779815de65541df8b2d63b8c8d2b7569d130369379a523ead65e62576a824bc4d5d7e46ca4c865b55a8ca8a4a0b78e4a2df27e260e3a1e6ae5cbf2b8c0f853e5d949afca69bfb71cdef327345e8bec5d6506adace6475dfa2a89701b78c43c4759260f2ba336517ab98df03dd1ba1d0658f7a0b23679a4b1dc22ec5f25d633dab18b2c29a5c058cdcddcbc567ad0cfed8ee78fd89ffb4d16bc8529715f4fdaa34de9a814a4569d8e047ec7794e1b3e73c1eef5f61e2ca86f841b248ff5df8d47aac6930deeaa8157be2ecba6b5e488be215ee877a79a5900f73fd065120a5154beea2c6cfab1b9392018d7345219a6d8012b801f63b51fab83557629cd3a84560013ab391317513c9b1147f72e9df787153d6503171a50e39aed71f312f5a41291d1b9143e14c10d09acd52448b1e77d379fb0e4be29e801e3410c6b0665d89232e433a88132ea0943c5232f2e90571342cade6ce5e9e36e8b9629dad5f441208725afb18b6d8913a1790eaabe12759c71df237f6d5d77a37b8cc589035027b50a8a22ab6e957cd7872e966646a02d66e518f07f5c999243033898176f4b3b2744efc47416a35cbdffaf1f864a4bc430176dc2829bba539d3db7997879bc430d163f7d3bc8821ee32689732bfd23b84c926023c2f05dcca8835df05781a92fba265ee1017d5765625353a51a14bdcfece21e88c71a67c50e151b7e4373aa2f4f6ca215fcba3034a0903df15a8a9d7bc8bb36fb4c5e522fd77e1acfd1a90f869862e0a10ff7e48edd57d27472033d524e23cd6b8f66e3a3602560f4651aa7ad2c41ccad55143b8767bc5e11b5be6411a193b29cda7508c992b0010248e28a8cd9138b5740d2f7954dc33485be23dfbc051b978db35c28a95ed1aff91c6a241b56c23efaba781aca3dc8fb50c9f90a95451c8f131390605d8b67fe859459e6e3764f3259e762b1e71f797e0769a1f25d2a64382e7efc3a1b1aa7e0f5432ee3449ca527cc79f3b79acd02505e2364a0c5227c3433b1270e3e98a43a62d140dfc7af0c3a1bb490519a1c3ff7de4a4bcfc05c96c7a37977a989bb91bcef7f662fddd156529ca0e6e9300e13ec3b8a30ad58b699d57cd4e97d42cbbb9df2579df14bbcace491f4c00c6151beb3a593ae5cc6b14f2ac3723c0e8f4663388b7366af2eb0a3a2b8770216d4e4614af1041028f5c0654db9f424be218548254ec8ca429b10335649f0ec0308b81124207e59b118e3c57f16eccf1fdf8ce49d53c867ce7ab2d6d431b79dfcdaf31104fd452f4527d90b6192a9472ef192e1b133a455ed7d9031235bbecb15513a10337569267b9fe68a9f3fc3ac6557f97dd2dc6841328cd7629b60e7fd5aaa64132b4d8e51c47c2d87a3f8a71a63e277101cd2e9751e652f592c24787d5893c2a238220d1b10fe67cd171502bf6739db353ac68fd76f2bdced61abed454ad113d38288abb8ff60c9c7679a9e3e6dd16826b156abd1ec76f84967624818d47f856df453ae1461cf8d007ae30f8eefbb790fefeafc22c25b1f8248dbbce895f47edef956739aed081a7fccada833b3c35e4a93910fe0f78c39f97d955963685f4ded38a8ba36e5f8e16146cb27a51f4bcc60fda7f2edd32df70911af0a978f275b199a3ced61cf2bf543df8bd21fa3b0f548526aba182a1145ddc16662707ddab72e59b6f7446f1ba8e306b42a7cd29d98b07ccfde2253e40bb6d25d3de5ea01d9915ae1d16ae5f8707e1599f11d17851cf5b3946accde3d242309be454df999a5f3a7f7cece853e5c16610559737b6cf7f1f1176165e8d0ac4e657e67e9a88b6945392b8c9d36b480d48009f0ee2adc4341ea1ba99584f6c0da016e325cb74afc5758b52e5c8e83ddb9cf1ed38d46f7f987e9faf303c0463817441eb02db9ea6257b6e520dd6efd91e071cfa9a28304b998c22b28a4d3df555416120035b4d0c1510fa5b44bd45929e15d16cc33ad963468da11398d2323b503433b2073730a4d7dfe1b29b11a67f863492801d7dd662695d61961da36c6d216400d725f4eb0053aeefeee55c0b36b6ffbfdd5895ca659fa0f870f85bff2390d232fb2467006340540c5bf4ae6a4bac73aee1144d1f4627d15310d8fe506e51be99361ad0e64eb3b5814bb2c723849e8ea4c08a653f742d922b9a3efcf63bfa1230770ad09c9db4c1558dad0cfa3c404e5114138fbf660f97f2a1d22cd16f7882693f19c017039074ef161056716174d6f131d4c146454e5c8af27249928c3f59c5c80d1012a58ef4b2adf41ed9c1422ecd79556af3f93e960562792d9db1bbfeeab6faa3588257ae5ff11fbe37cbf8baad7517a60cd2a3c0d450ed81106bc12d8eba69ae5719cc8f40db6a449849ae10e9310771ffd6359dcfce4e595ec58cb3995c6ff10b8c5ac48dc73670ea26da276323919a54cc2503edc9c94cb0924fa82f0c746b5110b2fafba68411f4d0341e4973933df7f4b1aeb234d1925daaeee944c1f625f6913828c736b3887ab503cd1c919b09173f03a6595099b6dc09f787ddac1d419c0f2f8e43589f71a2d18e6bca3410fd6593897fce73a0c1a91f815cf0b49be56b1e0bd21e54d39de01ad5bda7182280511e9633452fdd852e63c6bb2a6bfc03268cbee629037f0541d01e1ba201f3d8af074b1598d98f41a63df9fb2ea4128f9df967070a2911a025284688ed72a7a85f95bba85309b77dc4b151fbe2d589cf5d78214a6c8fa62df98cf024b9123b909db33f9feb37b819fbe93338d9bb8aeddc655cb1e36e079d05cf0cf4edc1028869c19ad27f2c5e448c4f85a9aeab8d82e60338328b71919fa1277d55537bbdee94caeaa66c40bc1cfd20c55a92cfca6870e32d987f7bae6684454ef84c39a0f24781a39feca3f92f7400f69156d7d78b94c3fcaabd50aa4d3a54015d6aefcd57fd9352c30d84b59429ede3bbec4e9b783ef20b4e4ff225d2fbd5e585ec6217d295f09fb4070cc16f431b3b3fd45b5b3d33c2a3c7818579b189239399fc434c568ca66255b6a7abe89896cf9c740c0ee21b244e1524578a4289879248c670d8e2ada78ff7ce95b296699ff7e30263b481349aa955a8116ddc712b5abbc17de8526196afedfd29297d1c1d6a758381293a29e9c00c7a4473ca0e792a941eb1ae9c6b11d4ef6c75311ad80c8288b57d06f247191d080a95ef0fb6218a5c66812894cb9493d482c530577f11ef9f0470d70957b96e101fae9ae97495269e92ecc73766b07aaf0fe2cc53a5c6617ca6508510d94f5acdf79deac0d237d9591812621129b79cd78781f73de64790953a0085c42af0d717a5b2259cc711e00c13f770733676170044da6a8a64b43437b5b01de007a00abcaf5c74c4a1d16b390aa0b5733dca0ef2cb3ec07940145dcabba68c51a2f24563ca38c8075fc78f338764469c3c442d7a1638586db3ec5ffa8a1c90f312a1e45ea886444545c792daee11d1d84c1617729dfb486b9c9ba2e2c644ad7831a42469a2e49f06f2ec541267882be6ef1c7fec05eeb26c651464324f61f3340573ca8944a60c2125c38787ffb3b1e89fb2b7bf9dd405742baa1680590d07371128d87a3a63fcd10d2241439e6c33bfcccd44ece4a1caa777ce5658964f4c4de9598a1c1f80199a83485b3897b267de5bb08d3d3cabfefadcf0f3cc2de621e556dfb49ff136b321f0eaa267bad4249f5f713ab9935923b0814b87c4478f6f37b5681cb5a7fb4065bab9968b6141854b2811f4761d841ea562f4cb94b1210fd584bfc731be92dc9aa87fc68e88427354933afdb9e09efb5d9ba2a629c6977fd5b6853c60bcb8ffd08594e3fc3811b93e679f75f2db9702799d9d9db5695ec0ab76b45fe1090b24ea0f7ef962ec78992b594b108c8fb7f0bc6dbaaa11648ec5e3110c5a8e492a6378fb5b7b7bfa99ed4c6b56620b92941883f38f4788ebdae3beeecd199324aa4c45c816a75beba0f7755e0cb488bd6fe4f7d01f20a8990f164fa3c3c2961d93c00de7ee7412c1931adc66798ca6de1cb435d1ec6e0ada2d3336db650173911a48429b20826d2877e643644ba8759b3a8c2b6e0df83f90f9527a492527ef1c6812992707f51d080e287e992adfa9dff10a8f39254dc44250d470671a9b7a39f7c44d9cee50f6fcef60e2a74230b9c4feb9b3cef10072a6946f9d0c3d3ee623855687482c8c2c9f487ee95d11d7cd7bd4acc550b87b88e8db7b590a56c87d7f05ec8839692f39ab847a7343cc6d4de822d21d5f5f73ce515e3a522e032f33cc86dc4623c489d41c22b9ed0ba4f23e51c4fe0b07f329f9dd3cc2a05b984e80e5d24802e0c6047dbeac723990e4936ddc549f7a07ecb87ecbaa8b23319e2b08acd9d3195bc5b44653a0710527c2a2a3b7501c7679796e9f2b49017d2fab2bcf5887ecd8afe5b886cad392945ccad54ed25027b89bc2f9c47a4ee790d1ed631fbd888a1b3b1c97da86bdc376fb459e5844bccf62c85e30278aea44d1db429c7c40b0a9a84f9fde9657dbb8e9924698d1ec992bc7a586180af3c9acd1af535751f4fd626cb87c84adec2655167baeac949f8839a960e4626f8d6be6060939315e059d00fc1bca65f69355a78bc9f79886b87cee088f2067803912261270d402add3d068dabe77018ad09e8b844f5333f2ca9a621bf5f8fcd0211e63e6e773eaaceb8419b26e049063cd8b5a3723b1b02a632b47dc5c2bf6904cfe006ac7e0cafd405a66e2c9884b3a94d46228c65ea944d1d4290b7f8b194bc26dcac194f7eb73bfa896383b9ed54b3d94fb8cd9a2b4279fc0f2889e9fef4ece92e05b443d2149f50e3e8f11107e2e7ba2490e28233a23c22ac96f7e13ac5187cc8829528d640d9f4212f56627c6cb72036447ba7c88b38f43657bc816e1d7c2e88830e2a896fd4f633684213a3b67a40caf16a097e5f779ff2e329dbb002b271f44f2bf075528aa687e1f3f7f7c116679b0514feb21986e71c6e40ef531d9f03c3f25e643d0a90ba3116fdf2ae04b7beb2be914a383199254309cefcd5b1872a496c86d130533b7b6a5ddaf5a925c99fad8d32697014174a6feab643de6c092d743c415769d4646f3573f18e5c80a1d8ea4aedf5acdcda6cac96075cc2f49856e74f154251dd94d517cc67753bc42407450fc2010f449d02e803a79efc352ea7a6caa852e698909f9df2360bff0504fe8952a7bcf0fe33accb5afcdc23377575b978971ffeb0798c3e4fc2a1382a83132ac71ffeab53d8d59cfa0c82919ec00a7adb20b43f8fd1e4363740c410235b22faf1ee6ba81b9b73bea3a1a26f3f387678fea492f0900b4993f425f5646fb7613fba316dc5073ce92781906858832e8b3eef2adae931da21e311614ab0285d8e7ca74dce9bc0c2838c48f19ce0a080ada4e842b18d9ee08cc51a0f4378c665331bb7f757b40734877cb3812af1637bb0c17e8525fec04b66c335d3244e2759ae8646af9d2b1df27def3c5e194532e19b290aa5addfcfe2995c5c622df882be90c2f3e246cdf2eb237d5b8ca85f16fbf4ff77188f66355353ff5d1e29120a7e34b6f5733f66248fadcccb0f727af03f2671e8dbf6ad61586bc694aed9ba982a4aba9f3ea936079ed6100334aba08535d73c69a54f9f5e433675332aedcaed8fb47a956c6e6e9b21bfadf58a6f8fa58de305928436e313e495ee4f68fdd29cece979443e95d20ea70c36a7cad1557fbde0631e9d272f9fa94b14549a497c20434f3fcebd88d3f0730ac3867c431842e57ea0fcdb7ac0246dd082c3ee419005c585cb6ae2057f3561cf26c62ebda9d6330ad1c90ee1384fb726c4f4737238456ff06d821966a00f58116b64e6476dc8a10a1acf113134921efc4fff8f5f54370d96cc2239c19016220e0755131ab69a548004aed7324651df989496b912b90b61f637b1a49db2f54da5537833fec48baf892e02140cb9bf5124007194dcefac3a8a676798368cee5dc1a94aace045d915a167861e55b1dd861ed61ff2b0f16899f20c22c359e7be734b07c580aa45788fe571018caef51072f2f29a92a7e4a9d6b0279afc4dd2346b7d9e7847f232c703b3c37f5052c82b12d337579a1369262667690d33c35761473b6a04a41ab8a01fef7a2770df64dd87913a2e3097014fb8173efbf746c2b512fbf6f9417ecf7d87042be8e122926ddc247824752133e6ab0aeb6b865026f7df6fd660410e9ee6b573825d72aa50f8aa2b773b28a7319d569bc53dab634181baba09cb89f7d7e6c3dc7af1951ef8600cac4988daa2125a507ce26f8f55d77a8a9a0ad172f01239d41e95f68b99affcb9c020e030f4435eb3c156a272854f49e16831227913530938cb9485a3d828e74b14a4088882afe13bdee74763461c6f08285a9f3d2a5b8c1bcb11cce22b61e7da9d7e2007adb3283305d8c6cd5e8f636a6c16b35927b4bd0a7f1c89749fa190530f5485a27906b37ac17206d0577a1eade8936002b815b0fcce0c104b7fbb310a539069b516e205c8fc6a17af546ac4508c0d23a12cbbe3e324dac1f7828f2a518e9bbd6d3de3f32b15a545c3e710538990a0fb177b8114683f9260f8e8447142177460566a8930af52ff4d7d208b3f3a2313074bb81f3402e127fdba24c190d22c1ba014f07794b250fb855f1eabf2588ce852f907717590e5ff3d853c6f52958c080d38578345cd0e2232cccf1456edd6b7111fc410682a9eaace8be27ea4a15f348b7b046433dc4ccf19663d571471b780d2dac5f9ec9f77bed1142305c7cba28b893f6818aa42546dc3d983e23aa820026ccbbe42de20b7adb2e51521ac4cbdfba036c33021dbc674de66331353ca93dac12edb693e21f56370efdb85e4c1cf0e26ccd36a6e547f60dbb729e92b1e085bd18b04b660a0ae82f5f41dbe089b8ccbb42cedca64a34f3a894e56acc880b1159c06fe74d0ce822ff794a0e00d82e10db4d8c902e76e31b7531ca8c494fd3c89e67979c52211ec3c23bbaf7fd8ef5dfa385b2128e5cb75db9674f015bd04844fa7c320c470e7a664339e713bcd6ffc1f619590611aa83b103cd7e53e9ff54de2a0e5d5667a2f485585990e7e700c9b38f92e7c3e981d1030b26d63814586c6676d55d48784faa9f01f1debd1e0c8a1b11463d32b05518dab9c32c6cdd040f1eed16c1006a6b1f2fb8892f02bfea543d2c84d8364f8161ca4f1df2a68dcc3d31773e420134918c5fd73333206f0b605edd4f49f1a0557b0cce7a2017a4889f5d27c0c18348931a0acb914c26fff7ded6d0d2f84f444e8332e95dac12c6f66a17e5b2a34c667473b932b9b781b84b5a5417ee1c9f97b61a2189aba06868e431a0fd9f3dc75165fb9771b4bddf077c8eb1d594d4ce8191b3e88572daba50ed90fa9e98a2c76deb43a21e6b7b36fc5ec290a946731707566196e357890e847d85934b43c2daa73750894e8600c1cd7d58fdf77d3081c25ce60de4a9b3a5e7b2b43df5008c4ae6d6905b5595341788b15cb11509b9342b7610cd0d27372b0062bc4d8436f35395eb461ecbd37e909f57be4f828c29d1547fdd13461d70dea9ce484273a53bc05471bc991f91b0922f717da522b86b2f51985ea46a43dbadad0702cc05ba6256085765dea1e6cfa0f6a55e5fa5c4b872e4ad828e370a3bb030a47a5f7ac242f665ef6989fa3bf88a0ddc91d1e4a47ecbd8be014b5bba50907cde8c0949faa4729f19f7928351b07341e41f0649853271bf42209e539eafd8f140414bd471b0da2a851e9de8616eff40706205e51647e10b1a2203cb00f4da7c1a23ac1c92d7ab8cb22fb859f9b346fbfb978d078ceefb329a05e672f1b7d22cc6e1ac7af80c9d702f983ccc5cb505a3d0a49980be4d4fd51a7b261a66f1b8160dfbd897922794373650914c2b220f1fe829329e34055469257373ade8338f6a001926fc5912adc2032293f391e77bc83439964b90ef93b3d73e4813ba0b35dcec0e029781171b09b6cf158450e4127a84e8cbc60c28749e6f5aa7953204202caf3ae32f2457e8d2e3f0da4d6ae336cb2e186f8794611142ab125fc7e42596fba2c777cb099a40ae653f55b4986fd02640f833000b551b38ac03bf4b852192bc29352223fba2349d6023628c33e521820df6f3a6fe672e8f4e5c95b1e6a12840e88f6111ddfff85658b7eeab08ba39da93599402b0cc9c2c8d22345dd4e6dd110baf14825b45e31ed290099dadebe74649a3d33eb798933ed156eaf4e63f2265d6ab7f8767db28a5d5fcc8bf3e95c2ad8f56d67d9782632897442a84cfc8e5cbbc54e4d297200fbafb9b599e8f724f1bbe218de5c2ad2c8417f11437e25c42b91ad479c9802fd698e5fbdd4c364784f63996bd26f2dbfb013df9c7149ed82b869f235e81aa6d3d90bc1a75a718c7d3129925735ed16124ecbffb1b39bc3019b8825a714567f695ac81bfa4de1d516b891ce3801ea5b6c8163978e1eccfca442944a059a7b91353d01e607f264353bbc69262799e548b246edca78a7857b64420c9dd8792574a2b9e58f0678995d48a5cfc75b2361b4c623e4cbe0157afa03230a5a66322b8e61918cbf62f914faf56a1eec3fb7c089dbbfecb89aadf9418105ec39996d2a3130cc4d43dca86be3098b5bdbded8cd5dcdf37d934aa5b0b33ceb81e3e6cb692a91bf5c0229ed9ca50470d3b7f62ab71e1310d8d0d159a1323920573cc90a3afa7520ebdb2270ccc280f79c45bad64ca1a8b9ca2ec77001eb525d918bf46c52ad8a127277af6e6648a96ed81b2599c8eda65c9c110a83a85e0a88b83ab09a572db039777b5ed19f69ae11564c3c710db7cf2ea3022628ac2c09b8618d5f02027bb96f28a6695ce8d3bf6f7d151f557620b1f699741ab93636930cc63595f258a89faf23d2acff59c1af6d9c064a8552076810c81dc389573b220ddc4abbfe8eb38186d97151cc6c28fdeda0039c8fe9c7b351d2ed39d9f2aaacaed46bda1bb6b68a361e14d4d69b7cf024104ed85a2a35a0da3180fe8bc15306cd11a390fe1fc1fd0358d884d1be1577dd81aba2ac2e3d82de1720226bb4ae6807f33583db461299be67c0ab8ee0938f45e3372e4f27b9c6326e32f0416bfd38aa9e40cefc4ad9c68cee4e0931c4f522475ef49af80fe90e09d41f4ccc4064c190b2a5c24456ab882434a06a29d1d950e56e287a1eb83a43580adcab00721c23b519151533bf470752ef01523f7d718a14cf88d90c0b28182b28ed8c915bf733f3f36334a237d2f47b358680b4499b43f73348ca30dbad1d87128371249c91644dc72a535302ccf2ae009535daa9a821cc7f23669a811873b249e97e959400699d00e0b4f75e2fcf56a159ae6fe1ddb2b5c48aca384c967a6e462967fa4aae6036bfe30bece12c0e337f0f73fe66d80a4d949dbb8e342fe04c0d1faba2807ba0b21d7b05d7fb82ecf5ef82b9ef39ca511250e4a81e15c813b6ec3b29bd9247e8fd8b27cd3b944dbf0e8a7c866d681c3cdcb4910e03bad080f2a7d692141dad366631b271cceb5970cb69f7173cb26bee3fb383ef3d3c23c65451767b4ba781f284463ee8fff190cc41d82abaa67d92a49a166c225c2aaab49bf93dae92438d762aa64387962e9c5b65477b3206c93db021d06021d0c602a4fd98fa3005f8e3e69dd5b20e2b651e597e7ed3d919786de2dc60c6a9faaf7bed62ad2887a1851284446439483156b49c7540d3835d441a4f3b5d1efd6c6a65b70465a134fe3579ef4754c78f6d207f02965b9cccf688cc7adf8891af1acb2ad24dfa27d9533bbe1e0705fd3a627cd3ffe929dca77871eefc98254b2158576c6cceea2c82dd2c1b4f30839de19b34403fbb578a3f195aa2a1728ab0fad64f3efc54919d54359e20601ce92199917f6ba4ab20e170a45ee35c05f4e9c521d7e2773782b5636eead98b3beb03723f28cb6a9cf8f9c842ff836fc50564ea278a5b3af2d322f358a4104f0b0babc7b845aa91e274b3afbfd5eb1eadb2d6368f5eff2173adf13b5fc62326a18a371c8612de2d8d544c52277e94cd73165a57da8125b20831e800ede99a2be7d6b63b5c4fe534fe4d4e8fe7c833597a00f221bc596fbb249562bc7fb5c7867070318ebf1fab204fad68c9635f463194eb06a7418654ebdd227f2ac2163b164dff4cb87612a6ad6a81d6a0e501b42e3f95eba8909efa8448594d8e7a3cf608740695a5f859bf7dc2a08ba835ab09c79aec96f0ca79e2ff4a28b65deac62a48c10211481245329520050edd7ebe70f5f1199f613b47fba3e69c840a8da13ee61d3bfc36722dcc32b8b8d444d59ed5b4bf14cf963e0cecb352039ae46d5874de3abd1f60f09cf80d8223b2869a4868e2a787eb731b534bcb34b3125064a2a0ae946da96ad7076a260864784942880e46cffe2940aba8d56164de3467b338b926556d42e23b7c602e08fc1c2bd24f62fcbcfeb5dafc06c3474d231cc1a57b859b7ab8c0291a1902d69e30352208469f4f1352baade0ddf22a1c843029cb0a308938aa142d1556c23a5a679f11bf135355d06820be9fd11305a52b3fca352d0df3d29b1349aa20704332aec055085acdde25a907fc5405865d9a984b64c35a955c9d8142af106f0ce88f4a299c2f251be1c7a7b63e9b602564feb43f3fdebb604f2f89b4bd14c45a877bb89f70c18e3328e53518bcc9f0364b521748bc5bc611a4d759a027bf174814f16623296ecbdff2c58b1a3c1f05303da2da529b4783c72b769503208bd37b170856dd50bf032743daf0c2fd514fd78a59a6c669248b080c2d3104c8ff49d411852acb173a41747c0687506144b3a781bc8ca33958cbbe7f5bf5340c9d29f14dc408ce164767e48cb9ba442a717fda83a4c293591dd8d650a119518bc6b243ce1c4ef33e1d577afe9951a132d062e107e8c71210c1b0ed4d42536c9b4e70c4ba1dbcbfa11b153ec87531968da1f26e693854aef607455968b7bcd3165620f00e4f58cdc56261eda99c97fbeb16d599c0b004e196c5493120f42e4b65efcc5f0f1934defcca11fc27eca7960533bba3adb045a2e4db55d2b7c7e1b6be8f43eabe7d5c1f60281749d1e209b87e20e48cf2eb277db87afb052370bd7f28fef073c21346b0d2f24ea8ef386e649f4168fc4f8147ab64e265f12abfa5564f2f22e5863d53956e2db42d20b81eb6167063fe98d20578e61439defe69c90fbd74d30b61fd1307a00e4a15a0c156d9683fa90bf368a5e18dfc451019c2c212b85c768c71f26b45eafec554fe165f1b4b252e7dc3ff3acc913f7db83705778117575f382090d7568699050b24aea12db6c61efe28942a0af076d901b663121726cb7d2eebadc3b7159a9cbe4d9eb4c649fa14d2f9b5e3c8c34c1d6962e19fd49e4e25645afeb86fed11a2fa3739a554b12e137ce534d90573220d82baf72d321736b140df6d55600dd3d336cca849cac2b7d3f05858ed1e286980bdd4cda24344672ae95f5eb2c7ab7e7542937d76ad9cd78cf514dfdbda262818d2cfc7046b59baf3df31e89980b0ce90ec8ab6e5baeee09a97c3aea2fc2d751982f1c40e6d8e8d63a4d7de49cc6230e551864b2f0c0432b7abe0c87fe961b6fa095b20ba2c05834b90c92221d292ab9d996a543d3b54b19710ba1ecdc88ef58a2a8ad39b63e2fab0933a7231234a4ae651709074ca46cccdac08beadc6301e719bdaf9fcf73690a2a465fc13dadbeb12dfabaa3b3a36dc10b8e461ca04c9cf0389d06d912971a6c004e53c6ba5a1238935dcbecd441c205a3140095c1603f4c1a37f93e1c4693feabcc3acf404e3ad83083fead25ea07052e8a088dcb90ebdace64f4eca02f19d0ccecfdffa876cd3faa85e8b7a378820de2b32f121539de06fb83eeff60bca981abf5c32b5de5e2bf8f016e07c3a4e5dd9309c3cb30b5bcba1ad38cbb2caafec5591f86bcfe2f5815d5b427c969161f7d951e7bfaba880926c4812b319bc5e5088c5b496b2a45f81f7c8686d60443ed39ab0b1fd4e4af6bd991eb243dc6241c7fd5ba35a622b8e5cc79cdafe663739e4957e79ae5f7383f7475c95c3cf9c568181d5d243c98e6d6049c239c68342d0238883ffae7782d894c832a2741332417ec93bf6685c3ca9cf06f40acab4883342dcf5ac8e02f7257e1e15373170de2beef0d407e0178ef63134ca64fc7dd35a4e0d5919ee759b79224fe441ef6b3f80ca288a863f67f037f9e4c9b22f17a670697cdcfc41d9836052ea4832eb4a42123e01a7bc241c6e07916e5e837b507758cc569d53b83688f605abe7071d66a69c6ffc0c870902d4d8ae1a1bc80feaf9b9d8fca1ac3f6ce038705120b661c0961328b8f141b8cd3a26555ee73f909d944f7e220a1e5502726b9ff20cc664a5a650b7939ed0e1483b7db8508a5397e78f8cb36eb258ee691f10877593f8f8cbe14c51bbe35b6670325ec14ce3f621938f2c42096e9d4e0674ee4a7e654a2473f8c6f749506801c5dc2ac743b8ac4804eedb3bd229fca19644ecee5595d8dcf3da928add637b122d2a0130052af63c76149d73b4ac74e3ddbafd3fe55d5c2c21cf57b2d23515740a919c4935d679d43cc11f9b27dea60f9e796429bfacb3d0480a1fe39b6c02d14061db07ec04aeb26a478aa302505e6b9a5c8854b79a9a46c044de2963d524fd47c2a2e49670270753e2b3b65409055e83b7c501f90b74c960b35236638321338848dad3469c909b4f9b4177089b67a5309a9a576a948967d2305accc098872a8adc364511d884392044f402f2f3dc0b1789f6d9a708c53b39c628a609e274b09b4a393e50f0a818f23b06153c49af5f171598c19a188a84705c1a1a3f3c8f08f871a2cd1913b31057391bd459ac1a39c2797f954ae3b702ecfaa1ca5589f2610ee0fb3b8f91e03bc01d0491794c329547808002a0e9e39dbc4aa43d97ac2fcf1b59e2843121f6c4e500849f73ddc87db2edb435bc1e11c67e132bf54ae543c391e28de10afa3013a1e7a485dc498bc636ec4f6ebc09712dd24e94f1b99727a8b97979245528fdf7e3c894655aed681869548ff800e67b0a375a642463c1fd0a9a1d7c5f38649214bb6b47eb2b17ee4d2c1fb2c18c85067619d799b71a3c811efed93e976bf815c197a41efbd4824f2eb4d340cef64ae6da8401e500ac361f162ffe53a94e1e70c3c4a68b0434e6c6cf8418d8ab48d0fa63eb35e54d39ea1654e399023d3e597ddb14cc0a5ce0e598f12183464428c22dac8b9bdee8db8420a8028033b3999eb11611c43acce87676f41c0d908b4b07d79e3e2baaa9727414474cc3b21ac4c34b8ba6b14b16c91497286966a6c1e403ade73c3c0f5da5d3798350fa7a2f800a8eeb7fd4277e18815b4cc2d367ab2c00c48e063d2380af94db00e81992fcb52d71b69b3f3b390cc61d1627818836ff6c3f81f6048eaa8fbf1e7ee4c5bcde94ef01c6663a508ee7dc7d6466a7c932ff7f6cae54345c24ca3f8938762e32bf732738f79e6e2950f5f3b3d0a44c78c1c1fed649b3a5540fa777849b5e5428dc9ef2a1ed19b7b4614d9ae3bbe09a42c6a239db6d5c00aa9a3aa6ae2c044c2d4160f03a083dbb3b20a56650183f65a5df662946aa82a54ed017eb583c29dd0de9097911c33abc66701b227d5e79b7791db01f8052ab8707cfad336b16a5dcca827427eb751835e46861f37e1916f02b5de8a3e15a76d29c47e9e2ce7b37b12f98f346a36479b26d7f1f4aae07f1c120673da8bc84a6af1366012cd07cdf4a243142508daa70b7a753346543cf678862c9c5033d8077c2e83a94648b39e617d47650e9d76261332fe59c30095ec7f4d46c5b0aa511ceb676296deeec9237519c502ed716ccd1634676f3ad9ef2848cb4650d73bdc068be6086fd89741a462d4a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
