<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a41fdb1ad81024f7843c41bc4700ddda3e0e6a60b3d56def3c74a5c202c24d9cef9b52a9fc5d1eb87d36aa8bb55bc0698881d3c9249695d2dbc501e92eca0a7c4e4c2ac5b6c01f872fe3d283837940bfeb33de971e448e1103cd058268b72ec2c750b39a36d0ac76a1a2cd1f59ba8f6996b9ed7625e824655ddb530540fbee8486df028c7a7ba2dd16f022d38b7e7516f31addd9345ce338e849cf1a56b32dfbef991319d3c0dc41e0c25cfa406a9627d400b6995de41a8e88965b9bfff3a7708069b2b494b57f617d450af67824454b51baa409a33ad66a32ee4c1051b56e8af456188a9ea38a6f985d86fc3995ba159443d7cc00f90f6576ff88219b52811a56abc38a978b434cc77b1ebe38273afd19581bf5d64923adc42727ac94726a443c5600ad21726c3591ab4ea25bc33acb33cc5c2b23939a76d1cd7351da5a6bcbc9644fd0847a0e8bb064b1122c6f59fafe8eab4356a6adc3452f1f394ca42a6c9e8bf3bf7820425d2516c26571b415b5b66fee695cb17d14acd4f64ec84dfd9e87d81c0330dd049ba09522ded327afb171c93d09042122ce2d0f9abf64fdb313d3bd818c34255741311ad45208c37fed4f7f65c4b61676521269a49b4878ef23884d707adfb834b1ace8dbcbed3fd360e79cd6134225ce8cedd8939a864e0eaed50f27c01a717111de902ba7dd570ae52c91ee953862e9d77078a24b2e0f4bb28573bcbb0f142e9b6382b0f30ce1c2c3019e946181c8e27bae2de5838effed3e0497d9987ef6012847003090b0894dd72a2a37dd5e071007147b506555341211ea19f401479c492de223e8c237918fc5a7a8981c0738dbe8d5a16bc77691e4bca5c1b0c3c53f8b92711ab7042d65ae807d0ca1c142842aab57f16aa4742780dadc6d3b5218d67675fde3fdb5ab8671e9961e188158f26db1e775c33f1431cd77fcb0c38b7755b12288fd414684165366b36e8d724e3a4d7bcdf92d42ebfa8932fd52f9e61ab7172c1e8aef75555fa28ff134eb4e57baed24afc91c06db4d6109b51731f5bd2cee455f8ccee08d9c141f7a001d37577ce08629846332410f34fbff99d583c2d600ef1f4ef15a784e2de4bac6e7a519eedfd94048aa11fa4e702d3010db88d2a3a43ed16230b782f41a917960a1c1fa70b780c252e93edd0981a0b47ad3d172cd5cf0d1495b3773311a873c89edf1a39dd3f39018ec596be1f9bbcce44b36a137758e0f296c6270bb15240b9ccafc0f5814aababd734ccf37414cf62bb994d72ed902a4b5609fd06b62057fe8c64c63f93e0968d1c3038380ecc90f7d3a9983cb43b8a1585e6907eabf88dcb058223e028ef03aa5abf5022ab9e54c5620958f9f92e75bcb5fccf81b3d3fed73565e1b72640219a7a1eba1405e75097123f1864daa59505b8eb47ea985d09b8c92af852c1f11aaaa3affbca57eb0e896d90422c97f999a2351fde2097cfa671ecff35e69023512c34a1eed13c46842daf75243a621cdaa7bdb31e189c87bbe46b5998a8ee53b8ca12e8ce21f1b3c0c55e1bf2573d305b7dedbe6026fd70847bd5a46ce86a2b18d70f929808cb23d4560877224a995183b03b8c23f3e8c19a553ed99eb961fb5f226b92c000d180566dd19f1d6b019bbca8d5feb2e8f23b424f4474002ff2b63ffa444a99a36f05b47512027da5c8449c1f177f9abbf29738123fa61259cf8c05dabe083ed8abf73e1beae94c28a2ef6a4762e7786dbbeece5c4f40ecf0900b5ea1364eecbb78567ac0c0ef16cb9e5a6e08b8cfb67bc047fb7df5a63ad85a1d1856e82fab9c0f81e73522722f892be9328d85482ec473d22f8634ca340145da106f708d77d0d6aa921e0ddf2d1cd8e7667315dc8750da812c201423d8f05638468c5bde38e957d2823e60786e0317c80742ead8c1e542a6d2dc370d70b299849dccb9330e31f6faad7006b90fb2eadf90ab9757a490320d7aac41fd95b953433aa72af677949893114ea0904c993e2b6d8da296c6de45429279bdc9a44e997da20edf92decf8749faa4ca3b139b3a9f0383d92834be1370c4df91189d824c4bb459552684a278b77769b390bb15fcb4fc9f6c504ce2132b786d8f21942de6b8865a0228e4e4a59d7b4666eda835bfe8545f8f71dc95c3daa75a2089d3c5adb1ef138e8ba40aaafdd4e867afbbb67ff6a83caa862f00ee884f63a54a858e73f9e2c0ce31f8aae43e4bbd8febf5928c4685e3574ee3f3943b44c61d4ebe50709877ddd4aa8d01edd61161cc5040412904ce3bfdc548e437057cf3af01685202dd77fdcec92ffa9389222d8ed67b42a44c437a5848d0f38af1be20b9e3835f1417a6b4a2858842f3c89ce7d78377fa2cf3332e1be56568d674fa7ea9e3e151c93517ad5a9dca963ff8ac4b8942e2f2dac3ce8d3ad1c7278503886166a57d5da42a58f031bf28b3a7b8d62d2f7723f845da79391ebaf1e1deec6d2d0491826fc265866ecea9a003e6f6e169401539741f4acfdbbeb450478a7a792c34e9d9ef72d788e70c9b8d51f67f7f0e93956376cbdde766c8265d0bb3bce0875f66e78531302e4b2dd892ed3057908ed4eebccb59effc9f86056ee8b3e21d2d9feddeacfba3d25d1565c8359d752525f57b7c2c1fcaa42845ee53dfcd8f71bb52f7039b020c22259deaafb2a15d92d6736948ba38fed42d367dcd60b18977e1db0361767f4b106781770e4b8985cf9d70b07767d0781d1879c04bc0e8ec52739be84df70771f441672fc3be3e1bad3529c5d7461b2a1afb4da9bb65886fc869b0504230f43dca359d77329329c51437350a83bd63608b26a25293abb798d0dadacb3674105e5bb741373e8aa9dddefb2ea000568eaa1f8f993a994a87142518e675b588715179d8a37278d472b8fcc7c8bbd99e3bc9630a727bad25c794b92afad95ddfdc7582b8293275d5586fa1b81bfc69e247a6c01ccdb3264253c0e4d88431d4f634d21c32d355ea6891f53b2210fb221c69aceef7184c7244a3b9d7ef56b2fd90cc0436476b767d107bdf685956fb106f5104e6bb17fb2a37a9e6dde5c7596bf7f2b8a378886793cf28b5f034e55580a0a622403cbd83c2695e20605c22d1023189c0dcaf8de37564c9021fb31b4a668e325d8aaf5d67631c294f6f1e4120063e5f794cd9b84415608319ca60d164622843240f3b364b4011275849985f5384bc26d526a735fe9b2b30f409be8dffa6c941de061144d605d16e790393ed9eecdf88309c6fed9477ed1e8c21e626c7881e2bcfe9725ca851e85161a32ab34ae8c8a0671518f6109857ab9cf169894b489d1243ba49dc43def7b227067816bd805cf8c4c27bfff1900b34d4eb076d627864517caafe325692ac25116751943962971ea025850a2df2134f211f3e2aa5566edcb6442abc16b3d30f65755c71a3dd7c70494fd0681a19cea1ed45557cf605eb9c57d493dd61ea9a6939999328e1cda75cb853ee4de79b0cd46351467fe64b9b1336169ea7737ea59cb1818be620b87a694b9e283ed30985a040a4129917feaaf14c94cd83843fac799c5bae3b17119d5a644b01a4e0212387366dc2e8e3581caeeb71cc446d3fff2d102f29054d9360c002e3bec65b1d8e847285d0112fbfbf6557117bb79a3ee55d297122d49ee3a6a6935165dfa1abe90100c20fe9d3d1a2b0f3ff48dac3ea314094f61182212ab8b6d30225372679de8f5b92251879ec61f950ec6c85e5cee188d0604b799adee894519d1615ddbe3332c06cc2f07d1725114216aa720b8532711a9b897b187802cde9703aedbfaaadebd1735f1b51b59577a0b9e7adcc6f71ca1008c4f0831ad851939051b3516934ae3c883f350f1b46a6fed8c0d242914e6f5cbdb47bcb6438c3f4aa59dddea93e9d81f35360c6bf1106ec43fb8e3d004d9ac8a884431149a365b04f5c49ab0a29768d1b24fcc63ba03efd5e606ea1b399f160d540457c9b97b0279b7db63aa3faf451221b526ab0bec6c1b3c02fe117cfa8c6cd9f1928a98928f15d55f8cade39e94ad3cb9225b7e817f0a1cb9b45f2db8a1af90fa55fe933cc1172e37b7c99147a591d36e2fbd467c08f8e94d876ba06360ca61fd27e7844a9bcf8e1a9a7c1d7d3818ac36f0e330f00433f09658312953df78e87a987226bb4ce1a71c6ad6d62987886e7faf1c42dec28a395fc980a46342aa498b0d53f37233280fa76ff11ab78cd65717f9f48c97ce1b0685259f28154a55e217260e531d0c082f18c91de748b4e6965d7cf9a0759eb946ea1b7798dd33da54bd2c8cd532d1c57e2b287ae5a7929bfe7af22e30884815eaefa25960c5773e19d94c025dcc86289c7896e3100487d4aa5f807dba7cfb65365d1851103e965dde87d6f3ebe243d455170c4758bffddf2525668a1f7245fa4365320718404647da70d3472899d79fe29756a4211cf83e732c154a34f8623053e3ac13ef48672849f9ef489350284ae30bc5650face50b934c463eb26ff88415b7c51691d20f711778989b2facbba7a2fc9788059e5d1b7f2e5276a4d0f5b6b3e72fab182fe7b0432e38478640c1211d367c28aa083e7ce2613194afb0c162d390321ab7a07104d1dd1f173e86e09c9d7d04332218d571d4e9346aa34a33f8845cf5e7dc16776839c47f8958c882cdf70c8289e7d5ed0e7bccacec8104b809e9fb4909bf5fb84ddc61f76d3dcec586fd096cecbbef1e025631f241428bd4f4537fe37fd098664296c54353d2e6cdb63564f143ec1187074613ab724d2f0426aabbc54538bde774f4b5ef268b9064e1fbcfddebd006242d38c1b3de3b054813fb92e48fa3e11bb801fc3f46c261c1627144fb60273e21fb8c834bc4467a0b7b1024a153988441263dcbb345bdba081ad1eea419b6fa80ece585eae7d6eb78f9eae81ed16bfe7ca6cc490300886fcf3ec555bb0340b6682161675fde5c38b2faed717d4c6ce8985338b41c161b90f55fe1708765647c687473807ef793567b7534ea6f92c3110400b2782f3eeb0d67e650fe0ac1c07a42feeb4adf8ce843afce4229705f123400d3d5b93a0b47c6feb83e0f5e354450cbb21aeef4d960ecaa7184bac2c4a6f63d9f9b5d822fad566bb0f66aaea784013ead715381242d660e90006ba28cd77165ac9b8e20c78b0f17797d975aa93aad6d91404e64a1ecffed2aaa1b63d661e7a5c8670e0286031638cae4ac363612c3d29eb4ece9d8113c0d4cb3d6d36ab1e8819a77f11bc3053586bb5a4fa9b694ab80c6907efd59e2470e78775d8e8f99b7b18ec3d63c9e496db13b1b5d5f5aa34e0186efa2210a34a47023f69f8ff4b90b17bcc05649c5954ef7b056b020d2d92c48c2ccc7c9ae9a7e2d8c4643f9cecf437ccfc6ede945c5bdaf488f20daa6800c4be788e7970030c9caeafe32b75aecb1601b5a065c0432b8f01b212a1e45e2a736a49a1f5da73612ee88bd68f7dadd461b04174956abd4c242b0ae28eaf8479dc628369c83833e64ec506fe2acf134a556a531057aeb255b8199cbf982ea5e9adfa427d64745a52fab3bb60dde0c702ce9f33a39ac42b6550987874f128f19e9cf5970151586ce8b8e36bb0c81e0f638f5cd9859c99cf6e9bf75696234c8cfb8023a95712a74a4ed09d80330582e8c9e8993908109d8c2fec97452cf8196900395741d4da96b1d26da13101ecdaf5249415e753f2de185c04724d4c21ca9523ce8ba71097ff2cc95dd57226ffbe7d2246a4ff6c7544977b26bca37ccb029e926ece00350ada32545aaf479c5400803dc59c0f9d94bcf7c0533a797ca3f6df430258f48b343ab092ca5be2a0745d32e0d36410ee77614dda7a43625e3c95cd569a72c20141f2ab7d89038e733219befc3da370ee4c1051d8e901e6b045a17e791e8ee3991302a7abcf397b9aecce65944ffb680c43423da48e96823b0c6876ac4ab36af04278675d8c768410a87f74b064b824aa6cdee48af70807e6e2e25dcf27bd7bf548903c6013fa8d94409627d133999bca6d6551f31aeeee0dbb4f58dcb9aa2ed52dcd352cc4237f1487c9b763aa6d2628c3405861d9b0ff6ee892072aa12bb68ff70d71c67aec60857293451aec1ed3271141efdd036a956ae9fc7d782a98c82142d4e2c4384246994e56d4a2014b034a837af1edf0a4ed02a17a8985c9472ab98b0a1ed5fa457c4c352e909c96b0f8d5703d1e9848062e8b894dd83559b5780a3834cb3a3c593d4d2530018cb1260dcda635704657cf18d693aebae626a5c3775192add4c08edea1700e44401b671707004cb4182912ac50901a1d6c71f61281ee78618034b8a1ec215c829beee0957ab6d858e9dae94a12058661b714846c3d8632a6aa9e03da79b7476bcf472f919ed854eabacf17723394c67c2cd13448924daa015434aac40691ccef7e5b0d72e3e6776037e8901c82efeb940d6f0b64d1750f7d3b0e865151fba38d47825b5039fec0862dbc24326834abae20795fa7e3185debc64dbe36ce28290ee2daf869afb26b772a4265bc1855ceb6e625d57b0199c49b842fab114ccad298fdca94458da5225c240b4286cdce951541700356377b77a6250ed0f478b7ad5678cf466fabb779bdce6b528cfcddcc1126af583b2b9208a4fbe08ce014f2f7a375797e0bd483f8537b2595eb0560bb0a44d0830b637a5bccca0f2f5562698849c82589885f4affbe5451ebf9e6368e0d8c4fa51f2a7e5ee512d22da35a790c74b44067363d904d33e34ebe7184acd5f5aea91791ff2bc5289f43df0f46fa43bbf9bfc95a58d68d593c1c3969343a0305f3a415e34c73324ec41b9a17179b2f7c54e769644719740ec383a4d0de961b0db535cb99b5dc2f38f32fed86470ea518e4900eb4cdc15aed03e5d90a2b84d5b104563f06f521ca5d755435eb18853ae87689411b4c03b07446e3dc3efaba4e6f7b9f73fa283f601019071477516287d18732e31795e70fdd9eccf2cd297160540ed923a895aa67b8ed3f3ba23ff1c4aa2b268d62e34e17bdc5f7e799b3df8672299a4d0dc8040a4fd7ffc01ca55c4f67543686749b489feff38e74a0e8e9263317c55eda5b4ccff8d228891e7ca5a3d2d85d944e08dc32b9d3bed93571eea736dce751898ccbe0ed032041f67b82fc3e384eb23a4535cf6a3f7fd1d659ad44ab9b393e1df9c799caa2acc05994ab6047c0a3f3e18d80440fb69a3db3106cacbf6c213aa96b2854472c1b4d68524edd0b27801a29917e5bb96504c8f3b08bb68aaac6a5952f1f77c2fd7f2fc190d6f84dfa9bfcc851843e3a08b003ea1e9ee1d46bd6fe81577cffd94ee96e0943b4ff5d0f730da27b6884ed6828491c7d1389689494daadceaf52b6bfafde5fd0b0805ae127e969661a15303e1008aa7f8c0ba0452c434b1d2ae5a8223d7ac84a108bfc904d2e559b4fe8251f9b51ab1e20154ee0478fcaf12fd1ef45c223288b9d7c5ae0a9b4e012c7865323ab945a6d13d0083396642ab70f534b0bdb4b4d0800db726e84a8b4dabe5d175f95570a6aeb2491197567ea8a0f80012dfb7fea1f30a6fdebad5531546a61f101b4f999bf95f9ef93a82c4f27f4f223de8816034e0c857244dbcaa6c94055f217019b68d29e52e24ddb3b0842fb3c0ef7cec69f27d5bce0b4937f05e10300c393471437cff0802820338005f24d11de3c3cde9a897f0a917e630d2650a7aeb0d2b625d5b7bbbcb46a696a8ef9fe6049e6f01dd641e3be829bd9ab70c3da1e938ff6bb3ad0051e83f190e93ec7aec08565ea61a7baea9539d176903eb4409e7889c6b2ddb9857367ecc61adacc5dfcf8a120b2e73640be290d5af0bd5b4e5b39417c18364f1b8ab62100b57fc16c9dc4e7898af68122b011e678ce0c1ac73f3a1cfc3d5b1bb4b1bb3d2d77f46e0263591586e6e596867b51b05d3fbb082d433ae13c88cdcca531fe040fbd163d371e1aba6755ce5b2a45fdea4e743f9659bc4775310058c8d62c9ac83bbfe28a117dd5bdfa77b4f0771d6dcdd9bd581a82c5b502abe07ac2f0c8a7642128aa6c80ec7924a0298c0fa80c477ab8a045acd95f15e9d6b72e4d3ec0526daf76398874e40064ace831d3468e5f097b0342d3b44ab0c7aa424e68b494e8ec44eb4979f5e424d87c0a8a098c15bca49ca850eaad16a9e0ab25b02c52a162a4925b655bb5ba214b08929da400b13cc21cc23868a16da0d4248a02085967a6e3481a2f9687d0d90f4dff8cc53b9e6746d152f495c3581e714b77b448ed4d8f6a4e9ad79968daf16913f146d4d2ec4b54124f22ea509da4cda017dbf952c1dfa87ae2a2281cc92ac633391fa9c9f460eeecbe6305539a52e7e86c861d16d40617f80c04b895b681c56d28c928a31dad0ee78f1f8dfea40ac30fb6f34d82a6cffb7ac8909228203f8572a2dde07117b468fa97e61c2ffa815d24eb5c605b5685187dbbc3fb96213f3537a071a51a3e83f5e94e9f7c57e09b8f9055b145bd6502433b79b24d439c18478e870f21d994c464425e0f33b34dfe951b12980f9d6d619f0b899eda3070ea8aeeaf8ade98c83a70bf384b8f94bdbb0ebe39ccb5e95704b8f0b2ce3fdbef481c5b52e8d138ab9575920476678b5741b3b3079ad330da2ef1ed97c6bc75b5fecde4a76461a9e42990734262a0b36bf9afb2d751afdf72d60fc67d55f9926c20339326e7dbd47d953b868d0dcb0bd40e8994fe69d2b2f8048e0141497a2b20800556571ac12420a15c476247d6f664ed2588ce9eef9cf3c5802078acd80f6f40899d663181280e7b9cc67f15334e3bee4714dc570f92b83c463a2dd70851a58c8c0587eca2ee8272ae8546dd71b1128132cfdab2b6438cf5b72fc2e176c1de70e5533fb797412bb010cc013c3989ba5d69bf67621e1bc862ebf8b1fe31f7994b35a764944d004861a20b207c76dfdb0516c86fc1b36138cc0cc77f91fc6334168894737041a533ace2e34cb93e5c27ccc228d451c81a2c3e9b6ad3ae442a121802be408bdb04ac5d8fefc88f1942157126970a1a6145ac69e7bfbf86385b995cc9805ad84ebd9df0d1cf2c18db6a9f7189f82f08fafb6a5bfcb7e66016a81ed973a907f0e1c820ab8650f78af61adb7d5ac00934df704b13a6a478f7c191171c3f47332d247dcc9d1772dd8fb9a4779e4603b95a83d036c8691680bac5f70796bd472f0ab258b5a091fe0ee2d9acb9f166a053a01470111380b113798cc447847f302a443897b6577de59e70a90cb3236c57510907b205f7d543dd4bc9f08bf8689d08529b7eb5869c3f5b4305d1942edf3caeedd108b35ab653076c5245693b48bc2e01156005c649f0d95dd59d35ddcaade3ad4050172cad36a76d1dc2c039fb552d51e87c7984740a58e9d26ecab975cf4291131eab69d91a98c67586941cf9e79e6ef756f354178b7baefd6ceaea50e42958787e7613884c90cc83963edd3c47f25c6d6c4e8cea7a8687fb11789e7d7774186dc57d62ec7b6a8c0610e4af422b2bdfca4da35d071af996232e52ba5d2fbc94680553cdc8011947e8880ed6a151d1c450f04507ec8e3eeec0b2436127a49bcdfdd26006a86b65eabc005b71901e96c05da9dc1ca9fcd2e1c7cfc322736a94495ce8c9eabec4efce52cadd8c9afb34c7b776d990f42509947b224075ca937f08cc36e31f34b3463d7d1bcf2c5955127a11ac93be3a4f0c7fb22e740ef9facab662555e1177c2e8aad25376d73710cdcc5115d52f75f9d72b527dec534fd33d845909fa219bc401e999fe4356f2e9e6e7530d1f2dabcf935fe33504f7e8997a8c570f2a62dcab9e95f259af7579b335c46f6b67eab391e2efbd04fcdf62ba774a7c4a834f4d5b25fa00ae2732a6e0e87d012a6ab5c7c70c85fcd04ecbcd1c4720e76d87ca5aeef0e47f8d86d89b2aa9d4ab3cc9021c2d26efed4e29abade97f4c0bbc7d7935321ed6e28aade8376acc43f1d1d4e87c2b17c6736623eff07a80833675399ccdfc0f3c62f086d44f18397b1b907c502751ca71309caa2b7d78c53afffab3e933ecd40608ef760117cc4ddedc96a68e9d85256ed2aaf7e773e887579487b7d8f1a634f0b4ac6d526777ca1c0a7646ca639f28e1d11561de3d2431ca205635f24b9f34678095e0582b61727fc4193919037d60f27d0a02a492d92fa11a7f699c9d3c089245c3cb49f66d6020453466766a90f8fef55aef84ec411fbb8281c00a3f6ec4e202f047215290e47f2415a1f5c485377b5720ea49dc7fecb24e7f23863c1c1a657ca0d9df9294be07978aa14c45b90014b0eb0f468686c8d99c60c9df564ca2d0d4214a6f0c06a6e048dd00234d381304b115fc654c72411513b396513dcf881c0d3ce5cc2dee5dba800711a6751c71d140cab57cd4b3101d23ca55926086d88d5fb61c6b68e838f78086b3eef96f49e2f3bce9086b145b2a81afc8e9f29d0eeb7333e6f2d0452cb5a69402d96a90036fb80e31ffea4a6c8a7f576df8ace3694accbd0a75c9eaae1bc5774d2e66cf8c46a720263490c0e31d04fa04b4b1aea50773f5e8dfc1f42caf55e20f51338ac69fe58de7a7c25e90f7982ba406cba9a2e56ed60d3188adc7b29a7453b6d16d2f03caec112f844951fd51c85c290b9c6dd2b635aef23a73eecece45659b38a3be229e36d7246addd1d27a4006b86b2c81948f037b29b153eed95862d7e4d6e754ae98c095963f3ff3decb720611ce38535a83bfc73de4aaeb94b28ece3f57cddcf5280f175c0f532323771703c79768a1ec8be26da19496983aa05d5305fcf8632af2c5ceba654d59ad12992770dae5c888ff65dde53e5084a66af9c775952b583823d73f83d670ba94779d1eee9ad619dc7e1700d72162121399f86f33b2be0a8ee1b05935b457ef1c45f6e50059936ac6bbe7d4b9ca0e2cee208a1917ef52b2a19973f6017923bbf9275032b2c6c93806e163ad46692783c7a46f0e34e6e85d546ab80bcda3afbc4d88a407f2e60b4d28d156ff05e4582669f77bb8762d9cab95ea7b161c76362bbd88aa40f248213b39f2e119442c613bbec50d8a6f6b41a08add7b6a2bee986bc19e94beb44f80c7f72e0618f4cbec1f8974fd2a530061937c4e4f146ac76823579b7f3ab777b00592b8f0c45f49f1a4055f389cba75ab4aae016ee44225059052cb0751fbc2599359c180a08aea0c221d9df8dbc884526cc7dcb7232946400ea204c232a27d4101a5e6b85271af0ea32087b6032120495a6f0c6899b7bf07ce96ab6ee03be3f3c2b84411cbdadd23ea42f76734e832aa42ff6bebb629a16323e8a217b6bf4dd2d03bb89291099fe3af291d9b8638441f9957c3f1988a81355efb0536d8703941c5ecafc701016abceb71970698f5b9b1f4c1927d8f7b3980c851bf3313c7587fbffc5ed542158c5a7dba59193b380c02c250b5628a0064af3108fd236df3178824ddcf6bd634f96b9ae0205206adb2144450d5934d3d9704ad28c047c004ebf165d5a802ad756126806f3003a0cd53f237c84fbd00d2a7a2a7313c1cdf157846190b17e71508c05af23d6556db45b73049f5f20654f8cef04c2d31bd7898c560e362041f5a98aba3478ae88a8a4e0817beb118711bb4a94ba7dd1cc345e8016238dda958012c507fc7ee6db0439fb2def9bd06d4e91edbf47eeb8769ca4a383e328a1bb62ef9863a2701cf7489af143e39866a042223ca39e12fa53774f8fa9afb9494d0117536541b9037822a3f30f8d14dcd70f176a08d1379e147f4fe030c8ab9c75e0d0e7c16453d3469cd6b48747c53c35411ee4b5a70bff9b9339ce374929581ff6e7f31e27aabbd0b40122f0fa15ba7150bed7559f2bccfaf1255106cad95049297de5d2a4b67fd35b235e8779921c961bc2786e1413326cd82df84409945a46d8cbe712ee0d6a5295de5d3ba5de89a1a2b4752ce269be284f093596678272e5bfbdf220585d1cf793019191f309ba0b296fb6a7913a58fc6f0e70e399bc6ed298c7bab586f7713d49875b796b7a6be5136bc16a31eb5aef6b7aeb806e0b348603367c4b019a40acf3c7c58032a7b9fc23b11ebece1de61f6841bc63b0d65a1bd1e3a4d71a7b5cc7a9a5e9f4f17816495a2cba89bd4cf06002a55a1581e13f7b4e61e32e428304851ec79a32d1788eda9288092f1510fb47107cce24d29dee40907e5baafd146a797aefdd7303ef2fda1a3b9dc6be0a6bc922b6f482a75e5653ad6ba567d2bf89befe53cfe63976bf0216e05362b6028e58c93a218ce1bdcacfb44ff0c1ff2fccd56335ea7674c82d587f96518e3eaa39c4f405b4a3b393e0b648384f6a9ce127a873daade4a7ef51ab59b3b576a1c3b6d6e00cb3c43e80cd2ad8ea21d98d8ac05d70de6bd35b64ffe5994e59195e63ddd0e4dde0c388b4b980fa4bb41009749c1f6ddedd62dd6d24d5ea82d1866a2e1818648477b6b6ff19944bdaba6fa8b68043053e5600cce95210a51fa09b7680a355674a0162b76a4275046edea043cb56e02d0404e329b7d953a1d67b963dc20da9bc87d352a1c890a7141f027e57631b8633146cd6cb4b86520bc404aa65810e7f400290134795b78922556f9873321b5fac55cad1b6ff57a320193b673ecd7dbf090d3303c8d05304df7bd2a81021e8409005d93c5f55b403d7165b4aec6d2a4e0149aaff69912d2ea65056e1dc316eb58e4a809a5cb9e533ea7e2d1f8af445743ea8193835794b3ec4af9b8cd4cf084696bfd113db14462300fc9df2f590b54031e096c29332bce7ee407e9088e0269540f6a7cbc0d765f59c07cb3f42ab0a74544b116b914100458ac067280c1e8ce9d2eba716268a4569122cb12a3ce164d817eff22b83e6eac649d41daa498c2521c0bee0787e215b87a4117fc8f0cfdb63c51ff586207158504fda4690cbdfc1e1b27f4503060cab3ca990de54837f81dd1d0d0bd6431bd68b1308a05b1a7f545063a21557274e54a182354994a491ab1c57c648711a75c59c08d94f2858c474daa4284b4267eba0f27a61d241e3b9e60fa15162c8a2d41c2fa12b2c5c5c2d720c906e488f887210641d2abfdf519efc90dcb3f92f33f7e563b9a80a27d7e23a769235c6fd8dd1adf60549e4b20c0f8552a6e7a75dec79660ecb0d96e1b1d3872a8a684f06e270343a2de82b394337c9b6e4e6f38578446325c649c2d53a54c9c89b761f96d8110578d5d66045c486323563582ca6b7d0d1ccc07e7481c5f5a0a2ea52362ac888d8565541b2f9708644dd828e0c1081d67d00a615ec50b549f1ffc64c42c29cdc74da2a092e4924216fdbac8791486754090fe1bec65ff39d2eb1e0eb92a3d9c31a2fbdfae6d48134a12ede9aa93466bfbca1c8162b3ec28c373c07cbfabf247cf0f271e8db3f510336f3087d7172ca3fe0c3c0c3f2c278b784097755ff77246e849b2fc951366f8c55b2b8be60cc7569e74274e372b85364e464622ee5ae33a290efa666ab54eabd606bc7bada955108782fb3f5dbac61e2c13b01fc60449a7543748b045b00afe2b51ddf0789f09ed2d8825561329788641dff63f520e7d09a0757dfe45f9d1f1a275dbffb979449047a847a5cc5ef7912a0cd6782bf1093511172293c7a2b1e7833aea6c3e7ee6af99a14c425bf1aa96c9b4e38b51a4bd65bdcd665119ac32b39367525fc6170402d36897cff0ab81f928a7de721205d199eba7b588d71705c47d462aa4afdfe4c1c3281f1c67dc4cbb5c5a39a0df2005cfd2755428707912b556bd89ffa6004e321cbc3cd639b7cc3312a2129175a7ac4ff0f57c28ae492a6d13d7d5fd6e27723687fee870feca1ed33634e4ac416829fc73b2ae98b7151798e88122f0fcd67e37b41b8900e6c1d1194de1a487fa1a4fe1117a0124b53cc1ca47630561f723fb4327979798f1ba45b5be984e10645e9fae1bb4d5803486ffeb9bd7b0c0a486eacebb713622a629b4c6756408b96b9979d2904017cf7338ae0006f37673c9efbdef06b2d04fac93da79f4b4c4d153445489c315bb1a390a36efa878739052b7fb686d734c7dde9fd73b98f04da35b13eea6979f5d209105820bbe9bb34fc5242fe35b13d2fe1fcffedb58d0a7b617d499c87f99a4929e7d45d4945207b6595dfd236ef51624938d946178b4b961f98e276584b319d56f4da0e6696926953e537b4913e160b10eb33f8562f9fa31edfce214d09544680a78dc67b4d6fec2313aa0a943d6799e8834edbab1db4d2cbe60a2497b34638e280b2d271917822e596189a23e2e189710ba0eaa532e21e924f6b80b571521e120129f034bf9f0c12bf50dbae177803cc143cb431d3526cf4f20c68a16368f5a7cfa28c16da56b49e86a692ff7945974f56b55f9d8e2cf7caefa7c87f0c4af54fa957a51acd544ed1e82955f3495f395c1bef6119afd8da5050cee3379e32e5616794d702ae24c7072122d9c231b4565fd94f426ff1ff93b6ebc6279fbf75aa329aa79c02f4f268b67ececc006b741976f6033b1014ece9d7261081e5a6e35426241c0b5a971ab954627d58f69ccf3cd6c52fd5eff922567511dfaff869e3228bfadf712434dae0de5e459ff0eda0531f02da8c7a76473ef359c45bcbd5a77cb03eac8097859d358fd891354dcd476102798090aa366a9c031eba8aa29a6833adf9493602d4b6beea33cef84d74fc7be85be08c3c02995a005e14d65802573a32191791151322756ca7a799417f09181e7576271e627825e10dce2c1f514738cadc2d44f13e0e89b064f4a9e1dc54be052b82d0f9351572b3456c8feb2f43ec1f41a9a7b06b8584b38865fbd9aa241bda691e5505d14b9300ccc1b220cd317fcf90789a6f554519d87f9ace6bd9ede552d22d61b0b206b8d89921666bee249813e715ff778772bc053091a7e55a425fd5abc03715939bb8be46bb3aada529c15b5b7d63abb21fd8b62c41649ad4a406b8476b7451601015eac9d8534f1f3433c5221f42a2bd49f0aabe75dd1bdd707fa2e0a94bca02fed5cc9654abdb00aa4295ef6654f56435a3c77eb4b488533be8f1a748b2ec466f3804f720051b1b471653f66fef17832e1cd514271d61f48cafb666bb00e685d9fe2a084fad4e9eed48ae6e871c71f86a220cbf1a4b519ab20856c9252c8e09bc882c1f6fd01b75ca8efe807e0c7dc656350436c4bf9bc8501f8602d525c96b103359902627151eef7e647d68d10738830b86176e0cae0c89527db64b67f574aab47e90106d30d647d8d9c1856ccda18e03abb9db978fcb85caf15c22b6edcf08453496e9b320bf071f39c005627fc1ce540273066c8fb89386b42ad88b1fa4c4e75d64bcf83c02934b59ce26520b52750586e2f2377bfeb8ed2d5c11bedbecedf4f2e5c39e4f03f7fdb3696e86626997d4ca4e98c6b7caef9e45752241930bacf10752cd6ab303e1352019ae11b15aefc9b77245b4cc4278d6c71d02c5776843bb67a476f78afbca6ac2e1a730b0c6cc24dc6de8d8e6ce3319cd5a9b2d689d235af9add2fb38014de0d954bf9ebf86c2aa003aed78efb671d11810584f06a2b6f9f353e818182aa52b1673c62d2aa188227e07ef9be59107deea6712529d676bfe3f6e599f7e59cd87af1874b9c6b9851bede74b0d09efe0eb6741abd19c02d8c749e24ac527e31faa793f27d328d67988ace96fdb44febdfcb8586043491ca1e14ee75543bcd916570a2e682f50d08f1a548fd04e266085179c4ac651f9ac3ce539ef1bd34b106daa5406c1ea91a9c586f233ff6a74e270b6a017323ff24673f1a85d2f93f99fcab3cf8dfc3e8efc13ffaa033da4a4204a47bb61f6f5fad7bcb2fc9dd4eee4864b869c2f6dd7ccc5f2206848953992da754b959dedda5ec4328aac9ddefe072d84d1ed88c86bd922797b6baf49dc591fe8fab045bfe85af7178607fa05f3b43035d05bad7775b53115e7d67fde336ee28ad419e80b1ca4200510da9bbb9da844925151389139c2dfc683f787af161e6c3f9da489d5a9c22f6b971e214b4efde77bb935243770c338b764d7caad4b1ff02f9d4c32eb21acb3a8491bd5d7425d997f31bfc9d08b23b96062921744dfe3d986359125efc758464387626a34379d85feb0f0bed263776baba36bd285bd5723ec7573448c09eec84f0ef5b8a7b94b8a31fcf3016e282fdab54bbac4b8ecf592d8ea769d0a5138483b6b7684019a6e0466671acaa1855e522e77abe50cf9020bb1318c003ee63f93686ad993fb81e22313442ce0467fd9d96846045b2b8a87fb5e9a51dfda851acdf1a6cf6a84055bb6b517eaee9dfe08fd6460fd7acd7cd01a4a408cfae7fd275a8f2103dc82a09d268cf56e4d3f8b20122b08fa5444be929e10f45bbddf47d64ac80d38b8484efd62e4de61dc80c8c513e066ab227e3f8786cf59a7c91f22e94dca5665e39c6921d422392e888ae89f80877846e4d1f1f937353d1a930e48186dd17d89f2f1fa7cc246d7996083896f7f4c14f10fb7c7363eeeba0be6d04d17efd56a2574394ea9ec62318ba70e24fce5eb368a42641e6c77385bf22b4b6f01c944a46cee71fc49a5323229590ee545decff47c209c01b27f5cad33f24e425f841e62a7662342f5c7f6400fa76cd03bb0c095b2ec948a8076eb39ab50c86adfbe5f1b436169067b9a2550442170129a3390726a4719406347538fd4b49bc1992d3749791ef8fadb8761678b4c857f57831fed4f52ec6f146581d23500c15a4b18d619d586c973fd5e6efcd86940dbb9e44e70f7e06e887c4f474d0215307dc92f433133d581f74eb82a476be27b6308307f75093331eaaea1bae1139fd56a5c812df57d860ccbdd8cce6624b3972ec4e582113dfed6c72031402e5b41f5215c4568b536a66cc02c0419c1acb3579f9b615cf38f3a6b6448fb78669b263f219e55eba261709a7471923a34ec998ddf0cd7995dc81180b106e93a50e9e0e7a19b3f20cf1c6c0a2c7fd51a620aa048f17048df30248d9e952b8462067b32327c6190590825e6e4dc17f53fc994510db02e0f971ca0fc7b7738e3f0efb318a4fceccf82c0344f524eeacaf476e2562c3f217385aa3496a6e40bf261f97844f1a498537d67b8cd17f2ddd6baa93fce221b7d9827422ba86ed8a7c6615c2addc5f41ba2a23ca0e7c0f1301ba40dc95a776418f29eeea7b15d280ca7b8c3ec14791d9685494485203bc39a0999b8ee0a71564f00da01540b962dfbcd49c62830828b8ce50c309cf2092e74fcc6c6c8a897b04c67f4ae0e08371c75002ec757d73b98bce140a2fce050c5c3fd965527e61f9d4eb30b7250208aac5344543d0f191e4f8a20af2ac674e2c8864c3ac3034267eaf0a25f23a52896d37d3dc46ef79d8bba3af1d5d74a0ab1f923dd6c5fb021f5b8261852490c17c11c960700b1792f98b12241894e7335057bd3e8112dcedac1bf843113319362edeeba0c24b9e3e7129724682e3fde1eb70350532e1b23e6d5005803122916de3972ebcc307fc14778af4c5c701d633346545b36869a51975036d1e1f27fae7bda33bb2e5b7c09f9ced58738265eb8bea5915da31f05ad15762f1969e2bd514d0124d4e41b5d2dd533a56e12b068e24a1fa2534ff2dcff7497aab61cade08c0695ec49cbbb4395319f549ad167bc6660ec87773cd8bd211800765a62bd7a410496995adfbb0b12e81a559989b9d5a9bba0712e8412c8a35f499448f9408dfa1894df99e3adc5ad3f29a9e93798f495d7609f680a9316a22e13d313f469a36453daabc8833501640e533304e7afb330570582aa768ccaae3970ad73474b54f2c33e6817f0504ed422e36058dc1320b70e232a6849293b19e7098f918dbcb08203624490e7d54e45d23064c665842afdca054c45f949479159e27ac3248d7e80a544b9a97ec6f6e5d13eb13e06251bdf867516483fe6bf1831297a8078864b92308be6700dcbfe327d06c667ec18448aff75b6154cd3ee447d3fae93425a748a0cf87de6b4dd89bea7a58355a227a0f91a9e0f72a0d1f730a01c222980fbb000bb9e1344f02577e859c0aff633cdb095b9e948e1155f6556ad40e2953be17d21049f888","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
