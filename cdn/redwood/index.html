<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3731b587d008edf915ed2674639fb90280c04c65c62a3b9494c0935a1e8caf965b6f9d7918c10a790511e8ad9dace076fb5579ee6cebb9c4ab9d0698edf494cef938d403ad3f14955c15a9919ffe8d8c430db9d53d206f8364b12f783dacd6f1b2844ef4d96b82195420a199bfbf976bc5ab342d451de4b5ac5c1f73f8e10d50d3abb9ffb84696f1bdd87f1e6e9eb3f5beda950e851f5ac8acb93c126d4e2725fee00b6fcd890e50cf25b854a03a65d8c87d96d40b2c517232c78dc1055a99555916f55d5d5bf1d31da219fd27e2bdba77428510e071744b5dcf173367b116cfca04bf95b4c551f871a966aa8416d47e1dc8effe9e43f2136a5958c40efbff062c5e1bb75f3ded0f942a86d4ca4a9fe2ab6385ff8573f6a97ae7d72df69eb556545a15f9e25fc54f11d5fd0e18b98bf469f9379dac2ae72955b703f2302c961f4c6bf61661ff1b7573e3e246ce7214c85ea2d1e1ee5e45ee3fb80b7cec6d304e03d7523ee3d7eaf9a7b347252d883b3a194f21650aa23b0a06d2bbf0bd52e02ec723601ae61161e74648db871e9783d0fcef77e7412f8b5cc0633fe13b921b5c7daa91c2b140264865d1fa91672172def6e35a080789e6b1256e4fd1a7ce7c0f57632953e6472db504fbdcc1e2472f5358a55fb37a35183bdc9bed121b757940292594003235888f954fc10d0fbce334e12c140606a67823c680d7401a7bbbbce7d434ef4172fb0f7b33f2178b2528937421167c4d54fb11822f94f35f6cafaeace4aed6a55a1d08d7203739ae9c4330a5ab99dea99367f43aed6c13768d3341c251ca4f225e82fe9e45098849103ad5f97f296fc45dfb5cc5ddffc7a073fedf871e1d5abd6e72a53969dfb9d4e4b8195214adbd234590c6afbb4e63e7e462769e343aba974c7c1c46e46a67619435fb7b5e328ac7a993e5b9cf19a713f03fffe2b4ad03a7ff858dd38a9abc0905b4c32ccd281d4709afface421a97570c1e0c7edcbf9c649b4331fd273e0726155eceb3bb372f7d7ba80426e98f68b67a7adeae33a21dab64eefaad42ee9926b445648e11044a9dbd5ec463a450d40981600d5beeb3f60024e68f087ff9caae0db00816ea89e24be00df86a4901f50a115a3b78cfadd16fa38bf6cb8761583ba07174b639e105dc91a01c47f994610b1bf3b1c1321e82c324ba4c961053ed811f890bfc3b4d8c9592858ed5f6b4cbc5c18aa8dcb7167b0fee1db0066bb29f1ab22a1d8ca81f9776f58ee5306bd40e722c5ebde5e107cf3473d7f83fac3bda32b66924c18717c9ecc1729affa52e076c6874cae29914c2e9f0bf27ce0ffac40f2a9c9eb3b7e2cdec4576ac98782f22c79ce5e20875e2d522ecd002c927ce3d716c0ef6d3267f2c94a420ebedaf336241abceac3e4e3131725887cafb7b9b300aeeefe35f9a0d24d4d8ab7e2f48cf48e6bc0561430687160c7d5b5c18f25a7f1e0ce2d26aef10c16bc1390b675b180cdb9fbcb57904bcbdc7ed7b5a3fac76a93e6d5090eb8ec237858aa3264d5e093387ad3fa9903b7bfd829c84b58b3f58d2271e5ebca549662925e7d97cad30ee023448ee33ec88cad4bce90957e87aedbc0fb30caa522c928c6f897c24124e9714d01d289d61966ce42cf63a96ee0c65ab7e227c9e2ecc0362437de3120173e7c3e476e8c98dfe67e3e2577caedfea53a464c9acad0804157ec606eda4142872aef9409ddc601dbabf9629a9966d6365c11c07344e1a59e4727fb3521a90ec4f79209f026b6ed82d3fcd923de785e289a1526197316d948b725a8c55e2215d1b492d1011b67a932cb59a349227e48ad1ee139bef532a7af4551e5e5616f3e08356f83c5d66cdba4bdb7099859085489bd046a2daef3172fedbb5e4ae3ac8628bfdb67eb9cb98af856be47cfb172874f748a37a78eaf49c038232bd69c4d8ec138ab09700cdb735439426a1b2c427de686cd8ec8dec81e422de6e7395cb81d441ef95cff4dfccf97a0ec78d9eeb50c8af8e5ff0efe144237eff4fbd3a939aa1a8a554df42fdbc2e06348b5a70a8b1919e70e770c3955faf91d706164390b597efde1ac5da94760da11f533315246a700954b39e2e82c39f601218a23cb9df71146b8647e70a3b6e85699cea924b28782e776d130a12578dd69aab12206b8c2104768f523ba508398e12868898cd1138f38fc5fb8976e812fb1abb0505de477bfc633ba2d6fbb5e611c5c96bc6e68a945343f80ba14030cadc85f82bbe8306f857f39a5ba359d8344a935d763ee8e5ca4bdb6289ab3ea925eb830e5f6fffc66609bb5bf2f41242fd5c29610145a101ba0671dce3b57f276bb092f211f49feb86f0c3f2773827dabed95958dca3af24d38f4ae14a7e8a6f14c04ce7260bb0e6c903703c9c07df9118e505939cde766297830a69e916234ce16afd30b2d6b88cb0a1fbe7c2cb5e2c5dabfbfb3f5d2bb0bc009bd84b1987cb781ddd025c9ddddedf2faad01aa111b4e8717c7233f33dfaa971acd64143a42dc1b99114d458bf03c028e823fb43ab2331d055f4255cf3bdb85877347e2931f2d4926ab692ffcafe62bb752e79a10d9d21b1ed9b7f4bc5afc28d4b7b8ad6f8b3e08f453d85d17cdd338a4b4adf3ec840a861b616ea7929a784099af660c1dbfc32470ce0c0fb0a7d4aa1da018c8088879bf41fdcfe2cd46ecc69b4f1ceaa4400e20fd1dd75d4529c0c0061b1133cd1c24b311370d7ecf2f6313cdefd16bb8435919716bd01313b920fa6687f8f2f1d8bcd6141836fe2af0b8b8a3eaadab210adb54a5979660ae62966edc6f6411cac33b11da64950a1edd3f183d527b267468e08b2fd525573e47f7739f3d5a809d02347bf8ce5b4b3848e6eca07443ea9d38fb10ef1c70d0316f453ae5f6642f2c401111e7e961ecfce9a34b01eceedcca7e29a2cb88cb100fe5622f14faac3a7d40d09d02ca4111ad28176652c8cef1a78c09d223099de479b3a01b5a8306d4a86be3403659902d10b438ee1b54250443da03620eb52e389a2b978f99176a5000393f66d514788c9c8f7528301cc835e579d3644984c0c66397c3fc41038acbf20e63d351f8709105883b2d4a49fb2c3bc8f5489efc6eb9b4354fc871e647c268d25c1f2c0d55d2270ecb1cf5e8837da33da0d71b843d3fdbd2b9d977a9a7723d5a2060346ee603be3e28848485219f95debc2eaa63357cd2f2c15e2b7a22806127cd96bcf33f9fe0d3d211f1f1a4b117344c58da379a4811292939c2abbfeb9e7556f90fd203678ee4e4b54ccec672123d2601187ac35c123639146a816c32036c969523e525b92a0f47e20abec5349eb50110cec8b5f445c766f293074842aafc45e93385985eba5984bc9455fce80cbdc64f716b04a938e0f638fffbb2a244c8abf7547675797862715e22c09e503cf24ca8c17c37c64ecea8d65afa00af101650cbdb709bf44881a9772c6750a84d1e16a6dd142f2c6208170aa8f48758a357e55fe46fa85eba439f1bb811f258d294e940521ded1172105f07362a09186db03892f1bc074999de89c8960657034c7461ef25d9fea1bdea9ea14201c7214979152fb758f1a07bb668738c6df7a2312dac49d18125821481c4d0a26417841baeada14a02c99d5bc91551e3c1907169ee80bf9911a6c2791e06654a524b660e61298e6833efc857257d332dcc147621fd134ae8758d327d7acfc710122d41704dd6db9eead2f9d093a3d81cfdce04283383482420d477968fb1229b7be9d83e00274693c787bf9ef23ecbcd5e1121275ff8d648db618f706691172fb107404b9a741a369b0c89db9d70345ca549b9c004e3dde78ad86439dfb2951f90fd7fe9b2dca6bb6d3f0b704e0a3908caa56a7f554c5777cd8e5bad176da11efe158a328a1b09c162c2c7046fd89cb040054709987dfc0e7ef7b6b0f52c045e6ac3ba7c5100f33fdadb391fb6ee4cc09ba9c647de50a3a93b154172363feb7c47f0a0547fadfe35040b14e3ee7a862ab7088bb3ab55de312ecb880f7539e7e8a336c4035f3e96b36df4e7ecf2db31040bb8ec734d332566f89f36401f121dea5b530cf1c32fee176dacd918823c726d1425e1c0b06eac6ceb3eef30d22f0276dd028d6173b339d8001ad936695ea2593188695c067da70e5ec8124399597dcaac23d06851d24d36ed0f8afc1cdfc4459d7202ab2836cb56ab36ebd0c67b24d8d8193e189e55f5e860a020506246a67d039ca85d7b31378178a35ad525e6822b5c7de99ca93d15e3f5e24c8139d5d2f6f83c8d76c2dea4dcba46ae2b7e42fea1b7a4fc00dbbcb7dde3b188007fef579b3678c4daf61383778fd940aafa44cc138b99d72cf31ab81afc07251efee6e71deafb4d5f7c0f69f1ce7fbb0bebc234481c37ba5ffb273e6e5f520e3f0113e41c6a81e56c860949feec334c015e9ba699b80f723a868091ecf37ab186e407a525226c55f229613504a17cab6c5d7446fe378f227c709978f0127ccc9e54316c7d6b310a8c4c805714a622a8cb2aee9c6831f0c1dce4e69f7bb08439b403cd9bc617d25db9092a16b104a9acd692d14d01e5a647dcb79339a0b550e92efe23d7d848fde8c6accb2c3c1ef5908bea5805539d4c4399fb4482758f68a34a054b4ea551ad32ef2e3e6340d090b5cc82e6d9e01f7fcb20e38f864671a2980f41ec1740e92ffa1876fba02066408a1e76da097f9981de2b6cbeef31f6a91b149d49fc00e0704f4ed15d28c110d8ffe1f1af4d01d0c34952aa271ca118819362750ba9988d9878dc88371a8627d12de1b07def86f4a851c952bff78d5c39240cb6cab6795ac2b288292652eebe92f29bacf62564f3fe09c8671e27b5dcfd5ecee110541fd932f6abf4aca8312a85628ebf85f15b12566b397f3b7ed0d2c0036798f36e7aeb931bf4be066addebdc31d036d9387378f8b2bb8f41c71935dcc733204cdd19a308a880826137d2fdbd9eb7deefea44ee8c1b80754d7ba049225e235e3a91e8fbe7fcbdd42a3e4ef00d99dfda2ecc953663b1e079103cce845b181f1b2cb14ab878d791c755776bf383f197288a1df11259660c588896bef271906b4353aa0a0b80fa3cb64ac238639bd6209218be3ee320d6bb9eadddaf60dc6685eb1250b9dec29bc1246f112628d2e1566f7936a1c18f34b19b6cb458bc52de01e421da61b9eb17a387053050b63d62622481b73b03b4b7daef9ba5fca1576a3312949d07d30ffd297bfff692a00234096185103dad13fc0c6e431d5b3a0a1c284d5094b832acd63a6fc95e956641154586d2312a33a37caf947a9d2d007b3dff2ad168a35675ba5f83ece736e370d66dbd081d1b66ec1d8746f89fab61bbb78da320e9d8974f413eeeb0a05df87982a3db5436b88b3712041d204170e5773e020b6d1887e63f43a5a8534bf15bd9b137fa556e03056a55dd763144057a4822ae7076c2c54fa7f74964b9769b055f3d9b06e60453f9b20c6fe37b1e6b83c20597f248fe7a36e7db85315a290f94c785e31b8084d6dbabdb0949eb2155b48ba75b34d469e9c3ef679c3b9ce82cbd644b705148e1cf68b28ba5b750d9b8b7d3811823213f6aeaaf9ec554d2bba22a324bdab73d93041307474242e039a88c7bd6a47807d31e08f25cccd2e5f5c8829174672e751394c6de1e04a1fd5dfa3ba643e0752980ee80197e40536e90216edc6a457b0d5f693d7d01bd1cccdd7749c8e9ef4fe2e4be40ad61c72a678ab844e953cca23a072eafc331bd0abcd2ab839a41a53d748aa5657b7269ef290923668648b038cfe167c26c1aa7f25b9ec23dfc071e33df8b9b0e9f55b252a4bc051a1d819c123be6124302cf40a2aaad1227af714d722ea7eff2c213dcd6921bd711f1ce20673fd97563adfb1f7a2ea7da6481c8f32bdca71115ac7df334226d3715e7634ba04be73a3c3e5f0a17da61b998f6bc2743c4b60cf4dd5bf3760cadea316e8194527e302bb1e3ed113c5da4f0e28f64fab1997328fe51511a12f3d8e2ce0e679a47905f34e8d85a20938e89ad157bc1e9685539189dc2b606154803f2a1cd4a2252a37d4bb8b86570dacf6b5296c1fe18111161831936a042f6991e5583a3c691e370d8c49c27ab9acd6dd23ddb4a53ad54668930665cfded366debeb9820e4a579d8125c330c3c374bfa04d463608dd311a73b6f7a046c202ae3966206a5ce0d4f68a3d731867ad38c6db8cdb5b7da967caf13af1c977f0bc49cc2ed32e4f24f2cbcfd66849e7eaaba176a67a6902b88fae9393707cc8e5ff33ad359997969a8742861437245e64efcc4a0e072e7080f6f3a7fa65638f4bc93708b4d73f87b058b3e683d8ca7450fce1b7f98e62ba1c72cd0a5add112da940e3dd9e167fbf16dfa2c01affdf6b65f6646ee4f77cd5f335647e8177f6f9b6a68665870878cb1edb7aa59a1410dbe5e808b2fd262591c0809afce1cd5e98ca900eacbf31da0e9bd5bb862d3c660ddcf65560884b51d4975f6ef060b40c200be46bfd6e34a6939094e784353781cd243e83d9afa9ab4e6f05dfa620f141e835501f5e9da8a8a45bbfc8b69052859a32370cac9f6b9df593f7e30bec32f21ecd3bdcbf09fa80313a3fc84f648324c0a33fbebcd6c0e34ef76962dfb3a740b6980e826f8d5b0edfde1166c55922c6acba3dc4ef2b85f85af444af4c247b071bcc7d2a869e2c804ea459acd762b1e28612416df701dca5c8d04dd6b28d0996c912c0b668a2b1337843d52d1fc16216a49bd520fc44f722441bfb9c83fc49c2cb4580554e7ade3dc068d55c1cd0ec15e0828e8d54a938b695b805b6803960275892ecf2882e3f412c77bb9ccc1a5f38601a79e43c86ab76ea98873cf0a941e268e58e65b0cc1123e3fd8b6a010c62775009383405120bbe15c706eac32e2bdf7e3d07f8dbc833a667aa0aecdf7e3779f966074dbb2d36494b0a9ffae215d5721d7c1fcc12eaef551f88352c59caafed1105afb788322e2a23de75432c99b1c6529c79ba22bba4313b4ea61f85512ec4591fbaf6cbdeec295c2c7031eae535d2e96e3e83069f8daf43fb5d4e8e9381d047ec36dcd150d67c29bf358c953f1d634b649c751a4f4c3a9801fa607d69fc3a162f3913002c58fb6772f855a8189fd7d5dd9875a606980198245ff9222d8fdd10ae2d3a9867aaa8feb7bfce1eec3b651618ba601e1b803cdd258163ce19fecbc9544e29599dd4d974a6b8e3488bf367f54e55ffd883137d460396a728e04ecafdafaf8f549ae5abdebb182fd28a68742f25c401fc80a3e0d32c63d4888d2707d9f0dd8e91cadb5c3a47b3cd2d2a86b156711ee5c0dbd6a4c46288cefcda6c0ceb07715757dd1b5b618de278492b2ca60cd3f44c53f541e4964caf93c35fd6e8a2dae994c66a11cb28955f5d8e1dc3e1b74893c8fe2301eb2c36d285a0039b966563d12f233824bcc500b5529af0a4004bdc3229bdc871819ba805840ecb648e728538f5f58a7b9555c0516d79d62484f43d03f1dbe6c8ae721faf3ff499693c5ff7f8a4bd280cdb4e6dbace4b9d38fa70d2277efa88b097dfa4cbfda117ef72df6b3746e311d4928053e029819ea23cd33ddfa78fab407c7b1637804aaef168982124be1d1080dc871810c5b15c4d89ff1856c261969d758a6e87048bc1a581c8d65c7c62517a39cc1e59c257b98f1d34503ca5cfa7cb52620352dffa39679a1ad8005bcfd95dbb1cfe179f5d9a520cf403c929b03a0903037ae412fe58b6d7b843022bb045d8a2f4d7ae2a98f78f1474146ffc146c3ce84c04718a57f0a35cb280f93b82a894dcab7a6c4ee7b41eb4d449e05f872be3d0af5e16ea65d354699c81bb1970c2cac81543f03f9d6094fb19009c7a203cf1d9bb6236b1d23d76068465657df3b467661b5cfe49c6c967e9fa7aac866fec542c8f42e1ceb6b209a94fc3609d637e77ffa58f60cb7c864498ff1b1aeb1d6a08ff2b9a6153d715687c4a48cd6643bceb3a232720030a20e43a249c6eff5518f9eb91189ebfa45ccca0eaef96e5378f11893a42410012d3654dca0b74d89e6e393ed918dd73931b3d3440a9cb01287ac012fe429857b1918980efca9ca4852313393d3841c9a38e8e2343e980ca55b9d8471073d3dc2b647673ec63575abc744c27a369a38318a0a9e492c90c119a4f42c9f0df73e000dc68f29c8ffd27990a23a9519fdc0e369eb73d346d7e1a8bf7280d448a64a822ab7e518d406598b5bf957fc656b7782381237c793b89776ecd06932e83426d569e8f6a2cc93ac001650f6b3ed6a99ef55692bcdb0395fdab02f24328b6c44b63b92cc61fa91e0cba309a0c866562e286dc7e816052ae0b9fd1f5ecafb5f6730e7575fe13474be389715fe75739640652cae48f4b975208bcc19e8ccf98235e0268512ff737e4b655a6bdaff87622f379f9b52f86ad7be43832fa00da6c9a9892939cbd41cbc7b1790d0c8df503998766e6662fe403319667a30fdacac2277e5d5f8de4dde541f3e5ae86d651d565c359b86217d2e7a589e109539a6bf94b0a2c902efd8b84937e08f8df14eb0939c0b88907abd085e641e30135b2442214e416b8a91e1d6a375eb9c046f3b751f23583c0ea2f5e8ddbc14cbf62ff9481f5ccae2d77ac53c0668d03b5c5c03f5025b15c7bd3a20fe2d5bcff25294ddf26e851b39772774b78bd02de1dc7bbfca7f5674e6982d5dcb1d2446a3b04426e45646b3a534b9eaa5fde761324d624df7f7686493c25a62c7d719f73294fb5617a4742d503da841399c3e277bcb5d9cc8f2e8ad12b8a145b35a6882aecee1aab87437a39bbd29f4bd6346f15ad6265e37eeab3b1914072d50cb1cbbea4b351994763bb4668e5c1f7dd66b5cf4e43bdb418ce77557040933edd0b161de99d8d0034a6f7003fcf93fe4fbe2f72e33e9ff15db74605867c70bdd4cfd932c0c63579d0cabe5eee732cbdbe3e0b187a843fd0b27ac26aa7b21a20d63d22ec6fd876b510bfb248c9b3ebfabe9462b79fdb6cc8476233dca44ab0eb3f076cc520ec4c6c4da7b9b21b21bc11a59c63f279f6b0588f9114422bf6f2a787345548842945dd38a8fa667dcce1a8285192a6bdaf7895205bd8684ef286e45e575bbf7e2ce8f7ec0f5f03162f6277c8dd7a8ac42e54a6fe7c67db420eb948c0dd181b9119ffba3caf6c9efed2c01e941ee700a400db6e5e371f368d97e398d86708420919e8bb11597a63945faaead10f6ecf00a119942951db046c22fce9bb2f117f33965e19b4e02ed8b228ef58ef1aa82afbe1957dcc4de7c43263845be78ad173a06e74ab4d314ba7a3b57f469ebfae015a65091c14149ebf93e5fca4bee1561949ab5db0e474eb9dc9ce24a7e64a59fad311ef59b93ed45886c03118b79e17ff2c4d318f3aabe5acf8a8f0ee12023c3564a172e9b0dda97a5eb7dcdb5155a4fb0d4e6c4a08dc7efa4259d80051bad61136de00cd19572572e9632e77bca0625e2cd6b81c8ff83cee7a5291eaf2b8fb52653a5952345b1f365c2de56105c125838fc79f70f59715add2d6146203925d5d6b7250fe132d4b20b25e09b5b0f6e5b0b8abf3c6e1e9d03d7b62c519e2f2a05338327b15128b17ea1f2c8381a12704da9d4a8246fa3d487144b84cd3c938286773dc81d62ba154bb2df5494f621ec92a622c492d1fd283eb0f4b648acdb15157b4cc3d6840c39443d99b515b1d8274c970a337f8eaae25a6f710d1e8bd03558d598ba02a21f7572aa40edeac3b65ba266391eaaafaa8117491e993e1340ac8925a7b407c293a0aa33359602194e0d5a1b4f9239e1dfa714f1a8fc5469620b9e7c4871837291c0d36e73fb9bda3c7ef636f293fc94a29fb0c90a36d4279203ca056e21f90962d90a6666be5e1b1f8fbfa863c1971db683dc8da1cdcbe213498d67783ad7829ab9a9e97a768bdb48b7862a8cd6a724c9c40b8f2c36120e63a0acbe857319dfd0181f0e44b2e8f94f460c0143f1a73f22ce45f066d62363ccc4db6f80dd712b5a5968744b94bc2a00e02e43f6650b588896080f4a9596fb291011f407a6a426062e92a1c5b0387e992d53d658689ad6fdfd2fd0d964f89df278a4b7f04aba8035270fecc72ae9753dcebd0cb0781a7a6c77bdbc6428521d58ec7808be808f598e3ea4d8c4c27acb2c238a173d972f225eb86c8c27400444d50a3e1ddf8ac6c0033148e69adb1df4483cc1960be0e32759be1e547b7cb5610253dae264821a2db74130f1df49f0852db7b441d5367052d403d723f64ec2b96ebc79f26951f59c5b883ba08ada089f361840ead64ad790aab0dec10d104d402e915828968c45d7e171281b886cc722cadb7f3a10c3e96040ed7f0e4aa9ac42f126345b413ae9b60a2aa7975d643a1cc90de56fc35e57c8660dc489f12f221497c3d647391eb07ff3d8b1705ad58e80350f871669c0717e5944a80e6cc4198a6ee5506fcd12b4c93b807bb3b28f305a592b516020f85604c865a0cd33d41f3732a2d0de5710e02ee674ce0cbec07e7ba10c018847259cc3d92a5144fc8c61c3954bffafd2fceb05815679cfd0176aa0b4118b315723c9097db6f16aaa91a685f0d7430173ef41953c5a22d3b019d8483076b5ad7f4874abdd76316f9bcd893c879427eddc7e86862632e14896f09e4d836b3698f09313ab5011ccd419ae8666720bd45c9a07d3876ae68e6b305be43a1e6af4976e82ccc4b6495a6a220489f7523d7d975c7b8eaaafded7cae8ef670a57ec8eea2f52d493f532fd67070c6e8e3947e76ac2b040ce560e74c8fb8805cba8c8afe314ebc9d15459bed76791f4895464fe7e2f242c59dd4d87e329e131727e62f1ac7b92b4fb9403ef522c203c6043987c6e628637fa1a074e933e3ed187b75fe0e829f53dadbd74db1238ae4fbf50d03cd2a0cad7268c92a0bc320a591de5c6ef97fcfdadd8ae544c89f53a6c4a06c16988f265e6edd4d9d26a8c4b6806486be08c681ff693d5d8e0eead0ca15d457b85504293cbb979a0d6684963d1ad6a01dd6262dc046b4a07b1226e61196b3df860ce1ee79d6c9cbfed3eb82198fe81293804730f81ae3202c793c2c0c50d6e9dc27898f076583a727f7c1f8db2dec3186d7155989bb52f0c83a0f95d93ab40c002de72d54f5e3aa355575ebd412a04eafb66e2f3b922535eaf770edb5ab3a15fc34dfb7fa0910c05ce4f175bef9262ec56dc07bc6ed8da83e4d240a5e6b7afd79301117ab094f2e5922fc53cf6c60da172a1e398dcab9def4a4f6008b077ca46dc1e6341e4462edd3a274e55ab541a3b76858416edd7a885c9b4fe13e618d1f54875cab476b59f6017c1decd4a91a3932da3635d85df7df3d3528da0936b500f9183d505623676eebd9b1c0811214aee07f74a1cd720c141cee24217b1508cc8f959d51c744ba7c4f164cf9cb1d2acd6375df6e3dae85705e5a5064f1aaa66a2c77cb0f6e8c2839b66bff2d01c33daa127de0d5300af3c7cb4722022021958a7f2168847d0129c8ac58e476a4eb36390d7292a7d9eb933ef2e936843735b63a4c8210ac8a3bc0ce99899c4919b1194a40558af8d1ecbd28f79960a0673b9b702ca991ef99a4cbc7c50b219f26abcf57c41ac165410bf3eb122c68d6de055de7d22f27dd98a3a4ab05654a738cac36186279fa5d8f6c20a9353f354d4c398bc15c45c23ba3b06df6632f959129e3e465e97890d189583563a03c7c668c4ca030ddbe9097965f713ce5a0b4dcbdcd07a5fcb01302a5d4260535d83400044f50f02a8b6d5d5e4d57008eab8f5ef1b324671a9f1f539ff544c05d91b08e4095588330eeb89a4ed55038f9a67e29eb1516bbe1a121774ba6991f11a03dc8c782c5badab8d7eb601368c612950e1e775755b9187296aa5eebe9b5262ddc24f19d4736555990380b7fdb690f492f309cbeb09083d4c6ee9b28af85c7eae793dd441674a2bdb023be33470357798d886d6b7a1fbf616c1e6e7614f83e50ee7c64e5e18493dcde43c00c0107eabc5daab55931d1b2454d4933ec4ba2f0b1fc01bdd5a1e35711a4087d7f79c666a8d949944484f5439a194bc6e222c5a0eec1a16949867b368c95c8ceec78c7e11a249583f1ed05447ca0da4ec2e4e4f751a767f9aa246160ae40d3ffa89c2ee2865456ec0f623c8b73bb774aec5d07abc4dd80859585a4ce5c860111c845ad81272fe198fd5953e908a1ecec48ec7504504938afa07d1ca14d7cc72e0ce8d5580114f252c1a21848a9e6a1910d314c35c265ece8f61f0bdff37cb7f3e8e7090ce41a41f11adfbad467781eb04004063c2b7b1538a1c2756196182c7a67ae9ec7e5993859f86fadc77d691b284ee8b96101449d420607334abdf2980701d580007a231d81d86605f822ee4e1c03074627e656925618cc3d89c1e5b805665c1ec79fdfe93f8c7d8330b76971b41640edc0c8b6aad8ead80a36cb900054954fd02d59208b9754e64fe5bd39043e0cc56c08dfc53db2817b116d99beb3854afffd3a8fdb6936197f1ef85564bca8a17242e3b2da645071a0dde65202645c844491472568f021fc4ab3b4566bac892adaaa172fab68f5ed8cbcc3a712a99a9a5303fae04f0aa0da59066fcc44643b80bbe58b12b89957c121ad09e974aab4e00c3cbe0c276a7cf2f687d110424f2cc1fc3512ce031c403fe56c44273e11922c4850c1563c9156b1e907a6334c2150b5bbcfc5f7ff581f40a76a7a29e599fbfc79e6ae429d917bca532034b270370684d57649d2a5db5ac4733f99973b8b0854605936c68ea49c60ad478473a69e389fa1824d8dfb63eb52d1eb340570a3071ac2547bdfa3a880e8c5f305fdffb43fcc069aaddc68abcb4e436d59fa993d919b0104736f785c0ecdd960c8e80b9c1ef404a406ea5e36dee02f0845aa545ca9cf8120f7653ae69d0dd7c24f60a35e7aa02c08a93ad2df700582e634f5af23d4065b8a47a77f952cb97dfb239da836a3ac98c5a5d81fbd974a7d93edff470b5b92a0df5b1f24204663c30d242d1beb92dbf759b1ae36d45ab78d519e9b13abf58eebcfa93a0a6cad7625e7b9d64862d5882465c076f14dc0d4fdadb782a98d62226e1935b05f7dfc1f11db051ef124cff0b4ee0f0f18ff3cb5e6536498f6500ce272565ff70603ef3d446d5d64411c45c049feee5a96f205c92fd861be397af5e01f2183f49ef3e0239cf686b519e25a38bd8d85ac3890569cc96dc35097abcd81cd49814a2ea5ac06d700d505d2a77ba7321e24fcb8ed8427566526558ac92d092706249a4467ada4a6ab3f4749f3012bcd46d5fda83a8bf96988f88117fa181dea8738846545d5e68becff3a264505af2477fa7e9f372a0603daddfec82faf23de082d24357fe8f5a8b1bb04f75e7e4942f606ed8e0be236794348778bdd13354f0ed1b3572c8b69b3ac09b3d15465c6a68a8da7253cc2110cdfd637ac3d22deb3831d1d0b75099063067e002ef2f1bb39ce1cf3521b8b046615d71185ed4f2e4ef6f89026f29cc381c92d7af8d532f69ceeff0ec9124f1a187843fc991c6c375b332785042ea1b8fb33ff0af3bcf8eacf278e266281da3a686293603ece0d19de46d8741f707818996e2b5d0c14f1de847a5a30d80eb1fcf34d24da3aad6eaca9c4bdfe6a2b70bec8193f5c80c495f39419fc833be50c67a5d58a55d43f290698a9e1c1727c440bb10057f16b3696debf3826f4b10113ddfacd8b9b87d1f56fb6ba91b1cff30a2865992bf2104327ee9d01891c1166d0fa422f851599565849da0907b262f6719acd49124eae230b3207a381af2f8d716cdb2f214168e9270dae8189dd6deeb9be6fcb9f76e0f5ce68487d2b1aebbe82c2be8d5523ca0de8677a9ecc61893a6e469bbb2d7194f5cb9aed1d4ca5b69ad8e5a53f184b51f97d437ca0d9978fcbff88807c731de8766dc6e3e47b3bd87885ea1a7bc90d5563a0b2e5a5bb310bf531bf2a8f85bcf15520569b6bd36405d25a8b455efae1ac7264c1841fed52fd70608753cebc440e7b92aee4c01222af1ebc247ebce026c20da1b14524fdedabfbe8142e2e680c651f056503b37923d10d10e724dbfa8c5320994c1f8ecf2ca0051ac21d96c113e9d9b466b78c2d733152dc00d751c97313cb419b3b6c614023f7afda0b84b849b1d5942346402911d3681ee5f295cc03d11fb5dfabbc56173be8fd27e0e02f0fe00234130f739250ce5205d2f5a2961499574d922dda1e4dbc066c587d9a01cd1ec73e8b4bed3d316e309ea758fbc3850afbdcd0b906ed016e34388c65dec61e337361557e49dac0112137e0c554d394f93307281bdffb329cb48c012e567e3394d102de588a4afbe8eee3d9b0faed4d43ed5fe7db4bba5c03459e6af9d4df23e1871d1196e0d834f13064cdf02db3d69c3ffe74592cf6a17553d04431cedd673ab791c2cfea6dade59e0c8cf45d487c212c3c07f521b08b3b3e6e1418ab51e32937c291d0ab6fe03c623f3ba8ee2aa2e6be4a3e39d8516fd1c93228973e555e7766665a6a30d8a049bbe0b7d97a614a669d9fd2e01531e036b5f2fdf35141dcbe5d403d36dd43ea81439f0cfedf3b0ca89776487fa2144e98bd87749b628aaa0f23b6e52d23a2927eea634ba654ef696b4da83de44f5ea1934571540f79301d6727a0ba2e4e8f62a45bf772edd5180bb56b724d8fa26978a25a666eef9a2433b6b257bfe1661aa88796c821877b75f6d477028bf865d0967081e739560d983761d760f1d9a04fb3c2eddb7ebee37fecb961a6565407d0bdfab5920819feec024d6aeecae97fd76192dfc6746c7c0ffcbc15e76e73781b35dcee369f0673e1657140b18bf876d4f1811034f7c37803d5596a2000eb452a1fcc97c5e64e037d5af5ab6bdce7a39b6412d7648f3bb6b08a618f9971a1eca237da1812297e80d226e96bb2c73c0850ece51b222c384664dd20ed258d1845cae5a1b8c6a354796442048bf50310f90b7d0180288b7d8e87c47402c0f9198b0e18c2ef8ed14c440e9a2556d069202774792f3c6988966d31fc1bce86997374f53b14c0bd6adc8a763739afdc7cc5ce453d101024357ae917f5dec8e1fd6f6bf85f5bf3f3d513ed44a411f515941aef577989ca615a03c0a36f76bc4720e32f8f89a1dfd4c6d447d9bd672f5b2cbac105409767fac23cf69ddf04713f1b281a4c7d72f57596bac270d162470294d6d5597d9797acf43186ac6e321ec300d515d05239149a9f25edbe53802685f7ea7339f56be354dc78d3bb6b0fcd19fa21a97de59bf97c1654001a636c8a5b414305a265f09b6193d11d82aff9811203c4281e53ae8390c64438c61ea5256bf819d92a3ae32a8a0b716171d07f53882d8769e0d5b1ea706680363709e468ed06882b7bd6c8c7c8d61cde3af7ebd9277dcf869fa3556edd8173e19f9fdabed9740813de9e8cfbcacab5c781c1f39920a4062171d2a6915b0e04f3f031b82ce168e29f0b42e1a1560e09d7908c3b4da466b3aba6972200df11068237f10ad03444af841d73ce7a1d6a606ec9c39c4ffacfe7babbc9da8c4465e708ef6484d5438d0c0fe24394f5ad9b200849134a059fcdf3501074b2e42711c475594b9b7206ec5ca9f07a180f818911578f09e53b00ad74a0d0ed7edf595b496a4a80aedfea1443dcb3801c620f5425f3c16cad8b5dc270d8f1b4ee36cadaffdca455a435b10c72f5f546e7f525d2f3aab5515c3df9800a2da6d09fd0f2580d9ec6b748e3926665a6a5ad134124260e4a2d85677349b761e5a06db4314ca6dac35d13d6bb15e29afd30d0deb2ffd23084f5c39bfaa98e3cc9edb0215969bdfe773b1acc7ef6fa8bf28db8ae266b90004e76c65c5030725283245dea7248c26ab632d742f22c4abccb53881aabe0502b6aa34c0dcd96036b14e95ad0157882d0b7f11a9e30e1e6a6a18fb0875a91a47011068d7a3ec1fdfda2d8c48b0a0b3ae62b5f760db204e3c5018d95e3f0dc791f4dc0dd00289623d74afc6f1781ffca0e919aad3f08f98f773439adf4bc5b75ecce31667743e0c33b8438ea835b8b99ec3aeebd28eb1fee17b0a71bc099df3686de01687d1f31f7ee7d3037fbf29bf413cbe6629dfad84d533036ea2e8d3c0ff9295fb29c9957370f6087602afaa00a5f430947d3ee788d1397e9aac24effdcaba048b4668a941d91e130938d33d502d119ae96aed57e8330d96174b3730b80c433e39bca8c7d8c23437fc6a4106b1801bb48ce05d72ff77a1c49fc4a0fa3a2f105e8c25d260602e7c74d7d08b7ff1381422cb40b57863030ee48a792f444625a947447dd374f849a29e2b5ad0d4d3bb905a40d0178d24dfb77e660f70e7d1b9e51cd79bf7d5f4fba926e1c610b4b255f55809b9db03f3e50fe19dbae0e0a3d1db9eeccfe7d5ad6f344effc82c04d8420ed693a85b949ea1fe4a1de10d0d480c2baf12c38e9394b726d41591e070ff0b801bbfd270e6ee295089e6329beed4318dc950eac59bb58e8cf07d1b07a60aeff77028b543d049fd03498976d29603701d60db9891a87e5d3be0b4434d2e31f627c3e4106bdcb250681b4d1487cd729a008469622113f9895e0fe6822f687d12e00efa7109079b3ca371b81d77e78732da9c6a8e62ef19d3599bdd433ef175e18a5ebea974b101800fb14e6a5baba74be41d78e2bc4cec13149abf5e29f7e677244068bdde6aa7dc2f4309d7cbcece2522e8fcdda75d42c9b6c11d989e1dc3d6cdd2b7a5b2e6113d663135482c0211e1c12896e694f075f535f5d8ce003d1ec5c10a8c0b141b2a7b0a4dfe61e65f7277c936cc88c38a5dadf17cd1b5db34460325eeee948cde781e80c3c841f628a4350559195d2db97226e3c7d75fb00044730b03f9e91ddd90fb0d925992055740b9a5e89a5fd6715a8db794d7f24d0295b8a2f90e7ade20770e1d40fb76f070f03a06c2b285298d42da3f28e3bad2c9f19eaf537f0f1d6887887a45931e1620907c3ee67bc57602fde1b7bbcedacc54e18cf6b8135f4a3b02318c0162f6bb32f2812c668bd8c4b42fa7bc0844f2e73c5123cbaebda37fb2dde02c6453b192425e3cebb01b055b552c6a203f76929d6293600c91d4ad95db13b9790288d190a7f1ef2b198f4d3703a291d33cf43680a3dc284d99e3dddda1e8ce86790a541fb9e78e2f560832c028ca4d012f4e1cbb87b4b71d83139c26ee9c487ef3999191a5ad53a16a4e1292d5c96f7ce1578d3dade997a3b1a585d84f36cbdda3f5a4fb2d999d7a93390c95dd49a7888bede120469ef534cbca90f96f3f32bd2f1eecee57bd39341bb0f5934aae48e6eb0371f958d2fa63f9980be7bc3dc238b37f908aef2ae263ef9b5f03e8f5ea443dce8140018000b3bb322f675ec22e5a74b904e600f56257c403a3a2b5ffde1b07b5b8cc9eaae67156ff0f6c2212eb808e5d8d468b23ee35a2474d24c85d94da2912aaba99439557d365791c1b5c1153783514d0cb217f70ede9501847b9cd7d81898c01dd5d52aec1821b45fd79b543118f70d76f5341f7723c64ebb787803fb645a0af32e1265a07bc346731056c1160f6972c270da5c1e67943acafb4f72cb28d76663530a9f39fbcbc2f53a42922ce0733d94d6a774a25cb5a6bd65af72d1ee7618fbcf2d795c73d8b7ff2dccf610423a1195b0dc59575cfaa6b8b7cd6f46421b73bd116c14bcf3d3a1512ae20286e426762040d7246dea34fe9935711c873c79bdba098652c8930b713729ee3e57cfd0284909f4e8746aef6d011923e2bf1ebb779e9eb3a76778d638f64c2c2284d452bc796cf5928592312918efd595d64f77cbc95abbdafe76566bd5545d2f734d663393474b0fbe5e126c2d8b908639f86326faa583927dacc4be2b521d2b57cdc99fc9fb2d3f112f8a252f83839e5e510634c05a0870c1e93f2ffac275af8eaef8cae70a931665c50effa82bf15b2e471f9d4dedce0c04932dbe75023a324df1f062bcdc776a2aade5ce026def5bd37d9a2d69fbc59b7df0ecbd47a6be792290d770b40236c6604a90727e71c912bf6684cda88eea8b79","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
