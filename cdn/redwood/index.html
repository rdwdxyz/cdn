<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"348e745293e9bcaee613d40054e21016c6e3b1601649515fcba635f0aca6db6d81de46c305caa7c27caededf367959f5c5a1a2bb5639426c5e56c0255fb4f08bc9d5900b4bc7558959216c71bc1d3bd6938246b4f94973f84f19431e538a19b69c9841931ab0cfa8cf057a3c39fa6f0f7b7c26793e7006a32bf14b57ba04a337bbbc58473fdb3c4443e5a8165d377643df03de70fd213dc6d3a96ae693aff81f2f9b8d15d575dbd1f1306017befd499d842825e9a7440a1c2c4e710e48fd1e3c26484884e41487129730655676e4b2bbec77f84a354ce6d2a766e57157cffe15e623622be96426620a8409155744421492bcc2bdcc9d0226cc998d28adf3e0379e1b8d7e689371060f38ba3fac1c0a333204db8dd9fd299febe14b7a6631022f2ffc26254d49a3c73b448c9b6ed4520ece870abf119c0e8da2f543dd4a48e2eb1d964b84f062fdbf36f7135eaa638c91fa3149da34543541f987699807877f36db4c98ab7596e9dc0474422ca404e04663b19fadd5f2747bef7038b2435682480f0e13a15521e413460e675242bc1af16019d524dc4e83ea544f7404533566224ad8c49391b10e8d5662684adfda2ab8cb753b5ed0980430f6b354d6203baff405cd98777059688803cd2e0da55a40f03c10ddc9efc094463566eff2898b43a49cb5381f375a2fcf587e4720e8ae460bf350b3144cb08d0c3d77ec7eb6da2b8cacc4e6a2bb98d4985f00a8e168c9cbe3ef3aba620a4990e0125d4cf83ae9afaaf852795c2dadc78d309b482857221dbc549984a8e67b7658d3c3c6bf32e0098a1767f8531afcb38111ffc054af1534cc968884c71a02e39c38ca1d145e5c07a44e631c06f98d56e224e43354b66ab4b19d342111e59f9318b7c0bf98cfbc3117985de779dbe2c3fc286507e80defd0706755b22ebc6a457d03f208c4cbb0c5f71abb23ab92df94477f02434edf14e9bade291049b38af68440deeede959e4ff59d828433a1d5b7d12c95af0302bf620a79dc7036d9202f305a8778b4ceff6ea4604c1cd89448cb6a6ee8764c85df6f0b0fde91781e5ca74c68784385d22375d568ec4ff2cdf2d6cb6e3b65fa1a53ee39e76bb6e45b50296a3a4d0a5ed391d8602364ce62e0646b007e21167cec1cedaea51da147698da4898acc6c9ccc18392f607ec2d5f935cc00bc9a20d9413c312b84f88abd68831a92a34d36375a9379903945f212bf60631f45d240eda88880194ebbadc9f4828e576d0d0a617f272a9b5d336c476224d29126e531df334056ab48f18ee822ab46681db9f8558ebdd8e319e15ffb27309abe39743c0aaad5f8fce83c13c16334db4e8c0a369153d04c83a1b71e650f0e77d82aecc135aac42b07ab9498b0da2e4292d7f9ce6580c7c26073fd8bb673f140ef0b8caf63f118b1917a667b70b1cae4b8cd432a064fd9269f55cea919f6279375f510178d6992e4223f7b456c2aa968dfef372dec0b6c51bc55ff53ef06466144dbd62b6adf806f447aa21843fb91ef7fdbfc628085cfed1828d9be5b6cb946803722b8198365a06d2c062859239324ba69ec5b35722f4ed9c991d0acf8902f1cab89ed63d0fe2bf44d6da2ab55adef9b43d25ad18ce5c0e7e4c9d65ae1883cd0567ebabc5997a2c67a8a9ae281d9df3e2f0a6b47927adba152867031f971d3df14da26c4b54dba4f45615f18bbc4579f7ad4be2110bbaae0d60a0b3ab3ea0233acbdd98b678a0d1f0f38b52c9f34ef5deddbc8153776f342be668054f48038e1f170879b7cda13d82c9a742af809e9ed78c57a00c7365f38261269a71c40d7826e2f9213303e2da5d1e889d5cf8a18771b694bf50a2c9ab5e900990d832287fc5a82550ffd994eb300078abcfb8047e742d69e384da935ab4d04ba0eb625aac6a0039fabf933a1292a359344ece6dbf2e286af80a355ecc548018033c00570acbf159fc5fbf7e4e03de7e906d87355719f916d26f5115de264fac45bf4a80f78d871c4bde5e22ab529abf9086ebb5b057d166c8dbdbc36e6d04a878477ba20c0e2897ad2580789e563c590facf6860d518101aff14aad0c8a588624a2de7cc5ad967596bd2786b417c082bb38772c970c82aee210bdfaaf5a4f2def111342d3141dccf7dfd096ae74c4a2cea68bda7245dd04405b6d4563113f3701c740b9f719517c69c08551d90255776c2e82b1bc5565661447ea49489c3c46541ce3119fdcc845e1012e8c51e07f8b190d59014a3c67e7f27ab5019d62aeff5a83d042340c1ebb72871cfafd208f3702d41d33e6ac200cecf1872b99efdda22fd00c14f7aa26ad7aad2427d6b3bcfffc3b4677ba368acd9b516eab4957d3273d144c76b3b27ea6bdf52b801338e2d68eedc124b072b3adf291b592125cc9d447064b518b2aea0cd8766cd65c55e7de89bc09a63528e4de3da329026757102fc024cdc66f1528f02e75824540ecea9c7fa32d42b3c36acd1d4b08a9c604d19c24e0a571c92c1231424d19182b7dd5460ecbd28713126f5690b504b834437dc5be38812a6255de636ddd4c668439025a83327d1d19c7e3aae2bf9374b31120da19e7d0dae64989dae29a66c847fbb55459da8e4396f619a62e323a40673e4be398f8d7593337d378d4ad9e1722ff75f98ab24d8e85e911597aec83047784974a2021496632ddd43116b5f967975dbaf1ed41f3ec44c2114d97c1a1ccf3c43ec4b044c12cd6f519ca627c15db70e9703c5980d0c0adc0da348f621a6839703a73e9a481acc0cbace194525d4ebcd49623d13de3d74a695c9923be13b9f8cefb25999e3d4d8d3af8d841725b9eadddccbabce41faaac850d02b6719f2a32a5e8b2a76b6de6fd8318ad4cec0dc9b1e46f8039d63121184669ef7aa5d58accb550b1c537a6e8010040faa1bea3a3b86f28387087b953a762dd66f20fa420c5f7b690e68ff189800b5135359f4cc9c54d2916184240238d864a51d3af374a0c6a79b6172f15dbfbeb88133cce3a6b6e31311468397598f61e52f3748fffd1a0ace202ae906625a4edb0164a8ce4f359258055f31b318b4dc905b8531b36abc89523e108997ab2948e2034582b98285b5e8691b870f03eb46bc723f9cb31b138866fdb452ef7b487cea14e69761b29d6ba5d7225d069480ad62f263b44eb6b6a884cbe79a69b76dd506c69250f8d7f80122851b1f11dacf19c361be5b08d3d818be1f42da65cf06f2b2ad620a7bd08d58f297803e57f8c8d34f5c708546806e79694d4e9a6e17f6f586b9bcf38836ff63ebd03a059e3e213704c8f1df27e4f7317b9c536e3ca0527c35fc5be1f0da255bad872232b1edb27c3b6ce0af50e275b2c83ae80382c3c24f8bb903451410db9f5b9fd613ea38eb4408724df61f9e7d6647a3998884d62619af0b6ee51ad17d41df3fb15ec1dbbd1d1e4cdaa696a00fef38bce770512a6d33e696c7eb8590e9518c6defc5ff79ef35854c98572eee10f3923aba4984ea5bf0f1cf65e892a74a07c967b877847f241ef875de3da3037fb9f8d2310ceaa4ec3d5caf29148ca96dd580e42b7cb7fcf027c3517ba6e8a002738ac2908907640f3d28cddf42ec7066890e0df6c756df9851a11014426eaf0f45fcea193ac191e54775ab9e1ad9130c0954abc5ef4870eb0233aa77ab9ef5615c2df75868c58f1d55e8479b87dcdb38483872a88f395bd8af11ac07ffb98dd701d6df56e0944622ec604e15f74576751be391089ff31289523281e2a8aeb47bea563d837761671868872ba24f16af9d0929ccd79f966164d1aedf4e4c673444bc4c9845401e9dd55b989d47bb01cbf07b0698ca3f7682a20fbc6aebc244fabcc5cbccc1fe81c00b2ce6b57c5ce267ea2b43e59ecbfdc5c09f9b0c89485251ff3ba018e15f0a468c67b378407272653d7bcffeb5865c7150bd2d6e1d58dfbc3169d4f06213f6cfa1b7768c7af0ca1185743402e9497b6203f00e3e87b80245e74212dffd9198ce865e8cae1824c48013a7e860a120e91764f9c3d3262fe4af6be109575df11e152604556e7290ea7ff61cdd12e2be2ff2e2b5896bddf131e61a802f8fd2be9fc3af06f1becfca1e951b84413532b78e9e2eb6f549604a717bc2efe847fd7b65b2064c532d8cda4699c8c19927fb1892fae6e04edb32edc0ee57ebbd76d672230b96fce7c70847d0758735d5c5c599ac89cea017b9730343505a43595dcb22cdc2a52cbd312c5f7838e2a1d479c52ed9d42d5f5899d0afba63bcc08d4bb34e9e76081419c6821b19cd1667942623ffd830f77b2404ced9f9d080561bbfefaa3e0d9a66946ed850c7e76a2a236a1c556e178251fa321fdc5c87978bb6dd283622561ea7f1d7e2cf18a1e6979d27721f2d3ac151ff0d3d25927cd7d097a1550b9b61e9504665404f7c3ae4c198a5a610a24f682b0648e98f1515268d8516eab26bcb224e27e04629ea48f416e2f83a373152f0c0781792f09f797633701dcfc92d1964c13a5dcc3943f7f1e994a2eca03d0bfc805a52ba484fcd9d32984cc90e2926885c5324142cb3c0ba23374a4c51659aacde6bf7a9ff6ff5277a7ca941e2e2682956c6ad9b6529118a12a1ebecfb9bb77d7ad4b23163aa2a8e250ed13aada656e51f899210a91ad9948a39ff8b0ad2b5b413dc4ea35e87e42ede11b5775882f787d2fb24f18ef1fde8f72b681c101e3939df6f9ddd693a9a704eeb24d0075a002d895dba53aa011e440c30ae3943401d106f7779bd9398939fd238039ba6a945df88927e958d80ca0ddd75e4888d8e631fa8a1d41dfaeee0754f311ccb5ffd611523c709063e90c9f51ee02591a9b0996bd41f84547d066dec8da1ff07a15ca567011ee8765b7e2e5b9be7c18425e131bfefe1582d043254d9f74c1adaf50f956f6347b7a08f27a200fe0a1bd393ef7a902afc23d5040cc6ff339e2f3800192f46ccc36b17cc75182004875e4024bdca407e54057a32b510768a56101731422b01a9adf8462993fe497eff2d5f51d932cc60ba6ae5a5baf2b236edc2510e60fba856bee2697655ca5a4a90f16d07bd3997c6d5a9c7babda195e9e72f5ec955c3b71cb7288caec0857fa1131577707cd43ea9828734f548869716b579d1c82f52b46a663b5aad4826de60140df6e9c91b2632d046f641bb0f2f20b1644e582e2f2cfab94ec4c3e7ca98f614a81df3556962a571bf191c5606e3437070c1ef975a417bddc65388e1fc76325b4d4d4efda17e39fdfde7c4fbc01e346d4960b0d1bbecc47140e90313c0ac4a36fe65d33258aad097d606b6abd3ad4c16fafc78d70de0346c1ff2542196f11257694dd10a132e5c02cb0cb8a6d5102fb12f283be2463d16e6b4c44c5c1b04fb0cb50a562aec8f49ad4dff5213d4541e74e377c3c112a995f1453f1ac0911d0ee6ac0d2488d2a638e3317b5df9dd5573d0e4153b50752302b3618e9ab1cc8415029e4aef282ab0e4a808def295360bef142a6add0baecd61e2b45efd8d68c9304eb861a4529f712c20cd4965455e0ee726a5420d1670ffd51df60ebe675a3ca34f18abc8ce100f7ef8400d93754c32dd05549a05e60af4c35a304d301c729c80ef9ae0ca116a45569f6da28d893a3f992480265dd0029f4e00dab03b17cab29a6953ace278c0dae18ef1ad5ddca375f79164e45b44f4916b256e738ab94e4dab8f772a809b25740f98b9f0f6b0bbf9ed8aea738b6ab3f2699afb21f33696146ce25ce1504da708ea8d9bb2b5d7d3e7a21a5e693a6b329c8ba4d854326901799aa123d78fdc81dca30d2fe717bf9b47ceada76f450b6f079f74c93cb6651e48cc67719315269b3bf7bf2599552f70fa45f0c6813ad0e504b6e255d0488a173e800f7d1624724fa813d52ca63f4bbe233370a88c83443be89de0d339034e42641eeaa00ab781e5da04037a00350cc0fcb21185435179a99645c0dbc538107807d75f3ba87f5d1061acf4d3dac9ba2fb3ce7fc88cbc44921f32602ddc7b2a769c92db88ae0034b4bc989b00468013e90595572dc43ccc5da9bd727fabc7258fdac0f0bfe7b4ce78c3d42533d910c284d7295ffda3971624c88baca1dfdcf75b68f36220c236da9b5f1d1f4d148fd105e612312b5fe6738eb468fda81b9844317afe9e648c4c7a5d75088e18c7e8353baaf0eb7c01e143f2d0033960e1288ca0f0782a2d149d48dbf6c57d0220193dd0ec9077bf8a7373c254584f3c8e33d24e8698a07791deae4ef2e46d97b47ce3e0be1ac93f9c37469004f39dfd89ba85edbda63a669834db2b9d04608fda5505755ac64ef619d6b57daa8d8867b7610f31af21c18c3f38fcf39a198a78ece2e35ad96fe374a33ca8569002b18f7f10e229665d269aaef9326f2b23e943e6ab1f7aa79050df6c74c1a8fd381d9dd8446dd5c3dde1086966fe399afef4a503bd995dc16fcb6d44781e88661c46453f472e8c55e78783d06f3157ae89382061ee889d31dc2e629b234cad2a504a43ede1152fa4d44df1e61f9252554bfa8146cc6ecdaf3d99f75d64ba0817c40ccd4a129eef348664a3a2e92ad4aa50a237d0a0e10bc5b822f276b59fc83756ab9e0b8bd73e2750152ab41e060b99abd2ce15ce498f59ec726fdebf9e8f151ac2872fa6f13efc8e0e92e408258488bc834aacbcff370157262013446349ffaf5ec33c18c2fdc5bc45a1abd191a980ddfb7f50800ccd3cbf17a1b3e542a1132f8c69739af6c25bca82e2419cfbc809e87a3dee47f22ac82235240d5257f08714e38b768c222ae4c5ec7314b30131f64b75ae178a797d6ec8cad9dae5073e29dac8ffded2c7173a16c6a2fb45a5da1ef8890450b9eedd1a3e2a1c7502cf2e48c04d62e868d4bc4a29d9793ff9643703a11894f1ef3eccf0901c9c54c4c2a8ddb66580b83a34103af93a276e7461f85e612d82f31ea91cdede06fb639638adb6fceb4e087419df3403b7647ee628e8dd8e645fb3218d2f49a0af81d68a23dd192ce1bec0322d18ff7a49849fcf06077b5097cd6be9f4caf1b4b5ccc1432f7651f0e374e1ebc323283ff3e4224c2f591af3565790f52ff6e76800b437181a2cde31e2407a709497409ebc674cf25daa0284eda5f8e28f54bc4321f899f4627724a180d91885c37f2065bb7d062d3d53b3a9817994214f65bfdf606bd36ac5d35c21cafae7ad72837df93f08849eb104a4b764656292cd96d2619150b3cbcdb4cec486541a50f37bdc603ce41b4760d2268175fadc6e33fdd025c7c814b6d363316e3f9143251ebd7e01be46901f065782541c956b9980fa429726e5efd648b6d8c11d6d218bdb98fbd8b6cf70734f96df0434d84adb8b13e133ac174fad9899445ba706eb3d88d7fe7121d931acaf0462ba20acd4ae496f17d6ae709890495421a1f653436667a02d67115d741c47ee80634e23c658fafa7d49d37c8deab93fef7c3005ed259f20fe7b2724a89b5966e0ba068b8967b052bef62cd3b78e4cdafb69555baa0887324df9608c1b4d08087fdcb6d72964e3ada679b85a551a686428fd77d759c373ed844a92038fb619806bc4d98c6b343017b2d2f4e6117f529c7d06b23486f4fa8fc41235faa492abdbebddcb4e96cda4db4548789fa83155c93bb8a2b14475af6ecf576e3fba39d5f0e312540dd14ff490c5822b82ce253efd7490d0d4d3f35cb0157d278ed0d44eeaa42d29bd038eb71aa5bf85d205f1d3b0927b8708f557e3653f00f7933490723ac6aa1f048944dff68be32465e0aa2c1b79ace24ba4f3a82c610b2adaaf6ceee3d02c0f8d27656615ef647cca61741c22b572a023af5133213556e0f253122ffcc701e58de5e19957b02bd22274077b2b14429c13b421a42985f2bbedd11971966fde862dada0d8f4c8c8ef0f10ac13047af199dc2ff0d829a78053a091a4f4ba6f4b0e49f7947394d45a535bc3e8cd360138165527ac210f5e585d41b2e32edfe2f2c2d310a3dc37170d9d12893c819b4747458d714c076a0937179f5eb8d8bca115068e38a5190600256dcf5292eefdb02bc7b92285cb5aad918f02d026d2a0b24f6efae441034fa3acd60400944d075d0998d61ce3235084d9a5971d21b01f4eeed92e19e1e7e356738761b330b33b660ba6897d31ab0e3e9538dd13c90e0e15e407fb5596d202291fdcf5da6386620cc929a8bd52367ce17433434b7580e60a73f3956e0bff321d292cff64965e7ef80809661c702a03e61222a9a95dc5eb3468fac56511e68fae790047e14b6d8a7049bf6de1cb0d55f78722c85c97c25de7f807e8c0f89c9125ef4388a64948dd69042c26c1ca96b807e5e52dd4026a3c159e14c4f510da464a1ae06616af8a63d8d4661ee049bee116d64a532a18fac2c90e05810533ddb86ce9f5a09ed83c7d04261d6d6c7f503fbb376bf7ef6af2b55ee7e068c41aefa7e764bb88ccf4b709c2db9257cba531fe67aadf9252518b9e73c59445dc203dd7803d6bb077ab21fa23d6af3225ca8a0efbba2b85ed9d96d19f8a299894cd1f237b59fb85577fb8bcecc7161e24639d5cbf3a8a5912304604e1c5a34baf4d175a2c6fa6b721754fb83a6d245e681594f6e78303d1d58d46fb58b18be4c1fe0b40dc6f780dc26c5cdad3ce84f45e9089d5db295c0bc2fb4f369c11cd36444d00071046fdd1c356d49b560bcde856628f13d2814f89825c6ea211b4a5e93b92e6ffa8d9db4d2f82438c73374aa393266d56619197df7b9742574f68f3a07dff37368c946a597259d9260b43d2b8549530a04181a2a08937e66e69614e8500bc0cbfba34e112f2ddabed7c153fa4b5da0cd7da1fe64410bc2601a0dae0c822c638458e4ac54fc8ca337fb3dff0e967b28c71a6db7ec6702e89eb65af36f0b315aa7eae61c337704df715808b3aed31a6fb54cb113d72c51e87beca161bbe0577f65bcdf0c35e79e5c2fe720e5405978aebf24f3259338e10696cd018a077b38c70160598fcfe64885abe947072f7141a6387eb4089351faa816556b42e5ed60bb3e745e7ef263c2d409126885269eedb608d1e0730e8f2207fe140223487b3d273d64719691dc5dc38d86b0d9a0944ab645321141ef9c2bbd3d6597e0f1f01a631fb1ebf30a4b4dc61852fee94a88fee6cd99ea06fe89d238117771752847297897ce831941325cbae937087ff11eb233964e41f197b35e7d9dfa800394f07fd1cabe0c1fb7e46734d64d663de926a3a34639f750f1b8f47fcf4c9428b8c468a587db9a52cab8a99b2978451eaa8f6f7305e81317b0c2e9136ee681a3b991e92ed7cf9805e2416ac333f1bacdd7fc6cb1296cddfb5bcfa8bb7a9133d0a2f19bf4b8c8e5c6e42782d10ea5927f8db25ea7aa6ef316d523ee59ecfaad1ef11b4d5e326be3edd3f2089298ca95e7951ce4170d631218a21b1e1666a5fb45880b536887c77e7cbad1b1c4cea97e25debc140dc18aa8268ce714d5c4db9fb0a633977dbb8e4b5cd59100a4015847df9a844b09109c92778df964242ea334737ac7eabd86557b8f848574c6c06460687329da250a3c78db22631fc480b4fc50def02ebc9f81df93aa06c263d58c30569cbc0dc63272235965dd63a38ea858df8277554074a6186a9aced59d30285cfef90c013b19f538489db8a498d715772d2bbb2b378502d7e30513662ef9f5764c1e07e1b478fb5613aecc6b6da6229f36f0de675720ce1ef3fccde1c6ff17feb05586b0cf61dd1908b6e8911d5ff1f493d45a304bf37f8de36fa5c4b2189c1792c48b53dd5d61f6aff48ceccbaabe20e12025c951cf1f569cbbff9729a59b53193b85ea5627b4dbfa6abbcba65dd4a24e206ce94e3c14cc0b98d40fda8ffeefaded6b448066e7fc908745f02d7b9d3b05b38be0b75c3065e188b5039944dd6bb928e1c68abe8f8833a7df0e85fdf34485fa2e61ffc0990e1b9591891e40521c9bfb9e09588d5779e634ea17e7255948daf5cf60a7c1891e212d31817c0fb5ed9c14313cdb4eece9d4101bb29adc1d05bf9a63e9556de9df0e3b6604fb4a1fc5680e48a68af55f18d77f80e8cba4839a445ef6e97a6bc80474efe7806e2c92442abb8368b882fde337e1a6ea5594ff4cdc6e540c3da509d75bbbe1faaebf63647b51b08f4c834f50d991f11bd2389afac8d9a2d35588f7bc5e1b0d8725a50b676667dd64535eef3023a02d925757049497286d78bf8ed2e534d6935afd1a84321df1f0161a6373814fd45d1ac41d364ce84ba07e66781d6ab177dfd1e6d897bc8bfa7a4d20f2349d2f5b54f0ac7a82553f545b191a2a14cfdb5091e1de4669446a409038c395d8deeef8ef57bd6c94d5b5de2037cf93fad54567384d4266306cddce3d20198a29c2b79911462992180ccdfbcab6d2bddac805f030e101aaad9c8f77fa80e8e7afcfdadbe4a877a6e2117fdfbf2c33380a285f6b69cb24903e2df0e98c50a7d1eec04253645a51c480ac724f3b9d8fb6e19a8f49834d7a90f4c63cfe83f1a6e27d639a04fb45ace7231161ecc567204082de648d81f30ea39c91092ac19de4e03719755d84c772190ae422fd7f303301238f420d6559ecbfaef512c1575cb649e31bf676e703087c44c7db3816fc90417f75cf46a131897b3509afd1789cc34db05c9631f99069088f42ee47f0ca189fba43091b81a24b8e8517bfd6fba376c7a344f3a037fc7702bb6d30881f17b19735155df0ff6d53230fc908744d5f6c39e15e3a7a4770ba8a267003cfcbc56ff4b7047ca61a5a4444566bb4993312cf4e0b9987a2a3537822f83be081a54d1382fe2963909946c8aa747b752be6df06748d7a8dad55cdabbef21b81152a289722fae4cce47bb94b9fc135033b57d1cec13c9c85f2000a997197d4ca5c1609966c8fac9d48dabc689105e97316eb1cbba0e329bb167146a1b25b16129814e23980d564916473c0cc8d7f49690f58edbccd05a85f58bc92df492948d7ad3219287735df2b82456edaf81ec0f25ec983bb584e7fa6f2bb65c64ffaf3725ac1c2fe0a6437164e36018cadbcebd82c238853da8d1b621774980c7bf6ae08e53ba2819b28b38226b210fe578de2e68e68bbf6807ada2a0b83b863c5a95524ebad2247c48540afe3989ea6eb04c12967af05ab1a8434c9b2ddca2ba7247a77996e8af8095537f658d6932b74a309130d6dfc58082ef67501200c218b86804eec0e3e44ac4458d3d5b6e5eb1da2ebb398044e4f6c6a08cd562fc0bf088693b1db8d69b41f3933f023e77813648ac20ab093723dad4527b0c7d196b296c6227afce0b8949b884c4f057e4ce06c22fedb73c1ae262584ac0611bda23df5c628991717feb6f6d4ddb3843e476ca775d93ba96c734c61dcdf4b5b25f4115ced533e7453a04dbe829dba2c581baa266c86ea6c26da51dd49d5088d68dfb03bd3cdad30cc4e4d5148a1802199053e2e4cec736506509fb8872fc25231184fbc87aa2f3113f96c1d70f60a6cc7352b74cccaf8ac5b090bda5ad662ff11094356e12c032c25893837a36a1f3e576d2beafec2f84e1f84bcb8c53d90024e8caefa6d064ca5bcf790c4b3afd2ab15a00888e3b77f689809f6365fbf6244ca040bb9e21a9fb7b46b59a256983a5a94caf3a538efd00e4b68ca6b9ee158cee81eb7f443a376c2e7ead725130ad4e4e5f2d1c6f86a76666243446b297e2825093809f99cbab1d7f11af0f90b65caf785bef9f67628a419f66ffa403819d315a48ed4edb8e42a87555d8c112b2c975f3c67ca6497585000c3c2afb310ac4c502ac5529d6c825e7a5aee0819b2a61457567f67d4f683270b5aece586928b8fe4eb9444557a0e844126e69d19e8189baf3b006f35518302eaad65d1b1371c2111ef60cf35c014499b20e169ae8bd0e6b9c747587cb04a88146baf71d8b4dca21855f1cc953f91305c1218c40ebe53bc4295c10a086a0658b146241b0aa51a65befdf60b6e95cdef227eb231d1f49c0bf6b1f0bb458b118f99c6fb700539a17d592199a2f89d671343fe9561c59ce90afb18263e5a1ea07f48d128f5929f64ab8b879e71acd9ebecd70df97f529ab5d7f1af529553a560122167c1a087639345382df78f225bf9008b7c856fdecfd83d71f400555115abb776091ba01a1891ee07fb54d5301162bd89a38101db3d5284d6adce6784a451d58287fb26b638257fc9bb005fd07426ba545c14aed9aa8b2838a645bc98d04108c406000942ead3f93ce64f00a45b3bcbaff6e1aaf5903aeea6580b6ad8c5790626ef9f17d79ebb5959766cfae0ff07aa512260dc4c2e52374e337781b5732f90ef41b781082a1754ec1eeaa8f11d809ee92565f4e976a2ee089fc9780c34c71c2dc91e8531d419cf2a84564220af60292884ec6afb85ea9a321187a581d8ff653db64e58885e6aeef30de28bd0ff451f46a17661f1fa6aa7e4491e64a81b82523c53100efb309a7f880a267a79ef05af94b5b56b5419c0934d4fabbeb2ae4e8564068d812fd051fc9edc49cc05d58068bdd5efd763f905778187b442089bd0e2a20d447fec583c40b3d6f6fdb3ff0d395c8dda5e5990887acc3a912fc82c90f8a2a294bb171cd64a17682b02a840c7cc30daee19dd559d8035b23a8aa367174ed73b685f36f4389bd5f63e7e356d178ff6d10a2aabb752783ac895cf3e27fd95fa0e47db2c8d7cf5da45c4cbcddcba3ac983cb5150fd269cd0a28972e525cc38394d9f031702f77c194f001b4a4629e8ea5c321f51f579e22a4739b34a47e01411226bdb29f6350392f85d52f056e02e1cf9146439cf68c3c5e1f8400484b3905eb3e25921b827baaeae03ac71164ea9f558a5efa80ea22485f679c6a7269b119c5e2dbef157ab7c7ada7766385f478b2c4d447f665f91893c8cb675c6778d159ff19447d489628e64cc78bacd98f8c242acccd911da81c945d418ced3325ad9f8477e57a8ccc60f5e7a2e1e4c435867981b790da46fc5176d60febaea4d358e399eeca53e5210b9866a77128de8e0b49d701bbf1855906857f11cf61a17fefd561c44a4be8a7c83b401cc24733ff85186a0cb966ce5ceef52402731dc31258d913ac3552c54f99325bebca3c3105878726efb7defce84c2479cd63e9262123884bc5ffa0b14ddc9570bf813d799ed5a4d888be6f3ff6e4c54705dfc0727481be09ca149e285b560785af7da066b1ef9a5fc1888b9afed88db43f769587e779a21ef0d9232ac0abed43229645de93e7825be4752d2ded01b2441a4f085b3a1c412ffe508a5e5a317aee8e334f75ff154703d7c0a086d19caae72cbb4dfb1b1bc5d1c435a0546571d6c421c3ecd930229fd9e1c082e8b6bf327a4a3b00348cb0ea3d04959f35c127caa83adaf2bc4d66472bd72042eb47b143c8c2e6d89dd0b57a3d87ff4c0413daa2d2544287995a4d21b71402f444379958e2be12d9d72535257de71354e6db54c362df953a0a1820fef4249f387080396d468aedf29502bf0dcd6686f3a292535a8be9d145262395cf39316f294f7a439c0e369b29b2cfd8e0f36c495999b5f501671f30ddb10ebb32440aec57bb559ca528430842b9dceaba5d6e66ae638c050e59071fd546afe28a03d649e17e12776f829d2a6285ff791b47b0652129c47669deb9512022d4c162f0715ac69c629ce01b38400713ad3c0fe63d22c52525b397e665b14037c983e2b7d885c7e7c682db303703181a7e68dd778178fe34a50a3333ab056534ff1216420220362f8bd518310bec650ec9ea695f24f9c78b449058b11b149e2e300317dc3313e5e10ea7ebf71c2860a2d3b82c8affe98ec6f1db34ff0811726282550d4af44d28fc2f2c5e3fab95dff6630f7ecb04479ed03c413f7061c78d063d0026d153b574c4fc65a6d160b914df9e5efa4abe8adc161c9cb8c271ded3b5d863b64bad8732721910678cc66ad93cb62f4e373e80c37ec94cd8d68d4b0174f788e5e3029e34346b1e81f58fc3e6c1eb231a0e712c0a1a52af2b65e423dc9019b90fbc6387780e2851a666bfeafefa18f7804e5cca63043758ddab2c475a746da1870a77a1745dd5025c68c529be7c9c06459f0f0b60f2c2964c9db23de67d236f80ed5d46c80d14c911816fe5d72e533a6b4bf90af03422187fb6a8251483cbfa21cb0e3bb1362a4b7e0b1b8480605c3fb9cca44423e1bd2b658482b564bbdfa4544aa3e047edd6dd744dbcdd11e4fad5ffc728ec44c52b1b602d4e48079684cd5772a7d5ec5fa518230e50b55999abdc2c78c150869e500f06f28b1bd686bd63a248beb004a51e52f6e5f10a167cb7ba5bfdaf724ced4323e549dff9e2112606f656ab6620860156d691ea33fb7d6add6f27ee77fe5183ac5ac3d1f0a3a7207f36722526720e1895503a1a37e46851f2b3ab45959458d95cc09c93db5445c98f06901b02a81cd9ea3052f197798b2c454ed96a5a8d0dc67ff158e7b84545ed6cfb874d4add896498717f5c6658ccaa0a9dac63acc1141b50f56062207723d1e9109c1fbdbf6e1097cc7b6b38eb3ba86032c942b77d5c0594a131c9beb5b5b8f7488886f1bc490967ac662c49fc597d9d72ab1a9a4be198401ed381c6d5e29ea5c81c9006da82a603a00c9985d8607d5f467b7d5667d17c220b9025330af12e230db6e8c1ad5662f705f0de1fabd08835e8919527739603b05db3e94605164b4a3c0f6d36928ae52e6a1d27ce9f4c1b7463e725492e843635218ee500ce1e0ca9256be3465966f8d3d29917c320676040e56919a1a39ff32b257eed52df8b17c929fc1b0e149182961869bbd0495e5dd0969133b98f01a14d9e85c184a093f00ac3140099d32b3254106be8f81fdb9b3147c5714ef1594cd4a36b5c7b4e94c6f276779a7786c05a27822ee3504cff949c6b176f9ba0fa9cf6ee8eb92f5cca88140de884adb4f11a03549de02b9f35e59088c43c7d60f5a98034fd1e401434f4c3ca2bd72dc2ed10e0d69a6578b3a8e22bd6545215fc5269a92baf596611753ea55353000095e3fc3ac0797f8e1da312f917278e6292e172a179e465677097815f9a3003fe75c5e2bd41111d26a7c76368ee233798024f15451f1d72148e201fb92028bbe64f808ddbc16953443456a01e721f08dc8fae8ec94d17568cfd83950d2ef04601d8867d5903018bb2f4ad308c35440aac37a088d1bd112e7d0c96ccd93a4ac8ec22854f94c00a590c1db84846b3d69c6395205b3f88051d7b1416c71f9f63d65d4af6512ca1264547744f093b8126d0f716815248c178fc597dcb5b7ea5b78b1a80a8690ddffc8c68682565451effdebbdc5f0c008e370b064b5d54dff9daebaf454ed54de8172333e8a22978e25efb157fdb3fb55ed41521ff6da3629154133aa7a56308b6e5add0301a931979ba63353d07a149d3ae0caccd955b50f2a2fd05934dbbe5aa4cb95888c2e26e03f821cb6124c05c6884572538e74ff381b3f25ccc1a60aab3fd5a0232718f303e6b6904f667ce20ff6bc27f297ba94e06ea648fa250d345f97d0bc7348308acb3bc1fa65a067df1dd2bb452bf20b763dc7c2eef31d72e97962da11f61b908b163e53433b90761c95724837e71265950eedb957848d689bd3875eef37917a7c2827ae9c29bf95fc6282815deb1741642f7716e88681a92cf625f7a87d1e4146875c090e183cd81e424094fb90efe425503004ef72b1fbfbb7efd75e113e095e5ae157dd9f348468380dc3eeb320836f64627ad8dc0ff8d7391630554715b4ae8124246efe5c516768edf8c7971ef211f42cd9bc1e5e3c64274da39d60d0260667e9635bee9d00b3e718829ac032f606cd6047606badb11b715439794ca64a7f5796f326d303744d96de3c217c839d0c0be0bf7ef34ad05af9f95b7bc6111a1f1d41edae513fdee662f88cdd2bd8698c31bf3cfbd7f608a6b04497a70638d150cfe9562f4f661d566de1592d8b16c105f0aac45ea04fc2168e47a44bc1f61ca4d1f8877988b18d2c6533d82ef397f85699899aa3248fc96d35d463496c8f1276dd3f824f08a348691835e4a68710686cdadea7d7217995c8f47f3f33bfaac17b46a7752f39f38600cfde6696864aae9f64c3f3cb492becdb601aa12dfaefa9c93bd10e7d5e1e2b31a52ae7394e9e7adf33c3a25705bf6f2c1101346942a370e2714dddfdc01eb9a1ca0c0259c3a31bc267925c79596159af6882bbe40b8c5ff5b1af95ad5e07fa64342f53b7efd785dee24b4f9e7406e429341775427caaa2ccc25f97038f3fea6b6528312edeaf701909a563df65dfabd2faa4aba6c106331ca44bd364c4959e580d34aaf8893d420fd591b3dd32d93c33124087803ad1d14679e8e79b88af16330846f27633c12130775842007f9611b141d073966c864b7396cdf21b6dfeede9c3f57eb7f28fbd0a21b69c2a4a169848c92cb49b298b4c3d0bf9d78e8a459a62525e61fdc976ae2c64f72803243bccb1606c802649eb7923a7dee4252f47d56da95523f7aaa77864ef78b699eb5aeee751812305817a4003bf958eaf0980a614d95b989c278053d7f82778c3913b5af9aa9d1e31ef25840dca4f44e889673ba770c1e6d4fe31e700a34157490bd3d73c24fc55d9bf02bb47b3373519d900ce4005762f6e29e28c296913978e1933c0bb5d5b5b9abb04d09ed7e117902d572944f6c415e5e8d2d303e9dc87be55494d11aaab7b855661d90fa5ae06e359bcba06baa59ce5df2058d5133b43b3c57b5fc2e44d28e1afe868e19303e909288069989c83e838f4d1ff4703739290cca36c8fd3c2d141842e74b0793a86d040c8098fc143efb0327eb143c0497f15ed0ea115ac27d209cc229d5e9f42eb55198587c9300e1d4db0915334b873440489201af9519a6886775c7c59a19e40e1178d03e4a5a6fba1c3948a12c20eedf6b82200379b29d68ac6db46c5bb426382fcd28c4887ccb6481c813141fa015c09a239bcc169e887861ce7dc3c12414528af7366c9aef1c2faa971caf71023fa40f424bbca15767aeebfc9cb5f94781bc23576de21b072cf0da1dbc84bb7398cacf8cbc5c695f84d61f2d4645e33ba71618ea70ccf2402f4bf0bea243bd9146ba5056bcad64c2a458a0d9dc08c1f57e7f5f279dddd2411edf35ec81903c0ec89af733f82308e634d4399d0b7b3292904dea8d03d335b6d9a277f5d5b293d4349dbaaa395e66d80a3801c4533b24c08d1be2dd0da0318bc120edea6fdba238038324ac1bb04e3d109768f4bd665f9afd77ce82d80d0d980a374e16afc210a2731a561002e046e2deb9ff94be6ec1a9481b68f852c6c009a2f0f05b725f7725dde99a98a8e630dfaaa14a82c9fba2c9225b0e343595356c387afcbca6719277d25d6bded0bf40eba73f1b0e4d9535fb12f41b72534bed38311e832af558db12f7dd72edd6948ea4c12408ea84d27d0966ef3120fe24e95339cc7d84d5a96f588256807727bc596d033f8c2e3a69fe33e98e655c99e7530fc5ee5071a2039447b8ef14ecc07a45cfff6b3cee99ca85fc96fbea938ab607f196f1a01dac50172012ccfc95975b7a1be481eacd03fc442ee0e595d4b14c201b76bb43ea9724f4f4a1ba22b3be99e92732642fc23c309dbe33e2f3b094b72cf9cb2a84c6c785b2e2830899eacceea4e9b66b71bf0c0eee64441e693428abe9b8902d4612101d63d57f519f2275b5cba4283ae09ff107e0fe3a3a88f727ae8ec3a3be8a55b5ac9a01153358d743cc5bfc8b59e8a64ecc2a75370f0aa86b8e75cd3e0a210774c1c22ba0479ae12a6884810f58e93e49aa96044f5881718a685043df735fb33c25045ed799c833fbc3aee1cdbe65f6a77635f46b9fa35dd1f087148feda55bf2032a2f6a8c6b7a225b9e29503cb00f005ddbfd592fb70ea04dac5d1b595c1dfa1dd31ef913a151438cdec15c0725419f00c78f2f92975a28643b9a60b46e9a0df2ea8c00378925e66c4ce627ecaad2341513d0d107667adc3bbc23af8e4ddb463a62635438e3c5193d5066723711ce471bbf508d140bfadd0c5573ff32ae99e2967bf4de585d4869a83a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
