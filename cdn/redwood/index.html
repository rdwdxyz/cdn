<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1609193648764433640283f929a2c0f2f1d63c6aad8a512c71926c2d77b88e1689b90244721d311c4de118fe477db4a41694400c0529349b71d17d0b4cfa91e77eb90e179285a88436be4231d7d838b3640049c302d6eaf834b0178353d2fb27a7470dbd3d299ebf23d7572164de218a5f8b0278b70586ec84ee1b89ed708698b6a88929a47c26a328bd32d2b14299cea1d9d08650342a2aa699bb86224d503babef0a78ce72feeec051244ad689eaac0f79220276b8a3beb3e65a532744db8b6ce49951529409633e2b06a1b13ecb13fcf8bd2a92e1badd397992958511ff687b25a8354c1ed5a6087d6fd3a141ad668da07f3eebf36e9c9c1a98db17b9821e08a2fc141bdf3f50d22dc56d8752165246bdb3348e57796cf97af0b6e116e7ceda816fb0bc199d50655fd3f9b2c1f8b95e5cac0bca1c3d76a5e80dda3c28eaa54a2cc6660afa3f7441a60365eef0aca48ca5ccc3a9261f826737069c35151643b5547577becc1ea5e3545fb502bb76c91d4dcbd6670d017aa02cd3c52a2a01de05d40ffaf04873dfcce53e50fa4d7853f2dcdf37117e860ca402aa33884a3aa66805eb0399bdf84e7e0b97e20d792cf7861b08bf448691b84998fca7c11279c128e8a8132cfdda56ccaf6207cca2e89de3095ae2cb75048491d51d360bb2a6c81032c6e326b959e59493a5319c328696a2f2ca31815865223de5e8b2f6422ebdb64a472ddb39212bd9cf4d07301a9acca38c266150c1405ac3021383f839f5224475d7f4d8116f48c2ad2d9e50b1cd7558f6014b89cdc4bf81b02a5ffcd7f65eab0a0c9b9e7475d010eb664546033587fb245c7362cb0295899b22f6a086789840581faa8f40b52f6228f4d3966ded0004d82c7aca4631b258ac7cc67455e27f8eba2a3df63c69d86784a206f8449cca701e2b62c9520083a2ee9214117de7f4b25673a0ad09650d34c0b6a64a43108df0831a532ed82f806fc1a6469900f7d4bf2c1c494bdd4fff4ae00767dd9662583a277d3f1c282350efd8e6d6da71bbd4bf77153ec13094ff0e47cfa6e5e56aa513ef9ec4afce5fb8769dc4882ff8a7d7f477cb653c092972103abf39b6520480116ac8cf853849705667dbd9102d5186fe93a765746f79fe4d867b05e8aac1ade041df6520991a154bc82ef9641caea7b97100297e45d5780ae12a6e63bc0416e6abb636a3378148dcd002b55ee0e16d03d861840625c580ed6b2a626bc21e485bc74407236d0ea8db32bab30bbb12bdcefa4a43f84a4b12e1ddc89a0d9e9bf53de76b05e5b4caebb54f3eb84b38d4e5d4c887263c2cc68f140bfcb049ad3b628754fb9112ec3c0e8d75a3de8bc6088fae71af40ee498eff08db18a5dd2cf819109c797a3b47a7a6a0c3a839f4b0eb764099ce1470b0da79e6484cf9d34ada88e23d1b8a3eb7dadd97dde3634869691d01aaf650582056bdb5cf42e12b9f65b0d15c67f61a468de54eccd00fffa337a4666f37c6d34b7cd873b79971ac3fe2109a38cfe2c8cd7ae3bb332602411c11c15453922629914a3db562d5f239a3a626ed6a1e2a46b623890636071d03fc5176ecd1bd58ccd94df9361a9d1246bf65fef813b647f2a96710a640687bfb3d67a5c94bcc5a246b8206d9bc208b651536f0325218f4aa8ae20feffa244fcb111ab39302ed0cf32e3baf9d3caa5ee8233e5cfe362007dd7d0f355afb4ead553f1e6816fb31e5c18f66f145e5ff20091e882e3e241a1d958a0d3a12d2be987ed681f2c6de7aa4f2de81cd052c30a8fe9dd07445ca29e6af677b74e1b370a53dc6df15e8c7f31e939fc951c290e56e1096ac8e9cbea873c11a80d101c51643a016436308d6fa0394dce50e019c8fe993006b1f0d1dbb25285adc76452f3977b746fd27011819fffa35f94ffb77ce00f1ff7d223b69a45b7e3cf5d4448a4ab5cab66f464f1b2ca9d1e6febfdcdb2b60b601eb650ca9dfbd6e9eaf36a19f785a632be26ce4243a9bc0345f56c1c2a86fbdcf863b5e00519cfba483fcb45f872667590b0ffb0204faf9cd855d6506f5a6c266e0a6ae3c43ce0f7a53b93e913b03c5564ecd10b45564889713a872a42fbb959bef43d35094ca06b4e5878f11cc7849d666be9e70998bb865e10bd346ea6a411fb6715b0791072e489264548b00840f2f69de8382a8a31a82f3dd2e75f16746a2ae6f531457424a4f3d8454e40e545b53cd5ed27fe631725ee7c36e1c23a1aaab46232bf34c1fdc4df9be2da1185b0c217c27a352fd647a6df6bc045d4ff7358fba9e5c866370cb66dcca6335a4f6dd9305e3c46dde4ee58bc835f2195c9ce37e66fe72259cdb3aa09a12aed7509ee5005b4496ae04bec585367a99224f4d7fe2e3f14ceaac1430959985cf7c32be43ec173fffa75e29374ffb0c6a222f174db8c6f80d0c1a37c41367e0db07a7a611a3cc71937afb9ef6aabd88bc9c04a897cab995395d9c0523e02881ffc5772117a1cf6cda12f772a814e8a671c1e774b6542403afdf2b8380f31c1ec06a022707444ceced9eed5238865d3dce802f839721e84c83bcc7d63aeb9367754f69ff1bbb84fa45da56a8b2b791873da38941ed8dc56b1543b0014e5830a4576cd2339b6039b6174f487aea5842b61013585dd9b4278ce534cede7defd6c62edc25a1ffd4d453051c4cb94c6a497a86d79334e3f819e2ccbd0c9b858478fbbb202d428441e01d5474feffe29e3fc35e19ee23b5a25a01bceb876ea21bb73f7b5f998748e931b8b7b14e2ac03a6760db1125c2ab95caa434c208a8ccd931eefe7aaf05f614d0dcedde6452d05a9ab7cf628c2ea2c39b9ab0facf65b5ad5f60aa1cb8b9d357cc7e7fca0c375b43f90d45736f5b4dc67954b792bf8391752429fdba4279a863e528799181b1ae0bb6574a0997860abf55e6d96175d5116f10787f98acf7c7ab1f6ed83864bc38ebb9a6a6365694f72918e8b8a98bfdfab05b41d02106f21e76782f99d01498831fdd1586a77c3d5f59e12b5293d971ad593896d72da54b390cba690c14ab856339e5ce7ba67a6e5539d323ca8cdb07fdbaaa11d8096eb2ad93fa3f3921bba17d3b76d37c28c2364b883c954f139d44085f41f853a0a82b5519a44ae2e27d72e6489f7e35412a7e1d975114f9ac92635b96aca6975bac3c7f81de17c6426a8422ed9d0cc0dc4cb3d4e2f438af559d2c6ef25158e17d64a14f3086a9b0fe57479b6b79a8f2a303fb7119e87cdd0a840b555e33acab1cad24bb59defb195acca35dfb27c5708b31187781a6e3e673df0029354ad3031b416fac1958314d92fa79639c905dab731e2ca36be1f2bf244cd867a6796dfddac2a5b3e8e9c52e00a80fd41f817fb2cbb32e96b2ebc8961c7493eb5bc45a978247954c73eaba188129636cc139f897b4d5116536f637a749e3e6653b7aa506b401a6035c3d834b3e71a1867ceb10908a8616b4ba5bb5ee84efed10e392cb8e4ac3edbec1cfb41cde05e033fff1d2022235770e0331362cc48e1e289f85f043319bdf8e3356f3591fb7711d76aa55ce53a8ab283414f597aed381ec7af3838299c7b9f780afc3ac9e82ac38dba6c3d29e28d62cd48b88dbf17809ec0eb1cf2f966d688175ab5925f09a26b030d3adec5d1a3b2f74bdea54123ca819de5f98316e865bd437f08271b6f213e648345a7d4473fea9de3f901849dd46be67bbf18c396240b6d753ad0f38c14334e506f10f2b8f62b384a2de4f3e5b6029348b68ef00807ba9cae461e4b892d3a86fd40d2094624305046748e9b7fa88bb2ae236059713b0423a63f5fc7aabd2f1a72aca900c126fd886837289b7299fd498fab788adb880f6e3c66c800ccf97c33d3d571bd29b1c78fce1a1648f7e56e6570b009b8cd1d0426c223038b30d7751f08cc87b3481ffea4c8ad9278eb487706fd8c3d36c6dedd558e4f79550de539880022d0c8cd09aab8e3db5095c8c9118cebbb92749f03bb5e1584dbb24b258bfe4f6853752d68ae850aee0344b6c527ab033df24c6050e544b3e082659f62480382c1e3392454fcf4a85147f5c5e418354fb4195aea1cef1b3dbb89f42a582709f4ebff2a51ca380d785a7fe5dc906bfde59b4af3c380f331a104055b895f87911238f1cfe0a10f59f5d57f7250fb78d58653dd3c6b9995b082c2f7b1390a46e2542c094e675f4fda24ce362fbb58f59cfb45e17f8defcd299a0b5b2fb9dbcf03a35cda842931ef6efb7924ff3f50d0bcb9e0a363897366753515d89612fb6d9d439f27da08d761a4817d7148613a720143e9cff93813c9701a16a2b6b59d90affa28d2b4b8ee9ccbf1bb76276057096d9ad32edb947180ab02b533cd30f636bfca2f77c2c83869ddee1b61bd7bebc7300f73ed8c2ce0b24a54511ec1e5828da58b636219bbeacc80f4831664cae707176dd845bbede3bc438b4022d7640c64145fcdac396ed9cac9cb75a9bf5c3469d1595d6366e9b0e969c2cb07f41cb866c41c9db9a194bfdbeec65d2e132fcacb6eac3acde7669855bd33e1499da9823fc28e96c56421dea395df7dbe66e8881cb53e438f55ce3d3294f55d4971436af48d0e48c0820b863df014febafc147b4d6c5a925e133c9e2c3a17f1d779ae048e54451f44c28edbf27d94b094ba044c69f8813e818cbd457b58407be80ec052fe30c53fcb039614a04b9a3aeea0c8464f479daea086e4fb86221912d5232d2c2415a18c5d073c7fc53bfe9c6a71ad9cb0bc121d8f6150abdd5d46a7352ab1c0494b3f93cd10b53ce05b96c538ea68bf3b1e4bfc8434728f3c3c9f12d415719926d59bd390c8f2ed7b39415aab26f3e3d2938f5700535f1df71851b8ec3f4f04c2ad506921407be085510341c3c1dc6f0fb54e733ee5afedf4814d819a2779a454132f6ffa4f863092d184dc1a28204874f541c3528fdbb2c46d3799483ec12e25911c90dec0b086063634d99ced24890733394b1e19b79bb0231e9f9cecc73d964ab65072df1903678efada75614b298e7c0b205c0079471fdf7d067051d3cc72ec6af8983a035f1ef937dd18bf1d340e40fad012d6745fc7fedb191b91a50559f4673d52812a78a65faed118c438f1fee2bfbd32ff891040fd8117b2e9cd24814b7835ebbab6f33d8797b2a5f250a6d889f70c27260a6e11678a0ec0618a4e3875109ee8d363d6adfc119915c872fcc6ae684a90e7237d89e7a7990f008fcce3c5548f6ae6970dc9973b91de315aca0322ce0e7626617a6e15e8d49c6046a87cc1d631ae1610cf13e7ca49ae7c1abd5bd84b406399dbe83b1d9e89527ce5c7328dbed0053911051982e525bae964621517de0386d57d22863558bae0c214e78c31401ab128ddabe773e1f7076bf5bc08a9a8f6c77e4eb6eaddfda5ed662e39afab7ee6409fdf79dd1d116f003811965df4253dd563b27e436adcfb1436c81bb647f05b5dbb6bfb016fbdeb844ed865aa1977d2f99e639d7722a279d25007e2c7eacd611443e0d7179b9917d961de722b2e19d64a4f8d88116725c8bd0e8bef1a1d7c24f31f2d33c9d553536ff27ed80ee586243bc6c00953107dd8a901660c120c0a3e93c11d61456ea7d81b54bf5777f6de9d285639705d67a5b774ff45a94275450a8b9818ec7de88e157ab924240660e3dd2cca6c205cb107e9b745f70806bbc7760d9f3ca6e5f9b56e457e8abfdbb23cb76dff83ff0e64511e5ad336f90bbb711218ea647dc07eda33ca8ac884de1db21da1bfa667c5d6a60f04216a0791b41b6b99a6fe2a48f978aa47b5a53003d8e44e09f8953c88d3db7aba9996f2ba6fbf4da046f59993741f55164d407803361f268002acc615aabe928246d290657b724a0e2f7a714fea520e4bb4d69d2e4dbbf1fd398da34c8c1b4f23d4d57e9ddba427dc29e79986f0e21997f47e5bf5db7a89266b53009ad0829969fcb0db2a9ba65b433b8741cd4174d027eaf732dce26261cbbf824622b12c5d8e30b0d79039be58b349246b09a436a7129fbf72e372971cde86db8eed6b4424728564cee0f6259791c07370f79afe151f3cb55bcf92ce2e9387b02a3f84a4b0074334e25092b9b255bfa0ca62bb2b16aaa49916d50179d835def85fb073219b1e9347ce328d2000bfb15fede4974e4deef20a8c5e951d04d592ed5d5d34f84a434d685434e26cfc374e88bfc575176b07980cb19961eb120890039e38e94e1c34929dfdde2fadf3990e55fadcede2a5bf9f6a8dd228b8219723d7b41baa1119c76c2ca9337676f1a5026f1f1cd78eece08fbcafd11620f5c48d717fc4f9e2d86f7bc654b06a06d0500943ccafaada248a2b0364b0ed7f7b705db5c170d878c90c6d8293ed2e84605de2ab746b35df768361570589c89ce5c6161fd2b6f1db142b964632b5c136847f336d358f44a9a6dd60b77e290293abf140e29f8eab9f450814015a6e5ed9210c2f58aa72c9482290740ba423edbb09a7501066782906302e1eff106d6e02a749fd2ba02f15ff761d347cd17e5637ecbb4e7ae5a7efae9db7f4b7ee9f33e428cd3f0de120bdb422ae87d50b44e74d31127dc8dfa1b3b9b3d53a560aef07d8ab0ca4827aea849b1bdd80776c54bd6ded5e8a209a3c3e81b8936451aa901ccd2fcc2d0ac7143a0fac8a6e67294184aaf1ff43ccb6fc47b7c3da8c9e93514113799562f9bbb55129367b34d2adfd0a50ecf3bdb60eb78e5bb0aa947da8a265ead2d8c2c70d955a7cca11a02a5825651cd0534ebcacb6c86a45dd5bae35f5ad937efe39c530b1fcf333f76fda035fabd8f5559e323ca1f66315b34a5305040c76486bc5c4b8280417ce22025a9b784c7ee1a69fbc0089797cfac5129a0b45533088fe2fad4f8749f76a0e7ed2f1f3543313d52869c33b0a6981a8b635c500ca3375425c52a9357b05934a01e867ee864031d246a2251eba642322762fce3d048ed277ae6d94c3c8c94b02883fd46e27294f2167ba0f6ee7dff97fdbf96da666d92cf8871f43a3dcf16f2a6574698c26f0b4b0886b969154ab3073d59bccca936003a26f59a99a2afdac4fc99e14366119e1cd39bb9eb73722d004f17e0ac80bd540e6f4a7765a9f5a2357b60cf01d5aac1fea518fd3b25fd793ec48841a4c9e24e93a8ba798a09eb08b3992b3901b50a7b1b5c95b5d395a153dfb3f9f4801e1b8d2fa53f11ff74319e35472cbe9957b08822477d121dd84f28285402278b38e173ac021320924b82bb0931100f74b5d3f5de64346f3ae7875dc993e4ebc2dbb264388990ec322f0713b6fc757f6c21cc0ce66f56b09a4daf24bd7eabf879e9d0f136c6c3c8182c67962d618cc19c92a5a2410bd027bc583e6764e40e9d478574ec63938b0f1ff519e380d30d67f40001bd1555616dae95916fa50f66b773d3ce4c403e2555ae6fc29af35918652f1583460ecb004feefd0d73ea55fd42e70b82b98a46e723a54044f99450fbb9c1e293b73d10be0de0e9e55efbc4a71e82d6a2669e64f08cc6266c08d8e170d084dc97f19282db4d53d2f506743bf6dd5068320eddba5c105c30a0378097eae3c0f8a2638a6b8809031f313cbfa80b3de26a9e1a2b61af33a93192f7288dcfcd2a64d19a354f0592a9906405fa6add76bbacc4f34df1d59a54704962ec9db12ce3d119264ed24c052662bb0fa3f2140e42b29a05db697c39ac8b945535f6126ede0777a7c88c3668ae104b99a941c3f2c8bd73bb4dfb07158127f83ef96cf460e06d914af9dfb97b728e17f8abb5e96f64f1772f62ef8805c9386d854f046827bd6cbc5e132dc12278f455685fa6d7285c354482e01754f45160d41ee68c4bf02373ee67a707658036132ca3c5913b2fa66555fec02fd6079905b65f2df4d487133e8c8965810e4b02ad772657ca614c59cb693790ca255c12d2d38d0bd3e5a6862ce03beade5dc34e1ac3d80970f05cc0581650113f64f67fc4dbd6065a481791c1355183a58431da02b44a4ab999974c4a690172f95ed739f7ef65050f650b52f07963ad70f5b23707a1e4166d0fd8fb8f2ff1413c0df9f2b7d9556e51f8f5a918ec21c798f873757b23b60a01589369fe24e8d67436df9a6a62c455b3a678cb6105a9eb11514613ace063486edc571ace6fa5b9adade775670a01aebf88f06bf5b89fff74eb14392357c3150ee88794c4a5614afeaa0017843f68c5a76c8a92d6b331c738188f58ee44ef423bb139ca946edf1c8559e91ef3e041282d64a60ff9c4dcd0ea082113dfc76cd0c2e8941c2b0db94c11ffd145ce9aafefc16c904325f6b162f3bc3de775951ee3b9fb75727d69e8b1afcbe990ed4a5526c463780a9a9a1caef473d60c4cefa46d154a34eb49ac1b475a34309ac836afda80b5221fe3f446f35f75ed84a6b9fd2b5240a3c2e1991595ba422b226dbf52a79477634c3339ee9a6e9b83cc1785e9ddca86d3cecacb57601bc257b33f0a99bba42f6c93d50bf93772e5167434e0d963179b444871e4f7db68844b78bdae5aa76595071b25d52a899bf383343ee1e263512f010f5d4666bc174d91a57554c32d4843eca4d20a562e3cb5f497982721003302a74ceed8e73045f525af26bf9d453094e9438ab821694e57cb236b751550414834e8c774c49632d74e4582c1f3fcd9bae229beac9f7078ad41dd6df2c8f74ed94a7de9f0a3b952b4f0a828eeb19a0bb823b7b618a0bb75414fc6e5b613b9ad38ce500d91281008ecf3eebf23bec98bcfc24bed546133fa31f197b88289095a6406f5a8d381d91312a57b05c7031299eaf954365f11dcb1e93148c6a0f8dc3bd79070fc0fb5084c2de1fb491f1ffde72a41ba649c623903e0a97378cc9340b41b97f5b671062207aef0765ff1338bda87fd89a2c6a39e54205dd6a30fb1dbc50851fe772406a685e3e9509bf0dcf40d28eac5bc35c5f8b7e6402e0d5012fc52789b86e127aeaeb723efcefb90ec41c774fcd151899f9e81c23b2cd6d8edda9f6808f46f691a6b5c2e4f9134567bdadcffe8401c8619014cb2abc6e703907c8e5eaf586907cfbe2ccca69aa7c9a348bc397986df77efe2d139c4cce5f20b20e71a26752ec1d47a4d4c1226129160046be852e2915841d7d0f3dd43cf1a8b6a818343d93cc3d8367f4e9bc5f6fb7261e2143022b26f9e2f961a1e463c1c9ed7c81690936b5b17e118f762fcdcac9294cdc20b890930453852924d0200d6c9c17dbe55f7a4c2c391129370ed04d58bbb1fa1f01255be590ce3c2bd9772ec668ef0c61dad867bbb55afb4de6cd6bba13bfd21138f0ff3266a6a0dd73f9ad57c9590cc05b29e2358882632c57061919e5a44ab3f4848f933c79ac7cba5d61946e44b7a0e2f58c77f5f2f47e6b04d7c829dace14a4ee05be6d220a7de31debc5839d55b9f4721c37eeb546dfc95db710d1e49f869ba6c021aa82e2360e4b7aeaea79d8a394448f842ddb27c229e72f8fbb9705e4e1df4ce9e59149d3cdbdd19a5958fe3f14000ab9ebeaf3060e74a640bc9c749e3f3bc94c1f35aa2bfac33afdaa24a9f5dd1b9bac96567cd2f9a54128be8b8b60d0d79f75d01844cafe217d213edf461d8d5e48d9ec0ae4b958ea0a8142d1af1a477c03da40c4811dbe06e1470c2daee390e702c3cfc8ee7f8777d5322ef537e7ff0e400156185464c135909673ca6e02021cc330d78348dfcd150d654e52f2455b6fcb47709caffc136956ac535c2885ffdd9fcd400c676bbbf8a0de263f1f9a3098335b6e23d8ca7bb3b3dbf5b09f7c898bef6a9cab2747e4ce4ecf203a491599f1cff265c135cf9dea2cfef5e0991529099b8995cf801bdbf8b9d3683ee91573eea0bc7ad8936322c4083a4a35bcb23d50663fd1443f8e17a9c7526563bac3a74aed0d6e28e699efea0854dc3ef9b05896f4b4142fbac5bb1d5c39d05ad3cc798a21299bec27304e27c32893aabc6adbdf2f69efe71827daff28086395643526640cef195f788e7c7449d02d0da92e4761854c67373bf85bc76cae44c96216cbd635ebb5bd7d9ab3b8f63da7696ac30f0218d284328a2f4cfe9276d12277d1dd5fcdb68141d9e0359bfa0f8c8cc12d52efe36cdeb9841185db756a41d5f94e0d34baaa4048e4b28125c4f2995e90c9ca1d1123c04699c21a6ae1383be59110a65eefb0f7fc699d8b07e6c9cb9708e33b5591d68ec1ac549be33d14a3929d5e2610eebee4eab6baacfd3a53db3819989a4c202fbb904fe0beb1dbc2056c09f75ead9b8f0d3fbf9d09715c6eda8d1a91f5623cb9f3876a35ab9b2b727b231d50b384cab2536bc567a40972996f5833e604b321bbfeaaa4f4fb9acc3331df6c981be82b27a2a5be708ec6f9afe5b84c55b31d7e2c1488d9ae8f2c137f799d60910902f9a51419485554ffa4f79ca41b3b7d8acc1988ee46c3583f0c036c28d439698884733375047f904f22e529e34a2d4fd20a1af438a426143a210ad500ab2780fb9cea6e5491b7da3e1c9138752f5feead6d2c1041c0b1bc989598c6aa0ce91a64992cf5a9a6d5543db960a4a96848ed435b2dd43753472b408f813bf4e1c45cb992a6b021f1fa975259938d3d761892155a01da4bcf8101557c6c0733d6ae8e690bc3adf25cdc0e32566520b2770278bbce5708f627cc66de439d9d34cc14148706ab1f2016c56a30b2985d362f82a2415ad1a8e3fefa99062fdbb8d4c40b1d7ffafbc05eca579cc27b6bbb5576bbfce03937f209ffea83977bb497b4319e216a7139cb116efd396a946fec5e06ce35937ad3de249c6567e1aeb9429cf1057c5266b9d90311353dfc583d7d2a0c6249ba63f4fe9e0cf3cd615ba6bdbcf1f71be284aed70d08e87ee106828b8f05e33b371133d76ac1f833ac157101326ca21807c4bffb763559cccaedc017e93f45632f04713bebe5d7fc26786d94a74ef2a6d5e04d4f36756a200d562d4c6aac28633292c17c5e07fbc21e37cbd909ecabf437bee42a6f9f45aafd6971e9ca5a0064ee24ec5d830302e3ed29778aab1e239b8adacbac668c5b50b1cae88d12fe1916459055d4943a3c956abd31ff4dbaa1195e7ce4636bd416b989f380b141f85fb9cee61c714b4fb8f89d755ae03355b17a0faae152a885d732956458e9ea3c981b365894d0583649d8b4062edec3599381820e37b6e7eda34c0e68d199e289592a6e0130eda7d105f529da82b07a9068e4517a38794cb2b2d24d9bdde8b88a72bb7a31a6f8eeb0d92f396b68bf5b81f9c52cb7b3c7f14d47375d5b7407158404f79efb6c933dd3352f5ca1c3bc9b2e861f088dff1a9992bca2c8ceef31dd8740b380fc47c2ea8355d0c0f10ef9539aaaf713af903c9d8552954f1d46fc92a04204d81053b3a150de78670bd7fda82d413a40366e43d1bd9ca369ae509a382ff8b991dacdef7454c17d573387b746eca8fbe0688a52de4150cbfde4f00a03c9dca2fc31616bc4f03b56d0ba53517017ba8a373a97722387880a312d6bcf97b26086e1b73fb4ff686a76c1caf289dd856e534489e332019a5ae4fc1b4c5ee67e8b5ff68ad119b3731a040837bf96c76d62a003773b644b4bab7fbb68b2783fa8933004974a668c0fb61591ba20aba0d52ab10b6bee292233e0efe6cd00c6634d68232d0d388f49f7d6a69a2c0e839738e3614885309998e36bb6afe87110593cf702497d6c5f59d2e2933130faaec150eda7e58949b60d09b2d9c81719a571167a2576bb3326efd531a5940eff7493b76697d1fbe6f6d19cc0b83d8b10830b9a51c3fc029f74f7447816c6738ba6ba8adbbb160a8165804f0c62160f9677cd1c08592335759308cd5137d0628d456a4129d847607f78d7cad6ee027a4fa1269b08beac98a44345bfab02975f31653cd19e8612b0182efc6dac3ca0aa1c72c9d37653a4f44e70ebd458fab170ea14b35f4c80a365f9eec0846f6c0e9d41cf47f96f55b57206d367928c44ad4f6997750537fd2fd135e64ea7a10846973a34861ec62fe4637cc4914c7d6d3c4e339f4916524a8551a3660d7ac9ca761679c0e55e71869791aba1263662b4ef41304f0873a374fef4f883d98547f30e0f5658b7bb04b96d516844c5ee58402b32d551504b0033019c4ae1a42f4a8a8067e40083dcd1589650b68679a449aee75c6df10c818a0292603da02c0d390e45f21fde329e973ee969f2ea8b1b11e80b406d6bad347a75e05dbcdd922334f63b5f1278691c0862ca037a5766f16ae0df34fb763243f725f6c3c9e21740ef2fca0c8c2342fb8fafe25caa6e940b683d24d92fe7b3daf26585ec99685f5aef6838ebb8902ce07a305be068380a6f6e90c510fc1bedca389004d98f8b3d23c46621980897f52a15adedca7c99cadf8be6b0f85ef0985213a75d65ce9d5a6d13d3c3371cd2c6662545b0ff13c32b27c1df11326b60348f6dc6b77c537e5eb26fd6767ff28aabaf967c165c07e53e1162f0cd8a442d845a4f9f679b42028dad78b9c2f3282803f14eae3c26ee6d12a7b7d6c32b51fae437e46e79640221b955838219a47c949dc4d5fe23fde47c70b232ebd1d07a3113dda781752f1148ae8742df31209b499aa5b8b65519418e566ef2c982bb02a7d6f3efce8a667b775d944837ff49a48224bd9c014bae2a4344402fb7a2088c69b2f187a80aa2cf9fd2f3941989212eccf85147e55b96d8950c24a35e515177627c78bad58cb94f86b69da74b1178beff7ede54d89c1a83bc5d44dc0cf3b5c042d586aee7196d3c96a353e0a7a4016bfa601998ac5aedbc5d4f65be26f31868ca2d40878657330fc2623a8ac6db1c0ee1a20c50115af93ab60561916bb468c01631b0d89d30fb1fad44cb760dde30ebd58a36b8b33650464e472ec1560c8431987b269040cad7510bd50e2541be89efe4a12739e85570d70acd661a58e8d6015cd7c57fcdcafefd929511aa178bb4ba47c762671fe7ac9db2bc8b156d05ad125c32e991f50de6ffd2fc1efe8e0d4fd4b0f208a5ca5a0b7f9bde134880230d085eae1f2eb567234581b5309959dba87bddd7c0961ecef673aeec907503be0d78010eb4d0d6070020024efe5079da4a5d3bcb25bfb8dd3575b125a9aff207126246925d4c9b1a621c469da7097a34deb881bede125bb2d508fb2863fb37aaceddc554064c830035fb7d395ffe35c3b3b1e8765b7633d3ea109922902f6b887987416a7acdd1d0829d63eb022d2d96e4cc54fd8431cd4b7d296d9d64c7f8198957a7eae220d1acb32a8911df328252e8b0a8fa1cb734e5ce6ccd784209868db1f9b7dcc149f85a077cb51bcbad392c214056e77630d5747a529b0286a2cad3d5416bac648d9088fb8188913038e6bf3fea31427b54a319faed1d8e52f67112c8c292e5a7e517ef837526bae71d13a94d54a6a8b700827cff01b5fd36574bc8ed6c552e3fe47247709811f1cef3b5a7be96fc4c8c41f90d539ae5444de890f4c5023e90b8ad17563b73afb2b26d202aee3e4e68b477e70888dec65a59da88f9b392f04468a88cb87133343d14885f02e20594bf58ec30f9404fb9657bfc07d749e0bad527743d02faad757155eb93d1f1b8331b7a4cc176c6891aac846e35853832d425aff2a24ae351b72ff8ce74c668669ee97ab9587ca6b8d5b04765b57c34c254c258d53f5adeb242abf8d55d0158162a13b549b2ed53f828fb1e14fb31bfd3feeb3f69b645bfbccf7e8bcc529e8097b15544c9e15da1b7ccd24411851b034f461590c0814f3debba16d317c55ee4e1810d58f7893c9cba8a8765d12741f1e78a9bcc23a1a9fc9607969d3252d03fe65969801c58f546e694140d6889b67b2060693749d4abfce301700b5050c890ab07f7687eafb610d9b4a588e5fd3f4751921f29fada95fa9a49bd4c74d6484aa69388df09418be3f249ebb196976d00bcbb1b371a5ae3425919d2c622354191f4cf559f18f9a5e924c4707e0d3c6c561322f2ce44f48541bf3d95975987ff03d61b3d4d2024bc469c99c0962bf9faf02235f2b9f8e0c968a61cb0bca37bd01408adec935782b8fecff918331324b3810c40180539acc34516df259038337d083d0bea54263cd1a4a81420c676803fd26a24c8309bd6e9bcaa3eac27c41a97ab958781ab25be5e2927777a208163bd87e8a47c830d00d407dc58a220134e6491e874357e36fbbafbd05a6d8232d6017a1b1f30a4932f6e34ada4a0fe55326019606da8ba594678608d5d7c14d397ff185569e07cf6c8229afb5dc6622755f6fb3c185f1f291710f2d34419579646179541898fffa72567e480d2bd42f09b2e9e95c999efb51b0d2d5623560348fd3cff40426f965da8065b1ca3c83175783e68776476eccf966bcaed8ff75c38477b107daaa57e947d0614a3eb0f9017dcdde09b4cfb2b49c73a38c8a52458f9ed819f9d4b1f38f9e65f04ac82c573472c5ff0396a5dba34fba4a1f660189c812e1bdb3b52b19f55096a6a2e07e2816591ba560db9c999b8f1b0046e26087c799d5d6bf00464f51f3eb8e0c337e6133ba6de76b2e9bc392f9c0182a59064f7f36347e386d71ee3a9addc69dfb97ba17abc14d19b49ed8edd70a50e5df189daaf9230afc6382b3e85849a8299f372e00a96b3389e2791685d0272e42b309ac8091e48626cd6995928be1725273ead84e592931621f49e321392337379f9e823251a12eb5d56f8f10af79b82cd779e6db30466f6f693f9e57e347992f60525251e13e3b14336617f7c2ef5a564d950375fd9ce03b3cc1e1831028aea59286494c0936cf62c51e7263dbc6546cf93e51fe73034235c926f5adc46b0977687bb2a8841cf52e1e8d7e437ff537777cc234100a64022bc0ed8778c22dcc56434ca065d05ef87d72890d08502b1be20e620e31fb76ddae9ff2656dd36d7089577bb68dbc92806ced0e4b0d2c7100a090f66ff23832809bac9149c76b72ece7b7994e6df3f86b0c744e748656de7cf660afd9d7de7f21c8837b37ae227cacc00892fef375580f3b28ae6a5605d2098cdd8a314b8ffde8b6dc0aecd4f3a7af4b8f7e3e3f369a1d991ec07c66e7ebd858d95b18f24a94f6ebd8cbd1489c88bc468c6f85204a17906fbdeac2f60f61409cb2c8600171fde52fa261645c309f6c4dc53822bba9e5567c2557b1cd65d16f324611c6ef8c22597a4e4abaa6069cbce8a826a074c7e8b0bc088066a2e1e842091f9ef3b61a2efa73654c043746952df7cb7a706256dae8307fb4214bbcc412cf3380afc5932bed63b4909691f5a0baa5480f338c9e0c63db2cd085521689de85dfc2b84b835fe01530c050e8569eed60b50e3805a45d31b453c24939985a3512d69de7b199ce8572f49de5ef7ab111058a7c8ca71b602f2fa5eba7c7252684cc40c6fa65f3830b953f3f15b595acbccc092acfb547a0855dfd7ad592360df04ce84bfb0b37cb064487c5c99a264c5f0c7056e57befada50a656baf5f11ffc7a9959b4983b501c83b7e79a07a292e5683a3e32a3bcac01d8fe3356f16307fe0a4d74ca01e2ad7cd2086296fb2ac4d425572b2aeb674f47208e46260ef8f36419f9be145667e78ec218ca1a59be1d910b495bbea823fa553d5f363a3a2669960b0cc19061f6761950dd3c8817c194afd5334df2722bed0cd718179d3e16ba2017b24caf140be3be8f41599ad4bcd365f79233b54301e59e7d022a5c6c8e9f5e5f69e3e3414e2a867fb62635ebf71220bbaf0d99ba7bf9b08e9677b863c8d34d780c185263cc6c94aac5c7fa4841d87069bc94451e0d82b18fb9881455d4bac7fa25140bb8062397105644fb8c75b7efd5ffe111c77b2ea399105d72a9b8c8d312da7219e54885c0dcac20417b73135643142fd8cf86742592378a860fe76e6c51e981a528b304ba4a9f0164a1547d1136927b4b7c362b5a0811d88ded6121af56aab9780508f9708cc4b821fd97cd585a6075d53a947d989198c234e33583f1013afe1586d272976b2e41b05e3632c7c4d8703863b1a0e0c0b257952440e15ce1f246c0785445323df45e2e7ca8694ded3c551cc6007167dcfe07ea0c5b46b1a201eda58df7fad95159cc8722db54f4444aec09fc379e8744b523ceb02491c5ea8dd417af3ebbf783ff16484b9aa7d95bb7b90f64b43952d49e74326290e277fd558fb2a8192aa4a6a71593ac50af14e66af65bc3fae24c4dda6be230cfb37bb75654ef7d77ccc40833eccd9aef00332b2fd2716e2f18c7b4448fb8c4a76c7569a4308e9aa2baa95e9e1b8e6d4379a137500873825e584d50bfb45190332ed39db86a47f36aef0deb61dcd2142dc4f011d95b531adc9f2b20f10fe66540406da9716cd33b27f1ca9135d9eeb140957c0dc046e176f92811c4fc60217e90b3658c2b8cd8958370545e0f787b3b021b06b7c47df6033ea42e8804b80739ef7f3b4ea6f9fa120456621fc6eec8998305d83ea839fbd592350a0f604fd1d18f91e21bef79c5b81607d97fdf1b5186f59142f38a311554d0df2f7af1116622e4b482e81f33bcd42a8ca0b6d908008dcb0f45b31ce8db40f1cefed789455ca3837c170a4c1f1b7cd101191edf42f54392ba55810e5b9cc8f2dfb81b8b0068b0dd60064ed3775cc7a66e675b965658b00fad306b5739c714d17f157bb8a374cb6522e2495e46cd916f8f030bb555b3e5732ac2e35ad9837e28436aff9cdb9c4da16996b5a3b3d7f57a4e3dad86d1923af8f2507f7e3ebe2a3614ba80eab6e6665e26db409ce9dc55223177f354d7835bdf85b05445060b7b73d476111629eb11a332c8717acebb36be7bc6f47bd748b3a238ae0284a9f9119bca188acb8476303b584918cb2979a86ee2bbcbb7541fc0a1c4b7014e4eaca823c39bdc19045e01dc6b16d0596fade3b68265bd63b3fbab88ce8a2de84bacca8e56ed6bfc70d3f988a382d553abfab2a401db1546e14d8f944ae060a9bbd07988059af65fce9b69ede02ac1f03e4a94a83bd9ba47c007a8e014c8f9ebca53148390e034202146398932cf23e883f79d63f563f06406eef805f28db99eefce248a07c87deb680c2762089bb1e4fbceef30d74827fa5eecaff98a64ffa00b3f2db9a1eccdb66864c359cb7ff31c394049b1612127493b8b1d2cc8f7a36871d7233af7f60dce2d4a4b3aeff98560c9537940b4010a01a75fbb96a05d4fb0e8f1dc16f5eaefa7f595eac27c6c7e435e40ae9989ab21e6e7bb3f4880bf365124ca8d096d99484f8230accea535cf6d8b54db16b84f7513b0966f058fca1b76ac54c91f7edf9fd2476223b04ae7935f5a4baadeb9116233d91d139db219d85ef93e8f1ef023b3afde45eac770d70537ec2031e065ab399027d97c12fde73f56b0519541232ec53630a5f70023d66b0694fe009d53dce123832fc79b2c57b15822ab752993eb2e4c1df75ce939723632eaa538eac9a52913273a6c73d107712ea41819e2ef85ebaa553222c635f1b9cfc83a2b3ccd5c89b54b870e4d9c37c6441122c39913e12b96b89f4aca884948607a5d59d60032674f522b533b172bfa919c828269d97e02863ddcc4c75964f2e301c9165256802535f5109e77631b38c0a559f68f9639c53d6379c14532708092001e0eaead4cdc846bc80ae123d73b7a85dc439e5242fbe076216ad185d124fcb3f1a34c9937a7ab829fe1bba241a7e9f8f9eb1fdf4727cc109ff1cccb811333f33e8a69d0ea3737c69161219edc99210898c362cc743eb73dc88ed82244fbec06b76a7127ded162932fd63c156f34f0737213b38852d58b103b22bc6054a7e584dcc757312f0d5cecdc6800d3200c60516325d4c1cee0543070d699ce17e6536757491cb01bfc66ba06728aca86e56274b43c59c31e984460dc047d8b2cf3c7e18818a01228b38caddb0be1417f0dada93b92619c52cf1c2428509fcc898b184764e415e19414b28831d9a5b7007e111efbc2e984502d1db1cef20f03a9ccd29773e68bfad010f3d0428833110bf1808d830ce694ddacb2dc931c4b9185273b8c28b0d03e83df7f5be84d0ee36a300c6b7fc2d8ead92d8b2f6239aaae2f3ff35c0df5abc86ed591464","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
