<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e196a5c17a18a5676af088131b44138cf5d9606c54557313caab2bb508afbb24490d7f1da2728750afd8940a2c0dd4005e6667e0e7e94204ada49f7baeb4ba47c48e09e456854149919e0a9b3563e36b7b12326f7597f11490fdac2541470eb19b8f8c60e1b95ff2b84956f1076273be0144e63e827cf5dd4c4e2f4fc078861cd68cfc1152a477d2a418e13c6f6e6f6bbb2e20d92da8acc03ba04bb53c0a6cd1a4a26655ca6e6260792fe50f36b9ba7e7e12c9376fb4450ef72b13835db317c4bc1bb4f025bf1fdf5f2c92f6bfc96945bdb9f4c68375d4926f2ed5b6081ec3e3388a5c581ccb662ae272c81ae4db23aa0803887f5f5a42db3ae182b803d98c981d580db225f838d29af266a1c2c0f371ffa8c222b298578e8d34e8a8e056766bad033915789113d71e075ebcd32e3fde0172285416bb0e084eef18e7d03fc2d72e553191c5f76454203a0f6be67d67c2c3ff87fb2896a11f2aebe05ddff4194d418faaed29b19c728084375930389b462a585c327659587d0ee503f765c033c768c2ab4fb098fbf8e764b89a43600f8a8abeea8aa1f2ff25cb7f911e5825fadb0c3aff66b4f32396b6696b2683da535fcc10293ff8e84f40dc96316838bf8c846267fcb521820cfe66f39f645c1104f7681259fa24362902b39b973d68b7b8e682f9eeb526d2f4f8df3dc57a9e5d6d6b273425e0439178bf83805ff6101c2e1d02d3acedba99bbd353c34f8f8a4d9c2aede18d83a66eb3ad249dbe7df1cce1529888102c343fa68be0b0388d290393286ab0d37b3b87b8baa24164f8f8214d48f28e57b2fa74da05e7752f162c5d0e7749094c970ae09dd331df88044b82a01b037f0297903b8640d9e0b40a8fb7bc3d781d38af44e2e93ef41c0b69c82596727212d5d08d4a214dc6d8e4557bc8856337e2257cbdc364cbca407643c177f0de56c75548cd48e8ae49e9b1cb8fd6e11b5e6f70e79c26282e5af4fb1c7d52cb3be66316799498a30354ca77429ea9dba28c0d15d98b235f26b354ed183215b4dd41bade73fd16bfa44c21b9e3d2094eadadd25487cfe923ca0480748fffc4b6c7bcb715d2f2cfbf9def91475c96edb668f2fe8f15f8c809e09b1a0b38d5593f5ca51f79f688d3790dcbf28566ddd25fad3fa8eb89ed8faed35b362f2b15cbe3eb777854c4f9223f8efae2189ffcf146d4e4e9efb8d8828c503baaae6461b5050bbf1969051f01cc6087b6160269390fcc96aba872b8ae5c9b7d9f14abe6d89445d37f528c09184f85695e88335f5b4472beaf610fcaf026a18b14b474d7d126c4b97dbc66a541ace5d240ec83f205a850adf9a4c9806b799213dbdef7929c96caf0d7ee985a79a5ebb61668b97d99489565a2d0a9a14440afa4d1d8b1696d598f3798366cfbff29e71edd03e2113c169466bb5b7f51942b17830802d39779ee6696e76ecca452dcea1d98764082a1f834058913daaf91f8d0ce03fc749f7d638a4d3e940910820f0d44e1f4523371833b08486b504cf89990697e1a4f7f69df4a68d5f3ae42194912d52b3688ffe9af0560d0c5b36a4da87c80843189957b7aab6d6ccc939e6604346538a460046b1dd543d3157817f40a0d26c50d28e8f8442d08530717cabb2a5d015b7d61be8d588f8b684c7277a9670fa4211fa9fce690bc317a17b5dcfe63522fdfc30a950e13301b4eac7b679d125204830d5a38bd27000eabef7414640f3f7c71ee5fd0f899d1767b74099fa1cb473ffedb6b686b8af7f1a77e7302099977d9f24c864ec8ce2a195a89cbb767c4a0d7d1e6d0d2fab95d76a928fb4617aa7edd3704453e4d966a63c7b5fc393ebbfee7bc3fe4ba272653e9ffb43ed599e5d50648d1d2070f5bedbb5f9901c8dfb5752f8d7d2f02e98f2a64453e0388af7a6c2f4b7e40e309b83a6931a14747722c0af9961805c2017de6f7ecff36e57fcf3cdb9e5de4087249f6aa60a84d53e8bd20eb12219162bebfdf892afb847902042cd6180364d7ad91dabff32dcaf51b4c944ce63eed7be238bb07613a0865ee41dcfe5f28fbbc3613d67262ccaa8f959f90b4b7da348ebe1a78e8f7bd934f57aa8cad1925317c0ee241dae7dc0ef5e0136dbd44e08404d3fa844325edd3c09219bbdd7a427905eaff5485a1e75a12546f4e616a51d9ef1169d75728ba02fc1a361ff09dd95314d5859a44c2ad5e74c3a35f740339e6bda244ddf1a573b6c9b4199f8ea5f0627398c6b3bd1ef5189c746da809c7770070041ffaa4d493d3f671f36eed35ecf4072e3b15fef8fd62e84280b353acbb6a642aae2c0ea9fa5b1e4fe4bce1be1acdaa48c7e83b78c2ada575dcd6e0d011ccfdbde1ede48dc058fb3057d922a3fd8d5b3f1257eb17c4701cee5df2ada9e941b02e2bc013196d912eb0533b12b7de0389a4fd8e43048741f53a2a17acbd2f4a0e3371d97565f94580cf93e5c5a48c0a22c72aa56801dbca6fdf293a2f51367cdeaee967db14f6726f6d15018cb1b5a5301692e46f76863fbca4a0ab1d6168a3b8d840d50a75733a14623e27f406cf09f2d0a1ddbdcc92d5f9b49a7318eeab24ac0085266604c96af7f41b58cf494701c55068d933ea7ddebbba25ce1c65276d4263f5334121c83b44899f91eed36aa82a3a22a30c9d5d26680de3ede7360eb5b2b76638df7b031be476fe45d93b7c722c6486aa3d6cad4d72245cbae7cea3375dd4f3510e36dd7f9d38eb72d0877516f48c386b159639636f44d5d2e76e7a5f6350bb0b7bee4d8804afe51aaa6029dd0faf30a6b19c1c05948a2dc5f1601e723039be8b624bf830f7c15ec15fb5131bfbc5801668abbf8f54d497551232c71f62e1f24ab756ac9302564d87e3edff6a2784ba6973356ba9e4d52a2fd987ff7294371575501c38a2110d32fc431a15ae293321103d63d088f25c479d5ae9c980c3a1db8a7cd7d89229b8bdec4a75584df82073690ae4680a155a4424abf099e67097bfd62ca176d52d2d92921e2d20a57a0f66e69082d27d35f5207cc777141e3d7927e79e6112491188650f4230965e1ac940fa1eff2f622def70f1892feb61f9162a485e79b7ec3a18968d55f3d6eba761313e532a6770b7baf5fc43c29714cbdf4e2e48153a88e5853867a1b5b370e7bcdbba791550d8055c01a56ad9b329bc0ed9d95d0220c530a928fa627f76291648f0ef1f1c3dede4de166a3d67e913ff7701ce70164c06c5f398a8df1c3afcb1932bbcfbeee1f3e67061d3fd716a0e5e5c8ec3451e74928644dead210d75c3f30fdd8edb089683c95a996704e277ba7235da785b4974d60e288db54473ccb6da37aae726b145849f1cd2b10156b2e560654d3cce4bd1dc809b8ca681c8c0322ee2c495b1bbbb21891110e7a32d6d794d214046070dfa38459640768fc5c2f3c5303af3778db4069bf33846069d461fb0ab8f405a95eb18e3b8be0207845dbfccffead0ff481deb7a5b670e6681866e56646ffd8a900552521d031b9f0d766cdef5db633d3b31b2ef8e7bae7edc22e7f24a14f03fecf5b27f16f435f8e72c07a02acc3dc63a3ff3072cc05a2313ac03a0b891fa9c3a3ca11227319bbf3444b4b0af51ac5c929ff84627c98c952ff952e575ec73f822e0dfdd130d90635c7ca6b557e67be2ecab6be2bbb382af1849eedf21a99372f4277a345a44b36943fa6551a52c727920c54ca88f5913515df43a8533786147bb41a56626b8b72b61ff7f42bcd4d5ccbf50122b8446139fe4f92568c1ee42b5444d508751710598704231d4e34871fb62b040344144ea4519f3b5de90cc5bd630e7af0fd67f716345374a4c254257bd14f709d02158ecaab936b9dc4eddd25abf97bde47335199bd989c82fa50cf81f593a9d83117e718118cfcd1b3eab4cd147a1ccd34c1236830b273b37a895b1ee638ddcc49fb95fd939f74c33d1aca1ca39481a004b28f5b69fdd5aaaefd2563f309658cf06990958b2cb86339074264d5e26128f27b2739b4fed11df364d87f680aba2ef7a0bf5daca9b823bd49b32be9ba54882164b31c076953a1bdca96a40cffa517d6b94b329d09d28ba9f7daf3cdddd41abc20cd35954b931ce880b8326536821d37741b5e34819d6c890439f155763a420d48c85ccee5bc8352e84ce4250a0e42d1892ba57f7da2d986eae77b8ec61280e86e5f6db41cece1bf6b0605b29b635ad9378b66f8a6918c690a2d898a55e31590e151e4746bd1ad1302f0abe9eb3ef5a8cebb2d68888f4ac504f8f626b25f52b856812bd765ccdf3be54bf8474ac6fd8b75aed444388f9e8ac596706129a4c8a48a9b738b382708321f1c1c7dce8039ff9513643d041e3d22f092bf0dfa92a7b5f66df47292d336cde812ebc7eb3bbc6006823f6f8205bab5d67b0ba0e54c1a302592b20d167db588462e7bebc5edd8326ad10c846578c2672b5e34f5d97d564fa915e3318507858289095c9f9d624f731e68c644b6d3a926f274228734d37608ab57fc7ebf1f79f4164c9001b39e3023b5e5f833e0a72377d3304383cef55600bc193d03c54409a88938ce92d5e714cfd7a818a7383a11622750077aeb7414437860aad9b82c277ed4ce77cc525e059581c818732a6a9bdf014e6b253ae7b37d4535465351f5f1ed11547e94bdbfd648416c6e2949ca2509530e1682f03b98b5b90411fc8e24ffe33dce0dbef10abc9ccca9b0e895ebdbdf2d4c7122d9d54d850d4d0779d3ae436a01ccd0756114ae6fa6ec1f47806def7fc533f5b5541dee0f0f6f02f783d3ab16e9a7a60b969d6044a02df4bed2c11ecb546c00ed2a7dd856c109f6ba867e1ff8a795071df966f72ecb73df6c577d971df8ca8605c3f8d50a99963175267afd39396f60887ab0da356a3dbab50bad15ad8d1a546ec70513a1612dff9842f2054090590fe3b9baac422c69673845983edbd6bfbbe10df9b962ccda73893fda122dbd34eecf623f3d85d2d402a03bac3187f860039794bdbfb29eec2d890f0968518f512714d12d0fd6167934b473fd0668d436a625a7de9cf967bd055a24cffaf886728167f303f5d37dddb720380f040e8804066d21403c8897a2e9efda446dcd7beda3b0875a16889d620d5759fb699de39a57e884201b604bd0523fd037c58a8ee2d183c53efe148137a88bfee1513d7cc001defbb03c9a82c40341e0ac556de399219cdd946f677233bd6e50ab89a6a17142092c66f47f8872c85f24a8d92a5fe4171e9b4bb8e908a33a8dfc29105b6361f2710a843721a90a53eeae1a3139f22651a51bf0997a3d9c803cb74a811ea647207ad10b73010198c6ce0222fc31ffa16e5ce958722160316a4bad80cabb0ffdb0f9f5579585fe60b79e05c91e784b17d89e316bc3c4c18759b5ef1ef09411f225cde524c892567e82ba216d296379d30d82ca028bef38411f06c97f15151c2a5f393135fa91f91f712d254cb20a8c4c3ba3e165d5bc0c3301f134cb47954dbf76c388533559e27e7b52f26a2a66c0205c4912397d6faee2cf240b75ebbf0c25e53e27e7a7503d11a86eb4db2c399ecf176244347a3ca796d23f7efb30906215d7ad75fa71c2cdac2cb532636bbca1b2d78c26dcdf8b807aaedff02ddbd0a1064756575ac17b34c838e4ea222bcd4b03ebe5b3b9bc177afa2f5d10d033487b28fdd23c279ff8d5ff38910708d1126e835b48062018e2c502866d4b89dc0cb16ed41249277d2c460ab884dcea314d066aae27caa4f8e9b3a5a01471f92e0382fe81031f09b243b309e6675e3eecb9b80d7f70780910c16e0a0af54e931ff7415d57412e9f4e2d415984487dc89cdcd4370929ce347d31d5dc2d3eaca3531b3f9cc263ca044fec954bdb01c63670e412cc64e9c62e05e62a373150db83fd87eb0424cbddf45367e61ca1bf82d925dfd0aa16ae71938d3edad10045a7c656e524c7d8bf8790e33f13c35cb0c3a6a36660aa7a06a3f40b80e83aee525c342b8ec30489f9169c4510ec5c6077336631edfe1fbad45c7a7be5c96644ff250819f8ae1afb497d62cce1c458ee065dc01a3a71cd861ffaecb720ec7c4dbfd51559cd875def9bc9e55c4c544cd2ad502ed476ba74e5c59ff06b1501648f22bee4384d36a06b46e6b4faa2e482c6ec0348bcccbbe9d836eb7f65ad1fcff2676f906ae2929479a0dc4468882a8161df691ee92d8ac881e064753fc6b2424bf0db14a8ae73920d9ba1db1e0cdfebf98e717007d36fd5232560a9dfd8d4a02dfca113edf3ef7351ebe05da188d70523f4bc6af53b571516cf8b03909cb3f00f774bb9ece1459c136f9248ab1fb97c0286fc97136d2005af8beda325c4bae89114c5c937d22fcf1661e7b56f4c9818cba24b99736cba38a00a6901b9a60c4398ed62531d1116b850614942d5dbda7a9a981fc18b888a29a425f7a12bab0ae007b682d36472652854895c5ff79832ee4fe1ffdafe0b78c2da2190692a629b66593dadee9f61f1fd9a0278e1b2dd4e06508bfcf28f694aca4bf8fc84a67271c1fbb55c7ba87afeb40eb4d02c814f37b7f27bbe3e5cf106f22dae3abdb98506bdc05ec21a4fd66b5444f0f45f269ad399036d49a5ebbc89ac27789d44d930ad0d35dc6d303a045426c963b7f7425b9fafe4daf0c9a2550921a4611a5038024778ae3dc1c58aac675bd650fb71c314f3d23d9a7ce531040d764431d3d230f820d8001155e82ccafafb6c0bd606381543c6cb197f09f898ebfd9bfe58995a4dc1483ba522d6cc5d8b3e04e9ccfb96979bb1ecf33dcf3dc9b2ade78d6130427a2c770fe2f7961469d010d875dd2cfcb352bc9e29537052eb496b33f0520303f9c38f0121db9ca5cc6eddc88041ad57dee4b71e054cd39e24e40b4334c52e852ad01790545468cd2e702f301fea665b77d244a34e6efdf2d9a848e3c1e98ac1543e03ca53789b8d5bfed12738ee8425add6e6ad3bb76ee3642ab0ebb0acb8bd54f968da2eadb5137d3f13286c9d9de3d6a257a09cfcb28b9a03ff8294f8dfd2102973c4550b3d167f4e02945eda7db6460ec872ac6a3c5f87e3cf9b8406d384ec547d240001cf25eee81e18117ba0d5e77e935b451b1e4a85604d69386e6170d907234baf6f38451c1e7da6b7bdf803cea48ae16dad10bb639931b3a2ff8bfdb8ce0580862db30226ecd0368658cd65fad52f03bc972cc318af9ce0067c19d43e94b41cf5bc2cfc21488bed38ec67f0ff84002dc46bff5b89bc0aaf8f8b66c132d657f416c51a2dd5ac66d32f96263807bf605e68b3c7f612ef1ead3617c91aa1a059bdcc1564527cdb2c54614dc48d0919ef5cd66e31a5437efed1c25b0339db0eafd3fe3cf736fbd59d07de409e185c7ae4abe3627c4fde9c1abc6be8633760b580745e2cad778b0712c3bbb28e0bb83b045991eb43959e2968eeeb15d77f0097d6021c859da0c97e9d891ccd56883ae637ea19c6bce7194379d54c1c022ce80d21b381dc9a9f9cdd98bc77127c7a3eb42e9ff76516a1b6f50ebdfa01639a931c131a99afca8d06506cabebcbd9e2a5bceee556196a2a2f64772652f87dff3d7d4874211cb5b1d74a6ff6cd2995c69db60479bafb0549d4293d5e51791729127433b5f08b55621738ba13813134068f0af7074696b11561e03c9ea81ae4510ae4bfdc6b4e0a0a985d6e77857a464f92adb7550d43550bfc36ca4d73ea9ead0d8ef9f85736883dc19cea91fffc5f42ed94c61782dd787bab829b2b9f1c13bc7192176611927a69ce953ddcc2124595184df2b5cd3420636ff304245e854078a0ec006ac06ae949a6c997928caab54e7989fd9a76fd0fd2f5e107ae436837f1066c7fc58ff20726038de46eb96a8fe910b7898bec51699d0d3d11833013047d964ff86e5122676d02bcb15570f732618e007c0cedbdc69bd373f934197ec280c110d0a4b6556c572800373cd9e29e0014f921874b386a7db9c8047480f9b38b50b4b827be195586d94fe2e3ccd74d20ff517f0f23c28b60e57dddde2ba1d4639222b93c9d7db0f599b4a60d962f5356d8734d08de9b7b26cb5492dbd33b584bee1a86331e5785296d3a3e190bfef8729a0159bd9611ad4bb6bb7965bb2a7c8f251b36bb80069e3667ec4d71c7fa47c24937d405096af420e7082575f448a63117ff6d896f344ddecd5d99506f6d318a4d9539aacbc12dcc9b299621d1a4f838edeb7744e1294cb677f1ef34877739aba99c0e1672e8c12f5bbf0f5dc1b8ef90175cf1ad42be50a1314b47ee682de28dc31850f980953605b267ba538d342454e0e0bb00c6b47cee6e6e1be2bdcaead84ea2aac289380e440d0b9fc6d3708865c46dc9a9d7d00d79bba615f9969cd1fbca3d2e719669e38a99bc10fe69551412f52e4ccbedf0f417781f233be71611cd31ccc7c396462e28f895375829e5ad6fd6f94f24503d26f4de0eb71fd9ae9fdf292e56d9bcd6c4fb90061a64c7838d90d290896158a6c2c5a2155dbd3d328d43fce5619858536863acb7bcc6fc7cec06d687ecb1aa75cec67343327e69f6defb78edde1029d5209a9d1d917af7868fcd0117db9ce99b425413087abdf5fb7f768530fd810127d6f166e6004d9517c162fc5d69c841130d8e881c7d124a26ae82eae01b31783f9cf6fe154ee3028ca7012243fc55ac03f138f1ca9dd3f2685b1dc48233929f51996eeac50cd8e9ac5290024c95d3354fe37cd8350e0313141dde734244d2422dcdcc60093d3715a3e37e41e880caaa5db87484e164d49ce66f19fccb28e0be45ef8b160db4ad9d1009c7975a502c619297aa4465030c9d656c89db27df8f8843ef2406d5fd149df96903eafb819c6c6a5f3a5515f8925d012698f39a17b79a1ec9870e311b3a371e1bc3e915709d3145f5410ec55b574438b2c30404af4ca5cf143806a51a2e384ef245aa3dbf4dadfc0bcd2b4958e90af3c55824eded6599cd5974926bf457f5e54da71b4336aba5fdc2c14714b90f30af56084922a354a4e225f287c99fe018ccbe6c192801da59d28b077f80ff617e3f9c3e3e24904233db09ec5d818c581fee8592c7f27d4c74dacbdb38adbb3b718e008050c559950b147d7163a07b4396590d07f7e1403b8534c5363442e025790f84b21e46f3464ab9412adffe30cc9f3721c71d0c485f3e520ff885098ef908869c91acf0b8535851fe3a627b9d80c0721d77fb4264097ae0ce5e194d1df634f896d1045864b84d03c2e428e7176325fddf18bf0e8c87ac141bfc30d57f850b92fc4b1336c97cde180aba572317ddf2609324725a543a0b098cae6b26502285c9e9ef911b2344ffd7e01b717a0a78c228b82ff2cbe7a1d8ab260e0bd9dc9a97012be68a98dc17385750c9cee6a18d1d32a3a997538840e48caf4371ed18c5d558a7c296d7fa4a0d42124b8c8516a359ecf0320440a5d6f165462f7500b2605694ba9d8659e89f0143417b3bb44312635ea4a1ed2137e6e95dd047c9b55a4f1c0eab403a0398e1eeaf9d1bd2e7e1d3c37117fd8e0b4a2abeaf10ef02b431b05e5b8f8e2cd959de5da6d26eeb6d648571dc816b527aab772c85d49d68e98c782e83d08dd4e26825c88d9cb69f0019e41ddba9cae9f8e9abe8b7929ae845c926e96790f88abec9877eb8adffc6f0fb22a685d663f21c2a5ed48292dd2d6ee625f0230bbf70915c97436cefc614e39ecf1f6cd4ef386d9e1f01c175ef7e8399d282bc836ca05db51f9a52f4c0a6048530ef3c57e1848c5ff0e57c85e2d4085b217e262bcc3b82de7dd049bd2f3c72c63b161632cc33c6848131466f6a743856bf61b93de8681b5915c0c0f5c017c584ca2745eb16f08200e895a352caad57494ed2db9b23928447c7eb69c8702f62fa02bb90dddb15936805c1f21fbd115741c310cbf648398cb605217db394592c0c604f0f95255cf4c18e9d3f0f062b9c01fa1b6072b00a2c0e0a73d6f4c7b3154cd38e217bd3343f2608c2c4dec11a6f0ef278c7e273b7b06eb0b9d376014e17e3c2a4e8acd1f1aec766f2c92ae005bb9296b24b9c0f697a76c773ebac90ad7110019cae213d274a283b83e391ac9d6792497be4baa9118376ae7fa532da7b18ac5a6cd6c1c7f65680a016772931bf538cdd626836eb39446094901ffa26c2fbc85a709565e6934348c3a54c7d0ce25655d54959d49f26abc1680f6d6700684d8195907d1d5cdba76c7931fd0155220e747a0b569f8432eb8dd7413acdc75965d74e1ec91f69e977973bdf39908becee2c603f65156147106d6adbaf0f232b8bb396ac4494e2e9831838597f1819991e334c72d8f5dc625d0dbaa47385f48fd30d751d5b5672a6fc08dc6cb670ae078104497a8ef74e5238b62b5423b254cd9632dffcb6b2aab25cee8ab07d7077c3924bcfbf0262b1b08e057eb404cab7629c041edd527af781dcdd1b19bd3ee04eb839a5de46de2700701605178bbc8f70c5f40fead1e8d4258e00f72c6b6bd7f9eaa0953e3c667f85ee9edfe654ab7535ad9f0b6cff2c7e7a2a0b8d268917ebe2b814e6dd2f057609dbe983ea0f4900c06f7648d4c1f321961a99f240c48c9a5114014cffdd35b3df754fd9d65a7ae0758f4f19d8380847457495de11ab7e3fe477dd5f096bb353d0583ae60706d5a57ddfaed5a005530c2ae043c40938e0a34c28f6f61635050bf2a08165a556295092ab4c551cb84153255dea266810d1e1fbeeae4d9d6239b8d60aef9658ff9f8dad566a5a17e2a8f4c8981ad021a6d059f3370acc96f29a2068b420df120f6acec5e64631a79f8f6ecb2b172ed7b47f3aacb82f7929eb9b2f2c48bdfcc482a72bf2e2acfec3c890da249f9d99ace4d066db26211879ad1c9b4f8f1a079f3d44dbfc7e69953de9ede1924bec7484190de3e5db334f17f18439432533716ef5720e89720f60d64be220c70ff008989fd8294c87e077ae069c7558704d84d468ae5b3bd9a5636ecc69a59c3669be238086a75bcfa3a07545695a12c3d19d3ff64571db6a326a474c09a1c333b2ff7e0ab995263fe4c770c26ddeb4a4414bb9eed7d76b3ac4d428b73ba5bc666c9ceb53f627397f48e0343a7615c219641e3ef10df3325af1e7ece3bd64e0e86137ff60a984e8fa65e99dc7be4c0e449048fbc26f72fd46b1e1e0325874f12bca27e3a58ba973d8a70b1362c5bd2c36e8cf96a94e0856b0a5464b761ac467652ffd2ab9085a700e88ddc40d1ed84b8eda00544d3548e1e8a0dcd12e72b365577949dc39b66cae7d2d5e28c0d35217d8230d8d5ae52fa48b7141cac9b375e9c1b64dd57cb71d5fee69d1a99e9e43a4baf9cd7b5f1d445af11fd2e5b702cb5f36603b08bbb241f5908ad89b90593ac39b3b61cd55697e05b617e89937bbb211641f3ed3dc5950fa287241e85c9cb6843b34d8910588b60ddaab8fa4d81b1683e9c1a01fb55dfe58310c8c29df06d5138001bc67b5ccda16169085d4e2c2fbb1ab9bd7e192fc9399032558ca5c89ff0e44ef7c22328ec89fb748c6906c24320434730bb90549b71df5ed7cd0e1310606e2c54933c6a65c99f731aa6fd7123690f2c5b76e2847fed2f46ccd96c8c244903dfdd73b827024b5b64816a0ad9fdd020d8f6746960ced3c1b13979ecef16d7e0f0eefd25abc1d4a8b5dfe0da926b3a00db36f1ee98727f13cdf9b5ccd873fabe0925eaeacb5cffed41a023ead1835acce369527c54d2d72414b9cd3d502c7441246dc20db399783bbc7f5fb1a1677bda9b0e3204d6d4dd75ac32667983db1f0aaa1365a914ec5167370f326649faa8b8973958d083c9fe451423202760be4d53008813159dbe8c840931d219595eefb1bfd0bb39836de59c6067f040c8d85d5d4697e92a3ef0f51032fe949b2d5f2b0dc23c596fe35df47d1b1ad6db9d8625272d7510ff6e39b54157638297221ae4ae191036472a72b80ae893ba51bf1df64ab5b9502527df6dbd168bc509470094f8df76d3a959385fda036960cafddba920d697377af3bb30733477095508643d4e43a175f1dd41e042f0c3785a084e470e7e981019238942d2aa8cbb955d23111bcdb7f7b9119d56fe19e69d1e94344a8f459b35202149d9c1b8a231f0b4cbd250b5f13ccfe0827534a2e9f7443bcf91211b8fcbecff6dce647fa7b1947bd805b5f2534f4de0bb731f944775268d86a1ed385dfefe18316637330e4252279ba177d7b373209579427f9bc46d46ceada3859392399d40c132f596ad67f9f5ea6ead81843485663fc2d9054d4e7d70afc5089d76291411fdb8ba87d4dd8a2d68f947f57c4d9c3e8118528ab538fce708079a88a3c34cd4768256798b9bfcd2b482b7579ea13c9e9170648e7fc08a194a7e967c05b41ab80468263402afce20aea649ab38de83d31a9807bb9db0aebfe3fea5515fbfd8d1078c6184794a946bef606774fda41ca79a489b4fa275bf3445edde3ca608efa0488966edd1b7bcc9e61b2a5666e30b344c65436f274e535331686075a267667f0804a1d740a294ead7bdfee21438311f232d97244d9e01c20507d84a9802d9f1423f3d1f07899ff6459ebc885ac04b56d8b46135f2bfd59e7098e7e66c293ec232c9cb34d42b92be20f811bd8ed0ec51778c5b95f156f4a73d00e9853a169d9629f6c5871f1e6cb4c306388778fcd629f31ac481536a9c2a3ced5968c6273824f78e3df9d8d8665d82bf4cb7a579a3cdad3c685fbcf6da9455e70325a8fd43aa972e7e52f651080ac2aa10bfb2d3d05ab6a63c5f12559889634e5f209119ea41f0675c18b6a030b3489963d7d382e4d5fcce25f1352cd52352ee82687d1f5ef7f7b3571fe4af419a73c99793b233f4920fd9f38af3f3c7f3ed2ba49abfdd41cbb4e5e56b71b9da29a095669a7747abb41429eadcaa284f24f603299adfda83ac3a198874575a2ccada9d0edac6db71cba400f9dc37bc417cc86dff6949e8757162fb4ac2c7a68e82700537e6a6277efeeed526e4bc9f7ee50f141197bbfeac7640014a2bff87e13cfcf5629e5ea7fc1e6dfa379f0d2dcbcbc383b7e4b18280740f3a768feb71255a2e441ed3d0e9820b57f35f13879739bf78bb1e3b061cabf5263acf2a22ac1808814a7b347237f0d40fd9dbb661656a351405d602537bc1d28f6f98d94946ff67c963a60bd4fac815912614eaedd67e9bd9258d84261d12a2568ef201874af370345b5f3b73b046e43bdcc9e30e7bc199b57949fcebff3e0b73f9a59b3613311f753a4b628f8f050457bbfaee29e89d0f6cbbf26f24db06d2c8ed90777a5ee6127d13b01af473caf7711036450fe33a7391bccc97197fc373ae33c4f0e30ae65646dcc50c9ff320c83d2ab80e8ed05419e95f599ca9150af12c74f7478d9cf618db7a115690d49c3a0df7e1872704c718db66ca890937dd894c7288b5eef21995deaf0812e428f207cb99df160519285e4a102751e757f5aabc25a02a48adb6ece31466debf677657ef6bc7c4705550bc011f9667bbf1e524175c807c8431c4d2d8ca55ece797d0431f11467bc8dfc49a9eeb483bf7caa53f7c019aa91019d90fff3c9f9ef54bea5645984ec8d66921d83d4531334db191b22408b4acc88d23e12a4cf72a32d6acee99e230d406b00467b170f8373174d5b00ae1746fc175c37142ee22917e920146bf48fd0259bf4e1869721264f75786ab26b7756750b14e6d78da57d1f6c1a11fa43080968ee2ab1f4a5ef35a5e28f8cecb868ffaf93c0488f4b0f9496d4e01ae785457cebf0b674351ecd4dfce855053ce1203169267ba00b654f792b3a93511011a09428e9de44c8a3802d0705e1eed1b925c9ce784ddb56faa5133ed939781fef8dfb7fcdf8d200383ab5ef902143af17141c7f18660712d4fb9c3e5845a817a122ba55234e12446c98437eaf2ccc423d7afb3158fc97ec3df3541b2adf299ea0572a5a303e04825ceda0d7d7b13e295ea604892681804c0c97e930139220e81e7401f0539a5a3e0e72553cccb943d159b9cec13115352819f55d4b46c1179f902a0965e95380206f08db64169dfdc8097d7f238b3a70aceb9e491e9345337fd002e08724d85d49b7ebef77955e0d27b1187f9a07cc4828ee3dfd100730fe422402565e4cc1dedd8808a212907411d27c105d018c4fa84da2af04f560a4b17343fd4e59c1aa0b21c6c8b1c89b730ffe771f5fd7b89c9684a73ef97fc23c433270a642c25b04eeb208381de5b83babdd0ff3d0ce173e7645a04ec0d4cdf4a38593170d3ae6ae1c764439bf5a05a1c0137f91a71eae8595dc1a1643fccb2b2de3548308b03fc5afdb8b43f545fa98ff3325692a6c2cf23d1a0fe5e880e0e73a71e85c721260925f71599e3fb6981a0213d463b2f89b3c731b649bbed1276d267686edcde0989ce992032bcf21dfa6fb5ed160782003e971d6d108b85558f19ebcef2989c6e12fa41bb57859b460d462aed22ffba187d22dad0aeb4d11a0ed8f05729796d6397d03756326f88bb72910a9d6fb0197b2c2efae313c943c86f8b2128d5e46c5cb716e16df687c2d99fe7ad77f2d9f308bd4e62ad804657a54f3005e2c6947aa320b82676a03b9a1870044997a852b0ca101838d16f31a09b4f772011733bf8c44e6cd353c5c243f90bbb393bd7fd99b44cb44bd4396ad8a15d83241cd899b9b5bfe191d9982af6ddd9b2e374238ecd9e8fa2f396e023b42ababc6c96963f0ebc513ced09b8623685e924220c591a1f95e4a1fd32371eff892a2805fe7bc154605e9516aa843a6221c89bb69edb4835ebe904b726e94d7e0a43cc53329230b65e3faf640545daa0f72dd28ea9be586ac6a67e00cd9a23dc7e956d587d691194d24bedc5af415c11f6453093041fe2a1733638a3b59a2776f0b914120dc462c1e44e15d0539e1101b6ab9db82c428ffc809f12e539f462b45eb9279352fb0e819c7259e870180233ead76427393efb9f8ca26de5a12bc848918e690b3f9f45f604709dfe7e236ac6786a333f84ae370cda0682d124c765b1a6bee64360e5fe4f74a116c226d05b059453a1465ccfb2b3f0b25e8e770408c9d6fc6a29af4fef953090f886e7ef1fc11c707828adf2c96c7dadd7c8b883a803d9a0fb912c2108b7e1a3519e9bac763e964ea0a3a2ae32af9cb3d89b0bb22b4ca1acb186d9a7647b7749911153a90927c5539474972c7c4423fe5c23375f37e60eea0e21f6fa30ecd5885080b7604487d2fc0436af579ef3f55709420294b4e48d27306405dca330da33ec6a0c8c1d0cb1f373577694cb362fae4c1fc563761588c78f7cf281c603799d1e34906674f8daad74b4219b5e495c3e789c489a93bee1d216a455bf8a1be65b1f7fc5608ca0ba8fd8daae38076681e21cd949937904debc3b1098709dcf4af93d9ad73bdbfaa121603115b58dd393ea076d19da5f8b83d62b893f6012c52576292c5f85b3889211ada61cc087df5c63c0e9f5327a9cc2e4b9ae711e17f3dedeafaecf4f01ed0b86a7fea457662dca95ec261f83d04237476a174af5d9c79b6e477a4cab46a342b2e9ff57494a2f4bfed4de97cb158663edf598cf3d7ab42d7ec48015689aef38fe5019e8f8b260a1181c199f876aa362d96983400778b9690067db787a3b8f8039db074b9bb42ab60c324a83a7cd4fdbb0328d6d62ad0f44ae81e1d5f206e7771ac13e19db9660bb099c765fad3b8aae81efbcd62522f4e48abe46221ca990e118fe17fa5bc21a977aa86fa9cd28917685af9fdb8ef1862dd636cba1563d2710ca1d609036c6583abb6af57130764daab449eafba9cc927e54586c4adc0c027422ab8a27b0dc4651e8749d42f4b2bcaa4b91ffcda3b00407a6b6593b85f3f31e1e747a6bf0c0e0e3209619a900d8e41b6d972df8d7f6bddbf571cde3ff47df06db2de19b27c3086f39238ccd8e4ec8ef584dcfdd9d73dd7c22891bde189236a8f14344e3a7dc22c4f12590ea55bce63d3d9f9579baa36fc2e3e79ea5c9476f2476df5e00b410499a2aee482a4205e832c383e2a07b9d5b3054b48003bbe581053cbd977cb839c6da0b7bd0f984db3281a852500880fb2851a47cf95f3f677393256cb08b4cdf6ffa3f2bc3bf33c9a03819acb6b5e593c1a665414f017b2339ae96b360361de91096831df303ea6efef2211014aa1d358fa526432337aa26d64c8f6e0592c72670e4c5f2f20ac8c1adb9fb9f11c2600676a0a11f876b924346f5c3fb799b6672f27ace6890908e294de26f45cb1330da5cba5ef22a5af83bd4af6d401550b6cf7dd83917e9e1febb416eb1f680d1696a29752ba42c9531211c5dc4976dffad75203bcb6a74373e1655de9394f1024aae5166c21221cb9a8b9f8ab7fc032f44a269d3a4af4b1e2cf9296ce36a5f335ca9d798d7fb2ead2f641eb9bd34c44921bfad40c39d934e6b67ca83128b6f9e7896c95cd911a601d6ff128e5e177c0576ad386fff2e456c3cbb0f21f86257ea2f118c852468e6356e723484ac4f8a0eb35d849feb85ed5eaf25925c302c64ecfd63a3009cbef04932d1c5501c0b117462fdd29c7407dc34827c0e0e9b161fa10665a4432a28d21ddab9e2197ce24b70ca5fb239edfc1ecebcf9472c5ab6cca48b7f49988afc03a93a6719ad05c5c31933d820bc816c441ef6c95d114d6a30143c3be744ab0e4cb769ea69d06b9fdc794c9304ea3152a6548db56edb9e74721b290a081a72b24c7ef7188b63e51bb48d988d4542c977e346d15a2a2d8a3d002285c59031d4225a89c1417945f919c7e193602c843e0d453e42c37e7f5ad6554dadba7fb8ab7f5b77d8e25184265754c1f4a29a817d0e900942b71319ab4fcf0d876e04105f39b9c4849fbbd895188a2a4500dbe04aa802277f828d5cedcd7913491743df8b818c6cafadbf051789cd5fa28289f43638d22d919db7fd2d0fd7125b5f4529d178b5c8a51f0f88e30fcd3224ed1946d0a1009ce79ef078b8460d9e5a96d691d34df9ac7d6240530ef642768e16fc34effe1f3af2f1cb7d9f6382c81b866f5aa23cb4123866cafec0dd5c6c5122076b35417198040edb195e2b056b1db5526b9c4cf11ba3150c5e325de2b0482c33b772aa7350f301255a6db521d8583b7603c8a22a9a314c84e888dafdb9562daaea577126cb9b9f478040073666d63251883c6c9e408ef837bb19d11a0dabcf0b6b2bf6152333bc0f800d9a7a001e8033ab3144c67e6d0a4a9a7259ebd8cdefb217be8285040c113e9c1c3fdbe7d3b83027c7decab452208a6808370c2b57e63c30ca397bc8ddbd97f5e1ecc85b6ff1a44127835072b49a3f7a11fc39652e9c111d4a6f1a31ed5d353132a637dfab9020191eab46b11ac361d012a39baf00365a99cc3a14569fe078326f7d86345dc462c3d3695490075f8fa17639d92339e1dc091e288f7d1c0e0a071d952099bd5a80608ac27bcb2c85c639eec27ae6a0597b872e92cb57a1230ff579d5728e2e24206101d3739a5360ce69aaf6b6ab64e749346e2ae3ea180ae44585f8c237e2ff42b654925e7300b9bf680c0acfc68c87e5c1da612a7669b87f8894abce8de84f4ef2a21b42a588e4aa5545ed9ff4de8b43bbe1cfe580679c8a51120fb3eb4e12bfb38e70f1ab406f500d87e0dafd52d3b93746bad11f5674fd58121a7980a2e2cb1b75e448eed0d9e2f42ac40e5c9f45a5da1c2dabe68d4288c14def61a9d86953ea4b1d19881762a0d76d2056171ca2d1ba1f0d1d4dd74d263d7268def4c033d49ca55ef2fc46e9b3ed5c0605cfcea39986a537dbf08cd8cfb3a9b4497a8933041469359a01f25696ffeaf5c996937f344abadad409258bc903b770895c79e17989cb3c372007d5ed7cee5a71b95c3c42f58cf40e88fd984a79bed0fca2799a37bf9043c9ef356878f477ca1bc24216d8e21e04572dab8f7c5a5784dfd2ae413d102f6b6ed78a075516947299da0f2022cf4fe09785e594df8d9f6dc4ab34e36c50c37e77a9854664db879d3626849a479199be78ef6c199feeff5205157fdc87476618408f71bfc7bbd91249fb18f5dbb6fcb77decbbb2cc161c70f9c76da1fbca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
