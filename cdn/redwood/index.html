<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fdf60c13cf02526b9e4b12f5f86a1d9e21484ef07119db28f689bf3f780b8f5b0e4360223a5680292b577c213674e80a776def09d4cbec6cfbb5397050eaa8a830e67e1f6d4348b9c51e6b7a0e10dc48e6c6a593060ecfffed8291dd4882905adad0b2ac38f607b469442269f5e593707917411fce20406938b6534306d6076bd29d763023dbb244782db3ccd409be1980483b159f8b504548d45a9581cb2cc5026fd4139f5a6aa7421665b655655d5ecb1fc1f90e94d14997bec965d6d171f5bb166960db568f7d7adfcd3ad08549ce4c3d23432028bd4c82a49f4e6cb37d4a9e9c4fc10b5ad597f7738eeaed542d1e7592f1d86c9234912b2dea9be015ce1041747e544d6a33a98d4b892bbacf516ddcc3205681de24848dd1c8b93d6893aea91d40c675c400c5dcb9557fcf00bdc84674e132d4d09d2fb556e80c86e883d764b7359b2c80e80079b79dc83f51654cabfe841bba17d27d518ff9e6fc984819cc16e0db6f5721d67579ab8f603959f214a7b8017ea459b7d6edda9a3e2940c44dadae0df6ff646adc58e95cfea98d0cb2b0b4974b141dfac0809e0b2ba5513198837182b393b4a31f76f3bd55c74eafe272f706b15aa28ae32c105413ef773217cfb87d27f256ad17f45bf4ae61812130f971ed80eec12c593809b582cfe5028c10617cdfe087a3f75d16f440b6f00d44c559e9af518759dfaa106e4eaa9171b4a102a720dcebda43e2639d1d6d33f809fd0e54ef4cd96a5a12d50867c6ee01357f79a868c72f233074f004e43da31e88064c0d39aa0f94d1fbcf32f8cb805b272b58baf7bfdd3e81469f0cd5422f0debfa131c8ef0ddc8b6e2b7d2901bec1a5ed83839da05aa47c72ef49f98295d9835584915b761b01d3749cd108883f8df5fbef73bc5c1644284f6a5defbb9ea1a3e6300c44f2d0d14ea4d5e43ec9f3bd2226ef4cf7165c46f9516e5966d52f5c0ef81eb8b20674cb38729d5808e6233bbabbc929a626e715e575713abd80ab54bbffbf9d7c3a5d88dea61729e94ded385fb19917011f01fca11857fd94b366ed8d2f81d6b1ba31b2452836e426feb278cddb7234aef2bc18cbb7e1bca85d87f9b86c612a571e79d27ecbe799ddb93477809661052c67948655399a49b521e850241cf5bcbc6ce014e0b4683cafd68f2a93f78cb320c69189b619cacccda642ada5f32b587eb23638c642dce26ca7a4f39d1294ac85aace262493f38255104dcdf17055e9627d24fd46e07c6f9e1e872b66443e5e2b9dbbd7df892f4083f09df2d3ad06de96ba06af1e93d6a833a023625918b5810c36dfbaee9a9e061712d6db64a1451a19a0711fe7711b7ad9a84c80584803dbfe53f9737f6e55172cb4ab3045ca1bf333e50cca4e84695433b4437ecaa9ec657f4b5fde28cdd218c539c6f97d33c28bfd42bb9ee6f447ea53ec4c8f32effc1b0a1934dff921c2de4d9ee82daeded46fd460800f2162e450267fc4d01acf515e77d8681e82517d9cca4dcf3009294248676f321fd8383802934293fa9c1c434231f6c3c89e1082bd5841ad06495200801596aac224c79982b1c4f0c65bb4faf88f1553075d068cc50974b9bd2bd81b3eab7da7e6d181072824106f44feabfb4064b580f7b32141c138bde223262ee2c80d993f0632f24e1acc0fde606dd5a642d52cd36a0cae7e79346d3501771824893bb9e6955b54200758a12d614674e8142b6df6adb657a54d2d8b05a880ca9801a980da0772f99c99d582fbe7d5a78fb8b369d56f4d5b6fc7fa060479c33304e6eb7c2f2ddb6a99a54a5007dcbfe8e581bcb38c6b1f43e4a3bf655d3c5bb7e47e7cc842b09d0f0a34efd4b8868491c7b3cd2f8f538c05dea1c337a720ab909e83b648e80d399861b1d5c32f858e77b1ee8ed30eaea7d2a57c53432a03ddf4bc7d3832210d519b543fd0c4674422779438b4e9b03267470f732a9bead77ce7d1a8ddd594c880d7e894fbf94635c77652c994294ef1005a2dd60d43253209beacf33baf88516760b376db7ff24d3cbbe70460f3bf4e1df706f4810c342526f8668fae633879fcec39ba315d836aba137095c96149d55a20fec946999adf614db3603b22c6f678bf57a65cb65a63bc2866bf8ea03237f217e031afc47cccf352d64b50cad4e9d30ce8525fba8416c14ac216ec8031c012818f44f1362ec578a3463a7345378f5318039a86dfe008577e8ab400bd7ddcc6049a4537d9a4d2c3145b5c0aff1c1065dfb70936ce6fdc754ac2dbbfb0c0891ea15cff007f2e7a7b2e532c3d849b5b9621a776e764a693fb10dcef06b1c462b4c64ceede1bac836274b12c822b499688382b6d356cd9323d520bb506f44ad86a418711123650d13fb96e42d65b01b5d585126af367871ef1c39f154fc354a4d9fb4e1f6675102cb21aa8772f5456775d52d95e60c55b97fac83afd08e9fac82c41ec4bde94c98ddd41f6485dea3fe18a36a5abf13bc4534d8fa23ea251a5cb8ece62baa61e8d65fc9b06a22244221a10c9436b62824aa4eef0163e7bf6aff379231a3c80a4e8dde06b8102c9e0cf2fd185a35ae9d86e44d3a78eb8e682466ed55f4a0b8851bad7c46107c023659ca638be874da8f2de9725d20e5307d37ca315db4064585a8532aed4de7276ea26b693cb2f0b4ffbcffb51bf5b11b2ab862724f95e2d8e3449dd909c415ee81e7c9984dd6dc6542433876da3ed3438ef2d6141eab8e612f783fac4dbd66921e831881b5969abea569b91903d7a07bb73651c6842a62553cd9164607eef6ed84e6d7e4a6645960ee671863009b60e0aafb7dd95cb99457dbcc51f048592756d63d0d4504ab63d5bef1e99d5a7c95abcb2cc8d03a26d5460c806ee1e283a35b67a2f516c2193fa4adaa708a5e63560931a6381f348553a01dbf7560449745d9a15ecc4a122085c6eda08e3997ed8c2484558cc4b79d6e791d8d5a796a379216e276835f5594b5eced17d99854f5b269d057660fb75229b88e036ebbf602abfda2b7fde6b0eeb4d06617b971a5c75e3f930063c24a6be1e116a944481d44018ae605ea96bd9cc08d0ba308445596d6e23bb3529ffda194c8b38b2a13f1a551cf9b13d31929753adbeabcebe974cd407f8f5dc2c617b78b4440b21995138a5fa0834017e0540f7b6fc17eeed9cb5705ad812ec037173283abd845cbf79cfb8e8ece3e8cf06aa1cad11a5a770322608e998996d3da7f7da1d137a86e8159ab3b3fa514425e698c6e08c25e5e7edc51cfd7d2835bb876b0896355546fcaeccb04dc9b2416ef9c89dae2a6587b785d929553ce1ad2e1d59ef70cd60a2c473f5d34c2a0c031962249d764775269b20930ffd6e21b38bc45cf5ca376c904a43e2d4510c2eef724fc3fdf1b44a8e01eded2beb03debde93b4c8a58a35caa9b6a1c083d57959cfe5977ad7e4224ce54d9109bd0a6c6c647c263b87313e6a85c31a16baaa0e07b645a201f3f1ad98f45ac5027924382ee9e8e758ddbc2e888f2434d559e7b86d971b167bb48d2bfb5f280a960d3b76445fd25a08b591c0e24beb94b851dd3bcb1c8b3228175ab5315e3cccbf8503c6ec094fa4d34a5f3e996585fd48a523b9cf996a3f8fedc861c3fba023645c8d0c84cb868c1d0eda4330e69453456157bcc304b3d292ea1b6c0a77906317b94d61dab4e66ea03a0ed92989ec87db244da4a935e799785ebe16b17d1ef3a4b7845f61c93f24aa79a740d41aca8ce01de5823277648bba6d933fb442b4068be6d1fe12f615e76ea37b5c585fdb5f2190605c4be6bb5e4964a7aa5fc60240985ffd376af67f673a309e049d70ed29003c6dba660328c6df35c645a8b8a32959907b00fe3efddbaf110f490330c529da19b9b92f926e107fe8f41dd05557b516ca889114a54ce0dd75cfed972ca8e3d62160c2e994e692f666f03462b137aee19ea3631db50c2afff9513d61769f93265003e2dbed24135ff68144105dd58530208a38b05751edc373495b2d8b73c1e80c254bc049192a513a69213ddd05ba0a01f4073ff5812059aa288d4095895fd671f825f0a74200787174d417bf585852e9344cfb788bdfa4a0fb2d45c2a51a5ff6a8338dc1c7dc7d07cbd2b86b8bc6a1a6b400e8ed19e4007fcfcb5e3256ea24308f8210c2d6767f182d9aa473a9ad8e1ef9dcd973034d497be3426840f342d04edb94bba609358edc948a56520886ff694b9d8bd074c5e4d5b4ede17a77e66a55588cf27f825e067292e30fd42c6848abf9adb46360ff6ed1da3f882f3cf5b35c2369dc510bbe386c36bcc67977b864ba89d92a2d9490a68b67ced0fef5f8adff1479b474af08c0254efe571501c485a52787ee8fda5ace32b54718902e7d92cd80ae9fc1e954b3fb97c464e1221120f1d1e84b9eda6d42ba36d97738acfe38704c63c03ce0a5c432327ccdf9fbbe6e4cf1f9dc96c1cb64ee7426cffa8aa413ebc501197fb2975b742d91d0e1b2191699f4fc6af5ac5c7295cf35553439c81d95940f9f8df7da5c6064a126e7b1abe8c55b0197bd9a6f91b8791bcf283ebdecc35e7327ef3a007fc0e094df3239f92ef5dcc55fe62ac39a367e50393cc4e886cf8e0f4615c5c16de8e12b39377d2735f5ee9ff1ee218b59fa5be8941908e7a3c0bb63adab15f97da1c4dcd6d10f9892f9bae941435ca5c36b911f2cb86c705777d742bbf19d428e50f2912e35f405fc3ae59fa7ed5b7ab410b3eb23f9585f2c1fcb39bb71a58e508bd10cddf57caea15db248f04b56826e7ea0b0d7120b592acdf60d934315b347ae9f902669a83f16f3552db8ee22bb263ac7ddc2d4de4f30d6c451f23739281ed585fbe62b35db60a26421d53a0cc0ff4ecf1c04731c3c7ba2cdcbc893a06ef477eaabc54b8e873db581bde501c0d37fe086944e2e3e51f3e0b9d50b7f33eab91df0198548756e19ca8af516e2888bef076b1f8ab5a64a02faffa657d5cb7eda14990db9fe581f2f7a09c980d08a0fa60359a164a597f651452ec4f65546da24ad4f08e7f78ba924ebe155482a46c50c094edfe4406494f4650fb000f5633dc59477ac8917a2b9638888a43799412604880b1638c61baaef1451fe9b12b75a9f3955af41effd72f5825792baaa658db1788642494b9e74a37bb343eb121115d8bd9f55b564736c21b6bfafefa49dabffeb027bb940d3f041df70dd6d3c07d68d0369a19c729fcb26669bf1fad48b167e50de473dbcdd13a8bebf81eb96e079883868b36be11a7bd646e49068cb33188891757e1f9650976e5677627a880e79456170c2c893012d0157de7fb387db61c29b581ec7a176b3d68eb924649dbd8e8c7431b6d1526af4f7f70245ed5ac13255d4eea913490bc205d49e45b154a0045f9395f68581404615018a0d1491f39127c12447cb603f60b91a733857f314da72e7178c8f34d4873e29483e456be26c157b2d79d30ad635aeb7fb9eab6b6e0777de4d8b77fac26d761d3ae5e9900c7835c256245b0b38e306db31c0c2a160fa3965e6b13ad0155ad305c265bd5d4407ad41e9ba1dafd1c34fd487728020b631b654d38c2d181246fc0d547a7302f23afec7073766ee2776eb5e19d64cc82b788b8beaafa029ce4109c7d2e564b53dc8cb63ed4a42d20de36740d8783d53db8b5e9a1b46a0ef6eff568e3bcda7770cb631794dcb681e9a754042c71006fd68f1fd43010a6d39a249f2780f36cb100c79b03bb435869de525326dd56d50762e2722673e33231cb7205568ff15e86092e8e624e2bb8f63e133f19e21bec5e373fdc766009c8997989c4f5e2b1072af13b39e3bffb1e8c6fbaee9fbda132e3261656bfad30d925108192431f8d229387d6ea4271b6c4368c9aa2168147cd5a330f2e103181bfba5e3b33b327448fcbbacf556ef3b3cff7b47e43323d1ea7f8be64a39f58de95f9342ec0cbccf80ecd140bde2baa5460ed2fd33d32469f0b510001ece76bd6493f436d64eb846ad8cd96820b338490550bd6ac0481a26499d02f9a5cbfd00dbfcdd281f140a0df758e27998755e12356cff7f485befca4f553e102cc76e35fb09460facd680cc3d4f1546ba9af33b01ea8bc88f2eb268f531e914700d2f39fe0f5b64872d5279227fe246219ea58e2a380ed91ea38ca1df5b02301f794d733ccf00a6d80eb02f6c3c308a8656c52e22e44a143defdc53e56203b465490e43101682b032547156c4894574cd87fcbf8d0bda4ac01d100b7d132c3aad1875d301ab5ef84cb7394404575d8923bf29e3a6be8e49126eae029fec6568c5103e85ae580575607806158bdd786b1b82368b8a288832e421437d9083724a8424dd7b8f0ac80b0e16a98bbceeaea847d5dc9aa38b43a7c2475ed946907f195d3c7a94acfdfd998dabe429385cfd7de8bcf2fda62d199c6838173ffbda8ab65f0da42641d977392ab78a6ff5fc7683eae185846c1da8fd7246bad2355585a11fd3eccec156befbd0c5e6cb85ae5783bc24f260ff8eacd58689232e2bae2e649eb29bb1c533cc6e30cb9688cfb756e0a1eb267f0880f9104a2f3cb017e2eaef8aa900fb3a5b28e0c554e4ec9b5f9096d693e4f9e8bec35a96bebc26a2a59b2eaf0ba3e9de6c32f1cd5dda16eb970d9fd3bb307985965ebd2cf18a06beec0f2356e55972b99d9503787e8603ad884b7ccdcbc11fc6c6130e64a3a58758da8268063f5d3bbb7952a30555086128a305f328ec19ad7acbaf5618ce073b960aab746fb34558f289928860f5fc7be534304d41c0200e42eaa17d387524af81cb8d68175675c4cf57dc719fbe0a7687bc020bf305b2a23c4db0948e5e2d7f6607605efe842b712ef5563280b138fb56d0dba3c6f93019eea8381a9b81afcb88f5f161ee1be3b1bc602e8273496521f25c4f61cf4d7e028dd57f05265ad51984f3f2a5213dbde7b9bd7f010d233b4daa59a728208d69d77e1a5c793519b2cc715914d0ed60fc53919dce870c85b5e0e146f98bc39ed54cfd29b1f2abcd195e3cbe102bfff55db58d7f8123825380802585aa1a328e189b4aea91c0e35e772e6e4b9b6140b70e77940b2d190db7addef2f3962f7438892d3a495263357b4c93ddb49507b592bafd4aa40a5139be191cc8d3cdf46b018dca5c9ccaff21f1361eac76e6028a326c60d8946ac1a86831f149a30005718f32d30db391b8743efa007c938207bb100705075e74e1b4642dd9157c0d9c94b1e7aebb19ff9ca858aaaf3c9ac7dac362e283c88b2016c195ffc23251194c4b708e3ec63ad761c6b6abdaecf4de6ae04cb7683611c0f648cbf610525b4bb2280e028e4c8c03bc4df95f8a3e7e337e52898ccf4eb08e23a3c656970e05228954e75738833d41b1abd942b319c54fb054afd30f80722dc7fd4c8ee21897ca910bf6e69c19914b04c5f90d06fa65fdc6c8f13a00789571537e68346fa37922dead9f24a653707131a73c2c63a6fa702d591bcc774dd7bbb1166974ddbafc6c9c743030ee35fa9fd88a6dae3accd8dfaecab4878c4b8c9d72d027597ac9fe72db86642f137777147fd4b0ee18e99340922f64a820e5615b66ac43ad2c77aa7065728a94b67906a4ca098774a04c52d09ffdfc0dbb6fae625be660524355aa99eab880a49a0b9344b7a12aa472a206821ec2e35c27d1163f61ccbcba6fd37ab32ca7eaa41f6af7231581dd7542e226367f52cc8466cac801aa99d583d7077867eac9eee18c98a0a18769d441c4f2f067c86d5ac3e2a2621b4ed13d75324e435b38fb90c2858259c9020152766faa3bdccd233c7480b54a5f707506a63d39cd7520d613225dac888c43a9043d006d255d80f9ecfd5f48e5ff6aeb45600d86e3e3787cd29637fd3541a68308d0ad68de423809649c05ad70b4cc883d2a69d5d702d9a34a79f12bc0db8a59c4d8559e713ad762acfebcbda8c9004712824c161a14e2b6ee02e3fb7ee64e56a03ea17a33804836281e1bb4f29ffa911a72be920d26e1495d5a173920dc6004596b3f6ab678e223fe0cab2b9338920a233652bc872e893a98b7f220f1469f6e3050fb18476de910c73a040e8d2621883d1449caae8bc1dfe7dc05b7d1efb9bef77632b34c49fc56cb92b348bf8a5b570714f4dae17a8f6475705b15a450018aeff260b03e4926b871192047b189638c7ae434965f8dd7374ebbcd26dbf24acb8272698b1382624bb62be410a02cf97417571046401a34c231c4c30ec39bf7e04bc0276ec5ff5eba1a5b908312d5a0c08f002ee6de6eb4c5ffeb90e62f387d8bc9e1f1dd20d5ca027aa41d32f98d6ca8da96daa7c9e51070662ff58ba0dadccd6e6aac86585b66ebc2f06922b182bd65a89db0444f03f472e1d0e39d22c3db61162fc3e3dd5065f4ca55dd8e68820b462c77934f3019bd68dbf143c7dc4f4db62553bd85cc7d1a729ae56ffb80af1f32c627655e006b64a7cd6c00cca8196f13798485fa6ba62e26d609dedaeb77f36102d5aa7767ed6cc1357d468160df956088117e3be221110f482c2586cd16a184223d43a7ea41503e2a4671cb5a756bdcec16f31ba503c0e07c8ccdcbfcc5092eb80239a496ca5579aa340133fa5d14fa6d8204351fd50e0f4f02e347db83dcd6ced7ebb6c4537bd0368eccb9d659380bd0dcfc92de8067e9ba03cf91f37b9a679e9038c2ba7852da0ca83b5aa2ab84f37fec337711afa8c7dae2d8e766c4b7d941939b1e05c625a9e44b7e784663e8ec6fcfc37bf00346d2ff6e05e68e1279c01d724d6e1e00ccf9c64e2491ca8fea904f92879b4e9aea10a2bd2beab11293f79c04ca6e96d049937ee3ceb5984603f667516855883de1b6a62dfd93c939e9647d775f58ce590a576c04c1feaf32f992601cb0656f8079a65fd5c5766608b9a496dc4978058483d9db998e20fc4c4959702ec7f6098f1501e00d7cd46b75ff7749cdafd49f012dd959f49cfe1c36c6ba3e092e9c65c035b1b368f8ab76fe620111f56015e5b7209e2b1472ccaa73d5b647db60d88cf6f83d3983f42ee85050729c7838a590ab773324c1fe598f20bd92610f27f993a46d8b74afcdaa914b94124cdafbc462946bcc6d20af6ce94d98c1260cd1b428bb2f78bbcc0c2cb29405f2ed69a58f80ac7f54bb6bceca261e47e6ca101bc3e482dcba87c76babf745ce12ef72a576e2486ea0d0364f5084867fd7a947bcc8661802c0a72a29c5b0b1a94676b0b5c58ac147cd9c97823d6ab659ad0bb84755766bcefd9e759a12195ff8973a50cfcee338573d1605c4ff5584ffa7fceae32c059459863a349e9392ae78829270cf36316ee8710cfce64436f5697e6b5c2ea698f2fcf28c11afcae28faa80f5a6629e1b3bfdaab09f15822ba76853cff1e81fcb1764995cccc6d8f9226c4052e53e104bbc6c1a90e2f2130496bce74244db26730625602d0b2214b4f1646986031c36a3e877bb24ac4aa80597522eadad2c6ae0fe7656fd4f1ae78b956b59564ccf5c93c94ff12712532beead91d233bc7c8e8951f1ab56ca592fc7eee029a6c46d0c57155b244ab5cc8cbae74f6b2b7523366e031830f32c97000d1f7540d679db142dc2d497bd6cf1f205cc6d2575796b082c2b1e7890b5a22f8a5e5dc4055469324484eb28de729e39ad650d10dad69667df22322055442839ac0c451a0daa2fb82bc855e4a20ea1b190927f77fbecf3f2b3b2173777f39153f6c16854d51c7cb2f64c92651cc79651b1e85d66353781a9278a56b9d5db6277b49769353e5344001c97fae080f39f916e34cc39601e249b4f1da2a84a5c640306d17a32797fc206aed4cc62c0215cbb86c92255700ea0a01f53a2a5a078058deff9b477cb3db90f957fa009a4695327386f8a0d0d89902062bd304da48e356a43daee0701762f8b767fcd65d839ab608842521a98078b32258357f0ae3a67c3abebf1dd07fe4a0c2f0752f510be116f8f54cd6f33e325aecdec434faf722e1d8763f8a31cf029f235ad3ae17733c1479b9eb02d28c19eebd3a0f572315cb03d9eb0a06d4c8a741ee8f35bd1a51c0e320b1f58caa1252f4dc421438b4386ff0b08a187dc463bc685ed0e58e5ad5a76d4bb3169b8643b8ed3077d7c04f6a0b06b497e5a8f837994c88f7f0d4e80913400984151bd6406ecc869a087b9b9c705478b54752bbb474c67c1b44e40d375bebf2d3c196a6138410d94ee1ada6c11435b6a019f0896502f4943dfa4d7af7c7858f21a04f727e11a8220ef7b4ecff5a495b2825dcdff77b61dfa39e0a2c85a504dedc29660c0e3df7b911e488a4a0f1a6d54cb40a6468699b797cfe97d37a01e93a0bed41dd6f00cdbaf9273e6f0a115f69c7ae0fbb8103547bfd5946e45fddbd677eff1bc9a26a0f32d93a82384599e4b0c79c39871888882c9e9321d42a6238804090b8fb0b69caab6b0dc264c7584451774720a277802836a8e3158b6514ffba7e376c49054ecb33386069de4ac11e6f8016d859037c74a5d282a4641b0bca6ee5ea550ed98e4531d873a00667061e31dfc4baf8b0fc7b0d2e18843198de03e078cf025f7393223b7308ce342156d1f2f046f0bf26241a46e43b002c1e55bd4a397aea35246e321c60cb898bd0c9c2fae8ace079099c4f0591aa3508d92b1e5c36bf0d10455c7698f546737cc9eb647b880466ab4296d2ae9736552534a902e46b1b5a2916eb54ca2af01561496d314e2a65561dae42112fa82c1b1197b6c068f152f72ec700a683aed622bb927ee2e71944c3fdd5628c3bd692b032ab0de11c9624c490be18b0a09dcae75c8b2616d81f3d69b31e299178a7b95dd323b48cf5cd54c0d729ffbe91cbb0b039479bf2f33ecb50c21134fd9f2d5e3c83878100cf05de7b684df8efd88addbfaf141e34039c97d7fcadb1b549b7864fa250a1a000c724220c414eb27f7e19aa541c5a4295be668496aab5c844900832d539571aee47ccb7116d2e9b317b986b6c52fb3be923b66b4f79a2cf33c03e9d451f37111e7911288c4e618eec29f29a77e3239308c4023ded19278b190efb330848c7720f57b337d5c18ebc7ebea675a906772fb7d3fbd917a8b8b6c2de9076807f9bbc474a676842156506b6304b6a9ed2a1595f0dd30fa2f8ae7a48e4a50e427de9a0963a5a70c8ae935049db1aca421d35099f805577fed4dd76da70b4a63b77d4b2fdc099e2dd1173c3c957545c355bfa10f649aa7dd3ab5b25b81ce6d3d17e6758fe79ed5d02b38c85deb891e228c6fa0816246ed29bcdc38ec8a47333d7466ab4c06c6035fcc575396582b54ca204f1027175a8494062851dc26a9a85c3daeff9e7f7079de78914671f75cf3e894717c65bde4d53031980f94080a8d4ec954a0b76c0e06f162e4b533cfb2c393af3ea13d8d715400f3f84b15caa8acfa2bbb1df0af5dd3c13f36b1c359d801ca27e7c3fc65886422f0a4d70515387896d6cd6e14709a675dfd1b8c8652bc583e9afe856466e7aedb3afea35ba7233f8d63416c28bd6ae21d2c34e60454f5636eb61b1df5e1280715b8903c46b9e4066a3b655c87b7582d90f25eda7f3ed3064425434c04759b09519af1d8bd0a92838719d72170d87a6b3da01c88522af93575b62cbedf7774309015c8d0cac860977627e9171a26fd2973430340b30d9086262e8c5460339dab7f46fb5a32f713bfcf43f7f7825354bd631c7c69e63770450a7fa7ecde8dc28893c15e9e3fa8371f129eb78fa167289d4470f6126a2ff77d12e803e2a9aef9eddb245b793be9b93a8772adfba850601ba0316728ff917e0edba8560bc8e7431e146d02888b261743ca0ac03173c65474a7cc91d8ffb766769d8ebbd7b50b13006c9c24bbd92488b6122cbde06353aa1ecc4e4fd528f6c6332fdade6930b565987d4179aa975d48bae2cac4f90d5b9a4200554365e2811337c52b119b42f3a946c00f7fe37d896ea8b17523583cc550673e2ad0b579bff771a4cc8cd29825c10ecac336130cea86f6ab741313e1b96c8f2c95698bfe01cfa1d01f3e92340faf91576ff339a3553a880dd7b8e22c6d126ae5d500eea0c26208e13a0a3776b8297cc2fb1d1b67ccc26a96c5e82c2f37ce42853cdb6135fe542ebe68ea9d1b33e2b059deaba181ada81c17b2b2284052c2532a1d5df0e6a30f49231a99ab3c7c1d2f0a0432eb6318a743b34c7dd61703bcec93197419e43aa25465b6b2c20312023d699878d2f26a4a60c38348a876c65774396f6f94299e0e2d3525708aaf46964aad416b2d0b6c3b372954fbcf8ddb40ce585d1939aac54b08a7f0db3c950ce5c542f369d20cccce1636d240733742896510797afd394ea09df104d783ef414531759d6a5e19205250b3f38ba0785bad214b812b112fe876a53f117abea5d62df0fd9ea253b6acc2c3b9f00c6989f77103045f2c46589d46c8ee44acd1e209ae018c5b30063bdf52ac8c5f8dcb0aba76305d6511effdfe0eee7259427216654bac1cd7ec2d18027d474b92262a19bca01c4eb0bb40a18b0a6091cbbcea769b52bcb794a5726647a6aea43ee85b2b1a69899fc50a585c70d8e98eb7e6c0547ef70c0b6c2547aa772551a3f556eb8dbd659b39baf3b631e0bf163f06f95a172a04e7c56f23ec571b7a2b0eacdca091c768a9126902818f6093c6cf35d2cfa95eca123d2c2194dfb7ec254dcc73e50f088215f2e8cab6766e295f09a3747f81b694574b6ef15962df99ae5b5e836f9f46050e3b9954af9bec0f87a267c3508a37714bf84a4994e550b61e2686bd207f0a78fe0f271f2454ef4766418b29ea9231613f9dce643ea5ecfc94f159129321a4adc6a110dfef483d8b028893e248089f2c78adfc15d65f8b8a6b7cfe91220f07a7138892ff729c4ba94bd58d5fea0890f9a9ede162f327c636edabc7cb9377a34a35d856437768ae46230dbdd8711c3bbb76e72c73bf3a61b87386422d8670d26f24f9e93953efd2e10f34429f15f374858ec46de57aec0af538c6584115d5bca97656d65cecfc02805b1285203d0cdd27eceedf18e47f311ac2493fe217a2589d247a0136dd34b546df4018a3d38a6b524c1d2e764caea8e6c6563c08bfbbc6822eea9ed1c128124e1eb8dbe1c62ebe69dda03ecd4c0b4da1d033f884425424e29a9de81c7c3f5778b834f20bb0284511472242e5adabc8d0335ec66e896c52c9c77d57e008b32b486ae3f13d2cfc4b23e038ffef13dfa4fa48d5d09c84c061f6369b0a7151e2f30dfacba4afbc2ed94a10d460f27d29593e568cafec00e1e42a17b8659b84f5c874b2528a5acaa6b998cabec3fc567152bef147a5e2629cb5cec186807a973594d914a8befdd374002681cdc1190e762a0858d47b43861553cd5680e4fe73e2b4efef18e7d09d71b3032cf9d209c6884d7786794be4b396c0fc1c7ff3f6f30368cedd125bfa03a935178fa310c86fc00e168c15d115e96f325acbcfa4f3375839e94dc1ce271aeb1ca4fa73e23b1eefa32bb741574a961ce376099ab6657b4e36cb49df7be2473df348b844aab0977f34511f36968a9f9eeae2066a02501f359ba950c70a019499c4afaf3cbdc31a4d8e41b02b2a96a3581d1bdf972cc73c041f632daa3585895a2eb64ecc010e10aad98d747fb66f94293e17359a7c6d9ac7e2d160b6476dee32a28f6b81391a0890b86a8cc70d6cdb8983966026828da37a88717d0c63e3e9b731f912e06dc86b013f4cb5e2fcc84102fbecb3ce54f8dc94e25d2b504d4505fdde47215b3effb9b2c36e4a8655cb4ffe2a9c774c7559f2d466bc9997bb520c63dacd27c37a86daddce12ef5822e6680c0db943e1f46bb8fdf86d2e69ea704d9c281ecc49799b45d7616c1fa37481cf9673634e0f2859d7a25191f171ac1f2aba346f0baa021e63b89add8fb2d3ef8d427cfee00c19796f7e134607c2b1b446c61aa98ed07ff30a945e5663f9dde12dd6694a46fdc75392ab97cf3e29f6c81c768f2ee5749472be249518a23b4ed747bd2fbc7c93aec414d8a52dfcd9e6691fc2ce04f5b836ac23759daff035a56ae13db4e5f8f510ec4ecdde79035410e6fa389d7a549eaf631ef810414533e981eed7b6c290048beeb55c7ab141bce24b4a10c48d11eefe79ba45198765d94926be341ddced19061bbb2b15a71cd3925b11a1e0392d374f4abbc3a80e80ec6c8510b3a8cc6d114f20d1c536e4305c1c06d339fc6a4e04e833284432b2e04f5f016719d4a3b354c034be6d7815915b63b413e6add97976af5ccabc3ed685b17db54319e3272f746c506be1a67dd13ad30df8cf686ebd12ee90e48250b23d6e678cce3dd01ade5895ce6a49782c2881148444f948675011a75bca21082c2104e20b9a911ca542fd9eafa837824beb1bd570b5bc9e294d46d586ce2c7f7f4693968dd1c8a5a63c4a2fe08ad9d83195b907241efa52d14881ae93fa6feb4d9da3bdd86721a94b74688edd925ecfc003e75ed1f1377ce9574d02d014a0451f663c30747f4a2f2ac64cad75311d39495dcb642445f52b323836b96558b51142f50e77132ecd3b733a6c9a9839914a8b120f06c90ced463705afdf028d6f5507f141a089dd5cc3069a53bb05c31e097274ad156b154c6507ec91aceb3041abbe3e4b534cb641e9f2c759dcebc65d82f2474cbf2240ecae229b33207fabbaa4607757ef1da1e44cc70fa6ad2e5ebd02b04eec066b42e274543d7ab754f140437059be31f83b7ea1a851f1a16e0afc9f8358070af93b795750bd3bea25657014a2182c216e848b5a9e8ac7ae04dfa0db82744a174dc3f237761e32894de9c6ae7a8af03766a4b1fce3a08f9440b914f873b7c4c6cf3ceb575cf0077255c21912195f919a3c40d0a29506e2bb053cd77272cde1e4caba72e42bf1e3c48e32279a495457e06c8c74a5013be74e67249fe391998d3838a535ab1a2bcc356e1af85f195a19ddb1316af58e5266fbc7d6727e6f4151c0e680a7a9d002d59abcfdaa242b8f9e22c0283d5f03d07c65480335360b2497bceb3206c00383ed65bd6594172dbb33b7f3a9a9be32929e23e78448eedf93254a4f730dc2a224fe9368cb2c6f7eaa5190c7341861f1d3a300f04385ca2b61a361cca233b32199a3bd8ee1b6dd3f4ba2f925e60765c4332401314638be52e4bf73b3ee356a06a2e39d3c2280efc04e2ce45534e20a834bf5bacfb4d2bde4fa434713759006ac206ea3f9cc3287f435c7868cfedb5c304b4d522c1051cc1d33fc5e5d9f4142973552f00a797bb63c7a614e1f290eed5616d6332920287bf8da02c008f3585d0e626b4f5ad864e6fb47df6d9e15875666ecdb2127991e95172c5fdb597eb150a27a83fa332f97791f36a017b6fe5c5333d511d991a0113b171c0d6bdb78271aca5bcc09aa08f6f8efde7f3e0d02b419ce273be74c5f9e5089dfe81cd86b64da0d8950d478f423f827fe534dc729fea028333ce4567670a276e43d85be0fcda6502a95fbbe4158fed81e0d7ab55c3b248fbfa7a08c96bc603bf9355be722d6fc2226328049b2558466fee8d19c44bc50048d12deed08c3dcd658646e086f758c85edc06ab479d01a3f9553b5152a520254b4991c8328236c61275ab0c8fa53c41dc27ecf9e4fa2a6db840ac63f13786161950af7af59795cc9ae39a7ed2cdc7212609a661d6bceeb88f205c0e5d8065c23955f005f33c90a5fc55574cd0a2497bc1e058f4ce55107fb324607e13ee693e582340d698383039cdb5c3bc8f648033718c1799c40289aa67a47cc66c887e600587f501d3b6f6674ee79854d385153e4a1f6627cc476c69eb1fae3a6d9203d94b61f3424a1eeeaa9f942c1c989fa1c17c3631d2d5d008205fa7e22276c2eae0a77ec6e4e56c5ddf08adc69e446e6a6f3b27e4c4facc629dff5210b8d3afa40d2905de5a33a9c0e546beaef6f19d5f54fb73b36f476a4f4cb09c2303ca96c2961cc2526aa73da08badaaa46d5f10739ffd69de3554fcf14a11bf4f78164877b3a1fe0b1895dfe71cb84ebc5e3b0c0193639c43a728678ca58fb9bf5c76b53f7667caf1dfab57fdadd79eb051922d947ec29c901a034392d120d5d499fa60a6247555dc61c28b443ff9cf5b34682f2cfe767f911e19e174bcea3ac03f58a77f2420e67a20bdfce698490f4f67242b7ea71d151ec00bcd4eb09f202ae94fdc6459ad462eb07f9d2795a46c05aa8d0b2fdcb6a4bcb872bb4d42ed211417d2098ca16cb6633ffd182067bb6d8104621a8b2956c128af41925c10eec99d110097587b66d98a305941a7fa25535d4efcde62ea52ed735f90fe2ed9228d37f76ecf71ad4582f54fad3a629b997e0bd8c1142aec88d7f9f473fb477b2cb70d79f8a0b515b185fb92333145191a30119ffa8c9ce30ac8c79fa24d19ff6020f5f5ad51fb6d67d0ee56aad756819e47715a59ab466ad5730b0e2cfcc461a97e5407aa036fa1e52266404fc6fe38b228c4c594fa153cbd54ceb17612d2ab4c180914a73ac3b8dee17ef5a2b647498f5224782ffe2cbef258179317fe30d83fe14b5fc3ce805f364e5ac4da51d8fb352d718939aeb389852ae95b7d187e1b8e4000dc759dd31ec278178f3783029d78e4591e5d45dfc1eb5b2aa7b016f4c9505b9cc5debfb6ce5d51f876079e9989a6d27e42fae0bd76aa7ad91d8b64764bea73ed4fcbdabe73fbcc699412dc50f2c3beba6a1289012b9726b041f976f679d59088bcd85a5d41601025bbd2650d78aa0a766380192513521e8193fe99a091f4fdba0b429d8ed6da280e7426ec2c1ea59bf6122367ee16d1d0f6ef1334777acc7372f196a65be837a329b8a5a0493445a0d653bcd10c16db8284df63ee5f92ea91e8321d45312b4ce49a0ac3d405bac4e9408d13d831c4d318259bc6c22339574a259b9bf6509877491662e11481dbab8c1404b8c94a785b9b94a7edfae29204bb8ea969d9a2a8d117459df429f7222c754c1a53336118fe3afa7683df320208820f447785a8a48bca2ffc9e69c44d0cbd31e1b9cfe5ff2cd4772d3ce57362f7cf90cebe457c9161b395de24239c6557b14543b1a433d2a8de2a5c6f6467d75d0f4aaaf6cdcf23bad54f47a70f108b00d743e0ac8c035d9334585d7003cef3f2c187d9b593e9c780087b1a9a0b3e6c6e5e4df5ec9dc32ea82dd075e12c9af05f635a7602e5832f4241fe9b5467772331451e5173b221b0b58f90f6224164714096b9e8aaa359ef08ad178402332b81564dd919c85a969c9484c99a5351fa0d993e45f76fa854c8569691a766fdd0612ae80c47be174ebef444253ac53238d188b9903a2abdc78bc79afaee138c7f82ad7be11a7349f1923966273a3d0c2a0cf2f9d759f86dfa2ec09ff6a3a8554d5530c590c9f42856d491b86789aa830ff69558ff485652b49a5a419c98f9d2515e56d613243fb8a9d327924b328e73cf5e057cf6ce0ebbe780a011609268f75767f1bc36b1c522847869a895f21390b97bda6cc4b75188633e11f6304237a9dd8d1e10d5808b6fc2969e4c32cc626682a75842c88da86fbd6e10f339d3e8236981027552852b696fda715da08e7fce9f86e84d604254db49063c5b07b8a1f12e619034104058081b167474951ba62bc242ed2e63e8145da29833a6b5e8efd658185a6087510c2eb8dee59cff9f0526ee9ec1216a4d1436879b0ee147151897c25806d56fedc828a0b8edbb47a35afe1d807b19570c8e292400e51ca1f2b3946100277a8913d594e2c0a63a5d7e66603c1a9c30f1601bb3cbd8f714e36a171a014d6a0b14165ecc0de452f292eef2eec903791f2904a791d818ce0a7161f25f800fcb12b9b505e55e716792f15dc2b51c418e5b76a4f4d978732ebf2f7ac2ff80c1f3da8772318d5aadb914beaade7fe61b865a3d8a7d78beee5161d48d22fa76e99c2705f7da45bf01e2cd8e4aa7191ab38068c4caa2d122dfd1c5d44b8240e9d99e832030ecbd48e3562a485d2c87edbf6f066930b6ecd2fcf49810a4faf1b0cb643d8a5fd104fb88af8e95cdaac0eecdb2d19fbd0d059e025204421dfe7362eb9ee1b24adf048dd9967","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
