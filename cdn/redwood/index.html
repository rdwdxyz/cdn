<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28baa579b9f013dfb24a406babefe95ce0826a6c7d6d701629cbb90e531df11f8e3ef1e101d66aa7e48bff18d36133688282ab9987d5a31b3d0c8b0c2667f40b7fe21cc6a2db6f0cde62ac9ef653b3b8e650a0f2e035a57b3164293c9f1d7a8989786fd26604a5a6feb93ebe88c7e06087375e8e3ac6b168cf7ef583f558e9dc371f40bfd0a049e01620ff7c5d9017a7ea695c2aba20ca2958220f16aaa4abfcbf3ce7d3316d633a2d21a2424ac982baafa880c3dc3f10e746d7dfc94e78ac4c08ea9e9759ed7ac1c3fbbbf40c84fd99d1abf50eeeed97ebca246aa3a44b930c7ad98a24fb1dc946747883330253475ad78c476b6ee6b23cd72aceb7ae61a5fb82d9a7f31586592e8845c68ace986ddd3bb59f0122b2d9d433dc62048c19cfe692a78ad89419233d4e4cc2ad86d7018dff435f578bd55deecef07c2d21d01edb35084f1ef3ff8bb7e9a0ff2587c69a8a62c9770611308e9a6c62f36e236ab0e6e88dd139cb81d656dc8db6c10e9db2554323be0e641c755e4c24b03fece7d0622d841d56b00c61cdfd1de90417e5ed7e77756a39a6d5695020324f57d3f999ee1a708b5fdc3a86827e303868760f6ce5dad77efc85d6158b52c9b1a950ce7dd7750c677874ffaebb1f540d17d13959ecbcd79bfc9846ac8793efad35453ecc1e61999758042064d4f7c3df8883de7a7cebd9c261111d7d2c6483b023003a500f05dbf5ececd177884db4c98ed5dd1e3c9c5ad4c904077baa19424563904c17171be24c392583d8b7012185f95a33d5ebc8d9f7091de06f3b59ccc9fcd44b9525114bd3cc6f0734fb4344e904435517b0d4adb47f31fd10ef0ec0fa4d533b94851d5e015b6418e9dd32d77b76b97ecc642f43ce182875ba76caab6ef223c2100e0f78d10f4cb5d85a34012372b6dfb90f55a38cea4509e402fd8c5aaeb2fec059043895622af91bb5dafaf6368929b558a1ccb493cb5ec890cc34b50c9059c371b8fe8c4303282fe6d034781cc944daf5f60209c55d40f0a5ae659497f0ae892b1b80d2ba35371b5ef12f9df44af2319918399861c76b970741665f3108d8c815382f0f51d6199a8ce4e3de5d58b4380d7bb997fb571fb030f7c77ddb84902f1e725bdc2b227ff6c9365ecca6533c92319ece3b94c90361ee507a33385e1b99eb7ad832224647c1ab987013e61330e5244493fedbd0b061eee12e39b951d29a496302b27ad3d78150573ebc347d4ff1a1d3f7d33df96bb71011ec4cd48270555b4f1127f45a6e0e9a730eb088664666638f4a86f1cfca28130c586f0591efdd9d5928e06157a7a7fde58930c2e92d4f56778d4f302e9f49307d7917343635ec02d25ec9ac25562ce4b982000969374860cb0adef466c9de51a486f2327017eaacb5034c939c34fa79cdd16a3005fcde3e481dae8750560604f6faf14285b8acb96489e000d223d874fe675da59d5b14a35ea8940ab9b617c5bcd855af5c3401040369fb100bb536c9303ce94d0cd53c2995435a215e10d59c6fd5af8c175659f4acc433465cc2ef8845a251fd32bd3b81833a9637b5667f9f82f0b4d8f43202703a8422bd47c52eb57b924de883e203512e328ea237eaa722db0289a3abbb6b281eeac8696f2be1b7fd13f1b6888b704a810c23e702c9d34ceda56abbc7dfa89844b91eee562437da2b137881d1118104d3a5fb6f195591d0174371099bff38322eee04a37e031a7299ac5b619dde108db68184d0bcdb863115b9851be0fc457552f363205a4d568866027944047b38e5b08118c74bfe35066c5b18fdc2f77977350474ffa443c26c7f84c082856621916298ea2acc9c08642748d6d4a1b509a8e2affce9e1b1bf301501894c5ba706515815e0bf7761ee57b3036ce6b0343c8d6265c7bd23da131b57619bc796d4a41ddf91c26732da65f7beac56cbedb0a40862f411b42ac7299a8f483ff8a3eb562257da30d5839c02d83b88526b0460cac6f8e589b12f845492a107e99740b2d62cbd6486c56c95956fe4cfdf7280ae3822b1af03514ecb996f1cbfbb04db4635dee32debb93947c3e4756d785931d7e97f42c9d0eaed1f6fe54bb911ffa8598e8a0fbb2265607301b94c7191453d4b0e3b4d4c8e55a5dddedc1435bbb552a89e38a2c07755c9d27bd8b5dd7cec0c45f6fa82c101d6dc62f8cd14fa7ae1a953bc62e2a9688f33d7ff2b9339b3e16ddd1a5e057822ee7836564ed6026acbe0bf668318b67a1678da0c51177f577ecb5bd371899a165a2b86daee985a86ec7effb4094bd9be80341fe1223450cd8966345f752ecd11ab2f11eae45e8b6c19c81fce565e30418957a998a2cd7291e511bf9d8b308eec820297f8834af1e4e7a833ce1c21c9c90cb5f51a850c0624a6f63cf4a61256ee5acea047db79412fae1c2df4ea6a8fff2055a0e473e080e482d57f198ef06debcf686e084f79f8ab743259236a11dae4ed0f0ab8ec274830c941fe1b858566558e50904b8a5dabcec050890cd8febaaa42b3bbfae531a76f87ac0bdb3e7b28de1928e6643f037c218d919297174b4ff1e0657ed28b60e7468fe209d5213eae5c106de8101cd6a8b46ac1eaf85a743f89c04cdd32f7b17c7c8b194bbaf4b92ce3a82ed1223677f3c469551f1836b67167447665a8d420d4e801a89b25276c21b1cc26a5c344fee960f52156fe8aacbe28d86d0f088fa1b159a2c7b71ba64a4c31a1d4bac518e10948fe803982f0b9b4244d7aad0f501f5abf1c3e157cbc868a1ef52a232a266fd9f25477e7af3e93ee10ed4890b98a3a5665d553122791e2bc5954c628fe333f5cd836d0a9c6eb96639d9cf1e62fc35ee87e043e5dccc3af1b6905cea182ce035bdfab59ac1c3ba86d296fbf3d3bb80df157805fe7b455313d65d5a6f9d3aed15f3c540bf32eaad39fa4cc271b8008d0df3108a64cb9b3765b562fe30d880c1e365f65e51657a4e09ad1ebbddcf1a95a88f6e3c13fe303511cf27bc014081123afcfc7555797fb689b31fa614e1890d0e83e2642232dd38538de9efa330f94bf99722ce39c568ecd7364e9596b273b04819d59e0e3067e1c4e9538f94bdbf222ee0661d4baee4a8b178da7decb0286fef92808152ea3810b942d399cd9d4b906861f780e50ff0129adde2fb9534a4b18c61f3e2d7d6e6557d0701fb8e400f7d60b3389bb8e29f09101e52e87b75d3179b7494a2df79f44866e2ad3a6699399de8c42179a328c02bf4029ec21b22b88b248d36e9c87200867983c503cbc21674a88f96c329f2ee5e27b4e93f6d6292e759e8f772348407d62ad1bb993839629bdc53ec920400f2edc1f4739dbdabc0c4a163737258beb84ceea8c896217a955fe1b09e0e7cf21d9ec03c09ffaa553c8ce6deac3367ddbb361587ed65586eb2abaf0e9f7e365ed6dc6a1c7a671ce91be9391e3ba1517c1069a1138c8152f87965527e88fb841a89e6062308f2bf99afa16a5f086b658e98eb73a0815e617769d6f36632a7510a703c85fd5f5f90559c8ffa683ce2503a07fe4b2086e36e4a30d4efbe7cd2ae8a3509c1584b7ba7d502e1d1874f2e9330f0279280c7b3f7a85a79cceb46d6103373581ded1d3b8ed7871625babba8efef15d0a01bc223f0b30c34eb6ba423fa96688e075b104f055e581f11853591dc79fa8642e084605a20232fcb2e9c9526071c291bb9677f91871e5040c494e40febf4fab5931e560d979e1a0769cbe8fc46971d29d73499a2b06e9e579157d9ba56522d5bd606df6d07025687fbfa496727dcccd630304b5e83b7ee21c6ff8be862850d26bc72d8f52169243f27d02c6d02b36df79ae7d8ffd10eaf4937d08f62385fb8aab17a269f2bd68018550960ea3f0831c2d7f351856ae26ac505d10f92638e63ee0998294de30c887761a7e7e077f6984ca1302ebee5d566dd509be5850561cdf3f6c70a8e9c5e986f98bf09ad54ce09b8670353ff96111f9330b6268aa435ae187b566b2d4b12e11ac4122dc3d46197d1e294e873464a223782daaf064ce69bb187747db88c8f9e955c0e04ad4d476e048c4b323f146952280d76f00b22ae665ba0076b922ac343420e6be6a09b4cb0ecf9cd739a7ca568b2217ff63a985fde366d698c4953f55df940cbf6d007b0d3d9fd213215832154047798dbcd6d2465915c84122093d70c3bce0082a2180903114e9304a0f3da1ebedda04695b4ba40bf0cde2bd3b04a7a387e0fe49c162fc32e564dbdf37ebeeb152591820a82155c7405a8bb25e6a5c0c4d267ac30aa0ba812cc5b7d4033631e1a2973f78278508c6fe9c55bc0e01268729bb5842bdb09b1b72804dd46dfef47372c116a27513755ff02b06992b9787c50b9076c04be98f2063936b539769e02e46112ce2557b1e60efcfa74878f2da883389f296f6a30f1a62e7ce932b54f09138ef9650a30c0724b3a78936cb4e3d7612b326ebdaa7f2495cea8d60ae14a380765e35ff6da8acdf2784e32102ab6895da4671457b68289dbd8896fa6000882f3c9b795326bef3d1ba1648545938985b26177ae0de6ceb5a4a3fa78835aa7f57210bff8b3175a41e32cc885b59cc0958c752c5aa79489f413296f8e5bf527a6c2abac4411dce352687bd38112ba2fbe25f1a9c4e5230fb32a05b412e9c775a60f7d96cbbdb4cc9b7cc272662b9f572b620221e2710893faff8eef144f6c70680b6dfbef7d95f7665ca51f54dd11ceeb4458aca6b923066b159803c6fd09de7b1ca7eea5dbe01e39c4822d52322496ea632e6f7ea39a43832d34ccdbb3ab12c153a455673739884b051b51945b38b83cf2c81057bf3e938d211fc334d63757c7e5ba3764fa04f3f10739972edd7365bbfbac50bb6866612002e2d9253601f81ec2634399be3c480a633ce1e637df93f8eab2b1c0f72aec5542cf29ea59fa21c22451a24a1e2ca214250def995f15d9efdd6a1b73ab4c1feca14755b6f801e785317f184fc5a50d25aaf20294f61b85db714dc4cad5d167322bac1a02765b122936b0dae0b516aa6d446432adea8a7207697f9cf8614b91f82b2be92adc90b1551f75d422e0c04626a6eb2aa375b32d1a2a71fe2427e0e99b84bb99c0df26c7ea63ef080c1f424e39180a3a687926dc1851a07eed2df9b9934d06ab73adc86ae6ac60bc90a75525c226349b570270ee586e0379a6e814ef87a8f1c4d2a0da68c98eabb5dc7e0b0805fc1475505a171d34a33f804862c5a7069bff508babeaf77309e47503b377044d36f632ff01a6f1db348589dd534e27fc30b0a7197fea2cc80b1e430ababc74bd994fedb708d43f1d55d5d7ef6cce4cd90e822ad67ce58013aba53af89265f5305ec59a042c6c902cc980694b1c79b09e786c0bf6c6c6b102eccdd1b2a12009b369e5499fff1399f52feff4320630bbb2107b7bacba79e4cb67276a636dd35319c0c1b9a6e7a1d3880c0b9f0980edcfb345725fc405bcf55218078aad994c1c888fe9e575016602c09a187b9f8e065dae7a9e8bf1063e09c0903ddba9ea13906246ba5770e7dac4524994890fe071e60e902dd706e005dd6448b986028dbe27d3e28985985ffc6e9ade6777d1e1b7f8c45915232b81a351fe23d9761b3a75f2a8ea7335a76097ff41094240023ac1eb0c057251fb5560386ff6385b2781b2f9ac5e4c45c52106e59420fefd01bbfe57d72cdb75439e1406b7cca2cc98af1a57879568368818ac59d9844b9577d13c663d3ec22f936c74753a669dd30bca789d2912fd17fcdb7d3f12e5dfa8bd7e482cc79bee5177c9a7810cde2f4b8b0f397a700bfedea25a11f575d1bde6e6470c73ec55b47a0626a4c559b6c1157221c44fe0348c199ac579d06b477f0210ba80c8250d8e0cb9877ea2549236a42adbe51bee09912708c81b8ef6022a147602306da07ce1797df8aba1bff76b00674c70cde44e3d528c71a67f4f2e485931395d2560a1e95debaeee393709cfeac069aee7d993a4bca481bf6ac260c18e76cb8af0f3fd97042ac327ee9ad40a0339024e98feab6c1ae76cd8f57c2dbae23e7d6638a577559d3eb5d03a95c878c5f6637d2ab0b7cdfe80892056f8f54cef8c2ad721889692e9500d76c99faf2e8f654580d6954dd1e090019f91ac9099c5d5fa7f738a3aa3df6bf8ad673a8c92d08e3647059fd5883821200d15bbc37adacca9833efd6f649d5e18bdc201580dd37c0d755941da6f15fbe17d5851a5ec57bde9c5ed857963659936dcb0d2499e1e8c229e31059c3a78f84088001888adc5c5da770c8274d24f089585e390b98ac3aa9bdbfa2696fa0d7f3a5b0f72edd1ae57086d765695489c5b716da6dd8b685a075e73f11675412cdf3109ed99140fc5a478c9aade79f169b5c0bde3981771da8e484f3020de28d8593c5e5fcb33edbd363f66dd02347a0da65c4dc5b3e2e1cda8d281773b24e2692aa99dfce3dd59a93fa89b7137eb2fc8588068bcc8fd0f2cf5c596cdc6f95edac6da6c5cdd83b5a3920f7fd3dff053281bd0d9d6dea0fdf77aced9a451de11a36ed60db602096c2acd81fc505baa8ca78cac378a90f345f35a3d4917bf6c1da46f608b2c500a9597d5fafdf0bde282321b86662c0c034d24524ed6a5877b179c8c756089c8fc4f93154375fedbbf54e8c5d6c8c5b2ba50d02a726c363113a6a83182c5d1976ac125cd2abe51261e83fae865222489bc5b63a5e443dd956eb8194d42c4276279be076c7c0e445fecc8e393731ea3d37f001229a201c8bfff114aeb419b373706cd904bcb64dfa97f67622dadc51546b4f91d6061e62b998c901f9ba06deb4d647829581b2d91d32364955a38f6df1e74cb108b66beac2e9bcbeea6e072c7b7e5978f7c25766da60bbb194421cb3c19273a1e4327bee024d42e079f3e341e9a0126ad7ac9ef480b53be2b9d4e27997018e818df85aeb9b8ac6815ee6c64bb0b7fbb5b3cc84a791a83c2e7d700878c0889e96c87fb2059bdcd30ccce334a235772056d355c9419a95fceed085ff725ab45095ef5fba2e1a2bfa20c6a7b1bed8fe07fb276dec3fe24a041b2f8ecdc2ea49bb4e48b11d71a4ccb4d66daa2f281143aa0a306a792764846b3c7e2f1d4c2884a2b3b9b00f38f1e4b1395bdcadcfbe8f1525ad626a5433133426d8e31aa42a5efa37b35fb893012317214d61b353a5af6f8ad828762bc17790cc611a47c3f8c3f6ae4e7611bece2ad06a49e91297f4cf71375fa7f1874d12f244732d4cc7707fe42b8968f6d5bbdc5fa70ce856c283cbfd2c25c612b2c76eacea1c3e4308b7bf751d8f78d179ed9be1bf7ee242d1290bb643a8eba1c316ec5d1128c19a1b5f298867ad2c3ee1e64c67bed7e233f1ca57790794899067e528b085a0f71a5372b7b75dea1efa4932c896b9130a07817f603d4fa4ee1f639d1c460c573117568687a28cc34e111494a27a62a538655addfa8d7faf8d121431d1c9b9f11fff83ea4d85e6d842fd67cdb8600bee5affea3150e481f5d91cea55d0786a4dce41dc560211708fa45d750decc90eb381355bd1eec8b074bceeb324bb44fa936e11ef6349006757393fbb466f0b03ffd04a57222b29d738e55da39961fbeb232f6a8a8b36b0e808c919e51bc2a76c7de02469d5d76b83f4ff75761ac2ab47e18fa738952e1fa46789cc48f24d64f68928387ed564c83a7f43c45c7aea5b5bcf43552eaef13570206f5cbbbd16bb31c1255ba913e4450e6ebc6b61d6e055bea236e816c51814c6afe369a7a995dfac87e3ef86e7317516fe3c9639454debc0553d330cd0c6349115b09a8702987e6f06e9af9b9981e570c4339abe6dbb727702bc971c63fdbd0f035862db7d2f3bbff647033f8971d753d4824f8c32b97403b176ed10d1fb5f6576c68ac0386efeee52e846628325e64b576812d611410c9f81fcb9665a7da42353dbe2f1daf2c8fa3fb725eff2abfc057e4297825f9b7765407611cb5447b1d9b3f498456805ad7959bbd8784c7de9c80cbe3e2fc838a28df0a3901f5bf494213d457fea310fbd026a8b3b237010e65a5dc66b292e235993ef6af2926140315a8bec8036a693bb8479cf3ae1bcca5471caf6d4d8e4649459a9450829143f395ff285f57cfdc07b1cfc0ca32ad6cbffe9a04dec79f99c8579aaa2a8a52689187aa62b4b79dc8484f9675d403795eba35815241389b157bf3c916a9f46315d3394babb64365452ebdea64996260831699f277409e7c6a5056a11ce296d9172c66876f48cb2fce6eae01d36dc1be91915ad1fc77c2ea5be600c7bf21448cdac808b3f651b9817b0caf77fc78b37892aa2b3311a5b1ae64f3a59d5453eb2ceb33bd71e88e768a7a93c14f58dcb6825d8696cd93dd09b80aa91c8c0ec2f165b2d3f0281fcfa9dfbce19afa4be51b515360823f2fe7cdf12c368d09f3b704f38f0a05b4fbf5f10b18ae4eccc689d2b4963ca2aa955c8e3cf288184690a862797e8b51e6a7f51a38f54cd57c34333d4d63c8b973d330af5bbe2e1e3d6ff02179426581270124d0e6cbd3a6455d5ad22fe69574828d88d160e305210c11d8f127e37ec8a87b5007ac59fbd00f53b65aeef73bdd159b080c2041151b01ef08d8d4d63dc91c8bea7ff6c996b1161fe8505523373ef569db79c726ccf65e1f1f2aed921e1eb7e393f9bcad605d01cd0051fac09d78f04884a5fd03b5aa4873c0c2c32d6ab7a31a9909449e6b47f994151f30430cd8cbc42b79477724e8b17fbd20bf34463b12418e27afd0be6ced953d4e54902c85ca49238723aea2073182b7dd870d615b9f8f8a46e29f00dc5eb940be67c620ba43537e46db852de89c38529ff383d99828edb4f6f70ba3aa7a5100966e7d543e8124b2884fde6d850fba86086859ad4d0487038e0e53d3d33c2803d4fa3f26f851d2d3dce92caecb6fb04abbb24e86aeae3aee1bf2b693c94a4ac6aab25718c9dac189139706120c5d8f715fa93580b58bc29c07a748d27dcdcf5786f0758512b0e1da626076ed2b4fd2e37f3c69b0eaa3fe6013620fdfff0729680b821398488bb79cfa962a4763df2efcdf01a6187045b9fb378598985b900ec1e918c58df492cdd8c1527f7a6058a31d0510fa6f4077ef9f338696fb9a4f40e67d4195195ccc56c0b0cd39a2b8ff5da084f3532b1fe352273827926124ff2c54d26f11f82ec4ab2b17f014e62ffc411ace42521e5a8555dd6f8327bf2810f5ef83036c006bd8703c4a1b437e75bf32d2a4f53e445b48be76872fc2ca203641898d560d6c99a9461f0a34c73c59670e530a8370a069c79ba240b5664d02f8389d9b10fe5617a56e0e6abe54e228dafbbf445d7081b40f60c54dc79f18d074f9c6edc0ccfa6e585758cd33843284dc55e898f4a9e1b4d2d0633a43e1288b85270bad1c61144441f5d429d1cbea509732243068c74e01e9c9b2baa1381f0b34dda025f304767525130123e2ea03035e17ea3d6332a1722f05707605152273c1a26210d7d664fa040648b7e37fb9bcf059ef0c336370590f4a115a18763c846d1a4ab026702bcf6691c4f4b956cd20d46e61bc79eefdad7b4843b96583118d7cc1d900a8f9d3889b446227d832147264619a3e2bbb1d04fac5d973cc19452c4aaa33ba880139770a0b52cc6175451968c06d1ceac6ff3f221e8b37e4596cd91fad28b76d201cd25ea7a77dfd54eb2023cb9ddbd975383dc29748e9ae6186186800c181179e34165e47c1fb8dd438d03baeeef066114c912fea7a0e2919783a862946120f544d2c0df8ada72bd2d7ee52d27b7111dcf7f92338affa76d4b716855fbac0915c9e155b2e433c9bb62e094c9c755fece374b2bd24bd67f139a727027a89ef33b96dbf38d031660bd2a29ab7867f9f6b60ffd4624af332149ffbcfa57c03be4e41f69dd781cce15ae1ac2830ff955611e10800925cc33932eb45f27d81f7f1e5eb73431d7864e265550c06996f45233434125247030b4d91587e051ad5dc562cb1fd5cc7ccf0837faafc5d32d2f9a24bfc7af487a6ddc64b5d8ec185f1c62ffe18c1122ca0cd84e40b20deb682d4e7f07dffcf8fce0af90a0623a31eb5cabf10c268d9a545eaf46c62be1843dc5b5ae2668b1d0b0ab19869cb31a25d89586e70fb0145e80929d43eedf3fe2f481c19db9d922d0dd003d41e367cf3a24c634afc8f55de446e8e4dbbc4a57f18198f497d3b060d1ab400c25a67b2f4b901969e7fcf7f187ed1e14b860acbacab53173d0e0404ed823d30e8cb5f983290fbd1df204384195c5ef83eec73899bbdce7b6b73659f17d0052b23e4391bebd29a4ade9d0cde559dfce1e642f49cb861a34a586f0ee8e687f393263d85a4de74c559bcd06df79e176b6f1cc47098000ba85f10d494a4811f910109c12d1b72e1591ba1f7d37e7f56c702bc2d83646643dee259c753a54bfb0879ea14ad29cddb00dc5d810c2813ffd2bcea9fefe480f02fb98cfc0a8b78fc60022987b60f8caf4e0183c54f035fab644d18913b73acb0801ef1ae34f67d6a28e6631492166bcd83dfea8fcc1d617ae10176610c6409d495f2acad51a4339594bf862388e2c707c482327ab70fb514f020e8bf3e81b49a491ec5ef74fa63138ccbce879a0b9550db8a3d97371fac4f486019769c416c9b539d4b99400c8db7d1a9a95b401654e111091465e4d90af9b1153695fad570cedff3c36f32a9d079311723b629aa567e8ec88a43ffbcd6c57404cb95f8ead01c4d4197e6915d3cdb563af24ea16beb2b9c7b9b91219b0cd8d806661297b8d43ca0627e9bdb877fc9daeae189f7f8efb399bdfbce60e1861277d9d432f845eabf072a3bd47429904f1c6628426f0a58a47b5c3b67e8d5aa79970522814a171f340809d4f0acd11fd83002b4123713a0fb5ad446b95a04bbaa31ab26f39c30a044b333433faed994aa466b3659b1cae704ce2858d4a5c9e4ce3983a65fa857468d5888f8f3d446b02c5a218661f1fb0f5f71d8eb9eb8309fb97ba3f54942a5082afb3c3fd30d3b14ebae8e38f13ea14c08f372e243e05f1dc36afbaa3fdea5a4baef12f3a29a3ba0677a58da1b8551e6a7a254f8336fb9395627fd2a7b093483cabeb8283caed306124d6217acba94dc4be45ac75639eb788c00716de8ae568066b701606850dab97939d5520e93679748096f9f0dba5439da7c7b51520731afff363d3aaf49001fdb0ce46d899d7ef60bd3b1a84706902161dbc367f6bb1e71207255a04886c8e5d9c1cfceebbf0c5c5149ba03ba969309f69dcda725bb5d5103b91193ca6c68fe905df6e6a66b6aaf4bdd3b4889e6267de8abc8b4731d99d00e4fac98ab528a9e27433ead11446b155408a2e6ba372f44ba90ab862b086d826bded4c1b4a80e371487686667fafb808312933d967781c2f6b09ed0156a384d8fec986fcec55f79cf1f0c85657ddfe5c8afe4b62e999e8e5555039a7936d7cd7aaa359b37e4b3b46a85ad4dcef151105a7b15c0265222ad6e21793497249349af39a1face39f3afb62ca6c3199bfb25bb5098016dfa8b04b38b589eb944064f46b3923ac1db706597a237a8c699f1682f202d3bd8bfa17769879e808d047a86d088d4e63bae45c07f4b0b54eaf721aa6b9ccee3bc8652f9b649ae777a883719a14774be941843ec6d88d4e346d9973da92d442891afa15f814964f6bfd37f7089840f5410e17892839f85b70d5d64f8ec60cbd67331a66d2119903b73c3f6b78a8341865a7df508a7580cc9f44cc2eb275c3a9e102a08dab5cd9477b8e07f4889c906282a65e60f43769d9ca9bdb6619c8284a54d0028988e4e60b7c271292e49470a9952d75c54b7000b949381e5ac8a3ae1677df1bbfbe15120b24bda5af9532896ee143597bd199ca17d3fdabd122aa60105f4c58121af233b36879dbcd8ad1b882c6aef0afc834ef7f039b8cf9f03cb25064e43f94a14de2faeb07e2294f083fb253e5d7d68aa55d01acd40054d222713928182b71ff2cefd053eb61ab3712ae02282e6ca2ba122c223a55215a5f874b0ac5ca5e3479daa1371936d537b71e89f7a7741605d03a7a5d6f4fee53a1644443367e602e20ca3c95451896dbf77e685ffd9fcf3bb656037e21a2a03999282198906bdb021904384b7f121d9eb61ae5e1b9c499dd7a3b291e59b80a7656c0201d934299966b1820222288b9702463dc563c2c779dd315c654c1531eaef517bc4361207891ee93ccca1b5f43367aae5a65c33bb8787f6ef5fb3c57636b818e3537e8ff3fa431a4ef6bebe326e0b82871b5fd76cb3a9fd6ce7fb2c5a1ebf388f2d6423015ff8733edbf2601ca6a4f8f48a3fa3c4913f22ffea7a3b7925d4884062df7b41f6b4601adbd8bdca5d626c948339f31d4004cd59aae5fe9ff39165c611b972e67cb14701a2b045f0bcd695fd2915f2ce4966ecc2011d1ce76e2c1aa510297899f9f974da927281c5df423b8c47feb5c8d7a8e11a9d5272636b25c756cef78a5446db3fcbc68505a2ae76f6a216ec0a870866f7b8239f2233b30207416ba21637d9a23a4039d0f3104272caad5bd0015a4fd9306fdeab97f46f4c8dda4a8e62d702e61df95076725404fb5fee47c6f1bf9cc9f6dc919d88dabd5a8b37b4ceeca6d8ae4c54bef0698a0b30aeb609bff9e9cc42b3246cf45ba0510a923f55ea9f773bafcb4fee9fe0ffceff0973d8ed718ab1d9ba261a913ef16e68ad774569a2d9692ef86f26d8acfc21f8e7af1624bfaed76a3ee3696aef4f95957eccd3405e6f890d4ffc91d583aee7bd4997ed20ceab7794adc73bc044be12edd6a02d10450d072eaf36b964d3fa093897369785c402b3bb379504d3e4dbf4d793b41b063854935f275f5fc78a52061ecb2ff6480b03f4b734bf78d516cfaea88905d7c69bbc1e5d5dd1746af939a8ff1cd82bb95c95d1a4b7e788edd61985073673a70eb633f4ce506ebbbd0fd8c66b4a66a7354e3e595df070328c57199bd99be143f99d85077e3c9fda58def7d32b7fada72192570d1a7d95fd8f23eeb4fc22bcda6f7408160eaba31a1a2ee46226e2edec4babceadeabcc992503bfa284a66161f72a9fc7a8e100230924c2a1b2a6f8d96d35640ce2f21f6adc3367a710f0104e4d52f947af014bf90370f07b7522985538ee9163b4a839cc3b6fec03076be95da9bd50b8c961617f70251f38d05ac9393cc39e3234986baefd813986f515a4f5e88e0ccfd89becb7bcea8e68078260fd6457de6c5adba29d56250977be406670e1a6b86aa0553139e44de0d51c6daffb37f2dd6dd5e478aae68213bfd52ee9fa44a4d13c29cbae9325926d3046a150d952151860e496882f469f9cd6da33f4e26b1c7e053ca2173e2df76fed3f52084a31c19f0107024bf86e0f649391b68403c2f025ee8e437f39b0e48d01cf67cf23e80e34eceafda92df8aa2a6b08fcf8e04c7d924375985b5b004a4b598e0a7acc3e8ff04a3c51b3323e95b9ffef743c65dd9235080b1fe241d9900354711538845b7ae05ce84925a6965d474aa0b1b299360f74f5a2b64e8e517d3c7aa286df6e5108240e5a21f8abbdb4bd64286b461408b3e267618427b2ae8eb98a1b0f59960583706a11a2b92d0cbf21e1968f2b08aa32761b857744d53fe08f537d14b90d2dce61008c8c01a47dc459b438c932f498ec0aca2f4b2cd6b1ce9aa1e13ce119ba3595b0316d22d11d2274effa0a9362de3ff0ade66632d584e7128fcae5d14a04203b2a559017b3fff9d8224fd0985f0b4f8234586d390875c341eca9faf85b71ae0d6595aa2a15171cf2631db3d95a34db0bc526052fbe48e8c76d9718c72c435031723e98dae687ee6c672cbdebe53fb069fac14156a74752a14b71a814c45bb53b15aafd43d60b1cd754692f2467f82d3c40a205b0e1f4f65604121ff1475ee4c58fe5949d8a013d57b120a0592bb7a4956fc7c0eb4a0f9c6c8b247a53ceefa904104c7979f77c9d193dffffe8eb70a330b210526fdf5ee7471504349e57144a240bf644bbe14cf94c6d258491c5a6b267ef0a56552a18c704c91aec9d3b88141e071715f151a84559f5d67e67ae221c5207bdee52b45701569737e3233d5f3b2753ce5ddf0bad085c05489a313e6e2c0a0de3e05be207cbbe7126289a61069514308bd7ac6689257436426ebe07150199c6417bf4399bccf8dcb0052483ad56354e539fe7127e998bbad0b9377bf57b96e7fb780f622d539130585f78eb4944c7ba453eb63de75737c441d0e99a771cc91237ba98f3ce736ea8cdbcf7510d6eec901f63f7b6d77da1a6f5c73908bfce91217aac818c1600d6d8b23793573e8f88f80147a79d540f688bfbafc4080455d00656d89317b4caa5c3b5fa5e0202a76f887d327e6e7198651f60c3d3d9fdba1bd07cd36ef326cf5de3a621c49c2759207375e4eeeadb913dcfe3750ff7ccf2fee096658880c77d93829887e55c5b1df5b7f917a1b7f831d0230e1d2ea9b9b15b68a93cadd928a419f226edf311d484e2478a418e72b50648c83f114435807564d37a8b468a23289bab229def3cb01831a0e02ff9f4247ca8e645a00a2cdb6227c733117e60456724aa220ff0b918b1a34f9eff6ae843528bc968121f07c016580aab9d06a933140c2211ba3d3313e86adbb7e52a6328859c4cb1ab39c4d5202ea94944ee65e100edc80dc9833b7f99559aa384aecab98b68b9110707018eeeceb00dda6c70728964b7dd3b08d2a9ee5adf511a6823fbbae8323eceb8d0203d601aa1119be41027f28e599d08d78bf0bc92f284a0953662054e817cf13b6d309d77af59143f82fad93030e8acb3ba57887002f1f02e62ee2f353658c71b720f8c51b4a8678a83936951329a31d7ddc3344334d1b8d503c262864a930c80bdf0f93703de2749c056b066b17fc515f17c0c8d586d2d1aad8cf54c6d8b2d7d991b5480e4cdb8849942e270127a2f10389a8286356272eab595879425a6be7cbe77cf29014353fb530353e62234fc4b37014bcf078af9893a776a6cf3841f9977e1fba70cdf494d5ee64f923d77195a434a676b2b3acd95e921ea38bcde03e8ca439bf6487f29e1af43963f00243f089ecd7e19314fa210417773a01dd9e8d70fd6e3ce9cb78ade33674e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
