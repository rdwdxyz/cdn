<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c947538e91b30c4b99e0a09398924053a1abf5c4ccd715d6a52a2ecded4be632d7710d03484fe0bfeeef4f8c3eab4c57fecdf1af46d86e7493764794431dd670a6b0520cadaf504232c65b74c9446d9c103c40d1f44ac0ed885464324733f92a7bab4019e1fa82d4f047112c9cd392100aea47f1275a722bec997a459c096b8e884444716d28b61e2151fc218f0d038cf6988120534d7b243413089f69aa6a436704008a2c707008ae99b1dd9f6250e5d66b2a2d892ccbd6706a4944556be60b4a7a9ca3d478c794d06c8b4258ea6bb4a542eb81c6dfb6f3db69a5bef4870d7c1ad37b748df618ccf7cc99a620befefe96a32a3283c774ab748cc38e4abd71e148494f0e6ad490a849592dff2ab3876029487bbb4fdedbd640dd0251898a83bbd02cdac5e15b0499c23821370ff4d57113ec946a928be86f2a399a5eff55e311f20ff78de1498cdda2be3986107b7578c2a51b19f83d0b6403739a76848dd0989696fa0b8fe359f67ec89cf0dc4b23d6fe7805d59f3e63433321fbe2c1a40ebfdcf8ccb851bd66b14cb226a4f51238820b7436a3bf362f1799d8705a9f4d1454802aff60fd303bd8377ea037de8414d9f5704d84a23022cab49e18fc15fa55bb133456c924b8b459cd756d9b401a89f79044abb95b4d6a0c734d26fae49905259c8e7022573f3f4dc5c111c0c591978944cb98c48fca4787f9df42ea93b74e71ed6eec1a244e45cb2351ef219e5178a36b52af9d0b7f69f974ba7cd2d235ed8c632368f833224c4b6a26873c94c83f38a1e05d403f1186aae1549247cec6206abe37ae1167b2aed3c82b8cf68826397fa3cdfe3486a1146aa4e44c2c4ed431a2ef1adf6cbdf637cd57e6c2e1d327a4dde48003d75eb86c600322a35fee743bdde1b9ffd4ad30f246215b66b196d82b09a64658637cfea0aa76f6861da980c93f5e47b1328f7dfa124ec4bcf1380e7a1dd73471b1b62613ff71f7a2dbd452a101665dd4817f756ccbbc55942827fbf5204507f6867a20dc664038795b576f27ea501c14b9f070afa740c267d05a6e744e65fc2a985f819e740344262fffbe3bfcd82e23c21b5ed285d1fd309aa76971959e0a2e46d85a390e53223c8b6c04920880a1db95377d47d47ecedf466e6fb74ab9631aa1c639432a69663048fa513226f0481913529bcdecd2eef09695fe97f58b83026bd415c063434a1c6db8a48c7e5132e0a63a3814c3a9fb5e45af4eb77c82c889500ee7f1f7079ebf8924143e78497919c541cac109dd609d70870a5d9c8eeb38f64ccf086cd834a734d326c246cd83b845d381f7f41e79088bf64c84ce4e314c8d384da4a883363064f0026eebf301cd25ea5b4ae7c5012a8d78d8568e8e330088476dd057a4e872b9361361d5325ee0a37ad976228375a7a6fadab8a3441cf72309dd9a471679f5097f638848d19e029e607e0618039ff8d9722eae282f991f82dd3e9f0ca77ab9a44fbaad4ef3154985f0132f1e79ad51e977e531ec567306d261b2d0f0686c3fb5715e336db757c07b8314e27b001f98b5e883b7de29d0ecbdb1f221ba4fe8b4585702db7d077e17e6128819ee2a2b6fafe90297b8ad10e8a4e2d18a1d61e4f50fe70d9c44e6f3a049f44fd173c6a1e4bb99fa040f44ee5cdee26adcb39945437e2fa3a152575e271e61ab1d5cb8e670b10a2aa15680ef4a42a9ce91b6288fbba8bfb65a670133b5503fefc3a339c50fbc0c003cfdcdf71e05c9139d51614a2187606ca3ee740cf59f9569ba99093c8230f45719e2e032bf4ea8ecb4fb33fad7a6bc974b41f3b972032c4afceafb97047cfa69ef1a7c6098e9736ce505a66bc66715ce61cb83872f9a9be8d7ae089bd3abfe737cef23a00c31fad3ba8f508ed512d89f4537c52ec6adea42c1d77a1d30311f66ff01376726ca5e624103427712a3d5525898ec3d6185d7c0ebc63480385cf71d9c76536a072572f7967239f3dfa9a9e6eb55b9f9da7026e3534b1882473faa2421d621b13d6ec385b951072c26a54564ac01bef9295932ab4b787992df082ec586a9a56e86fd9374075f8439727b6e2c1c38153b022a51edd6b1b6d9cfd168c541c9595aea3b1474d759441bb8a69b9fa845b1f372a72d5dd3bd9bb85a8de0d4f15d3f57b3ae2387e50e7d6876a082aae3497ea5a272d26beff06f1a7407b16f96b48484ff328c21f75dd02a613b0cb989fd1a4d8a8ba803ac919d89b5a4f9b63a2c6bafdec6d5d532357407d485bd694522140e20e00b83c3c62e09af9c9ba3a316ad2639cd69208191fb55d309c46c950d1a2b69a067f98f82a4c99c5ae35be468187c527666284e3c4010da451047c3e23e96c46b6f707f740e410cbcc843ca00daf9df4229c475fb41fe178960c091968b9d5e1a1ad5089036113de4d15904a77ef33f58a0b0dafff0028b2fe0b6d392b1e3ad4991d16dc592fabf808d186f11d83a084d99e0b64c89dd9476bdab0784a955e42ef2893f2118ac30cb17cc584a046e36c4de71acdc1cd5fc3d474598458fc3cf965f95ed6c372961ef30265078ba39e1c054ba6b9f0983150b1815a033c21d8fb0f3c9f471bd634a7294ba3c0e7aaf9dbd0b5fa5531df9c0adc80db5f25b5fec887bcf1644252a117913bdf8d3703955ccf677c15ac435e1fcddc8d44fd11d2eebb69ee35b769492524cba960a9465a6fe743ad1bf578d1eb52d94587e410c509e78efe9933a29f298772e3e7d215e3250e98c2da207a0194fe88d9f61430276ce88aa4634711dfe371b7dacc3b01509a8c67a8f8880f3e8d2093384ee9fa8ea97e0754a253e4ce32307e5f997f86875e0f3603c851388fc4990c1a9cbca27fe6651f61a5fa7100a12ae05c91d42419facb7235fd77d2b50014ca03484d987670301cf90aad2dd58fe2cc3ea465674d5ee8d64f231811092152129a8fe6c5ddd2d6da89f5ff41173254eacd666fe03570e3fffea78173e956922589c5bb5487457b75d6f9c3b5b8721a9fc641413347abc08d293e802e58971c1d1ca474bdc39a7d09b701e23963d6e4a6e180ac2eebd55985fde7eb7dfcb77e5adc53356374a10d4e4fab573c382c90c4806870a5ab3bc5050aefced7612eb226ba7be3f4d628af985f430d35f936025c63c39cc3f7a06810a4d16a6d915ab5ebc2f57e3682df7eaec7d3c1239021090c9095de67c839a841eff21c1b5f44e00351d0b714f99ed9085de18b32a1dbc089043cada7540c702c2ea6e5b4025a8a9636d65724b5dc7c919599e8ebfe6b3a0d589f42116b1c8e4d471dff95dad4996a5619b245e887c433f927d939a802b3a69b4bc13613fbe7c0166adba0eec7b3164a7b71125ed9b1d87a0a36ae64fe58e436ba7575637c5c460b45de1f84ab2666418083d91c25d2f0d1fa8147fffa96acbf6f559a98546621215b6cf40b73871cf7835bedcb0973578c8860fd179df08c5de8c0c92d9a19d3dd632d5e80cbdfaff6a09ee599cacedc8a61039da832acc9ecf0dd3821cb34c5efae05fbb8cad402fe433ad864bcf0eb65143b48431b0592122a5a16e6427125a8cd706c037a89e6a7a6e2ddc3f1e39bd7e9ec8314e218b0d9282a847435d6ae54beb2743841ef63ae047b01770b2e01991845a7f08092c76669bf7d9fe5b3e95a24e852ea5cde0a5f2ed72584a75c648da19b7d66504058b143a34deefaad16375a047f3bf622b0696b3689ddefc5cced9ca6677a1f8278e829522fc3e53b895a742eda1fe2a0e3a311766c006a746f72b545065fb13abde044448d75d17b7dea9008be16189da513f075af9f0c2af32a8abc06a2ff9b43a450773803000854bb36cdefadd649ada3fa0b8874f7b1a22682999cfd885c404b25fa0f6803edaa054c191c8e2f76d12dd6df4f739340f78e6f459d607491d793c091fed13b1703a17192196cabd19ff05df145d20b34687fa6ff3af6da12bb153a0ed9d97e5ca602db92f007bca53fc9ad38a849b029603dc1b80a7bc4f1b62b05466a99a71cadce3dc7cc1f6abaf5cdec71115b897d4b0ee8db83948a403b60fd59c99c01e38c77160496aefcb679bf509232472326f00b5e5e2a1caedc1e7d94bb5290e9b9b11efcb7b94a2bbc495623ae86f55f8c583a1cab3ced22e683e59679013053060cf29760e5f5ef29a19c424bafa97e4deb728ed396d65e0efa132b1e8bdcf4553e5a75cd4be703693269c4f47153bc3d8f4f59b1b2c47ff79abbaa5d49fa894df4df7ff8e93e535b6e3c1fca6ca2b7a43e72f9a36729c3d0e40fe49e5cbd53d85fc3ce69b316293503631c80df49e8cabcc1bed999fc534d6c5329eb04954137c8f35e691d855e3ad7cfc1f7a2efaa4bc1a0153f8b2097b369534d7071e920ee3c9c3104d70602a90087de515c4d18d15d4d9c8473550629cd9bc0fd8cee43a3630741bc3e3b9ce4f75271bef62d0ee9da89945110ef660e1e1fc80d82a22d8db37f60a494c092b1b16ae285d88c2a3a2b57fd6c5df7e3b9c42fefbd671786fcb3ce43c6d1ae2793edc66d4ff3c28868534972414ce77dbaafc2b978cba704886c48f7a2cc54993b0de01befe213a115243de77a5efbb93f0d961bb84466337a0910900d6727444f33988f2515e619bcaa8e1dc9f7e9ed2659b2f7e116753079e6392a95341ac35431f124ca488fad536f9c568d85c308d228e47f7ed99d56c7bbffbbe3513272720b24f42f749d721cb4980027f6649e8327f7c6b1b13139a7835fa876d35ef359897ffa203c90d6e54a813f14cc7d24fad52d6f7be604a2404bcd65c7be69260f9e11568d38101ba358f1b97fbd606f9aa7c5857a1315a49bd6c58e5cd6d032f78aef1c3583f5213b71f3034ebee54be8c5277d654a373df27261470b5c925286f2a7bccd8bfdc625ae657751709113c9979764124ec19f12a2b77b299ac43634c07d718a84bda2f33fc9035bbef8ff9c74cb305341b2ef7a93cdb639baddb8e2f664a7b4c02d4f700d8fd5c9ef457d96cc7816c83e15cc2a66c51bc6608419f20dcaf6f989079b5e5fabb93f81bab99d861ce1e4a7266ae2ccdf56f1cfa91970c30bcbb35c860dac354d077663267ace309c162961a7ceae965b945398525b9e3857c9926c5ad1f20dd8aaea385a7e2b83ab536da306172a509e8ba157bf4a1a0ae4f5c6e13f52f444ff76aaaa1b12054543983e544b0df5e1dcb9b95bdbd43e7c1335c6ad1b05c14cc3180f6a64c6119855f205543383c701aee6a1ce5b69c2889239a4689f7180aebd40ecc581734563e6146b4a7a6ef6a16f804fd3dededad8c92e086aa00ca80d2a70e3f268c2d91ccebdaa256e4fe9d248f0d2347879ead022b23dba2b7ae1b01078ae08cfb98521071e4de5b3bc4912a1e8f0ed615991d362fd59e2f7d8c82daeced546ed3a1651929529d7fd7b579056a6a50d00d1e9d333c70ddc9d801d7e11491c6bb54e32306c9ce192e1870e3a465ac9f0d565ff96c9a24ac9fbc3ac30709055ffe4215c25ea3cf37b7a11ec26ad6b8c149483129ca577f1b07206c0ecaa805b5be8ea992575a4a224622f3016b052cba7394f3517ed90492b27a6611772485de7cd7aa9ee3ea89956f70f36137df8f744bedffec8eb18aaefa90c0eea4886eb0ad24c635575e91b56ebae65c0d083de6993f9246299186cb155c14fa195a01c26ccd9e0c0374cdf54f3c1147bf92d76967ab8766c556bc9fba4d79670424308d8813ce061df3974ba9ee0f6792faa4dbc3646f25e4cc8c8957bd497f98a8f8e4fa95456c79eb01432697c445a93745925b1ebfd5e543941e2e09c08952bafb70bcb007337053e94c2249c6e7edd8ce759a2a2a15babd32f69903cc1bf6ceb2156094206d4a73baeaf9afc5279e8ae2e860146dd1c7b36398ea16979a0a2158dc6da94659e92fd83d7e68e36c6a0eec0113d93c8cb8e86beeb18d5b452fa153d2ffba3b411db2edf5641b2e11e35314f7034a98c4f946478ee013c40bce85dfdb490fc253dd9d0450b1470bd089450a49d7cb382454b302e97deeb561b80fc6911eb489aa185d7fa3972d7f2c46b1c2f9b41f9397f7da5fc47615ac90f7d30be34c1e88d4e895ff52c8e48e56abb37900cb1c406e8f91b87d683c7a071417d055708583936d4d4bfd8a0e627772f0e23e3a4a2c849a9ce536ac0568159298e5908b73f658c6089a3db29694b3c84f17fdcc0702fb2257b4a0788bec50bac550fe3eed2131c5037a03ee1d86066bf7d78cccbae23f7ddba31c92f9c5b3953238795e25a331289f1bcb91bcd44c65f7c8fd35428a915db1d9003c9926a83fce378b855cc3b832a6ed238dc7911c75576914911a25ae8195293c3f19c614f9a92878f3124ab7d3a692497f0801b837b6f6766670402e99061d4bb765d7bb0324fdd634f60658a3236336679db28d33bddf163e51af21015f3722111e9005a1f10aa7881ff716c74a3a16059296e8c52c3a51659cf39c0efe3636a51d934a3b98e5603a60931b63cd8c2b020f3095fde72755d6c3c8295fa1718ee7781c000498c9b210bb5efae54f7166aac71543208af46816cd69096f8308117bb5096c4ea6e7a426cb61a0f97ad2986329b2ea6fe64df060d5024fb5a75fee6f0eb09154c0d2c369338bd13c96d7f37d32e2aa447e61d340f7e0e3bb4a19fd42cc003b6b01ff7e29df827a75a6cd447aad5cc4703112c8ddc09d0074b2e074a439b9209f784a679a1c79cbcb5a44cea3f126c0b4dafcfa729741e33cd275b36eebd496cd9cd54d0e2f32149ce1ae3e23f9852719b34c1140fc62c40cd7200c77893d3576d5cac5269be1df1d07786a930e73ba3b4d55b8cead1649d76e451f91d6771b671f74f7c28e082c64c25fa72e316f31b8eb582f54f8992b11cc8ff93ffadb3784503c2a07d496df38272789e6619cd31ccce5b6323993624e7b1a6dfc4efa9fd73fc8149a4fa5317a33b3b784f15813206dd22cf6204c930a213900648173608d41153f6c2f3074717b4a615fe1f0099496489239bf38a1370efa1066b4a7f8aa6ebb2db1173ee025f5577721523aa245b91c195413d044c303cbfe82787aad316802ab13e4aa3899c9135342029f18eb4e6867ebbaca03fc4cc4a80c78351e09145cebd2f05b1d96f7b9a02d3e45f6398e27032c8912ac14a011cd4bb08487e3efa0d0ce80d09b75e32ef4d8f47805e229f67801de665b4b268d75cbac72a4c4f9bc702583fd133d030a4f0f5f9a3280d9826dad759f3b4aeb46cc0ef87b169ff2fc046716321598cd4af67257b0e29c59af1616c4313e8793ca75a0f5c2c3211f0f81868f4ecc70da5ac677f23263cda211e22456c534c6a8a4b558463281fb11b6ae21b09ce9cf07932b02bb1947799c79af1d46fdc0402830a98528209e30260c8ca25993037f9bb95004d6fd791545de6afdce7acae45d24bb620662549ab908a85fa690e2fa5ab97ac0756a9734509a74b64516aab5291a4de4e1e3913dacda4dfd293d54def4a651e2f8ca5e1914e2b27894569cca81437e44198f74597d9d3bbfa4d14a90d65a0f24682145aab9f3d3960312c3ad7a3cfed7c7cd3a31e8bd212133ecdc3cd2f595325e2121a4a45bdd32b75536befecab92d20268ec698c05deb3e0765e11c69534a5e20e3e2436081e9ce80da2e2ee085a02c919eedc6b5754ba254d007498e17ad2bc2e75531cbb7f6c468af83e3dbaf759fc9415f00d53b5424b8468af2235f43a144d5446d96d9e67f30cfa332d30c078ad8f065e73e1e2f3b86804aa8c51d2d2a909a89c2eee43684a10e49c2b0d963dd010386d7934ce595713f7cb9a3c0ea5ebec6b1f8393f48bf8b6c3efcf05ca25b65d6d8d3f1114f774e3c86e7a00a2a3921691a5d56d92f13215958c048adcae47b695ffac8ea58535309ede9873d6f7ebfbe5af33db92e97f32412f2c134bccc288ff439592156644761445f67ff473f39fb13930aa134daf9196145fe9170b1651e1210cf367f3f27e444930398b89a5f14e98d8474433f7d7ed94ae3a5e0d97a257b9e0923820b86df604dd089c733fca4544ca813c1ef45e68faf94f54c2d16283f00d4f4b1ddce153389ae13b37cc3d0c3c44a75495ad51b72abc290bada68f7d1760a642a0a49c5f1d0f86c7398bca7503cda152de1522d7a506746e6bc3ef1df32c7c71c81f6ed332c25d7f6c41839484f0796e3c1f9f75fc392349d6140a13c355f58d7fe1ac257d08350ac8d3fde005c8c040a69b6d84199728fd9aa6114c03c3f3d7db0ad4d9ff17d2eb35cdae92b83ebea656424791ee63e4e641a81ca6e909fdb84e77463f10e3b6c6951d6f657ff4e5d5497e5dfc59f94a479a2bfb20c53c7051d2a165ec660c136d5bd36e91a642d67b991a45a8ab50cf789b40bb881b2522d1292fc1f73b4c51e4bbb635da5e65ba4f5e21eab5f5f28312cbd8b79dc305aca35a9d62e2f63d26edf63a55e8fdb03ae82b3e872227b1e110e1aa2bb5f79e12e34d4a98def59433234a5ff2de434775b98b75feab03f86dbc6493b4c947a78e6863eaad61eb0a626229dc7f81453bff3b9325d99080edb5cf18ec13af2c060bc1b1785deb23894cd33b87f68dd1d70c1a15143ac0a923967688df29abde56e32f1681a07cfad4e310dc6a2c9b1244a808dd30a2511264195d696b8a695959a70252deb5f4ce0d7b1786b91e85a8bdbc1ad9262c0780960435638714c7910c0bd7c6ca1857eaa610b00adad0a60483429b7e5837536495169cd7513e6896ee7253e09cb10c6080cc047c20335939b2b944f278c1b48eeb4cb43463a59f8030fa566b4517c28487ab7e1a7c547223a84824abddc75eb2eec3b427fe50e24eb059adc04c0fb5132efb8211294c5e16acfd2f71845b8b74d9eba4f6ac6c0c7892074f93abd52b027864ea4b0e101559fbe62dae371357b98736453f4c6c2247a0d28e4f5757038a99846a50bc27f589f71d113fe86290aa7cce5ed230795acbf4112a95f4ca3502d29ec5059378e4eeb6e3f35fd05fc3ddb5f5bf65ca0aceda9b53d7c4a3dfa28e2aa83e0ec8fa1aeae1aa992eed33381cb7632b4cff80e122bfb8bc5cea04688b4a4cff935da4212e69362362e457f055ff064726ca0f3866de6ffac1859c9743ef24112466021a75e3d123f16d14f4473db934ad9d6458af75acab83faa873398e7615f2cb66290b3d5a61ffe34193e90b057a0e2fdc98b560d166d181e61dedd7f1fbfd286438531297ba622840fa9b687af24de7212a7caca98a111729bfd70d53d2a011699357148777ecb1acea58ce9e2caa84a3bd75aeb7eeb68b5dc49be29db7194e1a5d5c512f959bb2a3547ed690e5aa26a316811ab5c4683f183a6621fe1f61373d573a03dbba8fe0b1f5ea15f87edb741e5416ea2190fd723691dc8df87004ab8b6280e3d599272da2efcab445723a2655c8c2ffb685b70b47184ac5e3b5f079a7a5e88b3b495a3eaa3efb6150ec32f217fb0f058537e27f412e67dc8fc502f00ef69fee5cf205b71af5f395a1ffea5b3745a8e9015e846cac10d6147e9ac8d5ff5d06bd8d5373764b8caa18a1930bf4e00f756b4168ad80ffd30b005f9598dd1acaf4a0d42f9cd948514a6f4e41981581bd255751318a9f369218f5e3adc8e7f33639ef636cc3ec6feba0ef40fcdeb176285d1390f713d9e63de2222b7357b1eee92d7106544521d371dc4a863c75f1a866a025cbc6c9ab299149ef341fa443ae6b2630d11d3e73a58486ba89b1c7a4eb36eb6f0b7a9513daebcb0b13167ec049be28e535a876545c187da041562039bdf937148e5093745044234a1fcb6ff793c7c9e88eb9a2e6b8510d2b7b6e821c5f060d4e413ab0aa917cfdc06af820c0160027e9bf86c54f5e35bf08b6e3975d8fa03c671f786118c44a7f54bb7a2142838d98590619839384c5bae50fa18e5f5d7440b2d14550e4d78996483811ec4ef399085d4637d9185be6b145bc07c4a7a67e61807e242359cabaf30ab763d6447da0743a0fed209ad4c5d90521dac95c1360780e743922315907cc39f231df0d62f01e7437a7a3aa18b36d5b7322718c81fee1888f027d2d1ff155e6a5777355c545b7524271f32a9c157a9ab5cdd2cf56d96a4ff859f148df92a918ea795f20fdc7f7b938173ac5cb445ae02000eff52beef58d6382f64e7c7bb4e242c67336236a8c575f590d287875a6dc6f4d6940aa9c5d2824c66926630bd54fc6d51bb507135d57099986f17da970febb80edb9ced1ed21003d9688bcec725a4866bd226a461bfc55e20bdc79be78d656d83e5bbcb135af62932d72545dada38733005c1d2816887911b8401fbcbaf28c71f5a3ff164641963a82edccedb4f92561e1f1533e116654a5092cb85df791b7b498d745631612c65f8665266c72e8bfdeea2deef3246c4f254d67d7688f9f5a2db4b717406620d8cd4a040dffe4a993ced0f8ab7f72f6ee7bb387372fa3c8904e66b33a1b6715190f5a17c321622cb2c3ea49a5cdd05adbe6c3899011f79496f1798dd3b8644343f5fc4e90630a3d756925c14d37010e4d1e9b0d7c5e18b852313c562b086f302012b422fad7e794f3e9ceb45dc423ec8bcc8571c3d266655b58ee313fdb6e2417e94bb3313155800e27789f6e97e82edd8f3b0ef04121197302f0820517eb7637f09bc91a3835a2bf2e201ef1f64ac89510b70844ecebfbc4189a33982e80a7c7b3ed052a6ce4dcc591e08ad20c733dbe6ce25f02195701fb434793723038a9d40bfb78035a55cd559d51eb8f696d2b5893311036926efadae4f25050c29c306d74af78bf5acf8a66d1ed2a383340eb65e293819146ea4e86aaa2fbf2bd02e0dbde633132c8c05804bfa7aa1d5b29bded63917661390913ee658451a53c489d48f1f45ff9137f91ed7d257baf310879dab2bd0d3294ea3040e69491b12aa5e48db97995ea503c4b65004e2509ad91b86c40088f82240a6b9171a1204ba095d4c6c77a9832239698a5395d6797343af4e7d91109fa6b67e248b7390c858a1d984dfad33646dd553e360f9475ccbe14ac76de4d0c7fa1ff9fd04ab59e7491921516407fe888a53cc4e9d3f3c295f601a416582427ad094dd1e8b11440f802faa7b4c842ed132e78f97b38879ce1b06a420b39951ad77195ea65db9901781ce32ccea811e42e1883784b98aa52a5f9da4a721ed944ad770528fd70e1ac6f290b47d199b36755b58b8a030a902d2f2211e8e37a93fd552eb970176348832c98d182e33b3e71f68febde21633f3ec54ad64f248d91153a0dcb866dd5ab984cbed49fa2ab49a826f5e486cf097178d1698138b8e78200d00ea4a23d7afa7183cf0f67332b28e5fdbf3b2f91076de54b50bb9bfa00a9f7a94fff9e3ec9e9e67c49c77099c2f166aab2f6fb303e52ebd536bd9e66a2a4e37d5dd9400e4d1cfe199dd6535f3852b98cc4bc3b9aefadcdf4c3dda4dd98587f2bc44996d009b26ca0c43835c2b6eed8873d8785917e58aa8f8437e41cad825771ded1315b451c9a17c7a226303f9fd43b9103a7476fbf2bb4baf40a716d1097debce91090ada9f6f277b9f09dcc76e5a399b37fa20063fd8f8bdfd736f8c0049ea89956017a992f2037ae17a07c8477e09a59f6a6ab2252bea641a1a2f24ffbcc52185fb76d5be9f9235d8debefd213ed412fde729cc3607784cf6c6f33f409590944e18abb2506c0896655f22da3c9d0548482d17d370d96a203a267a86e77cfa45b5a6ea7a875c083a0cc53388fd35be0ba496edef9aca66c379a163efd3388839f887d553d1e0044bb4c01eb742fcb6b2efbafda64ac24a8d156ba232e46c4a4b526bb4fcbfbb5a98c6131537a7e492242687517cc8271ddf914f6bda2affe60b4dcd345f0ce9bbb76a3498f0679c6562a0df38fe90209c0e1e30aa4e7948ba68d4a8f9b7a5ceef1d4921dd9717a2cea22c969627a746fac6e1e0c341b9ff977660e418fdc59783c65318dbc35809f69f652e01c987993671d1d4e36e5e485ef62fef6c46c18761cdb85ce398f4f93199b23b73b4bec12a7bce498efb36f0315f7d6034f878b1600513de30a79d5b6fa6c1d0fe23dd2a83ce4b5f6e52d40bcebeafae67d35624151bf19adab7bb681ffdad79d8dbaf6db36037d12c605f6f1261032574656c6a264fc12c845730edac6f040162e4375616c19b061a43cf9400761e731bcfe3afec04e4f3fcdb373570578f72eb4b576ff5872bedd0c735388ddf0938797bbcae076b67081056127fe4e7ee5535100ad9fde4e61f28c5b64873f4884926b488199466cb506e251734cf86f823bf761e9181355613da8ac19c6810c5beea0df23a7e26fdad0c1c9076a53de9202a88af6a2316e59ae582fc2fd6c692642ac24407829e4ec43f453bab72d5dcbd4c43858b54a04a08dee3dd6a338f980a3e71cfdad2ee976b3c1e45e2fa2369761ebf35ae7529985fddbcf7368caa52b2e1911f29bc02415b6ea3108669ce99387d25e6b94a69daf377f4505d0b359e15284f0b06d83dd040a2f842fa8d0fadff85c100dfa9f8e74c989dd6ea972f2ca2c4ea37d390eb9fa99819fb2e554dfef5a48f5e46e9ed8f74fd01fa9285bb8593eb15718c8c3b491e285b9dcdcd653642b08e79538a089c5605f794a67d383a7415532de0ae591841dc9c19c601f5f78d43c52ad17e172ca5714763ff71cfce3e158e601bb9e2534e775a6f152fc3e6b182352087b35d26c6ba27ee5ffb72def522ec1bb203743c31554627fb0e789e1fa97bd8c0666dc7479c9bf2cd6ed91ae21346fc73338a887f93d12e945ca167a94d5c5c5ffea9982dc50208fd63ad91ab03c6807077a5ab50995703bf53b467db80d72bfb18a36c0b04ae43c431aa674581de82e58cb0c08eb80a67909d2d36c0dc1901e1bffcd9eeaf14b14a5b598e292c927503759dc1ac0000f40246e35ec010bedb74e66918fcdc35e523ca9dcd248df92087ff31ce78d67af90d3e20fd947ff8ca565780afad4f9b3ea4cb145f748c18db04144ec94aef857af1404472ee9c6286fadc9ec8663763e0d0daa55a30262d526616ee09834b8c1d73af42dfb3f2d55518d85bcbc2ccde777e737abd54bdd209fc89efd457a376a284b0b7076a4f8c1e27919a319948804fd4f547a80b264168438f7f1aa48d7283ab7aaaa488b24e8911d00a3dce19883ef79ca458d7876af416ccd9f58461564486a8d62f4408e738fd5647b916970f6487392336c0867beca4c696fe148c20a8a805325f4d3ca676685f41e77ed26143d7f9dad2fb8feea35e2f33b416e9ea3ea06a18d24916ef61c63c75178f5f52412a75cc74c2d19dd75a7cd4df5c2bb00bb1e4a05b81dfa8470d12ec12e2082aaa55a266c75ae959cdd65c2d71e3d4fba30d20005ca9277ce41a94e7428c542662055999071cb635df740e4aa9361c392e9ba8ed4f02dcee51da37c81b54a1e5c9dbeb9a3f56e743730ea422b056522a6452e75f3107d954af984df506380a77f6efda743fdc851cf085a2e42491f1a197198767bf4761181120ba856df81cb449a07a066040a10a44a2da5ab3ddef7afbab1f3f04efab586f449729c4b0510b2855f987fe596898846077c94abbb5bb64e7f99112c4ee791796008a301f4feb1a6e23222afb566c212f1f6e5885c137f93edd59f350c3d2186c586eb48e75bd0faf0287bac2f67f763aa224e2af2808756a6596286247d6a943aa8a1c45ab7f924313e60c71bc3664c9238dc874b2e75418714ea4232c5a316d899f0f32765c5f9ba77f372a83c29989a2d1835098a6df9a1abac5a00d3a865799e7901924c886401c91db7316783774ed7ad32f4766640079aa99c841cee6072c4c172d34e0f475acf9ad975a502c7f3dabd5b70ac02dcd204989f736e4a95416c4d7635e508d7172e55f85fa2ab008e98fd92342dbc59552fa7f608e071ee8a3dc283726e5dfef53362a719dd784f8b6978aef6615d9cf908fbb6aa3d69958131cffecf19f87e11eac456055413b035e9af04e011a375652a66a710360c6cef1f48049fbd2703c6886340f639e7a5dad58c403f6542dd865c9bc6e71a035463a7a48e786971197b4ed81f319fe18f5c3c684666270746a0431b95daa4fcba9974ee4a6a984f931cbb289ababe538f8c618d0b2b9a5ad4bd022ea477e91886ad745f308fb113200a2795421e7abfe6510af52c14491f3ac8a2d05c8031717e86397462d606ac4fcd88323e98b1715b54d73155c5ecb1a0a4025aa91e7e88f49c6068da1f4371d71fbe8e9a5824d93f3b394c3e6e7a45465c4c94b1c56a9da7cfa09c3a3fd778a248b714791e6e3035ace99894e767363d408540be6c9f90ec8353ad7552385c6c546b27cca719a2135dc63004b1eec7f5cb7a33cb24d2150caf27366987fc6c87bc8699a513562c9de5e032b6cb9023fe90725df6a8e65721a2b915cb6b9c7ff1e04a56c76c019a9d5801d29cc090ff539d01e3e630a8a8fdbae70d376a4d0154adc7fb1b8be8f584acaee071d5b20c1e1b97479cea7636f383539b6b63d8c358cbd2d3d199bcc06df122e261fcc1829196b6d168b96243c207d6c25a6c8a91e8397266c5c5a79a27d8ae00dde34d6c80b2f3d656840589031b57dfbcb0fad2468080b54f1896470e0785dba96cfef7a765436161197de85e48d7f298c01a54e0dabebafa1bc82d0bd732a006852bb21f93c72aeaaaa4c774e9081be353bed2477b442be2be41fe4d49a26ae2f5ddd3ff909e1b9d44ce067e7064a27d1713367b6964f78f32fd0e512d4b9733d0aa2f26bc010074f591559b057713b79e83569c2cd07eff74fe6794cda521b901549b8b4f0d7d2230181aadb637956bce51acbb0da5e51f13e33ca2c3237abcde3b60717459690dc247f7033bc7fb1e22a2cdc4340296a57c7f90ca3135b5742d75b0138520c727f4f1b2c83e145915b03f239e31881d8a77b2ed324309a2303da85e57593d70aded82fb9080da277157b023fa15a518cdbca56b2f53219a6ae07f2d76c100d64976e2f8c24f6de8d82394ac5107f95891da50ef4bef50e201b20b8f2b517ce503087644207d9bda4e3f87dd9d96a4869753cc9876f37a221d079c6ba013a0165f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
