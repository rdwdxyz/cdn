<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13950099f47014137464d3e92cf219f4205b3654b4e29fd9886152647e9183c3d227cd232f518dac5905ac1fe0c005c754142f160c19ccc1583d3429f25838074f84624ee9254e2d4eef07019756961075babf05d106c4e302f904f87ad2e9ff577104c36a1f49b110a7772dbec87c71e38eec6ab08b72ed25b89e41ac0590ed0ea6bcee16044475ab09a88782865782170a5c14cf93793c7c0e7341d0f112adc9600ac9d61359a51c674446016231d80c1a8c51e3f4f9a363ec51d5c8caa85fd74743140fdf5c3bac6d4463f713d9a1a05d4752015a9b3c39e08c14f76f1e1a20044955d452b1aafb07245472869bdc238009ee08378503920117af5f461603ff93acfd1d1e92aa38dfaf79c9b145ddb634323583876322f881b2d475eaee7e1046665a44b8b87329ae071a3b39d1c803c6570b45c7644f38786ec0d2f332a1c1164961e597dac482a4d5e6c1d484ed12703c1f4bf7cb0b0dc8978a6d9ebede02466c609185af02017b88d88f80f4e995f4e0c49fdd6337c3ab929f95e8bccd1943ca5ce069064b0f1882bbcf7f89cfdc39db6c6ea3fe1be4ca8a8d2ae2e9c86d6d8d1da57014f91d335bc6a94a3dccb257f3f231d4b469cc3e8d1f24404f9b8a1127512307333b148676b99185cd9adf78761ab88798405485479e04004027c4ccba9a46d15ea3b5b538b1ec94cb03387cd945d68968f4be1ab28c2e5c18ad50b11b1230a2aa778d1908495e24bedf196dd1c2f7bfc2add5e6b62425fc11619f11747af47b844ad0d46b342f91a55fbc8f913bd78752e6c6c5fbec1aa03bad376330bf00b5c916b52b36354645b7efbf43f4c73f86c52c6b591e948820236bffbd029d3b93d11690caaaf3eabeca977d52dac52f9039082edf9647c42508456d5df08f465533654e5cbf62527cfb64c53932237dd3ae60360daf87acd2c8d96f36b144934fc6d97227a14ac61dc628cf961874a80017d8176f801de0006126cebcf2cff5f33e10838369a0e5d50e67da99a99b0aa82ace574dff4154264e302678178a0e523ab0292adebbfb0d63eb74d1ea4f32257d683cc7eb3269895acbd5f4950b3a154e043e9bf66795981c46bd1f163ae5b0d56e78942b5f5916ed3334d9eec1682e601802cdd7bb2e1e967d1fdfb5679de36f044cd93a2478656ae01d58b78be4f473940725d40b2d721017f3dc4b850d72801be2250895c819b73543dba722bb4ea2f4eb7054598d7b9cb0daeb3ea56edc0fe109c0d565dbe706dd7055ffeb29ff863ea21d2084e5ebb065668dba4498e57e69ab549cf8b5e0b29793b5704a696a6ed47b6cdda644770ffaf1e7e1c0f683092115f6cd7c537a8bea62a33d7a222396f507c322ded9f47484023a31b4542eea62b114ead1f31fc7bfaae8c166e3e9845f586b41baaf167c14a0552d5c9df25252c6ee05dc6352144abec21aa08b46c4013cd336f7b403fe2f6f31c270349e4befc39ab89bb2226c4be2d6fdc66a1dfa4116509b441526bdc0ac2ceb8355cf69dccf0be0760ce6450506cef3dda383de75471ab65c703d8130883fc140bf636c244ac998df937e3b2002f5a5b75b957529c820e507e89b53ff22ae0ce62ca5260d6c3698fa672c2396b54100e4209cdf38433f46651d2e88c42d80660a73d0c8bb3b37659c823a80b8aff52f40e086a356fc7328937654e9607a7e33af55ae1359da0e557674b033ef7dbd357e358e21369362fef39b4fdc90eedbf3c3df9b020e9dcc68d3c7f64735f8a0019ab4b75986194fd2b61383c1de1f686c9ba0bc6230f2f729a69ecdff58c8e3aa79ab6ca7a8d53f6a6482bdef839619fa4224978c47e1bac95751f33e3376c1309c5f284eab632663746e90af36fd8c56e40962e368c9ac5c6cb298fa0b278c9546980f27639d9994d623c9780dd9c39634e7e8b1d5cba9a93d1bd6e4dafc95a61118279ff5a4164a31346e2e64c1a0d0ee883284a3d707db71522645dd4ebc75b001f6d1771cddf977a2793063ff25561d54ebacaa1aeed3d5921910a3a4e6c8626d6ad7392405b4b878db653ef49eb3f9f0fbac24ac6c786bb80c0a5082c5d924a88e393a3d63ed97430a52283b5c44b63de0853482528349b5ee82ed37aaa2c9c34260a8a0a0a171eceb820abf04519ded32b9e23e523bb1b05429be00928a9711039705ea9d6fbc518d7c824f1fe8f9f6dc6505c7fe2b89eb570bb175f6cb5afb3100a65c0cbde5dad6c9fbcf83bce5017c8fff2622b774af516afd3fafc60e480b5501cb57e0837e408d3c9d4d6e056c70c1b5db11a85dd9137728f38ae5492036c7d27986ee2f02149bce6b5bee8802cc8d2b9d2d746db6b1f78648be9a509b13be2dd767039df355ab7f012160462b205f8c3e1f1a3e0d67402a6e8a4d84c5798403fdcbc9d01b810236c86bfc396013d33bc6e5737312b258e0aedce72a499eee26bd43bd3af4ab7bfbb405f670703aea78669f4b447497c105358a487133174dfd1d1baeba5e09cf61588f337ba140c54038ea9b9fe41b28c9e4ea814bc404872fbeb51ba2ab71f7d9268e541a0e454bb12a6ebf67e8c06d5bbc1d69b842aed39f117564f627365b089c08465c28e68cfc4642e07754dba3450212788483589c573417ba45562625bf1cdbc6496f92f2db4da5c691df5eb0963ff6df782c8323a300988b596034fab5482866e9e5734d654cfab0571bbfcf3d3d07e7f33d5e278461a49cb8af9bc1265ee3d3ead74606802f2ef436d1d8be2005d67a08fce60b6c59b8dc15b4d06332ada08c6cfb6601f22c8076f2be683887c3554d09df34b22168f338e81e411f3fe7e4f17247876a8f20137c35daa84775df67e5fdff5385ae3eb239b03191b837d39655323878c4e09e4c08a4d1441d4f4f118709860f59ece342000d890caadad74af78c11133b2685006282b0173eb0d2a036035c6dcb2ac30dde001344fea1f4c8bddd17d733d59f3b4160972b0410ebd7dc3fed57cca5831f02abb7df67a9543b7ade1f0a82eafe6fca72dc70e5beb197c2c1023156a94e5bd5295a80d7ad82dc3f3119a67d66a44a2d2941f750af78452f63ae76f9439dc96196394a5dbb4d597d5de477b1f1ecefe209dd81b4e09d4947d0a6bc48992480f1b7d1f01158304b5d1ba44b5d80ede16ba687c0409b0b9e504a2624862ccc140ded4d4c1a8a487ff0ef347f164c08d64a95a75e4a381d75a73399ce9ca68fa1cdecb1916659cae7941ff9ec1f78e6a8f5e184c59b81ed9179993b735dc9b84ef3b80a2dc914223e83212e2e07ac5df90633c66c5eb6ba2d69382a747a7dcb11a5a718aedfc8c6ba6ea4b6c8808e0ba2d188b3440fd9d8152eae7bbb4eaa372deb2733c184bfb631d68e2183e19fb62da0bfa9559dd18cb28024dbd8bdf105dffa5403da24e40ba080cc0417ad5b332349fc138d3a0f4e3b66a1537d84f8b15455a0238774c7af927a466f807cc7b5bda8af3a508545c893415898112b429642cc9bbe3476fe3092d84e3453b32cf8f6b1ddff72e1df2f28776f4e6cf50a6893d60a1ad80e8a738b382b8805f053b3146e7c4fd9b066ef20d2ec2dd942cc7af18cf6796b753f7c252388fc24806d1ff73b3ad1de8ec56effaebbdb113affd187abb501152e6f1b0719c945e8a783d2ce764e30b8a8ec9e62c0ba3add02804a1331a98c47948165bbe8560a3c5a9f473ca328e93fb0beafdd290677621e3d04ad0a8ae7f2b3acbbd3f5466b2a81e2a6136d3b862df56ef3f26a6ab14d7f6adf1a1d1585e1546d9420788836321f1cb7e701053d3b8fe4415c222efa41ebb3163dfc5834a088ef0bd74c8d0e1ed0638d3d9f3ee74a5a38550a1d686d872bf741949e93450c120afa0c1dae9858c76faa97f645574af6abe004d4c80a9938220087704c2a952963443dbedc962ca21c0f9ae80335109a86bbbb1dff232a4609ce28b2c38a8d3fe0284483f1eb8246981bd8cba6f25ee4ffd120c452d6106a8047efbbfd9f396b21aea4c293545ff3f74911c5144011542ca87a413ffad8b67052489679f7b1f4fa716e29730a381505362ff9678284c086d8f20db24534092212da957f12691fef35dac67b504dc666ef9a9b68c5f979aafb6537d42fd2f1ccaef449e5459137e42466421ed717b0c638dc892fc0356700f2475e359528a3ceedc171fd3260f63d8eb88f4ce9c05182311debf3fb004dcd17fa323df11423ac38104a9a5e97eaccb4dab53b73352d7981810c12835828cd48857339eacc9659db794d3564e614835fc6a10ae424c1134ecd2025874d4675c863fb8a9341d43b1b2b03bebe17bcc6abe196d8e976fcae9e6c77e22d49735ffcb267f3cc1ba65bc64ce2ad31e759c7c7a235bc94e5a10bcb56270ae2168077d1849f5d79955b65f0029d455b59e29898e1502713836805109d10088435b5b97e87ca9c5967efcd810d7ba9aee2138cbfc4486053e3823aa65b60877bde34845b5d0da97c3f8a2ee04596622fd17dc263dd85a8313dc7bdea5d64b4bd86b54642462fb310fe555ae21b23b64c0ec8dc7151ef32ff1222d11759941637ad1948dd7610381949aa61c6699e865228fb1f73393c24a2670bb25977199e8e96b5065531be0ef2cdaea2fe67c0952865e4db8a3f60fd7db52c255f9b8c8f7d9c3cccb3ecea5cd052ca3ac9aad3d9112ac1fd8524e917b64d53f871fdaceedba8d8b1a60a62f900c8d8bd1bc86261def550a359ef39c2d844ce1a63a9c83fec92484dc6c72439e5712eaba5c5b46721c426a0d72f996c691729cfbe591c824a613a9201ff9a96da9b076f53135b8cd57b571bf7e54ae10553489bf44c7fbaf06ce3cb02ee7be14ab1b3a6f11e7d61b7b04755ceb7a36fa6a4fe76ef9b2aefce069f0fbe0b9d622c0f041c9c4880072f2c2da943aca276de15e5e8202b50936f2ec70022a93eb930408e3d6c816f122d0fb8c4f978999cd0a9d34ad95d0f373c4432e51b974ad5bd1f81b9cdf16eea6b90d7a1de81d7c20da6caae086dea98f466e0f1341f2aec76916e8bba328deabae8080edfc28ddf4edc3d2681f0fa0c045e7fb502a25389bd37d895c9cae909d211bcd6b7e409aae2f7cc490fb4c3476870a7d72df5f1a66958f7bee717790c3eb2265046a584c193facaaec344d043059b57ba0874719e25e09c68cd8bb8776a5ab15fc19fa7868265f46202f6bdec0587202076355c68f37cbaf3b23f8d220a332bac660ca6a6d92b4aea709e3313e276819119f4e817cf5efdcc7912c5280cfcc1ca135e556740af81063079c386cdbbbacddf9b18982250f3f4b45382f15ac4cb711ad4dd0acf5ce6c0b908fe42fa60587d9eaf4a52effc1cd2ee7a47c15a5e4db20e69674f33be15dc1f50841d65949120869e877fef60c12e0d8c5b2949dc3eb992563283c9d1f8e6ed2b5f5f618cc48ec9ab07d7247e13febc857154f7939c0c5a249ae15f9b72f83c03b995254fc5ff5bc72e22f0c834d0820a6f7fed54cf064e642f3066d2643cfadf5bb78da890abb717829b9195af1a78ec59e9408779a6010d8b5ab5339cfd92c8c119ad171c5b53342784727db23e7a266f28146c3651533e46afe8181176c7e891212de352c5a6039117b64139fc3823d03c1b81d570575d55a08def2764be157886d339056657702b37d4774bd23c79a902b7ed6af9673645d86f79c3448394194081b1f847e1797cff445cc2cdd811626dde891c98edd59c8083e35402806bd34b16f96c62d08c09ea72905af569789329aebfc10b5f4929c0279141225091d3828754c161f79ebd4e56e62b1f2ac0a65e45b29d4b768427c60572fb494da174ab1d40509b2384341316a0f0c47de5b04ced71c8853826d3cbc6e093beacb8a5bbbde3f0d9e3c6ab055d18e55b14dc0167745ad09853a95757174a01236816044c0d3b432a5dc3a89160257534bc171e38a47bf0f3579eafdf2ee7b8a1f40dc0b6089a37b2e05a4d7d722b63b478d6f148057db7979500a6199ecb30b3db09cae1b13266d548620e180457285a8eed1e86819f04a6fbc1f7a7ef47558918051b6ce493705eab009f8722de4a67f9dbf7dc1a33a27acdcb1332da2aea9eda01f05e297f625b7fb86dfde0c7df8d83a80e75bdad05188095d8c96ada49a4b286bb3511254e431532ecda86c28c70434a208bf885aa634739824412e6603c6cc7b9c2a8f06acfc12d0cea47bcbd6eb45854a620d332b6214f6ece5e85938279f4ca10399fa37a6eb778b376cb6553795e4d7fb32701b566acbbbb3ae99271e30cc89fc0935c0123e7b0e0b2f39c00d5b51d8409443fff30b295a07317a87f6fdae6fa6e479862f98762e6ee366dd09772f6411ed87d328c9d179dddb45beba5df6c579f3ded8f01500ab180bcbcf90fe2a06068eb20b7c6d24447c8d9ddd723ce34a7991143545dfa68af89d0c842b524691454afb18308d26eb558ca6a2ae71207e30447185ae73694487770421c16b4f3133f042b0d6d77d9dd92f3ed81d676e85b573af971da30f97a52690c3bdf2b00a374b292451c2abb5118aed0d58b803ef7dca579fe118e2b8a691ce85f403daaa8af2fb813afdd3c28efccfae2dc6e6274e7ded4ab93cda673e6d4a769d7c89a84b4451f6bad7bdd2a0a8eded5037a994fc3fcd14e50cf6602ad0fe45ac5026909acf6dbdafa3542ee6426a6daf388cd5493f53d911f8ea7ed42ea1f83c2f831e26ed71dc8910d32f1b7d3c8711ef61c1f314199a1ed692b6edd307e48571ac429c7ef07ab4ea775d2317edf5a969ac65e8733488faec67ba322c1fd7c240939fa0a5dc5ce36754836837812168e2bc0202d19e431c944e943996933d00f69b1170cbbd1b4137ee7cf6efe5edbe18b266a89359fe1681554cb378c7efb36257e9f1a3a3647500610292bd16c4a85f9e7cc067e98fedcf8783095d608e9dfc7dddfce5d4ce19c3209af57f2a37c73e3c6b5a2e8320e6535ba390376f785578cf171f89e6f3cd2b8206e67b491f6925e3181d4f01ba6e89a503c9f88aced1eb5eae65b7d75e1d88fc9b07699f08804bee8d66162733302e2960beea1ba8d30a43930f94a426e64e186fad4b868437d6d2f99f823355b6c1711657fae8ac17388cda60791bfeb67783aae922a1a3a92c169da7bd9a8ca9535e121b6bab4f1640d21b79f7eb49eefbda908d344dfbd9deec7dcf5a679f6a13799f541d4cd9fb915efa7ce6ed248b26fede7101ff2c5945380840f93806d2e63537e5e7b857bf48ad6740fcfa1ab5712a4f38b8ed773c8b43a88e5d87253b05f9750c0b3d3beb2cfcd3bf3523e4f16cc79f25ec6c65c06550a3b5ddd505de300d05c682ca39d7447f1f6a9f0f4adba8964ba615b0a047c93433a0a6c6746454c838c11d8eb837a3c0f36206b1232c40e51e86885672a1aa74f3545186684509889f8bea38e731672e12faa0804afde495c5cd46db975091b36b7ac3b6da0abdf0d36b425ba4fc771528f73cd90485b1a1fed2e1ffa1dfca0e5d8683d1fe149a47d3c558aabce20ecba70702627be3b09423c9627163c01d8b3bdd4e9521653db77dde3e3e256be0e5f12713c678fc2e654339250bf18f8d43f7b208df33ae0510ae40adaf1372ba263682c179b00b32b57c4fef1d147c50c8347298c00db522085dbc9889748a0ec743faf03b2a8107fe97d515081782b074772852d82d0a56625658b29d92f743aa9754038dc068af62ca8b6d408ebceeed4aefe33b9c3ef1eb5c46c2929f75c4272b5675dee04697cff14e266483b592dab37d7f401e8490541f536da71e340017d2ad4da331c4f3db9d066d103dba39ec05c8c598baadc1cb24c11ede06cf4a831743a186eaaecb1cfecc160caa014db382c28c4ac53337ad83e7fc17c0c1ab29c31cd2632753d4bee9cbc6dc1dfbad81ebbe79adaadf1a40a6af07c5347146d2369a5c3001565bd4bbafc849d4af3a3f35731bbd8d62b71fa5a973cec27e5f6ad8f8c9927a320e617f76f2d7a5f39e287a3129bf0596601e311b1b58dc5f13d97910fded04da12679b310f52c7980bc48a81d37608793293688b8803ad6f7b0e1e55c641efa98b6db8e9d3010e14c759eea36b1172c392aa8a27890d7f1440a6723c3a11198aa8adf894ca60da4e11cdf528b4f73c015532f9713ace35f7d9cb93d172720cb306c7f13b33f94bbfdf3999c6fcf40e052bb446ed8fbf9ac3c6859b5cb74ba47190dc734a9fed0962a2d0fe5ca0e32a13ba2e74c3cf8b53cef4b49f122421d3bd7ffd77b6e625e903ebbeaa592c491354063f4455eb934a0f750269225a4c8e0c3becdda7f55532b30b2628622a5da367a27851594cf46b2a5a6b06a0a8efce7dc2497d75eae3cac5126a90a68a2f9b55997a60660e284d42d200595eec3fb9029f31f124f74ef037065fa7f1f86779b4a5f7696ec79d0f7654a04b6bde68a10e0c648beb78b73ea3faa5b09625da9505aa5a9289f0513f4d61a58da8b8b708fd1b30152160e9acf86c696e958d612167c502e4586fa28058ac643098f5cd95b9c06d14c302b2763500cdb647156b0960e9ca41e0f293964be64159c1377165a16a6538f17d065555ff23501135b868bb3ccec5c0316d8231d6a030b62a9aafd9b3504143af12211e2609cafa4648ea8ca23c0b13ca3f925243b8a45751b86a7397c77c2fb7e70b853084319ee1b2c3dcd28d7a55484ace1754825fe40bdf6c7cc85b538bf5a33a3759114a45a525d4a57495433ae5b7ced012e945bcec5f65d52a50db4dbc976c95fbfed80b7a24621f3238a19860d7138ce7348955dc14917f3f08649b13c428ae65f96656221555562cbfa28a164d4b5f45cdcc819388b828571f61665b9032954fe361a1832be02a033363394257f5529684f801a8d43accd4dd100a946d86f2b6f907a53e698c11c9d3edc0b9f02cb3423579fe17586c417a16181c06fb9a82552f770d18b40547c1edf92a155f9249dcff7aa7cface8bc30ce7e0f4815712648397a7be5d96bca1a60e5e9fe6f001f7c94e63560e112df56b5f5c97c53cf4df6abadbac0397aef6bf0cbd3efd19de53810b1ff2e923e4798165198a551809e9c886752bdcd41b86d7f7f2895a33630a61dc49cf2a569a7be969e2ec8a05b48cb8b2b36ed37de58ffade9be93cd97300ddfd0fabaf9dadbe69673e1774dc431e9c0d9686e95a00e0e0d8ff3e0c4e18a3c2847822e00991b1c0234891abb2de7167f6a3f2233ca0a9545e44ebf27f301ba74b67588cbac96522e831ef05944a4917f0d7a5fbf33fe55b33e3c3ea0089608ac21b2746aa4a3fdaef1e432c25c9e88fd8ed0e0ef8dd4fef6ec3e938ed946cd72be5870d5f9cce001eb421b525b881f3115ae7bf87ee594578f37a875a4a37f2ab37f76e513efbc1349698041b58dd5b690aefd57996b968ff663644d39a3ecd2c1e88f94daefc3c4dd108ae9919331baadbf02d5e31269db51b1d4e62ec225a2bb6f4c6bf2042754fd9ddbf6ccd36adab12edd3d124a3b1364d12432ac082cce9b27630d4ebbaf5cee572bbbdb687c38d8f99f84cffb6ac24d1051939eedccbabce080522ff3458f8258c97a9f8a48b157d5af5f87c28b7c76ebf206d711df8264b944e7a3c6332725d1e0d575e700088de7d164a4da32ad4644738ac68ff1cc038e1021d9a2a98957a0354556c6e5fc17bd1b3588248dc28c8e99c8a54a798ea37c36b2ef28d23df87fda2c62cf27b72aad3b38bb0eb54c437f96e803facd3e4a9527ea42dc1337246dd9abdf63f48aaa34d93a17c206948d89fe56d54e648ed05fffae77b46a78fa8dda701b02165db2e3fa6c107e6e435a5107e4ae76e1d599999a849873a98e23ad2da2a00667407017e1a03d5d4e255b634361a1aaf7838a4f9f009f1068630a085330081029a457f1f829452828152f1be975f70f8c5064264d65855215f124bf50ba3858707ba1a2b23566bc9071c375a380c2d402790cd9d3e72582b2fc9443c3c535cc1643a06d42ea17cdbb2675c92ec99c04c49f3cdcee5615466fa11bac23419b9338840686d1a34eae9480405f839f3b2d4c1b5201177ec40d838bd4ef248a4f38a499ccc20cfd06057a20195dbaab61db2ba6ef90e6412ab787f867a13e8a18998aeed697a7d815dfb528664a88df00e813713b75bb7a10e00fde927e03d6f0e66d7af497e3feb2c2b3977d9805cf36fb47263bd7db66ba155e7eb01f46f9cd6cd422f395590166c9cdfdbed95dab58fae28123e609e06760f2a9f2eb9e5f1537ed6c0bef3770a1f1cea432d0ca11f9aa9e765d93afa6818c202b8aca24a97910f1ecc5ee9752494b0f84fbbc2fe25c6901115b0d1c3611add499fa258af8966277970b369b25c939020233762dbf64bd57c20bb02b6d902791a730d22b2d41ab12f615ac0c21d49f787c0126dc64824d2e35aefdea65c38bbaaf42a7cb9b8bdd002797fbfbe2eb36cb95aa015566594a82005aa5f11da949c9dab76a314229d1071eb436378e064d85c25b28ac30bce02f8be8f1729c3121cf4a3e8446a4aa61994c7826c9254fbca98d2190a65c68d305ea6df5ca9e5e4bf6622e7b3eb83094473541251f38a95a59ca6f19461ae1e058841d71f9e7c55be8a29cdcfb6c60baa44dfe769c4c37c39012a41e668ecb5c250c0a7d79e3bb752f9289117ea67b8f8c7441f721706fd774576dcffe1c266cedf337f41327b1a53bfedc7d916276b6e7baeca157be2b8ed2610aaa5f5e688b5d2408a4374e43e9d309e50bce073519c431d62853269ed949d704c93e3b35f4e451a908fcc7075082c6d59815cc9524f1fc9b75fae2875612559f530f7cc4256dd1a3ad3cb63d7dd15b58e55015e41bc140adb4fb3579ef7fd00b3793354238ca88f53fab6b8299cb517d1c0a3f2af494ee745d4a1b27163ba5e2512e32df4720a55acb502d7b737ebd157476dca6bf3ebd56d1808dbeebee720f4681435790fbcb5d09d5c370175f869da0e8219a51afbe0ba5c590949846bf8a507c5c6a93abbbae66f3b9887953aa607323a8628dd0d82409139e18f1059c8cb2f645d056177928c80e7055b7c531348137e9187f8096161c0e3cb94ff77666a97ed609224c91ced2e4374feda49752751d6ca5584a229b9b6e8d3757b41c2cd2aa2a44df9897c41efaf9628d974f4116e22f462f210cc7d320faca42d022b2ded3076cf9cb5733545cd96ccd2075cb7abcf604f285b00688d91ed678d69e4f956d016c5c8c5d31e77d81a6ec4191d75b38e34b134a3218f8c4df9f1c3b3b277ff3388f455a795d4c171adc505b3a5405b75af709b536d1a2d441f9b4550ff93ec605272818c0df21f2ff01678756d8ae07b9fe8af08c59f2a9848aa46a11d2285f67b55ccb8cd47a35413b279318686d87dd0a5c977996a3f9c37f3d20efbac57833be5a0eb17b647615d8005332d3da351c9c6ebc2c1dad51dffce85a57805bdb025c2b98b22ca23302ffd67adb4d8098fb147e9a0e878e8ede2f536206a6178386d247caeef937a946089c01999c63c2725f53f43962c77381f9cb89eebd7879c9f6a5ad915ac76746712e8de0236f9e9067eadef5cf08bbbc4ac03c67080fdc43342d485c41b344fa0b0379c8953f537346ba68705cadce99b57d86889488ee5fcd203185c66f1dbc016527bf58f5c9d1821dea8b8a1663f273a0b82f7aac43dbeae90e0cb5a9e52065195b81480d055684b22135d722b55a12c085d1eaf085c51901825c631cb452706608e34ae250a661251caa234320b791d3bef408c9b4eb6851616f36e6668fbc258315fa27fe1f34597c73698c2178a5770d7c24fa70507bf8c1bde95fa168f301fdd4b2fae8eb41b344cd8fbeb2b1941844989455ba668cc3019480f7facd5f42c6ce45d34518c515e88afd78aa4e5589a315e7b1763606749736da69a57b7db7997d004456e2fdb1713b43ac0beed08b6920c64e0c62fcb3033b2fcaed29ea91af79d99608676f54ca5d411bed7058d6532fa88b92a06513e52224c31808a05f69ee1d04df08dca51fae47fca4046173649565af8d84f95c8b6cf72c3888e0ce25e6444b2357765b8f009abe7015944e108f0a3d08ecd1b94c52c84b4a41c3eb875a5a87eae06ae14f84989fe848381838e55d8a8522c596ece7f10d9304736b5817e32bfe702fcda4cac93d58bf6e1a7ad8856b640d93fc24ee2fd2693fd76133d5baea35b04f50e1fbad296490dc20ca52c4d14a00ebf481b3ba22ad201a2bb2d65fcd05675bf9e3e78811bd7e5ce38287bd75c26d6540de941130563a882db9ac9a61b5bfb7476e64a5b17743ae114714d108d583039428e86f5972a4d1e6d3b64e9a777e0744717b66d1d73ae770b03ae576f34df1239e60ce74c731272309cc691f990386d6a17889aebb865d6c725a0c11c7821395574a84999d6cc6af84cf34eb75aab134a289c6f15cd40cc1abf489fc7546f5a93cb80e93805c80d5e47af4c541ebed3f3230931f0f7f1721a75d192f0f6691c4c4828d60f5f4386d0ad48332974e452536f68fd788776767adf6f13018c71cf037c2e971be7d13571750841b78aafff7abde88c97faff7fea2601bf2c0a26274880b131852854a2cc66697bc45de5c253a7fd9bb88e97273c0dabfb9a73321de452485eb8d81223e9d111f9c3212d2b44576a403d48c6c193a6b9a06de88ec8938616e90b6c4eb1c895a088c80ab1784a661a60d5cf5980ccb9ee33a268b1c1cec9ff8d9c95f737b8527f5b02cfa958c4ebe81dd0808f0085726a47ab9b39354d12d9d63e46ad1446e02897dc1305b5e6fc0a9bdd1a32b4651f33e6dd73f4b1aec82562acd73deb79d343665cbd872015a2af4191f58fa8da75f4a9b383383636dbeffe6f3aa52daf8b5a6d183970465d89cfca846830473aba13f65b4744e49f7dc5690fdc32e7f0bab310e58658e5e9f4f60e50f996e379919b59a461b3dd8e503a47b64b1340c4a30e01d408b74e16d959563f4a9fdc44f24c7187f2e54c57af8eea10d4391bbd2c7448acf5966bcb8a98b8df9dddb47c65a694729927b98c991526b9f192c3ddcaa4cd1d168ca25ad2d0bfb0dc4eec0a2756d06008d99d06ae6a9eaf9c029daf479a27fbf54a2e557ae56526c16bcfd72080c5d060d669db521ee68d6975b654ca084c2132b419b7a23535db09fe731fab2bde0bd4d0739873ee71364fd6c5b16584c621ae255e8b3efa9336ddc4969914eb6f2fe2e195b84b9fcaad3f42eaa8a2ed0dac77f9070909595acb44bab71ae21ffe7a56272c77b0c6988013af888f894541cedc2ddc70e01b9a564fa42eb0f6eeeba638267a37d546801b75fa4cfde5c33586af924fe751678a3acef3624186a314b0d5ac5c1267be02cc330f77f9c4ed16df208ace1d69a02223af8b0d5796c5c57f8aa32dde7e4bf097183e114926e000affe93f626eaecdfedea57b8a3733a389bedb5de7663d2695e402c855e861868dbef4dd2e29ea20b22c006f0df601151f39dfce6c7576400482d0da258f8d76413c8aab22cb43886ed9244283fe309316345355639f5400ed06b8651a91f055ca70af45ac9641cf8d965ef8164179b73d000b56a22d3e2c8280b779f3ea1393a5f22995cb512d797343f262ce641c1348bfff30dd53493c5b66e9cef05db05836700c3eb39959f32f15784729a45c1059ea46eb110f94c159673db033959844fef0155eacee959e03d08e3c50c14d465de9b0e0115a418bfb8cd05a2100f8b49d1f02ed05b13aeaeedd8c212eacabb5f4f60de119f4dfde21fcf25b089e410de0b15f2d1d51bfbc7b62a29172bbbe05665d5001f0d1dab2258b0fe4310dd7cb3a51e8b1caf73e832e2276da63c73dca3321ab0fed2f1ed1f256e53eec60e98ceb134736ed3ec6159dbe6c43ee1a2aacc54629b64b26d222a5d58cf43ba00a28d509e027e169b163c9f29b02fc11a26fdd9e3429975e2849003b988f23e6c1e8b1125f09b704538a3fbc51557d52a3018477ea5a69a81703bf8041fd60e35e3518b9cae6fa7078da58b9c2413fd71b16c2f651bcb9f2bc0fd3b22e1cd511a28bc3f31a3b3bb7a8efa2e7c9aa6df3d3635f4444b85d752cabc38302118d8ed24b3a39557830173e609aae506339da2b5babd0518200c3c5957e51e32e5afec07c1d1a2820bad198342f3de4aab6e53cbee509da1cde2433d0f7f0af5a4cd046ab37f5b97eb6693a7881af8e376e2d3ef3683a5f5cfac2e228e033f1247bc107a9f985a64e336c0fffa113e7d9d5c498db0024ffb56568ef051c4477397f16e0efe23325a36d651cc470ab8711d4c347fb1d0584d52985971c540adc4cc6fa47de97da0d8b68cf95251f2350e07e705cd75ae16c8ca5402e144663838e61939ddd9dd4834a16909ade5b7fac72d3bd484ab33dfbad8882761a9e216d64f98c165be10f419d4f2051ef31095cc051cdcf9641fdc238a0db84f58ef432d11b447265053f2dd14c92346c37308a4e3c2bdfd3a8a891768a7eb19690ab1058720e516255d199bf68c57d65b0a3d57dc39768f892c9e24d8c5ff0a8ba3231538990bdb98c744b76098e95af40f7c3c86461345b4386c16558a21d940f7c6a0635ac81570cf9c8f1196f3192130394cd14a6bed92af33597e588190c7b15374d437b95c7598506a4d9986860b1de229538d34bef09429cefbceecb0c1f29d9c266a0e84bcd73e75cd44feb984c5d1d052f7b5a6cdee121f7fef570a914bf4094fb829f06e8e9b73c9948f802f828a1eac535ef1164aa7ecdae9901867676af6fad76839c482413091d4e4bac75d20c0acaec8f063bb2d64823727cfba6fde538e3b75102185a1391e1c098c6e496a785b871777cd72b03b19973b6c91cd36c13a4fe0c573b5181af45197ece2d85d8b5ee78a735bcf1ed70752926b38623c6aee8e9d2194d64192c45f3aac3accb12872ff4fb0bdc728d7a84f4bd658fd60d73d9533e80b876b742ae478af173f53f1e8fbb30788d10c49ca75250c016e5278aa69f8fc37d2492a5a1bef9e849a92348a2305d017f86367ea2cc0e09a91afadb041b8a006987f1c832ebabbaaad93009f77587625844bcde772959ee2c21badc36ba510605610d746fb64ce668b864713","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
