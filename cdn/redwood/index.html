<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b21679e3c196bb621eeaf6ffab9ae97b3e622c2ca9e87bb47e5f859cc914bbd0d60308c36d135bd93378da2a09743dfca27dc6a35db28fd0be841b74eb9e970f17792c8ba1902f8299c467594a8d730ba54d31bdd0c80305facd7ae916ae80ecb8aec34b25e818cec01b4ba8e3be4d20d18233d6c079128cf99e5122cf09fc8fb701b6cb61a5a2f0c4f3385898acfd116702be92948943622b88726b04deae19a7d5384941e6e92313bbdd3643d96128d257d40d5e961525b7711391f226f1901a190f2c93078d0a66b99d61ff8c58d096e72096ba8387c762c0eda0295af42889b7cf5c60a09f35450caea5cd6840d446ac4f4c75ca0ebaf870dd06473f7576a461c47fbcaaf46d04e1c0f58876ccf376e13e1a5880490378b13a1aae200f673b85b9a56e613c028dc0292ced4a37aa03c3368b8dc44969bc69dbd8c6e545cda372c5701ec904243e315f9e8bc287672b613b301c9f0696e119e950778128e98232d7f2504e9eca6c7cd03a7ead0b7cc2063bbe056c84ccde2532a54e8d3d95800fd9135834d93221771cab0f7ed195a9ec8c7afdd3a04641bb005c9db0b17a0984c4a8423e58593d02954d995f4226095ea6f9061a6c0831e2da5fc4bf051df34da7014429bbd0628e5a558b00ce16840b5f8e184b21e39bb757a699615185652a94a1b4116d144202c282323854261e1632c576f8f6a284f9a1d7a7065a9cff6f47ef37445fa622f46b7b91f57494a4939a5efd61c480bdd488f8a8d68a30918cc4253a98f7d8075f3b24f909d923617f71e3a34786e9fd0a2d04769edd1c757dc02a82ae810d80252e64111da9d5e40cc8b3732f224e9cf1a6a41da63539453ebfcfa7fe47fe7a8f0cb3ccb7a16f037a77a7cd21371309b9d04d9dbb62e090a6dbfa927446f788eb47f11121414506d29022a7a2ce33ece3ae0fbcc5d7a41a1f832db6006a33094716506ca035c479b26cd3bbe4feabe5258934336ff0be1523281fe64f2ef550d2d62590b7ec31c46e79f8e6e67de049548166c8f4db0ef88ed24fcd10920e00222b07e9907c0e25b6ae8dae6eb7c5bc3f5f467d08641b7f118e1bdac36cc86ec1bf01cec63b8473dcc521d828263efd1f8107ecffe1f43c5edaf8f7bfacc5f34116c51b489988224e7e06df156a04f5c8c4c2fae3beda72fdb8404db470cbb05c3cabf3e6fa824f245020dc2ee5fb389933a40347416888cc83237336aa3654b2318ab6654c7e698e5e9ad2a11214a39137142d8a2337eea48e2727e2a0a545ec44ba7b77e1a108dd2b52fbfc43b7a5705c5ed0159c198a2437151759dfab25c0cc2e8519febc631a2248faf15fba81c38b7b36b4a55308df71c1d3ab6df870401792cd76c2e47b8f4cf04af1d83ec0353c5601140551ae3ce3a65417c0f754e32fa489fe9805050692ade22f46b10e9319bd62e2d06fe98620c840f572c28686afeb047f82a63653ebe7c3edd3484be5a97d0d7aba7510dce2e00375f6d311a189d6fe6a93b0852c93bacf16cb64bd10039ba93bff2bcf5a372d72ef2edd47cd074449ae84b35cde353e52d32a1126e95754fb05cbf7903a218f0d0fb81a4ac52871f013d3bf37c0e07a880e789c8834d602504cdde38499082da41129765031040e52960d98691215bbafa142bb218ccc9145434841985e40f149e6ac36be8d284c1f93acb1232f27c0e8dbdf9ad4c8adcf7b41ebb60bf5e65487c90cf02dac994a439247c1e486746b2be447badbfb659a71d1fc9a1a6657b1b69a45363bfae753dfd74e64e3fd1b335f83405e6d57969d40f6472e88bf967e27354938a36f21c5a2cdb7ba578dde745414dad7ef8b2f66fc14bd928126d878dbe5af87beb9271508c04341e1f2c6c13b7fa0ffb6779658b5ed5b65f82785b080ed363e2c1ed60966613722beb2df03ef81c99f0b891089af0628fd47a0c95bd4d48c3eab50262c6b6d5e01c7486f453c91daa1798e56bfc5758b31fee991f570c38c983e46681524b1a986fe451658f39001c422583095ddd79c1f027afc2afd8110b028f1babeced7049df19a5752bc878d5aaab7a0a5d21d3276d19d25373a8a5942ecf7bd4bb704ce6c6d463768c6c709ec1fd17143a5464aa0f1897efdbcd81ca9d645fdc681bd33dbbd611ab62371709c63acdf4987e1fbb6936be84c063d16179d9de6071222cca37fee478e9eec619a5b7817726819575c483a47eec74f97d27df6a1af9c64ca7265635720e617dae3aa21b1a61157a086ff9127b47598697c578ef2ff63e5407f47e5ec7ab77e7e18f3937328422b4b9bbac9555dc0d6992e11394a16205d87634aba3cbba5f16f7db7a1911ef4cecf9ae3b28a442b035953c6a5ba83b2957259f67ca3b76f6ffc798ff44278d9800da5779a7251b1d2a34f66ffc9bf27a6508277bc4a212a83cc0cbb994db0165ab85b387273b3a0bc595c247d2f75fce3dcd9a718c76d3c1f76a5c760fbe708520c9e2e3ebc19b3dedf22e6959c17262e55264d2b40500855d5ba68a73fa5b7c0178226e70634f849f87f75ceb7609729f30300e325c6940f82c55fdcfe815801496ce0568bd1a40a0175fdbb846e9fd2bea0bcfabe7880efbf7b146f21f8765dd2df4cfec66e9a373545afdda97072c9983778e049950d315d5f8f11e08761ce0d5a524fe4af3b575d7ac6ed9a2d97ecf75768290774b101ee8ce8e71e380d4e2217c98c835d45b415c41ab5b296a9a8ab98e932c982ad241f23cd4066b2eae487ca92a11d564ae739cd1d8acd552f4f594d962a581f682e005807229c8ca3263962dc8939897eb864c71e60562da1a48c16cc1a550262e924f776c071e3647e720b7403317b89b06d06fbc4f695c97fc1ecb55443c8d6877d24979e703ac3daeafb650dc791a568b33ace329a8ec1d098bc2fa7c8c71a2fa553aaa75eff75e10b2906d68066db4d672f58bdb4f576cc7b69e5cfe4c122b1f09affbb88e9cd3a36ed00f0cdaa22aa8f2fe49d9e86a0440fcf676b9e038fb4c687db1415f359f335c02da585796edb00c62d0a68118c9cbe2ba52536a61805f38fcf79c621c1f3fb9eae71a08f0610a95792a4248105041a3da91c30d1e6788410fda5e1ff505bf5f047020f7c5894f1a0f51da844da83b6f3bb29cd1d39fd8c4e0c7f883dfa69663d201c9cab0824a138ed4b687f1e8f4212e479cb52163ff8d087dc32658c7feb0557607bac5ab4b91507ae74c03c6ca58d95bf9136baa1da747b708c134dbb91e6ffa9ca69bc470e872fe5265b3194d8d8a83834100bf7f33c0001a2f8d0d930855530695426f25f0bce1488c00d5188426f12fe13dfc7f4775ebe261f87248a7bc4d312ff0c4258bc1aa4d0a0a78990544fb3aebe0b4c2b37ccb027e4e7d4ff9a370540dd60463cc92ded07efa66b2ffe89d3ea3cb5cf59f9e9830e4db760ae444acee6b0fc6533ec3e7efb4092582e05ac1ab66c151452410af57b720d9c825583473c75ac5ec71592b2c9f5c0e4783b1d44a141b8199f645bcf35633336f94fc371be8f8dfacd30f2c2d7a34f0a1a2be47f4b97e3b861d1174bb2e976a6831eb13d63cec33fe46fbc43ff49df922310d8c0926795a304b3e9e712c1b7818aeafe708e0573b3336e1685b010ac34a0827e38d0bb54e8a4140bb7f5a2b5e8d3499a0463b6a1181349e4983ce0cb90b3b4b64217a1274bb7876087d328eaf3bba921b3801706af6de36dfff2f250a23a66f84110b22c7520a72ccbee8890a59a38469cbc12605da52fbd9129ae20ec7d748c729f90abad4f49ee48e66a8034081650c61143011d8ef18544770466e800f71939b5e59b31e6bcfdfefd99bb1511134827e6810b2b74e25e25164fc40e6d890b43b50e6e1b576ade18150005ca81eefb0c60faf7078a722b93c309b5d8df7ff4f7b5022685d69f1dafab3fb412259081640796d41142b271586ef94a9be83068444bee8670b5baa69e6bf956e876528fe8a92e5f075d6a4f5b73a1e149ac7b9fe160572d6dd9eecd39d67a8c57aaa57bc0996ac103c5ad12ae1138a5c5bee18a6d4470989c9c2089bf2fc47cfed8fa7eeb8d0169a942c0029356cc46936fa4ec957fb73399a5bdd8a92a282234e9195b69ad367d27e6da92f917558b7eb2abbc84e2370ed23e3117e6ecc3286302702093b5d3681384c99716dd15cd4a3516c40dc5feb878954f811c29356ffd3f0b53f2c86827ca0161a4c29e7d448b804b060b4f99c3acf3fd824f11880c3b11c598a34cf25a6fb4184eac8c86e25d7be913bc4c1d7a3870f8b7e0740669477276f953861c6ee3b9b939f806c12ce9af8c49bc6184f0aabd5e80fbef3c22a46173853693acdef4eee5772edeed2196b31eeb4f8644a173562bf1ccbdb5df2b98760b8cb61a0fa942293466678b7aa4075a9d873fe41e7130140dce2166a7a97c901235ac71c9ecd11fa195a73f4bba5b9ea5151dda235199ab0fd8a2767702f44e75aa54291e8e9c83ca3e48c9ded972bb0a3460918155c5018d0545d34e3f784bdcbeb299e39aecfe737153066be9e6a1c5b4948c19e621ef73618afa6043cbf82f6091972eaef9ab349c57de18e5bbff52eff36c5c77467c7763f46d3aa71866e4cffae561abcd682833e7cfa055606ac4276755904d4415c123702d639845260bd04b94b0677e2838d64fb328f59e8001126f0cb51f3b7897059f622bb08b0fe067d3a0d916894a2317d1265c7fb4b293b3494645d25a8defc85fcc82d7ff957e2795ea58940d6bd754bf055be7388c2634720dc6ee08fb5136cf8779c63440f8c2d418935cbe7c1dd4adf49af6eb7ac4147de0fb774a08eb72aeeec0b66ca71260a6187faabd4f2f842f8fd3b80ed10e1d66b1f31cac7edab75a2320633f91477fad6019b1fcab57149fa6165326ebfd4e705a2e8f7fb38581326ce5c7f5b408bb6041127515b7cc81b42c2f150ba7749af3212ffac52b2b60a1f6f6974659b978ff786ead91145555bc9f12b3b525d1ab2e893aa22c0817e3581fcd1761cb74c8c7a204e7d7732c44786fdafa4cddcc07ec67b5c5825cb3dbbf48883e42cdbfc8fd9b3d74f5580669bc88caad5d21a9b2147111fa37a69696e6b5f23a06e68c32a6b55f884dd2811034f021f809cc5b9d6469ce70f7dd69305c76a81770234cabccb92d89e2c9c7437bbccdc6ab247a184c0cdff1eea24852a64efe6d117cb7db863b2ecdf0fa8a6d68283dbeb4ea2bfe61e5eae8a8df432b19f672bb91ff64533bbe6e0c319d9e5fc23bd6ebb7fdff7381c04156457d48a15f8d69c46099ee8cb9962affaff86e2f4114e125907bd8e183b41b6dbc8b6619db32a98ddba1959d330c793a944573ebc081e4928f4dfe33fb28fc9b8aa38be215b4550d5a39dc44e884cf9e2f65e12fa9a97c4b43e647036d18c42399c2bd757af22911bb761cbd7c1aff671ee5a20938e59557787c3f56cd7f659831392f833f48405bf4e6786bb9e21555f1c84d9c3423807779b426ebf4e6ed8b7603ebf2620dcd69982be5a0aa33b4045ebf9ecbcbf0c32e5e60731ad96a614039a6fcbbc06c96b5932c57642c21879486430a4f984a86389bab1d3a4b43bd4d56b480ac7e18fb7567cf8706bfb2d31a32a564aed5f8e55ca227ece3150df1f46c9a28f2985a0921fb77703fe5895843fa884d6ebae4f9ba76cbea037fac3cedd70bc6f9ecbec4000f1f0e26bf024fdf4ed6dcdd1f010d7dcf82d409d69e7b34e835a829d84f90693fd20bc62efa6f060d2f830aaa90dd7e63604a55cc2d57bc0550333ba92246e93cf78f8d75a7fb03cc676316e66289d3b4f4a4b2d581c78b66d2306e5ff602daea26ad6c65200e949e3721e309fac6eb4f1c58583c9b89f018bdb7ab69e20211665310fc50445a24a031ffafeaf4cf63ae5e6e35a3147531529530b61840401c9e012363cec0c72e059cd6192394646e21f6a2564494784691b862c969e66a896b61feec5fec7be645c5cdde52cdf07df316e9c8e132f6c92a7528121c9b50f4a37e6863cd639a498a28598acedd8f2d20dd5e876b45b4e53f07f6a44ea8c85520c76d6280c19bc23fa3cbadc6ee5e391979d09ee2144a0c1e82a28364b9e44e5cb335643061e4bcf636fe2a8097ad184ae005659cf8d01a0d761c81221a97cc12e1472d250b08ffdad792b0452d73ae37177c01abc52bc744854d805d72a87e7d144022cf67cc7f67ac2db6223031a2224bb34c393a1c0039fafab4a1b1d067df8512e2364bf526cd01c225a5b8e163b8014e61dac939cbc4ac73e23d18409eb2d9469fc0ca1cc959f3098c19eb8f98cfea45825962f042f594e6a121eb7239568f13caa8247adf7cc814a68574922c69d0330c334cf1c53b2a14c611fe13b8f2f1c76a12d2a6eeb25509470569adb1425d16736eaf32d0e90145728a9e5b04d1f0a70401135ec51f425403f7271d84aec8861bfb952b8ad7d49d88e13cdde9d534539b91144e78fa540f09276e3d1515c1595d8fc631e2d24780777496c9baf937d853257be8e8d88e23f0becd8dc979ec2893966bb68b70a2f5f116cb9f0116e797f05c0bbe19ec92599e0c753500240f33c2b3cb4f6cb9cfded0594fd5929ad505cc1fea8945be65c0b5a3c4fc086752cadf5b74d1ec9cdd9d7d98c7bca33339db0c4150cd14199462e9d0784f73fd2a321298151268938be326cbecfea931a872f51dfeca122e314adb97880d82121d69231b7a35248d5d1c1b122790e6adea6d4e7996b7e6f74043acc67949c858093f09ed813a477556186db8fc2ece97519cf6c9815f456b76115e3ab5d48cf4f574041a4e6e8d25afd4ee1bb4e437b9a5104683fcf154943f2a11576694577b82c6ec0cbe897420baab7b69d1e552ead12c160c3939921ce24548014b8fa676511cd99054b5d96075af0a04bafe919d2ac2e704ea991450f60da621815f1a2bfdfad4405211a05ecb0becef35813cb15355696eeb368a6044b1cf1129f05f72ffe0d3e6924ab7d519c48d5046dd041252a5847eccfcd133f10416c246578e5460453e33c2f96485040f7e84004093906bacd3cf0dc4b7524cd810a9118e1fc11085180f34389da4ac039f45ef7d736e464fa431ccf0d7c83c7d11cc399d9394c8ab5fcb2bfad8a01bd81801e0d807099b9d33e61ec9308f42f54cd63334e2a499bc2c7833b0d9bbb1e99fbd0617d991f82856ed46f80a60cdd7f137ce5992da2ec3cc8f9b1e0dd6b9289aa5c073b9cb782ff61f550a323d0a1688b9c781b75b7eda382578074633947fea9a8be38781cd35ff03f3dd1710fbdce7b14aa2b8247f3889b9d84963eca76cdedfcb07d49985797b2756e17b93c11d88d3d6d528001db1e6f2f5b8899d14bf3c47267aa92b11882d329f9c7fd18efb1f4a3298d55a54f63b5cd5c6f987314d0e3e8f86da5eff33a8fb899c0cb7480d65f52ef324a5a467b44cd3551855076f811d433a4b1dbe46546fca55f9a0e8ae5c1a32dea8c1efdeed4191bb5a74e23b6f069bef5c8425726e7d1d031a1cc28e8029b754b403bd1403a937809addfe0fed8af98d7b786468fd94717b28d31f5be9b0a9e0ba61fc7839d62261e646f9841fd6779e3b3eb4db6b51f95233121dd18ad5516dc032dc3aa390fb16441b3fb3663c666522dd66191b90689cf02d0f078743f20ad0a2e0374dd321e9034282773ca3ced3f636f7f2ab903eb92ff9104cc800dfd098ddc972fab051f4cfee8c7ecdfc07fa79827ff2480ffeaf38321b6d25cff11af3f7a5b5aa5ce2fe1a684edb90b04092bcda3da5488e13417c2fe49eff6c82699b987761333e78d469924222cb9fc05c2ebba83304416385294a37bfccc32449629ff42c33dd8bccae93b7fc29a413d05cca0bcec6e03523cbb3d231ed44da4e13365befec5c7e9a6b00ba9f23bb6b2eb322769cb5333360fe53e15221fac4066f74b58aa2b8e69f247196ec252621e046d581b3b35027ea7c5e7871c6c91f83f8c040921113ccf3b8fb968a6168d4e7f2293bba5fe81d7ac04c86fb26e9f351bcebbfbf9f1f15469f356a3f2bb3d12727257e94062549a78113fe3dd9c23e3c5d1ba31152a9c830c732a017da39a65e414d398935066032e50540887a907ea2fc90295a5551ff07df7e05bf18ee171c60504c798e20d0a7f4b7a78f527db6018f5eb085dd1d3188ac219dabf2d9cf30310e397ad702505fa807ee6003ab3fadcd3800162a304dbbf565e4a4584b1c7a97ae17c8640ca839bda4c29cc0d2d1d71bd4bd461dcab6da8d4bde4200c3b27676f3a434f65bbf0eb2b93951c3e07b86044c00fe8b505d731c618d9884e0ef62cf9f11b5bbcde130458874c9c619d6f0a5e75ef30d6c32005236f1bb5bc184ace659c7a8ee84ee48643fc5ec69f6b2806758970b1a16043a83e172f98f41fe623f565b4d2b43ffffd8e1ed3d32c33a103e6d5d900803c949392c32cb965bdd60d0933b6c15b2e77c99d98a56e5a01339edbc80be62f4340a619c1cd15bc6d39d595db5d44b20498fa356d5c810953fd12d5bef028b7b9c7ecd976d9aebaca77a6daa582b6c64f0ea66abaac20311859fcff3c9bd5e207d510160d92fe901bf9759f7c31f7a876c6a91869123ef09dfc7a3d28de792f5d386978580d478442a7ad7e4b5e6a162e7d452b5f26bfafc283ec5fd40f261a3fcffd5f59591a8bde1ab2ef460d11b75a6b1dea104aab6a917d92a367219bbc2b20903bdb196f4b5f260c194c43a98bf1b0ef95245004be999df92a026d3cb0314a09bed6febd0bd069b62002379792625c1f78708abab306e668c751563bcbbdcdd96970a20c71cf99bd5a3da46eda0e4d0bb9f6993b80f5f60c3c354465b8600640f6f5d0a1caca0a5f134c100d86ac6e4d02eb62473b1a8412ebce844b6341558978c1a16f9422c57037653b0f97cca3a9d61fc7a6bc4b50d26ea61099b6dc86a34cd6a79e15f7e65b7b132d8d61ce9f8fdcb4696e4f2b8d043273b625d025543297d8fe7f0d10ffcebe9c50e3f837874cd040231342745c84c04189bee40b5cece970b7edef53becce97c1f378f33395244dffed0900383b17ecf8ed411ab7ada6e87d1c39f2bbc981d461b57b1fb97b8866debd8d4c6d196c3b394cbb992f24b3979234e37761eda2fcf88db36d60fa994f6adbf9f5eb3c00e4f035437661e64cc043b13820f108fa5dbaeadf652d8d4b35a510c6fbe96fc8d9a67ba23a7b7e0f36f0af01cfa16b98cc01c553dd3e69361865b16c7e9b72d92e10eeb67e560799b5138ddb83b6a979a06bbb95be5181cd520587e4b8a9311cc76f51d06ef354d3fbb9d375e7bffb72015a1cdecb02676a84b51390be62de74598a33b9c892eb901c603dbdb43ac372c86e4573ff43347b1f811f2cd1761711db97ff19f83c4a0f9548aaf7f542a3dce9c61d4bbfbc2c48c4577c290b36c64d726a93a31ac8460cc74df2de05b911a09d9af3b50c6b7f11b0de562238d1af662b2484f3183461562594bfe2fa39f324326283f5f9109840a1f0adb7ae73129e430b4116c1be2ccd0b3a823bcfd6f31fb4bfbf9c88af8c6c8df7b1acbf96aff96557eeb5740e759ee223656f3864e23972b9f4d7b91bec322cb321e47fb171e08caeb83630d1a60a544ddae16f7ad179436f002ebd50ed638a7c7163b3df53bddf44f0d39acd461aaaf77f720eb7f750f3e20f0148a496890db6e787a292615814f870d76a7ad8d2553822b714a1efc6888b23bb19cfbb5302ff06b59606aab6549792b8cda72f196613f7973838a8bfcd3dc3d85e27fc51818d1a4fe1329ea4857a1891221c0928f95e46c0eb459a42f75601d93411ad01370eff0d9bef1ba6d36048a2a4596375544688e9e6afa574210a157636530caa1bfeaf10f5ecaacf34714b7d9bf1b9b6e6dca2f60265b773cf66285ecee2506c1be2be2c7317eb16317bb179109e464bdd9ef2880ab5923058b431e4caca4aeb366d04a049de20c519f06084bd7cf5d33df6922e7a17d8534fe761cfefea30a5fbda5baa3c41b48d2af47df249737efcaa35f112398799a98f4176f2251bb4a8a5fd2177dad5ce4dcdabc82e1347e4433e23d41f0431a04720c7793698f9b060903c4a13bc30de5546da78fa1857542c44508758e0f652cff0e5aa779fa667893ef46b47a94c946ae8056dc93690f92ec5f5e179cc53d37c4287e82b79551a82217ea42c65be7f50b75cc4f92c4e6832363e7304690ae9f1b705bdf84b8c62bda5b2af7b9328e81299b856a77be82879c6f5cda73c16b0da1ca84935c9ce3bb38aa7d156ddc173907bab7e7a4ddbe556b377fbe444da25e1e67ba0a2c2c977db39ff516d1bc633ef4ffd0de123bee613b6e78f8936199bc3e870dd3a5f8bb8054978a6f88b8eca730e437cd182fc30189a96786002d254c9f70c5348d9cdeda24f9ab9378cbc0fd14890932da314c54ea6fe0a9fc8e55d06a8dca8c65f159fd3d49e70b948b29e5b53ba551e62b8596f895cd19939ccf0defb0532e3827b6dfef6e8795fea1074f5e21d029b1d66044739987c12903e0c67070c8650b9fa59f674caac22658bb81460de13ded9a4045ad70b6923b7bc5a03c2e15d22d29474dbb8047b7e2933d61ff91f24d63ddf2e5493a19226ead8043f4c444735881079a5326e953ff55f63bdfb3395ff17789ec1c1ec5b4c6fa3b0e20985292216e8258a7aea2ca5272a2f5533b112f8b9804f676e82361bed4d6c9487f88eb4218242dd4a1456c2fc3cdbcd4dd8bb578eff8d44e99fb89fcbaac93ab70aa8a607631c7df3855784794279d52e8231271990ac583d01d24ad5165a02294acb83ed8a8cb14426e4bdc0de2d0b5edb4d16a8e8474831a9cc11664c31fc0e108147e85d9992c923fb5f060a73e4b08a42cbab354ee3d354aa1684d4fa884f3d67d7ef2cb8f58ede1da311f7aaa63831320cb51ff90eb6b41de9a6539b6ebc430838c2daf3c5e315cd688a8ce9ee3bf3dd0f56442bcabfa748d48555f09a4dda44876fa6a4e5425173c970ace78bc60f9919258a958620285f1442b074cc846a03768e470f8fccbe2df7ea0806eb107c9fb6075313fc180b7c2bcc43a619fd77bdc7707778b262701812ecda9a79146c7f75890478b14e0c0ad868a9892a653f81bc8f542d3ec32d7a4af3de092c82d5a3d399f8900bdc0719a7c32246be1501844a233d8fb441699f3d4e63cabcb9a70b175e22d0d973cd7bcf79b9a491e92bbfb7d9d0b4a7658679f9c42264e91662fcdf5330bee5a8d0e577b09c80a61465dfaff7366df791447e5dd79f532d7cd592564f1f77495285456c3c6f04e296b1eb8f651807741487ef66617fbea6abd6fc2cb16352f77767f168a68a610de29c66a36b769680770ed35a40ba57b3f96d74bdada3290ec164d387885ca3fbcb08c1ae5b32ed0028488eff0c9d7056cee237cabd646e93b9b7e1d41db5d1b3d9a5f13f61fb782634ccfe7859c89cb42850d5886f84b9311175fad25f703e3619530abcdf8f1cbf9192fab07a59f8e0dcc8fbd3ba506da9cdba2b08440d4eba8df287ee51fe81ff4d092debea5169418b606c40f0a0b3e12ac4689599c1e6a03d6464c10513f3e156b2de4c1e036f9b52f1d3e41ba7d03af99c7e26a3acbbd24b44ab76765ea05e62249a206a9e48c0390b8ed76970ee942ea97cbee74fed5ecdfe82c23dcb77084f61c3fe80e6663cb7ede83073cc815e148b8f7052843004a8e18a2f76c501ac0172c3ee969ca0ee5bf28802bd465bcac215982944858f0083a1fd7957664a63e3e50636e046292a30a151b1d16d981b84ef0dfd9c4a2cd3f4c79f0712d3eeaef3791b96f79ebe236abe1ce51913a0e18f83e0051fab411c6d8e32c0518544bf751b3cb1b03beb9dd9de3991858cd7376f5d2647ba5eaae4920d2de0df52f512c5b9cc6af85f7733869ad36e2c4a9003b5570395a5a950fb0c9540b2bd1732efcf7f3d5993fb3101a992f4d0d92ed4dc66ca2f96470a591610f24587de7a655ab3dfe78a5cbbd3b9da8e52d0246af8f8470e776aaa95331239f6d4722837680b38c7bfdb1d4d633c9a858f87f868707818f6cc2e5389cc58f005991b6f4d5a0efc7fce1275e3a32d3050bde67bb531c8264e7d04b097b31aca7840a35966732e94318b657cc0529eeff5e6f8bfcc54bb62d86b50e0b4585d5382fe1e52c33c92e0108f683f700b7619e50a0530316ea0c31fc021b5c45c8133bbbd305c75680d842f532b2938041e1e23e8c418e932822746202a9743eb317721ade5e76706c45d7e1264b2ed7694a31ff776915af258a4934f2b9246a8dd8edbeff95e91cf6306a9494d9e5697c31fabbecfc5cef7c155923da52c7fc356b65008bb60c95421026b185fc4a2808ad636e588aae8b527436e6ce8395072bcc5ea17f7139d4561a5784ad873a2bbf897929562b3734da216c91956578f89155f8059f7a21ba6a546b0b85ba9096cfc01d353513aa99f8faec798ba814c1a38d05ecce84f50f6d6ffe14a839881588c798dd3c266e4d62d120bea7856a64dbf848f1e05889546bd091b37d10a65a32fe41bb02185894e9db8e244ef5029615d315ccb004179d896f98edb381decb19e54feaae68a83e736cb8eac0a066ece8ef412d1ba5681ae481cdb1ac905751662e1780c8122786c78dabd52dbd981ec322ee33633326eef832969733638c2174b5e2ddd673dddbf11be38f8c7b317211639d66e8aa7d766da678796e47ef04c3e8c99edfce2f5fa6eadf05b2ad51d3415c1ca021d3895ee2a003b06f3ff25aca781d63c1a8bcf71bf28d2040a7411534dc73b1f57eff93347ae56b7fa8df1b5272b8aed83e736476c2bf5e46454592634b1aacb961dff4c468e3708144611f8864a22685c659d93d976116242fcba1b84fc1fa77520cc8b3c4075de7b4b8d5dbff7670c6656fe47a1a4f63633ff50a2ba43b512cd9aeb868cf68a4039985bc2479d4dfa2be36f21e9a324b4261f1aabfc9a44e7e75e0b3fe1075a60068793a759297729ebb689e1f13e21198196cc490b7482dd31b8e2c53213d4e3e92c8e63aaebe5488749a19bd23936ebc2b007040ae54ad470bd1907455acfcf62dfe61656b9ab17976990a7e429a2c04c17ae355475fb29f4fecbba618448da56adf580084839a20065c8487956f1e97846625ca851acb3ebf383dad34352649e1d5288af646075be81b51e8c1beb3f5f1309ae7e2296271235d3b11431f317d1d674ccb218617f2712d4ba29510981904250872199e4be2023a17c18a3c0d882c10f62ca116fdfd9b75f65264f5ede6085e33f1b38cd221fb20507807a63e5f0ffd138c2872bf9ab6d462419b47ba9733120a9264a25cf5519dab0984905d756305ec50b22d26dc91be17826690c556c4b977ac02b1348af8ff44e587e321f53f890df7b5af3defc7981dca27e1bb285a8a7a04cbab84da0090db112b7dd093771290c42289dd0234299f05bf054de18212d978254fbd45e9597d05ecb1aaa47f0cd91785ead39bb1c1a5bb866ca9984cc75700562081684a1abf2aff849ea3374cbd04c94ec3456fb833a1ea548a5a3166ec9f524d0b9aa17f2b88273d007580fa86d77f840ffd1835957f3c3745476a9b9f83ebba31f63d7611cece872c8ab5cee6ced7342ee6703e9ef9310e12fe9ebf214935284a24462b2daf3e1d330570f7ff008657688cf4f652537e91ec315d7f40fcd61691c114587dd80079e203112b418d5b9c90e43f82a685da3cdb4a36ff674b61a2f56895ff1eac8ad8d7c6746896c627441c8d22fce8a2a6df67319ca1dd769987a5fc173252902b3ac754db7f1f6397ea4266d340a889fae7d57da7012ead6bfd315f428c91dee9cca181f932df0e04d9fc3575e3aba11171c73819f892065a00a9aed74872ac9a4ee85478b14add5c791359d9d6d818624426f6bbd75fd88bd2079cdb82dacb897b305a0455c5cbcae041030903ebcac341f5157843a81f941581b1eeaade5e427071666a49243e8191c0801cb89eafba04bf386a14f9ad77a9a398337b29d042a0b444e4bbc61852f02c17320395f82ac97a900a10f05adadecf75b386bf6ffe6cb8dc5bbd556b61377721187f7e6aa78a83478de616ceac868527d2d7602322381e8b7deeefc12fc4fb1e16b222d9bd4d85970373cdd57a9e672ea22cc5915d0015be938a51b86a2cdac750aa2da112128d93820c206e167dce923901358c27738d15f1ada64e71a1e80d53d9041125085cb945adaaadd2d38dd41d9a2a3ec0e7ecfc32dd4b996875a3484ba723dcc0360370f5d496eebfc00bb62ece27feb7b2538ff3e9b758c0d3022d8e8a0ea140a9d4b7be62efbe19aeff600f6c54e0fdeec6309c7cdaa490d4a6a5863bb623638be863d910435fe3289cc1e0afbe36888c5979ab069224da5722604716c11997ea0a27d69d029f6dc768284f567ec3b6db50180bbb95f6eaf145471efd99ef009485369122e89bfddbc015895c4243995ee8e4faf2832930c956400d9037feaa261e11486c1a3098db586e78d7a6b12ec45337c5e6a9b5f41ba73b0f2fd8aee8fa1ec4d83b54a9ead531bb7e544a397093fce778300bfd0553dcad3f0e662d1a534aeeecedaa88489cc5a87dbe1de684d99166ef0ed83a0f6a232d93eb25741420a0043bb5d99e862fa93cfef16456deeb5ac7f417f98bca6fe22fb1535ed3661dcd43e5193ca789c6519114d1e831af6cb6a2b9a27a43734263198ba5114bd2b9562b30c4409236f9b7c2a82581fbef708289d02e26cbb9af2b1c1c1620e144f54c6a327fd51da4778ca25502650e6a0e968646344c0859a0b40e72441f39d7b812a51b0d71a765d37b01c875673830eb0a3873b7abf69f4aff8815c10957b40eb675692331c78dff7e10e78cf07e6e69ac59a2f137b01b4153b28a000b8b772c3b2013bbea24d62959fca3af886e6c0602f73fd4895465462527f89a6a6257196b6d1459f3ab207758622ed7055942408ef248d2d71e29b24141f7f8a6a3d858f9488aadf7424bf306d6f31557826c44a8c503947475bd1688713fa199c8dc8ab423af1aae6165e36cacaa62fe5d37956e86ee7f5233d2b8abe85169c0e6df2fda23a96e91a154155ddb6d886aeae5276feace63134a99fd1eb9230fff52ef6354d605e99ea8653017293165f911b8bb2d4b7d5c3ed5f4d9f59bf3f1389445bebe1c160588034ca3d024bb767f7677437e130c998be3b16fe9b71f738f096d34c030a93ced8e9843965a6bf2d5439de6efe822cbaafb3eda8d44360df5593c80305787913945ab04d97cd99e578d274da93fc8f87ebf74a413f3bfb1daec562b68dccd93701af65d69949eedcd275a4601cdff163f5365141f2a5ef7c1ece523721d67533aec4fe53ba93ef98aab336091d3e1e9ab5fb6e6a34082e9347abad2c2ca818a2a3b353178ca55f93cb0a24fb1e96a36f4efef0060ef213d6cb99c4eae022ca269a70091f5cc8acb21c06d5030989c9f6f9759ae3ccb091a66e085c99a9ad8bc139bb6899f544c1aa32445e017f1f2e4dc086b17cd5f178cf88f4aff9d937dcc509361e488d4352258d0dad93a026b1e5aac52901d2ca8521e251afbbbbd3b171f0e3ee60d26aef289062afa80efb7a6d797737cd3f6584bd09d93944576f4711cf59ce3973f8f0cb50313c362116c46f9da81ed59236516a57c77003efa74f111091f9355f960ad4d313a4ce35b8bd086bbd6e68a6765578406df424c1aef0e24fea10fb190fbd88704e767201028edffef53b576547dce0b08bc9ed7bd4b5203f4399a8788951b31df787de1a4fce68820008976cf801b0e88980ace93deb518e9edecbaf398658183953aee2b2b2b16291778ede5e51573b0a69be00ae4182eb0c3fbf5dfddcf623c472ed39a3893e571d612d86b166b76337a5bc0ef84ee5ce5ad3891f4db4de40938becce236fdb363d5ef0699813ba684bb041845f2eb526568a83bfa6283f7a76223579a53e17344704941e8db20f5c88c71378696be008d5a6cc3aaa6fa73ab1805ec22b49d2b7344af8c05d8e8eb52458276af517b2772cb71e8c911a41757a05d96e82a352936637e7555271bf5804338c3d305755d539a0c49a933e1c4e0e3111a518e379521fb2caabae725516c10c10e9e0c80049f8996fee07f35f349b5ce5275bfdefe79ee052f5dfb1ee81eef0a7788a9cf8e7334970346aebc200527f13d4552734cf46946fcd19a5c2b214e451630ecebb7e4390b1d98a1339a0f5de4a21690447836600691c611e1222b06d56c5857de219696e9e1817ab273c728a0d835e0fb80b60cfd873cc1ad63bd3e9e1cd3155225702e06b564df0986a227c75da9c09091ddbee8f4b974984e3aa894aba68ecb9a33a83ea43b0246bd9935d1e037043a9dd6949b55d13ddab07eb23b0d00ceec72d3546d098ff799bd52e83a497246c1286c7b2ebf6cb35cbcae351d60735d4ba5f6ab8e7ba1a8383c62d41251dcce8e3b184c71b75a6414b954a37dea7d2aaf22d4362581b0eb0b17d649f5d46b4f94ac9563742762c9c3a87ea3643350e937244f51c8cd93e3cd8c2cec0220a8cb385b76cc7a3a558529631cae7b6718a4a6ff66b30fe273193243cf6853fcd6ac4e7e4250a1e997674a8d9897c0e0f0adf9f03d4b3ad16526e3d10d33419020f2631f592edd4f53adb632cf149ec9ef64177ca9ed123949cb31cb863568647ab62c06855fcd48b81e354d98cbf6ce59b4c589af7d48d21632e8aeb3e343102475750f6e01e054065757cb1e6d25f0bd9b0bd47d62ca93ebcf56d4b9138db34793fca03a0df3af3648d711c7f860c01bb58189a02607f6215fd855e0a5f1e098d70f2d61261e1caeec56d4bf420cdc3cb2158a3a35d76cb865965bec8d6b69fd46139dcb93e1e0cde380b112263a413be3edc0f99d3aa151bcad5f892b2e269b04141e2b677b3d10a4c3e1db07a1b43eb38c4150f908b962330019015cb02997a7f24f214f10b72449b5e27c03860098a8c2dade9e829da94033d4114a2fee42ed57be3faf86ed7a0c559e8cacda4de34903c152aac9ad6ae6294f708105b9d7897cc3928a7af49bbf66547dedcf0c569587f83809f80875d65f83e200191005fb601163716d3cc8ca20b222d92aca9e15901fe24422d2006ceaf6c43a852655403c63b892690cc59d853d389c0fb6b8759d2906cda679357385e00ecd591dbb7c513d052e1c676cc67be8e5bab66ef434b1901228d554d2b094509d5aec15cf27a5746a105eef087c4601e42b74eace87da4399c17c8f2dd36e65d253c1b8fbbe65d850312a3c88e6db7a7e4096ce998f7f1d73ac00925d5a0402561c609e5a7c2349d0f5e48027e6ca57582767ac9249e50e3823645135b995450aef8cd90b2fdbffd324caab9e41642b76f8ba8d572c6783a8b940bdbf36a89b72a71993483b713e384b46968bf69ad0ac3c6d8acc6ea6df713d18f49ba92cd892483baa7a9fbf183b499e6f2f7741084cd8ff1ef0e53e3a9fbdb6f77be4bb65c627ab719b07bffe7d69b09e17ef576aa35a463492e73c9810e1cd4abe3c1de373fde6c7d999efa019be08c533644a5d9f8059ca45b575a613ca62d1a2125472fa728571c801cde374998ff5de2a2a3c68b52f18fed1a923db72ce88323c0594387cabcb5a0fd86f9796d062f81d13221d7446cf27802a3b2da6f7cc59a9adcbb2928c400d641c2cc9f9e9bdcc2466b5d845dd546a184e579ff4afdb868065551c96e0d583eeb8feba82ec2d801470f5abb0e1c8cfedef36d01fa698664f2b143f86f31151543b78ebe7d8bbf58a00f756d932f53e54e7de9df52cbe72207e8dd108099175c886c7eae2880d2e49a6c85d1f28d5883a931dc9c629b70c5098de23e694a6abb23b0bc05688cd6ae816999b5bcf41585d6ac6df4d3b36c69b380d92f9b19c235a7f76f29da404581069acd6acb6863065bd979d561fd333ce10ff3971e1cb3fd32f5e6b1e4c2522f99623947a76fde820adef0632505","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
