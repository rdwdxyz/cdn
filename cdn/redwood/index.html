<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"629d080d0414e9ef34bc8eab7c66d0a2b51596d85f0c5018e7c10500756fc1dac213ff061aef310ae0bff8fa62847d213a96fb7d5314c8b8fc349be8ab84e1954f7121769df987420ec0e60163dfd51dbe1774a4c90b8d722798bf82e620d3be639865c17643045884a2aacf90446dccdaa1c26957ae06b85fe873e5ad7596e74c23935ea9cd2cf648a91d3624f41cffe3bff5005b7354a310900e62f757ab78315d5cc6c03246f8ec51ad4bc52de4794c5bd64e2e35c8e704af19e54633da4362dce0a112fe1b7187083262d0a9378271d42c81eec98add6773080ae68ae66fc09e7dbff20c386ac14d005fdce9338c15eda7a15549ef3e8506100a929cc0fd72df88234f8d03c545af7c34e96755e27c9a721db0b06c97ff4a68524b67f980fe79c74bfd3c39fe17e985f25b33dfc774434a1bf80a62dc030a6f0f2e7d15dcfcedcce3db0e7d25f1d555470fcacee386b90cd5927fdb72f881210bd44f60510b7382e1797b1388fe5260dc652b381e40782108161cc65e7f610d14f47df35b91b77a8ba8747d0283e5da30d14f524fe988ac74ee3b135b9304a3ac6d62ef321af4256a0a6588ba18492aa6978b5eb9877aae6ad9adf8748c75427d965f2b0e03f17d0bbf2b45add976adbf6618203f3d7f744912a960a857d5088a326e607d981e376b7f1f470b974f7d05eb953a37ba0979a54faf491c92946eba1848117d2a219482f5125f60a37af779ada2472b3daee341a209371d9aa0b0b91a4aa408be5c1037c897564d14b391e7ca7b0fd88f1e1157dc60ffc9ac59ed412f63ebd1a9717ed5ce6d1b9cd01877019300fca986889b3c1e4c6ddb5bf33d6a23c1ac93fad1cdd6369efb40fae160f02f139bad6fa95fc98579985c1572bda12d1fd9570a8a7dbb769e4ee07e4eecdacdecb08c93fe38ebc93d7eeada4f00f1655b4c3062410ff43961747db708f6624cc5651f219fb526df7e411c5b9289db03adc2535602aecd3159340e4363367111ce0b4bf30e8b5d19a0df71261038628111e592f89430c28983c7cd2739e150d8596a72b95fa2440065d926041c110f83330029e7c7ccea8d627b3e403efeb72d283ba853d1435fc9ff97579c3a50e1e63f9fbf6d9829536d6e385ba85ff3942cdd4d4f2e802153e40d200142ed4b2588a4d987b50463a33500c72a261b60ce1b68593ff48248364c4989c719ef25f985cce8020450abeacc0ce53044abc5e7344d28861502e86ca9ee063ede8c26200b4186cecaf1bb844229763ebad0a62cb36cb25a5f8126e3fbac852d374d4548ae5d65e099e2b74b6f2061e6633154cf09d4c3d73339c5f2cdb11ac7ffd67c9fa5b1ba09439914a0a7e82edd8be8a8551acf0194d8b9477743ccf44bb1762bcbd99affb698882468b66ad65444eacad79eecd0f267c73e07da0924bea880d9fa79811b32c72f8e2f38938d07c27d8104624141e9ae1977f8c6a8592d99da9199883f70656461af649cb3f1fc2b343057272d50e0ce5c211857268b17dc66b4f5e631fa8b6922a0ae156c59d0644bdfaf7e2275ad0bb8e47db32bcf747c01f6112315b2cc68cfea0112c4e50a7dd62a4cc98532f9bf77e3a4c9fc5fe3f6912adf7da14447c62f91b853523136bdd326fa246b6d23803be266c1b0991fbf3d069de5c992b45ee979c675ac5d01d5c7e85fef78496b3e439054093714ed26c7c4a94cb41eeecc3f916cbfcac9227d4d552c936692e92b012d491dde0886ff9666abd6e49fe6ec3ba3479e62d621de3e3d4f62981ac7b2f1baa05d1fb7707afb3e30f341731eecf2b07a17207175ed9b9b477e0fb793e918643e4048445271ff58fe7deaa8388633966c2a6816e98aa3835b9bdb60f124749c89747f3076c746d29903a61cafd154d73244d323c970bba77f63828179bfa88e5576bf8b82173bd9c6fc4286474edb7d0746506b1bf9b402c65ad3431ef8fed831c84a16ba4a6040cc8b24453ab95ac1f9a0d3cad2c677160023a5df50ea339c9729400f5b969ebea7e32368f2e3f1158f9d5f140b98cee321baf2ae9a2f0525640ddd0b686be8a7ef667e980207b2bcb1a345e775ca0b7b43f938c352ad2ce320bca31e5c753fb42e397acce24ff5c832f0e69f5cd174c2413549f461db4723613b4918d3d4e4eb1db8eada74a863a0a75068642e552349b44f41992f3fc82f677a84605c0bd67592292d8cf1489c38907246804e98681396be23ebb9a709bceb2b92dff26f0a617f755d5509b5084d64d2348c4cda6d130a721eb143223505aa61e78e6119006d32b9539a86c7625d34413a46c40564df65902102ce793f660fba9cf58504f182c484af655e164210c752a078d86a89b1d8ee08909b4112e08f5cf3364883a59c711744757a3d1ea3be6345f4f1c49009b6e0b0926938db37d13df2c43a416291aec56f41a3977a47031ca13cbbb76e82290f72de032c3fefb1637a9100001babc3de343083159dc75b5f8c4686bb9544ee78f3fee3b2be43fff2b8b271c80fcccc20a7b5ecb3b0e6a50529a6e23df8236202bad640d127d93513ae7e91ff05f3dbb7d178288a53ad9a6217daf24e4cfb8fa2369655bac9b251faf537ccadd059a33bd64a359d42bfb27abca9b0c443555337be2aeeb7f1894ea2c37e89221600f939f5924bdb59113c82c570959f9ca21422c214e6e473ca308aa7e59f59cab05fb1d68ea206ef451bf003665f3892e0b9aad0f1f477d6a799eeac3c349e21a7ba820595b6c72bc75a9a40b66706a05786a58881561a6220104f02281d9a7b727a445e828c03592188827c761cf57fbd2369fba102b15ffbbd653439266eec27bd9c84a22e1b66817ee8acdd7762a5cfb6504496b4a33d29829aea5706fd310ecc167c87d79b70f43d236a84cc45ecd460e1ae07c114842eefbec3868fa9d790d1c81cffa82592241754db85e89f6fd43305afe80015fcd731988ed9d3bd826d4c26bb4a6eefa41d9f4636c418d457ed8a59bfbfe759712b5f9836e659d472894cc19a2c6076104e36f4fe675f557a0d30c17df77a7265a98e0d94130733433e88cb15e13da269ad6e8536143ffc442e2a70a6af5e053fda836a1a63f107f0f41fc55d26078a25e4c5f22c67229a02c9f58a528b36ea5adab94f3a3d9c09aec797fb7033a89e58e00a7729a7226532df3e3f3a3a1e5e564b466d590b6076ec8794259385f9709710a5ec1c47a42f2a2588eb5c1c7d5392f67a07c276fed59df59dd3e80ab14e8edf1cb7f06b96e5eaf813037c204c546978dca0aaadcc7d71d26985b82f2a7f18aa52cfe7aaa6b8c665f4d5902cd7b0cdd98533611f2df1ab130cf1e146016bd2ed0e9c78b34b0f42588623007b807c4bfb0d259dbbc7ff2066550389b50e5b521046a1ff04f7af056c1f15f3549c2abe8e15d4e2595ff0f64c3617b5591ba93d17071fa0bcd08f2745d8cdfaebbb1bc3a998fa7741aec76d2b1d5582db2116b0dd6b966b65a4f8df19b22cca08802a2807ae7bc6ee7421c35b391924c271b811b4159d539b0e6320daaa6efcb0bf27773e377d03701b1319767cf20ada00ab038d3d75e2a49fc20426dd6bf51a79a8423b0aa02838d3d875c8e7163c8c9c65ab934631aca8649266a2035a40546f360563b5bf44208c7b9d13e5d6f2a7fab93f556ee0ea478f69b887e64676c63f092b3878c90ba03ecf809ec03616971d915cde9f832e4b5841ca80e8e7a17c0b5e54eab9d1bff419cdac4879fe1373d950d82f3c59b48350c5aa5ae3a13150b27beb77438bc286b8a739d1fb705e621e3fc39cfd0c7f17f2395b2a6a41fa2dabd87239b68f73ecc5211050104bd3b09f2a1924e80f232ab3eee247341e5c8d7d6f791fec682d4f67d6f1ca202c35c42f23d47436c39237386c89c233c7a2fb75c849d1cdc4a224ff1c5090a219ae724fced5d303b53f716e6cc97ee432a52b87bd475081373b830d5006b43519e474ea58a3224300f2fc692c1691644935750ce6aca69423af0938e868fd07c1c8135765902351f7900894b854ae554764de68fa12a27ba79633c703183dcf33343c379523ccf0dfaf0dd54e1da0f7b565d8545e700fe7f57ec22f135a829e4aad6c3604a7f5649725d9fe2282bb5c6609ce57880cd9b09df781c048f9e6ba346053d088c5a22eb1ad69e851c7c1a92c8f68da58f5bbb0e86871796d0156610b3745d5cee9f452262cc8ade37b6ea8bd7a2b78256f953d47612de2131dc7734f6d40f141caf9ec658f15f33bca7df4746443d255481ae4d34b09e184d64d45a9a11cf717bc5b56d2a09e67b58472232ee0360cd3f21d554da76686bbfa26b63ee3c87957c2aefd743d6c4d14fc77aae1514bd5ed859c0e5715b16ad767f1a2fa3c48a2c3097114e77e410afc50e761d2aa0df982634c433f36572a311ed909b0c9834b9d8e394635fc9f30774264dc816ffd7d21ded99dbf269a801ca3190eb37433b4eb6a1a8d19419966f96d7790312c70646b86d5d273e0e9ac04499fce660870b7dee2cbe3dfb77edd272bd623f35abcf6dcba142f8267c1e84a35af64cb8c9befcebe0ea3ca4f6f64cf1fef678f5fdfd3bf01e94ec0f221102dc27cd31b5d04ad74cd5629243e60ce58f4640a4bbceb1fb62499bc1a49a1a1ed1a7127a7fe9e1a5f7612d65f1a17b503baad925559582cc0bb6542bf36d9c35ef01602b418314ad1d489b39587eeceb916c5b705bc73f69b118e7bf98a661f3e3809d8479a8c8666d53778de60ef5e26e465b816256ed20487f623c3f16c5ca2256fc76f23bb022269467503647bed16ad5caa07cdf3cf944a192d11c7c8a9190fe99f66c9d877400b7c71f1652b3ec98998def38be736772fd40a08d0db347b89c6d7e115b3d6478e77a0d9fad4e0f1bd77313177fc95a5c32088ed1c14c8c9baa84747a6ebc64c75002d0c94921bb00c533b0a49cce5d845f2b6dd0f609fe4606c646dd0b06e70ab7308ca495ba99a4a5b0ca2ce3a477c1f724f0da751b501eed0a10d658a5fcaac4abbe07848ec76f892ba081bc939cfc64271230244f171c75a5f08c7146ad8d3c67749c5a802cbc7ee942ad97e250d8c07148f243ee2538a8d87684d8d40e6462861009129f2aa67a0c3b400d473d0277f9992b84e3a4ae0c51b8886a28ffb724ed2d021bc39fcd882b279016f0c2115aad561d1801996b462dd63c18c4f07e6e0b7483eb31683a256aa00dd901e0bc53d6f40589b77ee0f561dfe3a13fd83c9b9bc9aa18d3b3f7a3a9a074ff577f932d71f8a92017585717c87f38d92d30e7dfb0e5e8233a781a52f9b38e8645d821c8457140272ea99bd1555525e2028bb91a4d85ffe938db01f9dc3c4df7af0416b50ccee1ddc31a6fa36abf97c8905171ae02f1bef5c0c4395d62ced289ef74a288d5edee22c48a66d2dfeac27b87766ba9d7c660c9b30931c5505891b2b552dc43814dc003ecf113046b63de630beb701f679223c3099786d7e61102de735c213eb5373151d4ac1985023f5db102647278bc116852b101b140c2c90add04e43c7722f129083bc2f8793850103fa9d3a461d784a6fea8975ded73c9f7718a5db817ded061a88b40d4bf828c958524155aa98cf4dd73bf12cc0d191ef21f1ee46822688e4aed4fd8c4b95948b4382a8864db9a13b52996e3d743b530a1ba26f7a56bc63e1d7647e8499e86b81df8dac3e37f37d1415aa02abc869345b60275e0b2649446e484d6f01bcf679a1cdca985dc6d0d93b739a6bcb01a58b021cbdd56650562346689905f0711e9c8c96c77b297c533afd13d3454ccb971c8c224c47e6f0b2faa961f9a10c8f3bad058d4a29b25c9c7237b56b2dd38548ca7828872835c03256ed00486a22a97d0939ec74bd8eae0fdae40326764705a1a06e5fbd82ca7e589d39609d2474e484a89a314c43b6507e95cbcba5c6d8846b37e493b8125daba04cf815527b41a7ddcc130c6300b1af85d47d4fcdcaf9a2d51d900a110e5b3e26c4bd3ffaa4139e184c6c56207a26591879fb3d930b91c6d05411f7c21685db71dafd5030ce0b4d9f820820f311b233671c5417fab4eca9b690a2be38d140287fcbfccc30736b05aa5e69965c9f20e2ca6e67b8910e623b3b28ade81c12bea4b780a01ae5ad918cc24bca5a390bd8d75d60b2d65342b782024fbc9827fb4322ddfcd4027bbb47f66a4ffcff5d5ce7ae67bf7e93a3816d9f4cf378d2d096e714777385039e56a26269d43446267cdf6ec8c9cb4954490c727d3405fbcaa4ea2ad774d9d50423a7adfd4ed314c2d5662a2412a03ec3bb9616f9faf696bc07f7d4629ec45d58533460f92d7ffbdccf6b0fc371cc42483ddca2b840b9bd9a55d00a18cfc60e65e5a62172f59aaf817e8f26dd8c070e9cee03be65a4f86f6089ab418f87baa28daa872327636cbc2543d2a1e6ca4838c01b53163e2edb5fc241989c500094efdbff146092458c25a85d60dc87a74eacc849c7b0880179a012967aac507c58aa8f9dbefa6ed96dc50ec3f9053e64ebda26224d23968e3a42969fd91cca2d77f5561bb8aab05605c83e411518c0f6b234ccfc498c7c76b08f09d07b1cdb1d7dd860d84541c1b0beadc81e0af4e9ba2aa5223657618a7aa0d8f0283734ab64bbf239fde25e02760754773402430a56edec9f1614d361fde2039d0372c1b0cb6ff095c27f2aeca7bcbe69c53d9488d66c0ba14db79e95d1c4c0829accaa17be62f2ae18a446a06b45b6d9348eea917166e21c470ec03b6ce972d47b67d20bcf7a4941124b929550226402f755e602a4eb2812a6df0109b2710f38e54d946c2d872036e045e64a5df35a60efcda9c479ce01ccd41c38251fd90e3d8927167a9fc93c8706f1cb958f48d0911988d7821fc328f4184549402f359bcfa39009b1d99142886a5b37e5e266eb89ffde82b13b7d16498da0caf9e78a463a73b44525d1453d6f9718179e6b7f347a27fd8ed965608012b439dd3f92c20e7a6c57083f01cab4315b6b6b20e97cc76b5fb2bf9f55b8975c5c9618b204c0f1fd16e074e75516e9bec72d26fc8e476595d657cc1ec25bbe9fcae64d2bb1982f4559cd2f4a35afd8f5f3958e5a4c922235f305543feaa594b3902ba495a97c259e40adb83581084bbe797d8190b807b4c08cd502453bfa1a4737595214dabd8c5973efebc7a7b120ee0930ad6c8000e209b167fd5eeea04c78281ec3907ba4c3ec89fe93693e3a77e95eb93016d4a6608d268d2d3de98487288efe524d6d3d3227b4cb072fc555d918236c2adef9ea667d1438e310a6e4aafe6a371c7dee278265799f5d084f40a710c9f5d66280cbd490ef253ebeec09a526b259d7cf38b11e31fba608f8ff5fd221de8b52781a30d77d2902d49553903b5c4af835c4933c6eff9d6c3fab9112ed49acaf0899390e64463c9d11f2c91294d5c1e8860f2324af04e3deb5524544bdcacfa8b7b6f93f00f26660be711b7cadaed90f856606acc9a6d3aedf21e8f0ba26465d82cbb34458a6bedc15277bd962cefb0a85ccbf2a6c9634f2c24c3770c391dbaf7f2e3115342a315351062cbb58624fdf8e02237d11047a886bcc5459d4cbdd1eddcc1d38bcaed0c9a1019b1ad1313937b5e824d76cef0ce53774f88f11d386c7093d15f81e77ee72d9e9529826f1ae31bc7841105cb27278b4f5fffb5887ac46b56b2eed0a4d18c6e810bb5bd18d4242a7967061f3cac2bec8399283f37533969e437f3f54b26cf9c2cd4483f3605359c1e0370a696843f6cacb465f8ee9c92696f92e2551b2a02a4efb77c37cffd23baf7d2ea1f56154705b491d486323291232ad73c8266287ec197ee1ad27811501b00b5b17841292dace3f40d81ed7e9a3b95223072b004e235c11a1e5a32ebe02773bfbfca50616282a347c7c6cdea4138f3b51b2b16725fa242bc5a33b304bd06873d3c749c4744b4836fdaf2a64d889a0eac94c021fbfcb6bb0abda37e6c1d4b5ad33ff74f0886f9f019d23bb4eb15fc35e56f807038535ab8118bd484d9b54bcb98cdb9f636571e03d0de870e6b70339e9e245401a2ababd48d7a6634a82b76324d1195126566c468f78be3ea4d21f2ae6781efdd15ef8ecc0a4701e07430fd607bd18fc3b7387f1e94d9bbd7fe0d9fc3209102880ec57804f2e27eb337e18811f019998a49f95b329bdce34ef6ea57bbea40d23ab39dba7e4d677a32f575afa37dfadfede2ea4188376f38cc20908feda575dbfb02df0c9177c80db331a67c5fa903c3483458ce948502152e0f2fc5689773a0bc8fd3e17b9d5f034ddc44e84d278708beb2c73094234c9baf5d869657a3abc70d268997f07ab75e561d9f8fe62025e0cdb09732fd1536835ff7db99320a6c34d817a63825a9b3819be6067f25c2b1e77c4ecf5fe9657313d3f65f096d3d535e7d20dddd93ba1ffbfd47004c1226590a8af60eb374009bf01cea06bacb2e134c25bf5229df11644ee60b75227ac5fc59ca2c74594d02b887737cb16f3ec58b3ff63573a2a32009ee56c69cf2abf50a48aff17f5d03f2413e604e3fa8b9c0f77837aad8b6528a126a34cc05c59d998675489524eda15568e4bdbda33b03e4ce6b8f21b807e5d39ddec6604d6cc785cbfa4fd45c8c653bb2e92cc7431a5d42942a03b96310bb64bf82c5e7c9d3b8694a120771a14c69cbc73a0ac6b18014335af0997bdd5969194cf4488040438c8c2ebe7f71e7d3655232fa6539c1746896a03edfcdb5ef81a60274f683844c00e66602a973cc3977408d07d3f13e7776ad62819952484c9d50c5a5bc934196929bd234f5784766d74252afc7484cc6f1adb4164c80a72f7d1f9c42ba77f80bd17b686d867f6aba9a375c384ebaf8ffc319e4ed0c8055d70f4ef3f1a531f9ab98fddfa5bf83cbc290740bc8a5340546d3f4abb3de36b6e098b794466fe1d3ba856a60aa612a2288dc895274d552420daeea97d244fecca5fe0e90bd7a2a812bc51cbf47ecae72dd243998ace065bcad1df503eb98f3c9180c636e5ca8e8c7cbe652eab1da9a6245bdf593b252ff56d957256b03c62dccbcf96b013dd916e17d57b51361d5bbee7b5ebabc5507dfcee7f2547022d7397e19bb3f0989dca2d82f14804a278448ae13dd532c7acaa15abef28ce699f33d96de2a6b0eb1151830ac802aa3f9e48ae0fadd36eea67821a9389959ad08534eb8bc6951d7a4b1b12f35c2ab49c52ff371e5696c1218a6b2eada1dc0562283485e3f767d2c048f0f307f9bc7856627ba99be1d74dc740b80647780694ad17a2aafc9086c9a0ece4a9dfd03f2bbdb9702bc630b8df2ca44a668df27d70f941d41f056cf4b7d346508f993eff92db720a212dbdb5c7646d500ef3945482da738d2afa23f2d67a07d5418bcffdd654af0397d37508cee70a235beb858e64ea0d808dd6a875eb5a81e7d1c48ce4ad6d1eeecd0d9ac60b638352fd4f9c98690ca2f0b69c52d0291ca7295266b3f5b99cf5034d798d171c8f9ff0052c0e9f713a5fc88bfd94124d1c72c3d957a54aad2d602d2a39c6aee182e76b41ee6a170d827700dd7007b60db07de1ba877f5f3aa53903e4f42867c7077084142a5ce41328d92442c99ea48f215f01ea14f7ecc56f8daf7d8c1c700d8a9cfa8c721e6067c9b05c78011e95f2a2e44e836dd7236cb75125e6926e6bed024a9f71708459ef69059add33a3e49dc74a81922b3c3a6befa424ff970edee31485caa4481410eac189ce16aea2587ab9baffd84fb2153a3e2a8065b620ffcb233341ed16a1a55ae9c79f55c20afae8246fd7741dcefed296357c190727d5bb57daa5365673057fbe9a434cba1e56dce131ede6afb0dd75aa99b81ee8651b93a689f50fa1beacf177043f8a0ef1373f34ddef04218aae35479f45e3026fd147b333d6bcc47c1c49b6cc90dcd7ac87a35031234c9043a6f2ea50e2a814693ab3bde12d75aafaf5774c7329258f82d2e5ffbbf44a223f66626b0784821c307bfdbbea39e862725c14314b6b516afe5c15e99a2aad8dd513902cb1ad60b845e07753aed2d883ef1549e30f81d1ad67366af74e2f6da9b8ded80cbfec4fae0509bab9677531875a180ab2bfde8786414e5022079f3f107a9c1964c564ad18ce2ba3336c02c1feab2a5bcee6687d056bff7830f48986242cfe8915bc09d07933046a6150e327166c65613fabc160671083b4dd91668b084922e34fbc9ec8bce512f4edd2de858c0cb04e3649f002c6f928bd32f76a700fd2edf8caed81e42b6813949b7cc2d152f1d075d3fbfa6c3af98ab264b5378c93140e2a66c7c97e45fce3e8be0b3452f1b4916bd0ecaa8e29508c146dbf424b71f401cc6e900063a726164874a9828a36dfce5a89600cf4b34546af22165c72dcb636a9b70ff108b0b1efd0e0df42ede2dbc9066437452ca3bbeafb52754fa9f066f29be81bc2f5ab011d80114ffea2394fe14b03b4349b34233e324d85b4528d1abffab7b28b34a0ec308b8c7cd419b12ceeccccaf126a761a197e948864ac3eaa72016ae6af3aeedf88bcb2f8c9eaf4bb9f23c09fa48caf67609f9a9591b8c775877cedc2511771497552af0c3626301499dca380aab459a7bf2f6987866ecc91e04b5aa94d3949bdbec3890affe0aafdfb7d8b3d1989d50c103f29f8198b3d66bd661d049721ae4f2301e6aae0d720cfd581120ea66d44dcebd8525ae19f24eeedcffcd9363f24fafa3217247dbfa262069990addb37858e2626e128ee52121a4104ecd369762bbee72b77cd02605429ec177a1fc2778862e5fcbb9b812aca861e0a55175b85d51a994683992b5231f276d73b018fd0b7bbbb9bd00fcd00f1b58ee5ea9f88b0bc216cfa4bc221f64557804a91abec2bf1f8095acfec3e92e7e294df45bc6f2f8cb8b110c08bcd4329ce0ba948d87fcbb3b8a86d77cfbdc92e4231e16aa4f4f2977a47e13cd47855592fcebeb975ad62b8c8bc31a5f9cfee4f532fcf7037d337dcafff5f1315a9374355dc89a05d7fa8f338d97e0ea46e4ca48a982541ea277a04ed83198422322c34afa3e7f87d31ccdb5d12b7751d80c64c894165beb05c411d949580829fcb2685af5a30ad51a3adcfc5e7411ddd71771372e01e9391c5d074cc6506fa6a8fe38f0e2b0ae3e64aafea1284ef3f53bd9d75f9d8645a12b3c694a1b8e06cbd2678affbe9f7a81298bc3acc0615a9d0aa68a6975f5193685e2998fd4cf57d0a9eacbff497dca9f8fc63d34069493f59ff0205f23f481460cfdacf7ebfa66c60729f44809153371b4e9fc45267d02e9b988eb845f7ddf36e25162a2bbade5481be1b023e5041d6d34cc039507bd79596c83de70a5e8779146efddc3d0c2d9cace744f93e110ce1ddbf07cbaa82ee8c0ec9376725c42b83d0382932793d496726bc16480d317904efed1da81ffc105237b34866199843d142bac97dbdc9087774a07e648fc689b950adb1f47c553fa3b03fa4fb4301bbd34abc56f9126b84bfda79664f1543f8f3f82c045155efbba9300012e716315929b463c702e172415adf40a5a3cbc117b947b6b93732469bc381f81dd3dc2298431d1717fcd09d3ffdd324464e069e120dbd00d67cde158989b0df6e1df95cc098af574e49391910a03c5dc80ef2727fab2cffb1d8cf36452c4cadc849a8495be39559ff715f6220ddd52360f9f39a0de4ffefc507a3727764e034129f11a297146e38cbd80f048239e7e00de14c005f77755fd2d683405d2722f07dd23246a21d56a6b7cccf4cce917df20b5bfbaa458e0c4de7106e06830f023e5bcfaf9797e2833bcdeb397064768678dbcc94454ac9ea1004d1d5e69d1585b1391c64dd688a59e0a4e45bd909730e7d68f8393cefce859ba0f1fbe50aac7b64228d5a04bce4ab42742311071e9c566ed42c911e972b754cb19a5a7f27578acb40ce222b412dfde51779dc42c75b775b0a0590acde9dde1fad3c95d80627757da002fc09764fc09edb6e9f155d1cff6c46db9fe9462e4f70bef30b15bb86f383901028427042794da957f860aac6a45aa22f658c9f8157f04b079564ed92710c4a6f3598364c35bdfb047e1e02a5c5bd99e21945cded51e571c9851da6959e69d50099f7f3f3c086d8ff514a99922682e3556352660d9e9b84e44280d7cad64be5f39f114e6e63557bd748423a80ed5dffee44d5422acede4e898a34bc64b8ba1b1009e71093b01316b1d11787a093881822deefefa34aecd2b0be625f06c0f79f530434249656abddee795617c22781ae97122a3b3319269468dbee909f5f1f9e96e2cdf38e5e25f42cea41afe2a1b8d3b8bbbb13eb8298816a5af77f532e2e3943e402137e247054bac635bf62d3645b40e096c49b966cbcc80f3a56cf70f250215cea56b6dbb78ac87598a2fc8080dbf14cb810c7a693f09d7d28bc5d28ebdef099af7ce92a492e63dead7a5e5662d1813ab8d17949a3a68fc2fcce78b609c4b3bde2944f7691412bd5a299d3192b5e063f1b002576c63d77c40e3fad24722695f346a3779230d2e593872f00a4156a0e1123ff0eb20a4e149310ad8484ba5f587adb4336c17f14684a6ccbc842fa9f25e15c8eae1a816e1c0a91197deb06865022256110854f195140b0c1c8330e813ae317d9e973d531b39e562c4cae1115e114a336a4d4e8e9c524d06a454595dc9c2b14ac7e9cf58878d06b21cdc66a51f35b9df97e407fc8f1df565c520929af5e8ebd29b6d52fae4d2ef9bcccfb2fbe922d05993554654b7b94c0553c7269923a633f9db149b0fdfe9c40e92ba0643feb2d18c925edaa2e7ac011c786dc223451de2a6a11b713e0a7b9319e35c803f24239f6073dbc80833ec8ba53f1dc1c5dc3658c67df7d73ce4cfd0a6d077c103d79860bce33d74243c4c234690416441fefc16c6a90b70ce0b806eec24d0522b5c83f69a4a6c1d7c050ca63edb2b93cbfd485c1e82552bd77d713fd3a8a7b222954c2be2405cb977b210669ce87cb91840da7f76c232a750b98d3c9faf742be74fbe9ba716f4d5e8dbadf663aa3eb0498b139f902d2a75188587a98771c31b446a146f16ed7a7c2d049c817dd01f4cd6cdd75ea3b8145393ffb6eac757c3c42a8d51e8caed4b85e32a4d47daa35aff4b4ced88aeb408541eba2119b8f049925bd1de824605d1d9fb60ba1aa82f66fbb8986c7f2f41d375a0933befc0c1d9b490d48dfaf533b0d13fa0928b82ecfc61808613fd2f7d21c4da4a7e0a70fa9039f6879ad4bdfa97de945adfa43592ebd560b2beef5712de393798e9e0d0398e3ee5640d1a116cbff1a8941ffa54f7df0282b5574c20321c6c81362829d0b25ecb5ead82d98266c130591f7f6df3329d1d55fc997b40cc5b6298b0948a03237163eb3321104534c50361f72bfc86af1537896e56f4b9666d1c6ff619d622d0fd73817185516768f911233fa96de4f44b3db0e6a71d5713dc92cfbb68fe9a78e7b49ace31201d1db8eebd91e32a33c11896b9272f8fc799158bb4c04fd52ed03c9dc429c0e078cabd4b435ef2d2552da49f4563f6c4925cdf6f3d33324182410ee731ca7d567a812380d2113cb03b3d4388cefe23cd1d096c677969c569b032a3ce382c63463aef397e6236a0b06c3644426f056de0f14782e7b48f5ad6684c7829d7e0efe2212787da25830ca46928bf1641754a8dcfe850bcf1d8f9f2316eb945b8c7eba44038a8756ecc780cfde43c6f36c1647785379423c5518b0920dccee0059d9917eb3870a0cb64bb024aa49012b3240eaa11e7520fac5dbf4d0115a065624b642ff1078ca6872862db7f5d304c4c434c7a0eda19613805771ff9d6deb71c3e43f4043a011f7b7f695272ae1a08b0fc73a34d265b470f1ddf927bef682b84cdf89b892a416198749c0114427643cd0ec9f74d7b42ac837d3e55360e2b2606088f5188ceab94ab76f0f4863ed17a86f5ef1c52cd8dea44f483f0bf2d831b59e13df02f8a0624dc468cdb8b874f6c1fa1ce778d71ea9a94cbd1a1240f66ae389601b905f618c80ec50bc02b46a2d1a540e5e230c6ab2b533731bd4e3f6cf209cb0d11148cb644bce133d00f837c61b56e44d6dd221a0b860254c26b61cbbaee4049ac27d7d7cda4863bf0dd2ff24dd947a0cc6257ac427df435f18434943a1ac3557022e72d9ff34bd4ebd98d145bf1baab599db42cc4576ce86569f9e8717f58effc321bd24774cf7e304440f4cfe3f3a7996adaf20224b4507fa4cefad17b92f9db17dc3efb6de7147040b83e25c3ae98a746788c93db6aa58cff4b4e8ac9af680d43359c09a0eac9abe8d62b810bbde8966ac9e13978dfe679e35c438092674bb52ac090bb6b111134d5049461c8a2b3e16dda6c20b4985e0e0bbe06da469bbcd6be207bcc7cc99eaf1facc8907089f0e82ad23b1df8f288d654ccaed72ff405523c7a539e33aa1a0da79136d82894018cea64a1332636b76e9550b376e3ed61babf6b9be27cc405e30998534d53f5ff432f9c59ac308d3e9fdd92464d0c0d714a91133eeee2ca939d51e93d05fdcf72c7cc2a81dbd836986ecd100da9534f508ce55ec209ba6f2540d88b3930f16361ebdd5cd1dda954ce2f4b18e0bd6c9cd6f4b028a9422c69dcff818f562db7b8d87652a0f28de2f3221fc10e2b9496d45ca68e86259bb46054bb509422ca317feb11f6ffc2c1a4e0572bd8e8dacd8728ee92d9bfc9aef7451c86cd086692ac7969992d9c317e5a7878cda88ba8c65bda04512a2ff1e7d00ef2f129d890dd69cb688574d56559b06337b6047c012564de0917bb9f6083fcab9335f0235d29b84dcd791838e99f1481dfa7ef7d023a49349f1b3a3ce3b358d875bc446322a420b8c12fff5890ad8c6613219b563c96a2371c82a8679511203b2ac05542b8fb563301c3119f8c7f14e96e998e94a842cd32d65b96db8c6d9bb0919b36dcbbafdbec4d11aa4f597aab0726261c5e249256e0c8e564b070d3a31298c89f23ffa3b132fb79d14e905946c10cea0d2e21267f82d6eeaf6ce40d170c2629bf7fca7f21156ab6a8ac11687d9eb319ebe243384c6db3c521d8d22fc7faf9b79b0edf5594915298506e8caf05cdad186be1b19d422f5d595b938780ef174287e46542041983930e6087c1a0dc0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
