<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a06a498b2d1c7a5ca626a9b7c98bce87c9219d9cdbabe14a64fcbaf65ae32fb4b5023e8b471937105cbbaf39d6f04f83acd8603da6d26fa7462e37f04bf3522d009e2bcdc713b1338e585d75cb6dad6267a3b8da1c8bdf2d7b9dba843eb49198b455497da4a0972dfba615a6b0b903d622e2b3ca44e04da45ef88743187b61ddf07911638906770401c3e44ea1163495f8dc9249ce3e5fb59f79e8403105b5f5f54cd99318361a4584b44643dacb5ee600b7a2554fc1a9a0251e354416454406caf418ebd67726774368193c39f4a7895be05e6739210a6b92588569bfd848f3b5dbd4df33c26532c21e34a0872aea935f2c8a5299cdcaf54b747bbf68eeb24d7b2de8633902d5a1ecd026d058ca39d391a5d62130f175177e5557f7ed7ae720bbb5be2cfc6585d8faf243360647d75d69ea0e0cecd7013e409f7005c0c48059b5443a67710fe68e87d6faf3673b749026d91332ac83b7bc311ccaf8e0d71fc03f346c1d7bbda5b21ce8cc69059a1e31ccc2689c2765ae68fb6a0c69a1704bd461f8fb137c2ac64541b9933d36bbef6efb13c8f03673882a12ecf52171f8151ad2152370454b9598441ec0ac416cb872092cc0da6ce5cb061c8814b3f7f015598b1edb130532bb4ac1e36251981b548593ee4985d9dbeb08aa38a0ae439d4109521e9e32500e6996560d9c192c039c8781055bfe45c6d4e6c2c7fbbedcd9ab4ff9d6135a901fc024d20683ba19a67e099eddfdfde62b4ae3b602103a101f89933ab933d5926dc034abd335092af3087fbf23048e0c7e58e40a995e0861fcfae37070b002b4f77aabeb82ed771ace69ab0a90bbe829727d5032b3c00854e968d380c0be1445bd84b67b09ad0ac058d3cb99159b4b3b6610dfb101fc5fe1a7462f138f741913f8a8141caed5cea3e6e071aa05aa96f938e079190a2aeeb09d963c1f12c752521bbc60393cf70adce59b511ac29a5dca371363c33b5da9a1bf1948401a089faa20febc8051967e0405b48ef45965fbd63b10a042f36ea24f8675f4ddaf4854fb144ee87c9fadc1651b042383744f67656b3fa416e3aad08dc1ddb575e11bcc19e36f2233280186104285c4c1c16e6e47379ea87b6b8384f5de7390bb3c189fe8f992c62e5716705aac8199ffb222e35e3299e4fab86230536af58bacca0479a10e2be2ef2231f4a2c90a7ca00cbda4c76a1bf33b35196f1d079564c358820ddbd2c54a07d964029f84e969777297a0246c0ddb354ce2c97d4a98a3c1d0f490eff3f621ff9f55008251d1911d2a574687671485bedb589b70fde6927927bf370d7c23a9d1be7898205b55b933187fddb276adff704dc512c5b8a7e6a8aeee86721baf7362078363f400ef257970343e32713ed672507bea5e8b7525a3448155ea0bf0f5af2626772c0f66140f6fd0790528fe6ddc9d2875aecfd24ec87daae751cdbc18b183bf3ae3eb18e8b42e4126cd6143369a23ed536e190a95a68a9d5413968a1a5803cbd0d4da3a7087ccec4d8640b57fe041a4299c2b560b5ff5914ff7ffe8ef15aecdb8b9e2b87a3eca090eae87af8a490d3d86dab7a0223e1f71060a76b9edfa29d265490cc4905f88bdce660b17d7a72c447750424c6f5dc4b2de912815d5b7ff2d8c1b0c89e2a4343d4cc495e3b27c107e8d836ef8e5b333d33bc3a79c7520dd704dcd0c9def49b56a12b23c630159f626319f0f25e482f4c5880bff2c60fb5653f86d97b054b0b0bf2e079980e82b8e150a03d2e312731439efcf3e271d7dddf4086dcbc6e47b62da70f6a125460b8487966039e12e367555a8ea6ea813fcb8b9c0d61851b0d20a684c2ec9423952d0737231099de552ac14ad8329ad3eb3a7d9a75433dadc282a7dca8468e9eb97406fd9ed13c032dab9e4ca7befad7e10acbd253cf3d4a2d19d77b3516b77e919893ed7cc571093bbedd685cab93be822c146cc639aeecadbef3559946f2ec7b92d246eb2fd72a3cc85839fe564097bb5bcfb509fd687df528938f52a615ba302bb1eb381a1a420beacb27e846dae7bec95f2f4622fe1e710fa6e6286b75491560db00790f3c10248928017c7868fe492386ea9a1f45c1839c47328c5e8dce16a83c77dafb7efa8819ab1271a279f825801fd10fa2452a6c883a1b2228228479cea3fea55251a53ecae151fb484efdcb1695012ee2ba5033a53190ad1c346c1f865249500811c779c4618826017cb3d4f7c732acdc5b63ffd02c0ebdf61ab973fc0601d00c2a033173ee9de0f02ddb2b7731efb92ed70990eaf9a06d2730af715d102b1a8dfa9aa1bc95e81e7831b3db4a3f79c5ed4a2c1df183ae52c286ee8125d646fbd6b2afd72781427708dad4eddefa4e78a56c062247faab43a11f3e65ed65963fe344e8091df5e1576784c958e94fea337b52bef3de20958cc5fedf5a19d0f2ee266db804355eba31b6cf35b50f5de1e9daa2a2968530951b300ea307cd109ccf6e0a3ab6cf71c19054c3a0b291930fbaab21063e7121cf0e7c2bb2e276d56da92d989df601dca9e3f8ba93dedadc9e92927619cbe43b05887f6b8750cf62daa75607475ad32b1035b78bb04d07c1d325af680bc00f1206398f41660f7a37aa1e89c6312b005b37b0cfb94350a869a384ef7088b7132891449fc3ec750190a039bfd24eef17c5ae1621bd6b406cd543b9d4da4fa1524ed10eee5b9b4e32a637ba4221b1bca3bebec6ed7937f46cd56394d73a300ae82c4bc0d489f3105b616c593023d1782261208e04e62f0ff939276db5320e3e2614d53f7ed7596506a00211da4403eb202b54eaf53087480deab9f06d136f177896ab7ea69f8c7ab7d9a66181b1e810fa792ae926c838ec332eb8c8dddcea575c2dd0a174db693ce923dd5f3faf68d778a80463f5fe3225d1fa09cc306383f987d8d56854dc38aa63c5728c09e2c5517ec85a3218dc82f8d0b6ca14845eb542ff1828abb2ec21f7cfd30b81b5591e177047b4ace8586ed21e745bd0c667079cbd2c55ec074402db1b4c3b81f42f2103c7e92172363bf50fd0f922839134bddea92ae57f93c38896e6d6c3ca616075024926ff6e812c5dbabf500636eb17339cffbb180d384ce2f59d2db734a7f45e475b4808cad4e462f0c1e5def4205373d6f3cc09a308911e5ee9b991308b4384b52bbf658ae909b3cf220caccbcc2cf26d0ecba2f5aa4a4bd0ff87a9294579469a1398f7c877f45f6db40a38dae215a1b143a5eff355464085d7a84375c41c754368917fb69475cd478a52a5eca952a7d2cbbfeff2a33e5f68341f24d1fe1a96140ffd7e567eb2935581c1590037053e6d4a0b6f63eeadfd56f63771b331c12ecaf39bcc2bdc51fdf38051a945ed76148e70243697461449322fd9324a93ee6e93563a7d5260203e05994bc74ec893c8228f733b652703a2bc1e7e136050363c075c21fc4764adccbb888a1bb9bd2f70b64affd0fd6a2ec31d62ccd033b271e7675743e1f0985c285954ba6a0e52b1a493606433865238067e0c9e6106f186fb51b3edf4cab40da6b1d299142ee9aba495b9812cd83c89685fc4df1395c54284f71427798a091ce2d67a7d99110d429eaeb585f831d25e65b2a5bd30ef842373d7f4dd07a41972f038c77dc35b50ffe45a9d47b0aef373916d0ec492493560acc258b46935eecea7f9ce845a311bd6ffdce1a27f406a8740cee33c1fbe5f6621a057c61574f8ec1ade6f43e988504ac76e55ff0d3967005bdca3fad5f44d83a5ddc76705e85969ec208db36b2d00fea8a34051d8f19ec2b956f4b9ffdb6431b0e5d304e180d81849ac60b8bd09bc66a64c1059140823e11123d2da43a8326c9d598777c0476d2ee25d70e15b585c2a367af4275eea82929948f78b2b18895325a1750c005731f0c0a001dcd660aa360bd8e6b230f457ac80766a99c2891a4e0340192238f4554019ae4067c27f3634d199a85cd099ae62b3f11962af56e44507d7a69f6de19f6498b5ac2f7031686a5f2ed2f1ff648449dcd8b26c2f410786c8dc8ca5f3f9d0f5237832bfcee5f30d0a181ba971d72a679f02419e4f95dc7eb2c8c8381687cebe823a2577c3ba1ad0c2b6a2ba1cd61e7f8ebd5c6a724e37a77e97adbd079f4aa6990aeea2fcf8752198faeee11941369941bc4cd9a92aaff36997aad7b853147b936e6fd458480305c1cb34537e6e05c80017ebcbaed2683ab744ee318e009c278f015e58d0eae006a231d69f8f4a81a901a720f79a9b8fbbf707f146b0f72d5a6e8f680c9806c2494bbf63a0b9971689a288433c2fd0e816688d5713ee7a423c5d4a95e96231fd9a65b41a5d8bf1cfbc9c59d841e2f106b08335d206b3dabcd2fd2d29bc3304a40b37e04a7a40ea8da6328f43a69a4285f1e5350dd2d5989f6c42b5b03efe3e838d62c95a12a31610310349c160b0afe73cec2979b7fbff98844efa6369a69bb833e92826f2d3912d886dfbef86950b954717f625ed3e67a292e90c4528dba74d1d129cb97acb58d88df343a0967c59863739c3e2ab41d434cc2258fafbf6020c7593e7f5474c71e675b8726f754b41fee3a0885ffba004446a373a748b262f9cb48e16068f51c7572aa8a6dfbd4cd8e9e5bec0b579a927d795487133a3b7e48da53307ee6c7a48dd2f55fe973dfa2feaeb21af92a0cdfda9ecddd430aa49a7b81a0d88aaef29893d24d097aaf9bad544749941ae4fafb91aaa51baf544ac920d39eea2490313cb045c62ce54f1b05a608bdcba0bec304312d9ff710449068d67a428d5abced51756af8b7b50fbaafa088c0249002b7190a82b5e0072047806e08b4b722eed73aa4f7d68340ac8ee7885160ec2aeacd23362c0585b8163f48e3f54483d4b84fa6b0c10f4d39cc4a6e76e4954ba21fb5d5e891e69998886cd0bdb5bd4565d2d83c815ef8b4ec0ee1551f94fc186cdbf6d49848af89f27fe601b13f07a2a4c94de24fc151826b025a87d0b3b9a2132922518d3828d8c72e176664b831ee7f9604c00404697627762a7a4709f747f97c51e642a5dceddcb87328c69c4a82cfc006db874201e1be6863c84ca7859801450b333bd9681bc0e5cecfd9fba34c56b43d0debf4234e2db48a0c7e61a6a50f824ff03da2696bb8fe762c8915c6f0bd90a094a6eb9d631f2026651e1dc72c2e628684b618d129194a9e20fed6f2b59b1d439821331ca3fe26f1b130c4b888f05b8631fcb8d3894690f3fba48e0d2047b1af17e1e7d75603460c355207bde17c1d346ba18d8c35386996f9b80006c85d29d435f5ebd47403d02aac94a1e4c963896a07aa1fd5ae340aeac9da964866a43092115c7652200ed3c93b74aed1253f3098132531f63cc6a4ce54f1a244fd87f1f384adeb34db2dd94869ec01bac44d76f9224bd538f36b4d916a38820d9a659c3500e7a6c0dfeab9cf70fa574ec73b2bc1a422ee991111c58589e079f9e98d47f20817abece418d89df0632cf381738403629e8bb319c362b14fd228dc300f54e3b49eced975df7e2baeedd123c52ab98c1d46cc78a95c2cfe94df5692b0e09b77227fcd045c96858e6d2c736db3b344636fcdc9397afd44380bbb158279829a60c1325ee2d9c1727aa87553bcc578cf85c66948d25ab4547d36e45ff25ebfa521b8d5bbcce3c26d73372952090f875b9379d08b416159b7e40d6c8a8753ba051fd18b03310410c9f0f4df215e253377c0f46e1f0cf78c5641aa7bfa72c6aad2b2bf59d656e42c01ef148f6c6dd20fd15679f92315ccf3db9ffebcab5be5790951769b43364c110e8bc60fd56b7f805e03d00a26740ff94175a2c1b62cf076518c62560e0800aa852dd8e3a0b8ab56e8b256b478a980a00d99d7f2cfbce434292b5b1bfbc65d164970bcac9669d9a8f7dbdf49870617942d8d9555b37e03637dd9954356b8a1ef3c1a3a4385c111047c5493980f7982ae0f0cfc708cfb12e3e06bbfb8e6091d2590be6e1629ba6a36ede3f14f266e5ddeee3eb85945a91b080b417ee5ae9ec753ca06113cbc753eab3007db32318311ce79df425c6ab6a2b9e978021e45e4825fa744089d1ba989ecdcb84b5d14a9c02461c28a1bdcc803bb6e1367a23e3bf4a603f62950bc8c38c959694ad65ade988aadbe05ab2c64b29f54a6555bca523e51245cd44dac456e4e903868530a7218913b6c786d5259b26275e09bcd649c25b8f465eae581a9f27cefba7794a4282dfd164eb2b366b768b828c62d3ce55faa5dbf53308a98106641cee54a4dce9089bdaefa658deabcb9a323a6ca80300e88426855776304cbb97cecf5f719e7894c6f114285af942885c6666c8c961d04110d6725d7b39f9605e6555a12326fb706b12d01ca9275211686fa5b1367ccd4c2b9a0ea49e59e02735327f43ae8c2d3ac6cc36fa5e00cbb9aa82705673ad7b5a3afb7ebcf603987f25a72fa38e531ec5b1b6a3270fb5807aee2e4ffdf9bb86899e021b47622d3df393d65f6a3bdbb4661dd01d75e3e5b67a1e94c859abb5168fd9406f14265c36c0bfcd1fb2a4cd9f91e50dc2358f612b4dafe59ddc2faf71f107d41074854861f32f1454600506755e5e650400e3c9e2fd27a3f952cec46b07ab1b94b068012170e151d944def3eebb78de819f654bc0d4eb2eefce9f9edf20296505cde35f8c8ec2628c3a7767e0bc896dd376904302da2a46b68de29173fe34267e2ee4fbeda6bbd310ef22e82834915248d79c6c469872abacee68677cf608a0c882d8960b08d2f6a921b3bda87d55c7ab4273f06aadbf01cb05da58a24b334abadfe739a5a87d4f769137f7493b0791d4171c6cff630a36e4dbdf991b767e7c9fcfae7f557f3828d46ed81cf700479d6c1aaee8270f57f3c2b18ca4e680470710f41792a9c55622b5338756cb54590169388b7a03206b135c8d05ea52877e23f5520af4f05559281272965f26dd1965ed44c7724b0371550b7aa42cafc4d23477fac0f3fb078a76dce8a24e532abede88583070e85e403158e2764c0b423d5f5dc25ea97dd61041a0f0a47a958b75fb5a3cf5b06e71ff3976ff33ea505d18c3634cd3e764486cb0e090770974955e773405a8eba288d2beb6ecb30065cda5aaee313d832039b7edd4a5d1b5a5c762c8bbedfdae9208263081a0fc1af8b4a3b20a646883c3c4fccc0bb714e42bea1e97bcc6c7d57ba21886d6b9241b42419e13dc800309b61afd31e73223a61b7276016260c341f4a327aa73357dcb38580c9a403ac44044178804e48f15b6a95bb43ef4a3123a879363a4e4ff48f5214fc1642623e8b47191636877b589b67bc7ecbd2b20fa74c0f25fe837f7f77248b3c26cf4631550af387f04ffa40470cd04d2e81ac554c464ad46fc12032576c9bd2365881e348755a1c57866cfc70e4815cb55148ef065eef05d840db827d16e7fe41d9334f3b240bb9d90299b7c4678239165a76625e6a320b5c76d1dddcccf2cd0404ce6d6d63b990e19eb3f1430fe4cd6eb280289d85a89dbbcee058c45da193b97abde7fa39b662fdaaa3743d87ed02e5fd00f9c80acbafce2f6019446b4c65c41f34da0ee0d10f60f8d158cc137eaa9eb16bce07808e653181c1a02701527986d6011cad7b4bee0dc1df658709671ad306e5e97dd94e99dd1b73bb3739c74c67d01a72a8fba9fdfe7f02233080f44d32b8e0b4a156571c55f78da232ec51f27a5504a53238b603b4f88a269e217490d830daac9715735824ab73706eefc8f3e7234cae18afd335d8cfde07c36d5af341f9f2146ee404d5cdb7b4406d71fbd0fa445a39f1a8969193a7283420d4a548aed88dfa5813d58817ff2e3791e5d3504228c293519b82b2daab6f2071758ba024eaaa39b89f0b84d55f2c2000ce5bae95b07c7ddc65cd1bf5a01f7a8c6506b6c112f8ecfa8e5ba8e8cc9f814cd3274831af9a78b2b7e4b5d4751b249cbb5fe7d5d61bd8763d1e84bfc1d948d4d7ed2c8db87902b440f3143f9b06b4e4f17388e162e3bc818a61d3c69ebb9c5df125fb4871ccfefddbfab6bda3ea55478c2a77f04ab4d2f2d47f66e1c132834f3c5f0ac10c52719463850b71a76a6c731ab7103b0a55cfaa20177e7458aae48e6f7faa97c045a1caffb556a2fb861ef9cdd34e394a480dd3e61ef953b58fdca0b0e6c2dd7eaf64bcab20558bedcb5c095875fb9d53fb4dd02441b055c3e5c642e23eff3f3eb4ea4fb81721d06e1966a666aafb2d6610d61c5030eed57396f905a9e67b9d8ca5327651d7b80a60faaa8945512816068ea11fff29cdf07fa877420c0e075acad803910c96249d096e75d6dce0b36b4707a94dd24f6f373c20777cecf315b41e6be14bb3a61db3362ada7c361d6f5254f86f9e1eb332386e32fdef3b487398f7105bafe84931114bbd95dbf880d1a9419d5d87b8134dd62568306fa3bce3f2d0a0425803df79c73f440f613b660cfdd527ae7f9f30cc457bc281d5f086f7bc6fe963b8879f1a19aaf2e756387adc59cd7f49bc2ceed5188fb2e3b5593a30238606de4131dfedd639ce31e371231d08a85db705249a705abbc93b44f3aa1d36f8fdd0f2675c44388d8e420572d91d3023a4e8b0236408f963436d40539a0c6fd7e329996a2e44bee85073904a8910ab944bf6f8915e818f278b099c55313d532343def7df3c7f826be027d9f8f9470d3edfeca85646ebc0acaf7496adca5c33b26b45cb7435295da13dae5bfe2dfbf1c2d0ebe0723609a95dc79bae19c7977e5e177ea5ffe8112564a493830fb7d39a8ae815aaa0363a06046acf5030777c525214e22a797f398506ca344ba51613f4e86b3d4b6ae35f4232839d6ebe838225a4d19c3b606862279e17552a2ed9d6012244edd871fe521639b82ccc9442b1db69ae9b53176112a270d28afbbed5460486960f357b26dc1f270b6207a248a04a59779aa97c2fe2263b997d600683a3dbdec50743b9fc217ede4dc256ea44ea26d77eb86c431cd8f5bc40429b5ff369c13c6f7ac9142d93ec6ba9b7828ffbadb0e90aa549c17c1b4f7eccda7d4a020874fcfbb1f2029e6f77864a2b3a9d4983e7524a83e91841b33834190061435cbc7f2995745857ded1b3bea678b31a3fdee37aca265717b730d0a1427e03ff963343934cf2db30c2902e29c95db965e1eaee7af7104d8ac096f285d308b9d761bcd6fd2a38647ad95dcb43980cd01136c7b03477470d79eb6af88bac28ab3aa86750945d982f0954e4e4ccb5968285d38dcb9345ee95e3f56425adc1f961105c98a9d209a3b4ff87e8c7f17b869373cb35db827dfcd00093cb2362e1fc545a63583c29e75141fb946282c9e71c73a3e944ed22f98a4f5839339f11153f284ae6130a3fc542b1bdf965cbbb27357cd4bf4f65dac66800eabca1e5329d477912abe44086a137d5017b159b7f28ad3f2c538ee7463be3fa288cdf7858b96318e97484d69cc378a092b35c8e3fdedd25939074c603c5925bfaaee8aadaf621d15efc8c830f10bde85f5dbc5a3e181c57a6efaaa91b6d38795a548e70a3e74c6ea482eb9845ae0c50e9ed0d619c933609c29b358efe5125a99979800398efffd10e35c95ebc968a6939425bb49c81dbcea941b9530378a05203f5ce2e4821de4baf2647df5f013bdb47bd92f9a358a1bbc1a40961112ea64f8982076c7d99e3f01fded02a8384eb33c038279c4fa4a5ff44b8421ebc5291f31044cbcbb14794612126e56d0a76c175c1d92635dd6e725db92bfdc426e368830c02bf6d4c511300c233c7cf509dbfa2e3b3cff36881773dca148c2a6b9ce90e84d1ffdb3bbf723890d08317aa9f568888c749351a3d94ef01ea00fcb1ff5dc7e2beb5a255c18b135c23b09b1fa641880ea0ed2546493b6786ea3a97b363552d353fcc392b09833f5634bdb9e4b1fa650ab9d4b0e6399ce30473a807140ab5b7134af36234e1e9dbea938f9f58827fa0a824a6a9eedf4de98bf6c894814e57dc68a85f15f600f683000ace63a4ac5841830fe7e540ba48e290c41f6bdf0434ae8f8748e5afeba356face68e95cb162a3ac4a50f3b12a8774b90d783bb4cb761a7442b52075e6f5eff78fc0b72de7083a9d7c83050caef2718673a5b02f62b9ccda5ef38919a30ae01c5645d00f74b861cc61d9d593968da1808b2bfe7f2087e011d4f93c70cbed5ce5a2fd18fc1af77f90793ff3e4c87ec5b0d22e805156cc407853895724b1e507a2ab838c4c9c28e8cd62ba21a85ba2fb45fa8cb076fea3b1b0767561c2bfafcb0e9c05973c73bcaa7310a219564a453d3f0d150ec5dbfa4aad5dbc0e73c2307efc6003cb334117710497dc9985dfdd7ec9e26891a93c483b5bc43a3a519cbe1fb0b47bde38882e1cc647b2bf06742e4bc29905c3e63f6cf1f3ef99d4f50ef2c1d86696306513a93760ad20f2ad1c2f2dd09d9e7c29a70eb8a725e0356879edfb268e8dfddf3c0923b519aec51a44f484433d24fc810bdfcc6bc9cc430123adf3ae8d47cc694220185731b7a7576af0a93a02aac17a519f3b75a841a49297bef4b5b61333a716976e7a99d00ed8578c8df014a3c6ec6cb1613b0645f18e20dc34553299669e2b1cbf11b245cba1e2e783282566fabe30a6a8784b0d3153b111b7d24c30cc7cf2557111191306c91f235fed27086adb88056e52b11b5c438f40a80d9b0a59370b3c10b373fa69da7c8957f7159d4d58c3b78da0957ef5bafb753dac592dbb4dfd985a8bd286c54ddedd257576dc4977023627d44bee8880c9226773bf5a9191c0dee105a4aa916c0840846e40498b280a5b84388c760c3517bc863259e750baab85e5098e6ab6472db40f2526af2f537af51cfca6f3597c65b5641273987c642ec31f1d35c656a2b4c7cd63daba57193cef1420fb3e56453074641c625fff00976d643d6daafc93665aecf50fbe62d5c5e54cbfde3054457e67ad19b2a126f0f68f6128baac3a1cd98151c4a1266638752ebacd4fe137f0d0da7fe267cae27770ac5a558ee81b6a4b51d6fbb395c1dbf1bb2c057992f1f207e86cb67f9fc79d0927b1fe04070f07444b35e1ec11210395ad8a675fe7729ecb013fc5a3b7b9c16ea2bbbc5557675e5ed46a71f853f45c94138a97898712d36feab212499308304df5ba889f7fe3b3578144f0ce4d9b75fda0c99bc3f1aa50f8b6b4e798c17debcd83ea48cd94c30992edadad81bc8a010a2e81e7b840e499f6cdaa59f5a1caec0cca82591ddc57e63dbca9098bb4fe3c41fde59ea37b3952907f1046e67e7a04aac5accbad6e013222ce146421de6d901e9a30af3df2a7ef733ca6db601eac94f1191ef0626c35246f84719c9a7432b989582164f699411324337af93dbc8387c993ac1dee610ec6cbddd284e7b4ead82aca2241b078c0e9e3c121b739b8ebbc5aec4628e4febb8b9a6b1634bf171864459eb05fdb4910dd972f6170c2956eb86157da560497da5ef82da41fc5300de2cd3fca7feeb9901c1adfeb098ffe468623764676d27bc5210981151692c95bb83005e477a7c9f589d0d56feb86256bc7dd8e67182983279ff1b6ee33f1980b96dc9697bd193d7d6556d4fc132af3afdf0f1a9404f097ebb59f2d12b0ce15cf9294e0e79b197a2b8519ac6cca387756535fcebd03108bd4f83df463fa10d58452d6b4a36e6ea907dff2952170d5448776daae865b5b53875247cf22582703d4ab11acded61e43dc233480e6fd219ed67743104bfb13cec38590a1d282d5048d618439723f43590fc2070019648209793cf09792288ea0977fe2795e27fb582aa2e2d45782f1c4f81b060d330b5221f906689ad2ab294253808b70f451ab08755168248573d47dcd4445b886d36eadc65f116614b94a898a47535556f7211375bb0c81132d4708d6724471b7341571b5c92a6d8248feb0d02bca348a9a04acedfbe4c577a3dd056478fcdeb7bce8e6a562b94106cf0841376b08aca9eafaf17f66d7abba1986f551cbe68bb81161b5195bf4b35fb593bd7251ad51c51959986a6e9ecc68170336a9277538d0da37c435eb5b8e065f7322c06316ad3147e24622b448284699e650886d9da270455270922b682bd4ed9c9c85b9eb90a66469928059c4bbbdb320ff8d661fe72e33c664dadaf5d8e6e9bb909cec046c51cf441e4f76dd323032ed50c2c65004cb116dc689457d99e855b56c7812557cbab8f70082c63fcdc0298b3f936955f24835f38e941f0a2045c967b4f72b69e78539add0978635284955c209561ab7c050ed7185e467f490df3f823ab3665b272aae6c0a5e37341291fb8c296fe5b407fe82348942f93be803a2eaf05db1d2eac5d4cdf7e365edd06cb02d79c8b8dde46eb617af99ca2d784974deaa6c671b73f0bfd121fdea3e1e317fd56bddbb3bb56706a281937d3840e781d340bceea7b5aac2d14c26e7b43f58aafaf86ed59c124e0b0afceecde40b453d9ea4cd2c501bbdeba5e4140878c2f0c52215390531aabf6ed3355b8c50c7368387d60c0dd51991a873e23aa8f7d43508f30b3e919398a50a8fe28bc94f7e56832f330cf9fb1cb84955809d2e783f97c7d672d23d7df8dc78e8e5509ec83d3f448e77590970a789160cd74de2a221b74e673b74a32fb3464409be5403d6d1acad81e661b44a985cbec57f251d9813c9c3036325a262f04f99d99c7a5f30363e179178c73159aab8bd1e2ab9fe82d54dcdfb38fb9d37d7d5d00783490f8de851864729edcc66a6ccd46fdb838915cdd54fbaf0fb559a778dcb3157a28c124ca1e6d0a8133daa1af7f37c3a5f4a791dc12387d8aead3edfea73730e1c3c032b2b11e460ffa0f4a673aba30ce5a5ba2c27f69a95415bad7a6f58dd21171484a5612a98c5b588e1d96551f5df808a6a02289694d5bf6cf05536e1008463427bbee0124143d9685e9460a0beafa84f6b59fe4583324eb86739d9037868dbdf8cf530cb311ccf209fe524e6a5966dfc7a190b609d3702c4f3e4435cf85985288b8e6ff07ceffbc4878d492241318d6db0562d4c9a193dede47fb5d26d6571651362ea9b737a63421c9351d7b7f55b44bb69684424b6c718f6255211f814aa25600754c33426dc4234651da32de70b0fd12b1698c51225774d4b5c4a747b4404da8fe66d6b519fd243cacae60b88cc9772abb361373ef5be109e0373d1b1d71eb1d5284dac4d621e59ac67d82e4209098a149d69d4115449828886b052b30890b35a743ead7a74753086550e4f7a5de77c2148d0d3e9b534a6dacb63c74aadbc810fd4459f3480b2e8f8068813533208cb5b41f5649070c76492d06c8786111629b74370a8536743e17b88fc0c00ff9b7537cf91533d87a8a0e63e069145e88b8a50eb98de6a560296961566b60b4cf2aa118d4dd6ac3741455b00c2631cf450681191bc7bc625cddcae60c5b76ce0566f12367ac8d180c526595231a3cc76e7f1d15ca42af8e3d3d21df912b20640d6d4d7beba2ff0e2df2039743c1304efc63526b9c096c65d74f0679e336fadcaab09d1fa554467db5a123b375b025db917f05b5db0ff26e349e1f202b517c03dd617d81f2d7a60f918f74f1ac97b3e6c98a5730198a669bf44e9386582eadab1da9d725a3d753b1b2af1eea597bad8bc78a9679a799202b8800e93675f22065c25318ffb41c1ba2333e69904a686d146ac87574462e9b0d8b790027de7448731359b60f1599ee33f8659420edad288bff23a318e8926bbace1764f60b4b3c473bd8b08a7337ed1ec58dc2d200e7e3db018f533dbe21e7ade929522bd2ec36a2ce16ed1f150cc6a2ee5d47c9a6dfa8f02287d628ef16c42c2b7ec270912fcd897bcbb820072df6ab3e5ac39349b9d170ceb8d41d2096513f46e7c3c748095fcc3e5451773176e0fbdba33bf8b8373f616817888ed5227ce568c4f9d19a0d0f89e5c44ba514c4949a9bcf510088459dd87c8c01e90c55043e129946acb697b0e08cd8047f93732ae10ecaad1749f4cb360e6d6a60b03cf32c9f7fbf7b0139e1a819c13de8092e0991547ff63d2afd503bc879e1ed93127d71482566267e4f1f4e59306875f39ca778f54d54bdb53aecdeb53a238a08e29978b9cf49bf9f4c043db8c77d81f35f0102afbdbceb09b729cee0ae5274057671d232123c243443d47c2021a8308e6211ce3979bdd33dbf1ff540695e37038ded7ee8d4276a72f4a3a347727f3b80d675b8ed6a7a92e4f488b42b345804bf3ab24d881c9a994b476dee1325ebdc1dc7dac764841ad1d6ff759cb735077bbf3fc545687770d3fc93b4bcb0c8f9a69a38bd816f21cfd1f793eb6e8c5fb49ce6def8ea0737a5f346a4bce09758e3089e89b60047954093cbecf1de34641bc4f2a7b0d53d1222d852457b840c0956bd691c86372cbe0850731857812a818c716e10525e7ac8ade6be1d787ff71a9804d8b63e3c382b747762da0698e790f6efb918d8017bfb7aeabb6fc4db9c9a422c02ee5e28be86ea3ecbf4400b45a55d0ee51125f411791edca2108fbb29388f7c551249dbaad6fd83983339e9a8a41400e382c339605d2fa610e40114f5298cf02861a9d1117efc46a5616611b789762147af956bb56facd188b8379f169bdb2c51061f424f89cde0586ffe4fc15ff33963911b4573ddb47b4d231e5b53f8b7d2ac64d40fdbeb1b5966c3280232d593270c8e10e9a9c940803b9d009f707a000f3d04499419f1ac48f55360b51b75d25a842fb10676d69a100cf2a934eb625bf79aaee931478ba16c0461fb7e0d1e1a0ab1644de8ff05d6bb5740ac798728cccfb07cb29f87826d5d5a5709a64b863e1be0051ca0afc327a8fd5e5464ef33ac3ce86975813326afd8fba0d01dc81236b25362cbf56f7a394888a7721aedaf2ef3852db7a9967d6eea44de13c4847fa0277e3b9a4aa05844b26e51c76681a87183db2e8bca8bd1c2c63473a1e214a7ef99e7ef4caad1afe641f2dba7dcea4dabcebc0b4f9ede176b4b3198c8bbbd4112a1846633b43565c512c4b121926352b757e5ffccc74f720f4af2343a706b7fb88291eeb84a5931945ec6bd570627393f44026fa633b7f13707345cc384e3489685ef0f06e92de128352cdadc06f4e128d99e2acf1be532e50a98ecbd97320592c7ecc8e317cdadb1ad83fa045f5bbcf70770609da623cdfce9faa74aca6646aa05ee4e2fefb9e04cb74f2d36dc4b9e8cd0f7b190dc205d1dda6eb323dfbfbd7302a7a410a6d15031ad4bf56bf2b91fdd9ad350b040e911d80e8a6ffaa18f5e003100f01b16606929003f923b501c2dea6d6efc36416f1191690020b382f69e0466fa79cdc6ebd51605a3041ba0f6892407c53426570245140eb1491938ceb8fbc2a025894386cd92fabc2983d604263ed07f82d43fecc81ef85603a1bf9be59c157d6ba06955e0fef9fb324b328c371f8a7dc3ebec29085922128aa1643f42f8c08eace1b0ebf24b3a0db659f994832bcca3b9015071b8005551dd910c0ddbd84d17345241fdd9697bcf9e1cd525bbcb9a8bf5849506d4f882fb111620b0cecac370cae7744785218b664d1d8af9f4d19e44ccb96ec7402e28ab397ee58836322aa22c900b030459987600f096a3b9e64090ad4fc81f785c80f58177f138179e8b061c886430834e511d2cb62730506e7f2fc3f2d36abce8221e7d75ddb8a1aba88195a6c390c0bbf8d1ff6614d9ac241fe45497261a4f848f9b1d5026831bd729958928d80d6ef4dcf01173360ff9fccdfd1819cf314e1b0a99f14a58fde9af56e6282eb0096fdd2acebacc7977b502c9be909958339b09dde4008bdc53169b5395b3a2d9e58ab6ad59b9346a7ce1545037cda873924ca3c477e1c6d8452c6462473396f2ff5548863f6e9342374a2c37b37e6e476c688932b3a35a9c947073583a2e549ed3923679f40102b46c8cd5c0259c7ad6c321ea9e454636c6ac6edc2890948191bde15d30a093f096eab00413fd860282598ea24e27976da2b0a22a7821d131d855f97278896c5716b2979660388998c30ef40fd726f58a3ef00760fc78495d44425911cdc988cc561d0886f1deab2c7750526c2d374fe4725ac8b99bb7248e126515463f44b52d64139f51cfda3bdc8dbdd5170e3f14cd3b8b746c9096201aac7f95022773528fb694c24e5db87d961a831da85b03891f8b74c80bfdac07119b0bc5704ddaba86dbda638258d85ce2da607e219fc833aa8e1ee245e2722b9fef90caf2a66d356fce7195f8f0a6ae461a08ceacb5d535999f50c8721ae72df6f6801f10196136673eb6fe6456968dbece9e9d40aabc14f98d0b07b3b370d8b8ccddf051113667cd74f1bb2d2d92e88e496fbac96fd976c0c5a85f96c4cb9ee431e4ec83836cdf3cbd082ab2168cebee8a633c7243f42ff70687f0830ab18395534b69e5ad63060403641af0c34b63dab440489fd901090c2c32413c02d0de39c15a5d3313974ad97d61c4a331c68b8e04bfa0e381a3ead8e7586194937abfdce6a4d7a7845abb8d5569c583889902d05e3eb378e2ac35566b5a883c18b16a8780549ae978078624f77976840a6afd06294f0d9e109303dd8bc58b9f076ef1d98a7f0625e66d720c4346a2e4d29a94c664fb2b7fb523de116df6a2c92b38915836c86e442dbd13a3115167b968e194578f7a27d45c4b92e9fb5eb1e12d7360af798d2b388f027b22f63249009fa18ffda60e60d2c1d4ea74bead583a88b04bc11f7e9701d4d389a6108d296da9de1a7415134656eba0e48a4cf30500083db30d6bcc2f0d53d8d20fe99d0489a7ef539497cdfe9242ad8c7dd63bf6c2f260fefc93dca478ebef345e1ff0388bea180d49f031cd96f333770ece794458e37b9d7adb38cfd33d17821186941dfa38157ea12d558bfe42c61a3b8ae14e95616bdf5f8209a0c9b502b1257c6215b3c461837e823a832295dd2868e9b13437d67ccacdb0cc3e300b5b4e585c6ea57a15828a616c37c6e1b85a08b7a24f3a5e112a4f79e50276a66c7c0a623359a6b01cbdab9ba0aefaf4a37865047bae80d3efbe7addb0fdca133c7846440e4e76cba57789e0165757090894724461410c82798146849ca96b43ccb1a587c9da8d105cb2ada7d0ba94ecf61338ec5613531425e0ce09e40e371c8ee34d92d81437d46b5724cba510eac67cd914c200eda49e5584633de88887be7b316e81b84a954ac74b34255025a1e2bb307e4468b9bd9fefbf59a6085cdc6e2b289498be86c5fa2fe9d41e835a05a8e49cebadd5ca9e67520ea6e6e2a17a4cf5229493fbf51558a2368b19a28d5f6dd7044e2fd5fab74e5b6126cedf39638ed9ce18e09230c2acdcb9de65892a2c9de97815d41ee6058c55e351f28173ad3e851072c16130455e750f60218bed0e44a3682f8bbe370b4b4cf01f0c7e3c055b91169d5ff10013d61163244b52a9ddf0f1b60b745d37b11743ec771259302b0511472618dea3012808c2b089037611b92273168a9b7f63b92005c108800fc42f81c0aa29448bafee50d645fa2c210d1814bf20093fdf0e124031446a9b4ce66e3754a64acf8d75f90269282e771035d0b4dc2d20dc1064d2b85616dc0d880b871ddc2759239ae4c9be7a62e7ed3971d0f776311268f561e71e9c016f1e6a26b0a6c908295728985e641972729b577a82bd3dd7156283286a57fc010dba8edd887526f824d284a5ae39fc307441a3d5f8d690dc7b78f8c18767f830bafa335b67ba3e4b46347c448f0990d0eabf7b22b8a047e1c5f89e352781780d58bfdf8b58c5edee3b7551f824ad3a7dc6f537e580988d3b2fcd8700f1fb16242271192ba3333929358b6505e33d88f4ab277c52fe1fa9cc4d39a2b40a7b8ac82280892c73d2c6e61ec9305b90f028459d64f857dac10aa719a54fcfc12889ffe97937ddbe58ababd5bcb2b0847ba4af8ddcc48c41f37f60b746a6e87f01ef99bd2620410993fcde8d48fbc532de50620a7df21e47f12429cf08dc919bcd2a026b4a6c421add776c3737e5d41852c6e0f308e7ed2a392d3140460909a76c9dfa6863cdc54f8677fb4bb30f412d4367a348c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
