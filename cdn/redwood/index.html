<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ea185b839f91e196cf86ff623c487ec462bedb07d511ab211916e85600b487fdbd0f8d0ac42e384f70b3614cc213dbac09287b3d6a9abf7d48ed9c57bd484647912d7be60998ae0ea9efa348269ad0908849c0d0a5ff1e6a78065ea0ef1108b3ac3d1e4d6b7e37564f2b9e6d282021672a0e925e8250468a336d1c1f51e5c8dc9dabac664a0c65620ac27a536263e831fa66aa8727e0b2c6e3843211bfb0d37207c38458282691810ee627079f9ca641fb4469bea4e296db9a271a90237b436b73f1b40c990019fb2632c0fd7e2d4c27a378be69e5fcc44b05b265c6b6f455e89de233f59ea247c1b5de40ca74de53fd3314ee71f38945334dea9e632a8a4c18b7c88abda124cf5460219d3c9acc41609b450934bfa2ee19d7c7b9c104638da589dc79ab6430bfcc4674c6405a803178ba5e5466adb6747ff0c17fba47a2ba64d497e9798de32d48efe55a6c0a50da6667bfa35a742b7e8ae14a8e90cabb9791af188fabe6943cf5aabf66e4717a22643abfaef1cf8a0e86e6816731414ea27cead1df817f8e7e93cee9abd2e7fbbca5c640acc20065e67e4f3e32f1c8b0a436a6b21667427e8e34200d58397694d9c99cc18092de91d905d163b378cd9fe78858c2f21050cca95bc255a6c68960d805893ab2331b4383cb28d8f83f7154bf425864b6ffd75f516f6ee88bf9fbb65496b4e65e68b5406ebba529d3abec0320d56b8d1666ca0289cdae62f043c00be2ca0be4956d02c74948decd072764bcf0438c6e12b2335a2c49192a98daf6571dce75a0365ebbc5f338e064234cf4ebc6226f142e3993787c70583531b46dcde2b00534fff01d067e2fcc9ac55cad634808b5d0fba5611cf6ba303836ef1bc1515bebb29c42ec773fcf2e7582b08c33411ac9827d7e4d2ef5881a57454593be8ff47924dd8b5cd20c9a830c3722e3aa12fb0ee0dac4787d37067d562fd57875395761c52a6af5fadadb6d15de178e41662a8f3c50f27390cfd8ebc22a26dccd2ad20231dd864c98946c9d9eb8162e89712cd7aea3bf9f5ebd1bd6c1dba819f0c6c80670c48fad2fdd2c4dd59af458533b6f678b649cd0c2f0c33093f448997589dd62935d283068b2c18313d10f20ceddcea9266f452abdbad26b39cab8932098ae0f2c802d5d14de0d8cf43352f5a1fce7a380c7ad98b9ba3f9ca3b3b3c8a53ebc2402aad21831bc2c06a4949dc847d5cac4a50a8bb73e6120cade60dbe8e476801c82aa07cf42a2c4a0a7ffc7ecfdcdfb9b3103168e8c7997039d33a973e8d482a0449e57baa2870d1ebfef58bccabd75439f9d9f86210b793f38099351afcce7fabfa8666e652cb3792accd1b2cea5a32798034b37ab285aa274e85bf1897f947145e6d4adcc767d31db1949833c463c54a93dcf45002dc77a8b37861c1d868f6355e4d720c280ec4e15dd229d854b65381a2622f8ac018233a9bbed0ff19d569d08a7f8282437a9ffc45848664c43c68752cefc2edb7758d99244301ecd28ad8b9233be35fe51b748a7c366893e89b155baa67ac6bcdf88ca5ac86ec61a739bef57f7aebb501a085d5cde9457cf5c5a79c5e5890e06b95644c74fbcefefd264e852559179dca7c4cf7e5022b798a8742803809c500cb153e085f1b26fcc68bfba35e44b37f922085f13c78bba349c9c7dac2ccc0a81dca163c14924683e9e86400baeec5d26b6bcf9e111519da00dbc2ad270e2ddc03653b6f06d1f8c6665b28ed58141f229ad046cc7ef4f53abd4b09562b69f600aa64eca28074bda50969b646a3ec9bc0947bfc3bf9d35fc9c55dd1a6fe1a21929fb9896b51b70338947ab498b150c982b25d9d0c681d86b39d3428868b0ea2560643efd130cf19905db2f47790fb716cd9b5af3ecd3fd68c0a13fc7af367b92550ec6e3b1a69077f8dd9e44a364e8d5ae2383d9ad0df749fd8456b822eb0255d57c83189529e38b39dad02ec6586d78f74c2fc58687bf8a5e6008a31350dfa8b3cc5f67d516149d6e175182dda2c7b7edf4432071e934a5236bc836a2479b5ded24873c43b4e099a99c94e72a6154c63cd3a4fb5a01a7438c173449ebd017316cda9cf351ad512d4f25bd7d2e807e613d2c307910cbac451321190ca3ad4c59df14235f1edb3060fcf5a1731299f5eeb1cae4df3180131a13486c2a9695507709af7f1ceb16a032b48728ccbc75bc2653c3b101f7bc217ad7e98d1f08480aba11caf01fe9292d9805019832e92f8d30c5932467c70d8b3cde3dc4f13d4cab4f2727d1995f8dc46a1b1f31244214ae368bde45fd6e825833cf45d25749686cf429dcdfe428a0b98d9f3f59a47402e64e36070d47e433d6b8b159fe00036307962eadba05acdcd339b5d8ab4c842f6f2af46fc94d2885f296efb2c39728e221ad09a7193d1c6a0a822daff8aa0faf2746f5b1983b766c7d61a9590f3cc3025c53f3a7ea6f4261049cea1de5d2b96e69cfa2768a626003cee033f6fb1c8dd22db3bd46eedbec66ed20719f5a7adae9908b6cfa8610e2dd4995fda7e5d2a67b4b8b30fcfc2c291e4c37a1263114f8a37f21632539e6b0d31157468c7c842e61fb72384e76bf7703b42e7d5f156d8e3d8bcbe17cdffbd1e3cc4134adae27122d57e4c22e0d01c145371bda54b36ad9346ba8599d3c578c897ff325cead995fc130a3e7a76b0352b2175cd9d62b8b811ae003bab0e90ea8fcf12b4f7360be97a86148ce31603a95dcd5c7d4306294ad6a6ed43677ae9d859247ee523b49e33fb0f76d0874b5d1f8cd0c87ed4b1cd544d7e72ca9be1b404bed3b72fa44dd07f7624ab43fc5a39803e2ca5c77340d10acb6e4ec00d4be25800a6d8f51785f64e1ef2940979ccf924b38dc0fe8b8fa2b42756e25873c71ec477430128e9e6802d8b6abdd90d04abfa7c9d016e9a86785a402f9e7bc3174598c6a5a295909c1b4ebbf14ab3e7ebfb4c30eac1b760f795b4b209c42bbf4f2a19f1e7c4639628b1737f854346732cd824592d210b3e4ba207cde69121d9cbd7b735a10813cc37957e9bb0eb1d2008694db05de3832297ce6eccfd075035ad84e6239982c198141c297c8d704346214d001385b5753372f99bdc8df713c6ce127ad192e2dda959d82b84aa0520face9da7c59a3ee90073ca53980998844ca26c6b0c26d5a3f459e27332977490b455c09e0c03d363dd767084bb9fcc07d18bc0e0de34d8fd12e4f5f5aa815bb747751346b406b7c19a8462035cd8817ad559f30bb7983096f25d28120df8da3402b5fefbda0f46fa14809b6fa5f1f6711fce3704b0886b5447067cb9d7746248b027a3dbf1736aa385537a191aefbb2f02f3d9e1fa734e9b13c9e2a677841ef60c6903345e703023e3efc85f1c8bd0b3721e87afa84ad868d58bb8a98759d9d9b528b7b6328a2bcef7a28576f751010bb0e98497cb3d80b91f7aef2a799a528f741a9ab735e902f8220071949bf959dfebe48ae4e54fd4ad794041b5beb9b81608c9fb423f168a362fce364b24bd48fd6e69ba09bccb5682a49ec1dcbadb794ef3ba08d2c251d1690d335c7014e69d09ee5601e39e54feeda35931be35c46bbf0a3fa953208ff1361c151a4c8806f99984fdc5ced9bbde6e0e104eecc69d43237fa1776304fefa8fd4cc66b072204950fe34d395bad442a06a9d44af826833eddc64f774b8168da491222fb2e39cdf58f085243d3f88f96eeae330ac35860ef64b9b5c94ba8fb45023ec33422751c58097147d2fe45251ac5b6c3bf98c33810da309e76270b55f7eb1feefebcd797cb8feaedf72f014735f8c467bddb1966436bc3dd088528561c464459cec9710c04d9196e992189386c9d8212765c73902434b50a1ec9a929a51a4390897f02605f39afb3a4c3f1943409ac5c589edc5874e9cfe359123807d62ca93248d35282de19116f7723808c35135987539f8af6bd18160abe2b471abb65a76a836f2c8530af8091a10c6fef273b6c78c4321735c92cf473cb6e789fabfa0279d09d302a3bc800d3a3194b90e557beb4a5605a027f136c52a6b6042bcc6ae9460ec932b328eaed56e7e809e15e993871fad17273c1523f3fed190c73258b0d2e0e317ed2fcdc7b9c0e472da356dac4cae8459755f69451d383a7477f6852954a42451928574debb009859b51b478b136e1d21dbde5ed2184515943bca01a898a717288d090d3009499a04f0da437d6c03b89a55645fdd31483a321cb289f1a33bc8b85ce70218ccfd85b9d45df899a1a412e8505c4cd3a94122eaf67142c7ae95b803f01ce836b28ca3b2a89de14c75baac30dea446d4a4eafa9bdae4bce91dd7167377e8fd53dd1069af6dfe1dd524209bc1cbb28f4c8cb051ace822db068e6c679fdc61923dfce276dc7fdf67fdf7f057eefe1fdadba17b867bb2e8c8b8739449dd5e73b027ebf998244bddc5fee832a943680f94ed1f82baff3cd4e3f01ef655d5fafdd6055627b2eef1252768f9d9c8f3433be7d93aa7a0e81e44423aefcbe03f6679e8b1fb02a7778248020186cd9560da18b3b41f353c411e0883c96488343d0f5c9b5e6116b3e58826ffca4dca30121ea470c0edcb199fc745d61c4652099bc9a2c3b5073fcc82603cd67f86c7623308731029d1be45edcdc5758b294d8f31fb7ab21e89b8fa8f590dde86ebe077e00675ef0cf4a944b1fab92a7b1fb423d1192079124989e1695ae0f0e6cc9b56b078d74024a7fdadf8659c273785a00e83f5c8f61b020dfe37ed4455fd8acfea6869abf674049fbe4d084817c73bb68e8eaadc591b65aa55ff924df7fec47c9f0fc0f03e9a3c29150aac69d914f79a4fcadcaf9a6564686d4830c8e2a93ee7dedf7d935685da973206455da6363368230db463753917820d8461fcae20e47a1460966343dc5d28012a4d7519c7febf06623281179d2c5ee3d55a6c640688222a4a4d4c49973a4e48fad68a735cd00a310e36ce09ec09dd80ed5f0e9d154b9f693c1acdeb5aceb8e7048ed96fa1668971f794d1abd62abeab6d8822c185e475c5ab93d44f55aedc6576cc331fd4182a22622ca379a8e9f0195927a8dcd5fe6ae890234cc2a7f4814e8c5f803590a4493433c26b471ad2e2dcd906856bba444819cb821c746736c397d36071021a8e355e566de107ad16dfba870a94646325d8f2442c89f4a05c9cc2b3627834958c64ed29b0844b5a2021160321d678126f21be3a37ccc30914e89e1069edf59f47d91ad7fa312011b12efeaf7e6e2b08294eb924ee0f38892da1d86175aaceead600ca517d5b07099d31694c135a89805e96d7cd69f4573671bfecbc54b94dd6a8312d0123d54142c9cf1837533c498b03827dc91eb6872b7be7b8ddfa23b015e9d8318e16ed0cdb7bac51489996de8e9e15ce9f760d1dc6b6415670c19f39b1b619b28c07af5dadfddd94c0c237cbbaed756753a1e8524f66c767335708755372bd0e6c366a2bec1fef3c30285dbbbed3c39dbca2bf00430483d90384d8bca267143ca2997b5eb4fc5481a181bbe837c1f7d7fd009c732b0521d45766fdbca92fc97063fefca62276ca3f6e289686f2cfaf708f799a1dd931e54c21364a44989a4819964c0acebde00c7f0c09cb3f4d9a055cb79172053bd6dd4c0ddbcb6b78cf661668badac09cb02994721205080cc3ecd408218ca46525c2a168aa243165bf93097f081a6c0fae4a93ed8adf57cc99f05d431e15e25304496ffb710187272d1f3988a3e7d189ef9a4a8dd250763d0ef88379d01ecd8ce15b636c120bd598f2c5925cbc7cf9556065f65b36ab5440bb0c9d2369fb771411a70033dfc834681f5da9aa3cf396cc1e876803277854212b7aab2f158e88af22a8b5781f6cef4365adf8ac6433cc3e0a2492ac4e14b3adb3eba4b92cad8eda3fab751e70ab67122c1775d004babda152650312817c3bd6c21433eb40583311266de98e661f348a27eef459bf19b4d29d2d201e94f2aada76a24c5ec18c881f4c1885c119b917f149517b1a36adc7a5675d21385244fdd12d732c4a57618e781c3e774afc6172a7afae30f9ac64662f0a26e3da25b5843d7488f59989b4fdee83a3f109a13151e6a98a01bfc3e4b9fd7b24aa17a91bf86e9a67198ecafb098fe3c9054549dcd6d9f4386643116846d3f9bb5f9b47bd6f31abd451d7bf6914d9b56c6c9947586f99e37a469b45d4e11634f31ee6f0a24703f1a4e1ef1ce5acb2e5755f699079b1860be5a6b31a9e7e26f0792493d9eb2574bd38f03caea2d4422a4d72fabe150ec682a84985e8808345c35bb704bb3bba37e27b36cf242ddc5b893b27cca002ab8587b586f005fc115447d47fb8c49e6e9ed22f14c0d5137500d21a9b67944b69d669bc3f38820af656392d47a5f41fc00c5ea8486b842a55f118741bedb4c2cb1c7d1f31941a0fb43c8bdcd62f57f97c90cfe7fe8ab54d2a6d8bbb9ee0e424644c90fcd697f04a5d6494652b0e53664d2ad31b57626e7f4c78e08bcec4fb3aae54e723ac3d127f26b0a751c897c82951172b3ce013147fb5c38c6d5e45c15bcdd05bcbc5f805309d2b1f708a2439f35286877de92b603fea5ea0c04d1a6fbebee6bff0cb7b5fefb2ecfffb2a49f925755b3bd9ee372db0679c664888c977604debc47453adc7b59043c7fd75ecc9a9863d7edb541a27513381af96e74180a2b3bef730f1c908a9e6458a9dd161b58d1068980c009e783c59faaff9c6f59ed32333a1369d64506dcd027d4b88d510ac6cd5511e5ac84ac623bb60a3b1945c098e4451c07f360cb73be1297ba9beedc00f38e5383c359770c3b9b335a1395db9719b61ba937ac961b3eccdd1cb8f2b09a28995548938a8eacfb502c4d899ee78b09bb830fbff832f3dffbbf9d53465b8e035f396ff4d2782031f44c88d70ed2c8bb380a2f9ed8d0b5ebc3b1f5f2ccda4396e1993307d3b88cb8b5dcd864e1d4a92f4791df1ad1cdb785920315b6e1cfdf3093af3c4a9f0d3e746592fa350a54a23a604bf286c4f6d476754f9f2096ad10af37e993d2b52c47649a3e6a7e7ad988e7276607deacaf3be41c31cf266931f891cc60df04aac916ac096d9be20b93e699c2aa818dbd9274425286772a6d5d69b4a2e3b740ad5ad7078ba5692b85cc592e036e9e97453862e234f50a597fe28c1bd748cfb74661035761729512f35603f15294ef9053be2337704153df9363b310976873a33f66b20cfac44647540e6a9feb53cf3cb7f9e76114284a6b022ea65a8022add79d2e2da9efb04e1d1fb7500a248b1b385e4e053aa34bc3a4802ea5820e2dc569a187e9cf66444cf81c10c52b331cb0a0977dd69493dcfab306de6aaa252599683d386839622892aee71e2943a25db38faaa1860ad61adc877de7c376593ca758e067d39199763cad23920645f3871f74a7f6624631fe6181e66e05d85733f1c27aace817f87b6c7bbd06f27347a963456d2ef837fa837e9d234c1bffc3790ceb73b96600c75c3a194f09aca9e69cc72f5d8ce243fc0479ef3c8e5c2d93a671690773ace864d9451b2264866eefe78b9655e0e4ad39b7c71076b046540e14d04b1f133d26bf0cd687c7c746bf8b0fb8dc815230310be7ca801f211852cb937b8017ff8f629257f893aae1102b8948cbc86fc632520430699b7a6b3b2d4b0fe71a42b27b6d8b05e2b53a0bd642f3e93361311b0b1eb73c79974f814c2b1d439ac9610bd34889884066f35e2533533f001f2b8d2dbf6f86ab4f6de356efc559dc8cfe654d6e25159c19a8e7a17fbdbe04e553588c30ce3b0a531d84635d40dc4e9c39aa63ef1d27886ee7b801ed81431cad966852be11c1c56a59c774b67a24a78ce69cd24f7a4a471613cdea0d1428f8974786b8224d24ddf3d9987a91b5a8a4d1785329d9ff84ad1043b044de7558625d59f2fa84537083c0aafe4ab968801efde6d391825f65f5cb9b0002bc432f5395225a02d24dcd4e32ad520a6ab009894c4c6305c0e923c43a85cbc8a773f90cb0d12ffb068925dee29531c97ece516764d82fc1a2231f681db0bbb1ad686814cc3b0f792afd369a2582f1e558b6f81d9aa1604046694f900955fb8d1933c8076c2e1d0b56f56cbbe2f7c9aee9131bc4f0dd013f0cff336c9d341ef7621e5647033c3a93dc6c973734db2cd9cc09a43b804b25ef50efac4c8f6748d450f927b471bc19686de00ccdd0a2759749d9be828b62f1a5353c145d879beab4002edc75a23e7758fd179684c1147e16919ac640654234983d2fb8eb461cc301d8495b50ff75f46321e29233bdf454ae6ee9d119b1cee2db402a39aa86a1b81fd5bc7a0d6d5655445cf26a986fb2f954dbbcf516a702220ad1343b607bed32b99456e10aa19f85554d9995607467e103df412d414e6b59638bea5e34a757de64803b65e642e84ed3029ad2705741aacfcd7d241147fdddd70b22b671da9f417a64ca4a586e8780efbcaa3c12a7b116e29bed553107483d632e2836c86944498cb05bc0dbe3ffd50982d69ae0907a6881ef4a7efd26a29eb79f4f724469059002566b54c11e16e2a5b8816cbe8bcfcc1a3025b7e666b74f935ac50a058719d58c958adfc20ee3ed0c8681db6076e5023011e4fc9f2e80d01b083d5eddf390a689a67054ebbb9d2f0284058c76aae057fc2e202505105feebdd7f6fe4b58958e9d886791553d225c4b6bc5d332235afb4a3bf0d929ef54a68affafe7e901906c240c6392a938fbcca31a69f10b747b7771bfb2690002e6cc0d77e15ae3f3cf7efc8d3e1bf99f48ef8041e9e3074878c4bd7f7dfdfb00aa743fccec67c1f9068d4facf80c691a192b211f10d9beb1a3bd8ddd5e5c62aeaa41bcb70df5b18bd2d619a59ef86d1adcb9e9dbd02c1c05c60ac6f680696809d5fa03172a71ac4d2623c7c1da1c06828f477f06dd22e745df66636758fa456c07cedb256a30493cae8348efe71440140fae4668575cd31331301cd03ff2297a59f7c9d26047f6fe875acbe5bf636724a455c7b69a40bd3e2fabed1c806fdef4b397d28bca2a36b9df504470d82d2c383e7651f5d59d324afcae669f82c2a66a3147830651e098ca5f5c81a62d158fa5358efd1d90e4356cc66d6af50adab328b314d3c3078c24b6eba1575e9ab4897afb6cb6ae99c0b9ed4bc805a715b37e36db084b24d5ef1fa6c9ba4d5054d59544fd5633657a40ef2fa34c5b8e50211862cb78897c38bf7ba06f2eacb627ca9f263ee8868bebdd3ec2592a3249f8cb665a6945493827b2bb8b69696c30f4663bec7cad998d34a7d21fe11d3557aae4bf328b058e2d78e048cc7109cc3508be8242a35be6f636629efa7f902ff484600f0ef234a76f0b7371a3cede2411c438d01cb095e47b9dce13d9067055ca958d81ff30a1d95e0d7f6e6728b724a40fa19c76fa53e7e2bfca5efa91a907afbec1f88338c80aa71150e2510cacbc86e2671e815e26045a8b354d432d5a04bca4eb280958bf401aee7d18695ecf6fec3fd696cb6681002e03b1e6f550285e9bde57cc3466b64b240ec828c4e04f696f476c8f089b70887c19aa025d2ec0be579281cf2e3f1ce2b035d6d6886cce964fae6cca6f1501240efa1b4f7779d51c7a58b497fac87689fb6427ae491ab72fcf90b5bffd25299e78d8ad268f97acee9463ae4353842def58d5ebca6c2c5f7787654d703122bd9d73752940a42987d2e12f29fbdf7458c93fb4022ff34b657dd3237cb51f7c8eb156f6c08b8eda39fcc250383ccfa43ecfce176801a5dfaad2c34a00321fa3a258f6cd50a5f0026fc0cbee9460a07e774773adc12f50c1a637df3370379fb131fcaa9c791b3c0cfbf185dd77beb21323d1162c9f4d089c99e6406daa7d1fffaa4b53cfbb4db0627e1c269c3465c7f7898935a7cb6ed4a4b6c4de1c2a47e1a9fd176e8fe05c1f56c92fc3aa0c7ea966579a66f636984996be6f6146d094ee65c2c787bced3ed4cc2315fdc31fe4ff55672f9cd8cc130fbc7d85a4034951e2a7962b7adfae52ca1d89920c85f1f2f7f835abb78bd51a44cd359725680862f17fdd231b6f114892308de2e8fe550e7ac1d96737e87ac1d48f2c42707817dd3e12934a5d6230f0612f1fd9778382947b45761193abaef9acb344b51209301f66b4fea7c86077acb98d5dbbc687be2d73bafba2ea27d9b995b8999ceb60ec528d6a4e9b69ca0dea48e7d432bb790b038e8e00b26a154441a52d45bc37086ccf4319ee09b51b345d1a605822fedbd1818e4b0321f496e44eafc666c75d900abff8db987bf46e1ee5b184b8d6359cf40b04544b470b267f9e02505867c73d3fb4fd53831410e535b79d149456dc5899fc92e41190d2eaadcf9b4576a9e0ae03a167363c37cf743f0de2e84779f6a54c240ae22cb9d61893a133a451cc6480bbc1ee68744207eb1ffd3c16a35eb53b42c68de6c329e9c919cf6e6fa4508cb1b1222c645a102b6c237e5a5e0f5dee544dc22d8290bc330d7aaa03dfa2828719194ee8cc6c13b44caf378fb61049eea4b358926067f169928c779496d98516e83950b1d7818584971730253807422fda5dbaf8ba38797c7838889e45bc444d0048a5cf7ee713cffcb9464ac7372df73457b64e9926390c6fd534d6cdfec5bdb4777181a1f189df86fb60d600ea3aca782b32d08b6544bfacf5866b2ba1c2de5282c5b30861e91b93f99c4db4b71a585c70df30686f5c6c7ebcecc5e143d72dae82d8e2017ae4ca7ef97f4d8ad73dc36251bcc550b822652ba2286aabcb4f2335030372fddcca1accacd3af09d19965124bfe9274a94113e9efefb03db1770e3011df245d0d9da0d56f161bde7ac525a17f874367f4099ed02eaa45f4d779fcacc66473d4ffb672e971dedcffeb396f52e70eccde3e184b01d66c4d753157d87501ef042e3e8515653ad5da4d8b17739262750b512bf33295a0105f7b8e4dc476ccdb4554cdddc6fea734e648b4b4a1af81ba3ce42869f27ce2d983041e2d7b5a846925963d4b7c93fc2e01c81dc2e2c253761186bbe3812f9d6a898053b04f4f100e6aac99e2b30456ff0507432b66c457a093b1166eb2898675997633c3596256fca1f742f2d635bf5603c47481f5e17bd88424446e3cd596a48ec3126b35e74bae361d45257a02dda6798924baee89ea05d5c7595a88e071b7607444511651b33bac1c36b7edde2f76ab1f71de17c07a101f0abe1c08683be75702ee004fd1767ee11f1c1e8013bdb92564e5286b836bce33535bbd4ccb0ca8c6af544cd8f2c50ccfd0d2aa016f3a12dbebe12a3bb5f2e22d05c0351f52defbda8bd1da6b0bba8231e899258dc61d55ff095613c45734aac4b8638e56c1ea64b939505f7700b319e10bf3a30a4709f74f1736dc3ab0670662864a655d7b481b302e47b47e679bfb5edd94fbfa7131a9921d49b907143bd31890b157fc628f5c0c1644be34a51a467bcd61d98b13e4ad469c141d43c45137f8ffc2fa943a08248b09b6f30ea8beabe1f7e3cbde4279e829c6496bb76e1009e3799856eeac412f172a54d854d7c1a310afa26d6cf5bfbc0fb5ac56f28f432dfefc732688109feb2be5f76aed4fba8cfd1df7ce38ab744bbc1d81ef62cc10b9aca85e0f42d6392b5061de7c83297c9a1477bc6c4b2fd5f1d4d544a8ce2d3e04239d2086b50b72e61ab5022304fa0341da6d613e5c5337bb083d50a0a41e02251dbfe4c0ea04162cf290a61780d90d2e038ab91aa28d5076a0666694903d904300fddbbc53edba1f99a1d3dbe1cf56c9f732db4bfb1912503da5972343598ff8136558b32708f3cc06ce28359ba4d3c44338baefbd12283170c4fb13464c4068f7c04b922d4cd811c674441a12bddc1422ced6bf97caa83f8505492963a8f9eaf50d2fb16908175b5bf083208b874db8d297503bbe13aa4f82492a92cb7452118b2a2887d2a33324292dee9b4c62bf2c94c858bfd16a2dc7b620c3c259da34d1074fc4b3022804fe0cbc90b27f37bbd932b260f57a3d677bc5f6cb86036357078c1377bed01098e8c0e3a5737ff352724d5e0590f9233e3c8012c0ed2ea4d22a9e2b9bc159e5db914263b2e9f95f0f49aa61465ccef0e30f3c10d6a68640e32d45fe7e37347b6a47b8a5dc4b9665e948ed91666f86c56369964beec1e66320360d9b19a7838d4c4353a85d5f6018f203a12472066e3fd99389506f0e7437bd9d6dcf4cb1f04c9990f575211fbbe9fe8845a4c1558dd9d66ca29625f7626c8b38e8bd95072a5cd0037a4ef0e26e4ff7c7be9ae9cfb4f1e86bbcabe3e856477765aa3c046dcdff37b5df9e223daa5a42fec7e6a0df642e7e27eda8e75970fc1951b7ee3346988fcf8b63b0cc4325e318dbc27010df1e1dd22c30ce2a912976d128ddfe4880c01fb6a91f539c06f944c486b876cab582313083e1b82794bac87d619577f499dd8aa9c122ecd74ae3cda8498dbdaa5eb54e457f7e75bf70ca5f08d4aa1dc45772b341c1f4b3ec8dbd32ab8b9ca6eb1d3904b2f68f49116d3786dfc09565c9f7dea75aafa976721eb02ee242e05d7137cc183c5b46c5e2992dcc624f395ebaed0f4a039ccf64815824fef253f1bcb7b6dcf10f4d5ec7d126cb5c3f026c5a84a2800e505417654f5685841bc7ac05411b709d510fb5a03b6a93e07952f502291e93d85f48a092e482c53d39ec3ee74a6f37a6501bdfb261827aa993076e889e90167962522cd9b4846af83081742a43217b5e09fda9b46e12e6a7a574fb4a6ac5ba1a6d7c325d3bde22a93854f8b7e9dd7e30224ff84d225c377333ea6fad08ff9625cc67e38d8df92788b793d065b55074bc74be6709a04078c5f141e3300fb8194e8bcaaa7ebf4f7b66f83e724f115eb635794b9de4727c7e24cc718ae7063180da98868a19563add0ce1ade6c46f770552b256a24931600b7741a53ad5e8f6a48c8a2894b3b4fbe0dba789fd61423db35aaa2782531d62eb177b45d54977ca0ecc792cac34bd7929ec96dba952539646e34906b275fb5c42f8402aa9ec82b035e476263cd9a7ab855b6e14e25b596b2a7adbe7ceca5238763ace802722b29c3f149414210da94bcf131ee11184df824f602007687f9b338cc0ed08ef4208d8e8cf26be735119cf7ffd15b5c53e0955ebd009b48d27933f8c47945a062d630bacab082a86dbca7c8be7e7d6ad626ae52ebf59a47d0f1b688f9ff6c86048c332ef24d37bf9206749248b0544decc78c7db42618137d9205cf34dd7c9eda9402923d3190ee8cb8e1aa47eb9d524110b035d87794b44945b2c4f6c357191e34da246656d308dd3ca2e04163ec0b415b3ff3fb57c96bd297fc913f99d764321c653ea1695fb1631795c3edae7326fca93b8d21986ffac22d2e658c2924c42fffcdb306fe894f794b52ce6e613277465192bb353173929b7ac9244ab7f078ec9741ab16145582cfd723fee674bfdbb15c4ea6b312991b9fc38e9de9c518cbd21e3ebc2447e1bff61eb5dc347a5eac8302b98558f1af1f212cce48ef5018b5c32249bedbe6aabd09dce443f9e7735e9f4795caaba3f370f6a02550a33eec4c180e59b0d5c5fc2267b32a6532b11540ff14b18640c8f0971958a5d07e786593115164e891bc808c93b6b794e8d0adea83ec965f0f0fe9ea3f0f02e8cc146e8455ff760ecf51e9f3becb0a0924d7aa20a92476a57e9c4bd115b0d435b8c988af17d203656b43551841dc27dabe5590990526b38873c7d2103530014f781e3ee5386eebcf6db36c0c6c9ed6e6d4149a08f89fe9e3e314091d8631ce654350ccc5006b68531fa6be074532b98869f7230f5b0bf8fe637322d43726b7b86206da91042a310fa96d8f92665c73849e38a517c9a10c535afb20febd96b81f3de2ebc1a0c498657696bffd79197c960a1588d6e1fc2e5ccebbb3374ab6c67d12205e2d967c9f9fbdd20ea6a23e86d80ad1afe35fe07e6ba00179fa05522953b75b70eea11fa57eeb7b4137ff53391e2ad80062896f581c527d319482a939a4969e18214e07eb81293f8ed3d018753526ac913601ec391026b02e2efa2f48075b50237e5b1fe024f253335cacc0ecb5e23b0fbb272f3c9fe816c291416dca2df430d71dbd592a35a631a9971306d4a5bcab1a5b1b7357e315f58678cf57330fa30880db5037e78a741487c83f277a02b61eb29c666d57479bb3486df40511c345a18c73eabeab08a9364a344e4e90ba89e6ec471336fb7204117a1a3507cac0eb0636d10c07e523c378031f171f23634c902e2c5fc054c53b6259c84564b26cff2fadd783fa3aec2aea25735e67ce5741467dbf35e916a0bc2a9c81c90cdcb29164c54897f94b061800c7030fc840db9cb03635e84801e0f940b8b50ff82fa1b33c67f464ab2b52dc7ab5b8817ad580e388ac2b920354e30b9e8f5d927d64dc0a790542ef84c87b12d0f027e0a49dfbdffb219f66fc177f45f9e8dc2cc52c5d1503774ec2931d84e448914aaf081164e6d4b8dbf8d138e83f80ade93cfdb0045cccb7353bc7e74da6e2908ead25a8d482bb6b02eb6c20064524eee55c93f75ad906da6cac2ea5fa5c53b595477a46fd05b2eeddd98bcf81ffc0a95ad74d821b6f563c039d694fbd828464e2a34973aae478df6cd6165e5b76f8a8eef642c12c57a4037d1d518b52093d588e9f6b2849dcb0b733aae36b3d34abf16f8c1f8daa9882df868e06f60906574922d0a0ad09507496b3aa0510ed5eaffd4a716412dfb93ed22d129b812406e7bffb8693ba106c547af3f3219165119dd1fffe0d788422f23101ef5e44ac500f03187490aee60fa1d11b47063859424e83c1c2ef308220f0e609256ee334d10c6618c856186fef76c655a5b20affda6d5f91f2920e4e3fddb427b585d8a5fbf74088d779340a231224fb9349a9b9ceab0e7175a75ade265e742b4e0a8487beea4b2811817b04d30086dec06fd075097d21146f2b1d7021bb9a0cfcea87221a6ad6bb370f243e8fd78a678589013d1e90b5c9f632af53d883a3aa64c7b9529910a493254bbe7fd549eff958595dd2b87f9b35a13bf87a8c1b98b8ed001743a9466334b51affcb3e234fa6e0a6734a2d4b9b989525987abcd300d6f7f75a1a222a409ae5e56367119932b033e8b4e83b8047347a4d06d94d323d119a4e6a9f36ed4a0767db88f5360238c3b2d5c684f760b1c91cacb3876009301db3ce11c6430b9bc026304e6c4f0e583b84adc57f9a60899b2a7ec3bb7ff627afb1162b76697bb3c8b1faad810bb8b99d372842fda5b3d7fc195cd7c931731b7eff3e532bad860627cc4b853a3f465e87e003d1953cb3776345130c49ce49b64fca7f377b3b91ca99ae0309da1d9ce360205e998c0e088c766a80c2d748672eff16285ffb7e17ca08a6d9a36df32a85778ac932f978e423b0eb97ce9dc19fb2fd206232c030896a5e63ff35d835b305863fb11c0c10aea6cb397e5140d1a5e81b3ac3c5ad9aa2084565009d523c0e31213a381cc89b01d27f868f051a3b0d52041e5b61725922c34d6c16a268c9d484b129db43cc44525f96a8a5045dbda1a3ec26bc8552cef2577b80e55358b66ece2881ddcde65efeed41de1f059d50c8bbe21cb3c3730b42578919023010a3f241f7a7f400fdfafe5518fd72d1351e91d9c3b126a1bc6f64a17ab8f5e37577214b95973bd0f66597f98aa0253b104ae1880aec744bc5c5427e331888bbcf36a90c76dae11c3f1f6a6c35a83ec5f1625713f50b36371d9e294932d618af7e9b2aad63fe79ed1de14545959d10027f5f7ffecdb57e9f65f1ef74d6960d157b6be8594c8a2d8affd4fd990076bbc98ce7d137577d5edf126bdb41fdfbc0acd7e592050c98aac0d5188e6bd098b6ce03ad394ed1402316291c98f59ae5afb62ab9e87abe9350c0f038f15937839232316fde4c55a6a7d47b0c8f006ef00928d05bf359039d5c2e83e6b9a5a717a19520059394abcdf9a8f52ce9417d9061275697dba2a70759cc1d7b906add68e74594c83a65217cd106ddb0a9fe92ab8f94bcc5bd639bd7b37eae9b4c10be98d7d8c23444b79fb7b5d9c80a210883ea4294a5b4f0311aa51c4990c7d82198c734784c7b1c5db84b8d61e50e63da0b01fe3774898cf4c3f27c9c05fbaa73eecac883a75b4e245e16389f59340d1107674a217a46eeec16a4f252a152af331879eeee93539640abfb698e85bae9302bbf3dce9c14e7096485fd6060aa3c424589d1ae0875bee99c7a6bcdde96190ace57a3515e0730127778905941c64c0e1c31987d90449a5a421417abe7a4893df12d41e2e81eb8a0a40509e0765d02e940f9610666240aed5b0e607c5b843b20c2aa276ca3759362ba9e7d376709920b877a44b9167324632829ea625c1ad88bd8dbb9406d037586f8b0d16a6cfd39bbe4ef253d3995ed89800841a12fb6a722f5b05562f04a0f225257d517f4f354de89dae87377b663b5216b40d88ea8e901359ec4c69d42ff99f2d67c6eca1006ed3cb96b5050eebe95544995371f0cfca799de46c018e0c1558823e7092b14d7f4a6aa5c82b6a179b8abf3955e970d26f0920d6bbed21dbcd087e42f598dae2cc35fb992da66b5c6691cefa780cf9f90037bee9756a796b4cbc2e117442ffd927cab238aff8ee3962145658645c06e5606026973332a1f46119641781e8c2262e08b1a2688a12882247fb73460bf10b69002f2f15b975544db165fda06b90c88dbe4986255c1038586564ac5e7d2f1c156006470277e62a8c309637c66562e0f5b3d6cde80c657f760c508f79665e6c554b154d033378be062bdcc9694de4ac91f8866f9fd8329fbb1d76f3b9380f8393c1284fce269e7d239f4797e1c5ca1fd3fa48bddeed537030bfa3cab5fc1b57365eb8bcaed1fb6ff80b2a216429fe52f7e6d7baef6d046235619c396a018bfa8b23a791fd42d9eec30e12b556f1877bb7eb725c382e164f445c7489189bc247776854ce92ad736ed39140609749e581f576105934ac7a330c538a295b11a5f78f91eb5493d9c130ba55e85247d77887fe7984585fcb4a0c96470c620fe716790f81b73a021072d422cb21ef43ce8e381be8ed8440950c2f45a9215cf61bf2d8083707330e003ee85e234a5f50bf3f8273bfd937e66f26ff69cc3454ca3383def1544a5889fd4fae0b30800dc99da0ee4941da8afdd9019084d0c7dd2a9c1ea1e24d38a8f5b84548f4005f282c7060021e3979fb4cc995f94286ad9e20f9c9ec0b18980ca95c531660c6d921a5d9318bc5127590b068038c510e5d99a6704b5237512a8952e0c537df7e6a0ef1bfd3b9015a685e1b5f5e5a3cf4bb72eaa50b78231a92e65857ab9551f7bbe0d9c5c2ead9c2f414402d44b64828ec768f5bc9ac69c0f104c9b6e8bc384e8eecb369f9af9a7db40ddbbe8fae84a6006af5b355e928c86d1b3aa22ccc2c624ef35688aa85e8ede03914ea082d6a4f665d04836c0e0091b2d8b23fec34fcd2fb960553fcca719bdaeb4c6b038f9c69bc0c278474643e00b01e5c2798953bbdb65a907f960e61e1bcfeb31c482e5246b7f5590cb799a565b0c2517ca4a84406557acad01fa2ae02b8df5cc44657049e14a83dfa67d30b4f6c3dbb943aee0cd5f9e84ba2c9f14b4c201ec2c9f451127acf194aafba2315398a814073491d32cacd361699e55934eaa173606845df16940a7d761b9937ce5275086bbae92a40e9385c543c8ac51ec926f0c3acdbf2bba55f0b9f0e250f95cac2f3c298bf2d0804202850bd9364b7367527eb1260e660ab360ba4bbf4a2b5fc9e235043451acf1197b3d36a7dba98a39db192423059f87bfb372f846eade0ac746670f44ddd3ab23f282a0c6cae095ae94eabc528e402ff0c29ddbb924e412aafa0c51f405cb6d5bd2bbf30ff8878cb5b100d0bef9a8daa04a61786e1f29e00afe2bbfe099a3809bff990eeed3f806d7111c42cfe354d89d178d02e092b22c88091aa8417c0c0946d0795f29332f8d91373aa89d1029c0906eeb712d3e0c0c397f8b9cd26c86992d58d35077be2c6dd5e993917b70f1a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
