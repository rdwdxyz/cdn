<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbc0c134b8ede95a0be90d22ab6fbc3b38a8ab914d4ffe177cbcbece79a918cceb5cea7d4562135b5cb30c18ca0b3e9c6e24bb6b352ef9236e752804a33a8756d959906990e5e357d7ffe414d0400251e954516617b343a40be0536cbef58768fa1161f680b35726e568b2b6d2d713c7c94458d3009aa3e6ec77e4afd14a44e65f2f6cf63165510dc1e8db3fa707a26a17fcdb502decf19926349fd619f192caf2a7bbe4828ed8e3e5d7aac2728653d2730f3cf8105593cded9ab84adeea5cfdb1a9fe7fbe1a83824871dfb70b31a61625957fbeab6e7467123ee876b1b653ff6c22f5a08df76d8c5c5686f4a143b0485508e0ef6470779fe42c79c479a8a4f166f7a89c940def61e2d1ab9bd6b7c33c569ddbad4b14c6c4789e1710f2c3debab786d6f0f91d3a707cf0a44551db9e2500d0743421c52a1a5556490d6c8008babbcb93dc4328e8064b6b63a3ea137bfdfb2382e8ca9685bd165237b8e66840bfda356f7788ff1317a6d6567db87db5e80542f40379c8f32dbd1d9936ccdbc8678ab80ba37fa259460813527c28bf2efc4452bc3fb3ad245ed6c3e8259adf3a5c0d2afc6de3f51a6c08f793c8d82c85bd4a84a1217334edd8189f4d74d37ba060f0b5a736e95ed2d3765d5c3536e3a2a334559ceed7ed7491622777deb80009c9e5069fe415b30f630247a24da89d02b58f5c6d89febaae36863198d6e013db73ac86a8cb2b22f74891b164a5ab5a3ab990c23a448740dfa67f2e312c7b32f3f21b7262eb2e427702ced4df4fca0123a802491bc94ecb2ea7ab832486eacb58d88a8ce5b9ead1b7e2599727c5715d7375151f4861e9a80dc01b1eb8c416d39647739476cfeed157a9f1c9c075ba4af253b0897d4d8e6e6a4fdb70090c78f5091e825b425363ceb6ab893a6db15287e58b30d93e98796b15bd772b833c52ff889fa86f313bf32b9f04dfe01d530b3ffaa5a5beb879bf7703be07e099729bd9b2fbdb57133b0a34673ee9f8ecf13b3461a0f37fcd81255c6572564048d45499daf3b808996e7ad6b7d80c3cb526cc392c3a2eb0c03d329bccfbf463678fbe476db9ca83ccea886f397acf7bdcd7e6846ec3aca9fd706114575a4f9e4688126ab0ec5044280990643eaf051158e9037fd47516aac0e8ebc162eea7e2e85e02163fa77dcc237885900c50a5a23377976f2a9e3cd1a420ff5155d6f400d8bea1a01ad8dd76c09ab658f1b9d50e965b3c33496ea614f50a9f8b8c0ae6e1951d9deb4c1d06b7dafd59d19b86f4de616e25452942dd7960900a08f3d6eed72badda621500577a923d712489441a5cb1c892efd91d8aa32d80c021afbf4c2e7287b4b27686af4fa183b096b61bdf585db18b419881be0147638dad97321f03d01d8b9923a5d1d542348ac33d57f31bd23790234ba18715c856e1acb0fa22441659dcfaf5b587502c456d46c98febb14eec2a05905a33020e23dad17912aafbc2fe2a0b68a7d6dd39de7ef2996efef12c7db2bf52e0d5d4dcb13ef16856fa87bc67f521db6ac4c9ddb4018ce307d41296ac11538cfd6d5e80b3d2ae875dece146948276871bbafaac7cfbda5d96837378aa64969f69a978ea14431405b8213272cf96762cc37f09ed5e1e32e4d16305929cc472032a854ef5f5c75276ae712ec5a2bcc5a1b17a7ba4f2899b98ae1965a9bf9de19efd69643102d163a9335308ba2b451743d903cbcc169b478d024def86346bb80f5f5757164bd0b51ed64379db2e77fa29aaf71aa3c13a7ca8f85521eb515b517fd531a31b9a27d3f972c3fc708114884be6a06cc93e607fa2e08e98c029729a7d481a7fcb329e345d664ec4439abe71d0eebba8dfe98cc8aa504333d93ba996c971c975f0821d87eae79bb4affbc3b0aa41adf5abf392554a46d30e2ab6c125bb32f09cb59a6712aae052d4061232587197f101027b0dca249163d574660cb64410abd070e2cbe7ccb10074ac3f521095bf9f6aa8aa2bce87b93bdb2e289b546955911ada8d8099a49dd89fa40ee067fe0ac45b26094d6b49c61cf01a66af85763f85e42abb83140ea13e1dcddf639fc9e6e10e767e0ac8de522996ce03c9b6dc33e62f7ff84dd3cfa7544d9955325e23d2839601dbd0a5d5d736cf862e77d1cd430c157dafd2d7abc60b859a149a871a03576a91b76ef03d053ad49e7d550a860076e31346c83e39675c2e498e6ce82e19771b61c8b73af6ba1fc93f932d2f72338b4b510b399af24eb1ade22e0e896ef700dd266b5d7d95cf62e02a6dc8b78ba61d2dc01dc468182145c01ee450253c62c19f52c50cc9cc3de740a44186bbd2ea9cac4be19f8f9e62e7caaafd3780cd731780a1ab74315eeb4d8ad8ee0f4e9f7acf549979e5b5863d4d0caba30b2319e29403bd8324cb336cceed1f1b338eb8905abfda4757e7974a7058955873997032c2fa2fc5fc2b5b0c6039f334e1af343ce81703a2216ffa42f836cc1994c0645f0b9fd1aa62dc5f477a10b19938c0b8b5d9c3f1523620ec479c2db8d50227ef4f53729089ca57ba270d7a8f47a44e7f5cd2140b42304d48a5d0c8a86e3e03978b6a6caa5245ab6faf4b4fa0c4ae43b48e77b619c7f2f7c30bdb242919baf1a2b090749d809214835adb09ad716273516a82093db212e4f15b96d1a980767f611e15c5b2fa1bbf6e0dda58b66d98bcd50c142262cc75f916bd529d4361fabd72c41900e62e981b931d7ee3db9cf5f6c29ac909abb6da78de6f46d23cc091e48c917eb9ae6c8501b42b75e29d29e66df91e4df3963be33eb15a1ffba7975f0f59b3234590cf8e4631fe63c6e81d77391c9b8b3b8a2711bdb18486ee9a485acf4e9980d6c782eee23b2e1962e16d4ed0b4b9239e3f684c768b3972c7237569bbcfa756f0ef53fd4c83774a7627cba65d1f16fedd6b37bbea7d258dab24e9843932558804fc2d5a10f8e485e6c4fdff3e0e4c17b0869ab3803658077847f9aecf02432295e9d842c6a8f738abbcedd294a7071f4aa4ce222b752c7c71faec49d4925e87f00db4e7b0fde4533d8536be281f1fd44031de52a4eefdd7b8e3845e00199c79fc2c10291a516b768e4f771cddc7c32f84e130dae3b808f80abe23a9c911d37260b3496deda94d1efb2a0a469a9c7bdd734ef9b51205ada554fd80cd92c89deb99117b67f5a9bbbb68a4f879a234228dc08d3d2a733afddfa69ab9f9c57bba7bd8716980289ad5b53bdca3d1d62923a96c12057b4bfb0014e917ba3bb632a7485284678c0e38d787fafc31e5d99840ce077b12661b428022f017ba53febdeef24505d5a61c48f29ca846c8e01d65eb6ca3b0d6a1b57e9187f6d40c472aa1b8489dce94faab4a3396b3ee43a989ea6d9a27cb2e20cfb35404157f2e137a9c0e7f880703d91daf873cfa5adf39c3c18d9cb7a38b970188773827d9af84d3508cbf6e0957cc14a59bb065b2bc50915a25e9856b9a748898219f99971f7b5bc346951266448ff213c6fdc06fc576443226a7ae8ee9ca24731dcc9897a5cb8b5b98327c0939911c3a6b00350c4ad9f3d120b246232a1ad5c5b9bddc18d1dc7434b83c6e825c5bb0303ddca51ebd7aa439b97fb7ce5bc88fa17e9788c2d064c7b0ed739711d5a03481cc70df339054c2ea0a0d70fdeee92c9bf13576d17e9925f29ed91512bea8d045da8fae4d18a5fd4bc4b406d7b3d89e2ff27a6e5897c3438c3b424863597b6fde99cc92634634b28bab5fc66d9b66751640c7c7edae1bd218d91337cc6d4465cabb0e57172dd3fe24029d00b318cfac895a25657d3483778dad16ed8ee1f8a1363c16ae0b817cddd4a16565d92d71f459c6e07ec19a14580d3c82dccd39a2cf6d9a1e31b418fa89aad599ddf38c250fabdba71f7fc91f735caa73d5b0ea413a4f71c272b0b100510b2d3ef00ff45db403fbbe17ef97c2fcfc225a62ddb8a3a24dfc3fd2dff3eccda485364b60a1a26ffeadf097727a307ecbb49769211074c11dff09fd2734d46971efd830fa20c7773ace6b101617b2608e45c1e1be9d322ed057cd02637da8dd126b3124f40a73c3f531c79cd9ecceb7a3dc295012f8ac7905788b71c2d98507adee900eb2d8ece6a482a6533127b407d5433e581be822603db8d8d4f1b1aeb2485b597a24066ba7f5c04d81b7f8249cebd1ad83f28da8c02dba5e53ebedafa17b3dbc9f19479958a289400a27f81b5795b17f6640bf416581ee85accb0e589b101551f5a6599863f3ff767d291a14c5b046d363f7c2e0956e71150ed23c77dde07161b3293d4ed48e1dad9655b825d9e7922ff91f70bdae4fae90deff9312b62236d03e3c378c5d24186864c313b735643be6520aad60705daab8d9e27812508ac1f3c5af0717c5f2b0d201f98bd423fb5c8e84fb40bdac0e81ef63bb1455e16cb7c36d2329abd58002de9f6c6498b4b2ab53233c5b271e9604c73feda142fd191580adafa3bf325469b408a93247864ef307b0a72b90b620efb92fd0df148faa29db33291071bee678ad7befe8ac28f08e4b89313e4f518c90cf7fd92eded80c420742014333b106c268eb0e96e951fc54a6a2779dc4e519ee7988027f3481a0f27a2e5d80ddd89c0bba0f5fb3ec3782a7058138cc2337ef29ed397dfb8208caa86a68bff06daff2ba8ab91eb8af5c0a8445520dbe0a443ef9479b0b114351c1447362c7646a8463068705c3c9ea6700b8b6d1ded9966105f5e7a408c005b336336772ae3bf1acd0fbde812864f9bcceffaf5e428d2b6100089add760557840c1a2031252513b10514e7e4904b57e1b024ed1f70f82a6ad8ffa3357e32b034b670f5beba958282b33ce3c4d9c0cbbf0132a37cccaef7467b68416c5ae6c0c633a76a4e4ee435211d24f4486b72c7d0ac032ad3822e6b1efde3e232dd878fb91498230fe049db49442e5486c9dcb67039de717b8d7b031b176ee42b7a4f190cb874bd190a6965be3bef298d9e7fcc40fb1957acb931049e8794fb12d1740ab33ba34ef8752718a6eeb40488300370f95a3dd3452704dfc48126009c7fa03f1bb3caa20e180a44e4ebdf57e9cced7dd841360c1977d2d4127fbc28ac12277a56c72ee165692f74c57f421f9021808813e0d6c0043edb32223c5b14d77622087504d06d3c652777af76109ef8648cb5aa72f83e7a021750445d48e1339d836adfeb3021e29e492281d983d9334c29bda40435078c61eccdd33361569b9acdcf1d6563c0ffa94639e3b06bf0bce78bfe22a5d592fab39eb2bf064b9431567989e75f46bd53df68f20081f9de2c48b18527fe1f3a8fdd509c3d11bc71f66195c73cdaffffef2e79b1f137c39c379cf1899eb97d828b062ef7372997e9aa8a72bf5ada49a10465610e36dccf188ac4bb0fc8a6edf91cd7e530ae99e9cb355394c9c3c0f06c9d853b253b13ebb54df491a432aabfa75e88e4f7cb834e2da40905d7f24453e9bfec50731dc01741a8fe214b4243213a7cdb016dc2bb5f35c41538999beb7b06b2f09eb60031baa7d6df7b58e1879215c81be3227a366b3eab9c756083e00dc1b5778b4457ad587d220846e9832b3e36e99ec5e168a6d6eb8c6a269560583c5284e17670b29ed9c1f79ffe5410dbf7ef89248395620daf8e90aefe94ea5b83f4c7330121749c48b55496bc208dafa09c0ce5bb2a0a653d062cefb04070230bba8dc314a649f33ac90be8ced7638137cbc69828a5c8b421d5de91dee653f8e5fbdbfc05b8576bf429106998cf9ff132ff186fc2af0588d7dfc7c97d49fd6de3b1af834e38b6bc2e87aed913fc04ccab613b028e4383032edc5bf27b7afd22a1d0d7171ad58a3224d5f7264a7f03ffabbbd4a71105145858144d84a166655fbfcb709e797a1f110af29626dc41ad5cb9ed9ddb64e276c1a5bb8d9edc767311fd1cc651fa20a7babc223180e3d93c64384e9fbe11c818d121c7b19281a783d7ed5537ca3a761980c84c84c39fbe5f0bd6239f9fed2b282420cc9c93c0320e25bdda6a9792ed331a88f66193cbb2ec5c3f450a18b6030b37f808ea013c8cddb56c30d5dc46b0d4864582e75363dce0dd1761e6cec49a84ddef669fd55a37a2c6a8498b5018b873392528db75a4bdc4c2b46c5408e5a6a0007a3f87fd287d09fc69a86a3517fa8863c13da4a9b7ee3a2d2dd17bfa38632e2bcaffd739a5d3a645b96c6fcfa1865c8288cecf5115b941c71ac8c3e981aa40d181f3cdd2b08024746306e46e879643c3d7eb78b66cfc8e7b77821521069e8e66e61438ee2767c9a0f18201955727770f2ef224649585d2161a2cf0a12d3106e761dfa4ebb5320cc7ae95b6b70df4e6a9470007554f3ea9f169597d7671fef9aa59a794742a415aa692fc42d91b6ebae72ef5bb6fc78d0611571d950448c9549256b4058bd972a845a877832b2203be7fa4544640d62a063269a8f09e436301aa47c83248c5061bc0454656efa6b7e7d75bf44e52d6f809cc263e78281595d472f55182c07ea309f19ade6683f5c764c3cebb9cdcae91759ed3abbe5532fdcc7c83d67e40884275ddced2572631098faa6397b3228c5def495c4b8731d6b3209ccad18307c7e10bff5e57a82e8100fa37d5eda702add941c3b8108324eae1e9064792566803dfd0ed4cb5074dc23d937251002cb2c43d767be8694c0677a19bfe3b5a6ed5ca8f9fe921d326ec4a8d291358fa59f0ff2069d643d072c6d5727a97eddc1b3b1792375dfe91439ad4839c10aa11c07987fa23362db85d8e529e1ce9d991a7bb10ff410eeba0c56155006301476ba7c11d8a729c41e00b891668dadcf6cc2e382455b2d4e38b19352f9bada91c206f0ad22bb190c0e56e15afa19d533aa2256d99e77d05c0589bcba79bc9eab208c9939ed316e9bab35f1127300efb1a13dd02358aba305ecf31a58a7deddbfeeeb8732feef946d6b4832243b3dc4dbe596ac617a0be28d73077f082bd633530ee6a3d3f698b0597ad1322fa7d15ae6ba33c439837f49bfed07f05b979f87789fb67c9b19584650a5c7b4611c2db5c9548ddec36466323987cc1d5fc4576c77be50e31b056182fb0a9dc8d34a2f8e97335aaa8c169d00d04944a511187b136e92a7274922aa579ba57bfe6394066124115edb0e75f9767c0e3d3cd0aa96317924aca3104676413ee2358c8096ff10be6bd959748109ec4380a328e1823da62194d135071d97b7c17aaa0851991b992796947ee956cedfef8a0c403cd1da65983c908416f87c4e4f7ce24ee3c0253441bd436042cacca312cf59ef9bd9a6ed0555e151aeba424c457c572c841f36d3f1fdefc76bd1748b2c60e9280bf1b4544082bd19c75184e001fae7e1bc8a3370eb913170cd1d7586694b6102856f9d47195a0bd5c0eb07692fdc76cd73cbb3d46992ee78bffa6cf383948db9e7ac63370f3affea0dcd0c03b0d0923f81a03337a60739f7e1ffc9aaf80107686077584327c1303638a86c613ef6449bd30c58ef4f6181500ab558793e592cbe45edd20b1084b8cb6848f3faac9c71f0a80c573cd4612c11740bff14e8815df0c375510495186f1930b7db46f7116871987f2cb6b94206e7ac96d9acdb4a6b68b97c77e990d6d2023f302a46d0ba0ce134757cdf960cee146ee98b3b7c296b645fdca0f4861b37e4761215041523435cfb3e6cd21d725eac5ebcc17f068b8edd6f54b86f486e102ec49c4bb3083992fd865c31847f8b5e1bc19b81be9c61fbfbfac16bc904df12f0668c2257b5f9a0b80996087d46ceae471d6b77e824f2dcb2bf42782730d26fcc89e3d098989cab9362cc20eb81c83ec850eed16ea28d2ad808d2d1737b690607059ffcb128d23461d47a966d3f33c4e37afe324f9b21e8888e301636d3b1435e43c2176c20636ffa8a3282652be6e762217baaabbc8cc7f21e974e4ca9990dd38712901b327878416afe1da7b4bae13fb98debd2b749fd2e03b909cc86d4df8384f714a12e11a38fff9e01ec5bf3da20998bb6041c55cd93b00055f4493b0176bc673610450da75e5c367254aa541a1698bc64732669bb79ba80b8b7cb83d6ab2072d4d7dc3bfcb830a7c3dfb1b0842b1fe283bfa73ddf5527ed2cc597d85535355783d06270bf9ed695c5045f50c460543d348ecd3876260149efa75f7c719f5df33788e6a651a68d23d3e9fca98953e804e7a0907adbd38fa4c278edeb606b11cd9abeb9474150510c6d96630bef2e0132314ff31b152f61653508349a4e68f40132e103965f433913898dc8dedb37f2bdeba0d16f65ae93cf2d88af7a637ea46468f832b13e423c35d249028c5030d4c6bc914e54ad226f9f1b6550b412041f13be9ecdae3b00128a1573e8ea754e4771c25e9f43672f3b3067d6297a628acc011dcb2c80dda2646aa011e568ae379dec88515827461ad83e434d9fb7bad36a21660ad36c86646926e2be07bac0dbf0d149670cf6ff89919e5cf4df643414c175a2cde3a3d0a0994d517461d4a28b3f29d1c13715c9348b8457a76c7b831ad318ff756333f77e2eafd59d8fbc2712a527516d2042d2b495d48a799fa60bbed59549296e690f41c16f0a51d5f054d9d24e82c7876b5fc02e2d7474c00feb60526420bc10d50aca3f2d95585a362c5c1b340b0063554ffb5ad9c7326444fb1c08216631834fa0bf7f8f627b0b78d17503291451b21a9f348933eb0597b528d687edc7a8ad24549d32b34969cef7fa313a8ced7ea595ae460ac84f7e80a3e17310f4eaa618cfb5a4217e80d1bf6a5ee18bba93b535e1b777b18664da439ec3e898499279e5769f61e665f83e933a6af79b6d389446d990694fe9b83af026086adc4069ae6ff4aae8d9cc7bf736fceee3a2e0ae9bdaa33930d4ead2af09bd1caecb22ad56819f3bc7ab43662743e7d6ae365b3be39b5dee21b0e6e8cd62293e568a08df16155b5a10849a88cbc4f54589ee17d27bff2edcbfed30819cf2fdeb0f5dcd5fa7da72d17dcca5c82f38c6d6d871256017958818bb88b1a21722740c0a91604e73d1258a570e57eba669024feaf9da86cba3f11f9a5add004370917133f1f4bc7c1459010295ea5ffe016b67c72adf596d06409ac15b1c262efb2bda68f82132b97d7d0713e178bdfd391fe2d59d7f30d646831410e4a6fb506aaa63ff3cee8235ba4b9dd2d8b625fd502df8a1ed23a9e98d25bc51550ee5975f515280de7e50242519980ae8a43db7d54923c440b0f99bbcb10e36c233f869761fab3b7d12f57da6aebb9d50042d17688066aaa26d9177641d9dbb79747d8881f1adcdece6aff7b51096ddee15f1d0c15d77a61944185ea67205b3824d0839feba713c4b425749d7f2ee8fd86bfa987aef7536722ee80dad15f7b366250ae102f7aa9f9cd50bc89544912c5f095b398dd4813d87fc8535e07a0f96045b4b741b162abf81eef82553b99aa374cf5e25e4af2cb9a117bf7ebc159675748a7b6836e2350574730e933740fd506813da14cfc103571b6f131abe57013e83f54748168b28dfa3aa9184cea42264d73d6dd0afaa0dc15b559bda0a6b7b065fcd6c0cdd8fccf71d45d614e547a44f060a3f0ca9e70f11c25ab1ef23712656c7f9cd8dfb93700c0a42190afc184ea210587407c2a5012ba12c176699b06b15705ea211f83ab0948877f2b1848192fdd9f1f04790ab4b35d0eccd33c35bd1f8f8e3b736f2b343032180c18d95efbd8a6933eb4450063783054a536e5ac5ccf3f6a0075424d16e0593a163bbad7caaeb3c9804a1ae60f9c1378b7b83093fd2437745673ef5ed240bcedbcc7bd4c6ba3e8a998bb86e8f0df95ec9533c9d9d5b11129890c247ce951e15e5705a33234360f8146a91805dcb990a861bbd5e50dae8e9744274ec5915bb22c32da3f5489452af9d98665adc51a25171739fba92b878418f37b8411cc5f1e0f766f0be75f3c1db839d6fe653bb51d4f8d9dfa09140f680f4560b730eaff2521a1b9071ff9d92cf795e55ad00cc7a567d56047981170eb2bfbd55e0e8fdb17f10fd37720fe884cca6e7065a510027e9bae9bfab6de8257297ccb946799eee1f313e86e1386611e7e10c37aa3128105912bc5d7254e4defe77a9538223a2715be64644fc8d3fde5453d2f63ef0a50ed8ab007d1615c298ae0f522c8cf259cce401eb0d443fd8f73acf44eace6e03b2feab7f888319f9dd29a0a3215ebd80155a89fb81f314a65147f802823c52a1fe83d9faf44b9bfec8a3915d6c5760f06a6057210a830fa942ae32a73683cd161854c85d5cb3cc30afe674e331e83f20bef3d8c0feaa5d06a628a6d80746a98da3785610c24c75c7e075b87aeace6cc8aa456ea39eeea159b797e91148520ab4e472a5f66cfc6036950739e85cf766982b57ada1f86b3ce47c1fd4865d35244776529f5d98c08b928a555cbd555e27103e07ff4d1b8f84c7f6a49fd458a6adacc7c1f07624c1024099ab21c6ae5a46667b62635bb7e0e18f8b33a24a22c72d2e86515a939696905152926629913cd0acc2083316b55ac917f9459bc0732b789735d1f5282f456117ebd2f9e50ed5d2bfe7b0ba0fd0cc7aaa0613120145ff924a672496b3205bac437910dbc6a8ba280720be25df938fab85a4e0d6651755267e635fcc6693a6e9b55f8e381edc0da43a106243b32d2f9e24c4ebeeb3164c0b0e3212b4a68015873c7546fe21182a46c1a728bb33e589fb9df6c847b595c61c581049fd2f6e524ebbf49e877f55eded19a0ae98556ed86d68f5d9aa5849bad84d1812e54ccce09a09a2dce0182b9405a793c3857b08882fb210faeace865729887ed872c1e080437e8251f0a2193787afeea708997c32b571aad2bf4067b72486d41a0933ab9b0d6e1e8568ad1f1955fc855582d89507711276920a6b8767814d1cc6e5766854d29e43999765b698feb646b20e95953454b5a312c9e1c0d34ae388b114470a1b01f0938e058f85de578db3c294121b38ea43397a2a224e89991c7e636eef460aeeec68060f79251a9bf87f2a523c04621a73d7794fa47c52b68ccc5d7023ec1b9f5c522a97e6c8df1fb15191eb51226f84fd2bcdf6b667ad2f879e6e709ce1d7b1b4949dd09a268027765d3d20ab304b144dabaca2812c649e7a4004851c787cab4e4bfe9ffca544ca00492668e0d11ebd5dce6254b6b5b11d824e049858552bf864c596447c360b4e28ec92150de870f002e0b6656a3bfd748e1e14f686cb61dd959ef5847bd229bc6c35f4a5192fa0ad8d351b9f8c5c9fe642285998f77f6cbc709c1d7b2182a2685afaba441b9db8689e298d5a5b3e4357333f44114d183dd0f28a24c0454d3f9b8329edc671fccab4b9fcd416eb11bab3072086a55b334a39e5c1794011dd8a4068cf751f4d8ac9df5b0438ab85e53e258ade978db4094ffaed82dcbc4df4450cbb235a014ee49753f89f5dc74fec775d9fd4b6040e50888dfe0e2705ee01a557b699fffecc61af629a2241daffdd9e00cfee8b08fc62429d489158e3a119f823999e20d5d6c410c10b24f9f0614fb6f366ef7e11b89e584fa529282ee5dcfb47401bce0a4b0396dcd0d3a8387cc32ce8772c399ef943e1a7b9fbecab8ad4a27f86a74166626e58f8877298264c9813417b7eeccef3085ced9884c7e8737e7164b2cf321ee65f8b4948552af2848dc21a5354bc8ac79980dda31a3d31e6c821744ac6f8a276a34c5daf39e0516ca28ff7124f9107b54d33160cda47a2edf608994c2dfdec45ad6569c20b79c1c149a1104efd77152151a4b83b6eaf8d19470ca880f7c005f045bb530af1e762fa10b9ae8ba168c8e641a7abd64df89bf7466e99148d8e52b66aad0d7e86338e0c370ec036550556e8e3f9fed8675abe2969d8decf2a6fcb057e002d5316ce9b2e5133fdb73b31eb0492655ffd0bd8ce23a51766cde4c2c680b0bbbce3fc192f14b1e48405a4678717e4786ab09934603ef84575e7a799ed5cd421c823d3c9ee31016a08074f76f626f836ecd7f8d1b330f5035f2c96fe753e0ca2f6ce1ae86069d244ceb1714840827a074b4197425cfc6000dd457073929797fe70da81db3fd60dbef5a73f3c830ebb7933268a7b3b3e479b44b0d26f848d5ed69a7353183fe2049064515b841931a462dc4e5b6e80a583ca0ea80731fdef13fd1734e43a3b81699c3a59756ec1285b18cc07b4b509d6a72f9e08f0be87802e6faa7e23e3d2c304df16fc21298aeeb5fa23bfb8e41bc17325e90640c2a1cea28a4aae2b7bf6fb84ec32b4e2d66dbcdedd91259c01bfc287f215db68432c6ac09fbb7c783bedf0b24477249ed4c213fcc5edf3acbfb891fa4ff962915137cac13f23715d8f2fd9fe17991479483c5655f9011cf651456508e65b1ba3076b061da1cd405f77759d34dea6a8475646c92bb0304698a888e016aa69e92ec9f8979facf415f7b408fa98988c627038e54201abac9b7d07e0062f49b74d08d3134042d908aa26e245ad902570923a0186eaf5ec3b8d73eb1f119c1a9502ade70e8ef522ec9dcb5e447e2eb30f09bf494483e48c7298fffa9d44d15021be9fbf2a28a600d98a92223b9b1e19a0c747c65753cd6c807a36ca29e679975c20045e074aa0a96e5914470a73fb767b6cedca228db7637a0ddd41a04137f5816090259fc37420f5ebb4dd66df373d6583ce0ee1291ec67ee1c4693b727b3817adba1482831e15a2aa0584bd9fc1bc429df8293ed1cb99a53b4fce938e2741212cd8522b6166441315ba050adf5cadc7e5eefe7f1192933aa8ad562ea6b4e548fc730e426ae6849bc4ba67888c5ba87a4f3ee6ae33325df34be948d6d71b92428536fb0409feaed4a27ec6d891136bcc0af3c01058304f3fbde4d548f85d9bf934209bd39f6e65c7497252c1f2214824e6a604e828849bd3c4b58e4730484677a55fbd8771b80dc361c834beaac78580ca814e2aa9b0134422552e3be6cab40225af76d6d69fa9ee560d9cd07fb14dd16bf53827494f3244bcb774f92cd9203bd3c90fecf6381155e39e0dbf40769d719a2c48b22e41df13de32489c5be0c4235e70923cc297592b4740f579243e1c3b6d86e3408b57b42492b4d2115f47ac971beeadb7958b1d41071d588847198b9e452cfc4002bf3dc7e67d7a4d1ddf6ad43640bd09bf8c6ff0aef940fbbed289cf2ed57a06e168aecd25132c86457020186b0c26755f98b49918ea9df964112ec528d277c1d55c572a532ddaf0dae92bb7aab1e46809779f88f19377ecd8b21920d2c105a05264bd385d9bcdbbf404d0c382923ae423096f1061a8b1df02f2647cb1248df1678ac87dd75b197cf92b9abbb3922ba1186ccda1d85035c7a88eb5ea1c934e7b3ab9e01878d5d9063f6d6ff792ce96103e36f5ef3df62a918227f685ac1a34f4ad5f64400177e196f15f8b30c78980021bf54cd50e3e2ad59fb21bca841d4cc778f9feaee3f3dc0bd32ee559130aafe81ea8095ea1cd60eb5d21fc973be2b8116b1ebd2b2c48afa2d1189790b59103dc82e44680ce0958c9aaf254ac7cc320deeae53a43a3c54b092163b99ec3d0d8bb59b425474f5733b20e545729b63b948bdaf6d7796bf4284cb1fc2b4b259a8c09ad6e166f8b202bd6abceb34aa290039687360610497d4a65b33c2b59e0a7136e998528f6c252e5229002466cdf989bead1583438612ecde281a8c76593c6c3d1bd7a8d992e075ddc1fcb37d1504ca3904966bd1b7ac872966fcdf8ad8382f8aec93c137a9423f603bd2777c8652fd1ad24dd4df1cb5c0084484c86ac222acdaf7b6faf3bf48167d0f289cc38fc59f2d37d822e769fcc1f5657d30d25f7bb3198ef53e55028c26e2ae569545fc8f4bc9b47e68373d7a51ca70659a5bcb13504edbb2a395d149d06edf5542b3e174e04953ed93e5bc08030992b70450d9cae915b8b65dd3b43cb4367d41042106620bdafb96e013e92f6a2b8d6c8a29094f9151c4f67e08885ef29d44fee789da5f372dcbb253f4a099033150d067facd555e3698d61c23351f3dd9c914dfb288d0a50735e39af351167d4fe84f89a9ce8e23af9cd3be792437aba20dad4be6419f4c17dee212f8bee71640a8713df6bd6cdde908bb5ff6ff58dabe480a379ed2deffb909c23ecb4ef458fea0688a5fcd2ed92a7f349f8c0460725d3cb047c4f9a84a3bacf4a815fbb2b69d1963b1731028d341a83e1581453f534f28cf71ff989e1ba57782d644a6ad82fcde28797cfbeda0cb2dbd03da191ef54f8089db48e94042cd4f704a5b0d1a04a0de89dca33e2f5ceac74963495918a3b74745f0b4160fa62a948085ec4164b7b754d160d4d62ae1a817ad2985888f90c7504cce5ffd0e150bb927a4a502be15a9cf7ff96d568f65763ae796db3af358713dd257c633243c6b69fdd59ec4cb95a0084f55ef35f7c98f6e13f1baad3870279b4573ada2cb9fe6b7519e4eef9975ba2b72e0c8344a3374380e8cde19d57f38d1d772d4658b0ea6b42323424d71fd5af5aa6df4f78a23e109d737d3d0ab9665bb53468726815d6c2f8ac2c5b2c75b5bb20a16d1345b28aaaf9c51bb58eb8c522c59457f8eb4acf426e1174accac97ab544905765d2508ff42af0c5565c7a8bd65e6b198c7a62ef5adc655f6e3d5d809e2e2afa42e8748db9bdad15e92fee5c5a0d4b7d8ac26ecbdb0caa21ebe4bc3c8bc1f66e7845c464595960156148402c470f1979f0a5a5016831242282d85619c0c82ca99568029a8cf2f78e6a588c762b52f9e3cd006118bff84d20b78d80beda839a138ec4f6f2e227c2841821712ec8d602c55a86d9898bd88ec3cee94caeafc56335967357556f8cb0fa5577fbef35d09e5bd37f3b304021d7f33d4ed80da6194b4876470077892c877ada287939f922c5baf30cfe8f6a700dbbcf8c3ccbb9c913e098a1faab85f3e550befd4dc6d0b629933b18d0f8da4d6b80d74c985540317ea66c7244a63ea6fd13beee8c30e3029f03db09443b2f5843dd55f537b6917323648a40816b3ca7716611085ac239c66fa10c468654ab4abaf56b79272be93e0243a4388fd57482d4bf90ba64d99406226218095a46432cbf8e8474111a4b11a5c03da94e7a9592311f902c4bd9ba28c4bf83344d129b884dedf62538cf65a1e7369b6f294059073d665573247a547e97659bcfe52effa88cbe633c81b6f6e5bc62c2fc528b6ae2af197c61bc5f0e1b1954c1dc1aba9dd9468735b4081f3b6d11331f6ca80f2d81619baaff8ff654108c798d1c24801e75e337145e25aebdf83367962a56c3e37f19a88f4b3acb70675516236d6e3f931f75451a25e67d5eebd257fbaf01c0d88f56460b7967ac97eb8c978a6ad8ad9120a682a416ffd012f02dc7eb112126e6eeccfd1425a7f72abaeb06dd1931f53935b536a87315833e7d9d701c4a3fc5e7eda5b06b8ea6fdce1d5d8c5caa4b96acebe6d64c46ffd05b1092ddc0830bc83ad4dd1958ce78472df3ed3d469fe7ec08ec0f204cab9ccfbfbbd728f7145b3348e2e6e498908d44a4257ed45ab42fb03f627fb1664615195d378e778fe94fba4b1055cb87ad0a7701505c61161e809b6bc2b816a15725b295e54c07997ca5f710d05606c225f2b5ee1685b7e3ae0dd2e7523b4e2830317cc24d89fd3c3031bbe308266a7ced2df4ebd56bb7285f1b7f7764b193ff8dc7a44623fc84334b1daee28c80e8a5904dc24b033bab7815318b7752bff5ad3f91af15c8176891be2a2688517f55004095c42ee40bc9fb052f4590168929361889a9bd1d69f63b47747d84026bd729741ad99a119a469f06eb6995c82c65ceed9798e882d89c4747149339be47174a9a2fa895008b3426e35cd1ce6d53cd597dc1fe7983de04569bc0f5563926d35760b16e7312f4fdfd9973f8c1f2a6d86b1e68b335f0a5811006448c853ffe8cb60f3e84eab48ace391090f372ba5bda30d6b30e47719ba5ee7e62ebd341141afef601e89ce02f77f6e0d9174f9511bd3a1092bfddf06238b9db41edc0f94294339107c818fe5717ca7460b84dd145895b0affb0fda31be102aa3eb6e15768f35602fc90d9df6dcd0ba5b15ec845169682232d4376a052b2a86ad8edd120c3eaf2d99fa4c20909415a35dd00f880b433dd2378ca5f90e01d45ab5216c6c0be3318155db122091fc2a36c37a73ff0962cbe72b0e877e06d3f725ab3f08ad9ea00e9a988166c318871dea2f589c854572fd9f71b0badc03645623d74557d8313d05bf4ca93d638aafc1c42f7c2b5fe3a8eae56f91232a170f47a9e8083d07aafdeb0399cb23b3209ceaa0e2d90bb6d8bfa012cd3f18a577574db26e254220d0de051b93e0b2b07ee8d0e4bd9e99dc3e0ef4ee4d73cb0641290b2cd4fbeed448eaee751dd04a7fed1acee7cceedbeead98dc1f49aac955e75ac7a0c5a7f6399854da5c637d79fbaca3b6688f96ea3f1c2f6f8eb194ce1f2900105322e8e047f720a91749a0a651b1b3143a891774ce5e76919bb7c2c3cb796e9d66e9b134970ae5a59b8f84fa786ac8772b99fd7b9e54cd538e9e409bc365b8bece0d44acbd6af3d2b8628963a3d4799a41fa3183d7ad7996994b0d1db412f503e802a6726ce586495776bc5eb07689e2a8dbfb5085038af13afb6fd4f097212363549743c995e75df38aad3a4bfe4209dabbd4a6f1a26e29564c39eb1cf0d836ef55abe36e792c63217b55df0f4cb60e63dcfedbb6ab1ecc4b66df417358dd9ee679be02f26e71e16d994644a24f50918e8cdc4608143fdd25d9d523a3b624285a6d8f8278eb8f7f3637ab7b802d4593f279c5bed8b3f2af4de9381cf324bf7ff4787f72321b628ec89ed1d7fe733fc88f8c3683ed59ab8616d3a0a73246edcbbfec086cdf1342fa393828d7625702f15e056fe14c0ccabc1f9efda3ce62fe0c60fe0acdf2f0033d46ab5efaf44a12aef8a5f569da20df03d9804db75e2aa9556463a769a61dbacd82890780776630f4a691a87ca2cf2cae8bea9b0c1117b26a31cb005078c217997624348540858c9c25849dd7ec8bf484f54b21c44cc6ccce0f1156dd72f2e37fe8a5aa1557dd5dbce18bb82dc53c1409d377ec0032ac23d873aef4dbe904982872a4f1dfe4f8d47dedbd74c2b39ab3e3513a6d91a8e7c7faea2b61ce67783438abf77548d2752e5fc4b6751eb8ebc71cd36335a8ee670b94e970d0010a606775db4a13a953e52779212ff8c113bfad1b77adb151b88793f76e43f62674bb7677cae8b0d8861e41a72422cd51e2667bc89691e13263ab6a63b1b5e6f3d33d8b331a5f8bf4f38b05df62690353977e2dffce1e3629fb6993b815a90fb579b7e2d4461f3566cf11fbba00b97898fefbdd9f9c3217eb85a89f956a246a9dc701c1abe07fe4eac9c4e82e57f498faec70df1fb46fe89a89ab7854185e2533ee3f93ed9eedca6d7bfad68b88fa92aef96fceff21fc777390ffa2f5d0900da1ec0a11d50d6aeca38860e83b2b79afe5b0ea51401fac91feabd46789910833b2df001766c3c061d4000b73cb1c66ea509082e6841228aaf5895b3ebdb40256654a6e9d96fb2fa02a634f46203ca35c1407f86cab7a462f3da2095ac4d1b3b4280320578629ce438265275badc56e8694b5519d20c11994bc871dfeefa2352b2b3b59adea6f7cbf73456fd91cbe33a08d253c7cbe74a06cda3ed11ebea77fe8872d8e5755d6b58a58c000d9b691531a8fa5b2ac882ca8ef15d5f4183ccf5b9b40b8ea46ca668c8f80523bc7113f72b89d32a4c20415dd88e3e0c7494d28ce6a98216113128dee7f8e82f311c114f98dcd8b51329df6afb94d40c8f6c6daf389e885a0fbca4868ef44b7a7e50824d7d3e5284608dfff9c33cc6309a45d7f47363702d4114e484bcd3d3a805e396d65c5790a066eb9e5e82c4aa9775ddf17e409526ea3aa85623b641b78dc04a68c08718d45fa778f7e6fc16d0f5d0bb5b472c9d6b7ba811825898abb655c0a55ff2e99fc5a334e2b82458f81a2363d11c23d9ca63e01364eccacd1574f189c27d4a8b19d96c802d2e8d983f6b576a34bf24703ba1a1b9716","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
