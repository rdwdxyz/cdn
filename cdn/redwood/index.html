<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11d921594daa6eb2b3b95c80a307b615b100b647f0288206089bb6acb4884b7370aaad9726d2405765cdd985282f45aa42f888ba907edd70a4df02b86a13226812384557e830c846ba57368dbfb31b8b29b352bd791037d29795d4f1c0b0d88805cee176e066b49517f3b5c53aeafeb72aa4960789a26b53cbd15a2c584cdd46b8f0b74b2777de39a3a706044c15f7242067c8b2b62fc4d8d79ef2b0a2f33b43770b6a6b544942f140da734e286f1bfcb8f447b222eec600b01061016dd9e8b01a5b62e8093986bd13af2fcfcff5f81a0ca1661ed1d6655678a934d0f2c6d81f0751bc7d54845ecc2c1b857e75145fb13e77fcb8127de7bdc591333eea48cf31464e6d2e279fac3e1eff36b7a14513989c39f89190e99eb0b90f1d1c4bb894af25ab2f0aee437b91d8827b66d6f3d45e4ee432b2fef1ce746b9dfa3a944ef1ee3e2ccb1141cc958d2cea0e3e5e98129ee22487f0516f25e5c399b8afb3c48e5417b842440fd089f57a45ed86d4b6f7a19272779702aece7a9c1d2ec1ac355851552582765b91dd0b66629f58101cbe160f90c70104ed82e0cb34e110145c56abeb3a6b041af0d74ae4b05ad859645fdcc5a3e1dbbfa0d82c71c82b2f35c7dceb642e8b391dd83805d4e484dc4ffba4184a0d17b631ce0b562d647d1437305998784716b5053131ce57c5ea42ba594bce8d265e28650ae3cbb4b74debdc0c77853be9418114a2d5f121129def7d8f1b9865c14bf7d155a228267fe95510ea0b570b943bb6aaa84e60f44d154af04862808376bc987d382ace4c8a8c0db01943b9fa5b862e5975edfce1f9051d6934fdce102302ff6283fc67a2a606eb76bdfa2eb255ec8a6ec60ee57001814ca9afc2edce115afc3724232e4e2c2af6a7a72ba6fc3087540b4d09afc692a9eb61ada3588788bf336f0fbac8c6ceda15302ce66ba2ef4831531e2b9d02feae11379cc9285110644d9ebd56f057607f601ebf066459304700804587f1d0a4192c952ab1e34b3d23d1a7f8845a5d0fda604655c994ac1b8d24d1e34086c2e8a8dd3149dccb1aca0f091b895a2b32c16b586320bfdaf732d31bdcd0d26a3ff59f4f3b52cfb669af8161fd74a690b20cd92ab4e1b7383971316c881fcfb833305f8eb103064b5b012035b23ffccd269543fdf100bd4554973a615e9893b66db8fcac046643b38191d7e04e4dd7a203ae5d241712a8f62af1f1588600644bcdee3b0bca41ff4f1564669cd55f6e731f2ca0cd67a05edfa3dd481f13939facb4225a79411c7c558ac32aaa6dd31c91cefb7916341994c0fd8a0d0f1997b67fb366da264054a813079ff56be64718928550d5737284dc5b3a66fa9aedd4e2614d708f6314957546f63f5a901af6be72491b164802dd2aede4157c773741cca64d36ed730981cd0a4ab6f7cc5e9a78aac6c9ecf61dc93e6bf041d0f45b3049d579e4f9351f890743024d0a6c88139a3fe3dc7a16623b4ce966ae798e8f0a09c957c1df02ed22f6c616448752b07c07ee3ff00b0cb1dbc3541071a8453752bf1bade81b97ac1e8a433396e0a47980b9507e986c837f4deb29f27a6b87453b27d58104c9f0495765dcb299aa27af46ccdbef4eb970bd4f666d440f36bdeaf3f0e5962bce8191b13381b7c644936b7174994294e87614a55604abd7ef0096b52aac7237f5cba75a7dea681c71183ff050790ef0dca9fc4afcb8a0716a094809471bb372398c667d4b6ab66ebc8de8f7576291b3d88fe3619d57177704d944de7bd2288e826ae9b27bf8d1e656ffabe1384cba7c65f022827e1fc8fa9e53df596765aedf1c7f96c872f394a8250200155763df8e63ba812836664cad8ef016d2f1183d3e70384ec643f557e7732ce161a4ffd001d69743a833e7f89bb90ce42548f9e73abe93ecee8888494a0d88a252ffb4578b6ed9f620a898c44ba4952d7d58d09653a2648ee8f23115c24671f9a31a515f06c83ed61b2dbeb9a5786b9bb581472a66e881d347ea582b180262a3746a6011a8cd81a2943eb450b693579c71050299e49d8d809a4c8ba462aae2541110c795cf6703de8559c2566d39056c2c94408df0396e88cf13320c3c2ffe9d745a026a5f3057c28e34930c2a119345b3a6c2bbd9bddce32577f5b517ed2ecaaab34b738f21b3a51839979343fdca2cbc28650d66a751dc48552bcc2497f16aa992d46effe52fc230b4147a75a12f283e42067699a9b1b9ff433d72b811f0acd81778974676e6538c34c8a60868c0400eafed470da6b7118c89ae4fed49d3cdad7b886b6f674b90aab13166a4d698ab339f540c22e52308abc81f3020114f7bc04843df4d17c62941e75b386528cc8afdc256476c74764e6fb4b7eb68643c081c12abc033cb41f2b1b155adcff8210cc976c3c32c629b9eabdfc16f3442b476bd7556524e957312c1d613321e94227eea623d449fb0c4b702068fd2ef3be30cc74ccb57956a8d1f1902331a54ba16f4ff3da8b540a49add9cf1615fff5be5e9ee39803891102ae4ecbb80f1c1ac36053b063aa4aeb9eb0529a3b5fc38e543fef96434da1f06fe328bc2931096e76362f561467dfd4d1c7ab31395c4b50991f0df129e9a47c83646fb1ac2d2118435b3189a4d2cb536bca9af0e87556cc49461a4b7713afa9ef64ef765dbe428c985aa9e80fd4d844a0c300c0f635f97a2e44d83009bdfee7ebe683a9c8f97bcbb2d70ced690ca1f3382e7f4046c6a3e18a05e0285f7531494e969437d4ed557a2216721fb76b6c2cc96659773da0fb7d8597b135c2672644adcd8ae65dac57cbe34c5a28c5cff9371c7d7732b64064040f0eb35ea59a7b2f86d24e683748da8d24b84e55d6927eeda5fc50f3f1c4f742cdd5b9791c3a71a19a3c08a75f82ce2b4840c8aa4210845595add1cb80a103d8bb199ea3ea8273076a92b4574a3ac2ebba21f0ceea22a7db1ea566224606d17e9c227a64061756da20560de3f50887bc6cc83b14d16e33b3a78abdcd2a4344a3c61f3993eed4896f10ff8067a118567329aecf0a55aa32e8890b3adf72d3279cde75f12f38a0194541b188a2c4fb61f45af3d1149b02e26b4decf888770c715b51881613517de70b82cdab6cad484a4c4ec76f9864b2a7dd6cd9d59a04679cd8d858bd1a500f051d6995fbb158cfb2e4a9fb5b6110887edb4e66b5c7af4fbb425bd7273384a68003cfdcacc8ad28d2a5e3643a30717cfb2143f34620a55a641f3e72a724b2a18a5d37e41506271ff6f63e6f9f9e3ce6a364e51189079b42cb741f96853018d60574d85b8e6cc8a9aa8e3a1c856b7087a26c5f6782f5f2c4348cb962e3fa59300e73d2cc7d602eab8a1a8c82458771537ebbe3653277c05b6c4793c5353d17e53c5666bbc5b64f2f463f526cd5bf90d7b7dd11c5bb29b55ff5b389c07c85f9491c9df873330ddde2036889dd6ee24d9ca8fb88443b1179ed1ee110c5eaec56a5d4826d0266885b8f65ae2cadcbd26fd36bb2cc2dc9832c38c639494e6b4ad4b6b62377932113457302a73e5ff5534389a688c2cf176d5bbeaccd104ba7d041b057f97335671af2b6502555dfe7ea208b7d447a56164e851b1058fac1f3492c7ebc10fd001b6b6dceedcd44fe56664e2b0e6513180647685222bd15cc8c641177d26c658d3902c39aa9c28fad5505f4eaed01a52495d6651704fd765f4939f6d79dae47bc350bcb2889fb402e85c31d669cee59453469c955d8bcdcc561572974fd70cf1c0b715d01f0ecf87e364b553d98ae03eec7c0c76b2ee7e3b4cd67af3c59a27c016e1cf55add5b5993048bf3a668609f9cfe4d0f2ba8344afcd82a1130ce8cdeedb180d591f66b0b64840fa89b7c22b515312c675c36fc668dc73b028eaaed12956d812cd8831c00643159b362be48178cd0a52c177968d0d549a5955557c6be5a702cd28371c17ea10913d586b47b0fae85086f84a037d438645d942056dbb6afc953f3074151af197147342ea44a085981ced739e09b5f1d8baf3d57a0741ba673675de598b8019b6b2f60ec5d4746fcefb94ab033bd076ab48bf4ae0fea8fcbfac69290671e6964e4795987ec3bcf59646a978f1352bbe7571adb807d68fc3ef7a91e001201f5c46223c6e31ae0f1c626617a79adcf25a75e72e791442eaf116bb23c47614550ddf923a528b5b1c5b79f7b94be2dd093794e80f27fe5014b3f036470ac93f6985cdf0a3d31b038dba75a067c138d0b119e913b20607349b00acaafb33fe2226c2c05a902195221d962275ce23f63001b661c2bf9042dd7f535a748b2b2e03b90d5eefc2dc86d05c57dc5df6798dda55173b4ccf84551102e097e802ad5c65bd9bbed27e7f73b06d2c5f0de140178a4c562052aa511558e2743dbf2b4553b4958fafda8cd48e1c44883006217962e555b04018ddf8bf27651dbd4ce5a8da80982addf43778718c06f7a4d554459ef0ea5ee4c6bb6d1bd0d2def1d13e5180a0690a75ab19d6f87142fbdf3914517a62f70948e69e6e4a2497953c5bedc821ad392d8e6b64a7ad8a89d09d697ae46cd8a822c4fb200ed8da159b114f826def8714d13097ff7c58249ea27ddf41ea6d5b0e1c2d0b709488239bf1d4ae12b788402cc02f7d745e13c650b334dfa0fdd0b6a17ce43a1d996c2a86f575c59af1e920743abc9984db11e5f692cb9efebfe32a49080a8b4382b180080b823f279af459cafc26f668937f9cef971a3c577cc6709efe472437419b466853aab08bd55721e01e8a0ad06306f12d446572054ac1a2c91ea7788df95f18b3cbef21e0c061673a11357b24667e605794d661792e635d0230fa76f4e461ba2ed1674c7f7868327b6c7c0b8e633e5b1214d64a856df10ae97f04c45f51a1d988e5b50f0d245f80cfde3276c3353ac4225a80052ef58de7b956265c49b6df571208e28191ac580b2131c562b801e5ec895decdb352108bad93d5b55ead0430b1307c6f08d82b65d65e64ba6c08531db4c5d9a49bb84583aab1ed2334764822d8e9a081df3fde1e11c2d367b4ca63f6fc1b41fb14f0b6553e8f27a6c1f471739c268847556fcea3be554ecfc8708420dd4306f19a05c0cf40fef02ff9dce5389353c55bcdc3002e53056e353bc5bef00ad6ecc079c8777867e62dfda21b01158ecf09a21c7c9b2e16fc8bb8354706eee0c8ad32c8d627de68c25b979973d33b3e82f9fe91e86b1f1c3246b5e9dacd01a985b00907a90eb57a66c0d99e7600c8f29a0da4a6bfc36abeafa1398237b3b97f6d960c54861a2bd8bc4c629a30f773190105e93e14cbde89d305f5fcc5c7f8247d0ee42dcb773ada97cc71f3571fadc8583fa6f109ecb3137378ee8ce4182a83d65c403f81663d49be7239cd1c84563004b9b82621e3e94776c3f0cf83ad174bfa88b8a18a1cee7fd8a1104f1e4d13e9668c6c87dc57f7903d8cf3f46726e8d4e55801a459db6eeff505a4cdc825e3860b2e1e54475989d0a43cad3c64b1e4936f83d5b8d9d00a8d94ef0e848fdbc4750b7f2fd3bab32ebdfc892d7a7a5013986f55963702e5573ddb02cd346eec9485a1054ed0159744d1579c91c5fb1c99dea25dc8d24eaa6e6f74eaa74d1aafad3535dde1b34e935003cfd03815b8be0f7294bcbeaec76a4f41678eee5ef3c63ebe530152c08d05d297484efce2caaf71dcc9ba524a9efb4c54f1ef073d9e165d076a92229729188100519325b96da0ef343ef902c9eafb8659fb404c2a3a6fd62fe340a725ac510f7cb2a0d5cec994b454e58c0e61440f0027673c14788e49da02e3717aa8ba0c16a195c0a107394e173ddb76b99fd1d2b7ab7aaf9a006cb8fd27eb43998951f22cd4682ff289c1dd9283b0e6b5e269de9cb19484fc8f5354720d44354d8c9ab922c721f04c5af0a2f3885179d7a46198ce08bfe31d9bb9e3b2c8d9466d2869823a585fcdca05f09094e004fc7dce0c3eb7e4c4148210431a6aff96edaab76d60b30252ae02cffad20563e68e7faad12af4b98973881eb2cb9630bbab1242fe6258765166eb1c802fdf0f47626efe8c0a0014d115d3dfb0b268a290f974cf4e9897cdba453ca7e0558f5b83b33379e2416e53bfc5d9172ea884a4cdf5c64f9c0da4c1d94d98ef0d584cdc5bbd24231c5c84b09faef91ab9c35b07403805b7ea75a81e6f236570990e3c552b91f7a911ae8ea9b2153ccfbbbe9a2c89ced2827c835c4ea1ff53095891ec72ececb7838c45b0277567a330886e1c9790e14a86d4bad0abd2dd6ea35f28705a71b065b5c523070cfe4d2287b81e0b225d597544e8498ec10aa3420c08afb94e1ae3e417fea5071c8ab96530d3e6940f12769399dd2fba2250737d83de43b0f6b7a22eb4789d9f16ef0ef3c39d9ed2bc0bfb620cb2b91cbe2592dbe9ff6a26ba94466268a37c4693366b9f794972515f8c7a36308f9fb0dfdf6a28f3fcebbef1cdd8eafb56560fed897ceefcaecef28bb77a0ce14ca88eb7b941378d8cc275d1aa00c502b6015c963d7cb33185dc2e9458d559260e59131a1c48d071ef2a8b3e87cf1e11d3fb6b9aafbdd5921b09d3cc93ac1f86e93147245da0dbec4ba652723123f94f16df43e4142a16f72738b547134ec85f6d82c102814e28e85c047ba17fee63560bcb5828fe57c810ab1f37d67229dd92cd2da416e1b5fa0070fabe9554c22207992fa5be4b9cdc6f2702a1e165dc9c8811af37917758ab7d0116d6131fba209095e786b15e7dd83bb36f867b8c6107e9d67fd9fdc0e9deca5cb57f30404ae16067cb97510b4bff28793cdba2a081e6e75c31f24e1d290fc04742717939b6171ad944f9695759756a8fbd1961341d354a445395b5a8673ee6dce284430447172b2ee5d3d0c0847b1b36d030d636fc92831ed5d357732a10e52744c0e045a2129383b7dc22a36e3f01cfa518c632de1258818a7dbc02c24e41aab8140175fd8bd27bbed7ada98b8dc957230e68d354eda6800db80a0a64e9914ac2179a3644a5d4f09c48ed82946bf5ab4bc2b140962cacfa8004c37de24d548b537e0744365205c5c636dc7dc5a8e9ac9fd8763f744e43acee97efb40fe985faae05d4f4602d92849866e73997e039e4557485e91b195184df1aca9c78ebf765b7a7452b739e756f165b91e9107cd05df21e5cc47f93af99664406d9f39f5ef1b8574f94f633f4b0272a3b431c8082c80c637b69eadeda07043a1f657200f6a346c8d0599ea52b84e196a5166110e79635a78342b12a351a2d06b3ebd3b44193f065eef3cc74c4f9f5016a2ce1c58b7d58839e3e089072a6825c30d5fa2840a15bfff904b8e46cc96956dba9d37ec6088c3d09f8ef9bebf80c4801402338bc2d13a1a1cc9c9f584ce3f1a55d42d0aa8b454db03d59a3bead36a74902c3de5e4af7cda17a403964b79db24462f72f12967fe5dfd4cc5e8d8fa7d834b1ab759513189d83048bed733536119f33ddede6c78ba3e6fffc2738e65d109bd1a0e569e11a72300f531a43de5380f3b571635575c2e4d2e41addc0a3cb1cca4605c8c37feea1557cce2fa880eb5281ad97a93a3f30affb4310c9e303118406e1d8ac22a2f6092797538a9ff5d6078f34b8a48ed56ce6b73498b66afa8cdcda441d8b5149d5f4989da20bcb8f9a9b0626f7dd58988f57cb3b7819cbab9e837be6509230481d65a56f01bfda7aa9cc39aebff23ba3d3553dcb078c58b99c6b28f677cc3d9184c0e42a4aa5403352ca17aac8063d3f492ef1800ae8f7defd42b235e8834eef3c0448ddd1fa696096ab7155f338ffe01742517fa0736f288f8ed9bf668065dd7d410eb209249c374f682ac6e364436eb5ed5db476e1991c07d9824b761ef2ae2b082f661c28c5c2383a9fbd91cc38f5f2cd8607d5fa07bd0a9da702a2b04ecf2aa9b500aeb3afb78ab82ab917baa99a3221a1c18c7051fd6ee51f04f790945345e608dddd367d9d1c566089dafdc760d528247f8d10f289e90858e60e678dea9d84dc9575a33760a11cdc9c94f4d2f31b8f537a9b77d9899711b32c57e212f27fee36accf6efa15f6f69efa70f514382a83565481285b5a0adbea792d24e390c25137e2be7dec52913c62e7384890ea76eaae99804620952e245468fc183ecb1fc0ad498e3f136d2ccfc44ada7de975620217c87c14156a859a632c27db4b6686e916d616ae7619bc7e68c897bf4c2f16c305af9466629f33e081cadeee1ec51910f3d33e4e03d79f77baf317db27b0a25a1859ab410234199f13a4ef51b6593a385439e2d7780630d1889884f0f8d1550aeef7b86af6964b670f1ef7c18b68bbf27480453b41a19ad098f316991f61e0f875bada20653e2971f788de670a09b9745e0cb54b23f7746619a48c877946b00d2e466a3ea96da3ce94f8735c2dc5c0359f13777e415b8788b77f865c0e126195718d3b0184e7429465d6d2b9719f8b96771fab94b3eaa438423ab7a275d16caccebdcee95809dab8eef01a24eb0a748472a17812e72fcbad85c5945c2392d72ff029ed4cf442b6c5ae450d1c1b5d78ac80ddd6bb696930b1b24394b18b53acc15d2019c32a4c40da7b2ec1eeec855a96b752a8cce4638f6baf587c9ab1744f79f660b4ffe1891caedffaa2b16a4258dcb4f868a458cf869195424c5dea2ed74eb78d6ddc74583d85c668e328efdd9eb62b4cc90b51ab77d1d3c9c7fd59bbcca9008a2fdb79e1a71c726f72ff82760cdda6a251fc17f0c8180a3606a3bfe08fb98ebd9b45c7169cccc69af4c0046e81e3cc6f0aff87a17bfb7cba71d992d7d4a7ab2cba7006b97e0f3d701c67dbcdddf76067322a6225c27f1f25c0f01f20e5b73bd42c2fabf1eaca8c9217ffd1b4e721aa900a02696258ed122bf91d75c26580b1289455aa1bca84aab2d5763dd7fdb3e577cd4fb93da18df1333b39f34c3b28c464b01e6efcdf672e2f32a8b375bee2d52a65b8e47515cdc268f779e7c480f6700e82ae6e40c55f07f72d4edbadd797d35f5886e1305e1f636d57fb186f4bf9ae795a3491d5477a8712c13d250062a8ee0bfa8c695f6550e41d05dd0e9baf2d71ce57ad6e839e23803b861ba0592dc9879b1f04776d5c9089874b62b41293a06ba1205fee9cc872ac4ca11033b6c5bd68051825035dc6bceafce4678be5ae58ad6dadb1baf65b60afc65d2ba4d7fcfd3df344cde07baacb42fd92e7f44b3fc792c05b5d4dba8d1ef585ebbd1641a374e74066af29dda8aac7094edfd1383f4aca23d953f1933d2998c713d344a474355bf30f2a978ec7fe2c324facf4364ddd30b52401331b5937ef991a12d0baf6fedc0c40763f92d926b8384d64bb1d7847b2c21383bd0235d69ae7056f511bcb123e840a4c0f8bc5f6035cea3e489dd8152529412168150825edce88ee9bc172640badd9462618173c2b3c1f55be0f81daa552c6aecdd01718aadab7db9ff0d2d5e271dca70ffbf503b0dee5d32befd5632bedfa3a2f4cea227975268ca1aea79503fe9e06bf763e5ae0649a2354a8f8e96c8217bc1f3e4a45deac2c0b0df302106bfbbc9e5b91443253deb4c5689817c79de9dffe060da83a73bf04304dd282f1c53aa546c1bea6f0e15e86a050d763e29da0724e94290475ebac5e482cc3fd3b82d3db2c6df0324f067af985486a364c31cadc5fdb7121ce544dc33fe0df251f6995104177f0f828e01c76b2ed1dfe65539200a64a8678a47d11891274e3324eb1bb0ec6951f1af5fb40a2eff185ff95dbbea45aed7068b0e6f5424630d151abfad8fb64b4302c986773d910acfa7ccc23837ccf48b8eb7311c8ccc69d9fe49eafa02e9a4aa2deb094157f5deb409b2f04a1217618edda38c39fc581f6d1a1eeb2437056a0ea109b4cfd245473e2e90893ae09dec7f9581de9a4b1c60b1cc1a6157e196d4e5ff015997d7fec7dc8e9a50aee5565773be4a1d5bdc211acb156ecedc920338f4f41188ead267cf6548aa69d7928773aea9b0cf713254a8d31dbed62d155fda8026fa71dc44159b0fda835424ffc8c1e0e70803de92318db9fa80c2082848ecac8684f298d66f73205828774df4a2e09dbbd57bc59463f0b7a58a4151a49c78d8820efaaef53267a371d056ef04d3c8df0c96e216dbd474bfec7adc25db54e1782c064b869ccb5df380de634444d0ee9b2dca4871f763d45dc7b31c8870cc5a8baf865478ed5d6feccc6413684e5dbd85f59475d60e02343924f678c5a60990857c3000322d2154a76b03838da2834d2fcb93800c0d5239abe36a1ff86165b93d251fece6b3a9631d97aca3cdabac6e56d72ebb77a542cd3b6a6c7b60ec4bacb5a42312b0cd7871cc7cb18183916d2a427a4c3d431ea5ee4dae9253a24a6e40a1675204fe184700e33dd0c1d7a7a38bcf0c7e45c7f468a9697af59369434ca3f295254da2f392a5f2bd33ee1d3eb347451f688ffac1119dcddeef704a65aa493f616fdd1891e0e4cc0f3e6710db9104fe55f33aa4a9d90358107643e393783062b72f92ade0e81b7516c50bedcfbda251c9e92ab69dac3b511e681a1aa503f162b6f2895ad042b187476f458d5dd062ca781f7e890bdfefd96fd4b869ecc6d74054c86e0852c892f000a75b4797956d9e6fa0940f74af63b3ed3798142207415a61dcc76084b0eb479c00404d584ccebe049bdbf71ddabebbdd449167d95197384ddd9a5b5e6843ed8be52ca30d5a128fcc87a088a97b02d909a2fda69a760a2a0c4a0b596f64e1aa92a77ca2b1b0cecb177d932125af1bc64338415388214e31eeac148133a19597833d2722ee3804068d7017b9312486dd92755a3ddf55c8287653c181e6fef3b3c848726f6d03a1b214e277e6b05650a7e33e5e5a9a893907b3d0e25280543959e64441ca6149d7b26c1a45114bea46c9735ee5798c1275fe9488c783d476c0341c6338dd5c40b7aec6cf8f8667bcc9ebc7181a4a3880eee9deeae0fce0a9a638f59d624d2251286003123333c2edb56714e8fee5e14e7fcd207a698b52a3009106d3883be0563b073ffa13d3fdf88f1788b1bab530d0968ef0de1583a23a56483e99039fbe6b174246b6ab0057762eb206034b588187420f954ee22c2c20e5a54ea0b7d2b12b4251c3c3dd2db6ceed87e0cb88851006077338e27d0945c0f3a42b38232acda35326b76ba3070c9569a1c96cef67421cc78e2ffc20005181a28987ab6db0fc4bab1c6a627f673161d1515e6388b48d2c75abeb1eb061776c6e3f1b3be978749bf7c8ef609e33bfb8ebda0f705c2e681c91a0e6881e6b72c012dc0bb027235e507d78efb612da7010dc44b127a2e1c81a95dfc8048fcb7c25e78273b063162ba74a3928e666af2d9f163e934573053e6acfa2005c5b6d256669155b04aa5463ed8aad301b3a2027b829a16362ba0bcdcc6bd4f2eb2677f78e450df1e6ca2a37851787a265fd2b8c5240e72bc6a4fb07cd6f6d8c4bc56a3da685712e050f650f0b1fb2db2aad5496ad8d3a680236de69df414f092213f25289ac1ea0b79f28b801eb39ab054814cdc57afd4afa9110c4719d069eea4a655a6e876a0e75f946e48f24fe555738244419964f9d1d2f4eee99d4db6dcb9e11b1eb3498e7da3cc37ddd0e3bc0f56fa50f6ff824f342bc9e69c48baaed899bdb1db5268ba8648ae8c8512f6246ae691212fb499978b285a4503bf135001f1dc7cd17c93cee31bb9e20e0b1ad92f678e1a87a726a2fe3921384d55a152d49b344689ff4e689d083396265705e7c34c5e3ce159e7ddc05072a167f07045f95287f2519ba61e18cb910ca619866c75763154f037aba89441f86baa9098d54d893bbb07ed2071c0e32819ab56f75ff958c7c3754b42936eddcb517f7d3f78a29d75ab58ec1f6831e5c1f01ae75e0149a11c7b24e6e4dd10c48c5d010a3cb9ae87118338533e9b24edb1c0a621946badb4729d926635196d08e7872d130b12398ef0e212df6d6fa9c3f754075d8819d31ac3c7e7d83c1f2cb0a0fc965334077dd17d8dafd3b5132005b50f898f5f91e8c12592f1fe5babb47c537f07867cce7d6a201d34d71eb13660e201c836d157f41a1248bb1a0f33d0b23bfa28dd360e3ebb24b8d3386ed1f92e0e54a6c487ef7757a9ccffc2fb0c749ef4ed79a64c23216618b8e7178a5e041dddb7a36dba49b55f15ff184bfb4089693d0d1be86035342830d61df7a2be0a69314f4e96796c21cbace71457cd549dec902ee673d5a2b02aa70303e6f40a414222acd19d69263a08294e0f0609ad36919f1af03fa7faed258f66f07ce33af2d104bbf0836f94e65465f39cb05d21a510e0e7c7d420fd755570485a1d0d8920e6024e5c7feda6d52700ff30ccf61b58b70979afa4b690fa7990f530024a6ea7abf3d5d210ba58dae227e05f192c70fb63ff94179c172f1224ce8e8b93cf66b02d1cab38ec38eb5474069f2ab86e8190fb21405fdfc72820f57175100e79653072ffd913f75c10ddef5275fa22aee22fb3b431eaeada9b078c1fe96d7306f3b7f1f93e3ebaa1f87b8cb9fd62f74a7a1ddd1e34480706631101631dba97705e188d990ff28644b6efd25293d40016a01a0bf137251ee5ba7fde641099e2ed41cb4a733c4253a844fa6a939fb7a71ca7ec0f1230cc1ed7bbf40a3055b12fb4d31ea444131a03f031f0e0fe876bb3540332416b738cbf2907ed696128c9279919a290b31517d76d43cd7917bd45c1b232c4bf510407151d7d61941f5dd94be37ec2fb72eee1cd2d5bf6b7c2926d624bff43c80d346896a170e92f5949341e06413534d7d879aa046378ad43a2207e8ca9c6f819133df5565ef06e12b6a094f7ab5d5f0c21c145a7d40ffd11c677143d2756996e619b674ef4fd5e5955d6f66da27eb77d3e40da39f83b473f2fa7f860a25bd2c0a654c03dc7f4898fa4807fd9642f95d224bd31732e4f085281c528528f402b22c3e515b17baebb6145e526240137aab3eb0129d352e09f6cbbd8e5d2c9845329ae54a226b0eb4fb3f6c36e056e38ee3554e7b43cb0264a93ac57367505d1ab8d3a0dd275474007b94866d609bf84d8c365346a5f2b50c3988ccfd7094764d57277ee3449fda2ef7fde65298ca7edc7657af7358c1ec4d5257b25228aa45c96bf355772b6cdc94705c5f910b240fef54772fe502b2ebeae2e4d9e22580b2d0014ad3a02b5d47b8ca077707ce6e149b68889a07de26b8315f8bfe6f24cc9237904090508fd40cf65e60ce9518b0a2f7fd708b140e2f37fee782cdbad7c7a6fef1c6f60fbb896eb5b0b28a3b1a70738abbcc07f9723eb8dd166ad38d9fee834ab86d0c7d8fab627d4511a145eebffed7df6c2c09dfe9b4be55a5b45fba6418116675f0c0d0fc1c2071ced85ca5c0c77d40f2d28000cc2f411b6ae7c708cd5e80d5bf1a8d04ec84ee6e0612909501ec0fb171b66fa8fe65f2903c9b1aedd291f262211ec93b489887c62915fae8a35751f51e45020b06145da00f31b6338ffad708c4ec4e235982d0ce0e414faaeafa6fe090471c1650e20de4d3176727623085dbe1eb2b228937228c7292ebcbcda1d64e9c1836107077c2a665efeca6078aba0611e234c1c602b1dbdb2d9004dce04ef3641ba2e84361593a636eeaf70b0f412c3c06ffe6019143d9152d5603c08b6978429796ef5ed327dada4a0fb0f82bfbfdf39e2d5c82e750fd2134a43d708251418ba949ec31e48e5f1a5291535e1456dc756060f34adfd4b397241089c97f9a4bd9b8e12ba1dea6b57ab480357b09e26da336658f272e915baf85352d57cd6888aab7fac1d87f174f0a775ef6f0c8fc120638fa8a36e8753ab4de57af51e0373c395279d4ae0be74ea10afa24873e2b18a2b0f4742cb6603cd5ce64e0181dbea04b443d1185d237a25661c8bdae3f82ebccf0a261cf5f7a33a1a0e8bac60165d13dc6498e3fac341ba1c477245d6f6615621f120a450f85dc29228e7a4b4070f8736e5da6d28050b104526e339dad434d830b5ddfd95948804a38d543649b797db9afe41b3733aa282d90236dc3688f27736c2834e179dfe6c466379018c3e2d02d97612fc0a73a7f9c1c98a3bf3f86694e7ebf9cc9117cea6b4fbb268de0629514687c544e1b36bbe0fd8fe02f43740ffc1c2bfda582ec65a626a381c245a07f9b618c99a3eb89b2997527c92186645919ad7853a617feb83c6e7db632eae55a0a0913c37c2c2c374370efd46f4bf8741a71488d3e440f1b53f4dfaed6c07b3136f406113881bef32b15be25b9bcfe0bba6e9d880b836fd98ea7589a5b4dae285db5282d13946a05d98a0f27466f970961d820d9101163e5a481b312f8808948bc72618915b2fdb8f2ab58a7cfa9b339c3b5089a7f0718be57e51e8704a7f520fec3eb76c689df68414a0f9b04abde48071466c58c153e0d88188369c71a2f2ce9e73633ea03dfe220fda9eaa5f1bc1acf6702d65edf5cfff1e28a51db0cf718864b4b49c7fdcea5d7768746ae8720535a9e7829b1089591f450cd57b9b2a484bbdf8ab8612005686500e6054f179aa1661e1d759cc08bdcb1034dbbca46721db2ac4b3bf5039b2564e071f5f473488fe7dce795c32156052f3c16647421a97740460ce04a0d3febec037edb5ddb08cafbbd156643613a48be05763628cf2c91c38c14611417990b8599b92ce7c44553f69aa01c0bda52a9ba6a8f53c1913e8fd6eb9aee9dc2e8fbf9a630885ff05ba9c502ebc28c345bd45e87c5ddca0bc90a50fe9fa242ab0cde94e0b6aa3dad60782c4dfa090e1bd3b1db5bb6a9728d8fb546ee9230093ab38eb535a897660315d8931db7148861621b1334137f8f97aefb9fd82deaf62ea7d6b9b9f6ea223e93fe18ea8b92a6a363c473c0a72cbf31be354b1b5055ff8aef39b9ffaec5f3298841893201136fe150c4113579beddb128eba9c05cf2fd8df648e527b2783887a5a7efed260c792dbe8398c7147cac1bf1b49771b37296417da98fc4fa4162e3a4d2ec723b0808948f4b538073e4ad37bc58d5daa9cce2ed9a19ff38855a34ce95565811136c353c6c78f86da079be5548224e7b15d0c7ea9a3c73e8501cc4a694d49e8c059cff08b4058785eeafd690cdaf8d0a93154026fed30a1d56048526232298178376649f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
