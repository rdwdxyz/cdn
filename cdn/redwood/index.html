<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f6ce12c102a7f7d0c6a78c1e2f602c15fbda7cce8416143d9c093dac59d144e4c6d9d4490b93a62a55f6ebb05fa87f252477682be602a89f0df46ada21a34290aebcce9f0bd054d6069f5e594cb45ee19854d43e26a6508055bdc2a366cb25ad8c1074eadc9f4d590984933c0d447995d5014d4f5655e88d1226409be8d83c69a1da7268a9e60da30a375e5ac28741bc0d0edcedb4bf859b15bf5d26c8c46a0c8be4dc500d52a9c7a60a6477d839abe060ec61de565ad9b8850767a106efebf7cd79109f94ed2dd39fe8d47b9fa6b4d5a257273b85755aaa59be73c4d4cb66d1ab94437f09d6b6c814afd6ac1c18531966d7af8c86150148d62e389c39f8f2339565f5f2cff927a0dbd3590a5f60412a9a908ac8b3830edf81647b3b412ace34b5a760cb3bba30bc5cc37dbd412b114acfe6a2070b9927c337562599f3844f667789456530225e792a31125046f80a7db68cabde0f775c84a42696767ccf90fa22f26cd90abb2d8e495bd57899552c55539619cd0e5ee74280f40e3a17f23a72255d0de3419b017dd30dfce44c7d35469da7c8ecf1d5431e18010588ea7a0e5b910673d2c43df65754c625b5a481d3ecd3be49e028ec3160d65d3bcdae99af0cd6a6ad687350aea8e173c889e61b69127625188fcef1a873424f15ed2c1bee0fce9c567842ce656ed039dded61848f80b00f712e64ee9f2195fe792be000a75d7ccf298958e611bb1ca280839834791917b68cabe6b1090efbaf86277304bdebfcc51a180bd7385ec600084f0a88b78ebeca2fdf7790c26ded51f27c071a1a116ea770483587752e8030680c1d6480420dae59ba280cb2bde4dc38db4487d4596c0770bc05718772457b98cebd78d014fcd9f3c4117ae476bb81ee547a7a9f501f4603a9e69d4b816fa89b0686140a1b5cf28d94dcbd919d4a6ae77d8fedb6aeb714176e6e8410ec1164b3a532b5a61580c58142f3e86b033c9cf4de7ab1f1eea61296a1e4f0ef5aa2f473574a8acab7048bf1580b6615a8ff776e7bc101e3441834afbde4d222e870d618295e4a1864a86770847f4cc07282fbf7e1bbcfcf69e398e190ee7c3b94f92aee8b8a96458ee82c7a3aa8d374f79aa735b007ea850070955f547eb55afefad94f7183026fd525157e86abd5e31758b13816a0a64161d40a9bb363a8a02b1ed9b27ee30dca454aee14563aa243677afca561d4cf49e97ae5ec108d64753e6f508d411f0756c20ed30b0b4d6d19ad5de383ae4c892c643e2fed24cfee0795aa26b91c1fda2797640b93f70f438e4e1ee567d3f72b50b1377296906480344cd03ea0429bd2a8882c0ace0d76777c8180113cded2cdbeea13895462f71c1aaacf0792e5cfdf4e2b8ce1a3b1147889f3bd1a8f2f149232fecd2ceb18265b2b899d4105f692b9fed6af91ee851627054d1682f137fe6ea1fab4dac97ea0dcaebf09f8dea671ac3397a638a65d608a59d5d16abeffe30d60f52f4d19121ed643c58723a5d50e3e777c960a48a0ab0f01c17436fb074702975d60162127bcd87fa0a7f194d034f0a807fcab54255b0d882ce2cbbd09bbbef1ebd7802ba0e31cbf1c26c9992bfd8fe7f88a9ab8b262402186627c728e305e1225a3361add0bdb8adfc66d4cc008a12b9b13a4437b813e2002d80874f9864234699cc0751be624fb819003bf1d449e09ba0c1ba23f15728ba88ace78a015b8d4a6b281b74f958aa4f547cfec0a4205d7ed6a5257ed1f586160247850c1accc844702ce4c0cc10da861156be42dc9e57c5c49fcae7f1e32e5def8b98cbf2d40f81479d500633911f407ab4f2a50ef8f2f68f81a6fd084801fcd82e8cfc1ed81187f5bd6a0f2bc63096233ed6445e37fe0f121835296a71f2e3aeb95d2b918ce45cecfb6cfd0043e6871e7c62a974a03e36bf9c1fdeb4339b7797fad08927054d1655cc9d3cab2b297e980c9458ffd80c508bea7ffd3afabee976573cd479aceb89586cc2f1a75fb8a887a48f9cbbfe47c400e467c0b722f2b360008c574c6dc09fd221c4e837880eb45b8ccf8d14c49e3b28cdd63d6c75e95f8a3ffbc8fd05e9d7fa00d053491b209ab9ecb1437d27ab29e9a22f7320e32dbfa707b8611ca3515a6e22be6cae3228e46a97ead0d17cc92fc9a23b4c94f857ec2c32b0445ef417905bdc4b90aed485c467e7bdca3c774d6feea4ea471d6fc53b2d4bab316ee4060451a86c3737b18eb72c00f47d608987bddddddd4f6db3e95482ba17ec8a6c430a406ce11b57704ff94e41b53f9d8f4b0d9d1ec7b8ef89a7b9889bf22f7ff2666fe539c9ee0368fdb1e8ff93543bf70831725a104376c06dbb418dd9213f669a5f1c6220bfc5d51312da3b71a3591e9cd5997098d3212f474d8c74e370846365ff02eb6f640128c70b4e21b20bdd1a91af70f319e88eb36857045f9e77124f50c468324e539148f2f27a29f091f62a5eeda2a7dad59ee813454c268ffa914f61a295f24a428641cbc3ab2ba9fd5b99d07512913566f44211435c15f50a9a528096d9428c356aec859485cbc46caf1afc08bc7f0e3090356706e0960f2259fa2c6058e511ae27ae21388fb5e6e342be65a6dfd9d137e0b914a0683ba6f170ad7b8035f90d823a4fc2b718b5f58a71b294ecebf8c19bd96b57b01da05303f9a94fbe86923a2599101389ee3d060ed34823ef7e5aa9173edf3f5c51df745c8935ac3271b43c4ac23e8f2674161adca92c4932a07252f94c37a571b828cf26842c42a24bfe3f3813a1d94c1f2b4cc475cdb4dd48d2206dca05123ca3279589494c2c2f533b3f049ab86039b8347a6aea7eedc2d1c50d2731a352844255fdf08d137e9b196692d8e2cbba57dbd0773b027676399bc0f8fa25340fbcbd4d34b0a9de1c1238639c4df4201acd5446ae13cd6214731f96863bb430ae89c130fb83d1627c820bdb4a436ffe9b4ca4304f0ad22cac27021705d8dfb556c3562880343b987c5aa92189e5d4efa39d7f665ad152ec9523a8a5d92949a79fe43a298cfef83c7c3bb3f7b440b24666b71b58e0ab78ae077fea43c654080c9ea0246855d49256bbd15a00bde18ff3c9574ffc129757c23ec9f9018f5f0759931a4a398df1fc2edb67655ea271fd99e9a1fb075be1b9cdce3bb239eebb3313a04f042e8195e347a9963b76a74051a375a6011b08bb275b0680fbd09e64c6789d239a7da0bb141e319ae26caa2a679645afc4a24b01a2f6f4be5671a84b0890bfabb5505f08135741e3e35c99f2c6722e8a386a97a1205864fbf0cc0a0e4b7b30105d0e44da13ed65082baa12ffd4c35c120f12568b7b9a7b311e7c5221707d842dbab38810ed20a217e7062288d70e25152f57573138a4dae59044803f90aa1455158ecb78e84046c6e005b8d2cdd10032ea36e24d48c96bb9e43f96114c1578d917c6f066dcf849f2f7160cd5a1c8d69b90c7b36e126423cd75df33fc519c3fb215d84ba3847bc974cc3e5795d265dc747abd98a2602ce6abd8ecc500741442db9685389b195fa1740203e8c68214e2350fb2a7ee0e1beef425911e86c012ff7467480e76d32bfbc5e125e31a1fa2af000cdbe827651ccb597525fb45232427fb2a9df1f3be93ff83acc7e1c9857ae01b16feb5ea7a0e017bd1d0e51b2479c52ba2b5c978801ee94158f18f3ec3063e5c5e44c0e27d74692c9382d923519d2f4e069e7f6ea70d870eb7586df3b3ad3f0d16aa5b618f710f0d92b5e3182f246d1f45a3697d209d02e1d4ed8627c36609f333982225686a4f9fd74e807618ef69169a7096d36a1568eb8cfa79db5ba861be3fa636f6a1f7704a7fb661a5f9a4668dc086ed99707707ad1e2e9200dc8710d4c3993bc4f80e8787e5888a8e49882f57107518f14b0a56d8a1df95eaf0946e0da1efe138ffa34740c43a3387ca537047dc717c4a4fca2fc4ab07413db3d20507874f3ad78f96b5f9531260cd0afed09a4186915c7727eedec99b71d0a8ea77a436af484bc35bd2f97dc13a1559d766cd1ed0417f57db879ed8d2e363315a4f02d01dff551af6578a2577f0b62ef0035d0bb7e60beef3f2aa6ae8950129dfb7042912768f786518beed27162eac3cf1dc98c2f80566479e017162cd4cfadef10af5ed36a846333afd6d632cc27cdfe34bde5e5e8a5881f4431a665205e10864b61107a7aa14afe819a6e0a3fefd25e57891ba48e4a79303b98b01f6df4f3a4bac2cb91afdd579663b9e6ef8d639e5a71b471501f1df774a07f7b80819f07b0a9c45bb662499bca89213496c79f51500d23834e63775e78efba48a49bf09289122ee41c9d9adbfa82c5a3f9ed91fa52c73072d1280615bf9d145a1125ef28eb4d459b333133dbc095b88c1a68223275a6b85d649908123a4d4c89c73e65fcf5a18457a5c23820fc69b5f3374611e3e707153113650d966ac147c2aa3cc00b5c8388a5dc6ec39ad456e4a93a2e923b0e9a1770231356e9d9a121dfa7a503414f4041d90c1387917c4febd6153075158d5c1e98412e718670ccc5ebd29a7c833f62e53aa482a6126cfe4f99de7d310191ee3da0d055d5b2f135fbc4f53888510a028d8a36892601ef8991bba0857e3e3434f093960289aa3ed1a01f742a8bbd161c136ddf965283ee2a25cf76b1767cca07fab64c4927e19157be42ddd868ba5cce95a2bd016a8606c849d5244526ef610012e7f95b0059ab81028f663279dc814e6e1d0374626d273787e5ec98a993f5aec46174eb69adf8ced5b83534275c34dfcd31610f2a160b2c80491a1d38d796afc29e0c55c4736f3ad0e611ca171328295c471e16e2c4d485e24ed731e59ff570c8e88fde8c331f44699837391c53e664fcd35a6c96a99e98bc21bda1403d7b260c6c3fc9fe69001316f4c29c96a6a7cf6eb5d1b0bfba65e899eabbd8f996b1141653b964b56d8faabd397bdb33738850a5ae4aa4f276d22e0af005fab607cabcd6dd8b9bc0c27df319c7699b9d600390824a9f5077518e7bc0c28f2068cb824965fcc02b57e58e61e3db6f5b8e0b43a6f71e6a9279f299eed4cba9d64eae49539bd75f590f92814f28dff6a90d6f4e68a0b0ce0efd0b01984cad8845b7960adbe31db8b7230baac3557ef42bedb7fc2cb63d4ff199225602f45c9836f0e0f171c8676cdf1e13926519da99f1a98392ca62974dac631b22aa2ce745c4b8a43e3df38120c3628f0f59446ea518383882a2b7a77e0f558488f624ebcb58d8f9d494fe1c9a5ebd57e6aea3b4f5e38db3e0f5fb1c1a7036808a361dbeb4aa4b5b7bd16acd6458181096c1e2ed044b91a8eeb7bbf8394656b542b95bae2a63a23b381eb6b0a799e4a9f278d9dbb2d00ccc0725bf31f9b8323440cddd13f3ec8dd615ad7601fa0649b186386f5243a5a2a8bc7520ede41d34400418770ce28d7dbc9b2c81fdd7448de3b53f60d152a57e4d2cf65fc9b4ad5cab205083c6359a97463e3aaeda4c8fbb95ca16e9502e1cb65dcfe2c09d65dad1b0829b8a4115db7a2325db1c842431a40d6978c63f22e7cba969817a336aa1e2ecde86148550ad67f0240b7c203f1916894f6e21aacabf150f29c62070ac6a383703fb9417cd7066cc55f2f275b89d9021586ff80b8be79d062926a142bf8d3d7fbaf1d9fe13e6b4b53874481cc8b97ff802537b98bbbb8288d4607c1cc614152281b23e11758c6dab45cf639bca9d45156b9bb2a3049403dcb1486476e0daad9adf012edf76798f7db4f1b7b38501f392a28897a1d4a0df7d1938ea71babc3d18a327f43f8e9546cfdea9c801d4bc43280a40b5ff713b6152dd6330c20e2933a342ebbefb7c303454bd018c55ff4c6fd45e7b974838c11bfa2e731a418f7ca37fcbb7e4b0b7060c11954f1ea6b877ace4281798ef093ae35ffc9787afea3ace1920e62ef04ebdb7fa01ea0a4de6e30b9fa973bd3da5413948cfb20113a287cd613dc57025d717f6649b9a46eb4d1a72f542d09fd036aefda466ff40af92d02c09bd417975a32d882f62c3372806ea2611599395a0a9210de9de97228a606bf4f34cbd0e7d37f26b59ee6783467b4df9254c44abeaa8c15755bd19b2b26a01aa7a1b9e232c2b57133c329ec95dc481ede2aea40a98747afa438c6e051696eb64904d6aafc154c950108876b2308db125d8b1f8bcd8d179a9d823e70a79ea01c4d6693e7822aaae399cdd28beab879534c1c314085b2f4991d01e6d64c9bf8f179136df3874a7185dbd0021a9ca344722cbb586ae991e613a2f1b9f8089c42f7b7215ad2ae1dbcd078dc81752b80faad4052df3fc9702d70f7f6d8594da57acca5f02773f1ae81010ecc47336628bcd3cfe775f3bb6903e3d7c46b804b6dfaaea4b3eed7da9c3893251c6d0f9df2ed1a8913e8b327ec275bcead795216e86ad2d45678b600cd6ec947799d9539fc546d8994f2ee2618fc2c9cc7200106c75ff66ae2cfb6d191a2d7b22215e2a049a7f526cd9ffd9c7678b7dff11336bf11edb9f37ad1346b257a025a5ff906e11a7f3bc6ca60d8161b5d7a1fc9064350184203c5f1c16c5d472ba088ca8aff834e01c707efb03c0f106c4c3083d00d62796723f6700282c5a834026037afe961df8cc82b24ef28e33f647253b3463352cdd7f637f3537672d795bd65b7f3eb713317fd5d912c04e9327ca075d4b2c553048a6f925a7fe3cccfc3007ae0a4631c85e7ef401e65330fa89f31d845fb2837cea08c2ea3a44ed0f3499c9794f9d5faf6aadb7563b2d29c85dc32e22959fda3a146f10ae3bd15ff422fd44f8ed5845cc7adc01dc0ed03b7b43468ff6d418ac4e79c3aabade3724a866ad84163aa7cd0dbf8451eeadc2b1ed764e32597ff5a43ac1c5e8c6c25b1cd96f767ff23b6a51d952af158e473a354fc50a0226c349a86e610af3e4adda039a60230868fca2c0080547e6b6eb1cd81735fd49f005994c8cd5c9f40a2d0dcf43da73e99f3379a4bfe0cbcba236b29af2c5c79938fa2849b2f46fe64e14690b1dc947e0f2bc0dda7f46703bd5b50ae70103e8300afeeb91bbc12a681f4248d3485ea29e94e0f71d1bf4850df7f4a07c8c5daab4bf82fe74aea10aa5d48d1d54bb514f4791e40d6e768ac05a819c9c344e2a181b9a7f1c53846f9f380abdf85711f6a66cec58ce4c7f4f23b9b8e330962205324d16d555e3faf0d51eb76b8e8c347a67b8a7bde2d7338fae675238b35c77aaac321a8f12fd524c2ca04d755e44f0a01bbe071691442d709ad8fa163c455026b49b1710af0a75d5ecfcb6046d5779bab5eee8b077a398027db69232963b4f167f6a1c76dbaa45639b7ac8ebbed0af96fec70d491329b4f2d83c3af8581fcb5df16634a06e0f7bb0d2216ec171847af15b2b7eb39f38c81afe5a513a7082e5dd91bf2966dbdb5a472cf0b25f931c711bb7f21b5add5c32401bbef8d7cb172f66ba82a85ca65e499d2674e61a5fc9ddf11413c08106d8131a91bffa4266ce502f4cda308484b397d1cccf4e9b281f5422cc7fc19816d9dbaefe12e0685eafb595448327444958f920c3e9a936228bc7184ec92080e22c1afbadc169fa2c63baa4a9402d2c9bcf63c606df503b214395b2bcbf8391948a6668538f79d418a80f9478abd996a10b45b4708864b2086cb6b222d0a31496a6dbbb5ea55b23dc75e55303d177bf6506a739883585b0fd3ab05bcdf5996d9f1bd46b8ed9528643ecc7ca5cbf88a315a6081ec779cb03119ca9da29359d83ccbfaace8dcaf1aff5fcf7ca9db40961dedcd5bdb969fa0a8f5b2ef8179890896e7ab2a77b251b6295af8319213ee9c52ba76f25f7e9e770a1511857a64704b52c757eebe128a864dcea9f2546b6c44f838efb1eb27a3421492c3a890a909d15644884dc94caf91cdac7d4a3056e4f12855afacc5b2c9369034d969f23545aa3efad62245690d5a9bbce65405658477748e9f9c4862903054cccdf5ab3494e9a4be82c20638bd29504f1f24f04907137b4d4de003ebbd504ddff32e49e8012312ab4eff17db384f60b83506b83a114eecbfc37a21d3ac5dbd8ceb6347a3e7b9b5e30ef59add103f78bd5b5ac9f506f3db4c050dd392da89daf6e7676289aab8d35cd39dd17ed1fd12a3d3778b22a49d23cafdda4d380e4b877bef6e3e957268021512f2b9c25d247e989bcce2860b21f9a5274b785a1cff4b366b72a65eaa4cb3fb0fdc35af01b26bffdb15546f43650912411508a071d6bb78e2ef0a9c62e686487e2dcc6848ebccf44582a0ee60811f40ba0160891c9b2ee599215f0312ed14312027e95deb1887c6a710d9613ca194eca5e7164ef0788f6e8ac44acc26b3892282d0410f0bfcf4c02ec44978fb331e75819a8879963485016f2c2c2936b3a44f59d8d2b1adc0ef668e0f8563bb633fad289f9319bfbb4bf99e0af41e5f497bbe827da9242f9741243ea0a18c8ae903dd2d4f448b8643fc4680aa66bc4c9f7590f240b8ca01f3e127a600fe15d5cf6bd019ffde6f3357932b27620ba2a1648382e881b75394b62d0421b170c3be096c45231af246312f1cf4f5105e164af6aff28add9702f721dc151ea66ac53c6731d9344b30a3c402621fd268c17e217cc08c74d7877ed250da55583dd30856a8fa95260d0b29e9c6653415a0e9251ddfc49fb1de21044fea9c6c4ee5735f111eb05097bf783bf70145ff8c26ea60e0c569a98fb3c41013fab8b322f7f70a7149fa136f6562ab3d04b5edac9592b7a2753cb36af6b64e045c49c8d83415067d72cbb86fe837e179c59179a8079c409430ae83aaa322fdf4206fc6614b95003fc29ccf2a0a340e399e4995443fa81f6bf33f3a611cd5536093ecd2089d19588bd80979231c07fc7e59f6a045846ef8269f94865253ecb76815e5c944fc34e833985e978f2e2c7f529bcfe40b98340c8d1d88d359b591177e96fcb6e1bc0f31263b8371413443ec9397616a01ce8cb9c29404fddfddb7a0fc8cd8149cb21da327f402330852673cae5771549e351db40b7f6b7a6f9ec7431eccfc5924417eabeeb557800474ca7216f6d144d64f57f1af05b3f1acbc3285c399dc2d47ad3e61ba0b999da90b6465b18375201074a1793d4a7b77709dd62c034e00ad07eb8f9eb291cb56d964e3d6da938003470310fc81e02d6bd427881371161c1fced07a08207b86042a8ac84b6914780c3d3c74bb2fc48990393e8623e38c9c90fcf5573f0e3daafdf2b780b6f4581d2aeeb9bd80007ecce37c45cce3638474223cfd45a5c7e268cf24ccc95b1ffa56a9a5a53811adf14ac5eb29ce00966afd66c991cf458a8baebe63c60552b5633bf45858c2369cfcea615b60c522d1c2f34bf39d4f2d23fd2aedfdd99d478ad245c67d44e123db4a56d5d08230c6e75cd30efe695e786fe12bd21113f142f2def0973908040bf1b9a7625f8442f7616f945bf09ac64c364a6f1ee3779f8cf60e64ab6e2c91b7a5db36ea48a04ba7a8e9d9f7f8e41442eef3aded05e28d98b91088be663ee39b65a1731c8a7ff3f2e7752db37f6ad887d90fa2f7595183594a18c48a4a6f627ce2f2c1e8fe2d224f17bab97a70a1fcffb467a14fba477d6f6ab934de776857f85430dc7ec6b084cc48aa6c16eb1e9651844f5898088bb71207062996d416e568d2b6cb0c03036086e4770694cf6d189134d94e1b2afa43544287744e12f7bb73f046e1efac1eaa045401a5c3fa36b1ee830448998e1d62eb576f9060f17c7322feb680a595d924948651e146ce805948376e19b404400b71082c5dc20a6158e5c325e35d0848b9e286013a4e3c72ebb0a916fc5f6b57c808d90f7a27827a0a8dcf473b4b67d9c4b4606fa1f8fabf17bd667cc28aacb5023d336dece875e2e7814aab4f7fef39b36451fc253b741a0ac1956f37e50b3e9150a57b04df9dcc3c3bc5aefbfb870a5def41f52d8bc114349e91ea77c5b25ba68eaf23b3571116cb8366c379472a8a30b69cdda11e6a0250086cc7484917fc19ef98a24e2c84af26c65f8f727df91f0f46fb9d494a59f0c303c687358ab229a5685e5c0aa06e166ae9777b9d02f06a7608925ade976db06dcc33080da3b1a0a96d9b9b7de7d48bb8b634a7fccc98e1056956ed62935b8445d3c7a5049638a166654be0aa6a04f2a31adde876ac58ece5429e24b7155f6c3af66398c046c50790218f98bcdf047a48274a93a12c988854f94436fff12a8e3fdf3a3b07c615ef24afd4a8f3bf93ad5c5814cbe83a3a826f47e45e0b836ef97157904e68523c835bd177623bf7f1f80fb074d40d1a5ccafb5a4478452acdbc323a3598cae421ff658f5bf7e16063fae87ab9d24cb06736c18b10e31ec8cb71fd0baee3e7908938c2a5c49b09f7fbd07f2170309b5f47b1ccbd2847426533a297c2bb86bcc69f5de901a12ba0f998e51f83535cd7e17eead2f5076cdb82eb11a3056dd4e390fa2b29bd7ea6866f95f90b5fb8d23aee98e250d1d2b00745143f2ef27f838ff9cffc9c647a2f6b957f4795eddc128d1ae257ba63cfce3796156d0693161b85e6df0a47543b122dae7db42f902ce570892f11db93d090560c2fcf52b53c8c06f23b5a09942a618a6c498d766a1a1b0300bc39f0d4ef575cc4001bfc6e325fc46d6e19cabfdbffb06e3645ffaef856fb2dbaa446b0512dfc6482fc22ee9280e0d8c7c8cdbd5ba517fa38b7641f91387699cbc991a0e67b945c76d810c60cf2ecb0c481c96248a940d856c6af0e138f45315107eb937aa651fc572fe988b21688d36fded0783764c56774281755a193947ef14658375e2134fa153c228c8cb535ca20d50d2593bb253d8ea1bfe8c7e82121aa5ddfc4e08a0c9137e14082924ed813a76b346cfb2b2c8acf53c04986310ebf1c50b31f76b6d6b13b92f1428e46c3c1f56662c2dfe84241db76c3b7fc32a57826fac8c9fbd27fa22ad2d8667221d46f0a5622ae382c1d80fd36c873c6e62f84353efd8ce382296d16fdb7a3cd442533bea90696e6f9f387730aa6dfba3ed8cd649b9996f4ed046d5e746db3fc6b8bcd5fb28a198ce86eb1ac8bf0da40b6b62371dd13b4f0156fc5fe879177e91f8859b670ba60832904b069123e1d3b9c8f54728aa11e3ba7686893ebf101d4b10b648ce0707b801c3c63d0fe8c6087320ee43c883ed1bffb3d3aaa31d2035eff2a8cc4e9f3ed478785db7a5eca4780978caa534cce65708a52524cb9e980706949390baa3a9fb6c91f4748500d1cc1ce280b6f5259925bf53dfbd178da1985c92b19dc8fa5a6bd8e544939ceaa2f01e1690b3efeef1f24c44b0c3798d04d7a4a1362babf9360ee7533ffd24515ae7ab1aa5d2c2ae8faf40c9df23fb8452d7f20aabd48b8f2402b30f85143908cc64535a12274168cfa106ad343c887ae0d13a7cbeba7bdf869c0c4df1653d0dc16396b327a37dd0ad19ece8987449eac0ad30588e997b64985fa1854b41e056caffd5bf1d7ce95c4fd7a9666912ea685d6e8cbf5978d78253175fcef757d73dd80e52081a4c9d9b8bc24315dd8b7789ea01e8c671316c5ef50398e3ccc3fd20302f3573522a6d2a34e1dfe16dbe804b74852876e71aeca46ad0c92b4edc3a2086e2baf46e91250e81ee24b64a82717388e3d1dc4abd4605e421efd9ccc5e464beee296af89bdc7755edd66bc311d594c854c9bd520aead42b416628ec5d0db6f7b8640f107ea090567744a9eb9c16db9cc6cbc7d991ce05259713120437c60c0ceeec07a2c6455ff5f54bd4ca52bd301ea63f7bc485ee4966c17c4fc806165abb21df403d480e0a7d4726cddfc4efa81a01f6362d1f02c85290fce629b5ed8423e27d31cd213dfacaf5c01d3940eb86cc6275239de029026bb1572227afa3db0c0ec3e27fc46abf112fea2495aec6bbad475b67a09fde8fc53e1830a16ff01d5eecd2fc803973de6302f94e0346018d6baca1914207d84e51c3ed4797f568c6f72d3f33657aef8c1dfb7a799d47d8ab006d49a2e126b9b6a24c29096c29c59929fabee828e0bc08627f86caf41d976fe32efbf4175b8d7d61434b2b4a79233c19a2cef51adc4c9577dffa3abdaa6b2016448d348369159404dcd2d9fa941d9f458b8c54c75c3ec0d4a5b0166f026ffe6cee6d23be34e6c516300d8021681da7a35d7caa644032e1fb908da47aa77c0ebe07ae593695351eb645bbcc315d50002d79148687d63bcf00a1ccf0139aa31d43146b8664869e101e9cb729b6d76690ced8f5ad133e9cc456a341af45c2385e971c0bf70328789c4ba09371882388d12e6b691c944968d9fb52c6e3bf8de74fe09656d69deb5f19b556701d9c1e19ff828c8a008146775873710c03623a872e63be131c382e445eee64a5c2dc22e08ae3425a7127e5741fdd468ea4d7dfc0b7891e7b5eb2cb1f701c730fd72c7b752b2d49a8bb59d6a026a79a12ad6b4e2a3718b37166323f9647f22939ac27c466fe6fd08f1d5cbd91c709d33893655c7bcc1a7c19c869bf810a85a2b705be12a131708a03f0f4cb0cb01f590816299a3ccefaa109f5c39935de5d287a08002357410489d508d03616d7fdf7ae2aa292af891b3f8b071dd0ccbfb97f957b2d0c2e5bbcd191fd3a671a510aa127028514762dd570994a60b239e05f3a02ccacd10b8d3b36f224255427ad8873a52714f4d621049e88cfbb4297e3e4fc22dad7667d239281e782def1323dfe455c6e30a1f63878e128c7ae8e260b786bf401e1860ce48fc45118b9f697484408a3383d1b91c81b99c64f4cd0c097f75ead85e96ee5e33111586b5e5266c0afed91d3bfea145f75f04ff30fb0150365b0a9771f905c2678f402230c81048b44f2bd40e87a12277287903f4a6f8c37178f718339113f36bf3bcb092eb9138a98cd0bf07f7e52ab38566ab716c16ddbb8c9035649c6f2b644d8d1f67d294a9aa4a77d53e2995729f9ff3b309a1850ed5512dea50a578a708d19b3f9cad6bd5b62c91295015195a8071c8708712aef14c70660cc31b7e1ded8b36e1fb1e29a2c666e98f2591834cf9ac08d5d2fe79d8f460f617248bec6c89336ded27fdf3925493e6cc00c427c6b28dc36092d34d2f3496cf236bee3783c38ad6987c82ac42b3bc489880f9453ae6c2c26b1de3a88ee55c4ddfe1bd1eb27b259f3430c95d39d0c373a5906304fd5a09810bc167ea6e59efcf995ed1641b2bd8a410508c09d43212792c3b077ee61c9a4d67a277181a4c3c3b88b206a209e49f647f38bdd74031917ca36cee02f7203a5f7eed1d1d887b4d80f15f4430182bbfa1e5637bcf45a4c127d0e842fa25c0ca0b4a6538691ce10665e3e7d0a7ab9593ba57818dc70926e948154336ef7c16eba1ed1e222d7e927928cbe75c4c1fe8938fda707e2a347d9ee6884a231d781cdf8d164281819583dbcaff9fa64e55dbfc9f480eb037d7f3f7a6e98e4bd5fda61532b209aee280ec24dc066019fedcaa699c5c252f8e1c0ca37207837f1729dcceb672948f95a5da875803cb79c465ee6b5f39363ae338c71d3e30263d51fc099c5399d2a95468a984e304cea89cad39fde2446e8c69e5b42b85ed68e22931a7157b1a1f442fe9087e373efe0c6ddf229483f7a6e454aa1046f04c046ddb66343894e95b7bce76ea96bb2d01ef65df20e56fece7efbd29cb71856d4f9345aff5d97f5a55c11d8632546703cb56df6e36bfa7a14a47444e6bf9c1a97c342e181b0cab68f13d544c3ef6fdbac6e9acf89357cc445636e3346cfae11f1a16d2a7683c31f53dbdd97202bf137839ea2ed7f4aad3c50c5fffaafae9f23503ad14d9e5cfebd3bb3600921d0768281c5700b6fc3ee151ecf5335891679e75459f36768c7e5be1794f080df1c00ecfb4af6c94216bf17d652f66afe5100e62150669d83ec208ee8f274dc1d8eec9a70a60cfba24eb811bc25cd491354922bfbbf2fdf98480a687b6558bd0957f2c055ada44d07db91ebaa7dc8f9e74b006dc817cafe10486e8f45c517d258d3bb996688c9b12a7c3e94ff36d51e99f5c37330af8f5af84dc898f01c1464057ffcc0685f22b91a5be84985bc41f5ada169b54a7c3cdd89b68dc1a9f3a120c44b0874eb516e219aa2d5b42fbe14d46817543ed9eeaa5b4d09a8e84d36191037f38fa1f296d3482eb0d128daaaa6409049036a8065f7a5aca62a5ff5e7231ac32048efc5e1ec1f37fe5bdf4a57aea9645e0b9626c1d28052873c86aea8605ca1bfaa79c8410e751ba9ac89284591cd78160de32332dcbd86aebe7c6d740f3f2ffdc93973cd78cec5d6c8404b3ce3596dcc34cfb5c073ced3b9e53e48c936109255a1cb13370f250bb78f861cdd6f46a4b99eb2261038945bf240445b1d104aa1f75966538d4e73bd58f512558cb05d74e3d3228f4502904ce0e6f695bb4172d5eae2ffc727526e1b4ade0026448d4b6b66ed8b44ec4c1fbd2037e65dfcf12962ed4ccb9f2472cf32827ffbcd8bbde92ebd3733105729c478bd1ff2b5cb0cae1c6f44f3a8d5011f49426a9c9ed3fa037311c4055e20af9b7950ae27006d0119ba9dce61187869eb3ee0d796da7160158ed1e5a0248a86ec994ef5dffaacc0470235cb7ba45db0044b31d18e990dc246674da0aa92086400728cd9da629908f4c2e018f46b5741e1695d81f398c9a9d76b7d91d339eca781748f9415bbdcc49c08e7c029313be35a19da0a7775d59d20cccc65452b8373842e7993a5907eb1fc6cea78438a68bdca7be5ebe5bb78d1df0306cc4a5abc4f451cf20f9a87c5917efe4fb9bfc7bea78d832fe67413befe21eeb0eaa59fbb70f29f12d5955efc9b527bdd67b58eb4f1d57c236ba91dec9d5525473b7798ec0ce4ccf6c356bb946586924bd678b5d48cdc12c5a248c2e8f1c459c5e1e84f07ed0b19693014a197152772d7be8703037763b74790c8d3b0c0002538151a6a4a8fbb22cc5fda6c81e5e2aaa8f57a876e778d8143ab54ac5f07d50ee9b3744af974f752720ad1cb114dd9bf38b1fbaad40522d9f204e0b1afb9d289eebc824d8dc20fa16221b8cdccc896bec38819c8d968eab66d9e7178f9c3b5d318e5722e507865b3ccf826c33a32dbe6c751bedc3f61b3b1e8736706aa90c379a5b78dd8886908defe53b5ab46449db39db408867a341b0ff083602a670dc72f5e3358b93cfa9cc5d3cc5cb57784b7f7bc5ad5ac163a40dc7d7a83fe243c39ebcc0bdd80306036eb8dd5b23c5d3254f49358c5b0c7975bc39f2c213e30b6100d0ddd4f1662829aa55e50cbea9d5f610cb1e3656ec9f96abfdfb3860cca4b9fe63a0ca91d2a89fa12db38e6657a9ab57bb780bcffce2ed787aaf4a51ec320d0d1012f7dc917830abe00789cd1424437c7f677a14073e866ba67908c5d88addf75544ceec90f244520b1d83126cc516baca63ec7a9c11dd6396f55110473b39680e4d9be16b438d881e38842626a206fd09b0acb68a71afca2fdf502c00d5bcbc4b54fc108723e381f9c68c80498490f05e39a7b6ee10213bd712bbaac18970bf935d0c0240e87b2c2bc9878876c9b25b8cab02f3640da8a4df0a805fca0edf276322888ec42fa30e25120299687644d096db7c923c0a31079118a454f6ee1c97f83ce575aa77d4191d1d3386c28e75dc3cdc4587141bc741e5908c1abe328cb14bf53615a110be610e7cdb954fcee33866476895feaf8911bf71b667431c88b238ba3567868b1b74c89aca87986aade63bfe2d40beb499df709fd9a7c2a6706ceb7a5531e156f3ffa7da5a56d7963b3cca51181927fd9d73f06d8aecf9b110d798db8f2b98cac5fa2092e697035b05ac875e365e7a21faa1526ec9043c71b6fb58add5f905fd97dde4417a2f1c8e842320de17dadcb99903a9403786001c461440a3ba669aff9bf8648e53d84efe841f0ea36ec1a4d73a8b044e56cbaaef4b355015a60966efde619c03255828bc5c3ea14eb7e29010b2de5aea90fd4f2fb4dbdefba144da77aeeb6425cc8a652bf5add09430d635b1eb26296292448e3e737b56fa37a03791e24ff82c3e572390a816d7813bf535f371d3c07f67cd3aecfc49f8bce79af67846b2d7c734152e9d1ea6b14ab206a9e78a4180984ec4b7b8294e5715954ca4bc2645aeada82a77b149b1a8e57b45f9841bc67a2b46410852c554d9cfd1cf7c418604acefc775a353ce28eda972875dc3fe1287aa360175034ad0a7d96602c41fa63276cea1e3ce933d9b07a3174534abd48db6ef2c8688fd6a4b8e1ba677d74ab4a37fccbb5e2d3c49eb2dab12426eb7a2ea2e0936972841de88e4756ab680ff6ebc0b7eb090fcc71f44d403aff6b96e067143ab9ead340ab380fd9001689d277b0a3f92e65a899e323cffc39f0cf3c8e56e30e271c41514c447d273160c2d710c05919656a45af79019cd61bb9d61d2511ddc391c7774b29c0a8cfc4e0557ed9ba38d421f129e1414338e8c4349aab64d658f31cb923d7093a93f28483d3e096dba61732054d34efa4ad8696fb3a91a3f48e74235be638e6d5fe2a7525c42a2a5ed6a4343d61daec10dcc3ab1ffed223926b5eecb3dea4140bea4c5e852550404e33773c8da9ed1cd9dacf283965aeccdb5a2dbdfa741797b551039656669d8f884069a4b4c484d98ee5e4aa50be10556b8c868f8bac8c3f4d04da68c8b2fad7ceb675788c9306859a83f45fae8c296d3f37b54b3cd92039793210654adb18a7c7e404eca872cb796c4c55e2839c7e10bde5f80341fb20f02ed78b39a0f028cb59759447909560b49601f2ba67f11d57c2c5c56536371ff8c53329fcf9fb41df0e7caad7faa9c3211a83e054f1cd2c0858439ee0f48b0ebea0f1d566e93d14e2841b35b61f071edb89253db4d982ab1f63dc5fe2218126410a75152308fb1ed3548953fb447e3985aa8ca56240dc4717f44818ca1e08f8affb0812c1ebafdca7dd6e8e9b5ce709e496182a7cfd70e5ab4b3da108398eb7926085403eff9c5b98566671553b99b6720d374326a49329e21931232d32d392590b079142612e36c33af2dc91b3a69c4115262f5ba38881d856481be5fa1cef3027e0a6c3bb3e151c81594c465ee03b016d383c64ff71baecc43f56ba4c4e009e96f18473790c2e505e2ed0d40ea63f80777f6092fecc340579e5ebd1188eec50e1eb197a0a75be9b3c1df454fab1bce0deb5a4e07f0dcf0346a1606dcb530ba99a4d196876b7af178202f28eb7121c35f96343283dccba23ff3c6336a294598831082b43c7d9185e8a09aa6fd14a1461b1766988163c31aa1664f9b2cf9fd63003e98f916f78a8d986c44fd49ee1b11159ae3646fe79be0e7c93edad998a301d383c579934951fd172167746fbdbc4538b8243d07dce75a69d2c433be5a6901562a8de5dc3817481f33b1076a84db84f30e65e56d437f392f736c4a5201f127e2652e13504a59440e49f2b126a445367ac1158f658ef23f5513e8a1686ad83c44af913c3293be771dfac4c9b05ad57fad2b31a6f2c84f86f0f01be5d5f3575a83eebee39c984d65f15a45dc0e25261705dde1ed143edd41ba7ecc2f1338172971b3fdc97cc730b5ead3f3b9caf2e5011a514fa713794661ce5c2bc2152d05971a74b96256c15b54002bee32ccf9818edde016e3eff971342fc23b27e8bcd1a58af13c981bc61855bc90b0f378b4ab800068b53ae153c3233063d942d935b7b1b58abeb1f6527f394445e72c3e84b48ae142d6a75760be93554cfdad5cb462278e4d3ef88a51f26451ea35495e38401b1a4aaa253201f9cadeb722b165ac13d1a782d76320d56027c68c4d6f7263e16476172d19b9852478edbb7c0f30f653a0b3a4889974d40153b082c6a35aea1dcea076f4469b698f77e2d87d762fec962d08fb9bcf1c9b0146bdcd5776f0905fbe2f48bb9355782ed32c11ca01739ae809499afc87d10879ec3548e211a8223a512d360342797be43efd7f6b28cadabef36f288af54b70441568f6d26c5b1d8e4def3cc49ff772d704b2440b922dde508a869c39f387840614a76106f5268b744ae26745c8d0ab91528a1a641c00c1aa9abc4eafd0d9b71d2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
