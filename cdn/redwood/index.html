<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6b729b4a0d64b9f5c304557c918f173dea46fa01c84dbe8e335f23f858f4f1b43edd5e5238b2cb414fad0bc971499e0998eb1cc66014033316f2c013c9c82d2ec6df0473e71fd17aded09beeb63621e6ecdf8c4d64f8d53892cd0135efa2447c3bdaa6e06b024f493d390d70f78e7ced1793cddd598b15940d60a75c7401424807d950ee0a8c685e1950d232582b43057b8e9aff662a9718d80a33712802aadef491bece26ad580b3425b09811d9a958b473e610644517c227341aa2a728365f419271d2fceff3a481fc8c0df9db883c8a9ebf076610812bb55cf5338c1546c89a04234be178639d67dafb4b37559826ac5b4772a4f8b5fb84424cb11cd606d395357883b873be778da70894b48a8c72879230c4d5764e4077df5847ef2480fb42b7d187e20d9335059401962a13683ff7756f4650c7b9f2d081277197b50c71f764953b2981876c543e50bd70f0d8b53ac7bcf1a4dfece51ae4613952335f5fc2875a17096ee7bb491c115f2a1f4c716761aa097c4dc418050edf1c7dfd983dc7938e6611dea2f0cfc0bed52615d4a54b3a7243662db367da02f037d1f6eab2fc3cfd04c2ff47d372ebf4ac805e39a59b8796ee194ff2c2e44d44eb00543bb58660afb00cc81d5c80b982ebb318c3159fb3fea05602842eb62fcfedbac85ab6cb9a5dbe87f6beb3ae77c3f3ab19a426a689f44e9e0d0e320362f92c4ac8610e42a6073ba8f8f281d735ad72618931301ba367064331d5699f43161739a041aaf795d44d38f14401a132abc0ca106ac65d188bc50c8b091524b1fab4465028338a71b66d96c2883dac5729843691bc5d29b9b5cfd4feea4f56399fa9c08a39ca33808ebb07633ba0f3a4162b1be90a1a97339734138526fc46e85ce7800985b981e2c64565442bed24a3b246b26e7b92d304fed87d0cb6bb38c334a1e4a40776a62423730dd488bf1898f5cca88339e2270aa8c7272af4ced586d01ad263d92e14ea2794368a2e2cab52e07d420d59042427d789cc0b7751544a16e175fdc233dcbbf43325abb2e4cd58bef30da794d500e35ee3f4ff07b9fe547ff01f43825ff4a66a444b011ca0da6f9bb037e513947cf280aaf4b81893b9b7bfe7add9682c4fd765e24d4e7e99e3363d231e43cb215bf223b44266864c75916436c01126087a1f317622bdcca112607a96401ab0b59e8e133804fbc10fda4bc288ac92a99210352b50de0371becd0a171bf383f067f6b907af8df981f36ea964ffeadff1b9147a32fdd5d93312241b17f67984bd18fe207daf7c87f332572da750ee4469d5f62f73a7872a7d31b992dc137745b1a7e22c32550df7a7d38cf3a82fd1b1f5fb8b80ff80c80bd3496cd291cf1306a3a583ee356546a8f34dbd838363b0be1c6822924a02af8dd00e31b92a9bf105657e3ba6304eed03137787bbf6ea926a1b804cb556fd2fc01ae90b1c05800de2701a87c6b57aee16942934de47748181fefb777ad2466fd54e5b627905bc1826876b644a4cd2190c035a70c23d9935857a7feafcc0c5920f6c6e69931612e9f55e8b8790caae4c51c4ee4135661a83a9de65b4d8da069cff209b37aeda3bb016e28f0b1a0262ad5fec4e3f3421e483762919afba84d26b6b31e6895683a6a7f09e1b2920678785aedd008d85d8754593921b0eb6382185142ae926d089247d4fbdea2a7754fda081105f8ffbb716d538d71ea4e0a432339f02d0a69ce548f1a34de4fa58a7404405388ff42a47d74db699e1d7108e61e8741f8134b05d83708234941d82ed9e4222441a7ae8944ecccbecbd14a8ebfe0f3d01cd7f0a7da8bd176e682738fb832866e94a867b522084f65bf27bc810a3b67c5ac02d9329bbebb7225ee78768285712200e393a84bda0a447c7842e69d68e8a4903b27bba808e9b851878f8734df3ed16f870ec12357402c573ad5044945a9b146bfcd40856723752f0f01a0ae82368ef546db677abceb198ec6d814d192ec8f5b93ec4e31d2bff9ae91039519011cc047d847fe4706f60fbeac7c9c77aa03c5b3b7016643f14a1db863f3e3f21c161aa079f1fd1893b22a80eafe3314ec5f93b45310bda57e850f2ae850b5d7b975b74e757ed8bd150f957b8259d134f3cc0b7f4d7a98a0b84e1114513b00eac4991496cbe1abb1ef463e0a693c6e54781c90024f96fd04b4e2950067099e6212bd2a2fc1c583ad4a1e50ba9b814ee309f9be97fc49c7172a8f83c5873e22928b09f8db790a27d5104a080699898df001e7a2cc3da8842a2365c02670faa2abb91cb4f0805d944e685847120c04932fe5f4eaab44ddcdc51a980cf437a6d15b1ad77bb870f0f39a4f0a72b2d69e7047036725e2e66bb4c602539e9b02c52e56c60201603bbbbd341e06515c0026876bbd2f5ee3030b251b686d66dc298ddd07e193d723b01bee9e25cdaa18ada26b620232c379b5463847f4ccccd1bc10295950f4bace954fe81567c040b939f65ec572d677fbd9575ea8b9e50066008e376289fda1ee4fba0b56bc840187e7b1352f4d5283e63c15ef5b00c88a61e6fe9e48522c08c0b929b275a0adfd131460d6bbe25a044b94943d4e216dfc3337566cea4ed8dde399e177b13348e4d939a22662014a3df4d5d8dfeda381b9673725b0378af43fc59d518039b17c6d1a64f50760bcb3a441c704500fbce1f80b4004d93eabe3366941fb03fb7b78b316a6365770d2083850ff814505be25b6fde75c232a867e5a5935f88b3d4585676dbe84a1e74a30bafc0c78979a33b552a639ed7b3801aef40ab07b077636583f2fd6d6ed5e6df5e45f260e2328c8580aa669c57eb153df4a8f6002918d27545ca62e190512ea2984ce7d0ab3357756aab80318447bef504779147d2a97decef8876fc6143d3a439a3ee5f00edeb449728f3d250ce3694bcaf822d6b413360df7c6dfa4fdae1ad102d8dc678cc48367c38bf132133a5b35c3b6e9853dae25f7bb9eb9ae68a42cda3dc527598ccf39cafd817e35b9c720ba7d3060099000ed3b3b668c442995376c15faa3a0eec30c4ad8ec5fe5adafc178482ce38955d089c1cfc240897b813410f260c2c23533140e5956dee6c4894101abe98c576755740e54ac0f9804552bf71da26d0a985022ad10a868146912b698604911c80503d8ac23fa2a4470fc6a9156f400b7bdd0e7593ca5c766999bcfca20d5d35f42e87049bd922257a119437a44dae3ddf0617bde273bd5674e8093c94d5f085e6dc8c36da8a03e82b784474adcdfd515f7ba27a3de2093c8740cd7990cb3dd04d5622c02d58bc2e12f9010bdf388e7015e1e0e51bb985127a27bdacc6d94d7ba6cf169531e371ed904aee0aa638072b5702f5ea6879ba84261091338b54d07623ca3c57972e7ca719c4080aa15d5f35bd5fe72f6860ed74a193b9990a6a300d568066f485169ed7c79ce3ccd0b3db2dbebde125769a3502d9505ec51a46407d5a72d89e1540aa7f56c44a422c0bbf05f2a8568eaf9a4adf0e9ea05e4b12bebf1484462f5613b3c17d1c878e3bf4ca2f54c52f0a210fe2847b0379db1c16e7f17335fa97162584385dff4c58a621281345bb1b8c8b8fff1b1f0bd48317d97a6f01a5a533b96a7fa97d564b5a8c20d46399750e40ad04d961907cd6e21c2ad2b69831d86bf777dbc25e93006f1023a9842792e08d7206fc639fa4a40a392dc653f80d22ea69bca28dbed58d8dbb17fa52dd2f212f151fa1e0c78e034d06590fe25fdbe0d3fa693e3d8206fc0836098caaab39c942b41308c03c92ee29e90a9f6d1371d67c85e667a2787cd4812d90066ca4faab7d383a751e0dc0ed4d2be54a8bc42d15f673c2e31feca1db52a434ba7bdd451c687cc9b42d303beb7b50577bb1ee9328f1242e1031de83ee8bca119e93d53fbd5e1ef38a31709053617b9b8bf5624b51072ada6937ae95c3f9e5ea6898af883416f8ba98596c59b5a97954007fc4a07d353e657f530df8834f4761fb5602c3f05f3b2f17d2c365ce356319f0d983badb071874bf096f23903242e4e9d73f00a23aae58e3bc2d904149b91129142b1b17f72534cc261d8a8a47cbd809c94052153b68b73a7530e9a0d263bb7e8c07a709ae4dddfaf539c59125427c45ec4819d73cc0e376922b8b92b61ad3e789316bb9b6cdccc501df7e0dceb0c4678fb8470dacc1dc1839c6659389f57291ca29bb124bf04bd6aa47651065794be36f0e14c0f45d00b2cf0ec025dca245ca73ca11a4fcc756ad9b474f121281158904ad5cbce67afa557951839382f985f6267a129c15fea8227a895f19aef1747315233add2ea96f5058cd997e5d7bfad62bd657d04864be93a8704ebd079a2b1b32560abdb35a77fb9c29803cb3deff883e86e393dde841b00e9f57cb16f3926598e1a623072d098f154865b8314be8cd4d9cf253f69df7327ad74680431147d3c999c861842f4a8bba9d46a7b2f5d2a152808921f769fad1c7569e8d262b1763ecefbce3abfa6183c5770391b32058d6da939f3151f51490590c51ab7e7f96216f016bfaab62de3241914d423b7a0497e8af842e29f0b060a486844331c964cbb04a1d7db3fcc63111376d0da79e9d1445681e5e00bff28eb3e285c796adbcf9226a9ba534919ff21d6b73571de616f57aeb61959bfe08f36ac12269864ba4d54c3a33fd6535a95f03e3b06657bf555582f483b06fd503e769861ab884f46340fdb99da57aa03939f6feacfc5e289395e8d559ef4829209682c9221dd6439b13d1eb37e6c394fa192dfb3738e002ed924c9e38e51d77a652e87b365349439d09d5176e8dd191a61ed3ceefede3051b34bc1910b408b2804ca69e003253d12bd401874aee033d5b0c5e5cdc32e776a5bc4708e5c60153aff5303dee173c17ea61f6953e70cf296e2630e00e4f28469178886863182b793d7ae5885298bc327c48b13ccc00ced4496ae7e797e5dc58840dfc385db0bdbe728a53f57527c32103b705ba4aee958a1946ae1e74401f051ccc6464c62f961319e9248927c864b5c0d46405bba1aa89df08a5ca85619578327294ddde5d24f2565e745ec9015019a011f4c2998b468e7b76f1b5f86eb1233cf525cf3cd40ec1074d841f8dbcface459b227326d9c2a6616e00499e1d83920a45894d8c556f1fc1ae6bd82d56ce565428291e2cfd13dd0e8940036bab627293534b06373832db4cb87107f541381dabfc1e85eb14106d2927c9d3e510aa7a29a6b0dccb61c19068fc4d0511c6a771d42b0e642b43efab175b40749c45ba7b070c4b1f544a14838b251b00038272dcf2bb3d99ddfa23ff0cbb53a5f00c2e883563ee09571284e50bdbf9e475ac7878d2cd64b0f993756cc0f3a12445afe29f8d790a397fd108d89a44b58527ca93b31333eadcd751cc8ad39fe369db231faf4f6aa08600c3ebea1e2e09e15604dd3848334a860816444495549a4574580bacb12bf8ab8e83889b76c144582d78906c1418dfbf0b1ab61480a84faba9598e8c596a96da37dda8ec3d8c274344564e6ad151aef00352763990985f7353165017f93f601523e37f918c826e1e42413d49dfaaf27c4f93c9fc9a6a715c59ba1842edc8e952b7c562e4891c9deb444b6ec60e1ce87c460cbb7c49031513e79555c877c91ad363c82ee030c4bc0d700e770165103f810b33819248462eab3bc9b4f5a62a84dfd46af0e737fe5e92c5ffe8446f04d4628ddaea12946db6d67986133bf7d9d37124406c569d5c0564c6b3eb39e3153b0df66cb8f64e3f6ffe9abdb54752752088aaacda77e1c14df43f62f00ca45f1f73e9bb971e1e067e45d1097c37e4865c165baf64b0752740e8d75547aaf981616daf3c8a9ace2cbd7fc47af377e9f9d27d113a046f88cc358a336f73caa5eeb4147a1f785382ebac3d892fc539c3f3966f7e3b7492ece0f4af86d6633f18cb180b06fbdcba8007018c21cb7a18554829bbdf2b806f26bdfdac3451fae05b73e2d24624b2f066b4b467a17a9f056311796ee2e3fd28745fa050ccc298e87888203dab199369be8cb88114ed5f0e55c308439a5ceba678919ab13a96d71d7fb9b8aed546f7d7b9685a6f844d7d4ea6b5f22dd0b64fae5120a675aa6c289facbbce2937ab0c36616b9e888f49a8a29bba3cf13ffee17d5579498aca469719c6881833e15382aac0c774846f4af09c3a1927cd74ea936d1a2b0810ea17cc3845ec65563272ea4421811837ac8d70083fa4c59405974cf282de32bfd45b9ee46caafe37cd3d8f98c5de96791b9b042f10f3384a914b8f28edcff09d5b041ff70e8438e52d3f2fc6813f9fc9d4cb2dbdfc136c760a338a916f88a2648632c8ee06bbb0a11bac06234567fb0cba56e821ba7de9ac94d1cfe1432d0b60162f745522667e1abc438d04fbf2beb8884eadcc47b9af6ddb1b6eabbc0c03c5571ce611d2d2c8049ff913e22233df00962660a1292ee18dae99a2c5ffc0755bb9f3393e44c7455bec5e2420f528d338e8b115dde466c54df7a31309111e5c9cb5c13ae24a9f2b2aff76590d7c4a6aaa7b8b85729794cd0bd22f4fb30768adeb13e1e39baeaf2257ea94b65730c2591cd36a802216c12a6f8ac677d159785e8490d30352cdbb7598444ad5a0463ab1f62e62d69dfd28058088a6343d36c33563134a8be35e27b3220be16de336b37ebe6a590f87c1e53ccfd93b159945735017be1802ad03543a4ac9020622522b3cc553b4cea0b8edefe577e8835e88cb23ed67abf060a0d5f65df46364ae48c385de4107f94202aa83c3f5b19e8dc768095e10127782613d658df92f58ae518006ce8bfb8b3f5baaea1c13419a357d5afa4f236dfafafd4435d2c8582fcb42d2d57e333f6a268d7594327dc34022fd1106cca445299e047b9faa0a70bf31cbc974697c69da0f13bf4ec01de4f4999446e9a3406167e52b4be051d5f3897d2d9f87c2700e8c1fbff599cec3a1e42abb01fac4070f21f00a465257598c76809660722a5f6e3ee5b8f37347830b2faa65d04617638d9df2eb5afaa6669ad83aff483bb290ef40d73c448d08eff0e4090a8e8c9f4fe75a2a38d654137f71641f94a7e2267943a133267a92feb266dcfb1067aa2d55576827dce1c557b90ca3f432c186a6d07bd90d2d8d5a8bd216785c59df60a0f53add7bffae4640e319f5cfdbdf6754dcc76eb5a62230bc6a261787ca03cf81d2bd1bc0f2b310ce6bd3982fd68566e4255d21d45156dd2bcb617d8dbe142c24ae65abb824320ee29a5c7b58de16bb854696ce62cc1e59dc5b468f3d49fc3d5912e9833be24e47e9157a7af58c4a67136e1830c5b1e05f8b28a33cbca6b2dfacb17aa43e2681f6f8fdcf89fbe2a63d0b4b0c650ec46958050871d5799ede39d42afbcf816ca9a76f44cde4daf705cbeec72c145df2b07f85844942510a9f042201093147f334cebb65bf5b9fb3f268c48b5cad5a35a8f7740a0c2c7bc94f603ab94358348ca1e78ca5e02f1badbe699303ca0185c0d2865c75e0def41361d6de69cec80e5fb26b656cefb3418318e300bba106f03805b3fa68211ee75b8440875bf9e62660e2d23c43740bd506eece352ac6b98fcd2b47511e5f627d7ef80317e476a8ee416f72aaf0c7c9b5d5eebb79292e3bfbd95e014d7e7a249dc34187314e49c2d7772237fd795c6a237bbc33521eb8d8a82c0c993f0f39006cb602915f64eb7620a85e5cef1776569b01a5d9a8c3f7c2408f784bf8d848676875f9dcdfb138d6f9011dc44c7bc8626788d4d244c61bb9de6250e626c957390bbeb0e2bf8dc74a385c4fd964aec2318b1beafa5a1df960e60a49a426298f5a8907c53452f7c0a7f5e9872a9efecade7124366cecbe549c3ac8786595d0f2b339c6b972693f94647577dfcbd74b244249ccb13c7dd86e5ed5b97a656ea23abe6462fd5fcb631559dd5428c9d982acb3cfe8202789a47d609b10ae1501aee2db0aa02b0d3cc44bf3a6bcaa314f2951d6d19dbcefb709320adfc87b7be4bcd2efa0721a5c08a79adff4e5c2b04a9066db8da4e40d6de0f1e951f8a21d913d35dbd5ac2595b08e90b890f89fbe4191fe9445adde2c836c9ea5bb3164f14b351dbd6d4ff64af81c4876c1698eac31372b3a4b1e09deeaffb7adaf9d032bd55b5e14773ba0cce23a8b7832769f596ae060075edf2f879e80f25f8cc772415ccbbae81941225f2a382f97e87e1a1687b55e776e401326dc5ab7ab401676c9ba7fd05a0d5a910fd08b51a45c9ec54726daab8f74a1141298f995ccfdc4ec424369ae4deeb4c62c2a6fbe667290e76f6fbd95c11cccb211c60186b5c31749521a61ab620b73a7b26c00fa54f653a6323b0aa84b7a6d743a3d70b15aff41e317624e1085dead2937b78edefb5f32337f3f7c86eb06b082839a7b9b1aadf1c68c633f7537f5a2fb7fe94e7b18ecf3b437343f42b3add2dd3ccf3f08f0772ff418f476f925ad8797606772702a92426a52109207fff1eadff3dc4661f3a271107018eb5cd3c80f53c75375f1d9cb10e5092070a63ba004097b35725e5b26d13ea3d343e060a26ed1aff0cf62c41ac0b098bbc54434a9ab847f859682127a5b8e88b6f987a2d31d32d0c9622086cf028c8cd5552776893caa231fd5ff91e566c30dc7253a672a990e284e889135b52bd8937a95d1b1c3179d75808bfd77909b1d43c48b787343319c07e6fe8966cef8925d50665f32075e6fd425fec606b58cb6e26abeb7e21c1435c9047bed11c0ca2a17e078dde814a29b33ac47f63e92b7094aac52e390507e6118ca11bb363e6581b8e3d5d4490ab71fce8ec01d03a4778395148b71aaac988d20bfafb0c15f3e52eeacf90ef46af0f537addde18c29cd7a5e802dd8b9f821151f6984b4f12634332b577b9bed6c28147da9674f2cb687d741c626318f20d3cb6f345ad8b7fd9ef221360af480cad48b8d4e0ad80c1220eb507b9e85bb6eff092084aee23ff4c813b1c5f615f6fbfa13af372263af29fbd492a315a7d93a67a81d9eab7b979f4343eb14b4dc618994cd193c43627fa4d804e87413eadaf77faec6067bba08d1fae3f3ec8bd76479377ffd4cb6983716ca9b989945d915bced2936956883b9a1c3095c143f22ec32d0cddc7fea5004f21892a225c0d4134fe75126b5283b291be3506efb3de8769661d39c3e757eae0e04a6215d498067ae4c112e32fb2082a204b2b380de2c6e09db26051b1d24eae5bafa6f5070f6526ed935896c3ec1ca69f46df915e35a9520f5a349371d18ecacb914def66e4c4d8fa664c5e5e244ab0dfee0d940d5951737cda3fc923e5a93beeceecbaf93e413075e535fdb42b5407f841f6a15ab7bf8df8b79f89a65b4b90455f1ef07a61661b9ff29787732e716bfec697df940c427d38118cc48c2ef272b68d624fc09154956b14bc60fc1a51b2cd834db0fd5e6a94a0d6bc9c48cf398e2e17854dc59799c1cc7540b7e7db4d598c7022def63a114cb6a2e3acca89d773c202cc4e0b65415ef8bdb1adb3f53ae1f32a487c4c5a7cc725f88636c4b369dd9b9d0a1591695a7c9c44bd32ab7a61969064b7cfeac1645fd10f167ce278030a24ae181cf8407afbefc9e2326a1248c4e8651152067031404625d7764cc47f2a1e55e67882dd556541e1bdf65e5afe11f0b9e425f0028c21525a6e446b7bd3b446872b19fcd731eb408070feba072e52c0284f3a11cfcb14090da70919cf6071f6ad58311ea69d9094c9305365a5f926d1b9a739d7c0e8b3187f7254cd69407d4b43387658157027d0e302c14bd05112859e8545c4ce9aef86175a979e9f9aec905dea59800d960c8735053091f1a2b182379c91f27f21586380b1538fcdf27617508b98a3f2a1e4551a0798653027b978b78caa7cc7692ae0f4fcb69eaede87fb1ffa8b17e89c8b95f43a115859d9f181710523cce371668125c4763558761b6098a41d2072676dbe66d7f36742b35c35a201bf73390dbb3573ecfbfa693790e590806fdeec938038563a37b900e36f6f71c0edc97257bffb270121a1152f05e0a40a70ea45ab584739dd83ca2fd371fe242deeab27a9c8b0457de0e54dc8739f2391c870fc72aa1cc5abdbf7e7865c470ab13bd038d206026c9e403f0c55a147e8feb8d9b0474682afc91550209a534ecd48988d01273dfb95de5d1b60344890cf77aae44aafc4b7c7a19b5f0be70553a5bd766303ee041696f627c6877193daf187389393fde4926d3d0110edf3f551ab0b94585a3cab3cc64f20bc3365037d3eab18526e0768ca20ade1d161d142d1c0182f98a974723af4049bfa1592382ef2212d95bc510317e0c17f8724d74e00ce7b79e424c541d86dbe91410b2a4d23f8cc837f1247a6231a71b2d8fbcfcc4b7eb9b7a4082c894d5d059ad0fe080050df63450178cbe82a5912edc07c4dba53f098a8b51b9297a5184185e16d23a3cbb7683326e5721b2053cc724ac35f59193055dd52f9ae44a2367b316f2394fbbe03e569efb18d68f1070d4983a15b847c7ba970c93a6afa9bf8520566bb8a674400ebe1ac4d1f9e4596995c467d128e8a344085051cba963b8bc0f5a9d5b128782cee58ce854331b37988d03df7ae2e228b5708d2eadc73de7be9a13e1e1b32a733f2fabc0d7be08c6d7e144578bf0e6558d68d03a99d7db00f9c9a6b8e1b38863ff671ed2e65332168cd834a795bb80a8b01ac9216cecef832546307737f3609f8bc90e1c5ac49740ffd4c90f57cca5d6967855f0c730874c27103973fb2664ce28174968e907b3a84cc3725b8bdcc3d48b52dad8a83de06a56741af78035eee01611912f3cb823de0707706ab049d5620dc1bc10d5364739bc15fb07d2aa27992adf92c82b19810cac1f2c3456999c7d4c2ce8bdf5c6026747537f4f436998395cd6a10e8cd9668dd33586929bfc44365552f8836900a13a503d4f37fdefbc3667ed5abb0d2534ee3580a6aa07661675459ce9027bee4442800e8926e7ca7c260cee55360c9053f6a5fc9ea4580d7abcfc06b22ef37cda41b3f6538c4eee71b7f84d40c38cd9454ac1f8f95b92600d53bbc0e26bf37b68f86091468d29fb39f85223a3272ee5e3ac721d2ab812552cd3cf76ef6674455dcecdbf0a0cc91502c3ca7a411ec35eac35ea95fe2c49e5f3a625a996e830f91103735ab0f79b5eabac22d62258f03b1cc0e10869df1b0bdc700639de73a104b7f0941de9a9064d8681de250ac843217737693f5632af96fc7773eada2572ce03bfa8576f8ed0131d8d9b56109d7cde829bd9e20c516320dc8f5ad5f9eed981e87ce4e56d43f04b5debbb087c9a316b408d0386e4f3d5c46d87e73864c5337905507414d976c89cbdf3cc33c2185e9cd6dc7f3ff416a9f2b20f1844c398021d2c62f4906ce401c1a8dfab178a85145598a0a36366798b1bff19b766d5a657b68cb0e6e87ae0437682dabeaeb610266e73a10b0ef2bc580d7a8d8629bf1854eb596626609a4011d5360244036576f16d6baaa387bef7475c7ac741e184baf6d70a20e7a3552476baff11aec35f373c11bef8c975c3f59573d32dc0bc19c607d44e2758d3a0067566100a5aaaf01f99e0939f2c93d23d1b417100ba3f29b0409a9c34d70f46b9ccb711cfbc3c3161d34de29eeaa8f73193d617ef145d4aab67483c529e02f1ff1dc9619fd987415ee1e6de3c69d508e8b892b4037d87edf96e8d98021b6ef9e6fd05f843f09769845676af51eace41a01d7a3efd2ad4a3125fd4f9112d7e88068455741cd03a15f607fadbca36af9a030bbc6a69b931099f5e4788e40a57fc92f7bf35ee20fdae6fa2bae8414447dfb33f22d91fe5881f77206660b6fdb4beb763ed01676e96001ae927e64a9c9a85bc821643c534df8e95e7fc99473bdd52e9668fee8e23696fb5a49f675d2b194a10b66b398a3e4e3d6339fafa848c2ba0a6f24758c1b51aac8dad5cb9c749b9dbe2de76a33cfb3cb59eab2fee359ef05e13aa186b5605a091b562a619cabd0cd25add8ea85ed90c6702b8a77280fb8d16cb14fcd2fb861a3ee0bde734af30323878f2c0def483392332513bb7235561fe902b9b56e19f838be2a9780560317d11922ed4200388d0e410c516a5c009f0a202437231dbce9fbd4a1d88ee48f286d435344bd1a7cd626d815016d6423ec9af24cedb94179e31a60e30af5530346bf963f1059736bcf6e37c13f6f40f5b314f0f8ef581214376be18eedb230465709743e6b7ad6623d2b21b43fbe2c6d3d53e92b4c2f2d6a61f3c3cf8ff12eaa7c40793f8062250f42a418dc82b811e8c2a24a5387ec18572b77dd0dd158e96575efcbdc67f5a12d180518c6b0f030b847d74d85fbb76939123b299f3a8e7ecf8855d8d31ed6f6f7f94d1b3b3f50c4f86c706018ea12402ccbbbdc11958c1fb694afc2ee202e93be44707ccd89c2c4ebcb57ded19c20df9b578113b083a1b0ab09fed074eec170132352de0cedd29bfc7b16b73695c5d85d1cfed31c2da654da14dd9e03b679acacb4c775c9d6f7c3daf7fe485c7164d8fb07e3d0de3c601ca6f7783ad73efb4592f30e63ae523fe4ec8ba92b2797cabd5b80cb5a5f4889e9225ae1896f8bb5920e0d391d595ab0da75ee84e55a5e0747a5d50940ebc6013ab64c660254f3b838d9c965825efc6e36cc8f23b27334648f71d3dcc0836ac7ced5c8fa953f141cea8477950b4d32d3563d51d8fff906fceeeb40c610271300267f39bd093b3a408cbe6d6840f6fa60454e83c6c64b92d44404da448d7a19d64166e8cb290a5400dc15b6347c6f8a1dd0a069080355e310c1882e84fdb44aa030ecc59d3c2567c277ee7988b9ce285e20b627ae91af7fa8c78fe1b0ff09c1b684f126f239fe470adfd758a4b8b14c57ec0d9eeef9c422248395a64d3e8143dfdcb51abdd8918e3687b7e38e4bf005614f9b411496e1ecaf321455c70fc7e39acd0a75f43f745b2529ae8a49ab01dbc28abc86c1e4fbcb4e202260a01e89f4431f65d971b74733e8546cb6fa42bd17897453c659a99a719818926404560108941f8567f6256bf7ffcfc6c1dc6c752ac87016d2b8437efa70e2dce17cedeb18b7c33b4432442e47295668bf523772b0805aa723a8ce910703a67f220a5ccc8b2bb548b59e895c873c9859fb15ea1c22bad2e3577e404c805f731a13551fd69a18b9e2f4897011981a20f0d17d24edacc1591d00cab269b6355fea63e47c6291ded3c76dbab885cfc22b853512ba1c3b7641b00144c2d27097600c6a82d51e95a0971ccf9ad37865cf5f9f6dc8b57f679d0321bb567c7412e3e55c608f13ed0ea61c136c5152eba44f421eb2b9a9659bddc0f265c498a7a5fa95823bac9193857cff54ed05205fa207883bad40a4e39861f15b6a619635e2c4c241832a8a45abbd06e4b17d867a9a084bb773c9e33868393fa9a544689c4af657ee845aab5e0086048285bf30c3ae3bfad7f6aba1113f9a5f1a8a1bfd8b05f372430fe66c6ddeedc8a53fa0faa10cbd46c452a8284a61f88074bb2f91d4d37fbf61a0f6ebc3a573beb4071ee435676c0c2b5cf52cd321c17fb69fa927b63316e7c04cceb9d4fbb94732c7330ab903aaef3929faa7c6dd4c4f6360541e435718744faa39e04dab2abeb86de575193088c3bddfffad3eecdc9353209a9a86e4cd84cc41af825c6c4a0c1f2349d589a015db3f9ad719d7550fb91b13828da6ee7e2b4ed9ffdbaf77f1ed2ba86f7786d66b5b2225530d09e7bb13f7355066127ffdc7c4bd686eea1c2f65275d10af9769b5e6032ecc9ca1546dec67f29c63b2aca89535e088cbfe953625713e4f68529d41cc93c373bb1945a28373414034b59830733671d458616f80cdff427f0065abe54950919cadb0e7c34b546a68800c8572ddadba9fcaa2b51621fe6c3f6801f20768af4d85fe25d8b1bd2d5c3875a86937869c9f8ac031b41ce0c0ea1933be9aa0530a0a11d0e1e7cb781d571cdb36fadc37eeff00ff8834b1524e1419573cd4a8a33078c43babc84bedb7c423ff9160b28109b9f3db58432e2a5200ed815a83e2b52d110dbc2de7a3d26e887631545469222476eb2d96469cef1a3782fc1d64c56aa684968feb36ec59ce3f0827ddadb65036293a0b32361930f7cde5cf73f2cd273e71a6bc55da3b35fd3687cdec38e108857beebfcbcea82851cf5a96a36268e53b245a6f8fdf547562af7993095797c97c8b5759b054cf07e361e305d5310d4ca250d03286d8fce837cd165230c6a7d00bcd6f6a940d9d305da24a60446553d971bbe818857a1937e6cda64fbebaf49a77ff47330f6238763edbbc022b6bf818c0f4d9a16d13f453f4efc5be0338bdcd71dfab327c1c4e29831124689d61af7b8d5e41429c1611ec4c69c85f68c7929de3f8fee6b7118ff285a6737fed037b9bba5ec8decf1b9f230e6dc1581b1149741fa503522e38266e3c23b9f6a1fa97330c8b8bb0e06915fb62eb40a04260a2f7f0c0b6f399890a713f9eeadeff9fc748d5160296a05e42a0c22761bdcd65a4cb333c0f08e9170faedf9dede50e85cb763d75b1de6c0987619912db7d22a9b799f1b762e07ee8cddceb5854a41c91eea1ad2c75180ba700fd7ae6cf5ee09c0e63cd9140776f53f71ed6b000713cb02eded6f36e0694e5df6387f49ae7836d10f8ff80c46111861cda57b06095f87b13a15d1ea438e7462b2e3b4d99ab64daf44376307def0a4cb748190f92c4c262220c6e7576f870c09c49ce27606ecb10c83462fe428774e38a9a964b2a3fba8b77376947038f0ab97e394c746c4104604a8b1c9847e481aba0f7741998b9922804b8af9169881bbb45be3597c2d393eaf5449616ac4e2d1c632853e75a99ac83728cbf9e2b5b6c502f624dccf14d11f0d3ac00a758a1afd873e62aab8d066c4e4c933b7aed333fd24b58d0e14ed46cae64cdaa05d3add89fd8eab2ac09a6e15d22f21e2d0c2ee6d4837459f79aeae9a84bfd75497dbd2f11f211e36ab778fa480844034869e692addbf17dd70614a66adf99994e3a549447bc4080692b46cd263a0bbbf142bdd380abad1df518ff8b6e6ab2c6322185d1e2c2423174a89c5812e83dafa305dbd03a9e7a2fb0991bdbdc3c3961f0469f246e8a50cec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
