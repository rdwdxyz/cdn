<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1144fec54b3e192071d74991d6f19fc47c76879b8381aad186b5b3e5310f586f2cdd8f9a5927614e0fcc4f95e1996370fb3427eae5c93792f156db65ee39228d8f0a0e8cf0a0931ba002da79f7d1c3ee0cebc6161cc6c52b65335d7212e1d0b9c9c03603e5ca9fa82871c2a1d28df66080db5acab8234be81c10da47332716ebf02d54abd3d3a1194ed3289f37e41b0c01ab15d998fb00a2ba44224309a85668b7bc55348d4f820922845a46b6a6838fee221076b09aa877263e45f03cd33c7dd5d90ca7f7c4d00700282cd1cd07405e4d262b2274d944719e5bde13eb4d55235594e0474cbe12f46b5c1a9a6de687e56c2ac70b69cf3fe5e54022db4d92eb45a84c489d8fd1d66baf243f89c77140a889fa5b1bbfdbba088acf94d1e17be5ce11c01187c8c7b54cda934a47078736ad5364a3e68d97368e924c6c70386e63a502472b6113069e042b8d57dcd57f119f529920b7594f75c0b817b1f830f6c88eced54e92121bd3ded3159e80860339f8212790f48b5d156399570068b277cac5ef04b1de6abc0c4f9f5cc38ae65c418011629561121f2a8065aab50ad8e7a1d15246422117dc16fe728aa907f0720c58a9b355e950c8add58520b4e617293513fe94d7fee5af8d3426b6a9f0636528892375a16e3fd0f3c26b77915fee1b58d97b1f4c4c85f40bbb76a6c63d7f77b2f62c9b6bc88f72939c80da4cf859f5376463269ac04b0d285cb79392b6215297dc252a3ed59d376ff83a33a580d507d30ffe8cf744cc0e6b54365e5ca73ef80205984443b3c9ddcecbe932a287910735b28f6e4e6895adb5749e45b2af5c9afacf6835751ac825a41440f65701757f3a3c0c088743a082858cee2f19349dde2826ea4ea970f51d48491737112eee2a1dcae2628797dd01197ed95ad4932bcd186d3b0e01721c2c681b6d1f458b72d17fd0d271308a34411e423d9a2093394e778d22a784ec13d9e68bd0b7371455fd69b1fc793b48a34bb54ad8cddf0ed483b7ee9dea4811f12f86777a4b44c3e28641bdf9ac0a6252a145f89338e104b86fba080cdb87925c6db99851c60294eb98f045939e9e21aef0be90b36908b8f4283b8781c5bc5be809c5ec7b29ad77de5d593e1be1e82eda673a36555ca90385aadf8f9d3ddffb3466467ad24871ff293cf75c1cb45b1260a0192f8a5301525012dab215c31b76b6ae162f47efe2f5264b5ba4c782d18425409cbf07b001d177df6abb9f922c3cb4d695414cd99c23f3953d0d8e8d02a6a86e6969537132119937c298d3dfadbafce819d728b3a62d82d4e9762263c435054c8a56450c80685b95e230527a68c55dd2b977028d6ad459eddd0c22ff4a2db09392ab46892a289cb48fc84bd14834f0a4c13a94837a48d0aa30aca27033e462b4f2048869bb171475ed3ab41959f44b3ec9e6f0a5a27490480f872dfd26f5527c999e02a58343d0f1b9e07dde9a8dee7e332f1b3b9c8d87f07fbfec6a6e146811267d00cfc4a2aa42dc0832efeadc5b2484f7be75a773cb49869aa813d71ff429584752b965597db66d65e95d3c60159a51d0a97babd45556fa91a22d00c8fe40dbb16330ab6d4786b893a7d4bf31b8f11cd6c9aa898fd20b9d5eb52907bfe8df6ac975bb816dfedb94f6cfc4ff54f4a3782f5714ee3eaf5f86c5e101d26e745d7da21dbb5acded29769bfcc0f5e15202f70c2712840e60bc29d03e334130ce039cabb1cfebca1598791af5e2948b9ca9e2165631a7155e6b4587528422705d2e1161f5df701826a40e4ab9fdb8a48ef86b41b2251f1bd6b8d837d22f8c767cdf6d696e99372f153cbc82eec021b7976250db7a7e5f3a348d2bc214ab0a525ffeb68321241747d6e2e435896498e6d37df1c048ad7b8a46834bb0ef54dfde5a18a83710f7945369db3ae314fb8401a433c86c2f86759d6b4826f9b1da9a8b14d10906f1b86b4ff0f5bbfaeabbcf0dcab09147393b900a0a283dfd82cb034bff360ce1bd5edc6afe83978554542755ff2455a3ed7035b82bd76747529458e22fa149e236026f25b149bc224ee7bbcece26fc8e24c405430c16ff84e2241100a5d47216bfb1eb2d3e98f45640e069235f257b091a854a6c37c440499eb96a1375a5d0b4a8d989d5d600e99b26e7fa11ebb0b0b86882bc42f2b46bf5d312089116d029c6b0288f299f52ff33913577cc70a5800820206cbcb9ddaee5da37ade4fd1f63902f655254ed949a2657c9b1011b2429d1b0a23c05b7b2caf706922994e66700a2a63ee2ab62faced0da5fa67a449925f931e558f3c3464ef6b1a6cdc0a84d7924b907210ec788bf18d2aea2badc14fc0009e22b335b71f8313766651c34a62ec87c0fe68c1c61ec3698e1b0cc0eba86e4a410ac99f004c5a338e13d593dd3658f8ba5366d1ccdb670ec550af92b5d0ef6c2c06084cf1857e1a083bb50e06785843151ae56af22f5c5fd11c13b432c692fa28698dcbec459361133ce7283065ae357ba0b7ec007f5990131a39fead1e0cf788354a50636284e2425617f96d2b0292557e74e853c6b682aecb02346ac41d27abc54d3d172b01a6c1aad0307d1b23d8db0b691682976d377d3293d24e4105f18c908a3412cbdc7f99e28cedc92bd4ebd105677462c69344b69c883f74139ab10cb13307306c5b9f0b968b8f89533cd6055f391f3d2af76570ba5e6617817943840931b37e23448a2d4f85030de5dd6fdb6d8081866659a4621318adf3d7c696d77d7dcfe29002659721335f71b0ec0eb2ab83016a0f3d7ce01426b4c6642bd507058819582cb9aefaf4fc62bbf2047083664308c70c7e6b0f5510b7eaa8f70e24e467d35f08699138b7381318f8a5d1025fb09338b88be5f6c409b9cf2caf143975ec019e2985570d716e1e5ca38631c0f43d9cc85ef5152eee209537310113e762e4b878bacd81935e528cbc76d2196de40f2a6cf3bb78ed161d87303a776d1e6fb64f66783a19e8a81e0bbc3b71e7eb8d3dc074b0a44339992d3a48734240ce1bb100a5dd33b8b04d4b378764fe684ffb48bf063aa8c31130e106ba48f08bdb603677254489bbaadb2370b47f7a1d23084e21c2964800d2beb909eba9bab5964c65e99b230a9fd05f463c2119f46cc8e2fa91cfef760b6d490d0fdef0b0733c8d716b0eb3f48b373ef8af9cc886fed487073b082d582a0eb58b40aa44893ded404b53342f3443639930bd14ac4f676b721df6644c161dceae97aa3f58736a395a460e4f7462990444bc752a3a98a4ddc915ebb5119316b6b08545430d76307ec36ce4b408f24f0bd8795adc685499550f1d69906e9cd047d8e5e2f5fd566e1db05be3c29a2e3482155c40b42695b3891ec93dac8e4e495c31dfa8577860ea8fe8151e3a3e6c0c19d41744d6ecd6ac3b081560258a41ca52ecfe10f043c6a3c7134981700ec1d018b43ce5b134e6970eb26e7a4ea9b2fecd80c67e81fdadacfb980b02b7a1f1854081595e32320a4c9313ada7d2303520cbbfba2f3e2a2d886ae9e8f641459bd1538dbaaa4bd3eae8bd9d471467b5239bdf0c521ecd4378a24264b38b59bc5fd811aedcc54783ca14c0d2ee6bca222513ec29aefb8fb69faa0b1e5c7ed80a85a7b2c316b749c1f9ef94944e6533aea9b045cf67c35c1a444c937b27f2185a45c362092b1559ac48dd23f6172aa2dbf45ed2f939a897384701c19f39519dc682c3b294572c2e7ba247fe65f1d829ccae86b693d27c1bb74c83c9ce60dde4a17c8362edd4a140065abbdeb19bdc9636d5e93963f0fcaed17feb8dcdb2f4eb0bd44d908ebae42cf7c388c8c38fa91a424e43873feadf42e6c1a45120e12c3228d54ecec73bd43041363746b4705093ba9c4b75d27c3fa23df54fd6994758b1934adf0aba30f9b29450a4a9368455751ec65bbf82d808906f18ec79b877a950194d1b5797880de04bc798a869c23c8758bc41c2076c60d74ad74d863c9f3e2a0cb53f61a13958584a1f212012aacf85e0b5299d8aa11d28486055a37a931e780e2b3a5ee19cc56a0cfc2142ef515dcae92e5b5190885798a89d19477705d5c39449056bfe653650f79b5428076ae0d3e4f9f20b93a7d401ae77670241d10a82fd608080ede7403b78d398aaef5b7eb3a1272d88a2a90493dd4e1f3575e7a044c3a01486557cc4849b46ac2d133500611afa2245d7240e259f5790469093f44b0a087679deb76e3734ed03ac34e31179f2d8f25b584d373dc0c20ab16ee9d1f2d7f35940171bbb8d2440d3d16b64b00b492a94b361000fd6db119d357345d516810013777a98b5137925d6e0fa348e66e514eef9cd69c3aa5f6ed01bf22aea76e8676194750515f90f5ab82f9f9110883e23fd83327e56a8bebffe0d50375d3c735ed345718748c77b23baf28979e1f0b4c7d523c4912c53457936bf6cdf3021f4b69525395a6c7db282d0ab7fc9d3abf7f7dfacf9880f53aa502afec535e7dd5d728cf0dabf09cf54cb26006ea865164b061b504e5970fd14e34aeb5f18f0cd9e157f4830626721745e60172a784a7f58b390362c4215ed208e8dd9731c681064ea60050b6e3f62ef295fdc43dca90617a246e0038462d9700d41c919fca9c63beac7912b5c1456573a3739d3bd234e3fcd6639d602d4d8cd5aa76b87ebb74b4c465b58323de2241645dea773faca67298940428fbe6d22305d2d1de76e38988655fdc6459c615b3a4291a6058eb6adf50760b0c62137b8c56edf92f594af68cbcba79c6b8eb08ebea9dfa1c5225cd9306fc0924437a913f58a424a67a9cb699ba447b2375c0dc25b7dc30457066bc1393d8d3c2b4d39554219e4927bc479ccb8cec385a54688a826ebbc8774615f88f16c7f4b672c9180d9ae081a6e0cf018d72bfe91e63c2c4b3b2ebca7a9dc1bb77317db58c17d37c995beb7ba307af603eed477d247a16021785b1d7a1dc3f1a57e2c504e8f330f8802be9cdcffb048931317c3055b93f330c945c50188bf2e8fd6f417675f7f17d53c6922b90040f5cc653d6b9d46267d8840c5848fa1df359d899263afab2749c01e07c0a84fa82f52bda68a5c56914ad77d25193521051f8c0af165a56c6f19ef3fc8ee3316ab66a71ab0414bd8122b112ba011539c37b873055402e4e8d91f9f428158018e4662caca1ddb770582765d87be9189d51313bc829425b7d300d19cb73b6ecbf071a84f19bfe1c7f8568feec2d9f6f6c6c76f4e335a156f4f72377f84fee580bb4eb7c19ce1efd8ba03fb8690d7de3ce0768261728e08a54e2fe95b07b0cf2a0c94bcd5fd725beafbc4c18bb1fa25013c16f6fe76afe520f61a304fc02f4dd940b42e43a9381f9ebed412296616124e426c558caf8d1c721659f731529c1d53ea1ead8c6a78446c20cb1f8a8dd86551a3f09007caa55ba338bd332b0c6556108ffeea3436492f23b0765ad59fd3bcf1679be81efa2beecdb06ad40d6a6ac1c2ae4cc30808cd98fd975310fb7a79036dfbcac8f3b3ce31e60f4d5286ae8b4d973b47443b7b249da0e177a3ce90ce0e0a98e369f162088cf8c366d7b5265d1536af746411d88d04136e701ba6ff4f6a52f63f36543cf1a2daf42ae8c67c857029252e4483dd17e16df4df1065c8eb7cb63435aa3532529aeaf9b568efed5c658a4cd19cbae3ed6ae6b02ef867b43f34599d3c3ad32589f16a43a663ace8861a7484da7689cb280a8c1edd71c488d1115b13027cb068d1d27b9072d7f00809994985441afb7d4ea64e6ec2d3b15f1ee352df0147aeda48cb23986f5c4437d80dcc6bc1ca3f6ad6147215dbf8f1528c83418d44c7435c62baa328b3f0fb03897f0a19852d6c812aca763ec5bb3e0941565666a906206f64b95a19bb44e0ff6e90caa373f893bafa7cbc2d873ecbed2d4bc9f93ac4c4895aa102858115fe3590336233fd323a50c24e4941a5308dceffd015b80db216c5a4a14ae2b9aec28eb09e7197e3a244086c399fd300dce1020d12e580f1ce501c7d7b54bbc680a8f81c1970ac8b2377c8dd8fde34db934ee634d98fb04eb50829f8c2a715a32154d7ec7e9b6680318a0f56b4f9ea50126b4887e087d2e7bf27af022415341904255595113929a10a500e9a96c97870f83efd5d6d4388245db68b98a906c52b6bea834ff0dc9c88d9c79c579e385c7d3d7ce9d0b6f057d1be0c381174b0753ad26e9dc2992e7bd9d2c87dba2fd3783c01ea84f6a931a7872b7e897322180ff139617d333a608fba99dfebc1cee156aa5c253094ec189974fb713fd1ed220fa6b37794b437415aceb725cec68e46ba9b27e332acffa827f6ba6f65d6d8a22ff376a7ab6cb1df0dd73faadcc36c6a175a46d0e91f8093dcdf1145bb41498b8f7905f817490920599f76c8a02db97c2ca2fc6fe04222614a5cb891de27162733939f207df7173c13cbde8a4d6dc2975ca6e729f8a1657e1ecd8badaf0562167b352d98b9c1733580de2545fe92a0a3750357d5bc287c3104deb73d4e6cd1a4b60b910ca3afebd224b6cb4e7d6bb02100d38387a29d85fe8493d13ed1a74d3ed01e029d85a446dc451b6060336a61fecdf88a5f4a40f37e4190f52d7a850f39163da68704769859ad5191d14f1d6240deec8550d2e284b57ef132cfad2f643f7ebf2adcacde47657a10ce845e97e35af1c422592699490e926d0a59d206d6711c2f49ce64cddf2ab798930c2967f4c4cae0819e67990fba427d71cd1d10c41a9bf2db2845bbb9c30362b7f2dc4fb82e2cb1ca1e741e68b6a2f6378fdcefefa50fc9674d0b58327872376481c6c93f17e2bbee91abd727a832d1cd6ed446d3881a5a4f17f2e0e316ab284d6248fe1c16a64f4b83aa3a990adda3d9fe6e3d269e2ba32e28266d4b565fb2b92764729d5b67f81e45b07a73be390513ce386b076da8d8e84c3c4cb5deb908b36a9cf27991c8090cf99a44425e17363ee054ef4cea3b5fcbabb651779b321989a44811a18b47002e26cf1bd1107d86d73582b602edab784897519a1f1918ccd469b779073717145175d28d3dcf34309ce71d9f9ad96f508e340b2a0300bcf64c9157c4c718cb35c43d7713d49eeb4cb00cb18992f2926464575bbdcf1fe1c6cf8b72d35330ef77ee0d3f7e7645040d903c8ff9ee64fe5ca435109c3f90f76df427dcd4ad9b9799b3c3032d5a61fd2a1d4956d391f87a06fcec3e6a010f4a1248d90149cb5fbde8f2571cb785f2ba97e18f38b7b204f12dcc96af5487d5ae05accaed9936064cb68915dfa8fdccb47b6af6fa72c268c169d5f7abb7ba2a36c055ccabc7e3093ae8de52deeb98e0386f61aa1329287878d9275c39807317a3174451dd80b4000648f2d8ed2083fe46da1c6ef1ab46cfe340bbdd23ff8b573579b470807f336a01945ec69078458bdef0f9a40797c2f34ee739e20337db94f22ba175d2bd16db31225566cb0af4ac818d43b66b6a1abccf27f62fe234ade2ee210a23fd3c84a2c863269ef6b1e8e82c3f136763a05a05ea33743f9ada9932cbb6f7547bfad04eedc04f1cee65fe9c1e295b482bc7d0e74b08ddb8e1faa136b29bd47b455b5829ea58726b95ba71f418ef3ae36b3acd52cfcb51e6bf33fd1b32234e6aec36d00e368b68967a92ceb10595e761792ee8ec50d24df5d6028b8caf7234c2a041b14343dba52e05979976181e8efc0555963dff69d4a46eeafcbc456d1ed3947eb7cf3ff1255daad148334557b119de18508d4e98afcbc1e445841ed831c387c150c9a99c17a0b99d3ce7a0c0f1946d255d7b964b1a6f9f0a3006d44be1c37b2683a435e4bdabb2dcc7247d4b809f5579816f8c9b3014b6584df25cdbc0a9216741494873b8ddd6fa97c481fe3f75a845fa7aa2baec19a5aee65f169598179c6abe753ddfd8fccb294b467fb57840f436c1e3afd5de564103e1a8f43e2e41577bdc2ce709ebd9305a52774908a35037bd076af6b0f9cb6d9f0a5f9068d231d2dbf55f05aee857c34f69901ca2ce01096ae08acd4943e668287fef8fc28a937f9936d189b4f9c5e79278a704ccdd41252ee53157d43ffc2450476c223f45cecc2f315d91ba4937d971ffff273ef724d6c1b67addb3ad7d280f528125cd8f4d9486a55cdf17656fccbab9cc443ac6c53d4509fa4cbd7f7f01999a08f66b4fa10476b76a4b4236ea3afc7393d7c4e2dde28681ea8926827ab8a1994f51b5bafca3e7ed5240b9404baf8358c028c365e8d7db49678b72f3ac56104f85c20f582d6a8686221da9c8edafb3d929fe549827e71dc0e6847d1349c37f4ea062c0b00c231535eaf2e799a5121ac71d2999da782e27c81439f727418f5e4d79c0d837d3d3c3e42c9e6923694b0b26fc74d25de3dc0667bf05f98ee14f75b8dd6fea12bbba87e7ae444487eae395bf7d36a22f6c3888b5726ef148ebf0b4630c22f2b9b26ce4d58ec115a5d9f90f3aa97883c11d418654200390f61a43a5ddf0a30901032803ced1de04fa397192a6796413d9c2afefc2c507236caa431c90e98cbd1feaad56f21e771e0c18d97d852044f2b233515119a01b32c0f54be2aad038b98f137abc6ac1b6680c2a7b5c992877b3f01be6cfa7f5b5c6ab8353cc3bd7a647d539dcc4333de4b8df70c35367f1a9cbb539c27749c8bb58bce0dc6cff3d8bd96c7c121afbb6212f5d81f73df1acb6cb150a2b3d63a1de8ed6161f8a38085fd22c6b914aa129c11c3dfe9ad0a723194df2f5f547240ad19705421060bd5ee8b34d8cc587a1360e06cbf2d20a3b98e2ace00add4e81e49c7564f0dfec29429f7e99906c51ecd3d3d25383aefc4d3ed12eb2769574ebf6ddec23fcb2db9ae441570eaed022ef10d34e9f7db45e361fc846c0af019df7c967b4ed4f016402497ae126f6edba26c063257205dcdb1c674a51cf014d1f9bc209cf80a917e2583afb6e83a4e90557c7ce0ee457c3461285743f72a813c80c00be47bad3fd1b6db83e45916c0d6c084457183dd0896477114bb2e7ed31b273d38d9ccdf537c9db133c0d1c1d412ce10a7933fc619d9fce8d82c951b70350d01b6fe2d3b6a29326786b459cde62df87e88cb8c59359c7315fd8c3e09079a2aa35f0ed0a4423713241b80678a28a3dd2391258de337a5feeef8d79d30a276f4a2b2446d21ecbab518d71cb4dfc11fd8961c31bc7f41c67402552423490afde2c6907ce03adbd1847cba47898d4bd14137253ce6d2064aa68a5cc359af1acd35486b76b05b594154625c313fc65d0fb579f2f32530e0ae04ea5c852e9a235a0012ad558764653f7ccc90c08b61335b3dc3f1644aae6a12fe48431d9688431e1233b973a25c94c9b516d7b543f7d96b9df941cbc22b5792586997fe0dedb6d48c830edc654eacd0594295680686782ebbb44b6da05582819856b1d1710e898669e62d7d80f9b6497cc3479ff954b7c4bf5801d42fd3c4e5945cf5a40c3ab5c2fbb156993cded9862ec90d01bebc4eb053a606202d30737c319e4704229978544c5e0452cec5cce5145a591940b2b1bda2d56ea213a04810d208194c39ddeadb7a1f98ef0f6d983c1e4bc00b25783b9cf9ad2b2ea4fd1d9af3b9628b7d5b5460b1450d710084c957192a40f0417733eb5fbaecf2f6525bf3b437a407d5bccc4c0681db091593ee52f2e66a93b8477188cd0bbc2e46b03d631f66e6ccb2a34d1b7004e7da1278cc7b26410a6f3837dab7e9ec8245b7520feee702b17f68872ca8f535587f0b91737a77521c63ebaa59f718cffe6e262346c501aa07b554a4585689cbd5ed91785f37ef2b3bcd4aabf4aea844cd8f13e5ad39e2e891f0a4bf4eac0785d7049805f913cb27c9fad702c811bc13a1129c20100ecd13a40d61e66456dade0bd0c0ce5380f3549153c7a33b51334824998ce2ab9fa58d5a97f0741185cc1ec1ce6e8f7455f39434e1d1d0c21e3d867cf81fb4ea1c13833ca7b45a10558bcec6ec2dbe26efafeae49628b799597cec6063faae8223dce447242d7a0dc86828c0a8a3ce5143fb00ea7a616294cfb17535fd49cc5a4d51575d3a25062c196ecc08d29e549e160fc7cc16fb246dbbc6ae4fe41a26ba40fc63a422b9b81c5fd987b6f3c2f772825c1be55fdb449ea78ad1eed1ebe69e721f403dca788a19e19c520309ad22c8edda839d557f1bbbd94340478785301fcdbee7825cfa96cba497eb99e1fab5433f12fffe87d03de03dc0ddb26cbd2b8d1735a5af6298b1246d49cd32adab7b2879c663ee27583b3842a241231a50498e966c9d4d68a4d59f116c20fb19dda363c3cf806a58e89724635017c4bb1bcb52f6904e9b8647c4522ff2c747e3a048ea07ef5fbbcafad0eaab94e21a2c8319598f955951fd291c7572258b39b8cc25e54f20b4cf6531a236b004285f9d292ec3bab4bd5c9c50c8a0b39130fc91da04717644d3075bca5239c83d0afb79d0b009cf587e896f1779cf2f9f042aac65bbaa1fd0eb656dd7fc73f127110761a50b046f4f070c6bf293c130868bf5b8aaf0d55fb24b2ddcc504908a3969eebd5e1345a3d95b9f6c56a1f092bf3268d9726d3ce9f0ef4ca1cdb145044e5267dfb309ee0f83b0cecd0f00a11bcbfe242bdde136ab795f120e3ba73bc1b603f1e1a8df8e45a9464697e9bef98b6ffce43d3fea2df59ec9a19176aff129e94fac229ce2b093e6d8e70330650790e2c7c7d875c8394c49c68faea31b3430697d1ee0043d7c4f5e0c5e2662e647f476e14f7e85133522c12050492a98829f712d38249bab85b0795fccbade4a37b557b552c5de70d80a9815873ca3615b84d5629ea219cc3102f08aec3722c76ecd8783869751b1b4d65aea9f7f09aca7de8eda7c43eb50c05d4158fdf5be7be83028bfaf65a04d27df241776122d1a3d4a39a9355b356661416b655824f0c9cde446e8b20349b5f3ae6f0cd603e50dd3720918eb870bd7b2055e9cda348514deca6efca879ccaf8a7975181c753bebd3fefd94b6f2486820bbd510ed642dca02063238f7b0494a9907e72249841dc1bdd326630bfd2630881a3aaa6bb56cf80852d8f0ebbd6853c628baa14605f952a4bdecb8c592b95f597d7fe028a112659ab16272e1b191adc125fa111acb4fd026373d1a7d6240371909b273c370c486c46147f82961c5e527755d6863875a7293eb9951dcadcac3e56c21ac3f941e970ff2db8090dad36a5aed2390d8ee56ee60611ca9aff2e66ff4cea5007f6fb34225499db3870393108d9fafed6b4dac6d1d4bcf4f3bb699c5396afadfb5d87dbd7da381b95e9239a816a4bf3181fd10fdbfc1050e7f2625a31e41fbc6847d5eec51fe916f112c77d7fc0261dfaef04669f817e3532f294f4a38e9ffd54d5f9e2ae659abebb34376496a96ae89c68a548c3fd0ef7054d7ab9db52c92f5a6a8c16c95127746c863e9c621296c68b15d0959628e7e69bf358b1116a846d621ca64b7fac8b344bcd00d71c82666240c6d321f3e52689ba63f734f5d653124de0d22edaefce349457aea6c95046be0b009c914e91384e97edcd860be9d5e8cc75d56f45363c51a85816f6fe1086c936e0c2f0a6e070c2439ce47870f7ec4213e7674fd8e29768bdf5efc1cf86e5f44bfa867101b16a98198169ced041a62b03a1c437ccdac7cddac6aaea94381992e36a9f15c51b17f4907fc8b8e473f100a7a415a6111dc57bd6c6717cecbe63b095a2f24f0ac9cb08fe9cf2917933e0a1caaa57e1ea31d39038a9b4d76ea30e8a8bb32aa849c2ee90e9f702038f2c5b7e618bbccffe21e26efbae5c4a50877d215b76e40697c4fc90c4961bbc06de87807a3d98973c5ed502dd1b5c101757d0d68dc0ad4718b1094c0f65076e6c8dc4e992c96fddef254131af991dd66d1b7e4382920de119d79b00384fbef18aa1fe5539a34fdd68a1f92276e7288f69adaa4527eb67fec221255b9ff5f36ffa775527d39d3fe3b7c57e49c5be06f5a9eefcdd88a37237aa5480ce34cd1d0d62f1a1aace6ef1b1f9eb487260349749c5a0fa5dca3e99d8ee3ea08585bf81341c5f79f26783889961ac604e1c0109b221c5b3787359f11da45e456c5f4b9a5811b522160de340fff7ffc333033a8670c8d5a4b1f5b9e7e78a91c54a8749ad62d17efcd46f4d2938a213bfdcfa33962472f823891680559b878d12bb505d077706aa18972aaab0af61e3141acaf93b4174d3b0f4e581b3106e1b0d5633bb144206b8260165458c6b7415da86adac35bc0824d0c1150e1b9bf042bc3928deea86ccc7f2bca5d8de59c661e005ed50f07492f9b52f50e20d1234d3d882b6687416316a79e547c303efcbb08e833dc9b41d97e4371e49c044d9fab62f6c782e450bd910d58bf03a9c12d568b1687662a4fe572dfff2088b46b10f77cefefaa82400e7c38061e58fb9a1fddb10ebd131d15bac459e0e3e0fa0a02b693c6e0beb1fc3396469e97644e7c9f4723266a2e6980fb52256329e24ca9ea7f281a9e9161b74c0824e518fe1759e5df8b25be4687d4ecdeb2172e4ad97e0e36bb8d4b6b551ad5a3c0fb5a22df19ba474914a613fcc9a60e5702b6908e71d799e59a758f2fd5a2709d0195c90636688720055549d227581acc8932a131278414653fc3886023b299e6ffac033f61706c386bc468b417cbee0d08a6aa16b5e41796dcb6f3b42ada87547a8fc81b0363b4da93fe7ab4e8c20411902380011b57b4a01359d184b9c0e7e593d783fb5d72aa8b9bb73b88ac8b20366f5cdfbdc53801d6bf0369eb56b19eb34c0f15472c56f29a13ff26793254de36767529c09d90db5a18f820726170b808d9998796f267c508b31b63c95b4886059511458f1d5222fefc15e1c99fcb5b09ff862102a4792acc4c82c947204d49ab5ffe4a21cd44c28e36c0558f0b13be2fb5edda955ea095b78f7a9d775694c296f2d48ddd43e51eb78d9711a951806550d62fe0718ba8664367d0804c89c59a8dfef78d2c3239e88461fc629ab91bb8a2688824a6b072e1ed10ff6f39ae6b364ddee468efb82a545df178d5f0904592c3494a9fdbeaec1c74865fd253032e68ae59a9123b32711b414fb69e0fb91a5043a2b36e5d4095076d0f50df5257ef58d4f44924bea9c1d3a79f9d5b973d3359ff0bfcb101ecc7fd0cc2b6435ad7c75e8769723b55a29af5bcab2bc698ff75ef8dbefe119fdbf1c3c67f35c1da7bf773ca632056fd620580ed3a169acf194bf40dc591762921f6f91c4e7a3d7c06565918fca54e4da86b666269dca83266d454327263a494e8b5b63fde1a67050417a8cb75f0aebb2e614253f1df7f81b5905d1cc5ed3176081f4e82297c846dc9cc4f9f21f9573bdce3444d4e58fc267069df1e84018a4acb7b290f2402d1bf6395d20f48c785d954d2e3319c03f4e353f796c19766cf1ea0fb9af3017828788564d153e42685ebb0e88a1f5bc5399167e8ad7d9c11aba92a80aab62dfb581184b31c648fb67f21b98cd8f8e6330bdb353cdb08b336206a685fac84b6d8f62ee8e3453bf882fef6389a20bae330b8be5171ad1ebf7db61a539e0a34b7f4ca567ff8377eb02e2c023eeff2006df212a536a15cc82a0fbf2c506b498ccc186df0179b2c75b6eaf631ccfeb903bfda2625adf97a2192a99bd4a093a291fa36af4b117436671393dcb183e8ca660695d7818565e69867ef4e74c10d08434dbb286a50e070c92d46d22a37ed9f888f9cf5893ea8e3a76fbe74781e3a77b1b34b036891189fa91b30e2d4c3a04efbad0ce3f4fd8b8265f7eefb12e07fb8921378e1f07f71515363795f63dd21c2cdea97465c86e4b77d6f8ceb0c62e4b7bc9334394b722e82fcc87297540c99c5d7aa381d71ebfee26bd47f026ef2df6aafb2666406dc7ef1d179802946552bdbe4243e381971ffc4571a13719d64c426fe55b5ede1d113e38a3b384c136b0ceb9dd1a4e4b5e34626153bea997914da0a1ee70393623c91f6315bd29e588a6975932d0e6f6c2e40634aee3328d04bf5638cd5ac8f892bafe5617f527041a16cce1083cd9c706edc9ea6f33f16e62ed510651274765836418c8b14b7f4dde9bee9adea800aa94cce3919f80f13d35273043c599e3b8cd08b5a99fd52e7c3e929e20f9bc5ab03e0c8f9766b0a444ae4c9a20d98aab23deaf868ce2f61953e64dda5751a066fe994211bceaeef1474c13b0427f0e3eb2dd5ffa0928360c4959aec72c591863f0dcc4be1bd32d22d729e0f14d397301c94d145573664b6ed0682dd75ebaf8aae2e3293d81e6c25a2858fa249b89de6eefc082ffff12fa90ca0ad7fa214a9593a492e7d2f610daecb58ebb309cb24325610d8048ba022790a023f4a147e8283f6f35e35f522af3e7d6318ad3e76bb0b034d919e38f31ac81d57c67bb1bf0156aec4899662bb8b3fb1ae2f44652de16decdc0107942c7ae653097b9022933ef602ae46ed5155a0ab089e6e53191cd1ea1c03652137d26bd9a6dc5dabfe70a31a632fd2dbe7f3282f84535d1c7d4d9df89bdc6291b4eeed445698891909dca302e1ade7732bd9189a37d784537ed632e1c4de203077811c57d0f1c8b8e0324d98908543628be3b471aa9b2839e6a54174e5687ccdf500afe591ae0755b02b3bb470f4bf57c0759fcbc7e720a4df10fccc67fa19b2a78223e76b5873bf68b0aa4243ad450d7663fae83c9a5447d23592522b47966f2099ce9b09ecbb95a4f0b22bedafeb626222002793c4e5d315c014e6db457a6c70e99c3742d2d24e9c461e8948528656b14ea09cd4f0d162242e94363d344f6c36c59f2b39ea1315e1ecc265cfb773614f902d9f3b67bcab5343d559a3dfb42d74ca50026600cfb01e02e52ca5cd96f3ae7972591d8c11b4d9ae8914802c4272674714436c5c26192599618168de823380c94dcbc73181b02b5dbd6943bef9f7f156c446283ecb6166ae38a040e5e23141b6d128f75ab55adc6ccaa636278bd6b194b785096c53869f8e9c2b1872125dd20f8c113c3f6ccc261c0f03166d59638f4e1b17991a439db14e62aede069525cf1c62203e65224553235c1766aca9dac54658bbb00cb2319a05759e802ce3c719576bff5a3708b1f2be7d32518a21239ef5a58d58a4b46672f5c568f98f36e0a591b932dbd1ee6198b6958e01dd87627057f8d29615334781b09acd69fcab37754c91d8945ac5be347a70da3ece5eb2eb4d8e53ef77a4330da1ec36c53cf5c8be95882fc9b8f84a302bc89f65d3f49675defdf9353c536d29b731c289304bb48296e60eb0be2db16ab4f8777fb3bda44ffc51ab5ed346a2ea53a5a01de732415cbb1b192e533b79cd012c5d84194df948c757cd1fc8c26ff9192828a2c4bd6b3bbd1c27b23c6aa94bb6e61e254c8f4a39280b22b7a03ba14b1c36b9ff4824e14e29ee14c6c7d87dbdebd5d2bd3866411ec424e0dd212009ba3e3ac264d81bf173ca8e76ed9a78eef595e21954f83cf1ee7adbbc5a8685be455a1a9f86368101f89421c0d585b4817f84e9511f155e2784dfe5063630f0016b430f443d69edf8deab89fe3921f9fa3082da104d33c76fcccf3037233ca3caa2fe3a4af59bf8a7684f324e2116da95717105aead2d794108a342f08945853d9268e6f10103de832c3a974a2ae4d7e2854c1514be503ac0be69ea5b49d293fe05198012a3fe4fd70d78f3209911cec223b2b8848ebc258c6fc5c3e9a3b663caf4856745aaff4dbfffad01243177c718a45d81dee32bcd138becc0f2f914074fc5e8f647f7cff759306cef52321c3987494ed44acca3091a2f621e74a2b976a204c0a8c9c399a1ac8847f5d961cc0faf619237bf80a6ad948e5599a53b49b7d0c7dc5f0210cd8e0198d56c2eee438b859cdcfcfbba197ae5849e720251d2876b01163a48cc8f8b20534caf4b7982b83fdfa1c58a3ea7e22a5ab1413e520efb0920ee40020efcea9e3cb4228ea11c758aec6f328d28b0166ae6bdabfccd9e8354e6d44ecae6d9f9892160928c6e05339218237eacb9b512529e5742c080a83668e395dd9fbfe51aedbbe3872dd4c1efbcf945f14c66f27f1a00152af705351ba9e32c4c7663efc7bb95e8fd05d530dba63d03575980e2df6d83ab94216344919cea5164dc312c5b7f89d45460530d3b3376798d2d012444892b8d0defd8ca006c4e4004bb494c0a0b2c94a68cf9860c30d5044425b63a876e0dd77ae4b82470b7ac802654fc59e1b44ff1bae3ad5a5c3bc8fcecba5fa981cb6673c9c856df0d8ecfedab463add9a2dc3e110571fdeef87f85584c614fd98d637b2bde25a8ef84fa0c9fc9d0a343f2a7b7390c835d24e3510748f503bb23c5f215d9d7b4de6a061e33ce1f2b333d2bac68bf999cf40deaa37c39edbbc382de853b3b1cb55e6a5f9de8929366f75b5d7115a7bda4e73e8bb53e695eccf5f81792a4f2eddb1fec172bee9aaf3f651b26362032c380e2c550479c7507cf89a4ef28790568c961213c732687cb858be53c33e8a0b9e4cc3f396e34ddcded2b729bda39afb899ed1724838fc0150333e2871cb62ef91c929d547f89a032c5db89c386d4ae0255e5ab597fdcee870c10f8d01fb232570c5c06eb668b8445e8e91724b135a9dec8b5155402ba9170feb4970faf4fa89a3c1dc5ed2dfee240483db1235e400ee7af7c10ac6de59069a5362c47385a1b6d61dbaa2ce4573bede70db9f0b16bf445d33691056587b84432b3a2d832e45f88e81f209fe1f31c04af2fcf5f49408a718e43f6602badf359c69f63a84d819bdcae3d58dbd705ef14cd15fc6b3413a95e1d867bf2ec19c2dd805837b0d31595bb04d2d63304977a404cefed716ec46a6475248e614b05eebf389b0e2457ed3e9863ab3cfbb7152a037c4651e5107fe35a9e41efea03a19a59dcd91e2618ae6d06f4c039d4b4eb385f47088d60d40f49ac9544ab0b6cdb6afc57605dd09f407b6f6524f68adc5d3446eed7d98b9412ccb8432100ff95a9ee5467acfde65b4635455b28b47d9a5900b34e9a5e6ad2e9d394de0a53e4388a7df61920b47826b1232631b6920e8f89e7e7a4f0fc070da65f42ca00b0ea32524855960620cdc0102d842516b37ba9b91a8012493c1e4f6e9c5ec8aa891e3d18c23b265e6cc57720ebfa1011a4f040e71bf08e540dff41f23988229d2cb8b1fda879a3ac346956ba480f51c94609688cfd46923876e6c0e3aa9b74efd64f4c2a24b6744531a9999592f05ee7523039a88b6e057144fdc2231308c495850b1bff9db8b68722253c774570fc11bcae738673e610a5a6b57fdb0451ab9e7bb30b029b0850360ed3cc13ef28e5656bc76412327e5e942e1d085e0e41e50f4f69559de376110a991ac897359bda69670adf11bc333ca459094244f301ed1e1fee42f2f3079f117c4ae185a9c14acae4ddf89f40f04f27f107588a1e8733f3f71d93c7a7d8e2ee97ab7a8ffc3d90475d68bd42bd294276f05798c5d33f3869fa1ecac9c2c3dce5bbf1a06f829b8e38ca26be68c277163b2553ee21f51a20b39364c0b571fc26367faf3c598c9dd4913ffcb5217c55052872c10a89f8c4b6f189d7bde71fbd2e6bbb59bf4ade5e8a087eea26858e8e8af0c8401348005ad941f6c65a80ee433c9da13ee4599ec68e1ed975a1186d45ff05ca3b3f08ac06697007b0ccf157452c3e67dbbcd39dd5a3a6b1d069b3267637fb31518b02ffde5ddffee8a230d7e7933a48a45491bbfa15254ac890b06b3286476494b8b7897601b3300f917e7abd2232a9cae95d1d618880bf7a026d4432cceacbfb9e032159c4b359404fe34db0293f2220cbe6860f89314508f83ea2a22967785c37b650f1509f5fb078f8442a163760e53af557fe9892e09206109af35718a5eb39ac4b8fa942d6783dd86cbc7275b35bd7d55d84f4dbd68a6025b523e047ab7459d4d3b5bdac5eccd4716ac354e0cbc5039bbf4f547da7c639e39c058ea0ce81020335be046a278417d57f7154f597ac4c69c1a3366854fbe4526b26116925a1fa61a04ff778279c242b185b620925b9f2ad9404eafc2b3308ef50202b4dd7404c9189b61c4ab441dd0933d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
