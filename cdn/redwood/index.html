<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ad288394946c7bb6c3cddb278c42edbaf962c2d34d2484bc7de7a9b05d6825198966f73d09cd60b35973a10b9ba3a4bfbaeb3d9dc195a22e03e97de21e725ebf58dda70f3e1f5a1ab747b846c82e5f40608be9460d0c76102891e6dd1282c0059064807a63fb6e64f2e170b1133b9cf33988d01863cf1ecd7f91202e2413180c31c32a67a93053625d0c9682fa1a3da34e5a717ab40203ef2014bd2c5f62930823bc9f59f4affe05350aee08852001c689757993a27c23a24f789b03be023dfa8eb38a9712ea0e713d6f1b8b13c984587196e9c539419346a1b243f41953bfa92efd6a8d3afb9dbf12158c8de5c2f0baa406040e3a8a33be70c56c706c144172d66e6eebfdf4f56e375636bc84baeae7b910abd3501331312ced804ba29963897d4be780cce5e689f021d98215c1576d8755fc1875d62bbbd035787f6ddcb518b11b6e40f7a93082e4c8b180276342b75cd9bccdd4b52200e6a2b8d8a692eac2ce6c059aac0cd0b3b0dadece67761f13c16f7dfd97b9650242ccf01fde55cef4d92b9bb047f06eec914a9c0b4392f8b13eadf38f3b27c900dc400ad477a261a2a441196603a1c7cedb42e96b8b51e1b7a64400168d3e98287e89b662d9fbd780db2cda36fca97d2622f0eb6638a5cef4569e9334ae4271109debfca4fcddbeec137090045b9f76f53648e6f40a0cecae2812dd9263c4a7fa3d5c4d96ca62fe056bc1d810efa0fbe5d3216e7a9f117dcaeecec27b8e7e6aea7b6f955134b4f518bee534933bf8bb0ed85dad141cb0d29e17f08b8f460425f06e583ae95255f9ca73690af8505543acbbbda993ac44d3c22656bcdf693ff58c165b3c48ec3354ad31ba3dfcc53b138c96a21f2c7a79fd4683471c5d89f5f0129201178917fd2006cc27e02ea80bb3e34c7c011eb86d69db6d3fee3961201cd1c6f9f16c53791b34031ca815104e8ff4675ca94da2fd148160a9a09cc9296c434f9da64d759a7d0076a5114bc212fe663b078e66d42ce8e2a6972293c2d123813b3447693d970f94b18c24245ae887e6cc169d04cc92c2e9c1f5977e6eec9cabb648cffe59fb05bff5061693335aa4f72c71e62ce7449ab30e4c91de41f694ff850e17777561333d05ccada1bcfba1907b2bee9fd24ea01f5cbf2982b86084305b24dda80f7f8b7d39c70bc3b22711804d3f0a374b88ddcbd2f348781cde96d98558ed9af0466990541090a5955786e885244de4060194919fd9ed77be1e4d8444a24f836537c0fc7e23d3112a9a5c6c79f5b1fd994cc4012f97afd0afcd226ea44f0e08f90191dd0ed521784115896ce480204e67a23e9904877bd2d40c74438076764ef8aa09f4d0f4f3bae62616a3835fd5917b6e114853dfd74f4b6510ab86bcb601377b616d38d6d2ca6244345229ee4e30aa62197b1cbfea632ef9c206f4ab9e8bb18ddba6dae8d72ee5a1c30a205a55bf297875a3ce2295195f3e2c892564a867ae7880f7b2a8420fff08eece26caf09be432e4ee45910ef3401f8c559b893808dc91558509609e5b5276e26648698fc48e99756d842afa9512b2e465043c0194e6ca8ca2389dcad39678de030503d9bcd93dee59b91d28f203ae8ea87fe581e57904d508e8bb081e8d01390885f05f59083db2fc0afe06d77dafb6f069bbcbb3979ef055f5d7d9a382f80fa1975894f1dc1bfd34e8457ff4b24c80bf39761d5dc7dcb2489651a076875070ae53097bc52fa779068733a8e0ceebbc5b25c5b9457a0d341a168feaa149953d792284e01738da89295909843569484fdf91e71d3ec3fd6eb8ced27ece07c425ed7aac54344b3fefea99efc8f583fb8c9a38532a2665f2c53d32ae22c49180cbab1f49fd5440f708d88441b0c65bad67fc3a483db93d5b1e33af65314bb6cae97131f6b38ad09dba29d952e744cabc9627a36d05d8d0974a1ec14907fe09a12753bc863a3c24e6a6f2015401657f73b9bd8653fd9ba199d1aa5db93bba19a2dabdc714798b0e24d07f1f1cd137716044a28b5f5f680fee8dc13419d1d31019b347f87c6afa84bbfd1ab43b0adf980fbc7bb9862b7b0b6899c34a8bace8ea71d8af7b138b0f0bf99f562f596e8272049f106cdf8021ecb6665841c2724fb72d23e337254d59a4a29eed50c5e46f125301754c2bf56920045add353f568adce6a874a00b36f4ae6b121acc8f3cb1c7a2a5ad18a7e2dd81647ec9d906d896c1d21afd7e0d45fea4f14f4ebc68be00f6b387a796104273f628c53c38b4a7d784cecf93f145dcbb0726829e2dcd5ac3cd96b711cc714e0c689c236845d45af734829f2907cd73cd9be7f88bc0b02c61bc750ca1a096efbe18dff86013cba2bdec6615e0d3c47bdf3724badac9acce8da3aa311d4951663b5b7ccedc11e2d9311edefeb9135bf205c6716a287fecf704b5253e83816148f0d1f4ca50a74eb817374da4a8cfad96db3b6d9681e4e2986633a2c9743e685c3cd6e94e0ea82b2c0962823aa3a9e332f90ae1d8b6e691b7188f8382aa86f5255b5b2bb6da1928d6b0fd0b2b57851db174fda221697ec0bb2694054a835bc0eb5ee1bf08c43a59b69cac309936528d56ca85c816b56985268c51f0d367e1dcd3b54fcefcc729bd8f38aae57aac38481e844c6bfadb0adc1a89e4b9148b70f8c1fc4f15bb8b031e789a32ee4837af783999496ab9a7a0e9c6075d291628d006b2d0be0a2509ab88ee09e5c57d056d10dcc0e758298b4eec7ff36ef66c553f7043030554be05210204a6984e5d4e6d79d90fb0253e414fc1d2c37778f684d2c538b5c82508830926e8df852d59391330ffbb074461e79fba90d3c28f25fa921de74330f8a264e654ac603114c3742c1d80290e10cf8a757e4c6a26f6d88ad5cc4f578841e6115671c357d750e029678476053b119051938aec18a3bb3afcb3b652725add9a611cb7eeaa2d8c672a5757d4e0a17616ac86ab4f456ba9cb13a6805816f3af476e0746e168379a2654f36496f1a4481ae8b704f6b20467417341b0a738cdabdb9669bf5f763a6afca11e3bb5beddbfabfad1881344831f594ab8f756f8e3b4e2c4b51bceb92c223dfdf2e7b0058ad659e09bcab5cb62cdee0404c4b4f1f639c4a60015b52ac464ec7061ac50bf81629d8ed6b256d7cc393e39a426aa502597b1eb1909151949bd2e05cde8fc3a0a5262bd29a591f71afbca84fff53894e4011009289f34d396799ad3c91c01fcaf99a95dcd6465cf556d9fd7bb37e878436e04bc30a34fc88cc2efbef561ff06849491fe5bbb83863cc4749b2193ec58d14024f5f744590765c707f2cbb162ace88e6105f952f4fa416e51cbe7c8bd6b74c3fa702fe3049dfc1e269ad9a54ac788a4d88c80b3879beb7b4207ffdd558cd43615d30feb350b46d5d5c69b987a71018960755bf305fbb7bb4a942af241b64b335fffd7166e8f23fc906624b59bfa36f880bd76b1f0b2d78b240309c33fcbe0de72cfbb899946a258493610aca4aa358328dd3ae64a9f755b3ed1a614c369af54ce40a6f4a49a6ec5dd27bc9b722abfb76e4f5a1a856346da6cf94104227b25030b5c8198dbeaf28ac97118d0b50bf2387b7bf3a3bf90adda62e003080bcfd3634e59c814b42039cbac72bde58e68458f172ba20bb1ebaa68a1f7ad994a6d3d92414971be4200c8829bf23f6b923278e32b484aadcadeefd4c646d2e0004ba12450872c413ad1aa82b121959b62a9350470b440b51cc1c5fee54aff426e6ba13ed576cfd51fbf459c85a8b1784296480bf91da65ba4ee3d241f318bdc1c5826a15c38fcf7c06b029de4519b771681459f6290c9c501e025dd51257c37d550f3a59ed89f9027332f39c9e299b4936652257b74ef93dc4f59a7747183606e692b92129289fbac714d7083a6976e95f3bc103dc22224c05ce390576beb2a972646d7c6090d77b435ace005be7f6ba8afa6de664c916669b8e0949f540496a35645f4afd1c7b9e6137e0af5780f1d25f6228cc4d47f0e88023771a3cac342338d7a7f1989c25b5120db28b1cfa34ad8c7940fb40daf6d311c3ead7ee752a5122d81a807cbcc151072b5c4e60d656a64d6ae7d42627ae9d6657795271ba12f802115b9baef2977acdb724a846a5b9e53beba31198456612b15a3575ad1e475acc4dba53f5cb73544f4f18c86c450f9138fd15cd99cbdcbe35306df7ec50bfef6fd555e0f4ae9dd43473bbdd5ff691805240c296e4a9dc096c547ff775f84ecf94fef61187901ea172bdd2be73f3d70d8b51325ed5fdecd0407584b230c25fa7dd05f3a72a1f92bf81d326f193afba4af9f2577005965095dd1a2d58ee17955bcbc0c1cb160b036297f7602995706a7952dd12ac9a9109abe4345957b207f1169826c1e4a3c6792e92abb04e5ecd9178a956202f4c74dc94eb2a3c274a025b03c43b7b858c6489927c644bec6b46b99ceb55b3d0d40e5a50ce941ff44055ac2f2d755d4a6b4d80414ad1867f4d96fb0fb9491dcce362b5e5acf950daecba5f44caf1f1f564a8524e55415083180dd559a20bd2d36abaabede9861ed12cc91526322664c6824f62ca12bd7d7ee4287d0138c6a3b0d79df5d12e8231a0bc73e344792c21fe7faea0efaa402121235d6a93fa6b374ee2605558c5e429d9aa602bd81512710296d72109803dad0c212492eb3b11f287d7aef47fdb02a400be8e9790e615451c47a2e276252d097f6eb7b1952b87963eff2842ca8dff681cc2a9a380f60bc643dbb7594599ee492bc1681d25b2c3499061b4387f0bd4be782a56ef08f8740b2840a81a40026e2289ee5a0849834d386fd6d674d9e35af4dde433d5a648ea4d18cf6f812f41359e54f12ca7990cd560d308da55e3a999bc67341c4147cbc4aced4673a84ab4af3b9fd57f8a4413aed4f619050deb11c77ed4015a6910d837a6a90415be572432fce3bf048a5eb3fbdef234ce7fb182f65a8240f20827754945dbb1d624b93dd1be15022a55389438f4428f5366f7b2bfffe3796ae7f957c96c6c7a4d493ce43ac423922df788fb05394fa9973ca9ff2f3ec10e4c71118c81503ff556426e3bfdb20a99a47c4cb7c408bfa3239c0e8475e1e840a32c75cd72393426939209f8d76cca961a32ce942b1b957a72319a896ff14d02094e23f0dfe792b3c6068627747d86f4031c80cb5147319c63dece4714163719188408b25897f8f750c19841493f861b6f16201438ccb063d12ea959b3d757e30744753dbeb50904dc21b71159a4ce4cfa74059ca14e1455fbf517da732ba196154f498e4b03e1961035ea293e8a154a4033a2de8ee94497305b6b04eed68c5d50204f26230cbfa838c9e13418745ca74b56d272d61b5d6d23e60c5d6b0a0dc2cb437788fa09db7339e63059311f567449cd3126573bb68a88fcc4cf966c7bc89252095317fee66a26fcb9ce93c0cde64efbe9417ce831c66ca4599b005d3cd4b10ad78fb971971c1c72403b2b266743049a65ee76fa909450d1fe9f5dc16b81057debac3012509ebb4282e97ada80bfea8ee500ba918f3273a5d7ede14e82f98061bc85e33c63ad0fdbf789cd596a645781b7d3c63324caf0f57812bed93bd1db75b6a4ca03448a204ecd82821417075db3d9f0f5ed020d5a8063c26fcca6f97604b7180b3b9755e27104d17e2303a54cf0ced874349de3079ba4a19ca0c1d1c307ac7b59c93c253f03ed97537f06a3c7e3c62b00e4539e670ccfc377ba02cfa423c940a8baecf96d4cd6d9a6af47bf982374fc9fa25fdab5b4c28b6b961cec665e174004a9f9f69967ee5fab8114453340ec1c2142e10066fa30b2a368bbc783a7d0efa85c0f4e42376dec5659e3543a5d5387012f56446e2efe994980ef6a088b54f32390ba74722c78c8b56d88b33aa6a54a754664725e42c0732655c229e2b684dc75e84f5693c65e674e566db33568952dc4e6ddd3efb3a3a0a669998210f7c9626d28267e95fb4df87e4132b55281b7e2222819d84c337b6f100e9d00cc1b994ec2d1a519d34a183f0367e6cbf578e94e2ed1b5799d5a0ec2d47ccd1b47bdcde8f9e8f7b9db2d435f9995a5aaab207b6328d94bd5faa1e647cffd239d6b62f49950a5a3946c6fb112901987134d97e52c047b1d6a2e75d8960199de65c95f047069cded48b9919c8bcaab24a8348fcb2aea843c932972ab6787d0e8a36d33ccd3a5a6a0db427e38ba17f2edb4e0d2a5a32ab0bd477511541dd3ec4bae377893f93d5ff0511c44bccc470e9533d158394ae0d9bcb5f6671ef9d40f0390915fcb9dc172b9b9f39c45f40163c69e7aa4ea12d5b929eee645266a21e0f7f22adc55909e09a55a9edf3b1e632efaaf3221d5639093ae7600a2eb45719a47531637c4ba7826e897db86e08356187a94e3eb258d388fb596c0424efac7ee901085ba85e18c62b8d94561cca36efcd580b2de413bc8a7c2c7b723b7c1b18ebd0c826ab3091e1a949b7ec94ded5fc0f8cdc4256f11645a2679d4018d77ca25a98e521e29e08d268001e50f1bf0cb595b5f7fcd4c4184230cdaed7508d2a5537d1df78d63affc28eaa7735917658ea5bda145c73e3db5f63db746357127892bc3e7928bee992ba2e4ae9b61296ab563d2fcb791dcacae3b72295d66b0c18fbdfd4d3435902ecd3d818f0d9069c26a2c9e349e8203ab68a86aa7c1460ec2443b313cb218bb23cfd75defcbdb4e29ba0de1f9a4af6a2ad362dd2357e96a57a1e29c212e55217f4b1dec03f6ef448b0bfd2dee3515d6dbf2de9209542d4007294a71420c92246842589c612ee3c09d153aa2ef35cfbda5b72fd96d06c1ea675003aead712a22a70e25106dcdcc1ba001fea50cf24723eb8acbc9fabc99d2608b00a279471372bae230c89550586fa5a31ab8bb622b176a8ab298a53f7c5157122b0b25eb272b4ab37fc2e3ee46f545519d60403b0de3d0dadc781e3af8e684a1c6832e6045335bc12afbfc042fb23b673cf8ddf62bcc07ce2f59e12e2bf033e2c6b80e6141e8196c937221ece054fa97109b48869a5d8855d31482399041f93d929190de74b6bfbe2205af1cbfcd76bb6f1dcb4158da1c0fc21e0511cea7bdc609cd505e4a176a3791371c3ae99a646e4b7a04bd1e5b84fae82b9a3ad44db88fd5b737204ded7fed4dc79356942b1f670e88159657c3fcdf7dda65540aac80e169cfeb5172993677efa0b828c5d5b4b1f800388846139847b9b4feaf035ce45cde2793e7ac56c4f7fbc74fa7268fb1b56efb2b70885af13c60cc84e2fb9f8295b2cfe81107728dcf1e6b1ddaf437019c3603e316ce97e49cc40f1f07545428be1e4ea046e715d2f63bb52799deb8d54fad86d7dbe1acd53b03542f14beae03f76bf19c3781d32f50b3f9f47d908a36267bb3930c81f5b4f2d7cde0efd93c5ab3a31393ce2fd239e76b9d0c1305343b5b312c1b01b5634e2861b6f1193f6b51a00b017662d5ce74cb8694c317f2f15639afebf476c1d7a4e1429497b2ba79f3b8e53ab6139bccce5bd83e7bd7ab8f61621d1a2931a2227da658df4695abcb44512248ffd963ab9220bd9ecfa3403354117c2915eeb54f8ef529377985706a3ef019149524d604cb4c80051bb75a4e913609cdb06e61372e487e3a425234c4de05c59c060598e68b8c97ddd78a8a712a9c31fd9b25866369adf340588c3885e08b84cf6f32b603e2335b854526f935ed93b38102e2be408d0b11e448cf73e77eed8b6120f9595a84a7495e2b05db17a30f90cbe31fac9f7e22ae60b3fbca06755001e71e84f0918d250b5c46e1b69512b6fc4532b0ca4f178d8f8a670a3ab187c7abffe5bee1ae9450fd4870324eb6b8ee2b6192b909f7a19aa1064265366555af99b805b49a6c0942656fa4d05b470fb6da51d7725b663724ca8799cb96b1a10e4797a2359983745bae58e842d1831a19718d481b0bf23beb7f4393bcdd87b0985dd7c316a30597656a97556a005bf2488030cb922e4616db7fd31506a7279b461f54d83daeec67ef120b79a746fe12942b199d33f9d6e83eccaab9bb1ef9f108ebe6c33ca14ac6044c44c9d9c85a8382d0caa8a83a78bf44ca8712e01638a21c4631876bdc19560f07d2021bd78e72fe52263599e069f643d5555a53d6334ce44da42cc9c1ae862dbba9d2a239b0519ebb8776aa7ce0c983cc10ecc470bedf1405fc81a04fb0ffb94b4b353e86b69fa4b465403b7c435502fec800761e1ddf1d5f6912ea4f8455535e064ca0a28a26fd10a905378a20c8f049bead5cf0d113e4d5aecf950b351aa80173b59ba6616ffcfd54fd1ca713d1056cd41636166054ad7a00045817c1054e01597eef23512990ee5e3c30f9f9e3b542a8adb0bbb1d58c1ff7cf7f02d27e5f53b89d3f43af1ad20a1cca44d93f10cc21235472cc6578ec21ca904b5a4479788892df505c2566dbae8fb91e6548012bb79e3f0e82a07f34f9c044b94e5ff6bace853260f3ffc897d8c7d42146a3ade64771325cfcaccedc4c068c23108aec0956c24f0cfbc12443a47ac159dee0d9b2832361b90a7ee49ec71e45331b738b3a035e605a9daa18963ff5c2bd8703f344074381bfd3c1bd84fbb15a9436a1f1c48baef6e947c01e739567f69276a4a558b4b3e298919139f9576fb6fe0105ba71c5e8d566ca9f4e38184fc52d7f3be06da61e7cc35b916a1500d2d3aa89775bc95aecd58151196ca85c62e411cabe28807d0f91df0ee3d82f6dd55aa5d83aeaf82ee51383ec96811c8ef91be0332ad09268df1597610bc6519c1d8c4f98d91ca09e923d220b022cf76e3388e6ad2d0985351023c47fa9094c40550ade120443640b4c21d5cbf35bfc03f69b16bb44b8829ace3e0275a077339720395eb05b3baeb9e209f03e4923dfbebc91d1e26516bdb083c73005d3bfd945c86de85c4738fbc53c395b38177e326b2007d35ae4037876b91dd2e53edf0b6908f4ba1acce5460ad5923047c3c43ca0d3fc6b58dfec3644b2d2022b7118cee72395ec5ad9d99be6bcecc3f372a92e24eee37e788e1dd9081da88914f281e3668b6c29c47352e6c4afda992e62c043125ed5772eb90b78dfaf38326266169dd4b87899815788e9947ce2a11fb61dd30a2fb5387d5664bd58f4b064bce8b80b2f378491ff353fd72900a93fb2fddd8fd96116d32f2eae38dd3d38a07e442d2d0c0b86134407e13929e071813382602348bb26e23f6412a2dcf53ebb9bf6a08ef41672be9224e566c2ae596004d8d950a0b915d58297c03a30f5718b7b34402367ae7725339dca52acb4b19d0b63cb43411f10e7faa7445ef59bc99489a9ecae0240d79adf1a71719643cf04a83032d31206e81fc9552e275d0f89ffe6363df6eef0380b251a57f19396cb52d2639791baf996693dfc9b2b7a165721f34ec4b0f50e227b632ed3684c18a8cb71e3175bbbdaf887fe45be140313417197463dc2fed01fa26594d9ea0c6f782ffcdf68837f4298f65a31b6fbaf42cb8039117337ee154faab7b40c1b147324c6e35f1667b4095cb188f6e604ac47b4b1cf784b09795b35dc2c1d578c8c5f3e33370cb3095ad6627518911c3a570df557f00776f90e1554f7d15f8294d9bf26b829098b703ebd04f97351c2d46fdc7023d22abf9fca6999c781af095793e261b48723ad9466be9247ae8677d199f71bb0fd85d4e3f32aad4c576cd122684ef03ae8f4b4a653a349f23a81b372377603e0fecc2478f8ec4aa47709b1dceeeacdd3e6038272c7cae2a9d0c9adae8397abe72ebaefb0edbe8fec2fa01a8677e36d4572804ebee3d0bb4642d755e4b4afbf4589548ca44145794f3b7cee5e68f2a7153b5f1c986cc98be5a4aa693743e5088486be42759d6289d822f935749525979251604f290315010bdc4bba3306f7a5a45d85e8ccceba7b668ecafd07f463f460aa17a8d10cac010bb44fcac77f6cdcef98ec5c2eeecc200848485cbf64a7ad79f3b71879f34110517c3a888c3a90e3258ba5ff7bd8b942309ed8a633e55acc7abc870f64465f0114ec4566d168a00b924765d3dea754fdccd2d1831613fae438eadf852f84321af5c7399d8d4f61f3c3b1f8bf4953f651cc355b5952b02b5b97289aaaf3f553a7d34c1627d069d222e79d2b8429538d13492857395cc776c67f5eb57028cc2af8a0a9488de63d1314d816f98595ad21bf48bddfc2cd1be15db6c182808864bd63cfc0617f0e05dba2b2a0d0bcd7766990b9d0dbcd84227263941492416334ff9e948d7dc3fac14114427aa5154884d0df63a3ae1a7189b759539e758e6fe3e729688481ab86f854cd782d9a2316216bf0b45930865761f1e122d6ea80bb30040829225c69f66d9582255202ce9052095423bba930c80025e3cd446b1bf629148c41e13682b2679e2b14b1ebc61d6a054cccdc093abb33b62e6dda26b4ccbb5682c81ed62b77dd2d8cf391fef1a5b9efc7ea7dd40c6680a2916fec2f2229e6920446cbfda44ca951fd108c99a614554ffad6bc9e676260cb8eb7d6e9816c463828cff6b0bd094fd34d7b8238030a5a90bf2c584a94388da31bb182c35e3f00db80aedf3afbc785959378880e1343b6decf2dc467d7eace31b652ff65c875757ae610379884792472a2b274d64616877450ad698a3ef2da73adf9acc51b06b48a25a0572b7689774e1412267f777caa5ea36529afbd43435caa4892815873d0b016e803c94009b6c5a480612054206d3eb2540b00f910b72be1f4c78d713c41e65b31c024e2e6cf7da56613bf2721431b65562e5aedf02adbeaf4a0a21492105960899f29480927ccb47fe5ce2d0bc26b511b9337ba3b1eccb60e62afd1af72642dde7586c246cae4008f1eeb60bf66c4684a09aedda577638af4de95c2e998d42ed9b95f0f3f947e96753e9292fff7ca0b531871b4731680100d7240b4de31171713da98622fe503d9cc69db3768722ce7274649ef33034dd0d0f099feb670deb749a6c192a3cce545289d88a6f47c526114e1b06954813e70508df13aacf33590c4c9367b590eb4931644fe739a9f891819fba6e6be767ec490715962af683f5e2c092e3f8d37351111c4a1a35749df9657db488b70ca2d6197a8148d3fbc9321d56a36dfcaab25a2b48e309d0c86c06b3b6c1259875f2a7bcdc088a27911f84f5d83c3e72e5c9ee8ada4772b4e5eca1fe0a1c1f0bb90b0061d31cb3c8122678a19435cdd693831737df5344706bf6970cec09110484380feb3fb0080ef39982b219f12a51089576a1a471cd5b9e065e33155fcb9960f4303dc0283b28053a82941b8e20608201b94eb799284b2fdf24dc66ff21c98a28fca07d73d5b5173e673c6f6b169db2c24bb064a6d846a2a3e7d97592a34052b9c8d03bdc61295bfce9ff60fe2a4a6a7ba81a435ef441ae738c60f24eafba2e4231056d23cb4e3d7ba5f64916b9f57fdc8c32c8c5ed88e4007adccaa6278f0d620c00b7a57185912bfd4f80a6fd037f3f59a511a0d4622e8d939d37c41f32bfcd955b7489a1860f6c3d9da6c55f8e761e53591a541b2441ec7950efca246ef8c951b1c3fd0b20ccbfaa2a205b6e4c87c494f71f0266ec63d8f6be19c8e57ad50327b2ae43ab1cb2952463f6e65e28fe417f5f0287444990ad0172d99a409cbbf8f86cf1428d28eb2df1682d88762e353d83d24d6884213040ac855570e6e0b7316561510fd805467c5ff1d12601334489d7a8017f2cb7e86765d97e1b7b6e3199210037314ceb9e6cd95facec5d675478fac0e47fcd2b247c3e93c02e6b72dc20a9bad96fc23e138cc3edb6221ebd964f6bfa60b3ddfbcc5c2b3982bd9c85c3c385d18929962c2ea4ea225e0384197e5628bf3d840893f0166d254dfb7d16143d351fef743c8f5ea2e4c941cc1e7738c6f6dd7f80a4e7d175922d34fcd28cfc5e6582735f1845073a50e640327e7d9b30fc77d73e7bd6b2c53881fe93f60678330afa4e7b4163d82673c1068187938db3a4e93dbc8d0cddd1ecf72e6ed6dcd314345d602e73f390eb702f7e5efa84fcf1d187dd87029cca015214f9bc17adf3bbdfc1e6a8c26152ddc75a74637d05eb65588198bf3d3be06829f15901f579c0e010e4c0f996851a715b79e5dbb90bb7db00693982fa706dbf0eea55ce6f9a0c5bf186d3c335a47f146c0de18965cacdb2fd9bb549fd8e1ae978643d318eb09a2b26e6fe8335edd36eae29e3af9c9a8a90ec1fe87c5e32b6b06561fce253d6e93507fc3b4d89d1acb8e22aff285d731c1332bad7f029c48cce2b35c445527d6fb08cd95d163d967faa3c2913572da36063cd2b0aded3ad2daebd00b70183db46f84514235a1938b19e974860a2bf6dd530460d5dbb935e3b818d917f8bec91824bf513d1f3ae1a99a0d0b479b75a9e7c57dca8bc2753252b1ac669e0ff3e84fa556b61fbe83c1060edaff15b72625c65ec79396ff66c1f3db82891a852c61a151593133de4f4c93ef1f3e57648756095589a2cbad150530365959a4fb1b7fa987486ea17e9a1060180708d978dfc7c2973cd8e062ed69511474c0e5f73edc543a7567711170fa25f58a68c7b58da144fe2886640de2d89c6aa30b25c87f8f0d0b2ac293398009c256be0f1000ab532dab5804611edab10c6f9eeebc1dbae34579830c0b81b2426de288fc26c258d5f909532b5a2dc3f9058af2ca11c5479e942137f61fd95298610b979190665cd5156c85aab1ace6900871d5fd1bf6b7ef294e1bd5893140bf278f3f1f0e653f5d5314eacdb4a477cb8054ba9f392ea836c59fb731a6f3b0179a38c5d69638d70e8062b3e5b1abe58e53a896970c4272788f22cf31f383d27f198c04f4f2d227137e2de72e87a69e6e88b5380d2dfd52a04cc0de893fc5c3d748abf80c3ebcb30ade2da6747035b394276f4cdda06387296478c0ed3a7eb4e17f5559a9cdc866718548d1a4f28fb5ef835d62b3872c39ed2de172ce8c6b17ae070a47b7671952a6696fc2c683ed627045ab12da8c3930e1d633fafdb12abacb6868a97e2e09cd67152aad4a0770b547a20b4de15564da807b79005d5512ff04306cfa0c5b7c0f53bbcc52d4f79f596ba3b804fea5d492f250748dd3dc760cb51889f6e4ad9cc26ea90dc5e6a9f24875cd0d2da29e23d9025470450f22f905148a85d81bbf30468982fd8d9adc4fb644ab6db23f3270c9f06cc438dbd637b6187c86dc284283bd9da253dc0d642268cbe998d78bafd513cbb29f4611a5eccecc0b72a17f4617e775f01bc9b5c39af2f526a01e35631f08ade4b17bc472abfd6246b36279fa3f7330f960620523e2b94357edf8dc5c206f732a1036fb60bc5e5d73d54ae79840bae06b98452bf44edc01806487a90252fef95af573ec05854d83803bcb37357538431baf55f93d25c32b7328a83e3898c4fd2a4c01b939508bb6e5adfcc33e0b1da7b0b0204d4657e20e8b219c55e15d5aee822d8409e27afc49d15de0e51af7af26e6d9dd4e6411438977957c283a547bff2547dbc80b5d3873a92fb048262dc5235d603b0080f5f7c43c6c45856d3d4b9ed1273f426494cf079e8beb6bfc50abead3f4a8357fc30556aba7dde644bf3048bd3bbba44950bcbf9a873c9c0737d6c09f0f8026de587c7923fbad724fa97ba1532af745eb4d9780114dc0de25008dfc2faa2308769c002bf92ffb5f5443c1b4249df079a7d28c166f4b82db842f2029d81570f8e04119cc9fe7b83adffc510ea3d85f5ea9062204bceb560765d59d8bc73e755e16c5498d90320f114112a25e1fe2243e5e5931549cf1cf06d805fe4fcc9f8ac44267651a4ec7c7be8ea1651348537d5749951abda351c1630467b1cd33c8ead4fb1145e6701622e8fd53ca3f8a1b78decaaf0bde2976090c51c3d6699fe2b734a8f5836c85d6a359bdbeb8c497feb5bfc115f24d6fbbf23e052c2a54b221e376caa422b8605839fcd9d08a08679f7ab266745213f16f5cdf6b125884db95206095688e314a47aa47dd4bc989130e862c573f1168038d0bd35c1b59ae5f2e92702103a411f28bb8b97b26a9c2a463f840bca722b38c0643eeab895a3215e5d90d02b906da9f49608e07abc9ebd5cedded6ed0d74873a0be86e946acd40e4a14e8947fe7aa5d50d1608ee98e2a6612007f7800d468e29b1ec2b62aa075f80c5336f60e88c3c5a406d661479ca6309822484816da79b231cd69e161114843a486b225ed39f4495ad769af237b1acbaa3ab5f6108dc961da700a6998849403781ad33bc60614d3a09d7a7c298a3479cce48acc72cd6435a92830c98605851521b69c0bffa447007035a39cab9c830bd7438653ed27e981d79e96b13792cec357d9a14c01830aaf66e24f7eca01169e3c98ce258e9c409219ac904915c94469fdf721513f189325912b013d370deeeaac52df3890d5dccac0b8828a4ef6891bc799a45d32f771d92db9cc616f29d257394b729efb21dedd70573b8a3cc74636fff4c1a01b51d88d2dde63dccffb7dfa0c8ce65e79c3e1754cdc7d5d08d34c9a6615a245a486d743a3cc5726f9aaab8d0311f8d63bed1dc89d916f3b9f317ee9599b5456ec8a95540ce584263934095349311e171760e65b87f497c36ea226e13faf752550f11c88fe26ca721290128cd91bc2d0f727f9959d3a852a5cf723423321789c1031e4b9fb2bcc62ace3194c808749e0e8f8b4e6856bc1cd3c1b2437d754dbc2de64ad09ea6906baa9bd843d0d752487572092d7f629f5729fda90f4593aeef8469f4de5205b115f4e0ba51e44c89dccfd8a11c182cfe3f159dde743d9e6b8c72189a16152ca2e2e7ef1a56546c8bc62c4fa36753740989ebf10c15f68bd31050d1306acea1de38ebe4173025f940f6b39c5cdcf2b8470a9042202ae7f0b12f78b456efe653e3bad929198ec52308087594b21d29e909938c3cdf4963faa924a454fc95b11c5932a1fe666ec46812374687d0f6fe458ce9883941bdad389fb56f8bf737974311883ce6f002322c4083b8ec2a9fcbe4196405f06d1f5b2d8432963e983f9a5c1b4412be439a358eabe5ac5156ffe2f6bdab38ab31b87ca07bb1e9cd79aa61778f1bf72cd2eb94d46d6a6569b4925e70a5083a3187f686ddaf11d3a678e04afb0e64d4f443d27b82ebe5ad56f7ac11547c2b6f6ef7b781e2029cafa7fcfe9c2f2282c3330580b858cd92baa5d7d4ba4facacccd2f8d7961affdee8c1d625370eca813dd10c58446cfe64130d6cdd51aadf7d104b66675b796bd34782cc50a01c4d018823c82d8fade3f9b561e5440a6763ae210f2848204adfc0f7a2e61f2995856261b41bb715973c3e105e90464a02bdc3eef9217a1eb9f0ee7993e74154804fbe35571585efcfd13b4b57346dccc28b7774baeb3bc3c3d5ec5c72f2ae010d168aa87931f5128bba46ced430e3d95f5c08c5fc2e6703b265325ca71449ee3904caf31cee93f542ce52e0b8209e837edd49763de8301662e1ea9e1f319f3019123e265fcba0a9b61efde27ab1e9c7f4d172e2b6a39cb470052fb9751ed1ca89727131369c9137a0b5114254e45703011d0b8ff9192d8fc66d6cd093532701e7fab3d4177c496b8a2058cdac19995838d1b9f4b3678ad0fd021606f0af05582190842f2180cc531307e330de2c2f8aaf27a0b45609c3875bfcf73728d6e1582a8e3f25882b13ca300ec3ca0ebe39adcbf3cba50e6e2d9950003ca5d2cf8986e71fd4c214ebe317f1549bbd8d3291273cc3cfbdeb70f27da4522ebef1b14cf698b609a31e434e4d6c52e3468878a23dc90bfc96902b7645ff099f277b06a6b4ff4b3fa90d896dd02ae0cb4440d16d4586ce86d284b4f2e748f60dd2baccf6b6a23f68cbf38fac89d72790fe77ffe8d1543253407f383b4b170887a1259c2e95d39f9baefd5562e81477bc536292351cb1b7a79d337b91fb09a184c01688cd34e582355b64838eeede8b5b5ab3831a535b298ae42a3a7de6a2a4592ed3b4d3fa7a9c743ba403cc7476a3f36b8b56c789a82ad4f48f667861bd9e1a84b443ce70dac1f235cbcb751a86b19bb542892b8750f1c3fd7b0761f61b20c9b606ddb9435bb3528bc8c1c3d88631929caf9d66f23a357117cf25ba769fae2090362918b2e5cd705a7fccf7f3718ac367ffc081fe9441b112f2b69f9916a131c304b9807feedf84553c81716292b9c42e9efe1d408a8686a03b95b8a4796df758bd145c0631f8fc5a6ee42216d3fdb838d51b85e7661117143631a5e9d12b35d69f919b559fbc79c76ff9e9ddbce5584db5e92422bf0da5ca5a39cf54bb099d4deb29bf92a09344e92abdb609fbda37c71604bb7c3d21cbb6d2e73d155861f81040ede9ed7f62f2a3df10688bbd3fdc7d6a4f461c28095e669a4fccb46be8b8e1b7d555b6288d7f460e59de8b4e0980e5beb48328558ba5dabfed9afbf32e1845566e33ee0f7a508cf0243dff7388f141f664c2db8edf51664629714d8ef5194fddbeaa47cdf6ab3d220170e2934f155f02ea2e4aa58d2e29bf6e479d7585a3c3647650e2948d803436809d7c5b7ab88230febda011213153a47ebe633ee2c8b13b23ddbc9d8d7db79dcb723f46d93589c8544635adda0b66be5d21f86d292351feb5c6af5acb2a700eef264f1a0224f8a5903b90cc35cf5fc4aa1aeb464e5a99ec1c2f1bd2b98372e15b0ab7d223bcf38ba47da71f640277984c8cdcffe2999fcbaf8b88f026c7deaff26eecf315d19a3b6e93ef4f3769029b1e93fc4fa4737cde43a17a004436ebaceebc65e1733e0dc6822947bbfd3853977f4653cd1cb3cedf227c0e9eda33b2e594bca3b8a4d73f2216b76a8edeb30dd1425a7f21ff61226b5acf47f574934e398654c06d7d5ca344ad0bc9321644e603167c74f45c15aab35a286c508847099cd20867ec82a65f6bac938f313a8ae0bb6507ad56761fceb7ecb7ce64f9191caa2d5635c7691a56491f2b3c800c87eff62bc350bfbacc668314e46c573b91b83b288f7d02607e8875f11d5bbb4cb6f38ed67bc0717060c7e3c434a400293c182cd905b0fa8ed78e579ad803d67c37553a189e88e5516c60621b927832397477ba54b0278ee9ea82673b793839bd1fb1929e5f4af742fe02ff9b78bf1163bc2e8e76160f8714f843adcfa14392e2818b64e431b4365dcd20eac4e2b68a635f2f1af169a003403db2dfcd2b35891db08485fc5bf459af1980852c8356b5c0a86c8b85e055379c1b2034184af8c8b26bc5d8562d7db237d02c2b70def7135034fcec42a323645eec621fb9e8e89dd324bd2d5b0ac3bcc1e1582d2701a0ca0cbac7d4b87cb2dee31a4148e9fa00dd48ebeec1202dbd2a79a6c4791cf339b43799f710cf2a6f4e5203477cb3d2e9360763adbccfe71eea3f3e1546d0a91a5ff7c45593a9dcfbe290aea2c3b87fbf01805cff75182e559704ccc5f3f397eccdef0743af16f10b4acfbdf563a5ee96b01bd9152d53026354f64bfd53b1e766ef8789a67c113f25080aa8b73518f5e0963bba34d30bc63e78d7c3208ffcedf3963c6a329ae8cc214011f55e56d9fec76522e8497104789b213285f87684f8ef8a474b64937b5c26fe8f9eed65b4df8a0dd172b177f1dd47262d9fc71afffe2ab0a2a146b4423ee45d1eed9fb05f36f565d7bf01870d82b7be801454aa45cbc86ae28cddb1af983b16eba9473363563b06f282bee68a89079f92d1154b1c00283c7efaa32fd1b905cac93d7314e3517d75568d4af0d702aa08f55267bd1babe04f530f8325dd47d33d23898fefdf04d847aaf8114595b42da384e03b475071529ffd62d89aa8f1f388afa50b6932c9def1300141bab91523a0ccf9d82a434576217be5645a7dff6902374192654314dfbbcd8e445d135b772eb0a2403c437a3df4dc9346287829776e7e00de44691e8d0ef6b5dfba58563ce573c7183075795f5b85c58d96d42da75ed258b3fe3fff82a5e690c1d77101dd183236acaa87ae92f2d741626c495ed6f84116c7097fca72f460f29a3c508b913cdaf3d5de3a730a76a6a6e8d5a6abc47ec89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
