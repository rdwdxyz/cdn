<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c1f40a3fc86bb5712d3d475c891c46079bc9a32ec32c6b65c2154f7ac16a57dd1e4c7609ccffde47032bb06d6376f4c68ec2855a084a6d4d5e6e07fe0a439a03607762aae164c8294f0ffd1da5440b0becfaa063bfc14e13f3e6f7c16ea6dd28dcd23f4ac9a4b212dd6a8927ca57065c547578dc56d7c376d4c47e5b1d096338c4055b941065bc6e7077e4af28fe7d7cbb2a0ec8413396ad5a01d30d2c42953caf817e80a6ea274e01d1e4c9d38f67e951622238e017c87b687a68ac8afd85b5a1b283601780c146b12911dbcb669d28f1a623986de864768e48e76fe19312fb7e31eab17c35282459dd95d5f65b94d67e27aca0b91961490ae1e02be50057e1ea49eacc208dfdea7c864831ab39082d7162012a7724251b0fecb49ee37131124c8e740a82ea4293b0f31f8843877f434c6c6529b20e149d00b589945a218b8053f6ae61dcc6622e8a27000ecff89fad2d8e41ae579e672d77197421d9d06586717c26c346103877a27c02569b42ca44bccdbaac3c4d83cbb521750c0e8badc9653b7bbd8c3fc7beb363ee1c190e3358024fb91d3290e264ba14ad4fc2bde37e2ba861700891f790ddbfde77cffdfc7afecfa8283a9ab9dbb31a539b5d5d4f3f76c852cabada09249de30af1232314f9af3b26925b7b0d271127c68efc808bbdc0bcd92fad5d5b19126399058587ef462e8df4cbf87e38167242773f3aad7b68b8a3edcfb1972d3d72452a7e264ab847adae68745ff28dcdd937dfc0a76cf9cfead111b3cb591e1b08cee6d243d95e36fd687e4f9cf6c446892a73ed5fb6470303377eddd3fd2755c4a12b12150c7ccfc217c09f96a2f908c8fcbd45fbb9783e34c4f5209a359db0802bf6e435998e2655913cb3a85b48642e6c40cd344ff3c78d1c0d9500b2b6cbd9db19a15b1253819f4e2a5381fe2a5ba3863ff463d00d31cb50ba69b66a28cafff4403f51d584e15c6c944cf151ac621d967549e03ea18775ce7074ae285be5bf6c693416e51841b2e70a0a8ada3702eba9b6eeaabc9fef0acfacc020e818a96b54eeeef4dc5a5ec14123ad88301fc27de91e1781dd19e8967c8432c4dcf29e85c180062dbd1ed60a3985b500049304ce50cf11d53e82e5c9118bb291c4edd7d0d7583129b5ba28790ae1b64692573193392141d4fed91b550cd5b350d0301101bc0924a59d66c01bdb47a6d0f16eae3852f25c29e0adcf21d32a68364b5cdeb5507df318fbd047fa515d5d79df350f6a368e13f3684d2c7866ae3bf2d0085dd50f252b5463ed76587095764129255c75428043068b1ce18c91169e4825d4c1f42bca1a746037e95c21a73aedc757b12e0a447cd465a0fed7a811443e72d4ef1d86731ffaa14357aa163e92f9c4bf62cbdeb3615eed29d497340652b5ec045276c9091fc37cf262b0b871c4e99f1dd73401fb1ca4dd5e023c820b3c598c7992b1ed62ed6dd359edb38ee70d430b5e9372fe38373db956c4d2a3d7d7347a95cd1670b70e2ee3d827e8e3080a043b17df237c74818c5c98d3a93b37cca6f76045c3db49d71ccba8fc33f825fe14d4b32700f7ebc56758b3ddfdae9ca2082934b19663843301822c8d5c40797d4a0df0cc5a22673f0eb00220ca4653be46ac89a3c9aa21bad887a4366b6bf8083a71345c7b7488680d319aa8926dcfb636385dfc948e0d0118b7d342798f85ca9c805c8aebf4bf271537e3901de6befff6b65637dfe04dfe426cb7f5e2506537bd3a1d1d1df11aec7eb31daa5800038b63b83a6a2049ba94a199de40be1b2972efd53c5a1d5efc8147df21b3a70ff51d79d0d6fbb1c5d7bf56045fdf6045e4df5df471eddadb4f0b889bfcf9ed4f5979c6d0fec149a153df172234116b29ebb7d99432fde84acae400d86f207eac496fe855cb5aa8bf9933f252bd866fcc69a14c95f117ea0ebae7db62bc9d978c4d78311eeb498af8689c24b2ad836d4d5d84310b119d8192f74bc93528cd64f7fe021427d30af61c5b12aa78ab7826e461055495738e7e12acc1db77222ca0aad9d0bc31ab6450642f76efb37779c91e2bdd568bbde62599417d7a36287943382b929d7ec7e2f5fb33fb5cabfc228b97813d58c904a31f659e98124aba1bca415274e6ab155add11307534e06f1824ac10924b5f0a7279b358750db798626cf090589e6d222b6e439944ecc431292d16fc5c2f189d69dafd7a43c2d541e689dd1a0d9d9c65b2edf2f466edc2f64f15514c8e16011fc8667c30910995860cb18f4ef17d409058912748a5d0c2b88b4508f960609ab967621928e0d3daeab78ff64405d6f9bec017e0e935a717e6fe889ac350d2f38f35f1cd40443d9070d4f8e555410b964b4d0f9460f04792c384ef04168d9e326d9f37b08694a183fae15559c5353fd3d85dd70f482e363f652efe1f5d080d41ef140c847f4019facb21c70fb15d8abd1901a2dbf7b523b9d25add38e6086548bbae0ea2e636cc86d552cbe482e42e411faeafc9207676be544531637a87af14aba88c4601bd227151861672c9efbca692cba35c8fbadb53908e6e3130fa4b6e6bfb2320510c7d403b5165e2b5f4320ad5583ff15676b82a6b9cd45cb5052cb960c73203a08ade0f9f85a6fb4d15906ab5acacfdc7b81bb897f255b44a1d451fdc172fd83a7bcb2d37b6232d3264bd027d5a5009086df82464839df3d06fc31f5955e5490b91d684628a1144151e176535cd10aaa58075444cdf9309541999e642ea5392aaea96ad7a157e2bf025304e9e856904b5d30b413b36f4d98bf8fb5bda384b9a322eae8ba775855971235091769439609ed09891f56f196b98172ac8bc4036e1ef7112267fd45eab9b8eb03ef3a32dd215b2f41ff11cd78984dceada8395859ebbfee992ac837a411064b491fa8d02b0f655915205da2992e6f8a1faac59b5af44794480d6bc751dbd5eb2e19d2fed8f7768cca112c2011653ad9fe64e01f501db91c49e86f4bcd043980f3c41e426eaf517dff3d9051b2042a41c42a16374e2f299546d75b50315c2e86976ff95349690c1a969ef8a702518680bf347182b84db4236bb790dfcbf0507aa74eb601c186f110d99b88b520123646e43aa8f4e6b112df7768d95a13085806f72b8efa17be049638cf24a1e193ce2dad0946758a4d9b665d9711dda8ce58085d3c275aad12198db7e56928f3f53086c29b3fac5f6fe2a3bd4ae5920110136cbe93172fb302d7d636023f346d8ce594388526070e4893ef27b0796d81c293a516b285861622a11ee90cb14801a4fc0d4a205fbee4666e8ee0790ac6ec3f729e2f3bc9ff09bad1289d1b55221e0654fc0501002eca704efedb9c3516398838b2a003a25581940c184e4c1f2a4be6907bd1ed16c026828ca8cd17be00f84dfb6fa8cab1aaec396fc4ffa606da586d8d776744489a5e70cad48b0d73ba048483d957e64c0647d6bdab69f30cd7e770368f0da4fccd11e215096905a351eab991654f44cc47bbb1eb7ee20a4d5a980909cfa65f73f1ade529fd7bcb0b296f32ce7ca477e14996575c32cb1cf85ce58ae39ee6e8e686f5baeae1d2c6daf9bc50b63b0bba5f2bb2d5a65e731ab28384fcd60315e57761959ef3aafd4eba9b889e7e168163c6ffb7b8c43f3ac70f0d82ea3ced6a6eef3a65846469246c64eb9c3dbf6d98e570e0b002c287df47b296e44be04ad942585c4ca52e2e91ea296bf316b40c291208c84ecee51c525a26c3e3d48f9f876f97eadf6b5c62850d7ceb2c0c8f2cc870dde074bb04f5db7513df9424c11af3de94ed62b6c17f423a506f9cb26eaab0ef495c808a0edccddf3d60a3d47bea6ea0da8466b8a4b8f3ceaf1b7b455cfcc92a1915a578db7736b536f736ceda77b223e73ef6ceaa143551cb0be09d2be41e3266d3ee0b28bba95ab1883167bb5583e4c6d31869c18fe3b24425eafd3921a5d09514d270776a7449cc17942e9d71cd9bba19bd4d0fa005020d946de4ccf73fa8d1039bfda0af736128f651b17a09425d0e3949e49b425e3be08cfa972934217a93fee32baa505ea544f89a87e0d550031240dd8bdf95de67021459283373c5919ec29c98fac141032f4c4c9aecd6f4850cefc47970c96a9e15bb85144e0ab12fc078e43e3e3160c38e4e51515d79c3285328814c477ab5e0aea9370c6ea989a637a4386f1a2d6d7174c3107043b794258d5188696d8cd040a27b5c2507503d3cb4fdca12192f12a21256af4de3569ce32332d6123b0642f39179e6bcdf61774296cca735ac4f67490c5bcc015310a7918fead93ea14933e55770dd97b716a684b90d4cff52e207defa1ef77ab9dba482c8c01554afd92fb33e2f3cee893e168e0b722b7c08a06d90d75c682403bf1b7fcb5d1ab1e519627b83f96d85c99bcc50215a8b207a6f2af49d486eea97f1bdc70ab465e22c503810dd4093b17c8a7b5f8e16af4992e3d43bf17d4ccd5fc3f91f7be88135121311394467444cef860206d80f681dc72053d8d1503ad8aed990d15a11cb97ccb5691cb7de047cc9ab21134439f0e550f5c08637738a16e58b4f4eb8d0b9b347e9105e05f333c9d16cd8d5db0d06c97943a21523669ae3f01b38d91eb1f9ab543e1c788a35e832f553758ee2864dd0d6c387ad7b120be4fc22459185bde26fa2eda45b90b33c71c15ffe0838714a3151700c618d8cc5229a3e142892b395aca69c25c9759cebf4e481c881e2cdb72fbb617f2b44e60b29d352782e26a8da8743ae7adfe540a1a21fae8be692ba325e457443ea1ca34afdc9c0d3981a52441cd751752809b5bf99510de97f7d667cdd8015a975c7c355917d054f75c7f6a45ee445db84ffe107bede7c2ff5146d90ba78d6fe78baf680438d81359eac7f561b5078054f9bf8770df87437f151747fc900c0c5d8251bc63e222b6ec349660f6a3e38e5b16241ed23b23af1323d3ffbbf2e8b4fb5a54e62c4bbe789d11b1e137013fabf470f89fa6501f9f8f314eace4519b1f109c47ae59bf1babd0f9d4c34f5015dae5a18614f72ee0d6f55a87dabe17c25c67bad3aa436147f318a8a129a2c30c49606c3f55737c8446bb093302deade77ddbd2379029749cbb7cdc8d9a90d216315f967b0167ef632b763264b991e8d6dbac19555a73603480cd590108ee474d5174473dfcb3b35c5cb14ca9cf017f45b7edfecb3719985272db081ef59b8d5e681e851a3570c2951c4bc04f5b92f4e6f4616f5e66307433b7140d7eebb830ab47922c2b3d35bd6e7bb3c5e232e0034a9a93162fd01c67c449bc8d32af4b3129a5ad460300624cc0b82ce43b5de3ec3157f2f594fb0c09109c75195e8fd87377b42aa4e7f08da1305dc78dd39515bedf3239c0851cb0a4b86887d3fc6da7f2bda673f8dbbfe8c4abf77b0e472d893f19284c53a56e93d6322f5594db298a5ddbcdece1ce457d32b84c998284ab7f1f5d34e06a2b184c93b6ee2749b97637b4c1c0de821b0f57f0f106d3b10405bcf14ac22fb19722b3ab945cf6b81ccfaf09b594ab52ab9350f6c906dcabebf8e400c64a05160d70d7f4a52605cfd7845899f65df8d2d74a2b0a7f15eaaa0a427686ab34a419e3a0acd8b0312055a2cc998d59a2c36d0cb421b503fc5af373311fdebc26aa231dffdd6ca7e104de09e34b8883e391003723b18d3908f653dbbcd562bf9fdb457a0430dcd75fb8c4f545dcb4ccee4246658653be6c589111d4d1ce986a911bbff9a17e33b54d95d5f0b053eeb45561a361f9951dd9ea62f1453507c7094efcb8045da4d0f6d0f306447106608ceb79dc2aa69e6a80a5e5b52ab3864697ad147410c529cef045028e5a971b19f555f97f84ef93bf633db3b4a954b8808d6d1c3ad0773fb29b3f183f8a0db5de842905e7509634ed5e50a7f6bece420f6f1fdd82b8b2e426e3236bd396af572c532657442e5fada6ad894fd2134bb9ec95d9e4527843e295080603da98ce2b1b31fba9f08ac31fb3cdb013699e07b6a8d1e49bf7b22d823e71e764de7a163a134068cec7d1082c7ee77d7368e6be9682344fb8eb0e1eb7728a253eef5ba682d0f35654178416b1d7460d7a77989c99d6a3bf0e156cfddf4d331316eb11dfb43140f6206d117b95c2411ea42d6f0785e1de0c791364d9e92212ba8af6623dc676e1f58db0940433c4fd4dcc239de0367a28374970bd6b8b6349ba44fd7fecfa1bed71d959c7406bf340e95706827e6add253ead490be93ae3e130957565f7a6803c9ffd4d53cf92eaabac4d1b953b20d82f43c19331812a95a329b98826937376f32ebc21083557c28d19c78dbf5a52584307b7577a7d2b9059e4c2bceb3a7a10a0b1972cba5e1ed80c0e3d9b64e31c541f37f9a728f820ce782df5c94a070c9eaa65e6dde1146dcd7b28c6777e3aba3aa3653cff37e74e4efd0b17f9530dc53ebb86fab46718722095cc35e7ac423715be729bb0503cb8d2718c6e4057a71b5424f0d51de2f4047ee55f9dc6d44831657dea96cef784ce664e05e5c976dcd0fcc762ae68a00267d9d2c65f456deb177fc33c34bb41c20c8ec98e7b2ceab9b1cad0453d2514a8e28ab1849b792070db155eb515696265dc036aafc308d73c4b87268eb6a5733a067ef3786ff6f96edf00cc625bca57524726facb00cf5d2986145dc840d9df0189d35dd8c58cc54eb6db7d271a237e4a731eecf7bb90e8a4ee0d0480a6d88a3d0508e937f2c70153e7a06ce94acee52bad7bb9b00fb809a39ae34931b725658ff1b497d6da7e27f9f07529d40c5e69f123cf5b46230676395d9d9d9f32ead0a239d1fc8dbf7edb7e9cc81a91b15f8c08073f07c7a039e009f82ea487d40d10fcd91b1c668ab174196d004d9d6143f2b189b08818b10956dd5174ddd245ff84e2d6b73e32d958da376797cb98f3798055c92860af09d4a65fc3afe21e3c9691d1eb4b37a85ca3e14c31e48b3ed662243ba37908d28e6f2c84257fd7df79ee08c62c58d3ae0606921291b6c06a299beb52c5e842326bb99f9b0ba6c512f863366f54ae9a613c6718875e8342f5ae6b85377e67c219f664dbe67f7fb5779692e1554760cdc63fc4adf0e5e0031461ede0d0509b643e178cb7f27164c589523a414c630bd6cff961af63cfda752e6e7a4aabaa7c073bb093e15fa305dafb77440ef6b7953216fae10c24c84744ada373012ee06b4ed36a63ec041f9e4a7090515b4d4a375870bd410f970933540a2869cbd00953f0ddf159710d073f4a1140062fe3df6e5c520efea1ab46ed50e2f55eb473cf72c700fbd3a73974a49b1971f3687bfe8941e1c80015aa90d974778fbbbee95326c0e1c0b60e701d2302ba4ca3305ebb0629c8e997377383cc04612ad2589d0bdb75a8369ee77ec3c75982370a4200d2f69cd98a0160127aebe20af3cd97c22700438d169095be239e81ef25a131ff268479ea8106b2dd1878240769fe9fe8940e728a51b5c0993224aaa458733f954e5ebf2b2a31bf6319aa8cb515e56488126dd80816d80bb44a8cb257b2fc91e9a4d5d851382e9fc203a2be8eadd828343736f3d3664aa715adeed2875a9bbfc79d761b866b6d04855d7726b125426e8e13616a06fe33d01f50e17834df7f35847273a736c765e85c200f7c8cd57ce0b11f595d183f89746ad1ce2178cdaedb62565825fe64e7eec0d46be0415c97967f88dc2d31ca255e5c59a5ca84ef3c33cbae2981dd4deda5cbe71d620f29614ce66ad57666bfba924de63d8788dbfd592ca98bf345f639df90fc85335f662f0867311bb6f3ca2a5ffb2287548b9ab47e1af4585ac58123118a3caf4128f35fa097143c0d4cb205bc9ba98104360ac8cfa5d7c5ab70fc6576c19260cdd22030e7dcad090c0c710b07bd6fb118beac9d48b90eb456eb09c97d3c217f281127f7b5dacfb8da9939b80fc9b5a12b8e39c4a9011b3f553a78279499012adca8bb7deebf6781e9adb0a282fc303a88c1c0e04878956a9552047e6ddff4be043f81a755e7de51c030ebdae15f43da41942a269cde964af25e191325bfdac8deb04ff7a925923259e2b54786e177e4276d757958dae7f3f030ddc57dae51f0481dc05f2e2f2a0166e73e8c1eb9f9bd015af313579d727449711025365cff6e7da9fe2185dcae548527a3962909d73336d84527622a7578a11748cf3d960b4886061e821cc7c4aa35fe6dd97a20df036a73dff9edbec08a8eb9972e5d861f7b9456af6e4a78fddf5d4433d8e7c9c8718c13d611d78ea23f3f5a440175c411d8a2b8f5430d60fe2c13e47abc98a76b443ae533e9ea1f2dd27a6eb968dcd87b8c569a1d374faea0dd3b2e14450c23adde85bb6d620e8e10b649eef1ceec3b3d759c9aba5d0f9452c17e482b28f64c4a58275de2fe4fc524f954f45382f40257bd335fc7e9285e07b6d68c79cdfc08377d51df92483b706d134acf81948d87da3e3c7dbbdab2a8e5a8ebca374c7ee9b3aac55de2afeb7b8f107c3dec5df4938041b158957819cf8db7c74fdf821f697821adca75f230e6ba9d10ed2a8b63a20b82a25cee28ef367a0f01383c6d55e0df1f37200c00099a40d37bfc980bdc4f649b72212e1d22c4e4953e147cc438903ea04214df4b1625a3aa5f8cd371875f35638b52354d6e70dcedc59c370516dd1ad006c53455c14f2b83cbe6b08162fe4d3a390d05bda5a87465d38681d981b0d93d986ef5b9c69bcfe03b7336abaee50f7f00c402fa364d76f66ba9aa2cb7a35fe8a8dc8d738a6e65d92376b82b398106016aaaef75c2a3f68e57f97c7303b9771fa85ad89e143439b0367c9c9dc900ff684ca3315c4ba5ef7f8c4705be0e8afde295e0f6a8d685bcd79aa90f2ac70e049eb7f48167f7855527d98fb0b95a76c44ba414682f63e7707785e71808c515a92643f9c885a14cda0e8d78d0508123470e76d677b9192641ec800b06e2a791e7cee2b375e46874c4445b2e8d8c04a848d62d631c9e7f067fa23db55b80cb4136b08f81162de7a1893c406bc80c2680e8ec2ca368d9a5f121d188914a442b014ff948e59b972a04d2f57381f3a8b1cd864cf0510ffbbc8f1097fed090d68aff14e7aa601a92e5fa9dd3e157bc4783a74f13ee263153389ef79f7ee7caa1fb1a5ce42db37c8c97ee51f9a98dd1802974cac0ab8a8adc82211564d0ae0c806a3f83c3aebac3250f9be9f7688a399cf9cfc30065f6d81a8f793c86f4425dcaf6af224926a989bc4b18ecbfc24831c4ece94d12920b901c8187cc2d9bb27e375d152f0956fbda9a6a0a999a3cc0c97b61ab7110c4a66540138e7ea2388f138d544357f78e64d7c9513cee8fa3a4cb5e23229b7f688ebf90826c1e065fb0e453200b3e2dbe59e79d8b6ae5bbadfd06a96fba380a317211b74726c7ffd3d92c5ffb66b2c9b69b91d5830f364ce54c8a2352fdc73ae6bc391edb30f2d3d5aa608f39ac0520348617e7db2134bd4427b78317bb1fa1d2bcc30f41247b838b2fa52785e57463c436c68eb5260243227a50116101cd708d4ff53d8b016f3f46a695f8bee91dd099c31dcf3f8312feb64254fd0ec276fa4aa2bdea27c40f35349f3936c331fc0550a07d6d4e6286c2a26ebdb875ec182c3f701537bee6c60e9ea477833e3667938e5c5d0b1731b15e8024a136c8a3e321fac5538dbb3c9596b10540e5a2b03a03e941370a6b2d6fafbfc2be1fa288f615d195f354fddf7a7534fdb5e33264419f2250179b3601cb92e0cce02ed229d8152824ab97cf02b10622caa6d1e8e0ea939b5589a6c2b1ebe2d18951c6d1f1e0e17e38b08a22b948ef60ff7e5503e2dd0e05aa7c4505d4918c0ff41b98c8b78b3d5e6e6da7368652f2cda996d9a2371ca5780e3bbf1e38f0398588ee347da8ed1893a18cdf7a20a852613a1a1bf23b421a432ff44d0c838588db6e8aae9de4b3a0a1b3ed89f288a001a4fa77cf63db70f78537462d6915424c4cb4077894aabf3f93b94805d77e693d00e8a3bdd6c98fa72494d5dd2955a4d709f172709eb6590eeec3eebb24b4facb4638c0d98ec2b894e380c337185c75455c975eac26a3691615a2cb489b480a066c5f41f54c740a176eda90697b7c0f3d2541561473536f77deb63acabb96aa3e37e271f625d867109bdef123ec00fafcb2f359e1af69e41e0b8fb7674d7f212a375483fac0bf9bbce992199334e2cdfe9b72e75468393789c776fcb5fa00b9c194152d142b90cedff3bf5c063f86f2eff7395acd2f59f492ba33ae2c83d94688652813562d09cad78c192bded570f751b335f0f301c0362e51838d2a78d364064fb1b84604bae5d40dcc7a0a4e49860dc4f86f8691449eda3e26f419fe2d4b50dcf21fea260eb620372194c0b795a917d918104195e5a12955aafd91852a3b443987aa819455f08ed782f1daf261e5e956179531933fd2bc75b894cf185e25897af4eaed9cf8e07f296be7ef148820eba97d3bde2742a12012f4e91e3162aae3e919969a6d33184a1b8e6544db4ffa95ee327f37fea23e0ae65658fb391a31a255f8227b901a611dcdd40dd6ec9fa365d3122bc3f92dba28c8514453fb9426f6f6f721353d674f055711df26a8c1ec309a38f653e0e9693c7e81f38fc484b352e55ccd93081becdedbb1fe3626c790baa1e2e2f5ec47e0cb757cd153fcc569ba2737a757dffa3f842560e65311851df66bd5b37801ca1c204934873d1d6db4f73d22a2daf9b3edbf2ecb4bc91700ebb0e815386d5ffb11b7fb037cb3179dcb6066931ebe990437265881600c46f97e2978a95c17cce5d569e2617b055eecddcf9438d1b75a07f341019e321e2e06b2f6c1621c0e50dd6a630938e3df90135fa5ad27408710d79d0b8e691d93318a0b322f11adca70748919b8241f23c7cec22e3e327a96b44906f4b2953e7054e42fb9c9f04a59530a747b47d5e3849eaff4a747cbab97de629d4314475599c1a9348f76de981b79b96603125cf43094febd2125b32667798d8f2dd5b8c0fa81c0c7725340f7227c484f8fdd49878c40cb98117bcad1b5f26b90790a07601b32f2400405e17c5df8c331187ed0820455b6101f82f982e549ec608d7c15c07c1460a9d38c43be43c49fadf67acd2bee36bc71127bd9a44401ac91f820ff16be6e0eba197084de6f8b4384eaf2bb009c26b3ad1701fefeea0769a78d95463340891cecae53bd13cef47d12ff9b0b471fa0d991c7cdd554fd0e17dfda933ce0126af52ec33e92c9200bf932ae91bc816b82176a5d9d34938f6a1301b5f05760121c777aa3ba39311030ee745030a8894d9f0b0dcf1983fbf54851ebb070de9363cd319eae7d8fcb4a72918e0567ebc0489176cfd807f2b617928c3f5aeba86e0e3ac321b6853612459109a7e5711a57f0f6328f4a80bccacf6d9ddd27e2f525180e0a447f3edabddb508f8d26d2d751306219c2baa04e628aae5aa4b20b8f5c9cd63036c082ab0e69708668fe5ff02b3a84904e3c6efd394c48902a28b0506a255ece96998470ea2f7fbfeb9098c92cb9ec1072b628b164f412555a98246ea5e533330b437495eebe8ec0554b2247d0517f05437c45ae52e27444ebb396abe853f47440ea2dc395db58083220aa04648395b489b2f1cfe07e5220eb482cee174cd6d3b92ff705ca2530243530e0ebc493ec0d01dca2f95bdf6ff791e563f300aaa68e5f8f193da4c40b647a32d0f78ca10618cf5ab7542da3c7a104912968572e4b820b76476fc8009cf3fe266286619d862879b610bc7ef95824b2e5444687ebd65e42a8013bb4cf15c7a60a1a30b91d857cb6f550297f75c25fe150ff5a2152c342990c0245590fbf8523e79e5db180955243568bab0ab8c02f0d0abdcce9efcbb43d8ad410bb105a0c23379e9f362833efca0ced75520aa60e6287c084fc9bf3054cd315451cec3a4c3a5f5bb876e001c8d116c3f7f2cbebe8ab9b806f02078413925052718b533b11c7becac4d032c3be5d0c95fc1b7bf2e7721ce66d73a64d836c4856e49fb10b0e065255eb2ea00a36ed08eaf2667817dd0de92348cfccaef5fbef4aebc1e5c12ee17570b6b64a6697fa93d4ab95dda70806b23b2f7191ac7cd03354447a182d198fa8665b378e0a55291d4dd47ac2d0ac25585acb84876092f7eff7791937a7ae9e8dfcf4291d34b5e5aabf3981d080fbcbd09229a3d7da499abdda94f77bbebda020c7e564d2c9cc61b6a03407003c63ec8c287b10600ce8bced0c9e14a70848991388a1b9728907a8c65f2d4fbe05b53fcb7f4e58294da8162e9a1b98ed9bad92de26035d4546e9649f98d702054f52add311cb7d2f6e5ac7afa18523c225ed7cc486c928aa46c050a10e5e5ab9cf6923dfceda5d6ef2dad4f59b61c11ac6373dd149b47f86a18ffa48b5c6be3dd7256f37993f81c6c53d68be879fd4f2a5a80e3444e815e5e98e89d47be5e6902ed518a103ab4ce88f4b0c939828c1b008c19c32b4d50f6dabb3589998dfd4bb8b1f5d33d403fe052e15d6aae6ce50150ef22dccc50ad0bea4ea87a013fa62fb321635cbff0d6aef7b4161590e892f970c88ddb391c4ebb783228e57668c71ad281ccd6436b60553490782ff0904a5fe575ee7f44024a712d7809ed33586b998376f42b5fa8d9dc33e0e91277c71288fe2f30b80877a2a5c9f2ce4515dab6eafc83d0129d93c170ba7c6f682b035aa26412a8dcfb14d1903be703f18d86645bc922e665a49e45330cb8fc8d2b1fbd58203fed17fdea481305b167e318648bdfbe96382d5ed7bad8a24bbfdcbdcf67fd2a0dea4b85b19b858a246a62cd49fe1ce8070cfbe60cd676afd95b4ca816748fe19bfb2cf82d56d85284c36159c062791dedee5e72fe3cd69244fe558519fcd3f68cc14ad3988bcdf5a1f1bc3d32e7f3638e022cc75aa8db87e47cff4b5509dc9bc378fb3cc865c330e71a8eab9370df50430210306576b2c0869515337ce11ccb530f8187efde94d2f5444f21eefec91d969ac2578d6920cedf2064f7cfa6abfb776c94ead5265ab5587d13b4cc5377b06b0d2040d04bb6183eaf6eb1223e117eebdcc1d411c3a33280e002876dc94520da1803f5ef23cf47b82a2e6d4f01ab31d24116411c03914bc3e37107d2d2824280341fc2e9a19c2f063b59b3157a13bec497afa51ab5b86d891431c741018ce21eba8be206732c1f26ef6265607abd36238936c201242117b79e84fe986ab02348ecd09af607cc07e9cceea595894d256d4594e260dc2b1f509d01ca5e2d500944ab6fbc40bf54e50b51997f50f07ed4a91dd68b0cf5995984c3498c779892f7b32f65d4c5ae1289528dd07a7d2bf0a738fd11528e4fa27e74613c656d3eba963f00a032942b83a42740f5ba5594fd42431f13cfae59e55f8b9af3408612ec7ea45463a0e963b6137853a7322ae80802b06a4d01239008a517591597f4aae33a3b77eca7b746332315152b3c2adb58fa50123165b4f6bda44d4e9e32b0795e70d8e0cd6f7065350ccebf70f507b261d1b35c36c5767621b7c12864fca28ae8d72253a82ec06677419c3701a3968d105b2f89cc00b569272e3cc074b10ad6d37bb4c068225c6fa7b646ade5fc50a98e649c3ca486d4981d86a28040c13ec372b56046df5b3daf0776280dc7c785c3f6dcdd6600cf4e14c45413c831c8cb74cac8d051b3fa57ca341461cd28071c224cee81f1c7740baab26ab9984ad7c663e29228ffe54941ea1f5c5628538215875b893bf2397c46a0334086e9015c2f51ed1c966b530a1bc409277ecb46deac33ff1bc9854e8b9e1196eef58c520a43471add9d225b2b6f99026b4352d1d13d533e88cbea6a2aca23aff591daf190fd04544ca7bb4745f6922830c45c3a9a386e0ea1cfee81cc2b3c8bc85e647ef2e2cb52116f11db57017df7800f0c7ee88d3e36c6d60c6f4a9d52fe58d387f03788da13bff6d947b60681c3084e932e0752b97b6014930e1d0c2785307f850eae0bda559559adf12572da3d2ee68065294bde19e9e4f62ffb0d90a8a71d538a452ae4050473d129f46d451de27c83f59adfac0003dc19d1d26925fae7f2683545e8f004fcc45c97fc94c21324d99b2d973c7372bc256a206d9096a2d9388efed31698220795474bfae22f3b1832f38b6648bfe9ca7d27535d304f0671050d1c352e686972a7661d493b7aa3d0f9108dc3467ba5f830803d370a72e87d569152f93ce3175e791d5dd64202c3deafcd95ac5aa121b6e6d5423cbf3a42727608b34ff1bc73882c3e3481788c3b804927aecdb4c43b0fa76caf31852069ce965c5db9e861c66ebce9f380e60b61d182256307a4c9eb51383c449247853058ea2fccd6676d3eca4e3db70b336f233e9ff20c6ce61e7c15b248f40603e6b64a62a2945012a07a75f829c9c5a397366e10f3b616baf8c301d2faff68f99384a0773835a22c7895cfa5ebebf3eacdf06c35d0131861ca6b5d052a7a139cf41fd1e6e65ab81c7e3b5af25e2ac8f66ae4594e06ec162b8c0536c5283d54141ebcb09f3d901d5ba0d89087d15b1ea8f31a181ba593202c0548350dc6002bbd684d593a130e6059a486d51b0533070bef2ffed2928ea50a3abb8cc6fec48d9055deff91326a5f4eb4850392c831565007f4b616c22651e51d3948b3b172e993c4ab8021ddd3bcbb592832237618fcf063f842e62f1757939fff797ec422be930e9cfa8898e82c3f5e1eb4958a78a75e63c1cb898d913d69da0112a51e7b92f51665069f794cb285d4f0458fb339a704151f9d355b79ab10751ab7cdd3e793a147297b9002836ed7f9b059100196e97b72bbaf6b3bdc0893f0e9d8c7004a601dd62dec8459770d62fea634f799c094f4828f136249ec3e44241500876676dbc2a8f982fde759735559d9a179a54dfaa9906f1ca1735ae95285e22248f039c39c4d40122aff878acd0118ae7fa8088eac14f0ad06027aad77ae5457e53679a085c0cd0c9a933746e0a0e5dc949576007777197df3c900c44da4cda6ff9191c5a825cbaa558d97b51eefece1317b5305aa406177ba1d32c7d2e36b96c9210c10166a7dee41e383548fd55f14e692b3bc23e2889f6d7a5e9608b3d604b0c66b2f7b32e96b8e4e8ac8a35b579c60d6b0dfede05f3a8935f295056de12b5c7556adb96154b367f7a58a35527d7372e58b5ae0eb8255c93a7e99991be56795b192d626ae4b4a1a27a48c52e1520729fbf227398037f5ba3d756e1dc56bb20c15e8f562718fdc521f80f69ee218ace21fef09acbcf6aa044b29aea04ec315e43afb5bb54e12b7922cbbc0c68c7585ba520e8d7ac0f51fcd35887ecf49ee6b23833de455199d2e58c74fff95d079494a33ad927eca3acc4ccd2e3698757822fd9d6861a22ac7075d67500c173bf25e1509212b55e319094f25d760b75c14922e64ca63393d1b0bb8e0d29e96288c32f08e3d1d8997e7c29a097452dce98ad11957a99c99276843b063816243f44c0480706f63771f58b2c026e847117b67ade6e34631efbc3639964bf7675196569264c180655bdff55cccd412e9333f4fef8de4868c0364dd6a0c38cf48e153cb7857e8c9ffe00879026ed8d86d95f2f82847eff941483ac28181e579f766124448a0f806715b3b82c9d0a8064c7414d8688ada8092f6b9d9718fc5e574c1f78ad3c34c80b7729ccbf8909049cd68f38ec910fc983c2f87195832a198b9dd5009486ae204c2e2efdf8a94245ca2deadcddd3b11616f4f7de1aecc7b52f7f952ee9e9b2d8ff7143ce4946f39134631b5898ef40517ba729772e5ab8e756bbc48b19af97f1fa7deb119977a7b0a370614c796d4218562421c2b39a0b04f7ba52b0f29234036b92c2b91cbf65bf1cc46ae5672ebeb9186b7ae2cb82f4289402acc963bbe2513ec059de806249f307df1d4bc283dddd2fc3b478a192cb9ded31a51f08da64a6591bf4ad3c3891e40bd3c2052aaeab9c5dd33a63a3128bb9c9191a1694cfae9cd791b884039ca9daef70a61a20021d713a6301ca43e73a03227ea4ee4f414792212c13bff380e8b947417f47f31f8d45de3b8684a0da9437d5d117b84635033bc2721d59fdbc73c13bb946e234797e94b87ef2aad03fdd721fc8f238cfb2a006e83be2ae58db00115a05365fdda947ad26df3b159c66c9d626ee9549c09fc0e5dab557f8fa372745683e6fa4ebc91d86c75d965e2979c6236bc646d68b2481a0b06b1414cd28b0175e6b135f1782e914a6fdea707b04a6c28001074c603b7a9a0851926e3553b68c19abe6a870ce34210a78fcfc31e8225df4d9719107a59cc4d3be434e8fdf694e0eeea2175395109eda9e4cb8e71235b5e534bb22845fcd76b7d0f8d55d8bef09cd038ed1c042794b5ae8763c4624e9559b15738b865aaa40c6c3696ccc8a46e1655f2c717fc73713549d04546cfab64d820cabebc3829229d86f0765e439ddc1bfaf4319f80b7e2697a6c390665f5a3539365946e1728b9ba38ae415cf61bbf0ab3bb1a0cd8608dea18fd9cd5186968450d7bd4b19494dd38c9c06d52b8eed6f2488c166c7b6ac0b0ee8a53a05ed30ce425035a2babda4418f013f7b2771f0509d270e5313a95f6e69f386a87a79cabc21fb792541220a78ff850413f9813a467b6eb687902b89ca9aa632aec3510d8901719c878350d6ca785bd51c8c8db0f00dc9e0a407e13eabfc126a43627ff7c41d491ecd259cd1c7534f5c625b148b9c1f44f31d4858fb319acdb31acfd9d787b7732c22384e1accfa0e77e03e9824e44489eda483361638c939421f811d033ab847b68cb5ec9d4596184821f5ce4efaea3d2106ff823f091061d6ea9f5403487d47a4d074823483b1ceb98085629c6401a9e715ef589e2914413235410685fbdaa875031528a5b8f15c52c03189a59e6a282a176fee1350fc060a3d9f72cabeb5e7ab8411f5e54b6a9602faa80a20eb736c458b404235dca7db27d5973c00a64f17a26941375700a5683b2f91e516304196bba714699fcbc9603097bed5249fab5e8ec59c2b42e4665c2fc6b78daa8cd06eb6a5e4f7d6a59adb1cf7ec69c69ab1ccd1d8a0cb56e69d53e25cb898f795cef3517dc76e6683bc6b540bffda9c947d4efd0cabee6e47aaf62a881487c2147b776bc23b090819915996b1e69e1ba682d47a83136ab515ddbaadf83693050fd390401a8baeb01352fa5afbaf3d844a1fbc829750911866086c0b58918b8ca905d0756920176053f2d10b5cf9897a1ccf0a72947cdb243ed8455afd01e8990d3cd886bee6c144febfcb0ecea4a6806101cc0f13884918a9b08d2d5bcac5daa34dae05f27eef97f939a31429feca9beae1ad08cc85c042964cc6a9fbfa80e8b26fa1ea382a76f102a823dca7f84497ef390df8dbb43195544da001570a63f9aa4482647262d0f76856741453277ef559da406d3df789979330b7951238ef2adb7d2c683d555357c3bd0ae7265df10b87c33bd838f2eda8aa35922d6c9d2a1a77e628789c8e757ddbd3b92716153992567ec4b79a1b60e6b068aab9dd7606bb7c3d9a0c849610f90631d7cf7e36dba6873efe39ad9e0775ce29c647c2808e6ffa4a6189c7de2c5d972d1399b08ae30a6aa6e8b9b776120846591ca443e855931c8f7c1ed2a452919a2535c27902ca5537841732a7a25f9ea9f0a45346e6f3363c6c7d56bd5e2b6073595f4da3505a43ccefefc01f2f44f1c7e031ec360ed8d8c65edf137e267b10e5ad3ff5648e564cb692f2e917aae405cddbb5da6e621d284bc9ab6a6c89b0ab9bb82173e154fe31f2deb846fb89f7e943d7d7671bb9af72992acf7670358a2d434f583e326e3b2d1d4b2dfb129b3266e7c16d89b2766e92e4973cb13d9f241c96fb1fe789c422fd62345d90bf17c5d92d5ea940b9ba6c1e244bcd71d4b1629e32401870c1179e0b42a2281590589334a064a843d17c092f94dfb77257059e14d93d8cad57d294c988b5c258e4e781deeaf0560724232a87c30ddedf16161421f0b87110ae4485772fea18c114946479e750e2237f499f7dcb44f8511b85e4090a6d31acb5270","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
