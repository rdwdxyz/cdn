<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0aed59f676d6fec8e4294e22571113c18e3a7b1740bb095e4bef1776f8b0f4f142ce5f1bc108a6c88d1d658e3bb8dab204ac515309fac3f1b7c96a37c5b4fa2984bb505bae53449533f909a2a953d01cb04b76f88d758d03af1fb865926bb6b8159bb9ab4c48d69a468497103413c8b925b9561f8f44fc42df9051dffad5c788376ad962d1d0f498369abc073bc2cf0a96b71a090e9b81ce13f53f3ff556b75855d75f2481218f5f75a29ffc745a327f37ad40fe2435707edb99e64cb44fe9a1f1fbd528026cf357887f5c744a5311900eccb08bff6268137aab4841e391531d1bd25226894f9fe82ac6d2470da4c57a8f58df585e4845adb864a6d0a7d3b968be023fe6195d48a74d650b1606b8fc256ae01011d707621ce09f413c10b4214f66eeae61afb6c62f74ce574f4409a5bc53316c9ebf1eb69260a19b6fb839668dfdfa2a85a97d93030b756b18f159ea9361e3945a2274fce7d546faf0a883a3b56cb984a32973e7781204222bbc36f0e91e2a9e7ead7f221ebb7298d4880339d03337b243c81792bd757561a851c760eb00600f1288c73ff303e0b78a3260f1935d74eb4b503a363a13817e249985897aa193499ce9ac14ecdf1be0cdfcefba9420a56bddc7ff42b0f7fcb26aba9d46a53a5abcd5212502d7e170d309e79dd57d81f724f4fd8a042c787d596f448487c5b4f3dcbfbef423f42c6a94179cd877a0de6883d12901fd4456e8e6719192ce6b36be572a3e1b33b2363fbfe2314ab289933080d181eb57b92447f673e7583731366cbd63a6893652b67c92cd374781a49e88ced1d9805a6e6cf14327b2971e8ce8c7bb747124bcb6bc841deac4c3728461a26a5761964714e3c3b73b2e5656e58c6ac305a595904fc9dd787dadc4016317ae3275308a6eeb878d5c8c2ef164081844bd55ed075294a5be94239aee1899fb56cb5317fc5ba55beab482bd243c30d0f277bac8ac4bc399d865c87ebcc9c5dddc42ecbbd86ea9de0c27ece6052fee0132803ed202abddb7088675b4cae7b4d23953609da06e2dfa8faa070f62acfe99555ba133a7cb716315c334c80afa62fe1be240af194574e2ae94dd3758bddd49b179b76fe79d7ff239d27d08d70f642e2f2568a618f728a15d112e2deb1d24cfaa5a067219dcf9507c66ae28c1678e690dafcf8f1aa4c1fb6b1f0525ed39f95cf2b8c386e81829e95b337d4f74cec378307cd6c8278ccc28bfe0a395ae000a9498ad8a774ad4ac60cbefbf6880ce82af398c4c10f799c3ce527024ff79fb52aa75a91fbcf6afaa8e54fac3e18d97c5efdbf8cc7855742e1db85df75705e0edc5cb9f76d8e178982a57eca0093033ded33a74f26355cb961650fd2dd7b9396d1e9d3f4c7d66f19df69384115cb73ef58c71290714afa0c85becd571f77f5a3f433ebf50f8cbb2550704c8a03f721a81a55afd4d0b3d0cf8f208c28ebc6fa66da1dcdc4b56a164c1b88aa8897855e89d26841a4a1680ae038d2055e4c88708459569dc84b998242eb7bd9b71b78ddd1d7701e9cf952092ac7e2df8807edf2d37b720f53a7cefbc468958754c058ee6da8b5281cf798a709c976e877f983da162bf426ce7de89486e74bb3db8c8a1a126b8e5f3633f635daa3f25eaf039a349ab7812b13b37fe8464c9ea91fd5e828be9a5ac12779315e52bc0a73333968daa5551fe635e5685bd914227aefb1f2cdecc8e54b02b4b0c37e07b2bcac22215634795e9795d5ef006c393167f9fc1d4ef7fc9682bb87a75cdd5ff30ab780e82a0f42929b00ee7336c4cc07e03d726b2057c726a162df5e587c6c33452771d705588269eeb03fa5751e2d7b2227365adb3f0b742ee7bdf8265d8be1c0bda6ad6927aa39f1d1e4e703bcd155f98c0b9958aab292f54a3bf55fe658d8322f86bc6c314f3f065f353349bbd9aea5b5fda13709c59651df6bb8617bae1404ebef99b930823d824b8417811dd606bd9a382616143781dfbc4bd50f50a4c9f89d2e89622b1a2947477936d07aeb8afe54f13d1a8d9d8f3057a49dd15cb350434fac6a6518b1ee015294548ab4dbd1fffdd4e65528b4e186e5b895dc6e912118f988436799f00da97fda27634b7973e74cf3bacf5d7580d2b5730aceb75f30106e0d30147a99d6bcb62599eef9962e80569854d96f61b7abc27050b0971b637e1826a442997299a8d6bf546f3846ffa0b5cfd3eeb9946df0ee1613b80b201daf16f64f1424ec24f0c689f4f8be8c0c260e5364c3fa632f4f57492264385f3be6fb190e2040af7c18c0a877e078031eae7378cb24287501bd6ffbd68bb05ba1261160537c32b368d8015bc323835f38703a59f9d22844afb6259e0a8031f7063ff03321653faa1bf762c524d8c7e21c9a4f0d1d407d515f3fa600e59078c0dba4a50549913fd5257ab49f3a8f5d488b6e2108176fc1ed170481afa587ee91cc8f6619928627a5594771a5af78605ddd5df46d80aa8e55f2284cdb9244b1db11e4472b8792d50826d94f8c226f4b3a401bdc736d66d250b0095bd2c7cc687c51cb659d4fb0863ec5d5dcfa46d2e6f049810aa82bdef7970aedb1df2b0da095f1fd4156b14277b4074aa2675fe5a47285cd36fa5f86a898b1fd3f5c9ea45c9951d8e0a2f6543430fa5f2dc9e4588661fc9c48a6c785ca427a36dfcbccfd0d86e3e8a57eec63df8239af65c7352340b1e47dbeebc331a5b3f16a02bbcd5b0d9d46bfcef07fb6b23f96af10b28cf14125556cecde2c1e3b9dc388fbf1b2b90376b1c800c9dfb3ea84634a0fe0c368115cfab3d6e0edb08acdcc835aeaab754191f3b1c6bd1d67ffc9d4c1077b256de346d5044f4f54b384d030e5f4794472f5efd9fbe0816b721164ca149203df7cf9247aa821935088e5d587cba231621922a63ed69f7dcb4de5fa1e71517fdc3308aee18828fc802ff0c7b027b5f18c09a01d12775549f1b0a6eb08816ea3872b069eef25de488b601096bc66b513e79ef7348189ade33a831fd151020a55038ac01905a154faf05eef25fe870778f0f01e4540b0dce19541599d84d3e88cc82b3998c0e6dc3e19c21fe3c36e6b37de4e610599cbb21dc94fe5a0729ad0f3b88a4e90473006a6dcfbe22587789f1b2fa44b73fed7a1824e8fcda35ce837aa3fc82d64a10eb18fc5ed974d41d8746b7764e0b75adda5d5d785d02f4c5604b7a3e4e660ab29760c4d8ddb5b9ed5bc4bf93e857c74d98d3f2a7188f83ac2d7a7ded3215e3194cd9d9297815fda84bd70fbe3ad9b19c0a7e050809e6c727baefe8563fde331eca3813af615cd47934216625afccfa00b1638702fb042b68dd9d554c9bac07837a747f5a20ac7c82465c2e80bfc950692b4062b5fb4c58f6b3cac53edbc619fd80de87e6e31d2d9c349007a42f974e20b5a0d562adf53e8a5ea612c36fdd7bf5b0b183a56a358659c345ca832d47f421e55877eb87fc50025a1b981e4acd3910f515bfea83fcaa01f2e2c094663ed02643effdfd660cf87086d0b861138d354232d78d885919760141e2d1b0c32e489c7d866752f6fdd621285d9249cd6dd53b889ce204944a34efed6a44bd71e39c400cbe532008fcc2bf4d7e2be09ab24fb2fd1f7679e27468cc432df4f76fe743e7a5e5f90796b54e965850a856b4380b6b7b242afb6b8f576f3564a39abc5f1da5144a506762a7160c9996575c96afd240b0c24536114fa7fdb2061383b472bfb99ac6705df6afdf8e9bbba37327d17f35fd09cf7f3718f0a74759237178857a2a8d3934245baf66e0a069e5e0b4b01a31efb4884fed955856b8e3ce89139197c3d74cd0e2cfbb8c7d8d548d2d1049fbffaaf49b189318b0b2e8f9e76027d111dbf2dd740c06928e39285052ed5f8c6658ded6b708c7d6a5043e9b93ca0122f96379c86b223eca7f0dce3543f81763880976be9907e8cbf9fc337cca943ad9bfcf09cf1ae3bc3684760727568f23cc04df70c3732891585849be3e400b365b04b9eb3ed1800fb645db04dbe8e257e826508423e4f802bffdc3070018236686dcc68018f2fc3377f9868654c7dc1cfce9a8dfc1d870a0c48d91c6b0525b9a0a87ead8e0e94a98802c3b8d6adaf756b8882355aac1b061c81cac567171a21f120c555027fe915f8f5db42e769623db04cae4e0f2de5d6702b651d9a7739d60ac735602fc98d8a9937d95e1a097b2634750bd22713439a3c15209508ec9efb5f1231d1bf5e1de1acac588f6fff26ccdcb477c9a0987d6e5b39de5b2fa565b0846727353f6fb5b9f8ff75fb05e12754c40f1e210f4697171087e84437bb7fb20e41f15562250dba1a0f711bce5baace3d2b0de69b853198e2b70d04835a8e8c2366a05f96d9ce3e8f9da59a26a1b0985ada23e48e86fc10ee9fc87ae8e43d4de98f66e4a87788e58d644d93cf1d059b5b4cd5d51eeb8ba79ad9c526f887046726def52292a2e3d8704336b7f1233b16ef1aebcd539eb13b63b3e56e71eecaafb39849612bcd38687f750c9b5816e60c99957e34bc7a7e3cc67fb035ce40f8c5bfdd1890bd555a16bfe430c4520bd3bcd937b9cd7ac9f583ad730d4273f1c972d7f1c02708004050ddcafede380b1243f877c34463a5f12bd20a247ad53ad1942fa01e75b44d6817b97cc66968204819cf0a472d8afe57851556d9767ca10396f1e93018cbe55e052972dd81061bb533e810fca36e7e5e0a747eda6d610da3737d1cb1ac547b83db4519e573f9127077e6896b3c84d8f01364cee1e3bd538d5b9d4992531492094800835b060d3ff75520a7c8c32eef707e5d71aefef76b27d4d2334d1e85da9f8f0274f96f28a28d2a47c87524b126a687a20df6fb763675e169349f5c925ea1ac73ec2e72e3823e02dfc5a307ae7f7dd352c4a7b4af2fecf23d970a8b7419392d881b0ca354057127ba05154ffbee05e394a1804e4f8191f69a3041c47d97b1b5ba3861d73d4bc7920ca83f673c31e590f7d03af61c0e7eebeb6bd815736063d8769a4461b93bfca2823c503c200824971b4ff07ac66b8821cad7f117708abbe5a638de4ef4154768e8481698bb653db86b21fd849dd7ed3bbed50ffed1b05e6d8833ccec971963ef5525f375fa2fc43793b3998aa22138eadf108b51b4d046c8d1447888029260b4aca74051222e0a94784c6dce5929cc7eb742d59669c6df8e8047a2cd7179e8b1d0f301151d95bedff8f45d7302be0d6ea1afcaf06eb92ad21125341bc00b4c8c7c45a86da1affa238d985b532dce113eb132562bba3a8e0adaddeabbc313cbcc0dba0877a1936c682af532be147dcf7e80ed8825c9cdb02e945fecea0214ebbb8475dc0528d2c43753cdc4be304d91891267b66e6a57a96568f7a223bf9e3a55afc316a8fc74f72ed9dfcf686ddd5f5eb7e12ef2881078bfaa7ce230984f056e3b47fef1c7c11f6e83bd973928aef7c73d4865d8728778aec082edb14659329cd4728bd3e461a722ed93debc9b06d938492a8929037dbddc910c4d479999b2206510e4b9f420d20aaec0e49a7f8f6d9804d9fc861e2626318b8bf71275ec37486204f51c7df5b2830f184d3293d04b7ce4608b56e04555339fd8282cda76c866dc12ce233570877cdbe841e045359e699ebfbec05e318d0983bd9afa50136ec6bb42e94db0675fa5bbab43e6615a6cc5160a7aa4be3ec32998ba68a9027be5ae449e8741b6986b70e64407f832ccbb3f5e22d63b06f022e9de63b3cf7f3c05f9dbe5a94b8b9b7b7c441b4676c441c48d936d9a25b50416a63f35a2107765acabb33026972700934292c6cd1af5a4848b6f4a8d422e108bfcec65964540491cf4d0f387a1eed1d5de2e647b4430b2e6cab787dcac337685de203619394d46251f606ee6b88f2a70d47d91928c556dedb3c1f9eb5d47673b80a1e8cfdbc337455eef8ac75c83072ad7df6b027e5a1bc8154be4f145ae1de64adf393021e92cd03dc7e76a02d6770028b46990a1530b478fdd79734709c32b678afe41720fd34467436f07c1dbb1735232fcc0735e7ab98dec65d968795a3658b06ec6323542f7e09e5612b7d262da4088e04215f79ed3d5725dee9e694dbf0760e81bd106588ee42e43f00b64f4117b380a00ed00ef74d91106d5a52d1c8a47a8107225f996b5faa4248aac0495dd46064e4c5e91393fa58eb578571cb883d1e2e121b08d9ff4eed018961b22f2392759c0da17474071047803d198c6c8c68dcd017c7659c9ddde94b127c61d54936237634dd44581f370535860d889d3c3013e97f4b478f8bcec1e0356e3d7e2c7363e49d11a527556d91dfef27b8dc71f8cf74258d929f56a086985940f25c15ff9893ffd589fbd2eeca6161e541328fe02a820f9fb6b412aa1262e7b13335f7e1dcdcfb4a607ccf80d8408f1cc938fa64987c10cff1ec70d21c6cf53f98755ba999acd1f2d97600f34a94dc426194b3fae3711b27016c3a654abe74bbf88e7617a9ff1bf65772735357abba6ccf801c8f99accf05cb8727ad61d96f88a8a1b54f79d7cd117f9ae1226741970d0fea9633c14e45ca6ba202fc6f268519535de941b3270299fcec304fbdb0d2a965c604b49e14fc2f580288ba56a790eb0a76db9294affb7db3953918eaf3968f3145ca321270bd44367a688ae12a82a1f69e1910734fdcc0126fcedb3ce8d9fde34450bb770cb258eac0e4e638d5978255efbe0a233dd322fd22a1dca645cd92003b2825500fd8d58c3e34c0d9a6eb3ce376fdc9045caa454c6309f5e9b1e8fa3d359a51f399129e34e4a3ed71ed90a3af3c2520de7f76272ee2f1d7505df122957b94313b2bf339a91286f0565691ed680ae7fedc9dbefb7be73b8c46b78b6b3602625cabdf2d388aefb86d4fedfd368a8c78aa9f8b46ed35a78f5a5c92a0556ccc33cb855d40ba06161e834c394e3dc818726c0a193d56bf37c1dca1ad71ac538f2fa337038636e5ecba70fe2f4e8427fdebc98e8b819c1c9d74412d53f3e6e8b7cde30a6477ade7038fee3403412d1e5c288bf3e91644b848e791493334ff57a2da34f894825737d2ed579d15d3b95292cf1041c1a24d86b7fe0af787e8e456106adfc758f4a724f9d7847bde3a641460a6f44e5572056f6f88589b039925d3084857c70939ef437c780f1fc439391a049a89169a66be2faf3de38e026953e45cc04b4082b61bf6d30c25dd8649737730398fc976304c012ff87e67cd8a4878626c6abc46ff50c420ddd944ed8397c7e6aba178fc4213d029e6e1386bd0a1a46226d92a3f114f6546204bd10e6f9a9fa76f98720f94dbe7af76e969aa53482ceb653f9e6cadd209db2878492d45dbcec9e0479878c25ff6bd6e0e7aafedd455b93c6d46a9b17bea78266b883425b130598f806cc7e1e9f93d918a44fa992a38bbf4f809279c255b35b54ca1ed2c383c8be98ccfe7f2ce4fa05e24fbbb74f1a4610c26d30b7957226edf8674c69304b0dfa72aae020feb0899b3366f86d2365ece2f9ce28a35d96cbad4e5fffeee5087170c4180031a50ffaa355b81e9b66344d80f85de4bb4fb7c643478256b8f013ab323d5517715408b59069442153408018cb44e2880bef0b5a837ea4de7f8d8881ee7a32dbe57b023e84536f7575600e8abcbac29f66d61baccee5890cc8e36fc56bf3c1cad4964cbb996aa94c2b879425f495d0505ee18ed7f8e114349a3f20379f8e3c29ad5300843f3cb3c8903a36cae69afc5bb96d4e0e7a6a424244f62fe595ed7fc9d366d1c9e5c58efafa725d52f116548b90219825c4168ea1fbb92b3efeafe2d8460fc8d6c749aef580073abccc3489a12137619153ac4b90ee62430538b7903aeea0213559aa3b35055727ae7c2f2326a6824a32cd5ca99b8390a8c77225b7c5f9c624b3fa6d5a2f00d5ff12a829207a621fc9e8dfd1de2e163daa1558833fd17805f7e3b2f0d347746cc51d7f7129d2513c0ede282cf75f5f9adb35fcb71c1cd54dd25bcd90e9dfe0ec085fae72c8caf5345af0c28415a758abbf661dd51d99eb3df72e6db95150e4dadcfc29fccf95cc206ed22e448b03e3dcbf7863eca0cbfab1bf44859fd8657578622f87dce3df903dab4459ff6ec72ef3aa0d39543b6c117182954176fb94bbc7373af328284742c5ab516b59172436091ef00d1fa12c093cc25d86fdb85fa1e37d565d598db789131df3c34a4d03ff95ca61489f00d14b3e496c9778e4875f285867c00f4fadaa1140ad9febdb23bbed62fc3a65f523480cb5505d9a9b3f7eda9cd2f7c352f190a7adac2b3b8d707beb22d9a08a39cbba0c24f26ea604b3f030a3e3ec29499c10813132f8e8f106747f8b912d2fb496b7b1e1fc3bb7a7e6a9eb6b60f080cd0a15438804f3b4c49773db284fe9efec32b2002348cee7a22fea057be6c1cc8935d094895d8b53b4ebd887a8499c8160969538b2be2c7777426c85210b4ef1c8acc2f8cb27d2d37c732a9fe1c8bb6b68b03395da2bf8617cd040e4b79631735d587c7b504f120a49c8fbb9036f6c2a8e79d861dd32c7762374da5380bc1a5e9d7237cd68f79f25013909c7cf350fc50e0d9ffec700d3df4a3f9a13962d1aa292061a93349de6f2d862ee5418c11753817ba21ad794fd9bacdf5e291613aa86e9d310e092d173bd2aee5548b17576e2e9a17c819fad8124a6ffccf5b573589c6ccbbb1c6b587eabc575888416a1ec657eab36c2ddd52f3e57eb5e8530c1b61eaf2f5bb9def5e03485c4bb7c4ec4028db81736419d29c77c910514b1082bd2db311c27e66fd2f9c6b1d5a978b89e7dfcd53b78d243286eb31c65e3c9597bf6d7e99ed46a585994b881a0410540e5ac856bbd9b614e57e5dc51c09b9d15f2042cd6900d8beee472e835d8186347e019fb198fc8cb825d274c0fed8b485ec08941d50121aa5ade7ebb1845e17ba0eddfb0eb2dc96efbe0add20343e053f2961087629e13e687a515659d4d3759291ebc8f2773e7b41c0dfe8c204a1176366457c9f19faab033b8a5b8400ca1453df5cef080f317515f0139bad1ada3a0567066d5b86463d54a8cf03bec3a299f583f2d04ee384e0852bb39bb59eb14639bb02775bbb99492719cc90173dade914b589285cc8b2ac559ca7feae82977d33fb442e17263ed398e0372c4876d61d550eee986e16e96ab3169ad68529cbdce533ccf09f3a019b0a16c602473b3a221427a335093a10ee2490bf96853d1ae1bae156674b2eb4e5e8b284d945acdab035eac6620560be2da63577da6bf10099e04e92ee94ce12ab842f42886fe4e131a58d6e84c02d79653e2f7abb2e3a9a290815c089f2bc8f7e04b156f9bc2a60b1aebee299e405ec548de7eefa114d82e1fd5467b09ac5e8fea9de65fe59c35eb6f64909c4dd35806887fea264ebf9438785e6347a6fc9488687d558d449bc77e99dac76a96ca4c9439a51ceb4a066dee300f3ed2b9d21d57b387d38824bb4ec596df2ceee06ba416bcc5523da1e3ba714c85af86bda30957bc3d55f89e6dc228046b2246f36b401625a032d33d9a4f238bca3b18c2c7877331c9a875b3004d91558ce01d6a71516c86b87b95cb0afe33e7a4a9941f19a7f52cfb973ef6fd1e7edd3b147b988df21c91bc7ba43ffd8fdbc6ce9818590ada6dfb6315c651e90a685ece4396043ae7ea5b0e7b26d961915aaac0fde0c221b32d2056d83b1f18be70d760d6db8954db726bd6d989c9ba6ba976c25ecc8fca14da0694cded0c507bd0e925f66c14c2ab6407c22cdc10b968d5ce4097cd4122d759c11621c1767089aeca3ff237f466cf21d8f28e49a4701c3789200577d8c22bf00a1f28645adb160e2411fc28b534c1093ded9d53733b1046f47ebc5f27c39e9956328ca7b98a04396fa7a256083ea0369916d6e47e60b929c6a00c6c0dde36fcf11a9540de4448b1ee88c7d4129309d1a0ab77a1a5b7b15a2d74a8152acd2607a76fa26cbb11050993b8986e11a716624f4ac6d28f60e91125db31d7484e36d429a82c4fe4be7a584c2d62979cc83d2771216c3cca4553cc860d3b9d4100c0b1f4d8da8f264bc8309038e517237dd065dff70a7acd2491b3baca25b9b8bb06b4e9754865f22b2ac1cb46a988d03f960df16d0c926e99575c177b931414a5fbe5e51a4d319fea7bf3a991680065c242fc3d0b84dd89fac5cdab87d58f51cdd40417d67e14cd605ee54e387d5e5d692dd780d22d2d492aac43e0d35245f4828e056eb9e4c65ec81a7259a02804c6b99afffd6e16ef14e6fbe6dc624d1ee7ab07d7b9440fdf1f0a28166756fc10c4e62eb45d016e7f65dba909275b0a85e58dd822aef48adb24d9b64cdcce9726cf22e634d53e59f60e216c1964525d91701f1de0ea21d8266c4df44af6d2b0ba9ef60a99d7e6d97dfd38c1a435547779bd535577dc12255064c5299d9cdcb3f7fcde3a4847b0e9d957f5069a2be11d895e94aa713f31cc09f9ff32ef21901223b17a327120cb763db9e5e4a074d5aa53141b6c18d147f9215a634d1e3a5e26cf226687999c0f4afbc5aa26bf451c8b9ad4eedc60ff4beca525d4adf503af30b3c9c8c882ef5ea8932a45368c9f653339012e55385bdda7b697b16cdfc99a39bd53d09fee9a94acc20cd6e7c0127296829dc97e3479c749e69d6dfd2d6f00fd86058597deda67aa5222e6f7e50cc502d4fae77ef4d3025060290c3a5a7ba046ca421f4c8273bde6c066f6476f607563b6a73cae9b6ee3e4a995ccc82fd6204067bb319baa48931f0dafe5e4661e858c947a8d2bf506893827b16061fbeddaab2a3c09ad5f634da3b763bc94746a9c3204e0eb290cab08405585fc6f7353d938d3909b6c3d7517a6c41300bebfa12191c4333c7ffbb0f1107f8aba7f8ebbff6fd613ec387d8cfd9d13f874c31ac5ee495329c66a7ebf6be5e85f25632ccf8cacb0bb7e1bbf35590ee3957b169633d3cc4dbd175e2899e5263ac64b4eb2abd6b02f4e0de223b4220d70561743dfa05b21e3ac231c0b17d3d1d1d3429d82f1ad7033084feec3d64c28dfc0a1fb2ad9203ef5a2787fbb033a1b5d7ba04feffee5d82817063b6f29ccf339913f6026f8232b90046c316b8d7ade9c249739dfd66330f4119acd3a3e72d53d1016e0fd0252f24fd461dd865689e04a8ef349850e3a444895793bd9e7b92d263128a25e4dc14f4770fe8b1578cd26b3df9eab5840f7145c0d1a55f617204f92e4e2b5a98062902d9bb57001264913640e1ce47b09e7df5a8f9863f03c1cd42e1afdf35faf43780d1f8cbd367d3aa32fce34ac15840aa23d1402cab63e0f6b6fdc007e81733d06a08dcfc5b134fbc6d94b7080f7ccae6d761c4147eba30e14b0cdd4856c067f24a5ad038d4fe007deab606fdf4b257ed5c92d813e67460d0300100e6345944e2ffd8c582aae1b33860a4550fd6297edecffc5dcb4feb34ceea876e870a6a5864d8475f50d86bbbebf49281ffe9f3d299a4eb904d58805ee877bac7961f244bf92c587b729cd9bf216a92dbf71860f3c36ee6ee71088eb864600821eb3af69db3e4f57b63769f78e5532002035104c3a6ba96a698b96ef12abeea87fd49d5cf04f57939975ec2957541f0733caf69b97cdb8e4d8b7ad3e30863d604f14d078dccbd54ef7bcd0abd4023267219513932ca905a1489cce29214e59d98d08e9b11a30c1ed39060487d4c6bd091a70e44b54fc508a830023dbb8d7df9c143588782ed51768c6ee9f2f9c926614dea1b0164255bf51972b5984cefa65d65a2fc8833db22a3437f7f96d83be4ac8049d114ab7256b996a355db634e6463be7a079df365988dbc4615570a69c4867d8bf310411d7673b76636b5ee3fd35d7ee54e3acaaca6658e9943d79ec1549e00e16896db4d168620337866c8ee99351dde72ddefd81b8c80ca89c520ac3eb01a9a0aaec5ca65f9b9cccf2b32febd2c164ce68284a0e019800d62146e7fa6f3e5fc840772dbc0dd7d902937052374faa422a0bd5f5ce5e51a50bd049c0b058d000e4723a9e1e2608a1c6ec9c1567187d76256b119016ec8e7385f99c12116da0d466f0ffa880f0df61ac82850292e31ae169a601c6749d0f8a212769ce25aeabb642ffabd2b2cafc60675ad324c9ff220b5889a7f7b4c1ad08a6eb99e390ee92043c75fcbf4b494f5012f65844aa31b756658922f11321b93d49b99e655f0a65c5d369b2e8dd09abfd8167628961df6ce0bef063759144e6d819da1c1d2987a21a0a1aba95b15ca3dcf7bc151bfe117c58f747214ca913ea5d6be1384ba8405d0c9b3a816c9f9e54419bd300cef80e74422ec741d3265092bf78482a424ed75057b1ba5ddb8f1ce40c7e5bb9dc9be4379a202ac3c06764883b54b1165f72e04d9ef18c5f6e5e27dd86539f0ec2431ddf304525b3f1e822da84fb695bca1568d4019f5b5236f91be9791da81354bce26c228c07bc55e5ed723aa8bc16cdde2d5519d9a31e3cd912d2845a3d8b7596199624e81b1e7a86530822380f8196aaa23fbcf11bdfea0e1a9f871afd6cd36c4f92d7333c59614d8dd032735229de21176a72b8e88984f0f9b1b2a3e8dc07ee1ea6965231028291d38141c99c8dc1823b3349f45a18e9c44dd1d9992590335de2fecba669fc84fd74beb9c11e9de7a5519bfc3ccaad17d59355ae2e6a67306b14da61cdf3c388dc33ebc040252f9f9d4470feedbcb1a50e4d8be56f17ff6ecc1c2409605eaa0f888ab9e7820f3cf28f84c1f52da2118324253ea4ea9880ae480f5a7967fd733c652003b9604a13d75217e38b0b060b6d7f2571beeab4c8ab44544912354afb1030c263ea899fa0a6e1194ce7d845877454e426798df15d2dd03fdbd78a7be05cdb8619756fced566e4602543ba8792723a7bf39dbe7c0b45cc8e8f52a3e544726031b1d1552f76bae8e485160f8b2da17dc2a91867c18f49fd9986e9b484bf79e53e75e3e0cf7c35c34f0d4b5b8da8ffa8c0d32559e386df064fefca0b4198e8e8876c2249a9e994c0bb221150a38ba27347ac343f91b04538818989ad7b4c15950bbae06f0615e818fe33ee4ac904ae00799e1df3c0495b0ce8aa132866740f37bfce0b39e0eb5ce0a6971eeffec439b5572deaa1d7cf9b5e5399e5e40bf369427c49fc957788d996d63951c89abd917bea59ae4c5293961741d40d889a16e28772ae3e93a442993088b780d2d595002df9c24542e069e85261c01a1498241ea41f870b8d90b3420e0de83f3d287dc0726b64d5fe7477fbf35bfffa5433b4d6a982bc2e1faf56094e74468b17768e70a87cb56dd62f157e4d5adc96464982e6d2d5a06e2f706f523fd1c9304137e85752fc03eaedfe5e109582fa7191c87dea7376c36b4f02f216cbb859ec46d39e8fa441e4df554e77b4dc4c95f65de005e6210a0a1d1594285970b6c4c7d8d6b71a098713f7f27cde171c81f0b9a6078387f8799eb65b33ef9fdf53d9b8127721ac6172a6a4cc83e0aee44c53e2eff0e4ea8159e6adcfda5e1ae7c907f95fdb13381fc7bc89b032bb255b172a71772ed8ac56098125ba45d7798ca93fccef520e178b2a8d7b9b711c2db03a2c873e762f24ec5ba0c64ecc032358a58562c5988d7f57158b2ffe19bc20129ff2ddbeb3c6e818ee8cbf6d8773dab0c330e394adbae1248332d1f96255641f95a7f8a3677187743acdac2828c3ce7150feda83683a34745a9811815973e1a9d0180739bf61740b7cc16136997b9269f11ee58e0923e991e99a48564513edab559ffa194b8dd130e57a8f05fbb65f17c0aefbeb31260f1eb442df58bcec56fb886798bf672a858e37fe370e358271277217c4db50f2999a67e65590b4a10220e51aa7a59f8713e5d31b7ded026d9d0d75e5200a47273b3be61ba2619220be6722b81e03797ed0bf4ef81c6670a30300821b1870a6e28bcf4b70712b530392c84252673e6ef6946ed4ad979273a8a4b223178761b80c02fb2813fe96e95b0155c2031d55490b78e4dbd2bca196abd593ad036a96c79151af09684a1fbbd75cad7db667796591c167f9e6b898bcfd2e854671630fc8bbf02a7e57cacaaa3c5e56b3c5b45e632cdf814027ccfeacee3dbf314632b80d51e1a8f4381b03e8c9f6b651c5775241c139a17bf4a6c99c35fa7ce0e621274db51a793a4a412f7466d7a86cca5a022f79240f03a2a776b4d371eb08f320cafae10fe65e3c881ee51024776d6154a7f32f5786fc74d6a4dd33efe119c22243abf934e7e2513b7d9b7f5927c3c01eda0c4f04a7aa356d85d23ccaa9e7265791ae53d843c04ed0597beb9524d0930f8ec9bd1954206c18964224c47cff61bf2163eccf5d4964bb09e5f1c29882d837ff0282e4d56608e8f9acf537c08ae1620fc603b02945286952d6766e279506289513f14a559dc30cb61a5f5fe89c3fac724aef1baad30244ade270a4a3f97b203702a654bf409f1f37c47503dabb4d14a410ca27a678157f4e45bc4086688a665c997b6cca03d216333e3220aa0c6a10a0f6df3b662ec7efc2353ce67203d3b2bb60135958896ffed3d953108c58de2a3f23b9dc97a67774cd7c4bad104f72c0a3d7e73cb4943a40be46e9f20109ac3a104d4bb3b0aef467836aceb340ae71c8da0e1a45e738015194f7a9014ac3176c8c0d8402c43022996f2219a5ef135d172f92c77c7bd72a6e63ff82fb77dd6e4bc421bf50aa77af583b437101aba6b012a4c1758e07c2ae5f2d73ce290167b7fe51dd393bc6926859883eecfd5c41ac083741e352c85d6fe1946dcdce1668ead5c2d640bb968205d7b7ff8979701270a2eff3d6931980eea0973fe67a9f2b57dd0d740198ed7945ae05047f3573c3ac322a6bef4aa22deb4c5d8924403243be9cf5c425b663f7d3f0d71dbe618728b7b2a3b2ee5f9e3dd055bed39809a58236fedf264ba87e1150517fff14119a7ec34eefde003c5081bb3a42202a7370ced8ff9039d3e9dc09a5173ad478868afa63d12268798b7ab872ec5878439d760260a2f3ed47f1a255f966a5941d5b7a1e81db578545458f5d6832bd72efd8374f83a50f15cee90aed52bdd442228cf193086254315291538c2eee270ff8c8e7c65d592d46ddf785fb520e0a07273bd2de03d594e607d781c901195ba4f3a73e3d4ce204d74215e4c1f6cd49ce292880c827d3ae0871680da3f38a19ec9abe0b0200cf13b57ad4abaff2e1673e08dbb8d7fc2f595c16cb8cba8efebdf7178702d7dcd67952379ec4bf1b3c4eeeaba6585dcd01bf0153b1039a8845dd038fb6ec89d457213ae20a9325f2509b564ebeac7d118ff9d1bff5cb3c0a4582a0ce08ca7c1f1840a517b97920067fb1f857ce0e680ab4cf874d6dea1ef3d0cf6d2f9a0d083f0e2c516cce5e16fe611e91f842c93b4a4c695befd806451a7abf35eea5bb65c00dcecaa05f1243314f43c8fc70069947e5455e877ed8721e5df2951a38396a41e560aee7a4b10d9ebdec7d2bc24bf0deeea01bc3b5b1b6e27301e1e320d8eea146f6542da745309a24a07da5ef24aeed5564f268a275496ef9c1095b072090edc5784e5fd14c772bcc3548e81dcab1cfd6463a7b8cf1ae33b0f71b300a8475b401d4e76a47170dd211e2be1b67db542170aee0ff3f988d3b21a74515c979ab90fef311a32db2c5aeebe5ef698f2bac03e8838bca27a112b13bc5221add6c7fae3c04827a35c03e43788928eb61bb1233d73ba8ca373d60a173ff640004e15ffc945e8f9a17c8e6d0322bbf6ca09c354febab5fc099ef80899f5d26389d184b13014b953e861f5f90bf4e881a1c6a4afd11502a47ad5a3acf06a482e2648b9d920fcb680aa3c8652f2ef0ca1b46f9560ab132b62826a02843582ebcb77b86b55164e22eb2d70bba6c73371ea562f30093e107c66cc3a22c469235cab7632da80243e98cf5af584cbb439c9a4ec81297bf4468afe7e609bfcb18e27149a88fb1d46af17fecb84304b259d95c8c4f24cbd52b6e0e598dfdc7088911d7cf4fd3d1e6c54e27613eca3f68ff6d127b60325c9894c58cdb5c5e67db29ec20498d388ec5de0c2f28bc9216ba3fb5712525db0d96f659cec72618a3459b7e69c5f615a245ebdc8e3afbe55f6efaa7d1e7d55cbc2b0483146874539361b9da5040a51e284af06b9c108d2ca3efcf3ca432db98f789879b870d6cae106f9c492ff3d72990e088540db96cb0588933d4086f52d6cbdbdccebf81606849a6ab0bec9ca7e256ccca61f8d4404419c9c1ffc6f6106af77a7eea4faa12e9544ab5c42b05701ee8365604493e3e5113f5d15d0f58fe913d8fc10e7bb56feca7d4c3eb31a1a2ea7fc30177ff95f0d533d2fea866d5a8faec4e792053fc051ae1b108b95e1549b2fa3008aea6316a67e4c658caa2bbe719ec46344235ca2a06d0286b2839b2a33d6a18754a92556645a0c212f14035f10996bf1f6f053b356b314981f6769e916e550dcfa7e7ea82b5e2bc49ba3fe2a9b58d19e721a484f214e8155cb9bf3333ab7dcf8e57ce563195417cad8ec4f779df36ca7cc441d85c085f99a332a15f7330d05a1c92b169224266d03242a864ab6308c7ed43902cde0063712ea4461f8c7a482c87c2d426fc1dac567e6b20d8f30259430d4fc7d3ea4eac794e5848fe7df70280487f7f8d95c18a786ce20debbe1c9e2a1ebe134831e97cadb67ecb52dcc80f30d1f84d99852479a89e4a70e8c51e328323fae4421cb8f0444a6e1fc21d69f2613111f1cd815c9bcef0ff93bff6902f272fd6df147a1a44a8c084e3bb83665e8ca7a01dea050453bab1bdc5c17535840bead89a35937a85ad770949eb6b11d02ac33e362b2525c2b905d4a799505f55aba1b708e57fead35ae1b66f80d28fa5652090b641cfc443f9ab094c53404d524a83858ca418f6260810a7816205a635f8a2a874ebe227e0400dfa4caa29d7cc46148ad7828ab06db43a966d47fb85faa089ab0d95a9fc49f1a23a633be74efa0a09bf22e9f8e0fccd0e423768a749adaaabcdcc81e120a2cb0e6a6882ae9caea5a7ecfde4f949e46cf22889933ee0662a24500c8ab0723977ed0afc2bf71c199b5f528f4f4ac45ce0fa635ca2d0a63383249a1dbda1ad885421f719e4f7c0bd980c2d3add1fa0387f790a5452b936b79e156907cc05ddc96e40d2a98698111d3db56d8c6d8df6b2954c6bd995a7d85d9866a99605e6000dddaa7ca2b40d977065138d439fed5fb8da8b92d87c96974809c855f6fe67d3ce6ef426c26123cce1930b382867d1031ccad730d89f8cfb267dc9427b44a6517856e76a2f4049c79c05401bc49f11004336b0e8a4024f0e480e34eb3d116ebd82d5a017cf5f90ab890fc334602a91a0540e5ec968acdcc47d8c9384a760cb7408d7f0f4b4001c00f44f227b97cecfa2d8954515b941b69e205a1cdc742c30a34cfd1a4ea03aed957fbd1a78fdc5fb1cca03992d2f3400e5163d9a4acfc665adfb3569e0433fa5811b952195e368aba741f6dd278d5d131ce233e54bacfcfc7cc7dca9d8cb1d7f7232de4494f03397f51baf562b68b43eb512e20ba5a6c828c812777067e0b7112dafef475070f332af17f0004e6f4b6e6f46f8868566b5fd9c3a6905864da4dac2c236f9f9d74fcf67aa0d81d748551f7f81efb5dc0126fd7b40e0dc262860d06f14321284f8f63c1707e4337cd3b8f65b20b09519935bf8141f545aae4a05553101ec13bc5b5ff983f1b271ba748b82114005b898efc971f93b1126268d6372761541e814334643f1b84beb0f3560f23358de73be1bab5b523f20115d674b217972a56c540959b389155b8a4248c2484b1700ccffebdc71c828d099d27269189689a0c04a2899e0539514be9f50544881b0b732b9d7f4e4d19c1a08e1ba6e0231872b2a2830c197338b3055e140e4fd5747d3e507cf0dbbe592cf421f00c760731c01ba61a26fc0ad675291af4c6af58f8bc3a87201131bd7ec7d8be2620a3108211c3ce4e63ef29beca2ea550f0c387a955f4dc828d5f0a90c03410474c54b0648400ca68f3e1dd8d8b840a597776465ec61b71792a1cefa1b3791a9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
