<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"372d5a92ad20e1491535b5527e7be96285061a93636bf5c95accde77faec8df6533c60af2d92768daa590de089fcc69752e87eeea3e81c4d6364d57ec3f18add203e875d57023a4e587783fda3b9dd0d2529f740f82c3ba9e4009050487749d4aecc5063963eb15c4314fdfcca5dbdee7e376262a1f2402e1aae498b8b020d841dccc38493a28fe4090d037a87f58268d69d2b8c4ef22eca8cd9e42b1b6b4333aa3703d0d00d9ba2e4b8bf78675ad02cb49377769fe5c852d85e62f725161cba1019dab1e4a051295afe51b3434ce7b1bd162403f4d1b8328d652c4f119229c545b9c94c57687858a4aafac5ba86552299664238e3b2030651f1ef9ffa802e0f2847437f9d47de09bf7c525dc27bd2fb3f01a5b32d197b15cc7ebfbd7b88d0774fdff7694690dafea8c3c0a32c70904fbc27b26278fc2d83620da1e874c9ebcb6e74b06fb10b7f4ccd1a61ab3728ac9bade62aea98c7bac0fcdf9c116d68c196e8271b4a0ca624fae371e26648454a84ce73efad92a89b44764d20570e0936ca7ea51dfe57ecfa8da7b4bc610b5f72c221de715c7d9d093a9b94a74c19e972ee1fccd58238d77f13f55e3fc53c0828321384fbafcdd2735cb1d3ed3e179d9c41e21ae8bc8024ff8379ac1970ae98d820940eaaab4d17258b3c1afb0a139f746127e1c13a1abc8ade367cbe4c6a53fadf9c26ffdbd5ec5e4625b39519d00b7d8dd43552cc8cab3b8cc390387809b1528f3d50da43dec28a8ca0c260b672af77be9e7535f0e600c24487c95a81682657a00e0e586b59974cdc19aac91af8f9d29b0dedf45cbe7ec9994e7e862eef0d72ba52e677b3637f1a941a2e7808a6a4db53f14657dd11c47d14d567d51afb70b90584b792e27a6010467db11790afd99390147f18dfcd15a5f5fe657681167adf15fe320c00de7002a8734c4306983dfd9b35125e66b99e0a5691f2756ad494ed9b17fc4ecc6e44ed864395699889f5d18898553da12818c2ebc4fed6c7770d8ea1a8258804e4eb21de2d76f7ca46d7d9b99746cf916adc961b135efe9834aa743382b27005ad04365287b4f7d05df53dffd9253dbfb9cfb13873ba47af1b9c6e9182001707cc9b869b7c1c2baf152f9c7f8df170c32b6cad19542a9738161734c98f93e8f6f18869f5a72323e34e8a93f0c28d2a74dba83c174f3a5c04161f4c63b7707f3bc056c830c9019d6517aabb9c147dfeded8485a3f6ac7ef54acb4638fd30d596ae8309d43f7082927adace0727f76f36ad5df34e429ce8540d0f0316918a37e7b72040e771d9d7ebe7684695472e7c4861d818f2177d84e3f7380c01d47f7901b52f29906fe96b56ee915f66915bb3bfa720d4b5964e7809896007555a78133fa5251e9618eb3d3e8166d84c0ab14839c4bcc4b6c23921648a4f345a454aa2fb21457a9e1a68f43f20d60a27e36008c3c07ce376d6de2750809324553079cb2cc7ecee0859d20e2c137413e9a33d8ba52c9de8b01483731e4793348110abd930e5390149c9672d04d4bd3b122bee4b1dcae57dcee01febe030390eae56a22c3f5fd2775c0dea574b7a4314182adbc8d78b173115bf134e1c813101a2154c13b0b10baa7e2141a6be64ee1c81a04c6e3678f8e48042c84ed89521a5d3e866637e54c7ef29c6da71299f7fd9cc337ca6833428843cf50d1281c0b98f834e22890f6daecf5f3ccf64ef5b918d5bad69c7728b14e5740529432e49948356f2cd91583c3b415c5d641eb95da73f99964c550c779d3fb4a1498a5ce45f575b06bc2a0be9990f18ba6276e916532b5fb1271e923fc49657f8e675b117c129aded950d605d3a7b23783ea96b49062cee9ae8824effaa6105a90959a5cb345689e992893e1ecac4e14da5804c4d98492007e05ce9feba2b1f0aa5ee7386221650372455e85a9ac777457708461f5c6932ee8bdfacf6e80422b139f7fd8f29639e992b6cd5399a24a197ce23c01a1a325c82f0f2abf905c33b2f017b435f5f61641f8e71da7598bfca63b60d27107391543253cffdcc928b1dc4d75e8bbd5edcbef6544756d5e862625259ec3f1695ac79e4ddacc6f3204c844d9542ccd7dfe9b96b0657c0391f57c1cfda4ee082eab65b14f9a844e0972f7bf230cf7c734a8d87c8ff89e7199c2772b823415b179725cedad1f3084d1f41c048d617deb8754f683ac4f8a2444ea567aed6db842b87eb7434a2ef6f6eb4bd4ee4e27610a7e7045ba9687c980769c70b62227c6611981ca6f23c3db7e31137e1533bd4d3053e0baa397cf807133ef9e11f1aaf571e9096b1309e259d9d3f0c151de803f93f3341aa24f643db415e560ac3fb4dfda0b63446eef6ca2eb2510ead4b88f5d44ab1b7e39658f14a0f2a6cae5cbcdcc55e2f840f4efbebb4597ea07c89f93cf28a213aae861106e901301d05f7dd3daf3039782a5cdc501912e404470125bf9d7c9dd00c6f95a6b3fc6e32de50d6d5fb2f9b1971d650d992ac1635bc51854431636cf7a928df9b46ec856d077b3f88b83e7c14a7125dc8fc752f40734ea82373913ecdb917a952b9ff2ebe45f003ce6a38a9f88d995973188059567bff308721999d4b9ae7a54140b8a22d93e7800e4913b3bf13aac656b66631014b4ee7862992aacc9f47f4a359b7be1e4a19c4b80cf3ea3031c93d54f1dd782156f178add46f9ea02bbe069eb36f95052b3fc1ad973d9b65e6f63ce5c866079ff3785f0f6c67e40f73d3172b34b181d4d5c199cc8f488a02412638d73e70d10f84593be2adb7709a8dfd4f2213bd576ad2d9eb7523f0dc793de32623c3298d3698f04a13db4a5abe7f54e42cc571578b50a9aa5f4868fa81c305cefc1051d432b8c654bfcbadf4d434c1aca11d217a182736f6cd0667b6a1e23198030dbccd13baa339a77f803d1c1e2f481ec0dc854f97834b9e1a7b99b1ada271a6635e522c406e6d7e1807966bc834a6be32557b810ab6eb4bd0d859581ff3dbe67c97be67944416ead7beffa8b6b99b3e7dbda5c5189e585699feff435e8efbb2c9880178a1518ff7b5e40440406db0215d89dcfed5a06f8f6e750eaac135ab20c98047042ec165e89e2dce94fd83c62944ea80d84a22586be5917942411ae284e5cc95f6709dadfe2c7f6288e869bb03ae77942e4b324135c75071bb0fffc68f4823a0fd19f14085e10f5894fd2278c6036cd5b33b123085a4ca6df11118e6d80e5805de219dbb3d0c35495d55fc7156bc7373f2c4d09d005c57ffbc83f9b54704a37349f98ab8ae2be9c9225a85ac0016c5f1848f6e1c0d838f1db721e94581b03a1289879746a4768ff315eb4eb5b4405d86474ac705fd99f7ace75c7a7b7906b8b53aa3080a47a97238b2d2e446513e6660117eabe6c382240b1933520b2d643f4632fd729439b131ef2276d75a8075dc64bb2a7658d6ae5becf2dc630c094447cbb2f1346aeaa8f4f9e08c2439fb4c84766765d588e72d7a07bc3519e66177946d439f7f7f78a0da9d292ac5a88c3b83453ee45c2c1cffe9537b2f35a3a5fc1a4ea62d8a82a9356fa921d6fab1ccf28e41b016a109cfff399839fbafa575a4691ac348e3215f817c6ce4e79b869ff3f75085f513b4f3e27ffa6b6e27b2d3cdb37727c4586ba3126c6ee5454b69bff8ee0459a2091c6e32df66416279eb7cfd1869021a780e752a05e0bc9d67efcff1ca5d0d12722b63273a1bbb26a34e1ca0d59f7c2113225af5db4ad6f7360c23a881c126feba555401e336cef93e5f9c300bc250aebcf6d482f7966bd7fe4a5b4d91af86370892ac0a8a14148d2e6a47ad5f9b5988c0776288ca298b14bd5c72fb425cf60277a7601f2b63254d85bd5bf7b448e39b34f887812c1d1f353e7879d85323cc600f3ecafd9ddf4246abf6c45bc28572002264942c0d8f6d2558659af28299b8ce7ea2492df76319d5482e3ccef4a2035ced5b354b699b8a0f952c6c4be1b8c427ce110c06aa2d9d79f84710ad70ca6533bc283597ac291da37cc6b1aed49c29e7870520e3c534669d429df5392c88320de0791fc234ed2915edbc9f45d54c694bac9205a0203c59c8cde6abc7d107633c36cf1c08f1bf4e4edea97033e4728218edc5d31a2e0809d6da0a9e58bbbd18224133b9242f472e2ff6a7619649169f18e38331a8211e8ffc09ab370cd5396089ac8ec93ba88bfec65fca0ee00e8c4c53d355e937ab64c0f6a0d708611936df5de63db471f1384221cbe4d984b51d60827be6f352c5a632b227058e17edf5db0a1b9d6a2b9e4af3bb39855d96adcb1b3a15ba58aae4661cb6933d482719a0cfdb486f45b4d19e6831ac329cb0b2f5fcde1cbeb695625377f5b9cfdb661126ec2c671f968067df3df91dfa6effadb68e57e1fbaa1cca4583e9f61c2f0344dd02ca13867eba7912ab523b7e400b0eecf526ff07425a03a3f3143e5ebb79286a9c9afaae38bfcb87e15a767ce6775eb6401fa4d6e134a50b35ffc500cf852f440b5486ac8c7c98dc533e8bdc1829cf287abb22db63aac317cee3ccfc164484ad63840e1341b1a9c8a3e1daff41ab5af60b44bdf161358897c0caffab0c5e2533ce6575f492511941e44652c182218756ba39b85afc418f51c2c613c0af9f402f7ade51763aceefa74a9b4587070abb6a733ec2b1bde02097d3e98c7118d4d49d95d28d4243911b4b047558f80c41006f450b772846c8bc20a77a79ddf623e553b58281d051da3d27328073e8bb67ff8615cb929c8ad9bfafd5fdbf5c87f7688e54bb4ce0e51844d4e318daf979d7b6af51c8035b11ff9c908693c47e389a8bac38c46e9bf932d600c39bdcfb85b4256ec35117d833faa56faeb843686441d1c0af71151d9f4670839f7b6010101af28fe63ac8033bef0bc65a2dca552ad6356b9ea063c2611dc7eeb0f9c41304b81f23d7de85438a826b6491b24bed5309651bc4126c630fe6590ebdb907a876d8a8c1046dd4856b3af8c2a9fb16aa0a12dc653ce3436a80a482139e1935eaff8c24645d424bcd8ee5c60706a8f61a406ddd7d8c88d28fa42a18268d8a69c1147fe9e6027b20e2866093ed10364483846566f042b5d18d69769314cb0afd79ba856c1bf77f30ee4720a20f8744cf09e47185630d17eed28a053c7780ca2c8a591ec3faf84c367517b2cbbfb481649a0990ab073af3346cc3a63d039a78b2f02617dbe6929647e242ac39053950ece1d9db5bebbd2e02ced652262fa878237502c3f79adfd26b63ee581646ff4d3bafc476e4c17b4ac07badc865e1b18863f66e48dd237f05db3d4b1c95dc911e219dace581810b7b6018447f8cf783f338dc890ebb32f06b2693338eeb5c1821b10646042a0bd85ca89377f7444f0158474768832c075af6dca9a4ec3bcac90f6e45f1b7097350e162d4a0a38e4679311d8f9e5715cbabda306788ef8953fad59e263ad3c15af7aadd6929b345edd7201af197a509ab9296fd45f564e5975672fdb9a5f860718e9c024268e954f5013fa3116691b8b3fb6c0aef7109ab15cd99efa1730a298fb6105c31489412c4b8c7cb23c4c88e1e7c0292b55620e906cfd7cef7dccd4667d799dbbafa6b87365fede2119e41abf442360feda7347fe6d02a0791450f5ef8f3493e3412ce145e98b0b784645e72726b7916935ea26eecdff9e40068b76c011ecc2f2d3625fe4eaa5d7c1d5e54060c7327780819c929caaeb5e5c2f079ce3bc533a937d6c5d4ae3cfb997b6f6de6e88b9838122a6ce6daf8ef866868aa7e567beae4a56d644e36151a74c9ca8cd21e06d05b784190a270d3a464d9cacdcf38bac53d5ae84cf255ebae209181d3178aa4f6bc00093d4f7c4ed3a20dd3ef9be2d41da2aafa1dd3b35029768897c562b775a03a823efce566c746b8aaedbfc746d8a1db75081d5c1487c1c89afb313bcbaa16012cfce6e60d51642bbbbccf7892b49aa0e79540974a7f205339bd70561e61f6dd4d36586d5739d64088724263900ebf3ba43fac31e02f8419d4f154c240c8146466c7dfc2ac5f1fc7eec3be6f78b1eaa29acb28fb5493e10153274314313cf1ece0ce7161a645a362badd0b3e4649de6c78f878b4d14b0cf4e3981c95388082e2a478e14f7be19f5264780aafbd011cd4256ec0cf37ccc3fb2980fb6d916cdb7cc0d37d1096443521612e1e0194ec0605aa8cfea8ff2daa8b45fa59f77569d0c5d623a5b7237ed28a8f08791e7450f9009e2ebdc5e7476d8dda272d1f238cb0f0198aafd78f106c3bda0e3b261f39fe87991415a3fd441c1d70763c1abac7bea5b3e32dfda208f40a0bb5825dadbe81f893fcaae990b7c08fdf459a01454597bb19220cb9f965525057d3ee528aa66615fd56516889d21e951ecd79a0d7d650b808f4fe7e324a8d6d590cd5b15c1aabb42bf4b432960e9abd95a38a6ee476a2c854e6b896b007bc154eea35c4052516ec35c9b31ab98282963ef7a65b3371390ed97a30de6236d5da6a191eed5bfd8436146481f48acdcd07474083b4857669ac392a43fc07ef40f5196b4f2acda215d44580d3077738b82beeb47ecc3e3181d07011221aa3c6a3f3c035ba23c1a837dcee85b203acec2187600ee89c4df6bfc4b6cf202147829a0e8ffda73154b47940774de6512427d1dac51ffb647be36f1821a914ba1703f2efc819be501a278bebb469ea576f532cb1afc07e71508ea4fc82912f4aa0769035bf1efe6113aacbe6d3c33a5379dc992ace63ea0a1d8d6c1a9981ce477240be74dd092b34d94417bb7bfaddcdbb17879e982e463c93ff58e6a439abad21c587b8f945418fd6851cd5bc4c19afaf965ced8fdb6a845519b3c22d53136bac55fc5333081e60727a2491cf63f97d80f482d0f257c841632c71839e6b3af67b26b9e18ac098667dc2b63042feecd47065dc99cc3e1936be735805197d688268239de812f0d93aa86fb15fb48287511ff749fccb495eb82907ef864a72c7e11dfed77780f08be39960fe5eb86d42a000f5bdcd609f6c6b70999176ab8b048b6ce02b6b07dbcc857a6bd7aecb216fd116f41b1155bb28f610ec641584b053fe96f07ead86d61cb35de74f96fec98d58a6f4ee5d2f9f010432c43975afa1d7201ecef9b69e2321baa52ec5587f6a87a098884e7479955463d0a7d699f211f6bfd5e30e8b108a78e915b8e392d5cc0d8b2902b7098e7fbce0c3cc0056031064881d3f9c9c432f053a79567a2838373e4ec926dd4cef37db3fcfb6181bd9a632145bb40c077fb63341bee0f116f29ef3d20770e17d8c036f51032c8acf3407a1aeda6de01435f0459cd719a19bab686e74cbcfc990bf951e5d18b77100f6bfc5b00bc9e1889eea8da4e6a9f6830ce7b07e6a4d942e1bb292dfa6cb4bd74c663dd4c2010d97d64294bb96cf1b998534ba2e99c65c2bc8058614da8746d3e66ff8e2ca1888f9db07dbf7803b8e36dfd7a7eeac939c519093ac705a5b32ac35663b9f79205fa5bd8e0a951828dd3dfa2de3648b644f65117e352dce663423f1e34b63e959e10929363a4ee13c5fc3bc4db402b3f476a33a34721ae967620b723bdca51ef82dc7dba6d4d2ca370952746f7acc555b7574c0a708862a7083489188138422d6bb02618f74a91623a8e18e139b1ef35ce020699956272b7f2b3e4eaf7a122850f644560550a289be59f998177fb1bdb6035e75b70c7b29b261212f945110b86abfd29d2a7fadcf3f62c0b0f7d2e46f07e49f10efc0507fb8a9fa78ed5c4ea819ebce82fce98e5116ac6a4a9193f6a33b9df03869e03c6ae3a27249f6019b21dbc8d326af6674502dd764c1a35b9d6175da9a1161a9b54ddf960f3bdfdb9cc1d47c013e8e93f9f9703b14b3c1c0ff90355900ec9075109603e8d570bcf9f01e533c04c18d0042127844e3c6073e659708b938eb1782261b0eb8c109f33282091789258bcb79dd849f57fb5aaa8fbda9fd0ad4ddfe7d8f993e86c30f2a4f2ee2c1884afad0ce0ac93ce61da882ba0480e68a24a1bc2e3fd5faa416f5f28c78383e69c3a99c3e50ea8e6201dded15ce466a1868873bf64a50e6b1db030b0d886166bd4454adcc8b3d44daa3d33f27125609eae26b3405927c92c6e5e486188bdc29632a15a3e727023406c7c6ec20f4bb59722a6d784eb3fb6bafa0532fe0d4096b6ec82a3a27841a9e6d3a3e156bf2ecb68826b32d46e93e03b16f512e32045f995f46abc53e93ec7ade4b16342adc67190c6582f7100cd0bf377e499d120e8c120d6cd17fa278eeca323f16af2e341cbb08ab8bd77c202be3092f57c1340ae3b50902dcfe1e743bb0a40606caa1eb940899d7887986175c758b3982e6c83c61dc4a317c1ea6c2166cf0cd1e101bda1a124ee350258c24cd6301c7543eee920e73348320f7c4799563d98dafd4cc625853d66a1d77f1b43351c2b650439eafb69212bdf0eb957a0685223c97c527c64ff05b79cb1b91df1fd89274affdaf2e5e4d4bee7e851cdb9de248f7b2e19470645a0e40685fd38e205d1347211203289bc2ca900aa092387a0983fbbe05a981e7686afdfc8ebc035d1cb2bf0959d69259ca263a93ed4cfb048328fb1355c8e6d9159712ea40d216000fdbba8ac2e1dbdaba8d584c068f9a71e97aa1c897556008914e92fdc035325551e198c8ddd84670d2281b74fefe4b34a4f1768b3756cfa1317e4400e2778a6cf42359d736a824cb1d0d117d0277156937785e3694b4998fc7c060c77cbe4aa6e1b5354bb8c6851800ab11b37405e4a7bd97ec10c3e406ca88e3729b3ab8e5b65ff67cc65036b5d88e95334b6971df50a76883c6daf0b0236495b793bc6057a9ae1ac434b8fc20d9839bd4a329ec586f80047daff93989be68cc77bc65edf370d41b6326d2c0b99682a681f6b3cdf21e8978683745c92ba1875e31c7a579003227ab6890b10c09d3d492182dd85b61d5d2f42c3df01f273c29c132eb99f66c443b2226cc6cb199a8bff491f6aefcc7fac03ac7fac2b5f30702a12040bfe359aa95c0b725316a8d25bc4c18311823b73a5d31784f35c4baf9f845c78e9cc570ea8770cedc6e157fa6d31286442c5aa5942e54bd1b9c4503196bcbb55098cf1ddeeba1d04ebabe8bd86ce77bd40dd447d912566b82cbcbda1b929ff95c9063301a5dee2120ca6c7a79a916532515709d6c71cffebffe3d0f8b877907efd6923e92ec2ec2ce4f0fd55c4f8e44d80b541593717bcc0ae496b86566fdae1f6a20303c0134bfaea41a452d647729893b2ac1dea47aefeca4dad094f9d248294f44657e2c0f9591f84b7584921e6dfb365480daa9c5925f53790d51ca96f16cbc4218f39df2ad11959ce217fe35999d4007af02bc494cfad60cdf5a271b18b3e09d72333ea3e5cfab8a88de66ac63967dea16c666129b72eb83551861e2a615f02626ecd9573829fdbb12b5dc618f075333b532427762dda8a7519b0c3c8450f96dde19673609c26fd094efd76ca8d689e56e64fbfe18f3d554d40d4bde0904c27f53cc1c2a93131b4901b663eb24b4626cc13706c736ba97e8668641abccd0bb370fe37fe998be1c32f764cb057acd650072fe706ff99b86b8526acaf02b95081f76c3158773b3da1e07fcf602c7b7c9327339e3f8c2d2036dbd40dc8cd79134c7c5a7f901dca09af7c77c6405d23c5739091cbd8e01be19255fe413d2662bb344cbbb036eb994989cea279c2755d70f8d420cfae66d9554f0c7c9b2127bb95bd686da5514054358a73aa2994b6cec433a1e28acf198ef857117dcb6331bf505de355913d320bebf81dc6d3d6b7fdd74054c73e6337e70ae617f70e7b294c62358b6eb2052e06e7b3c2390cf50859526dcc0ad4c5173e9667bcdaddd25d8f792e3d04443683bb5fdf70ad3772a7f0ce7597f660015ecb75c7f0ebd34a59f721e1a0caa60975493dbd52737962cb15e2da84aeafa22b2693e9bc92f9e7d6162e608e30b0ff8b5c390c0a7b2c6a8e8bd4bd57fef6c3755cf1c522b7375e30aeaae923f5f113e4045a27a6a4564b4cd2e92d2ac1fa546843bc37062b8d825c4f2d6d6564793ee65a80162d8b5b056969f3dbf5bb128a799ae7918f44db7730e3b062b85fc5c9d78eab3c5d5b2cb3555916ad8fecae96150af8458fc0120be09711e4e9f96b48bd94ebe5f248fa7b7f77981de0cbbcc6cfe91a7aee02ff7cd39daf0a265af0ef2c74845b3841f863067caa0bf323232fb21601deb27f85bc62e7d972d92e9c9bb350d8fb713036d38fabce535cf28c5116106dd8ba6450088f183a61783f505b1df9a63222a3e2d94b9e1edd14f4b955042da0fc99ee6cbc4e0ba24abd5e6943e386d7607bfe6b62ff852a08c4ecb1f526e572548e4974eb60165df5df631480c74f674ac937f98c3eec43ef6b6c4b1c731b51110ec1d5cd76cf470d3bc3483a76dc1ccc4e37002f0e37934231527eff1560f7379fba665d186ed050dd78c6643b5d397096aac01bed257358e9d25a98055b5a958e4e4d38d4504e51720b0d22fadd892b15f28e6df0423c18c0d1e3da6a70797cd8ac11afcfc924586bcf527d100952fb020843e8a4778a4aac737040ef851a72c387ee5a1e754e6dbbc82af13663f348b506e8958e7ee0342812d29e92a852373b2e881e0c6df7280729e06d60b27deb8488030e8c97a466fe9f54fd6bd8ef607e2f7faf0b853591451fb4c18ff0c391e670e283d106abc61003abcc635061bee7d2db367a02b325e52334834fe0990efef6818fab6335747361c6c2bc5fdc30f1870b66b712b31e793adc87ef70c25b87626f12c629df481025d483d23b27364a63e0ba7098557f6e67118704e6d0a0f75fd6a8259d0ae08467f513103ceb6e23ac8f6082229fb1ffc65a5e1a5bdc91c18f56002ed9971434a1b24ca58c86b6802f552cde7c705518f0cbe13998f9a1af0ef6af2226010a314d4e7e804a952801ffe2299b7eb7229996190b775bad17c400908861d7c01b74e2d4453411e23bd7379fdd05078ed7f8021aa6ac826790fd3719c3b38b2dda1331a12d266835a39b0020a2dbc5e992b50b8949298267cb7999fa1c891fe57ea0cf8f66867c75dcf2cb8766bcd4cc8fc7b6070a12cf8e0aca1da8909f8b70fe2c7439898d6048086dac3212073d69e1c332d4eb4e47b6cce55b1bcffda089cd89db7ffe0d125d62570785a1ee2e00619f6cec8caefb278ba2a7dac645ce11504b83ed3f699089273f4c1f77acb01196884dab18700df1b32cfe86fde914e27253c1f67cdbbdc9d6b60dfd3fbb83dedfcac8e39fa1b8cbb0854744aed1999ba5e9daa052acb412e46efd6fb8eeb3bdf5b7b85c6f3923e5f24dc83e537043983afcc788b00075c8a16cdcd3f50bc0d241e37205052fc095814c52f7724e8416a0735504463296cbc503ecb3e880db2e262f94ba140e7b726542a1ee93e3d948bde6a291bccc6d43d7a926e0a0148e1f16b5b370830f04058c435a2d370034ebfad4ec488695b46ec252cb50646e7a1a35a04f88b4a1de52ed3c2caae6cfb4840ee2c03e7e63fcf573f934ae948fe3df9aeddbda39c3bb2b50eb5258cb93bfa78466cd6866df49244daaab37ae8b47a2e99f082c22008b99d992c32cbe9a05b9b9d54e1852268dc1456415d4531f21d2a3b7b2245bd65ad3ba228bc328e9d676bc7a447393a96a6af8a91f7791a08168091ac98426c7602283678100253b3754bacad009bd831ee48a3c6d6fb4cb793e9997925c4f5b75d232e9671486f0a7a090789e5482dedd7c4ab66b37b78964e667cda3eb91904538c7cc90cb8dd62ac043087e7492c364d39a7a5a4161aa7d472667d9cc47fa365403ea3053bf9d216ca430abe355e0cad2d2052a06231355b577ca9ce7a5ffdee0a0da24453cfe2b71961174aeab7dbbb44b349140a36e4831598114864d9588745aead2e680554ec1410154d0369385a397ac773c6377d655965257f3830c6df371f1bfbbe13696a3d86851b738a7a1f3f1c6dab02673bd2254df3ab7eaf3c903b374a92a7eb5085c984f3e51ef5c7168a7899f1265799fa866e506b7ae6cfd5c39a31639d03118ac9c85c9c1487134ab04fd60a520bad72fc81654cfbafe11d563750da4f777f16c1446d66b43ad770204f259c6ab39311a753b20289dac0d041c52b1f57ae7353e0b732791f9328a8d8728b913ccb4930bf4b164d42ffa2fdb6f5e8b97e819e1bfaa6aed242a84f6747dff4550aa29477773dab45fae5c887f39a605fe7189e059d536fd95ff377d0a60d02db3129426b49de08fcabcf7d4c5bb17142438b79f9d4e01493c8d884769b2d5ac1169542b451acb01269de2665c36a18a3141d414f89591109ff1f02ea281a26037adfc043f4dcc382b9b89857a77b7e1348f69cd17efb3a92d78fe4e7983c2d9bc36f48e16958fa1eab7bdb692c3b68c3c2b3672c696233fb6ad633086af749164cdf45fc5a5b619276002d65c555eedbf5b0913183547ef14bcf27469187af11324a9bb7fc36e75278351884d5d1336acc6c616d7b6409741af0a112804600242aa9a0ac47b35489b219835f735b99a5f5544f096890748ef26506ba09fa9e6f17efebc7a6bc2165f201fd26b25032962519df3db697e2e8c590f4c2c5580a81f7433a71ec22164231f0509da965867ca7e349fc2085fa7032158e7ce49db7809a9faf46f61c4816020ef6a2fe7c6bae9c8060d1617fda979c3e126c1d8920c5e2278ab9a5f3e16786b161faa1e13b195e549cf384ae2a2a0fb7ba192307aa777e58373a026cf2ca66d380705022dff52a1d337b6386de28a4d96fd27340337edbf05ade77122cadd472d93290cf8ed5a1668cfc22cbf9525ae0b06018ed7e52bc107ac8f2a4aba0868350633fd07ffc266718076826af2a4edb557f271067561289d7cdf92b42e17d051517c74e132519714f5fb986ffa7ff1f0c46b08b842dcfbc6aa1fbebaf8f9f86bc752dd2579be74f70d16091d18e536cb204e03cfb44d04ead5e501b756d5bd97d0f58b4df9c9a2c80bcf32f94cd2c7d473f83c3b1868e3427f7ac9523ac04b96cf42ff46ba028c8dcaa84d37d75409ea20d575472bbe388edb9981e2c9852907262ad31a1f3786283a11aba887a0555fb5e4ab63b8407b623497471a981a4464506faf82351c5812560e3c74490d321e22029a2254c6927c2bcb4c8331dfcc0a5dc72a41a7c9c32ca0fb95f5ed2ae35628bd69cf03f061f8645515ef5fc0cf8b61b89afa2b702e231ed18b2bf86cefd1cc1f12c6e184facd0f16cfe17e3ad13c44d0feab9ae5e805be1192fea5b2180ea15c09c8ea586a79c9c7b0a46121f308f7db374b8048d3a932db8e6bcd2707afa82ad48d7a19f0d9e22d6d9b78105d241796a6555173585a73b91468c7810a9a01a65a45067d4d88a87d2202622788fb5bb4c40cef439276ad35bc63d0daf92d1cb1599baf862c9fa6210c544a26c22569ddf13b9b85ffe2a53d5618113fb201a31b4e045012bc662acce2b4427cb5dfe8168bec5f98f7ca46bb7f90056d896035408f0ced9b5df23d42769147e31d43fcc4581aa3d300361141a9e90b19d9190c9a9a6f2f2d6e4d61e913c499a3a2cadacfffd29e927df69547ca311adc486a039dfce8899a793d57b11deb3a1c7bfe8d5e4b3b12af08b856ff707557b27de57e9c0c1124fb26ad0300ddecb871682cc758340e33e1f4f9c2fa63d594a4282a3ea20d5386a7982739975bae9756489b344409bd8dbf03b76e1ba45976fc176ec8858038ac39e402ba8a37ad798287d9531f91cd6f7be3b6d4549befb79ea10c52cdf616123f69152dd2a5eba04241eec7587b74fef1ffd1bffdc7f55fa599ddb84752c563b4d6701ab2524a7a7c5ea7ca03e5da5bc55c3cd2f44b90d039b2845bac62c12b685c7ce317ca1b14fd7a3c4e4765c513ff7d24f43a6f4ee19d2983a269ca4d6154bd080c3140f96f54fe1e047d8f35825b328b30787732cd98b57d13b5ecda92dc036de75c6516f91b0e6734fa993ac3b35506fad3ba968404e1cf4dc1392da637cd345e379c30d2f7cbc22a9b376f28f98f60720a3bf3a731edd06bceacd0a3e36c030e0b8911d149da976ca2466efb78682274ec9bf358fe77dca82fd96058657f6a7253e9a5f463cff8c64db8fed691180c8d896df79635acb3c0febdc4694e20196f27d81d22cf06efafebe65c0df2cadc579f38560f98f6a09cbcd9e7151908faf8c9257b03a323e5bd29dbb3b8b83a77db47897d2570c05646fd2c0d5fbe97f2640e3ea53ee912c2c995271d25a1ec51144d3023718b1923ceb63e3543292b574b9f00d192d132b324728676502b398fa93c45b66c47d2c8e73bcc8a52a7895f80149c989950eb4cab8ae4f318f52b962a846950e357d901a9956c89e5f6f628e990a8509fd568f1e54e657ee0002006cddfce4ab5c09556a2800711e1472a9b1992ecf8310cf015e017fb5fe61bb1e8dd4e34525e29fe95676b054fe783bda9390211fc1c87c6399ae4bc075f80e5672e7b01b1f9891d74258d677c2f0ab34682dcedbe5819469f319a65abf06ecd4e60f58556faae49bf1272cdeb870c805cee8c6191cfc6f9956e468800161608c1a7d3e196ee9f9d5545115ffe09a06d18eb6868e4530294846c8cc5d7bf256bd30d46c64a2166b50d0cabc8988c3b36daefedc336c63ecbf91e44b34f4f898f26191e07aacf02c37420f0a5aeec50802f3c0c80a1e5d3ddaf6493f5f564b39be2999428724a8bb32d924e0868d330124ab60a671a4c54a57f5b6182b678ac1bc7880141d4f57809935efbfb7cd40f9bc2a563a75860387365ba4c7a0db674331573582759d66446b0ed6a522cd68ed80b78c93410f92a7af6328ebb44bfd4f7a02d5801b190b407e9b9406d3c6ed63d3383d971c51e95e3d1e202364e5dcc09b2ebb34f9c87d189668d7be5848bc60ea075d322bf92f39ceab7905ad0410092552c067bf5550b496e526490f35fcc198647aba21e97e2fc10e66e79b374cccf9a051cc4267097daa6d7f4e2c95b360223c7160084dc912e35daf3f7b9962565ca015b3610f63b8c4bece55277f20cb76bc70ed428cb552fe2cbc1ac3ad4e730ec08db6a48361c2ab533ea87ff6282a204660ac0542b95460ffd3feefe0a298d58b833110d35593a7b6ab25d42d341e9b1598eb01ac42fbd4440fd98e71f475875bc829be77fa57eafa19b058f7bd88ab8f5acf923b9622d3e145223d78d508cab2101c2b78b080c1bca1503116e2e41a18ec1a127683caeab8134e8db1b230752764dec6e3554aa2a68772d7ba5cb1f721b8defe0572e991da8810c00c47e7e1bfae17d04d1f8703e5cce26a8be0bd3de0560c9a6b1b5ef5858b6c8091e0451e18c178d8d68dd4cdc166edb63b47a732f3fdcf819a6a17200a3db8911dc337b048f6c1571348ed8d1c128696b6099ca175da88a0c756e6571fabef0d4fa0321ee802154481a4b984dc788e8c9b1b68a7510c59455f9b1d8d83cf99f9efce7c27e471d2d9ab25d3471178e38f3c73bbdf0f91a54579813678287f92df8d967e107fd51f05f62235800201a07f1b0dfbceb7c032a69dd06ac556a3627681aa1512818e9bc6b6982865263d9acc59e38e0c3943e1453f8daa558f49b42be051d74e860db0dc92383dd2c157c7baae7e9376dfa9e3992552060ea2b3056f605601ef1fb6445d7904be32bc6a009b7647f988a6535241295c68085bb5d1a1ab6ca2f806e56975502e64049f41bceb39a80196f33fc767480f149e2eb87edbe34775ff19414b9b7db2bbc2326fcf1274e32de75da899f594cbe95bb7f80b0cf97ff51b6bd7206983cbde18092dee93c8bbde50d9f4157f68476f96ead224cf37126421ad6a83ac15d543a1a4ba2058086720a2bd24f6ca5be4c933d9627fd252f683e64b7f36aa313d8c2a236a015883493df8f33cdbe85228508feab7e13b4da5f2c89ca6f991926a5e686f49e6bf847aa0457ba69c8ef5a4f7cc9572be8f0e4a6976d02785eedd9f74c9bf5d7bc35c39be7f02fdc6a9473f20ffdb53af5a67d4957c5f59dc17735db3e5b959d195e3c35e0b36491e3feb99f2eb94a577e39f697ba0503d57ad4405a2a476f8243cbe6446c1c664bae8b4852f742190a3c9dc847ef7212731822ada54afd18e2b5f1f71ece8beb8f18409625308ca6640b508ee98d4555233dab17ebd2667c65a40c3d189d06fc9f31cc7438a3936cbd0c28b88401182a731e678a163edbcc3dc3670df490b3bff91496600e8c3e05aaa8abc21ac593adc5817a96b4a9ee17794a740580cd20978b7403c84292f0d03fc8a07a2a162303c7c835cf30a324902c5d2432841b10decdf8529eafc4a5809f36e4c32aec47164ef35d3a09265a6f012560caa0f046d35060f6543f819f8d95a67fdddd4ea5cc89554b97987b7e81cd07d6c81fa927a818db42790612209249b0cba9bb8775080a75829e5f75a13ca1d25fb239bad192de1bfa55c1b4a4a433227bb9c83d7edf2458e9a33621e981ffa7b1b98e09b69104a373a890008deca38d826c86898938ee441830df1d66941cb39752a7b9cf70f380c9474e5ecb376543bd3a854b71ac2a08a65e6eaed6ee497c26e8089b93d215a8587aa8b2c35071254b406306777742241d22ba7bef0a0d38bec3448599f22092d83db5c8ffd4935054f9f3c01d25056bfbe722a723a81f871618afb88bdf5fd26cbde21719176215c657920f7452327d5e4d5af10cbb458b6775131a71e2d3a55c71aa7078f1b0506358da296458f35fe1ce5a5b4bfa37fb92d964223d0b569938a25acaca6271d3e9b27eb04c5b939394c698252730b8a0c9f2038a59abdb0758a2ab273ffc465231bef5400025e53f398605a1a1a4322904af4c43d1e3a4f18f5c0e5efb5bcb91c2a0414df28afbd986ddd394e68fac2c4bc8a8caa0095525547ee98121be8664fa75a129d25334759548919f0408437fc6f78d201f0ff9a062872a8a18584ec59a50fb76b58ed4a1e7b67ced2d8c2afb2356b1887fecfe48240cf88fb5803849a129eb8f6335b5decc9f5e8febd6055456ee5ffcfa45c0e0e897c1ee816a4359e8e53333c4a3113af9b229ef73c97554b0eaf2212691735f229247ed5bbde062a6d220640f2bcd3d99690ccdc98b1e98ac6ae3ef39011d78c5ab7bd16a3ecce956f81175ba0eefdbd5ec42c64a5f7d268454acb77f470208662f2a74b97dbdb1396c219d71b505959fa93c7e3a57700f0268814dd8a760934a00254bff1a89286a14385f59bf74af84fa0cc49135a58ce3999b042848b030fd2ee54c54387ba8e6e35f538205c29570100d7bad34d8cc05e131cc2a24a6cccbd56f695bb5739d7f78fc3a346e88c2e835f684f656f78052795b3ef4a0e45bbf2ead83b75e620f09e9fe2e4a09b6299ce63f231c9053c25ab12cef4389dd94ebf397b31c873354a3813eeb4e99be26dba045402b94b2a83246cf909b24555e8f34df3d03eca2984622c49d8ba2891eadcd07b080b63bc0a07342b389857dd34f57976e610dc05aaac4396d55d4604025ee33935229740e266ad83b1b3c627e8bbf0d4a4f61c4d1c4f909fca7bb444ec0c72692d84479329a2410f05e9194c071ad7e5b779fa5f513fadbb96deffda7ea8972454dcffa5b2ffd51edcd38548b7b469d7979fa6e705ec19c3108a4e51b5c088f94292bbd0e1b26d04596b546c51b68a11c9c910084c5ac74d5c042a8075cd358a663e1ab65f3c37929ef4fd99a279f4476c7e48fb871c2f79c40d4735f222866a798c5a63bfc3d935484b2450839c7d7615377c637a66e15e17e85e98b5cf21e52a6ca4936ab9d7b173882909a65b2e8ab1ae303b5726116036b54c5e87309ae8676d75524b224d29083877879a8bd7ad575aa268b6edb4e3ea465207ef15e6bfde5b5844c02a12c8e25ea63ce201ac24a9e64825ddc6e1dec7d5e0cc139264ea0b554d9eaa87e0a93a007079f6eb2ea769d80d7c3011d2644e3eb0b7abe8b16a3d4104ccf9a8e48023205b6fabbabcb0d9b002e3652756ebfca","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
