<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db2919c4a1d012c17ddc713a7bf2dc8282c0324806e4118398b9d0593ffee892bc888aea9763db88847fedbb2c8e519f01666f1c3adb02e9952072c8902a048f32b3f8d2ab7928805b12f0917f8d751d35cb38b4f772de83b938535d8d62a7c9e25fa2be6b29561a396c7aa124e98fd3da0c2bb9d126487b19f883286fc71b92635ef56893110b37839e2fc42b46f3b44d71bb607f49ee35683237c61575eebdcc44e401c7954111dfb0dde44ebfe91fd7b02163ae0bcdbd1ee9f5bc636d9dd49ccb44877f3fea8283fa3898f4dfbe5f9ae128cde5082e0951e228569f51e38614ca5b2d18a5b341a46e38b2525de77da007db420a3788f2458ab14b4eeebe9f2ce85a2849b1f9b24fff017a33b7c1daeb615c9c4117074cbaf42e2d4f492daab7685afbb574666a5b3c0dda7c0ce2ceac9edff257d63f8f7e35c08c9facc76c7a0096e43067249ab769205acd37b44e93f9a7ac7a5bb246ecaa71266cfb68cecf323c2450b0fa4b14baf02c3eee2fd5999f65533318fe4773323287c0b65a5ca42c5457298f7d1ef9120c755df9172ed38691e999bd14c55f95384e3d8099af240b35f22476c573bc086494892944d317d5d3ce10ea2ea4fec59bf922b9cfa0cabd24ade7fea79cb416f4c36b5350005686e3af981a79cf1958282b4e161ccf48beaa946b75d715471d59bb1fc64e5d782027b09f5498af9250fb35f7e5509cf675934dfbeef6918e4604c48edc7e660a2c818f843611fa33b6041a83b5312197007165666e186da75694e1573e0dea6f33981e94626a9bae747a06480ad12db3890a1a047ffea2c5c2d52d856d8467628dc7053760c94b978e80bdad0c59a9b670164653645db8fb9f85838d1b16ca54384707fb08d73b9b618e4242fac08443b5fa5c8ae30537b47cdc0e6f6766417b40a3857b6ddcd7d0931044434f1061308945ac738a8e4d8f2c680e4a09e7a65bc567022f0d7b5c08e32c63b38c2f9a571543326e55bddbeec1fa2df85423d6b9c8c3b3698bb6fcd905ca9f7e90e708652123491091ebd6a7d38f9f771592fa262640b09124d59b0803b2266bf5d2e34011d907290d1c8886a386f2c6d62b26c1f3c06da516190908c3d8f1e6047af0cd9c959fdeae83794a8255d7dab9416d998a4c6f74f35fc70510f7ea46de1b7468869934660eefaca02338303731ecec7ae51ea55b763f311c6d42cf44d69ee1b839c748ee2f3d3b2fe04db960a52eadfb22cd746447f511817e3095528348d5d2fdfbcd009be39b4b8a977538b379acd5950a091c423b9d43c0e783d79a6e578b3ca817f14430e8e3dd93b1ee458fafcbc585f9c8a6a2868e8d19c8b5bc38123abd56c5896f434bb346854363342ec3472307125c78292a84c30124e5625e62137bb6f79857fcacb890528bcfa59fe1288d7f2fff6293676af6c1fa63de0d7d3c3f28745fd0d468312e5e48dcf9075061f5d589ffc5b54678ee43fdcc2ce4d8f9796128fa61da9e922086f6214bca74ca19ea40afca30e05030e80d90e05d9984fcb38b3afd7a5ecfb83f65b72c9ae29a6e11f1548c415e576e6af1535c73030efee97204e380c0a3e91223384fc841e9aa0fbe9135e9a32c11ae8d51798c70c7cb48f14f00134323e04a2e7efd3e4afb52c6539d5b9b73f9461972a2bdf23a176b4c21a123fef69bc7731adb562dfa8ee3622105ad5599a4b298c7b901022ce1e13978cb9aa6d68a6dfb22e8c115ec5b93582db215f989a627f7bff0c727e120cb3738ad0bbd2b695614621e526d7301aa7b57dd23c9a2e819c075e05852ac55901cda0621a1bdf4bd4849e410481849b4f92c1a8835eb70629a81a0d26828104f8bbc57af6a94fbf1100ac6507a9784d2684c31cb048c33459dd71af52305d32e33d12c3cc501cd05864bb81551915c5b4252c1b4f656d9e5242844d0d8eaf831f444f4eae7277c621fc707c18fb709f0696483f24adb52d2dc639fa9425e512a1339b297a37c59a73dfe6db8aa9674220c4f71c7bad18d7a0d90a0f51a53eed992333888df374ee45f7c6ba1295ae25a674b7450e51cc3231174491c9df0de88dbd44d40c55f18edf4dee77a49146a8cacf5a2c7c899d88c9a2e81fcbc54aac44a1d21a9546e9a7920963efd54bf253ae652c3da1357622be20146c616184887073eece9cb7dc13be9093c94d5f790065ee4689734c9bfdd2612130c9ccee0943a8eabb16ceae12dff7789fd9ba74c162b3ca0d2b87cd4f1146634f063281a9fedb794bb5aecd382b7b0b4ccabc18b3a2344b76614103c741a02fe09e48ff80a984a99d9a2e26e6630f8be32b9de69dea858b92c8fec89bd3e634365ebd0f8c9a8e29f7e5d3b9f214c7ce665eb19ab49b9b4166772c5471c39a1d4e22a5ee1669202c2c51dfe6f287664ecd02fde437aeb02e7f9d31efd44871c04c834cd0efd7099b7a8e272257ad4abff95f2aca81c51a78cb3da30802143f21aee315beba367ae77e3c1c7f91c69bc466c67eeecc0b8ad6bcf122e1edad9fecc5e21041b3328542cda19be9aae3348c20bb390c8a147b6ee40d1899e2bf0700ee21cd2b0a690ce3592817c56dd20e42982f44ae84bc07537896f1e87b0205ccbd5ce95a4c546332db60d6cd567b98df990a475925f3a76a6da5c680e40b8cd78687af72219a70e14b522c603425db431e145f07e0fec403ad06fe865f74fb8c90e313e55573e4efa86e531d1542a91c12180eb2270da998730a0a81b5da77a7d28c76c44a6eafbed4e5033b8f2ec10e676393d3013338859599ba44acb9926204803f19bbee6bd55054649f5914900d87fbd941f5062092b9162e61dbcc3955d0f89112f7c8321f252c0b053efce88f014eaa347b4fdb2a112de5f07896764fc218b876cd0b772e023fd93001b17431c53a45e44068120db9464034b7c6b9dda4c6a1b242b406bd5fc8aa54a8e11cf547af156111dfba8f84ba692ff5973b15ee55db4584b19cc8cce7cd3e34d16907b18f38455f3951a6df43976f9c0d55ecd7b4dad1b0ae10b14909c8de5caa4462c448350887bca7d9aec55838eb49bf18c2b7c3c9f15219a622d4b02eab8e545a6eaafa50ef982067a56ac9e91849e9c5e3cb050ed52da8a3d9cca7a926c5af9f69f9949643fa3203b03222e337c2ecb6b7007eef6d34df11d247e9ed8d5d773d1fba8041dcebb8a15ebed3add68241215c1edaa08a5958b6dc3bb7fcab0e157a0819d0ba578f8296ba93e6eb846ba7c7df2a1395c9edf1c2f38fe7f56f5afe452f0e3acf7fbcee854cc4ffb5c87ad98dc827d45bbb22cad8389dd8e351409013563277c2b7bd643afff017c14e9da2a1fa7d5e3c9e358101ff02c49d1c19c0f7a0dc049edcde8d162516411d517caa60b995567782990ab17a37bda1e66680e054469712dd407167afcaacc13d55939a87356b80c06ceb85cb57a6c4b67db78746797c109e093d519f152ee10bd28b1deae545b14b4ba6a2efab40c1942d28ddc2c5f7dececcfe1d6cc5645dfbfccb716351e082d9035d658cfb0aae35a07b654da92c3dd7855b74e3d18800b504c01909f7ea58bba8d2d51fb5bd7b638bc96b613cbf8eb28a7dc7a91ce37e39b7c2861adac491996456af75eeeb1d5cf2789d35d29e638ce561a16b653366ee73001ce4c99267ac774d9e72d302cac8e6f163b68b94522dfdf7d59fdd0bf4c637aee8bbff901f3d91720f7cd0126912f1b74a762c7f9c07d505f3c6f734b687704894b9b55e86fe0ef420ffbfb5193f830807b700d69574dd5e991936867ca1df7fa40a4bfb7d48de12482fd89ca4779495b358a133a48a639978d6c8af9326ee02924cac7f78abaa7bc7305d903d227f21e748a61f3031eb6749dffacfb12b32a0af1bb5ea09970c27a534f491d05c4be4f3d3c725f74cb721ad99f80bb98b4a677c40b7c690116ac69c7cc555f1fa0b9a11422169ab5107e9fbb805ac6138c5e97edee990f67150d99f0d3850d3683722ec5a6da2b33b94481655565753d9eaf8b780751434a1f4d1e55bdec052b4467342c832f97efdf7b643cf7b011264f7594a878000e0741e375bb853c7ad064ac646046f3cc8f6184e66ba5f2fa581f9089a003e2786e2bdefa635e55a2fccd9bec1b98d335e8556a0082b77580e8964df4a3229845c5f1eb1758fe532107b4ce5dafeef7b391ca53ad73767a57200ad91157983fb88a4fa644fc3bb96d1c547bba0c86eafbbbb744355e9e5d4b2980cadced42daa14603d0dbcd9a406e2635045a45de03c23fab283e1345633f2882070f4838aacbd869e568cecd9949ba75543bdc462455fabd028615e99c0baa42dc8d8b21399369d809840b6938f0e879b9f4de068fbd017002f4d60aec0ce4a3bf47f3f880a862d6fe8e4f9c094ec3431daa4070e1f14fce3a821fcbd15db482665a4d59d6c7afbfbe794d8787153fc3e0725cceffc6349f3894405cceba13224716904c2da92d16cc9bb6fd3862e5a0a5c4abf904cd7d115d080ea560020ecfd6cbb00dd3b610d27c6d7a6cb2e68540af4d7c728e4e9edad117ccfbc25ced087b2d3cab6f3e0f663b70ab6458b726b7f0f8bc6887fd73fd0b94aad57ddfbefb9963fabb715ca913b0c1c3e989bda0caaceb490cc2029f049fad2d7d536a5079cbdc6afde54d8fc89a0aa294dc952f293afc24dbe1ad3d7a4bad3ef4328658d626d8f1025262bd95872ea18fc84af909bcd05282828fac2f922396bb585cf0d738d8f05adb3b58d738d5260bab3040af37f92a712aa7b6dd76e69267dd515a8966b0b7e3ef976dbba04ab285ea1371f8ac462ecd2b927ee72fff7443af8b7ad5a993c06c5569dfc07372ace380cba88de3b901dcd97d4388768815a07e16390e02a5b1ddce41a3ed538e865b28d93d86778ce40f730164c595196ded0bd0838839ae41dc48e5dbfb8bd5e38c2570177c378d38ee6ccf90a4e1b298511736c26fa369ae16f9ba8f296c20c2c9f7d0ddfd383a57d624856ec8e97c7818272e0977768e8c34ac3cea3e5568a8bd591b35df440957006a4959bc7bfb48d3bd018a1af162af41daa3d8dbe9c0b03c0743bd733fe1ac5cbc00640d58534ba43c1dbef30f6f511b3b11c45b58b2288c65e67c6fc636034126d20ccf11319bf84f16603713f7942a0f80fe3fff5bff4cf85f59b736f96b3b9cb8612b44ef0a8a9286acf844228143de45fc60f430c63e63a27b6a7cc0316d465f2fdda731e0ae0a304e045d118f21ba3154b4b28d791195ca6bcd0d647df39a97ae5b49a6b0234290f44df804d01957a32756aec3271f45bca972a1fb29dc7f26968b2140f1796d4013b798cca9f482bf1f3636f0af0a8da8434050201c948baccd421fe014b46aa58dadec2495c3b39f47685e26401b79b8b6ee9bddbe50dd9343c5e7750124262663b5bf849d0316c297c80ebc25a816965846e0490d4fc916edf364f060414f7181417f974d5bb4c52145336df293b19f0c6b81f7b23272681e5630c3d557bb5927d992cb24a73f72ba6f563df740c6f15f4c271f6c49e082927961a1b756cf9b81dd8684970028debdfbee73b3591152ea5706a4c94464c65f463c9897d2a691d33970530a7ef360c866539ad2747863335c098536609509334b43c717de81961e179e76bbfc00c565a9dd02e65a2e08ac2434f8638275340f9a4de362ee35af062876eb67ae44c4b38b012d3dbe0c8fe1940d9d69744e105fb9220b0316edd0c48b8848a0216d6adab3d9ccc464bbce0b63c9611c711c2e4c2f572ac972305f51ead5c959636466e49faea96e0f30690878bb73f65c097de0ac991a443a9008526528802c5859aba09611b3a240922b19e38c2dffc9ed4b44429334145d39c1da3effc89113f028681d48cef78acbe773694f690102bf373e361906f9e1054f2638d173174ac7e8ec3c164bf01a879adb3238ff499ca0b21066e8773eb617851f42bf5b52de827e8d19171947b623f65c684b6d2f4771f16b164010d9c24501d19eaba364ba84b17c2c754118aa827b7ded512e28867a37c5b4e983a5f9cef3af821b6309b40e088c2f3d03200402d6001473d5d0a613de9fedc9c532cc35629f954ab29f6d341c8eddcbc7d093f2e6d33277bb2e51e31cdf98024ea94b9b2178d6e2ca4fd8e535efba83214f214632486bc09ec04b64c60fe728d1afdcf56c9d84d95ee39fffd0335c54266632160446adc555bb7218416c5377d48bbbf1b122ff87fdc51f0536d2cb28bb47ef74896b72b1d7c57a742454316c6d68daa7929ad9383b13dc0511ca7f6d8e3d22130d3d412fef89651b5b50ee81e78cfd7c1469218ef2fa8972ed052f6c47083179861b7cc27e84a94a5d54ad497284299b0fdb7f5e06a272a61366907c2328a20addd7186f4d6644827991257a567a7c0be3dc3ab741bc71826cd2e1cd06f8a0a842e7c3ebaaf2933393d72129ed794342da6c1519f53aaaf3cc2cb01cdc8297d69b4d5362f0cc6cf47bf886ed1b0faed4fe669e45d563c63cb1e4cef5877a138629a860b37adcc4ca469c689ab71fe3d8d0bee59cb825f3d0f03bb2fdefc4ee6ce4b94f940e856174cb850dc79a18124b6f26c9965b1c1aaa47550b406a5b71469cee224e022b44dbe9712ca852d66c8f6fecf792248cada8452143c0a046e4badc1e92691b530282b4e2b3618409c0a2ab67ae7df9368d7ae9f8f62207bc386a2d9119b3d233844b68b4fbefdae965b1de5bf5d0fd2fef3246a6c5626d5529d6e7948087753b7a6382358774e02b7c4edc78b2fe2c4752bd59225905cad373dc50c2c969c9e015bdcb08506b38087641caa24f06434e6363add94ea49c92fa7688ec260af24963e12653be6e71947e8bce1018d91094dfebda10f8175568391353103dcc4d8ccfd013c25834800aded7910ea5ab43a02c534e371a42c6c92b63a4d8a965532872b3406180621b5d34e3aa08daad02ab21376756010968697d03d44adac9e390c46ba014dd454231d180c203bfa39e4177445871971630b8335e4f270cf4dad38cca273e4162eab9059101b76cb63968a3142989ed31404690df10dac9d988c3bdddd6e1d0bc4bec2eaabe82d17ff262c899b69bdb136b4a504f0de3bb9434434822309bb526f7b6bf4b450dec0459acf8b6dda6d3028da1e4ea00b1d96748d90a3ec17e9c20d15ea52901f01104cc62d3159959cb3220dd1a9af21ceaad5752111694fa4e82123bde70cab74140cf026316ddd5b44c6c7bf7a808063bd9d36010369885cfe101d58c52e5cde9b2344295a02bb7083c7150f6320d721a90cecb1d8c77c158b6e81e737c6c43aff9df56c97db8971fbc7e1cb5d652c83ff4bf2ed382874c2e7c43612862f24779d1fafa897021b46367f0a3a002e6fe7879832a214f6e41f3d8ecbbabb417f302ebeb15c1997b44e8aedc76b9e8b762dcb85458934aa509d577a1b0011de715a3a0a2b48d9f04a6d4abaad0ff53ae1fd191719a23b4421347f8fcab9279edf99ca1e817877757aa0325f8eebc5f937043aac5e64495fced267c4207f52f4267a28a38ad814d70ff6caabda2ebd64f19986a162bf0aa5c8399eb0b37de05fd19a9a085dc9cfa952e19ceebf49ecb577dc4d8b0b5e6f8c67b4cf046051cdf517c9106e8c65d6bd7a334bba8a44943931b15461b76fa5faafbdc8ea55c036af14effa126a8eaf7b711f04ff548fd6ef10149606d9fe8bde14161e535238baaf12258791c90d05666bdd9ef0fe855eecad95390d8cd41a8214d89cdbcc00c7bb0d27aba8c4a2877a53cf19f641a1a2bb72326bb5c22071b88a10e06343d9c7359b091fb1156a5a03c201bdfe3608062323427d369ed6d177f37e44c95bb7424b3234be33fa4055b3961e0e920f05afa0d485cf28012160a7885c95011affcd6ede418d33c2f8226532e15f98a41bc36eed6c58f7398c58d4dca3ebcb6919178809fd4c472f8908f76db6f885dd5f129a2847b811d8cab9cbd4767f64ecd9106acbe2ae155877077ed7480c346c974f3608f6e4b23cba03cdd761c72d035d1b0b520c6dc54f0364c88c2eed6c2aad610a64cb200690576e0150019e8f3cf1e2598af2b8bf216be8b97db10dc7c7b69f5e6bdfdf48feb21ff6557665b4d37889b4d6f58dcc4b86f888c7bc0ddcbabdbe45945877fbc1d013dd813fd0a4f16423f742d26434fe68b0ed6ba2ee9720e611e4304945e5b9e0ff16181be53f1b295822485b677a049012acff43148e4fd2476de66fcfe75afe7dcfebea901972e64f6a2aaa7f03094d8cda0614a5d1348d7fef27d1147e9f21deaa0f295f2efbef5c61bb07f8e7d4a328c3209fa09f00422c152e6ecda1d3d6bdad9bf8d836459d837c7681a2bb2ec2c386a21d8b57a94c3b8532513d900247dd956b60d3f7733dd0520f57afff061404a0521476f3e721f24468455329f02c377ebcfef3bd42a0ef77d9c862c8ce6b539ff07ebba0bb371caa1afbf6841c3e2c4a40d079ee47840e82e892d83fbabe2ce00289b54167cb38548807199e22051306e7d1988a17b777d86c5cf7fe8da9913fc5a8c0c9882cafd5c58146b650c7f2bf539c8dff80a35804f6dbdaf8e3da5d5c5b3ecd606ead46d7304115e34d373caafe65154743009d2bcc2fec6bf6e115c627a8ec304a6a6ed18267aa0976d23b7d6b7dada58b74372bbb8e5bb55d7125eb4d25a3ea06a3ee667aa9214d1620f4714c779dd990b5dae6e26c3694a994e01cc3723bc54fa55cb75ef96a09568b3a38fd088678c977aae36035c94b10485c9e01574839cec912f2c4bd6bd338f58569034525defc75eb2499de96b981e2671c02291ee1b950404ee59436cb5a1e308b9eaac76360e4dcdb445ebfbbbc4e4dc36647b88fa1c1ee3efc3cbc7a9cecf7a400de9ea3710abda5b8182deac9c5d99bdb7fe6ecc3bb0322622eb96b3c5b51b4c55c1659cbb0ea17ea03f38c58ac6953ed7eb12d95b19d6bd0313ea8e457a5f8cdffa2ed0a6d9f38ec8d752183226dcc0af896e1134e5b0ac0b0b7930946e7ba7277e848cfc360389854c24341e10932f6ff9e0ed1282f99b89e60c02e7f533530b259652ae285766b71727b8c5f337fd3129ab2d60197654ca275cdf23c47247f0a139801e32ac0d1a1b16440ea82f6dd28a3298c067356c127b9b1ba14e3e247ca08e7d7e0569de66cc077efb1246ec378d1a6890b9b81ab3b4f61f7303fc174326682586006ada7628dc6cbef4795bf51c1bcce7bc0289f316c0d9d8b89a6c439e657d8f7c3263dfb9f3b79517c4e56663acb1fdf887c382172bebe8b4f583eb9f042696e9a2d2c0c86628021f64fa78f3f0edc6779896531566be149454c82f843ea47e9e22f9ed7f53b913a0affca14e8cb0a53ad000b7b97cd4e3e087604ff3b0254adbc1c401c74b5cd7bba5deaa651fd1291878ebef522c7d1dcb13bcb70f512a32067881d4f8bc2a3625ea58f331fc38b5eeb1595a9e2da1756d1ebefd046283565bf27f47f007d4bf2fcf3a16a7d23709bd1de5a1c4ffa0daf23c2f0de839337dcdf218fc5b3169669ee97ce64dde009b1b6a1ecc09c25475e5307087db4b928ab42aaa5962d0cfb4d40635eacfa59b92bf281546e11e391e9f7da0c9469a4b64460cba0f76a5f9a1d04e0641919322c941731b4d4731a579681f6e172e9003c221a8fd181fc287ac8d8cfc40c9feffd745d400f641cbad798e36308217cd8fadfbc43efa66a340d5369402c951bcb840ee023e8624fd24668afb6f02534b740e711b93385b936645d4431f1f41ceb21a321bcbd554023d8c47357b1546521ebcc5ff790df3bc969d0eae97b4cf6ccce8fd3bbf84c03a25f72bbbf51cd31eb21f3e20552b4bae23ff1d2936481a39ee93875b22dfd361df53ae5db72c000b2952f6ebceb7ea0e12edf2d8463d34fd8d6fb5882a1c1feba9bfa8f59a36877da0c49f457d8871eaf4afa76cbb60653d6edd6acad456d771b45ed886e8a45176c0896e75fecb277e4e18852aeaaf5ecd2c2e8775d8a90fab55f383cfab60ac7c4dacaf45252837971cf689b53b4bd1175f58b635002b4754eff9d498ebb7311713cc6833c2787f2e7e384509b17083e7b0eac38228f66fb8c37b4124953846acd7c079e6afddc71a2890ebc55dcd66f4826b92a8836235de90e7f47ef70f2723e494fe71b0b409087260add3c4822b8aafdfa409d0e988ddb4b21e3ec536c71b3758e9ca30affac2201ca382fddc716a25608d0eed4c1a7879555e3a4254ffba31209eec80fd389b07445ebbba101adbe89bde3524b7648a4afe359799a56a5c108a081f58378ec03a52bd5b09f917cd3c27aa71b9918b18cbc4671a9421377ccc13d8ebd3e177f7371e708e966d2cc49171d5186aad658c38644958d8f0204882b75f6fcb9dc8c5b83ae4d6c273a377b5af305045da8b9423f330dc90664cce9313250aba99cebb939bf2b5129aa8f1f9a7e78a9c8c494bf1421e4412dc0b62bbc07ab4c81ae78ba79e728240bee479e8070ef9f08b376b12c1a3eab388f2d3a4e1d80bb38b14ccb4858d5e6e922c0123ee65d266ffe6ceee8b55755fde4c69123ff69aa2e643db985326bb697abb4b7b788854ede9cfa6ba47fb5d394f5b5f684ac8dadf4702db5a262feab890313ac8afc55b0bef70ca47d4c50bb1004a821bf85c1b61669e4461eafef0a6829553c4a984db81081266b538a83e2b272b1cd1278c35afb234a2996b2c74ea2b725ae09f232b873c2f57756c0ad741ad238922f47feb472bd7d790e7852c0c366348d542872f3bb56118b11a3ff1fad16542e50cce6c89218751c4622956d76541084f70c1435e4f2fa5327ffda6a3c12507d8e33f7e5aa2771a19dfc71b1fe344e2da5907ed92c3d11a7f3b19a9a56bc7a7bcd738ef730f53e6e34230ba473294bdbd7e084e0405378f23b45c68ec025d3af2e8c3fab10ec36c0d544df36f61922abfdc44aa60a173db42f1d3a41cecff09d7d145803157ffdb90ba21500868d6bca34298cd9e8d7b9ce84df6da379a774caaf741d5b11e6550d7ef37a3544ae6358be044fd32af4fd704667faaaa0d2f8a4e3e26d2f6685a847beb2d551e3b8aa676f7901332fd04e97a365ea73c54b2b799d23a3862853d9b237d4c7a7c90899add3d7efbafb8bc10098de32718ea33a6eb321a0301008d0ce31ad65bd05c3f8fa309b80d47f04b3982b8f0dbba1da63cb3778b88147aea5fd7e22cf5565415bc2fabb665a3c2c89223cb19c507c2ce8ed10f56893753944bd1421aee954f46ba666b5020d0748c6175f41bbc10220d401300ea836e56d4a0b79c0060306798c7532346fcfff8590cb95ff2cbf4f75341cc331494dc9c204e2ef81e78dee4970d19f22e6c102fe2ab552f672f1b9315d9b0d8084d07775c77d7ede402a6889a54ddc068fa0e1ba1f2e2d95f07f8a2fb8b8a4a369ff09e6bf9fdb95d3fcdb4686cb7e85caaee5a24dd86fd0efb3f826213fcf1e29be63387f4ae168ef514d1757acfa19af682dadb5a7cab973959604b2e74acf5291c3cbf5312766b148d9bd2e7a41174d054c9c49a91579920c4fcaf98b6c62c2b2408fd556b8e51f2430a39e3f5f5062062723b9c43dd0d30781e0b8122ddf21ddc80716748544a11af9354af45fde4356208195ebbb55df6aa21c2ef463b04117590f6375b66489e87ac948fe2376541c2d09f5a92e2478842726d820882d5b98c20222b8ce1b6423adaa11537bc33fc1e4048c60233c62ac741f9ecb39c03bba1c0f0b70b41fb48bf17c8efc4163ce956ed4a7bcd6457b526027ffab02d72f6799455dcf6991f038fb3826db9e1f71238ff39197dcec1de3549f0e4010e995534548801bcf4400e766fce2d9db832b299ce6e62991edc17584b88bf1a3abe7e30f55a719134ad0d93ed7092f9ac8a5645df3ce68d40f7b3ddcde8e3d523f45b2a0b29ad8242af7803a758c21318af9a0c0d2b881fca6ca0db668c194b9b4671a0c12bf8583dcc76c6969dba38a5764136847d2f6b719e90efbcc219704c61f875b8f8eeecc0a2912b04f0fbbbf5acb70e09e8cd60e2cccd29f4c7a76baf73df88173f62cec30098d9c6c0995dd3661962f6dbf5b564dcf6e94983852c9f90044c014ce823f45612abde63473916a0c780aaf5eab084ddc0278a4ea1881e86839bf6de98ad1c3c778705d4816a88fb4bea3967f7e39543c8a13e17ee00de9a577cb5208b54efb448c7180874600436192a15c55227c5b4caf1b1eb7c8e5e143e71ed8fc8d524d41b03dbe5bc127bc694faf1e388abe344b858eaaba98e65cb58d96b3b09bf0fe3e2cffde108fefe492c2ec52b31206bae212a6ae38a6f2c1ea2a8607644546e3ba57803968838f72de78e5434a576a6a763ca0649055b9ead433b4a1cd807905721d78491ca2ec774afb06782daf18b92de44dfd1ed342b58819cb9b48f80ef3d4c795dec159e95f2153f0e632b35261c4dd4ed0ecf0f5721befbcbdad720bfb04c770a773ad7d1403be7a5f6647ef82f65981f6aa057ae9ac4239aaba60558395c9564087244e72c8c239c447584c3838cc9a11b8b634879934d481ed03ad2cad945e83e11e24d0d38794df7bcee231a3e1d0c8ebea6d2c5fcb6a6c1606e9eb7df88186f0d76e7528d992853e3310f08a7f1982d86c156ae347629bb8da43e82f06ba1244500c94eea9819a5aeee8acb8c2d0260f54ede6d267d1813629e279fef77415b5e14e1c3e6da72d1ecd1ef5a4a6242f667af18caf7b953fa510eb850287e109cc3f64a30bc24467ab4d811894df3b78a3191072e4cd474758d9882ebe4b112289acd3224b40942a5f33ea54d7ec48df0ef4d81ec3a17fe15e92e26ead601e5ca5a3b4cc6fc1bffb2035ec2b8a56968283ef1931623d3b37d546fe64bf7db37334b731d39e15e8c313e91febd31433982a985a9cf68af7f6cbffebcfe5230c7087c11374b233280b140017fc7895bd0eb12059173b145120f99867c860d500cbc4fb3334840f8889ec57f67291d160bbbc98ec0c4d98fdfa4c179737c72b53d596aa91fc9bcf861aca6e2f1f215a03c0f2c92affe5934569726614ca2f06ac46850a6a7f6effd7496d6567b63dba294971f3c146482e5af86687e49e98893b1099126decd74d3ba7640bef1cd062176188192be4cd771c981bd03c718f5143f1dbcd85666dd44199ef4bc6118c98085c3fbaaed48a6a0b8753309ad40834f32176dbc25b09c432e7b5c29b9863b59ed0fc0c42d96063f96e964805f73cb2f00d9b6c623d0760b257b7cc9f3248af2955bdba7459c2858a5058cc23bf862f07242ba4cd417162778cd02c1d79841b2250c1d4de921106a182eff1da68e523eefa5f1b88f947a4b7958a5e12bc191cb9fe8f4a4ce7d89ac9c4e188a8af021c60463ab9959e1171784f59578c977e3fa6189fcbc989a400412cd43cee5a6de50c5b84ec3c95b76781b16ed25a5981a999321ae169e87bc1f0d6109adac07f6ae30f3e5f42b30d1d695ef3dd666ab4ab86de3d091d1a9c9a3b4d400ae62a7b8129c7546a09dc7d39bb811a1e0ba4729c69fd82805e296ff779164b7bf15b7e8c39c200c6eb3d661af5bae148fd8ab7fd404b27d5a395302d4bea10b5b3d6ddc7bcd18e7565b53e0aabddd3def07b0dee41e09cfe2e15f0e6c248cbabf6b4ebd1a076e7b3c66fb673fc899b78d1d7aa0fb0a0feca4fe1bd3c26f91c32fb96890a29fc5466cd1386c4fd72bbc2bfff54c1581be61f5ead3845e0739b4a359ddfa9bc018f2132e099569a835854aa62b886cda8875a5a41bc021aa91839d280f6b19f4cd382bca68fcee0c2b96efa7257f08d1ef92e1a68b1a44fce017b09b663fbc7923579635542f83d655117a9969ccb895143832aac35d49fe3ea0a188c6f38ec516722d55255f566061e9630be1d20b40521fc39785d23f7249e51c1645d1a6485ffaebb6466821967ce448104e22bed11d70c2b6ecae867ead08f4668542ebe4c6ad028ee21fed33d1b4280e9851c78fe3c40f4f4a468b7fc9ea863c18450b824221add374a594b06d3fa661970c84defddce5203bcdb9d155673db3e8a2efdc5ae8cc4b7a2ef4e388f16181b4b895d725cf28e4f905cdc404641ff96397f379859ecfadc046b665704a7a3cf37224eab345432ddf83fe046c0cfea10fbd8b9b8f7042a7bff93f28e8ce6c0334aa09ce5a3914fa5a19db820b29aa13414865f2b402b2ece9618a6904d4b627896e186ffde1f774d94d061c0295de2e3528bea95670185ba511b423fde3d82c35b797e090a4f808acbb3f75df35406aec54c44951daec8a45efe85ef389bdcfc465b41234392d9c08b01ea14fab10819bcf0183e01633eab4823f6a673736fcd8f8fa5eca082cd231bfcfc5bb1c670a821370b34869a66a12a8353c0bf2f641d1a5752424a737c12068cabb4a7b3c053e00b47f02ef12029cbe6d6688917230dd3cfafb91edddf4a3221024fc68c089809ca74bd44e08d1a8c975b765cbae092232f5f1602269671d826ca0bd0dab497eb6bfe93101e5899f4df9e9a3bfe9ad0af1c99085f87978b49dd70733ac14a4e32bad165b6c7d86a14af7078dd9a2221f7bfdcbaaf3df329651d97e068c2a73a24d4cd7c7c527f2143ec5fd911838bfaf741ccac5f7f7ef8a41d4ec3df5bfb404323454f39b7bcaa01b7717b738a16456aba1627013b5e392d9e30e54f367b9554a1e9bae828a558650b44187c25fc3f8843411c1b9de66f05d67ad920bec3306ea5f7af1a5fb971af6e238166c6d4117de8ca53c7533851699b85b4d630afd9ae089a1d610eb7c367d614deb68e39e8fed2ce9e18a9ee7f53f40918ec2f705faa9990f61801d8584e950d54994ce6a259ce4f1520a280a0440b97e628d1f1e4df53dc485b0b0720a795c9ea5db4dd16e331686226d1cd36c3f65537a11ed211009bc9b06cc1360faf60e3645be3ccffefc6e0facd0c16a3e404d795b68a31ae741e228177266d3d8f3a1df0fbccb678933569dd5042fe1b7295d9d15788fe380f5745d669e313bd562c33963c8894d527d5c8e32794fef76634a0a47be1de299dc46dcaab792e8f8814670d9f949185270b05542bf52c754ff3b37a5323b21beb57211f59dc5f7bb9e1bb1414ada0d36934bcc60d489fd87774ea12fe1aeed7e4fa86d7751a3cd2e5f8a1bc4d92c8e5f8ea7e4c74e043ebc5e0f62714e4b2442d8639dc0ddcc22f980490efc6702c919862a8dc9101baa8f393c50344c693bca6e57e638c3b9964522b6f29c22fb4acef5a60d9d1ad178f3d5c5c63744933261a424f9152fd928f613288aec7b709f75ea2f0fb459b2733fa045c42926e48056fac9fcb8cc248f027eb489a51e7e9d25e66035bacbaf77095fa1e54581733e7cf2f7f5b0a25ce54914f12eb2c8b1826095f5108e9e8fc4fd6067ff422e6c262c767d4eddc85dd8e41b828781861a062988b3f4b39de1efd67fd21153a8d9fd1a518854941ebb781936149b611065288a21d3abd919d0b36306f039494320307374a96e01619340e1c4818436da0f2d9ec49b3a519342b5ce119521dd92456a645ae134dc2afd5f66dc1e8aaceff443fefd4ec703c5886011a4d27e209473159a3fcf3367b602686573dec229cdc8a53f5633a70bdfb82ec39fc3682b06adedb6df19f3fbbf7801bca9d7f126b1e848d98f6b67b1a5ddecc14ded48b76d16ba7250aa684dca56d4e6402e161a574a5e1de1b224a62dc50744b9a8e16c4c0c42b75dcf94df5cd7b690a17e4ac2624d9b21c0d3488ac531bae3654656b77a59565f25f99dfa40117faad65cf2e03dd9d2e1bb54577a36872c49a9b7903734ea1e52699ecd98e17566010a0afe1bc0c8615cfbd9c3e60210b93133793d05d7a74d5310068b83a099ae6d42a097444a8239a535b4bcfc02a66cffa39f03ad5d93e06ba950c1281975f5473d1c20b6383f33331679b526fabfcf3c35c11c4c6c8e349dc5af43cc4c0374c01b8062649d892fbb370387b662ffc352f7d29978acb0b77298a3d5e532790578002616cc1fc8c3e3475e8ba6f9b0e6e3098c35e08600c99c205054c5da1589f2a5f183908a7c58a830b4d4a298ab9ae3e32d3ec646b4fb30b4acb64e16731bd67bd6bb898d04157249d44879d6e562feb2a7ca7a67c69434bf451124154b7612b3d3fec7d923f134ea159c4a04327968ccf037f5f303ab84423f24dabb42fc9fa48f4c452d6745315d82ba2277276eba041bac1ab67366bb0d2553bc606a194f68afe2c1e7111742023631e8d74f2d9da3b1025bfd7b3399bc64c915872f47d4b7e2d86442fa811a61914c9f774663fd55593713a387c91a815d6cb204ac1a226396b8474252a1b339525d78001d6d5bd970f8f17e3adbabdf8db2801d735beacef706c4c0fad5b80d4fcfc45185a44c401e2798508c3bffdad56c11d67b425d1143fbe1cab3e66d6e3f26b4096de70956b25948303b68c8ff0d7b99ef892561fff323029d73884f4c4c589be8c91a1cb769716c681085a671d58a5fe23970e42b0ccb838bd8d7302f72ae2e925fb0bc868be21e4ea48be1b73222ab036a811d4cd33ce756ec891008d9fefae56819fd0bb1e11045e14b5ecf91041664d046c8bb9873166ed0d810156e61931cd5d765aaf414d8298d38dfac56192051b81e885affce79105f4d1e64597391746bb9fc92721d7e5d880aec7805294780a590e7bc91a831ea46a1d3a1c0ac472a658ccccb16921dfade7ead255425c2a8fcb1f5e60b73bb8b5457a15d897e7e31a28f53b5f66ff8ec2faa07877148330d87223eebd19a6eee76c54b8d0709d0b9b8f4f24e62471e5e6dd748779c3681f6ebc907bd3c845c2ff44a5e5ef6ea50f196a4b040b0724ad21e1994dadc603629d8a37c60daef67ac5da8908298e700cb7dee0b8b16ccbc65b9fedf6a77955e00628e1265ed543c906082fb894b40c3a8cba04ad5c959e963d7ffcce341d680093a61f8719834653e099da1981844004905e253b230243e1b0e45d884368eb073c3e4d38d3e83c4bc7352fe8d71a7acf642a7f6c1b00dcbca2a583e74dfc1f83737cf52d7084972dc22316abf84ea28423574a314e36ef04ded1449534cef41f56812e298e1097f99d893e881a71e853fa39fdba17ebd242c954c36a477b0bb676d344830f2c86ba797a05fd1758054ec3eb18f064bcbb04fc85c18d1d124935df60cad8afe2bba54282f0bdf70e5ec302747fc4a9d5155d9161993f307b08ae484ca389493040b056aff187e4bde2b19a2206507d866864845e743e07414215561e542465fdf906d40ebc53fd81dcace7cbd3c8456f791c1e2e0a6d969fc607b3ad2da9d97c22df71298cffef1e762bddf74f2396454230fc89a969e7f837d70d0bfeaae7207764600614914098c991cdf715caa745ecdd9a2f35137a974c07b7ed9ae2b56d089adc1b6b4d51be3c624404ef6599a780b1022ca6c81c458c505e56f25fe7089060f588d1b7736f87444a3a001c6e47c8f755cb28cb37034cc7196a8da40f54cf34243d396eb89ba0803b274b1f06205fd25c4c776d6f7acd3d72f1ab95abdb6c520670a0670090c75d0632718a8119aa3f52ce1c1ccf9110435e488b26f30f8a1638242518c9efc034603cafa67de61778b03e4cab0b51500ee1b70d66f4aad576b013d7b1922f4a572f849b76b0f2e98a9e4bed20434adfa97b23cd70820480e5c14aac060595148295d49cf70f185fa456d2aa13b8563fe85f02960010b744dd697ef77cef5dd073f3cfb73fc8a9092c986bbd4ecf73ad7db83fa586c3375d2300c7d75011139a59e3652f93e7e98b18de3f971c72e99dcd08f365cace2c52032fcf0f593cc4f4e525735f462bab9f239a46d1c83495412a71d489b30ddaf9dadddfb06dcbfc302735953483310a6a252b257b66672afe4009ba3ae32205eeaf010a35286b876e84de814f52a780bb611179219fb9a1f66021b79be1913554fd6f84781183fbf293dd400640cdf55694c355fb323e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
