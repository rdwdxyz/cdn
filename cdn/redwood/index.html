<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"795d122fa70ce5ab0c124048b36c24c18cb3efee2dde82087e30c32077b76fd516d7bcda74032c01ee58370b9f2d0546658d99064dd7a5c93feafc9cfc2d8144f6350377ee6c7c7b90edd6d3391ab22436a744df4e204959da40881a87b3b857342b1dafe9ce66b9dcc7ab5d1eefc0e11fe5fd6c23059cb315d715875af060caa37c99737da5b7cd6a4c3ab3bd3fe91355c029266582b9a73ee01f7dc585ca4aeb3cf9b7222f3a7645ce7f30279ff669185453345e9715f576f5b77aa73d10a4b55639d651f45861dba3916daddf7f1ade5f929e03362bb8a3cfeaacd950fda3f44a9b2f75d7f8aff0fa9bc39a9c8d2089b51391c45451394c27c08b058447dace1cde0b7a21f4eab7f10e8cd02bc1100180fb5dbed24e5cf244427db93b7f62efc13157d4af5c603987d433fd08c8513e745ea9fa98cb9ca8016c5ae28496f7b37f9671d36023a048fd9d0b7b0dd11e8c79cb71f6f89f02ba7322f3800cfa7aac4a998810345d459bb1ac9940e3b75f4e6d7ceffb0d3e393da40bb5bb75090324227a921784e32828eff3567516f604f3abf0ec376ecb90c27a0ca86607b45ae0ff48c25d1dcafb765d0d987b11ce3cc2f731c037232498a8fa69bc122612307c265f7c9d7df45761b5e53cb1604800e74249b245386cd6bf04677091d1ae53fbb2f5106d22826b26725cdbb2e4fb7e390661888caec4623b3272867ee77381d4e960a2cf8ff57f908a430123c70e86928c9de5d393ba278095bff7e787ecf35f21f96cfb5852460724900348cd03600b7540903190b3e5811e74ec3e48f122b544ba1b04a21c749ee5bcbf1478f9d1a799ee5a7b8200042e810aad7e72f7bd2fed304f773276906ed521df62690973f0d75fe229c2e84f7579733861d2a84f3fa7c1e535193381063153e9e871680be86db1b1126bc79bf329de9167fb77db24b3d75dfe6387451f4448a246587f3cfb0337d1805d493f48e103d15d9fee1304971a4c21e120894075d2b0ed0fdc908b60271c7a83796705cd83e96c2e6b352fa97d664b71fc86aa091cb7644fdf75054256141fa2b3abb13e72392082a7a9cc81ee5e8fc8aa0864a93b6c7053a9fc81eee01e30f5a5710e2f3cb580f719d99ccd6887809a1719b8a2bcb138064750ab15282692acc7abace9267637bc9f52a6a87f0e432e61e4313935ccf77e95730cb7e02c485f406848f27074c1724a44eaf99fc945cdf41508facb15ac5ff4cbecfd9e92f36500b9c954e8b98fd90d5d6ee03c490ae608433159a9c6f909c78367d2f4966b21369c9cdefb600336ec3deceb5861e2be85b9df547299470d1bda4e28036eca77bd6dbeca9d973e7d0ab8dfbb9f54402482aed9697045a99ba128250d03b9c09df71d03895575b9973fb1fdd3269741006fbd8b95161cc540a9549ab384d9151297bf1c753c5a441f44b47b481c53a7480950b2cdd72d90eccdd2d4209631f3fb9775cb7e421b2ae7cf9e1d16fe5a6903f7f054e7f7c421bdb29d1a2251a2fe384ace2ec826d23c3b3a9ed1bef7536c3cb44f4715055019149c563b6d9e63fe255e280d4ad4e8e453337358bf0bbd3fc309f965dab168ae7fd84306c82c209026d534732768cbd9ea03cd33fcb8718cf2866ea3280468b9e92bc941cc971ee43513a12b8df35d3d46f5a6fa79e3737173ecff032d900c16e13be7f9e1d317f22568f05a478989ee611d020ee4d7b9e4b62810c28903ae2acf13a1d1b6852a41f0bfe2eb756517aa140ccab019bfa684338d8baecfdc41b11f228e2b08ae521bfc3f97d8e742f40cf6a25d4293bb5c9ede43c4c00ea44a3f636808f208f55e34c97f3a1ddfa880afd35a523360ce598e3c63094e1387eac8550e022815a982d4abb5fb3c4998a4d99fb81ab8537f59fc8b3ecf4f2acb15dd2dd8d767c6a181b2e0183e1308323dbdeab9251a97599f365f96679e8ae7c574ee39198c167f002bd89ef4a42f41147a32e342b5437fee9150a1986fd8cd12d2e56e1bf33d00372854425e04cd9656e36217a3aeeb7de3113022f3b97b8c7b1b057d5065fc9ddb73969475195d1a5800d05fbe272f9ed7882013248670a906f345165328c0568a63afe04b5f3d1679a5fe29f414a9d02df61909d29d4678419d974b38ad2e44390683caf4ed015503ca41105a55b6ac95454ed3b91373b1aa2f795ec29dd6aa49f811196eae85ab946eea01723f70ce60766405672821d1c805ae223aa0c9fba24ec7b339e06454ae32a5b2bd937a09a47f6d4b3db29948267eea03b133aab88cc89556cdb8da279cc3018e000c04fd7eca12bf5dedee31ea497e9a09a1009ac801b4320df494603cd152c6117ef3b1a27f802fd7258157192306e1884228dc36972918f4e950de012909e16ba4fdbda2346af1c44df256c777b251d368a9eacf1a6b846f304700cb692e009759d33a3224b2e8449c073f8ccedbe7103b992f87db45481ff4b90d40a481e7f09cb865b8f1e8543a7242edf05a703b44f7b80d1895f2e5db6a187045c4b50780bb98031d4280f7659085f4b22c4bfe8f3f3d8ff53f3c63156438138c6f7e7d2b916855cf382a136c415e01a26feb82ae0796944014da28ad725ca4eb705a7faf87e48dbc774c9b0542ab509652c5dc2f349908db6ed01af1bc8911f54f07119729bb7b9caf438a40ce548893a5b6358d0db8daa9cde49d04a2f9f6f87549d079d5e79d6eac4807a238c069f5d7079847e0d0de87108282d2d4a0af5e7ed18264f38bdb1a5e967b8c24966c64895748a282bfb0f7d1ff35bb02950a2a0e077dc263df79c10a0cc91a54168b5b0f24075a46cc6608bd17c7981df24e7eee2ae07df603a6b681d2110ae5debd238055f8d5be5f540cfe1997e165d40d6921d5e29046d6c9c591b3027ea9bb4db0ac5e016f38b32de246b75ad579db0e5edf6f4813e71da25b8613cae4a1e75bd040a83f796ddf950347b3e81176b75b30baca95cf99ba940d40bd127eed64474faafe0163818144e484b7b4e1e8744a1ad9f1ab75e1c7a54fbade7b2629e37df9ab9f49dd65915d290b6003e19e8c75f362dceb4949208164dfc71a7d797f479bf244f6ad0de103cce6e1bd02f08c2bcfeba9b068514cbcbd2461893705b4c5a866d7b9e7ef8db60d0946d321184576750069c86ac98091efd861c381c49a90663f85ae487f837483923d0f49bc71c9c35b260f959d8e60b7397b2af7f70e61043c1e08ebd32baf4475c51353db8f3feb647394d37770c5d3db3bc0a21f5fa8ffa6912bf1b68de5329c008e21f225e6c2d7707d2077233c4612999f2aa96007b35c9fd26816806ab2d7ad4d7e2333b58ac9e63fc76737110e4549f91d78b187d682670104affe86e36329efe8ce239952affc9738d3da51f0460864360745bc6e7d2a757da556bf964358b299949e4f77eb21ee4c06c303c992beb858d5900e68ffec799f030506c2deb766e9f65ec607228df3e7844f8b8fd7bc6f0f881f58dbc5437cff91925df64afe818c88ddf74a4ec3d35e14c9e3d16116804f155ea98ac241a70e18a5e33d75746b54dbdefee97dab8faf35674b37370ce11894465dfcc97d2e2c6f296c2a7ea5a6d19efcae909cc472a015eceb7390815611e94f22659d47c0c94d4c7c83d47a646ae927bf63b271cf31f2f7891287d64ed3d02d79e4745c3c0d5ba5559549465cb9764a932279e1659ebf31861cbcb53c09f220611878f9319bb04cd48d0711a03b7fd566ffc50daa082b5cce3cf95c59d1b4d3249d66bf78c424ddcea077b481f660dca0b956e43fc701c29928432710766c31883583fb7d049027ab6af9d34b656444fc681835339282e9a198536458e6dfe965f3d907bc066fcfeb24bffaa25333d9feef7ed9a73b0d6c52824b596fc92e9efbe7ab3c2c6b6415f6f1932a9fc1e84b4c48d904e714f203374c87acf3d203a75bfe49794f45da97a5ae2d370c7fe19babb45a2c78ae7d3a1e0aa30c43b52d60ed0533251a97d12082d2c109aa769c6cf4b945a43461e06c75b326bc01a89666b5121b59e13d66b4fbc77df2e86121c67c68db72f347b28dca695d16c91d334c8eeb98419ab200cb842c0dbad145cd3b0384b6f35279a936e9f3f457162ebd71954f566bb2b4713830139b9ece45cf54a28351f95be85ba3a248afc6e24888c53cbae06c81e5e43774bbd184a728c81c0970c4e2bc1c1dbd952e0e42342e800c708e4a8d3af2ca21f60893124384af6f010384ce6ff3aa76dd5207b6f5e9ce4244006b0f90962de65768c7a3bef751e12c64b2d5f78c3351c6087b11abd2791c70b3cd9d1610f35ac1a573b6efe4691db76a90d31909308b1c5793931f2a5e7b82a597956655cf4b8c67261233d4caedd28517e886a542f977c930f8fce5a3d773c6a094c8869d2fe99ca439f6b959290967d62fb743dbb1884f04c2b9c06b7601803854c769e6d0ffac1113e6e57a154756e836529531f59a7ea2ac951839acb4051dcbc9cc978492dfa9261f71cd10bcbdef5974090edb0da2dbd68e362eb85f6f66951a1035c32fb51d8ee5f0c315bece47749268e763cf8fba2f424cb9163c31e432c7795d01ab34ad908e30fd496245e37cf23318aaeb19f7275c36af1854a7f4ea7cce5cf9202ca83da1cb95e94b70f4b9153b88a38185939878667a0d0b9a7ec0ec91915704c607c556af6b00047ef10fcf3fe93ebbbded0f31c5e3653a573909aa3886cf461e966c81eabb000d15cf1551219a41e1ad5c3485f0ef5246e919d5afcfbbcd522346901a0e613b4b643679a07ff62bec4fe2d869b2fe4d48cbf51e5189bfe0a15738bf6faf2742f0c5497b35074359844cd1fd70b06f269c88ce311ee9d2e6ea01c7f9106fdb0b04cbdae65d3d972c4357b51fdcf8eda81f128b97c489f252152181061e8103c2bcfbb5bf0ab74656b3eea1376a8d65c823ad687433feef76b0da9263e0bc83693884d16fd5c4b5f0f1093d83fb580f2733ac3ce2e2019bac806a1533e2466bf7d1f572b3631ed2a363969bd7477ad7833bf2b77e82566a6cb08fb10ec4c4df89514b55c31ea1b516fa72b015689f1b0194a2ea98c3521d7bfb0ef618297945549a455f3e0e1f4a587356b4650ee84f7e32afb86199ddee43eb9a5528d10affaa12f6894a19c3ce4bf9004c5c581243cfceb3737ca1ea56581349e7ea65d8bf7c108c1f463eebce5f2517c139cf790f328153311b8ce07ee4392b5cee57f9c634eab5683be4ee457dab609a0e6289d9500d44c46a2b2a7f04c1a8a997f49d3d77a2f73d09702a7e749241c0c9a3de44e9bc292093f9975cedc43eda03a14d34438945ae21675af2f91eaa8273c98aef734f4376bdd928a2e50f4b70a8c4d4e2474261614a66bea9343ec8f934560653cffe74e091986ad2270c3824f7c042c0a9481f82bcf43548e75d6edcd88c401a3ff1519835ef52a25aeb8e92be97d4356fa3ed279b23a0d1f1e0106920d71878d148662cec328c2c7d9046c50393324c495231008aa92c31db4f8f989953f6c96fc5094e38cf2753fc7adfb0938f12055b3a5f4bd18cb818aae531235fc44f85a230198b4e7a9cee95af7448dc4ff2d2e23dbce24dc1fbf96e0aaa0a22ca40da912250abc990b20c552aaa7de0d0519cb34b688ab04e51a1c452eb37ddba9db897fbbdab2cad5a15c9fad9a01febcbc2acc498c7668fc1988a01b63b76d5a7d1a6f0748ad1c6f22aff36bfc18dabb8136743887a6407573602353299c1b778da0a2a9808ae612a03d904cefe0191b7ce41ec065fe48f45aeb1699dcb69a6eacb215f30f24051c0a515af6263257d92868b779500e4a01c58b0924539f5f49081a24ec9837e17925c4b89533fbb2ff74e18458f8781b1a821710d959847365523b18c1ac9677d44ed279044634e56c339a0b249e48280c52b1fa2303397e61ea678cb21ae14ebfe940a2b943ea28479f7aada7b3067292b4ddb12bdf9a32d4b723d17189655c73ad4e0a1286a2caeac7adce9a11b57db3ac41c92f67ce636da15adda8d93b5c568d5036795a3d0da8999bf2afc42c45e1affe335b0f011e18e624b74f5302c51075206fd8bab70c4a7cceeb6443f6ba96204148932a36455d13c47c5ee945794b8ee4ba8c77d4f43bf6bd77d9865b0fb7bce7818b153b61955fde83c63787b7593eedad84f655b9c2711cb1350291c36d07103ea32e3fea37e950f9b5f3e512563224118b10a6f7a53759a678f472573071b1d0fc8ee654ede1fe6371663db97021d9633da14a8c0ffb2b1de9ac3703915419e4856c116bc14ae1631ec292e9c8e79e8d9056dc3fbca4b6c46745a6fa6ec5109e39f735e406916e8feb7dfac391778988678391363b663ed76b7817131c25345e67549d91bd504bf5eb4b684aa8e84eb746304381e98f31fb93d45b6df3a4364ae98c20d0932f803653b9b4f9bcb242be34b83a4ffa3765aaa7ed4a23b01ad44e229691c00670d4e88949a933c965c80f3c1e2a6953e45f06b02c0dbf0bf6100a690bd9e45233568c7a2b97ccfd0c6fb81ebacc5ac3e6dc53bac688d17d5070906473d4f48c06fa74f0085e89911fcf7aed51e3374704e00c28b3333fa05f91ecbc64a0da0d16a8af8422f4e4c51993bbe201f25b46c0e1e0f1e7572c1f82789b3cdf646beec2377e5090ff859d4c728b071f75ae11321b204fe2d4da770ca5bf9360f146840b646b702913c0241fac4724df3772b198efe480bdefcb70a4423e8d7bff505e25c02d47e61169ff7e06b710f907b2cfde315828224feb968b33122c225e6a1c564628b2dbcec10090983c9f2ac6b804d28f77c223382715bb3c7f1663863dbfcb3c8e388b164b63f4e2b477169696c233b8763dac65653de245273f4b6ae29a5abd8222a48140c5da9b3959fa8aab3dab9be405ceeca42d25675a1e3bae6f811d3baba6f03f90fa2793de91ab9be6be997ab0a533b6480c0b52493a5468fe36d4967ba7c9a6ebc1d94ec0aba01aff866cc48f954da6811209f41dc9cc469e9c71a5d697468b95aa2e5a8406396a6f5fa78aa7995fcf91f8e3dca2af8958a21dae03358e3ed97978e561c9bd8f1afe3f5c02ebad059b83e309a706277ddab578d1f02729ebc998ea7046750995d055a333c12adda24ab9c60fad40389fb81cb847bb7c453bdd87102ad25086898bba42e05306266af57af35991cd5fef90589c3afe6ab62aeb5958c2b739165039af40cd6f83ccf2cc4fddb991c614bc1040a4c72f9a38d7ac50a4784c849c9b6b5fff9e0204a3108dc69f48d9d3a6f72ce0452d1e7aec6f7a4dfec8f4fcf242b4c54151af19fb7e425d39094533a5b1da6070b2541b5e7fc712103547f06bf052bdb297d683c458e4e3efa27c33511895a0d92a785412ee32bac32c774d9c8b221180513e7a57b950a09ba6a136909d71699b54be77c77a2412051dd9f938228a9716a8b32e56c8fd47bf594f90887848b075f9324682e1027fa533c731d42e9e93af6d5326834ad03bae6be4796916f353d509a71721c047f422a7afeb109352cddcc0d13e5b51c28dee69e19606444d98a66b8160bf44a202a089d641bf72f2c9261b2fabe2e3269dc30f6063bc5bea50c49e6e1b10de59873217942f4288d0a94ee0f0fea722e5c61a523755df79ac1b2a48eea1cb8f8fd86fe976b85fd2360c092340a974c0cf6228e61f953cac1c7ada4f52bfab4dd2508534216c891ae60a55c4e9e03959e0f07f2e35a4671f448f05a565d095a15e39fcd82748f2fe362e2151d7767a171a1535d190b7717a00e59f055d1417a3b87fd9e0cec72671f1f6ec69ed8c037d6000fe9b6ca94e62a9a3342bb668374b0771549d24762f2b1b5647dda35980efe45cee245bd733ce61a1dba469b5acaa42e50aee7e436b384592fcaf07a49deb66080eafc0a45ef1a716f50e1fd39bd8627fd0303e36e411d90332085264865a7cf9e1a5d791b9650060cbe493e8777fe9723cebc97a6e35bb610393c4bc78bf9ab7292e183b9bab747709162a0f8d97199427a16583656a4a11589650edf19608c47418c4cfb2722db2f3f89e06bde0343395bf327596894a195d64645ed766040e56cf49091c57b0a6313fcc6a4bfb544624a4f668252fb5c4c29f5e6f89b9568c03044c8dc9848c824263ee1e82b355895b21fe020629e98e55ac02b11f3c3e9965cb8e76ea2393eeaa2c0d1a62d383ff60f5db43acdc9281880b453d0ef506914a7e7e8d170ac26f57a5544a62fea1ac5a3fc63261852aa65dde34e1dd804ec978d549a181eed4532ec6b1e223e6043c77ce2d714cf4e93251491bc205fd2c43988744f699d3422759ec220c250bec69916d25fd0b5e9245db238baff840fdb0a24510c6d0a57603486e839b1ee01d6eb9ec879a88af9fd9f44949cd311f874d8808d567cc839c025f683b958d972e75a643ca9fce81079ee9c86c46ef0cf6759f57c09e81183c0bb57dc403524f5e433b52bc816bfbe8ade5b8a0b78456ed731f04cf656b1269aa4a0753a5e453ad876daddc95c5a973b3ecd6ef8670e78a06fd71b7a4ba11b249bdc8a31be56ee1f778d7c6fbb908cdbb9c95694d1874855c48733f123a789a170d3b1f9f8047a3a87a69888438011c6a65903d381a6c72309a9a4b8ae3788c695211b8a6e12b25751139e5e9ee8ed64abd9d7aef0584a52740a4ba3b5e954f18e9e559dc87b758726233821b9eabbbd3c5dd874b5fd451e209839df769bcda3d2746954df17ae5eb36105e8b1b796206cd306c3c0b941ab97bcf5dbf9133a8918fbb4f6116c97afde4899016eaec0c02d74ae36b89e8edec6abee47d6f94efc16c485b4330ab306df642ce99ce2c7f9bc852a08acb9a7f10282c02b2cb027a33b97e1d2f88a498351c215ef9724dd1ecc62a69da769544f5376b2a75d4d071c347da612d2e0123d44add03057a90a407497f32dec6dcb26c60978058f45b805c821b895b5633ff51566b6ad1cb4d45d8b467ebaec1d746a25b0ab6bc46841435cf806697a30a85f55aac49187534e6d176fb0e6766c72d29ef42204adf80d5597c42016faea334468aeee0e80271e06adbc1ae9831bd936af0867de711a6a21438af6c42ad09e71303e0072305bcb9fa23a6d86f66e8b4be116577fbc39df20a3ddb505fa889de5210ab98539339b8e5f8fe903f1442a3c116e6e18d70b40aec48588e936b85f86743e9150daf6946d6d98bebd9099a9a41dff0e55157eea8885addaf13caea846125b2c81481dd71712ef3c7ba7c993630ae87292b1e9279178c783c18b1ccfbebd75776a7ca6098ed6ce1a789e9894fa0a0f44ce3129b54d43bd4f93db037d58affbd5097a8dbb3db8eb1e029d64ed385a67529a8363bdf2933f8a50ab35ba814d38e59ac1610b7e9239a7a1aee936ce2830ba9049734e35fee56bcdd6131c06c33a0034c68af295a8e6563cd279570abbc116123c35bb49828663f865eb01b8f00a6b0941f0c5106a9c31b68140d5071551562662e6b3fcb0e7bb82b0c29428fc820384dc83fa94ed9bef618f4e53a6a0dc01560321e731553ad2db82618e6dc72c0de4062c081d5f412b200d4933cb26c081587b961559800c5c18755e160d2dbaf381f8b6f7ee99bbf3068e54296a77c33fe454e310828686ff11a6dd27d3a087c31d7828d4dcf33987a58e8f79cc3514e242f7fd1239f4ca0c1791038bc21a15300af366370b36ae91d3e6135d124a5430ea7c0546f28d50c56efdc489bb3f65f14e78f9dc35ff08ceeca73c80f1fa110bda715f6d31ae650927899ab98ed387432c7049bae5bd4bad8e0400b0cd6c1dde4a9d7ad7084a3e5dd49191b4815fef697ce372c2b49ad985acdaf7c165c0c9c32bfafbfb0b48a4aa841b22e4d500911df356a364de0d33dd4d925f07899a8171dac30430c929a3cc5c739411695b63402d69c4891c4460a19b834613a5cceb088db9a2b5990eaf164f34ea51b2fbd2a8513dd0fbfbaae92f292d8c923a7b7c0ab14431621d182fd7a3bda554faacda6f1f6682866be7a1b0349081287cff8d558e86affd57939f869db650889dcdd27d1f0a227c626e0d341cc572b5b4c9548fb6c04a856f0b227848181cc0fcc383ae55c112ccffefe26b38a52045f9660c65bb801cd0fb62bda2c85a4c5a13180a155d18f676f76c19861d504f9eabc9acdd3bf860a0489c6851f9496a2db3b2c0d0ad8efc5330c85db02cb7993ce4f3863771fca1367642002bac85d9c16853c05411452a7f578fecec384b81d488b404fd599dc7f2a16f2caf084972905e9d3c353fbbcf140b44fc9c9477af410a1866cac4b5d22d071608863d43b8e2c789a64a1f1eea70e13e5fd27cdbc54383bb4e11a2e4d59844e0d6e23e6aebb2cc520fc59e0d09ad1034c0643a5ee7de9fc520b52a2cd23181d40104b9598bac31c632036388d37a624aaa54f07eca0bc74040fa2f236d98d1b8f16473f7ab46ebb920338f59e9407179af14db70253fceeae263115805c526ba2daac64ca88316114c766b386005b469ca874487ade64fbcdced80657387c483a55ef13122fd2db3bbde93efee709dcc9d514f6a2daa91229902fb2d6a102ffe4fb9354dadf58c0c1822f9b2ad69d7e5c1d987c01082aac6e70ac48242f340e8d69f55674ea35d7ace74e962bd6ceaa03145c4c8a9e2178fe99fb40619ee62dcecc06448743d036a1e9d671fbf364d2b6c94247223c1c97f398d0801f681e874f3eb2404638ed37d04a556827294b40c066721abb005abd78e4f73bcb2908c94c492997c75486fccc2a0a483bfdabc98933bd4588407eca533cfc42e290e6e7f900ac7b609047e9b9419f4ea92224bfad75ebe97420f5f880581208a5488d489e6c033b08458235b6956027352893366527d71636480b9672815b3e22f570cec8db30c6c3a94809cd4d3cab0f34ffb3f170abedc604db0e3da1a82e4908bf0cec0638f712a43026bd66d4bc982ccb042778558c390de81fae39ee70f97383f34b6fdc9d6cd09f0e2c488d36b758abfc7cf925128bd94f1e23b98fb213bbc596d6363c5266cbb4e5fc58ce847d66e0f07727bd9c4d21529f60c826f02c24dabecde936798f527e3c228451a6d3c2be605cda821deb03404954fb4fc0bf37f3d062a71418dc55e476e19ecac7dfdf770b4fe324bd7bc1c3bcee705e8a404deeb8dc07924b0f8eade288dbcb1134d86e7ecd8373d367761f8aa65b3ab849eb894e982829ad7283fafe8237c3dd0e1986497bfa07c15870782164791de0dfb2ba071713d9c24255fc016f8569f842684d1d30164656f13c4a28e9ab99675df6c26c3fe37100e7301b914208c4e09c2bc4c3459fab26b3311add6874cd8426d31627a3b200f97ac3140175c5d9f9e8ac4edc62068c8817e633ff5339a532e8860a3cbde23960f81658a93ce93da9c25648c0b4c2da77661c950c320997924ab8cc78c61d43590245d1f7c8b9a15191ea18148bc9d4d5425a437de379f5335a19811c5c5be3fa5afd1b2633fa04f6a970ca9e09bcd4d3fffd677b0493c5e19b16c7f9c1efddc2618ab9ceb5a57ac5ce91114157d370b326799d5d2ab458e64c4384389482cfe078ccabcaa4c1a16850394673c2003b0583ecc83d2c2d6dc0152b05695120ea20382a318a27dc2529e5b916e3d47d538de5b55025502b4c9cf04221810591ec6554142e5ea6c2e986f83bafb8dfe4dfd32dadadbd49741f4afae2beff8589c671a5fcd8ec9724e9c40d862e280b4404f2a53b34aaa1690135a201bd2243211a587f8cc3dec0a3b87ffdd36896c468764cc49cb354ef4da469363b1458440509815595b13bcd5a6c11accad2e0b3591a51e4eb92ce594434952b87693c390bc7db626eade6a9f99836ac1a1fc45b66f866f9788e603142a54621f18e94ac40070dbad5f71ac079566e8636ad7c2a8cb4c975e3aabb7b3647e173cdbda3fb3e123eca3565eb1f317d84fa581baca43b3ad31d4ee508c247e4ae282bc2bb206ea25df1406ccc5d14f68dfeaa21a22703dfc34e5f81461fb50e50e40aff3e6dbd0650208a2df7b4349ea6b4260fb53c5f6e04b23d454d435b8903254e38bc4eb17ec1fec097fc071832d0b6d6bdfbc22a5483e467d9f67127400c2b90b03b2e6499570817f4d7ec669bda7c2e0644076775d1fad416f02ffe2f997c5b2ac37db702a880d5cc92fb5edf802ddd45c5e638b5a7c2dcc1e4264149df0ecc116f6e3b6c769af0ea1cce4ffc69fe515856f37b1788595e10a8814e49264453d0a21082ec66e859c1e085a539a9099589b88c737c5a784c8d73a03fb8b4a4f8745033f38f9ab08554031598786cc5648aef5af162dd61d136fe3d7c5fb0321309845a7ecfd4340c5538fd3f56b1c15c384a182b2ddca28169ff876696e2420b100e85421308b759e3b157ba5736c5efa59b8bbb038755afba2f6aba6fbad90d8c0b0b18ff73087630a596b0e2ca370201c679f60e0b1ad0eef5f5cb53cb9fca1366d3ad8146c24517eb735fe51397c2db0e74c7605e2afce51f3a236cce20bbddeab8c51e74f8be9d5d927e56bb1fe74103e26da3224785475a4759607885793e4725c53063d1c2c2249fe7d9f8757bd1a891537120e81d3d6c4f1cf18b5b6d46a1f6c4644548adaff0856db747d0c94d416d89ab10e9780053dcf1e3b05b5e7a4a5a7fbbbc43bb90ffdc4ab42f971890ae30c7557056548150de91194e37bda576b5c274c3bdae7095ff256b37239d8ac0e5b51d4cfad1a03fe83300a8dcdd654ee9fa731d7df61947207b4fbe0cc7dd7d6e453b1768e479a669eddcba35a4ffc01779009bbd93e71ba71c4608823c0d03ffe2c5caeb7a1d93a9a36d03de868947da1aa2cd9bd9ecb64d8d142e31e1d2c19410b0e45c6171080c883bb3fa37ce6148008c640f0a502f001ecdbb79779623a70bc116627e93fb9925a17c58258054afd356509624048ee5ee34edaa3a8f70543ab342005a1cf2da8dd419ae89655d006c6becc96ecc0a60ad5c51221a676c372cf437ec7b69743e159f90c526a89a7e11e2343e469f6282778cf3eb805ff7a0b5b9f0d67414ba049c36d92216eff836fb3ad9d970d99bd458553d749d08fc11c1a61c43314c0fc1a38d2160ca01d8eee13081e0c95695b56f350afc81e4b1eabd0f4c29ae4f92775a95a5b3302f69b901d4b663c4a4544818ab882726209a78c17ec5eda6c295aba9b45f422b9f6ee0aa74ec1b276cd5459e74158952d8d3107b11d4a09658fa99abb239318969d12f65016766033d91da54186de4303bcd2af1a6cea730d3ae5bfebd66119b76d985f5bb4f7dec1c2cf89e6fe7c1202ee19f3e91b3e48b8d0492110cf5c6d167115fcf029986b421e5dc14739e9c63181f1565b11af16a86248f34c061a566aae18b51376b3a17774dc5d0cbec9029f27e793a215a7829f2e35d69bfc4526688738680b3d70ce8eac0c4767f5922e2e45fefa195c79ea5ab5b49a9ef9aaba624569ceb9af665ee650ff49157f0d1dae86d515ed4b3d1e5f23df6318e79716802aba65740e619cef2192e6358b40d95fc8232739e2baefbf3f0142a6ada5876734a2ab030c2d596c2cd976a5ce6dbf18d72a5f08cb6405491167bdcf5be0300f04ea74845bdf5c6baa612b4e0611e3352c514c5e6c7e0032b8092c0e51af615f6112ba1ba068abac1cba8c62bd92f2b1ac244f91defe24c65e6dac9af534cc878abea98ff33160dfc802321e68ade358620a4b7a0926513e0375f00859c8b7822c29fa7adf9b1b6ad72bbd5d5289b8c59bc88b0c8ef666dff7075c1f11ee0d824a51330d338601f4b72a0693e7032b2b9145b9d993bcff509e8f3ac51659509c532a716460a6e45319691e6d9c05ac0b7ef675f1fc43046234be8ecfbc6a0e7840251aae478200c879c79130a33ebbecc30a4bb056d3f3ec3b2d947d1c5f3214f0c5e6fcf21ef1489a4fc3acd33d67b95434065574bb988873c3fa43356157fdc40d274914a68f40365be7e72a7598900ed6d9692acc06e975ed8b9c12649d387a9044fe1993e0389927e2958d862b86242a2ca6daa70d0c3d6eca50c5ca4004c3bcbbfa1115519cff3a2013c9028b4cf7bc2a4986b4b83fcf6e67a43b6cc5c879f10810691365280e26b16609dc91dffd20021c41ef2bf0509ae6d2e92caff1cd815f403390458e53626f168172f5182840b53046d9ac64c434a5309f742cef084c31d890ae3cd7b5a0eefa422b259a96342e365bb8a28ab4607196b207dfcf746c8351672d88ccf5775622af4694f5079cdf1a68cf851ebcd5dca90990c414a07a62167b15079302e4abcaa6c88c1fa625e7aa486f854965550ed0436c5e1c84b84d54475a36e766bc3aa272f52f7a0bba083741470fafda0c86637991e2fb9912c63d1a459ec12af34b502168646d89a7a069edd2c5c5787d3ebb1cc9d7a5f889421b2888d9c971e46f8f1815d0259d2cb480fda694f06f746c905bd9f027a7c1044f32b3998b07ac4b98ea4aa37c0c0e723131eb6810898623d3f5cd557111bddc158856110d0e1cfa9f50f9792b050f40fc91af28c006cb3f13c3bf03bc9462d7bd9815f5f1bea0d1ff2a0f3093fcf7fee584ab7e43fa3c0cebb03336ea2a1fb844cb8205d9f69e2eae1bcedcb1e81bd33d48dc5d5edf05aeaa52944f30b65823b15043a3cc483e20971b4d0faff22e083215d2cdd6e047ab15566be9dcf985ad5b04cf681c5dbf7856fdd8f559a6831006ec096b151ee9e55bf3144291cdb86da4d50ef8b895d33e9812549f5d8f62e2fba22c93d9e3ed38c4fbe3f1d4bc5516ce27f6fd03683ba62e7fe4daa3d52397d92984a93d48e4b5d657e2e0516a8e99b338e775580e91b086c554cc6f2543ee9ee8fc4130e0fee56905350aff39d9a59d7ccd5db2e3991dc7c868b71f5f8d35af8a3db6691d915b66861debdf21cdd369f66b01fe5e7e04aec987c16605268fd3c585bddb9682fc6f8e3704955b07f2b6f16a167d47d1f7d160502c24cddfecfb98aaf3fcf251c8ae911f8dd865b44b3e43676ef3d5a1b656d14b769b9713a36a93286ad939a0fc212cc64addb331c01888a9cb1b625e526af1ff9e4da68d6ea62a2d9e9372622c485add94079b3f8c8accfd6d654e462c3b078d1bd1a581e31563ace779e8c45ed511176324a5d7b3ec110c8ac42c7f408a8549f962998146902708b0b55e6402f7ee57bdc8c5c8d0ddd6af820bafb5cee062f22a52db88cc5ec930786ea1f238a27d6c6b833f92563ba0f19da4a538c4ce7d1f295df70e9a1f2f4265cfdb7f8e045172744a2c6420c545675144e5448de4afbe325202531815e89611bb36be950107f538550ea3a38241a3c4ca9f23cfa0d6eea00747116cf0f81d719b1787cdd3559ff46f82c7033b940b03293876936d4ca980d9077411faf5fd232b50a00db271b1bac7da9a8b919b0ab7fa8217776ec800d9d0a999461a70730157d51c81130d038f540af2ad5d9cc8626c3910128233ca8dd0f9aad7b0a7672d1ae87114ed352b4c8e26e6d388d797b80e419505ba1136ffe8c8d85b91aeff759dab4922649e8024504e50f4fb6c407f82fed2c2fd3dc1fb351f5a74b95c6f0eb312672af4e340b4ee5dc1f80edfac8b2166a5e732b6b250d1e264af397ab5f5c25230d65167c3442a44436f89f5487d58fc2d1894f4eb731515a4ae0582db5556c8f00d101aa2a1075f79208965c7af7727ba133ca8c36c400a3a5ec90039822cbd5d0a0b81dcce0a276be11cc9682ee84dd87a6ae0549f7ef21b88d0efeaf31872853fe78421fcd2d2c052ed86a51150cb3dca4cec3ec749a60132394a0585fb03eadb3b55323766743789b1564087d416aad92a9689c28bea565070d825ef41b2b8b36aa9e49b34ec13dbc078ceb48b119b29697a5df41b6835b865feb58be593f62ce88a84279218d02579bb986b237813e5d33dd1797b978c22015d2484f86620d46ee852df523a80d92db8b563aeba457a1b775d125cff442acebad51dc0eac9e5c5f3f0cd4dcc6bacd3ae771ebf7bafa9e2f108363643837fe92eb2f25a86c8db8c09fd829f6b4500d31e08919f90dc23ad353f587e42fbc6e01b9ea63ba70b5de44a871f7bb4f8dbaefe08412df84e6302fd9acff268917199a1956e4fe5e4b808d4bd16002e60d6393f268317079744b43ec5594f1a8e9310b282939bf6ee62a5b4412e8be6a6ce5ccf09d74008168f9923050827866aa25c513d38683d238d2b4561d4b2be8bef4092f213fcd2a67030c7a12ece75c43a205f973d99a0e24e8bef2ecd06837a32b4f2bb151825a3534796492d6132dec51f983ed3ed2b1f4b81f21aa7e092eb2309cbbecce5b4446d2b850dbc06ddfff0ed6ad65246cc418f273cce80cc7932334e3d23064734bd25d03c0841367fc1dff5eec15d3c86abf67948db226fc1363b0df17aa1b7c4d9b53ec66590ad9c23b7b57ece3357cac8d681f1226bbb07b2ac6492fb8605b47c2036d5369884dac25dcc0e576671491c11f83b2f40a4481863eeeada3bada11d5250aacad80657711b2dd9f59f9bfdb2d6ce17fd3b5825623ba8da7e30f034bb58a0e0d68b3507cafc61cc7f5559f2ce8cf00f13ae5af25c2dae4de5e4d6e159b50187fcda13dfc18482005e02582431de22f473e3812f35506a3996b0e49389976f51ff5a03c83c04064a548b71ca4fd6a0ca99730dad455b096dda301c264f0eefa6831b51b9a5b5d95ab9dfdda01ba30e9c54425234de68ffb63e31bc75660e4107284bf0c96ac2704c3bfcb59d59d34ba8e685e6aed3cb4638c0222058e2810b29a4edd99268becab90980b9ca1f9943482bf41c6a50f46da7538fbac9f88abd2424bfb3a3176d3d53acbd952d7b3707e4b7da762e7ae4d2447724e3e79728b8406381736fe1e1ccc6cf78b946812d794069afc211291f95b4e98ae234cc0b3edaae6ccfffacadc9c32786c786d52c7cb8fea28311bc47bea90acf9e114dc5ea845f97644b099bbba5c32c93ed9acc619f349d6616a33914241dacb2519acc0fdef6c52685d7214c5fc3d00ab2db7802fc32fdd360006baa7e67b85ed535749835f6e0c49ca59c77cc9989c85e29df71584af9109c8dc487c1d109b7917562b6ef76aa1dc9fcc2c1e3eaf24047b1bca46e4d37d2740856ea8f650817ccbdb1d41b2aed51f3c616dbfc073c287e9cea7d4d24525e4b0395965e661e4584e1b0ac1c418d827346f600aa87752664086d10c1db7ddfb13ef69f61a78f738d0e7d0152fd33e1d0e432bf8878a7dc89208ff6520d70d7f9042393d46ea4927263bd9332e4dfaaabad408cf19a43439f4d1016126efad13c3f662c9a7e7e81bcd0fd7f43083e573e9bd0147d0eb8e77e590c6cd8b7df346eb883c9652179b7bf80641ea6c5e1768fdc30a6e4096c72abf7da254c727d2ed895ac18950ceb8fdc1dc1d7db007c8a22336c982d978ad718d9799d7bcfa31c3b95373e9ccef5de229035dde429c5e3cf273cff79cbba478abf574499453354628916d0dbed19afabe71cffc20c54fe78a4062b0b1d1368c204f0d003b412db19699bc6e38855d3d532056464301061b5f87cdb11cf37091860ad9bf062607bae59895675308f5601763416aa6c0967a3beb2897f464258b1d798b48a056841fbc1e914ef05b8bb92d38bb9f17e550d37108c6237b0092957e8dc826dfb20d77a9fd6ee13bba59838205626a60da5ca0f0fa578eeb74ca9ed6f2628db5e65f73fe8f6ff7f6b6e589e32ac09bafdeecb671f4853f2241444fb239281159d15596fac534b2677814dd67fa0ca4c88f9522041e5f2baca03e8f62f1f1fc94ba3712384e199a0e8fbca09bccfc583f371669c606bee2f74d8cc0983590088a33b85e2eb1cf058a9c29d9628f6df8c1a45c93c9312ee46a594e10e49e61fbb9ed58089869a010df335bbac340194dad71b55acbb258812e2e9e63d165c91192d2eda01e19df24bf8fb98efb0440b3f699e8e076082715170751743122e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
