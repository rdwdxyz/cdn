<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"03df49318fe79586530b01fd2aa359522f1e9d72305af5451a2296b266e48ca1c763e590f73598288c44bdf4e4e9be2590be60563071a3889b68cbfd31b9e5301920a9fb66ac03f06fe561dc283a374acbdba023644cd75f55f95b71f7d3e0101807aef8731bdd1942f3e3ed563fa32d263bbfde2917635a75334569be0af97a2ed03c9f58dc0101064cac019cea43bd717a295f5b765263d7510fc7e8c92fead5d24053b4c33cc8c793c249214a276ab70c7e2be4345186f00640a0a22ba1179f72c8c6a826e9d9e95de3bf321575f044e69c2290ac61b36ca62496f6f1399a9af10f33d0fe604d379a12a2626e1ca8ccd0e29365aa2642a2d7173d4fcab7d7315eafad1ec59a834eca1efaf0fad1f3cba53830c768fe2d18cc5019291b71a5de78cd2500b47a10e5d7d0a440290fee44c07d91935089c400e6d903dceff930319adbadb11a71559bc6cb80e1d13c9c4c7cb4f2c8f74d433fb00c97c702b5a1d85e86aa78fd4762967e664b7fce691f2221fd64e2ff7904e9bddedf0cef121d80aaa7e3438f37bb86cbb6721e352128b82145f29967fc324fa18909ad37f42d3d397546b545fef0c5aa125fcfae966f51a4c7d773bc4d48832a10993cb66c6e8cc1bc8a21ef5def96c0ddc2d953baeb6adf6cb1b3fef815346b79e1469f288547240ca815e942ab97e1271502ff3e4d9c2c0c6d1ccf9dbbc52a4445d8b6583a2815082aaf9f926d8318cd5844bfbaae538efa68bf662776388f6e43cb3538d76ce53ee34bfcc33dc6358a6426280d849ae2a4e5a2d28c07b663aae240671280e88e0978819a364a0526ca5c14e73e6dbd262d19ef0c294fd6d41190e8a7f6b40b510cd0f38abc5672b469f97db3d7e321b51653a72c056a9cb62424f8cb0e8c9f6bb1c17111c5ea70155efe11000e1a5004ae878ecb97638640a03537ea0627d340105fd11ed548be49219f8e13c40bde8534d6f8b7d670dd8776bf38a1793f1f11d76d8a755c6d720a308c5fc3fe5e648ef64f77cddbef431938c2e4192c705503f775227c4914b6cb2d5d39a622316cedfd8ad82716f32ddb50338dfcedce7dee85a8b4fe46136f9e04ea44258609f3b8992343515a55e42f2964be4f89368e3a6a1c484306be1b7907ec20a61420f8c1310d37055061a3a11bf4ea55ac0f8946fe0fec25ab9f301a8d36a3e79cd28415eba14eac2a913000fe2c1eadccc24981655b36ff4f1b8b03e9d8903b0ee7ee70c9a690edc4730b5ead4d644876828eb37bef88464ab39132ad13d988ee888b1ec42ee0888f399756a5d65373f97b4ec44859cad5ad4a4dc0fe234f2384b02cfbe26153b43d3dc71f53a8daf3e2eb343e99c5b51a45799ef2c1219b3f9a72a6907b271386cfc7f427a9e1a7ff580cedf7033959bd8f51cabdec71ef6c695113214827201ecef6c91108f3c6c3269691734e8e96e32ab8326264bc202b7d46e84ac78bfb2f49a4956338bf7fab81bcaadc74b04b9bea8a1021ef093340da120b0002b6bc1fa1e14b26f6aca5b4d1477f21da3cc2664b5cd3b5a0fe928bb8fed35ba9490c079cc7b1bb114458bf6cf6ccd7cf1b357bce264af0a1c9f37ddeb4bfff9b2770a59c912198ad19c8ed5a4d27bb9ac299595065ef1d2b0b5254cf73f4e2f6c16d2e5fe8c18b8f73c27a9ade2d2094e227de57bd51fd506dea2a5d0a4cb8161b76fd35eb97ce6ba1cfb3ce7be3d24c0cd473a7e13c2ef29b49f09253985d8543e8b2a97ab51c72a62e208db081f08e359e4ba0b44f080076550cc2e0a143e5aff2a49e9a4e10fee32d2b597ed162f822d20f49a067fc15dda5cff3f48f18bf84d9d5dd6dd19f013802655863e2f3c90bc72ee023619e545e4db268e6b631f2a14a2cc6cfbcb16a17ab8eff82ea2631551e036bd8ce297f3fc53f36cccdaed0a4e1e092cdb11a13f164172b25b04e6ec49a1f87fefb145990146176fa90983a82e3132046d65ee40a9e0bc5c399218e6ba2c28b386a00a96b4bb70de19e1fed8aa13c08dcf62c955fb39e5547df1da65a392a68f4b859b46d0082cb9b11d547a495568365f54d6289b472d404fc231d2c6f1be5b0e9dacd49d8f7878a91da6861ace983d535185a6202d288864fd04b33af0df956827c96d77615abb7f0256827f512ed85bd048957cb8bae5cc9cb85b85f7fa2796230c1f98e75ba19ce3b19961ad1e632198f691380afda0520742d4ba50419742d9620f20b51bbe7162f5bcdf06ed3b3ba304d571a86fae30c3ed2a50402304326f5e441d95d32a1324d17d21bc93417af964084f235d83f3e9b8c26e1982ef6e6ee65948b2c265e8ce0c5e172000e121146eef58d2ff54b114c8a660e4df9a905e2481ca46ce29b5887586443d853e20d4afaa3f7c74f850797fac2745769c11eaef7825e93dd20aa41ac26de6368c0ed9c059d3654675eb4e7e78d43c2bdef04eaf424403910a4539e222d4d63d839679884fdc691083017c1a522c69b2caffc31b59063c27ed9f39ed0e4887a08662c880ad5381824a5cbded9775ee43e6a1415555df45501d438864fef24900a3f1727e53a0c6cb613f2e7121f76171aafdd1315a43388b0be108970ad8e2783a25b8efa2002beb0af6b77562a3b1a85bc7ddb1b9f579179e6e94d7bdc23277c962839c6df2615f9142fa4da17229dd13823dfde5c2fbdaf7d113ec18ce7c6b0ac27c2939149f1b87d224e6852e45eae8ca76876155c0c545a8e71ebd399aef5a451ad17a034957b3861c89fc3bf9d4cc9aa1ee0d50f8f9ee2986d9929fb8ede7eeef690c92236fb544d76bd00af9d6d2938f6e6fa714071a2dedcd00b84e9d1086a9dda2da1b896bfb986bd68c3bb6a1c7cf252e9baeea4b764f8f06b81d1b416c657754dd425088cd82c2752141561c0d872a396b18d4ecec950c824a9bfabc7677d2585bbe503741b2d2ead2afea2fc0b98d55d42bd74f8ad18ab86b890d0f07db0126500678f13add8054c4f2dddd437a86c27cc9a816402d9c3313944e3c73d8eef9345402c72232838bf4f34b49e7fcc106a1e802ed1595572529778eecf7804643eeb716f6c43e926cfdbfd8d90bd901ce16eac14b98f7f17c6b2ddb683bda2858713d2ddbd39ab72125917c36302c59e1e5dd5bd9558107b92b1b4c0f794cb4733081bd624a8cf41866bf385f555bedc78d2dbf3c41623ef6f364e47523f2caa577f411faff109b1dcf81d3a801adbd64c66ecdd666f81108a7888d7d9fac07e2e08edb176e4ea93c45906f0afd1aa871cda618eda5ba3d468eca6b20cf34c3c8c92901cb285ffb3b0cadf1de8c943a154b621048a946e2e1046b5b65d95485850279f4fd3891dd221e0233ead7e2fa2e9528de039c71279f5f5e6e4c5badc3e9e9fa6e118ffb91762f6bb0275a718bfa663e5f42c992dc1e17792b108ca0d7ad47fe9f5e4b26d11862d499f45c582db0ce13abfae30bf600b88ed342ae24bc8c34b839f4575033d1329cd3a1abb164931eb5c0bfef3a2b33a390fe2c2d1bf6d697c9778d11fff891e2bb49851d4d2ea752b57d5370248e54d10ff83d85b32bd4138c752d92c209142aaa662626d52f585a76e43f7b8689e90a886fa61e6d446cec6709ade380ea5c35a7ece0a1114531803d82e30b1dc16fa8b13742520094e859ff92cb66307b5ddb2af0d1a1fa163b78544a0d843e0bdea183adc545eec512a200d74f3f5806f7bf203efcd745ad7c2ee7e827009b1b3c1caabbadc0e1077b6e5b3890057971d40ba0d7f37e130031dabc75f1b446971b9aaeb4cb652b5cfece459e2eddd3d959418c0a80f67f547d695fceabaca77fbd794abe48fc2081b3c3fc780e93a61eafb6a9252120190c2c8c410be6b4af6692d0f008497aeb971de29960264bde41e6aace2011eaf0b770ae772ad04f4b3144b3d4c012ea59437d999e02e4aac32cf6a22b8a68aeb996fcb17e3695d72b5cd70d53e6d44055516872956f96f63d13d5e6a7498a7625587ee1d2e2daef97ec5ee6b3252d72b504ba4cbf5fd0b1308f8957435513b5e1d572441b738f74879e6257fe581cc13238b9eaee0bb67951dcb60f6abbd2ec6da3599ab80ebb57485161c06ba52df8447ab6671a35262169ee7f4ef1e9da258ae220e36d4d216597fa0162be51f9bc6e3d2ebafbcc6d117c4913d23c8a6a1b27fa4d60e7ce750c642224ffb76a70ee53d09beafef11197c9c56260a3532ecba0317ad281499bc1468093895525bcacb932eff15ae29f511205eb6b9aac06f6c3095cfbb9f0faff7c766c5f325257b16ba1c519782c6410a47202f2271caf905d4c2c5adf82b633c371324efc7ba18a4ed218d79ac653ebce6fe7a1d2590fc266683c346cc7707d794729db3bbcd430b55dc327d96eee7ee7d8744db1499b30a8ed35d2ab166fd287bbb243368ade6e80fba74de8bcffcc7064a90cd5a407995b474939fc1a47d75b1cf6e5ea93297ae8abe61e166577a38f380133b311e332058aa0929534a53ce4ac9ad242f94d22a64ae0df21f001888b3e24d7239f287040810910f0e2a05beef90ae030fb04f3bbadd4998634e6f9667d583d4a25ae0181eb0a7e96a1467fa8ece33d4e1793d506c11ba37edf66b4d6d7e6b1a33514f37aca832df04fa21f5be4a9e2f886fe1e31d088eb4173ce8b1c76fd4ff45e67e71837f8580a039ac6808f8d52270f0495ce7e4152d6af605a1931460dc22ebee55100e34e4444f1d2f18c195e0084f4a64a1ef17b0248b18cbe5d1996a23de23286ee503af9d6b69a6874ba3a1b53b430eb3be185c797ba6c13bbb2d87b3226d3b86ecc34e5fc2241db4020075b771855de247da7175c5b0c48a6227fbdb87308c32e5490f0b2733e1fb386146506306f979ce100a52b140e92e973630d07e24ca9e8b038f8c9a5551343489fd203891f5c25975a43371f08ed08d9eee60c0fb9a90f80cf34d35c5c070cecf6f906412a1ac0198410f24a160e5ed19e94313dd5f2e8289c2fc353997064841ba1a3700783706615e065a3214a8f4671e16908114383fd84f08d8240bd719345a00a569521b54e03d6a71aad9603d4e247007ae365ffb013ad7b266147fbc74a0fb4c81f2b1f7d5538cf590053ee191bf030b8688c5999934d651d2cb5d9765be57accb736c94cf982be9fd0afcf8ff7442b37ab4f7d98e0504adb6e21f6c586f03291ca658dc30370f6b13742e7dfbda242ea6eaf9bb034314413f353b4274b2c49d03a726986cc05dfc56c8b75424228318f3ed7fb95862dfc772d38b3a7d723ceb614237017aa3fe25c759ae5790b36679d92c1439c24f1c0c007ff075d96ec75a37d254055afa6f1c309d30504109b0d02694111d05aa6af939bffb3b9942209992331955272542fdbdb6da69674dda1975df957da8ff134221e60e8103d89771195c5a058f8dc6eea50b870c23f7a109ecd5c8232180277d62296f2811d0cf93db671a9cd86d65e0d041d32aeaa9c24a8997ae65c78474d5f984202343e21de805f76210e0dca79f65a2276a40ff0bfe7aea18ec520350ad21cfde1984f118ae753a31b6d722a8eb1bbf3e404178956d13f589ba04cd3c0561c6a357dc13bc500cb64279c0fc13eec4dd88d057fcf5924c9d24f2d85f2384e7b07b451c47db28277d28f35606587e0fafdde38e585c50d771eff45613b36148016c1c82d842139b462fc373921cea5fa3a7a8f5ae97dc3b4b65feec4b6365b1aff4d48864c01f12251e665a67398f12d51496dc52b0fee4ff7759129db544379f75d01f9b7a3bf8a2bbdefbe8228f21f92327f25c5a30ce91120cbfa48bd5a61ee2e1b6d3c8e77020143dc4ec2d47d696fe5e04e1f61b5e4605a005a2e59afa455bbd7531df631bb2f65df118c03d19f091fc32bf0cf10613aec566cf3f5bd013f08859c56be2c2fa9ed083308d26ca90f91fcb83a1b8c23469c861b926a0e85115a088d814ece5bc274cba6479ee93f0b399cfb0b8ee1f7fc8ef227047785e1063f70bad6d2bf29507160c8f6562ab8ec8749d397c45919a7b704787faccc6bf5703aef2d2af8e097c129857ee49c47196b3625b06b4bf934746fbf290532376b500594c66d9b98772f3fd6a3659208c05d0d06a15df94dab1874da1a21cc95bd150117969923c1bfa01224161a5953ad18a7f35685dfaf0329fbaea200ad0b5262cee4df74871fc31f60d5e2fcd71b42f10babb92261962c26a60db28b296789a61a8e1e40012f9ba5a69aae94d4d5af1ec6c2ddef740812a5fe04f1200bf909b4df6e1cc855e9fa79523cde1b9da17d061c206f9c288aecfebf847f646c98ce1320173f520a5a7dca7bb57d1586f546e8d1c39b30a1b4d09adcd2edec741eb69b1d3e39e430621cb082569479c932f97676c98dfe3c546f149a176eca9b5c6eb1ab668c52ed9d97e541a3b14612cb56c87984e2762d1cec8b0a9af5728a68f2f581ba8ed5a1a38b6b013084534465fdfaa83f59b58bab511c22533d02c99cf277a46d2ab0010c6fe757d8b32436f3cd039e9c426af075fdcddf5a78bbb3bfc1e3963fe1d563b680d913c703d7ffd45190ccb755fdbe09c843e0056db9b82c0309c4b7be2a9f0df1d5e076ed3adb168abaf6d48f02b9f14295145e464b7fc5a218c345e818470dec659d4641c70fef4ffe0e62b34f2ffacd539da7a255447272835e6336bad2083c755d636757e56f37e156ea73c7b50adfeb16c62194258c85b595433b5459402c330ce4eeac55696ca292073ff3356945faf8a05ab26b8156a74ec0c7af1e502b5c5d90dda512cda51f02384eb7c5871fd82915c12c8c846f8d22c95c5d7b433bbd0e81c5b759377483777d92926fe4ed4a357b920fa7015951f2fb777a8bf0262646b1d9700f782b8965ee5ec005e445f839e5470dccb4bc391e2bdee10aa6584ca1051764db3c166cf77088bf2099d43314126a6afc982d010361583d1bcb4cb30865131ce8ff9f18e99485a1ed4a00c634e91fcce942bb734d1d5be53baa83b484af46df497b34e73dc8e3b528e2e794ca7b2b9bf269e909044d792bcac4087c8707ef6ff5d66dc84e1b181284983ffe0d251313f2c7f347227f6860137aa002339f844ff7e20fb4e1847090f5e2ef189b2c94f75fa5fec685e0802e7c2df2288a008944522b9388e424382bb08aea6d922ce6d48d28c1edbb70550ea457e2214d5f4678847a24dd6665bfb3f0733f036dab238598145dde116412bb8b4ba90d5d2c1870cd274924157fe6df68c0b4cbc5074d3ddddf4c33bd6b9183d355785ffd5a361ce3e131684d3f2657af1ca6610ee0bbbe7fed0efc32fc68c64bacacb077b5f344df42954c984d8e4b3ec24e8e3c60e77b96c1f5e4f420bab80b10003865d6a4373746254ff3a1d99a1d420c24dbdeb03b5214ae14b676a568735b55d809f85d3dbe7f74ee45ced6e724d9899202b08e59339301f24d73169f2769748f8ebc7c6f291b20fc146d5f8998ed13e978c03317822620f858aa207ad25cf6aae8e6503fe1ce93112a6dd09bd60c40dfd74716cacfd387d742cb7d159a508a7c7d8694e7c93000d2ced8fdefb34b33692c08bec36b852858a8b6cc09851764aa4e13bcb7d9f999ad756d703b926d86397c003b7586f77db902b44007db6a6ec3714c2c14ed484653c215c581e053357d50902f1ce70e9656be78c80676f9ec2c10f9de0dc04be5ea2d6d97a68e117bc3752c247e8ec5c63328b9fbca350d03d2896e63181ed65214f7121667f27768eb0f693d6fa81aa2e1bc9b875e000d623233a79b384f54d297f0f74fc69a7526b7a3d70e620c6cb609912f14e66d1a01c8b8ee1b39140f9e42a467fe6db338beaff3dca4b588f9875cfe20da6c3ba8adc00539c614c01bdbac1f2acd9246701355b1f43a6a0aea3581fd4e8b0ba0b06246500e0ed0e57d7273fe54407fdf019a6bbac6f7bffa760a4db5af7684f8905d3b1a19c2dc50873340302049efb79387d0fb2e1263f366b0627692a2e9d592c1f39ae25d31862bb6e1d47cfcad05d0d2e04ec990ecbeb315383d9aa46103e70e3921dde2cdce6be5619ca804f760273635f73add5cb25fe4f31f0da93ddade383b2acc0601772c6589affc956f1d28e9fe8e4142cce3398577edf17efcba3e698227b068e330d64cee36d94f751a9d8ac3fe564b742a4e9dcc7305383f5f41650caa0a789174aeb6a791d5b7564a82567f77d96a00776201b45b39432f9aca0a6af13cb43f9e9e8f58b5539ca198a75a4e85a12f3225fe227f92cd11f8104bb987afc00abd25fc6e7f9eeb4c32fd382940d28142a88fea28c59fded9652b84e05c675266ed93d721eafc5e08dd7cee28452eb215abad9ed96472bb1cb2d8232a08679c1ef48ad4621f3cbd16f24c32f4e206c0f6ab9ccb243c16b6d30d5407c29cb24ea7adfd4008f89f48a7383e80c9423cdd6c37b834fc1c81e6b5c67fd21af310ac28c7d584a06eae051f487979a132d0878e1ca8b30baa2cf80725fb970592cbdc907bef9ea39dcba37d209590e34d7087a7b807bfa800ae4f1d7f9dabec645c8ecde1c5fb8d09ca83b498147a2f6aae04cfaac84731b0d4fe486febfee8839a6c851097630a7947db02ed538dde371ec71e5cb2905b097a098037f8757a15e6572d7fa0bac8979ad5fbb7faefe3cf11dea1ac6befd7c081ebe03f6ca6c42e1875e1f4d5a9ba4ae7ee70f96cdccb6022da6c05dbfc0436acaba14512cd04a91ea96919ee98a02851a76e341303007f18c6ed4447c78d22c7d0968b3318871f456f3348161d7fe59e9baee4baeecebf69d446bfccd88aa4a7d30df74cb1febcef828cdbed60c574bf6d916d91889cbba095f8f25124b5c0e388eefdca2693a7de99fc38fec8c0e69cf22f297d47dde4efca71407ac879181e7097f7fc0ee2e23b2e065c50aae5c40876345919b8666d44562308223221e71cfeb6b47d34ead57629cb9fb50f9e52d1ad3b4f63790481a54f10a9d199397b3b1235ab986803657435357440a3ddad09c19a46b644f65bbd5c9d0e8d6c88f8f8a5739ed9a224cc49944ef035d8708c631294fe982e741e69975500da6cb73619a2aae34fdb516269221f25767c7a40d1f3cf21a3ad7e054f0bd75043d6d8ee5083c75f7388a3ae2a8d297612f7b073ff7e919a89c799507271583ad0db199e1e6e8609d4da2fe36eb4a19fe91ad914510d236920a46870e2e6987c39b83fbb06049f7eddd5b617623a3e3397e1451a01f2d0896f1ddcc4c98301a49be35db8a06996cb5f1547f0f56c00fee9698eb19f4a7596d0ea200d560253f21d6ed4e39873e25e0a2834919161e235a236cfb6213e7a0aee7619d117e643feb1c353045bee20acc8e434c30c3fc93254d988c488b859682bf9e36f897c3b28dfd6fcb8102a37d780dafa3bc3dbe0fc2ba4bce68e35c2b50cdb91886a084b30e5dc05a6fe1be010df783c1565b75ab96b5914bf8c5477911cc5171c3f69c1625b8dd9c32d7fc40a06843d4c2bf714aaa75f1d2f4c4ff37ed5c0a9ddbb6f277667061d568a8e69b1964eaf27709e50e345500bfd7221e68f10ab304832fc47baa5447fae1ac655eb629d30114c1c8197fac3a4c997dc96d508b27796ea18363ed56ad944fd2d4e5b33bbe7a5cda39bcdc0fe2af38fe81f8689933d82948e5f298bc4685f14d1dd12ad80b6e0ce7499cfa932512f19b1c5e9f34265ed1c092de3251473c58638beadecc8190be7271f26a27a3d7066f642a3b00e17539315e3207777986ea8168fd55224ef1c7689cf0e37d76c12b27a792195719ae3bcf64364efb3af84e05a563ed600526a46c010070a83c92273615c397829a7e818bda9bfb5a74e51087c58ef883b9dbbd942138a6cdd6c2a7fa33f3570ffe2edfeae90946fd85e6676d9172cdd4c7f166fad84e9a3ffb724531635505ce06e24eedeed315ea15d24b9a44c16220ef279bff15bdcd980cb2743d6391780bb38affbf902dc85db6987a0f51370d39c8d8295d2dcf130298774e13b974dbd2a6307c29648a077e348229bc3559031459168d3a7f4b4287976f0cb95fe7e4dfa3e08af9c7226dc0b0b502ae2689870ea2e3f412e4e846d3ab78fc776bc0454dc17762892bd442554004657092afb733b6fef5cc185f598c6fae797b765bff2dd077443a701c9db234dac3661bacecd4799622ebeeb532b6eabc52cf8b38ab7f7769d4720b6d988971c4ddd862ccc9bda7aae6f374ea307268616d71598f6254fd2bf963f9ca33db40fdf10601912f4ba181b4f38b8dd43e44fbc35292babb00e0fc4630ebe985c4f01ddef17d75d0e0263c5b6414e5b943124781784e20b977aa30cf3dc520e1255b43c4d2d26639470b6fab578116dd8ee2ddbe3f9197b6baa2e9bfffea09874e721d0a30219cbfe83362e8387479536b3a4bf10b435a2dfe3a404cf4eda4b78e817179e1444373ba21fdc7feabab6419644191f2971bfe53ee3d6d081a644490f4537a9b2060dde7d3c2cb69e5b97ae211c402190eb1799c39128e88deb331058a7aa2815249eaa10239610b651b29a52bb363cd3c2951087d4085e782d17a8edaf7e866f379b2681412cbf0129f397027846a7a420d3666b151b4592dbb8ae61702023b0e840b93e05a53ad2e1966848d0cc67e2b520c32cb6a1630256e29b475aef8d5d1326c270801a0284173bd9f7fad92a4094b8b628c756e17a1a977f37107b00872ff14c5b353551e20699f99269235cee71e7f6ad35eda5e6f4eb282aab54be2f0e4cc77b5ab2e4fdbbf27fd8c433d73f9e13e248416d343312137b106a192c16a69593ccc7ed1abf50ee19083a58995e99fed9caa98c8b4634978b9c2badd18ca5e96946af6094123b0480f6bad71e4f4d4775e5a1514de491143462efc0057a2b964ced0dbae24e8a813e99a843d5677120bccc3e55557fdcd4cf3b730efffd76a4efa4e6c50c7f1b1f7a6209a72e562a2b57b88792c5bca04f1c29f347d7e706ba74d58221059ddd04baa62497cc86640c83811cc7fd7c13599614b83ac51300e9bb994d9b66fb121f2f5c6e9a3626aa57b8a1824ab30eaf4f830146c2f9d7db77282ff086b735994a08b34543f23fef188ea1df45d0476dfcde16845536aabaf41b7fa43a9e4edd6404a4c53d916e2c85c20de7aa46782c54ca1d1b02f820820fc64a104604566a587e8cca5c69b5c89f30a55b6bbe0929a5ee897044c611be300a42317cc9e53aec0d127bdf55af676931cec6e3e9c4b35f021b724e4b04eba576dabd99989b2499acf1edf9a12f8dc2d449f41ccc6cb291e8fdc70a375ec2c7b3301c847394e5a0569fbacb37015e872fd6b4c568a67ab64700cc8bcca2419fc33df93b8cf411105341efffc72941349109fabfdc77c3db96eac50a3cdc2a8ab5cd40f83a4e3265264956af39b71af05fd5abfc9757756fc9d1ada5531814a550c1abc6776347af242f7aa708022217cf7ae94e561c31e5ae894cb1d3c74005a80df43ca771a3c31a6bd3ddef9312482fa15eee38bed53b170c73a29975cc0eba41320618999e73c6d9f1bac717e11460ac39ad796a37f2aeec7a90ed2575c9e885ccb8ea545307ff8bbddc5bdbec84285f7fcceef3bbb6b58b3b17da1fd849ad5f59a98f6de87532e2c528bdd85c18abb8be498d9ee622e0ad7f21113b181311ec0bd01ca01bd983be6d5d08d8de8733967e66c15cc641be489de9ee0589724663d46f5a2c2a93719422317fe2310eca2e49030153f4374f1565c692d75444bb2e7fe11a5c3b27a87c27d4fbdb9ebc3b841ac49761f078f592d4fff2c0dbbdbf80dbb8011148fe9c2eb2f1d04cf436bf38edee797599398a4eaffdf4e493afd7ffb628fb9a0d004a5326f4111aa16d2e21dbd95cc6997805770a3612cbdafb7551b840d2a55d8553ed690be1d05d3f1961768083f17ecb16aeb781250dac7ed4c70951805c301a81fa485c85bd2142ce609ebe84995586dc0cea9a96009ce20eb4fe9dc13b0024c88a857c130fdbb655ed760af198f1f6ef80af4fc5c9f93c12a714abd6cd58bfa67b49c50c878b3f1c289470cb7a3140289758a84663e64dec64e350f5ece0ac589b5b09d51b650948b973d713a7b174d176015e403ca5ac16064f56a8a8d68c410bbb5bf68716b9ee22be843aaf5e40a39ac350be64da9910085b18132f6dfd2b95675d52c31dfd17fbd08194c2f1e59392ecd19c59d5b415ededb204e8e81aa7c430b36612371b92c20822422eb9b94806133ea23df97ee2368e953a30e18e191cd4927aa4a2221b0743d2960f4bda5ffd861e774dfcd3905968bc0a31a125577115889a0025e00b08099137f5476c0d403e693abf0fb033bef3983ef4197cf6e7fdad1c9a04a7c3d97ad4a4bbcdbe8eb3e8ae523b6740501309eb51f5664e8dea0b46b848606e4282cc9a89a56e6b0589115c1325e54e9f0976d28d1ccdd20fc6e3c0e0c80d67f3d0f684db3e42af792e048016f7bba62f3e8c698132a8caf6f0ed8eb2a850bb5b98c746782d5188003a261d608a2be3d943f60f5c52ecf3a06a9f91d34c980001c147411ffb1c18cb84405353ba30ba38a1581ea1976bd96107e4159632c4ef25449a5273bbf7445842038ff69cd002ecbb17037b6252684281209e44c4f73d8150d78d16f46ea3cdb81db6c4f6d41153d6a8aef42e9468cf9c0e146be1dd60d15cd69c84ad60ea24bebb64f42ec01c29962a7d11dbba30742e9edeb44f705479fb071924c2837d2955e988f8a6d74df48f81a32f3717a9c8f3b26969e54d5e37075416c5b307ffa356f93549cd74c98aa719c775b105d69a8b7edafcd2fbd18c628b936584aff24a4e79f0aaa3cce95f64ee03d2dd99a4757b3b9c1cc0b286fdf5de04545759f42ee4084a72f50b704fa802d79c28eb078e709de9e20f19fb4926f3dc47cb427ccd94413a696e4b037612be15ab1987d5f4514041d40e1bbccc65ef5cd8c4900395dfa6c4780ffb15c2b6f92a44a33f5586d958bdd41e381b530a49c701755ade09e6686fbb30c981280d6b365d1099c6a31ca40cb1593854a417085b847de40817c0feeb70e2dc2d7da9a9067902b95ca4c3f2463edfdb8887cdaefcf263578e45b5ceec2d8984748457cc4364ee96f6e4a07b1311f245ec5f3c6d95a7f2546b91dd504be1b14692f2800cfb3e0046eb4c917f96e5443e9de250442f190d52a3452c8f26c6c2e55d1cec42cc4a76a51b61fa18aa4140ae8bd89bf7a0eb095549d1f6d80257a62a83355ef81e82e7ac350dfdff69a567b52c8acdf485da963dc6d042f886a1aca4ac634911a09b906122b61ccf4f4feac934344d936d7179fd3c7cc8e6fa2f6158abde828401714dd8d8e7dc988f6b451a2397e83008ec18dd265b2825a8b44ab0f3bdb7a051d77b5f74c143a5ddef6a0d78537b145aa37ef311aa18630d4052e487f48ad2a1052b9b45c3eb5b6f17d1eb132894eaf7b59b2e40adc3838135dfe10c089476689fa8693b098c751db6b6aae17e97e3708f6bd3c6df7f6fe572eaed3a8a2d8f06f64f2d589a557698598cca171a684919d92a7fb81676276503f889de7440b19f59c041729bfd63555759a9e1748f703e9708940239ef6b1c3c8f984e4a0fd02ec05ee75805859bda6634f0f675aef80facfbe6356c3b4b8fc17b5c079c311192fe13c29b1218e254cdb15848bde7db3661a89a6481f68a868f4c09305714046fd23e78f860c908b95692eaf8d09c1b6a7534b791dfc8323e5274b5817710636e1291b45a2be28635beca96e51323143f604457931e62687d5c69853a473165c5520d69431a94aad17a0fc96a465bdc21a44a35b9c68048551b9e4a03ca2d3f1d8f0737eddb0b6c2a72f9b6720afe6a353ca8791838f571f5d95e785c40ce4c6f81a287614b779f376be7108027dd66ee11ef3bfbb66da5054b4798d8a4c0a309dd1f3057cf697ea5263a7eb9e29212316a5dd50ec1b97ce2542099419cc0293b2a26222af3d523740d88d2e88dd9559689aed7e73d142aac641f2a94cecd205b9c3e8be774b0a2648914a43962d82e78ae50dff7b216ab1ef544288bdfb9156778763abe39054578098e2fa55e28911378b15b48339e31bfe4393deb70a3c2cd1733a556447e2bfd5a38e0af2cad7d287397dfaf2441ff2b102c018b31d5adab9bf343e59665685d90d348234aa4008f78b43aa952dee830b593fb319c7a3d163e5cfd9a9c56e08f1ba1fc3fd36a0dfa368bf79de4dc21a1c251a1976ab6770aea194d14325293acb162041181b3ea642064327f6d8c322464b0e082b6fe65674c2857b0df32f3f7cd5048921cf46d4026590e31d44a6e88ec86d492a777b2f683fd9114769e999fe779959f8f43db06b0dc438748a1b897a49e0602e8ecf916cf1cbbf6d1ef3692b5aab7824aec233947779256ea3bf24f95d2a898e067f6fa898de590060dee41bbe53904c1228223d91bee1532d8fa3ae192b7661edceb7bc17e05969691456a849edfd026ad3d7e6b8165a4b2b6aa2a457a6be6a1c34131a42167d598371e0ac00f1c2033e6b40bcb0728a8da801f2fcd940fcbc1a173ac932f47b6465aeb4a41f21b474d1b029922e03b505ffcbb4cc2b5d00a115cc40faec54d7b195a4998faa92178fb637e59680cdcdc05961cea2dc984b989583f46b9eb774f92f406f1ca73d65c24035b64a948e38723c140ef84d51af607931c1fff40b086efe301871808c2ee1b6e0e3fa208b455b5cafe54e37bf9314f885e12730abb2069b0b2b2ef104721003c941afa64a2dc5c7403e150ae6a5c146bf2c7cac40c39eae02decb64b22bbf4328e5cf9c7e862b34341c46d880a9ef2f990effed53373960bd4a93b00bbd91a0466460aadd9442c9ee46d15af00515681929131f94a0938d24850d1096c16917f8d92abbe4e26fb440ff0aca7de5020e94952b5844b40aaa8983f53b3b73a7bd917382cf960fc0eb563e98e3fa7eb2743e78a6097e450cc847b83322c8c7cd8bc9acba819b0060e31dce63bca1551ace27dac9d646f69652aec7446297bdb98353b710aeeeeb29cd63cc3030a39460047593ad6a65d56ae8228c4a50ff16aa4c3b95480d0c5307b0b07909a3388ff2b78b307394263f50edbe82dacb6fc3ef3168783004ef65edacbf140bb67469550d2a62f131beb3f1460d6640388c8af1a75aab2b52fc5ffa14458b752a97e5c47d1ac8c26b6d8ede6aaa035a83537c1c455f7d9a6502e9648e300e70c171123c05187a757210a5a43476bda617ebdc6c97893866b38cdc30e1b9d3cf230ea7b4507cb8fdf1a4defea58f954076ed63463604673d576c6a0912cc8ca83a2d733afc882313f2c77754acd03a3ddee593a8e525b180979405aa0291b9a83c7a7ae86918975ad7531547370c6fee4955b404be8b6b2c4900ed3a4ed22efc2283c6bf22be2f0114a3af5986743cafcb043a423f4d697fd2f1fd6d23b1ef2bec79eba06cb18a777cabf69a2507c5b9a7014ea9acea180e3af9178963049871c6a4bf93f1dba176010ab33588ed0d952e8b4dfc319ac1c72647f8068d566b3ad739fa9dade45c1dda314a60e50639be817d671d45b818789399fd6c770032618cc85b647bf97823c370aba184866e61195e3b76e5a0de73e8739ecaa80bbb4d21cf0a1f5568d0580879e03f433ad73248149d5d7b0c970c333321f7c7d1b7261a4403fbff8b985583325eaf3f50f24b4855ef75ad75366dad25e076bc1876f037419089eac1f059431d5700ee70b581605bea524440823a4e6b2395bb01dc9b65ad256a0501021f8bc2020161765559398f205bd924d567e626867701cbcd5abd30ef7f146b09c9ec0b927235d38e0b7ccda4d8a3871d8edf1f4b1d3ae03a568f5b70a6e21035018072d1d712f47c24d07b5f94249e716ca735f66a0d3b17bd49b9f62204c28074f441558116e44c5ab38703dbd48b54c89d3e04fd87b17751228bdb80200b105ca41e55c0585c0235638d1f5da6cf3f2f5f23f3ee1141b8ab1ae49d5bd259609b2fac3ffd371783a6c4f650340ca811a733bbbe576c147e9ff30a351910ad8a75f129098e8147c07f4d5d6e35bf802e99b299697dfaccf2dfa8105e9b7e9d738e8d6431df85c13d6d48bef338310f1c3af49ccba90508822283e0f95f880c395fcd5a6373a692cd9e49a0514194a6af8a00bf7e554d59b8f657c2b836fa8624d81fd37799093f5de5d9ef838cf81013551555ccc19ce783071cbe94f5c5847680c4caee44f476d827efec89f1f0c6373f2832fa7259b91d7cbf7c07f2e28916bc8ac0d67fd713ba31be2e053dbb1045f8971fbf34b430a3950a42c5accaac06d535d0f3628f396333e7049bf14b8d3bf91a30c47c7cfc9e2a04060a938146dd3ecc46c874fcd0ddf9764d92ed013e5d6c134be28ca0729aa4199d57c643a1c2832e3e42eb26bae73af8b070d7b196887b76e6ecea80e4fd193633a961daa6174397d146b26af0483cb821629d08eb4bd9802e62403164daf1a2e7a99e1518c10e6b367124c171f0ac4e8160ca73792407bde7e0a8b59f0122ae634d388a8da8db823314c869037f5a0478ca3948c9a791012f4b4566daa50616b36d881eb0507947903aa27e1d50dce53ba3a5258730147ce4a93db5b161ae19929b319a33c7fc2e8b5f4430e82f812b371bd186367d854762d2b28a51c14adfbf637df23400bd7e1e6675ad51eb158fb48f6055998d229903e9b08efa10848feed93a969afb698a45751d13b7e2a6451df6d298569eda585d09de360286c783e85cd9665f67a3d2ec69729b6d4a082a8a85da75844eacd0c80a2903e5e4a5ec995b41c00657ea4647a0506a78cc0aaf23bfd81421252a2e04336ccf96682b3eac3bdca8e21b8d69265ba8fcff79f8a2a6d05a25cf22dcdd0b932a9e36b38e891d81122c0e39d61d781ab97b08a05bea2394155c0d54b2a81e8e3378b2573f04b2d388b4a0911cc50dc336b5b8452da240860ebb1e6d180e4f59a13f10ea08e8a263f6d9554bb1b535323a012c97997a682a5b605cb1080ad7a5300e6d847591f4d6f0ff4d545bdd45297306a6f63d031087df7a6cf84345e244af609b03f8198d581328aa973fa25aab490951fc6601d44076636e359ee106223b8517ff6ac9b353bf18c7969466aa33bcc43ffe7f559c8ddff4266def1c4e0e2a681c11450d75a8d6e9dc4b834dc44978cb70faf5d965a8f1aac36e754b66a909b181ffea268adf507d41d474a14fe478312135b38ca495f14e58742697e4bf97cf5edfadaa54d05554e042940ec5e60a543fddbd5ebed0477597b18813bc8494759d57d89907adfb2fe111c42db1da3a7c7e09ea8f1479700dfe8f4de624898472d607e55396fb0783d96354a4a3720e4c9114010d4fe306f0cde519a53ffb94e4c24cf100e50faccde51216b8beba7415c1ea86c0f0396a1885d7152886d9b7925bade6054890922e2bc5db80e569bab6750c3f5bc205aa0b08c88e91116b48e2b1e7de49e2b624aa9857f49a5f09580a9be455fdff5f57e74dd6b8ffc98d2ade4a955a52eb9f6552e1f740ef05d75b52ecd1bd7f9c01ceed1a4c662cbd151633db0e63a2313f812d2b869a78fdabf9dcba7f4b478c8675732603c68bdc747ee25a98a2b17186df3287aef9e5c223359faa1923bfdcc8b57e882cda51d4e13f8d2926779b223ac22461a00ce0aa38c51addc0861f3e1c5db10aa3f660c8d8d5e5f9e5bb7af6f9dde9670825c6ad8f1ce85241fe6bb3562939f53ef7a7c36207fcfdc1800d4ef448e60f28f9fcc0f3988c568ef8d95bfe107a250a8e5584d7006f259276d3d236b5180956393576a76e7a617940bb257ee66d076943d50e6978ecfdffcbf350357c5786592f612f1ae34df1c1680da6d2fcf9613d1c461d78f8fd002445ee597fed33b1c4434997dde10cdaf285d9586f5ba014b01338a7e7abe7090e5244ec322a2a70f81714f54d20f26cb563b2e7801531fbef44e325c9948e68b645e8623fd428f16659c96b537298","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
