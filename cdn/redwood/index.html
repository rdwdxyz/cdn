<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4074bf668266dd30205adf0b352a4e333d819e24da28bba54864cbb73380748a9feeb1d2a77f1f904e9c8d8ce95bf58a611867a1b60718df1ed3e014f52e4c62770ef3ec30e5dbf1446556e75411858ee4cfbde4a5acdd1f3d0d287735658fbddab5a17cf6c56e72e8039b503a849c82e6df8657fc245c831460f8483282078832c66e6819100b106395bda905a979d0bc35353252dee815fa4c1f2ab344cada946978f8be4a3d0279a23acbb0345bb977ca18a785447baa29894c2d3b8d95615aad12335ab74f5a1912d578d9d40aaad13502270847b88bdf09af6918f5c78944219f95793e956c9b74b7012f3a153b1a87fdbcc37991310d50022e4076cec56dda41b7069c824b444610e5232abd93976ff9de9b18dd8cec3b2c5706e90bbd3616e086c6296e19876e9cda1d37eb52162432431a2302340eff08d6ce7c081a2a55b144fba5c8e3ddccce37df92f81d60f15878b5090814ca0da0bf6a5e46297474a325447325947d91ccc01a12f73156ab291fc269da1e408ecf93b2e8f263401699a661655d43df76864577a1d466ce65bab2cb4aa8d92f913f7dfff31f3562658c7187bb5ceb45d53e1479d99e289f296d06d10af9875e09e551d50db0d3121cec22ef250b91ee217210593bb6c1f46f229bc6406d315498515ac6db4b6bfdbd7769a2373ed2b48efc426376d1594402752cc70eb8aa5a4351863233d74e0d36951439ef4d27348bcf255fba82e5f23e318ca2a4d74a31f6595c802bce8120d567342af44465b66d2c7a890cbb24e5f31af7c11f5395e175eaf8a71e34807f2f8855ea988cc34905d56d836e6c6ddb3abb90bb62099e9b7ccfa1cdd245cc5e5cb5425573f59a91e5907350e1c74e60c64194b915f6bc1537a7579e87faaf6fd9df68ee0c419a56385489b485fa12a3df21d8ebf8be0c0549c79b64e6e52a690a0c721b1802c51db04c104f9323738ed37004c1b9dd113be133a6e5c3886cf20755210f70177ab15cb6711bdc5816e50102cd896167c79ccabd184ce0f43bf783d6f026f664d729a665ab84775b5689856c274601ef2826cc8c806ff7a85704d8222b4bb074abf81a6b32262cd02939313da8a62f806cfa1ba0176fcb7d6aeb71c12fea894682f8caf5b2d40d9b7e62352fde5e09265ca90b919a9292bafc5a0e7d8d33d6b7e6b3bfb6cdf1503d104c48df9f6add0acfb9c3488ebd1cdf268d2d9e6b331523ceb481eef903942ba029502f69a274098c406ba9eefa58c6b618edef242f07f3de4d50ec25da44cd16bcb0b66f54043fc4e8cd8d0ea44c7df55ec13769ae6e5c47cf798e69b2537bb5b2dd417e55cf09e27481c504b4835d48672ecdfb8cb4caa9b35cab8c10d5cb44ec2bb5053117ac5daffa9cdf525ecd729e20ec310dabc90730b8eb06470555f0d4da6d015f6c413c9a379d5dabb7d37dc78fe9057f9f371c925fcd90633e984a2943b17481cfaaef1afcff17facd017186135f2470b3d323008e2a59ccde6f7b62e34b4d0021b083c38b261d5e9e5bccb571a5f967c06e52919f9380058bf7f9e516b4f913f9aea65e5e8d2fe07e33f1f6ed16cc94e64e65e34812799de05fe14a6bd3f8112e8c4698d2aad9208abba183fb1d0d6b2e79600cd742865c6677d9d711e7e10d6e32f33823b82e972ca4d3bb2f1fd8fa8e9483dadfccee8d1715a1b7571448e6228c3eb3df049cdcbf826001f1859d1a33d962b78ed3d1294625ab9b815260baf203decafcaa7b2e96000eeb463ab378aec50db058f1d7bd16395e5cc1a7cc8f596c58122f1238ec81a75f7692115e8133ab48b37b9dacc805387ee6b6dba26d1f340d152f9dbf043d719e0349730d1b546422c2258f713756e01b49f40c8510f6e8304f48a23daf13265112feb3d7912c1133dfe5b528f56e92ba44fa64eca8be5b94d4e9773d11e81e0891f1d00f0b7e365a56432b324aa3d5224559b22acfbc4bc0d53be9435b7c8a36adaa64ef448d2e084b6d52bddc100520c4d295291ab69de3a32db5287e2930a83a76b59e168b3aa69fc72264328636516f0b7a08791eceed29a23b0da59e5709f37599b7349d8226e4528edc5a32f4c439ec8e3190ba014ba8d5be46b11c5d4068e74b48f1eb2ef18be70313273820a220784152830fe2377ff27ddc9c6b253d63c0c307c3f9888c3988fe7ae8c46686df4629c1bc759ff3648d3be5e0d1c1ffb730137a0f38477dcd9cbedfe28cc04dce0d192585d72696cfede9517a4584948543e11dc599091c021c7f59ee047ac38c43a78019e5932575a9e13995f13f0472ff1416617dd1ed4b107f4853469fa3619fcf3ecf0b34787db0f078988fb55f6eab4719bf239f94a90deffe63582bf0e4657bb411c993a8e1d1e2265f06bbd6506f026b09daaee96f1f98afb09022c9947b754d0fc1cd9f87838fc9667a284a52d38b2263ce226c9a38d73146a0b16037fce4d7862a688ab226d42658e7817fc9790cf4b147b158e83f211840c59ab8e16ef8ec10c7aecd3fee9f023e295b4c6d41fdf9daf485a78a7019f5432afa10a889805a8c51007b7e9894608de76770953c836dc49386d034d93f02aab2efca9b1deed5e23a067e8a34f2527864428562f5475b1758252ba459d6bbaa168df0118338953af0215f6a4beabcd40cf75fa6a473c5da51bcb4426a2662369843bb18e711cc5669feca14a7dd24525b1958b31b41c68beba9380cdb0973635e72446f03d4ac9329060001d6158d5c9afe4453a9416dbc0435b9e08dbc04756881a51871ec5ecaf60815bd7ca6c09d1c3cc6cb4c0d3d9a1cd50bb899b5ac4855e87577e4a29a8158157d9cb61f7638cceeaddc34f103aff5eb172c1c8d25a3c6ac4111aafbeecdf6ce45d82542c5ef512950a5aac324bf031cff9cf8ebe74a0a4b98227d7e84e3598499b0280a3f46783bdaa66c7604a7dfe976af0de9e247b88487179bb17e7f0f0a9ab3e7494c8b62b85c6879d09de53f214e1a055670803d75bcb4771989ee6c62a8f72d21708df6b6fa9ec511c77065c2ceb4f08bb93fd0c5b744f48c3baad524959f8cd06e9efdfecd6fa8b9054ddbc9b700b58d898c74c08e0a331e211b393b2ecd572ec5b750b97ffe0e23fd3cb003bce6d2eaf7368ff393e8f55c333968c57ab7625e29ed2b7d4edc84c26b0b095cdb5eb4c4cd197eb67859b490a873bf01679b4c012a63f7845e547766276057b5414de1947ef4622a0f9245b4cca58d1c08e0e31fdd149c9dd9509b0bb958884700eae614758fd2634b41ce4d26155b2d478645a0061241f5d3fd6c621db2d3988303e599f210dfac11f2965c7528742d065925f9a96fe0ff9333bc1509ca8f86c3b273ba6879199fd44f2a35265482cc0f5a41eabd45920f4288ac75ee11647b36fb699d2fc0643713dd88ea1eaa92c9742e3a9cb645e8fc7773326415b27ab1689a594fee8aeb32e504277ff81bb28435ff96000c22d70a4bad91a48b21f233dd1f38d2e700ce5c671cf865b74a3a73e6cce007f085995378da1b2173a6a2f85193dbe1593dca4f0e21191324e157d4fbd97057e9d986a18954b1841754f5cd657efa9f703f2566238e2fcfe1f49048c9d534fb9d63f1ef642a9dddd7b132b2098725b15488618dfd3cfbc8bed2ee8865d7fcf4af417e86f73720886b8e9044ce2390c802b93860eee73fa818ea8477013c4dc0d00cac5af7170df073ce160414116ccc5e645cdd5541b7183bd25ef812d13c4d65053a7a55ca3951b20bcd953b7a24043c1c2fd6ce5f2ab1cd5bc50d81f11085877cd7961ef7eb4a3bba0c239aa4a8380aa6e105cf506146e74e40d76cda7bb96016f99a41753d5f389092538ddccdb7af288967d0fd81da7d1cc3d2b6fa165a1009eb44a747727cec66aefcae6c375be78a071db4a193906d8b2c9eca9c57335cde6f044a695d5154122d865f66252ee87eda86e0cee3456a7074c360a2dfeadcece4620a5d3f4097e7e70b34b6deb39f1ea272122fc3aa8337c36a44d69e31e9c0fff77711c3f180e01acadc25f8bd516e3f1666ba31dc85fb0a928041c475d2d5f5796bfb44245d4b8aecafb2adc9bea954f4fd7f1900ae2ac4b5abef882b6bfe2a22ce53b6250910094dbebe1f32830edd9985dad4fa8a14e6d685335ef13c3578aa46f64f8c202a58a990b134d755af6587a7269e24d4ffc2ecc8599cc022e99b25f0ffeff5f668d57e98d8a4e24a7fdf34889c2234d5e1befa4e857a497b82b8a59f27c10cc3d4075698d5e9f3c9a5609d55a04528eb1da69f3c4b2412606e092b5dc962e0f172e144f5458943829e9ec46d0fc625a53bf6dd2dfe6a1cc7b09c486c3074407a9fbcbdcede424f28b42489253a3149f6887f9f74a83aac9c465bc5a3ecd4298ff76c68233fe789efe7c1e1f58a3c982d622131547652f37d6f9b8a3bb2f6ac59ecab44554c25218da9c44e45d36a04fb722ff92c314ed193d51e9640f2c53ddeb959242c9b3688bd72fd7f183adfdb273befd360a5c2a29630fbde4c07bd38c98d2aef250bd0f3daa7b8e06a07b4cc0543e86987313f88846e6980b9e4830d9e8294ea4c1bb79c617ea4a00445c5e2519ee3148134834568bb960fe7578a52b99293d5df362633f58d85f679128040908e88ba0ea0fe3db7a7d4865d39c9f9c11bc73d9e965d7fc8f2b436c20ea4834657d0c3e565754d0e4ed9e0d11482167ee02a864dcb939efc0ebcd97fc898983956e43ff94cf55a8bfb43fc2dfbed4ac40657467a7ae18769c5fc1e20cec5aea27d090845beb8ab958c2a281ae8566ba91991cea941fa198a18f4ce6665140990f3200a9cc4b6fcb3d5095678958fabc515bae4925ea8965260a807a503db54b358d035fd9665e359837f793a45f19d4f3850c03b16cb16e8e7ebfa4d944e33896b248201d6a9bbada0a8dc62f2d2961135ed712e1e568eb8bc64686f08c5c28243e85da9ed3e214f8767f03e67f78120f0b445f4f7ba1a591fdee96084632b5209468e905c1a5e82dbabb05c5fb41978653603549701fc8380d7dd01c2677fc23e657626d449f8fdf4f13f5edf1a67e3a6ce5cb1f97e64d9504b36b1093f72f6b61c0d64b2fe6de83f3329018b27c59a8ef943e5a8a0a13f12d976e2eff6ac8a31f5d30beae8b5867f0923cc2afbb49364042b063e09d4c0f49706a95fa47d65f9d3f227c0e6c4d76e9489d89ea8d2b9ff821d265dd2dceeaeca61442fd154a37455a8c3d282252b166c29881088dae196f02f887012c97917129ef743e35cf30ac940c53a27cdc022c7fb72321264394aac6bff6e946688070cccc89e5af09d1b5c8e02695da478727d39775e07ef788713cbe159d10eb17c33134b09013ceed7148caa9c22f62897b0d9930c4b688130adbba9bc61c029cb704f914a0912ba67bc022943e1c85542fe17ab9c2ac27a87eb0713ad12ede807d2307b6f844c4a84cda32ff771b99923785f6c0e9671f0681ef4d033e2d3737e33102e0314a5f46baa25f0bf2fe7866b8bb8f2198bafba32257a0c5b98575abc00fcda8333c5e44e0a7ee4951fb9f311b03151d39b4d7d9fc9bed19232f9e411e9ac4c0e1666e289ac238586e17941608d3380804aed0857e8795b74322ae8837a7323a226fe3a6b89d8051f6505d7164ada8b2237cee2fa31cc793c8066a68c93d93769d33eec61b338c5665030e2108161284eefedcbedf37cf5c1fdfe27379118607b73a4f74792749cffbdab193440e6422a05066c6e6de7ca40582e435bf127cc854b6ca1b9e38ad767fa74e42280d40f3839151235ecbf7f5e8362471aff29387e261602e2adc4fe9f8819fed131946ecf00985b96ea085fc9849475da2138143f641ff933b3ddbbff55077868a67d7d629b5471571531e689b0e3a78512c1f9e51392c9c54cfde3dd5192f64d5e650d6a5cce2c0df5e424e6c705b449d0af990c7635cd717a42d5469415ce975017eb442783f72bd3b43f6e1e1a32a60b2d3fda63b3cfa9ed5742d6e837b7f17fec9a5c33c1ca658aaa83a9ad2c1220f8092123ce901f786ccd0b68694453ff874560b66b058943170510b9d8e853e7ec1f59bd3cd2075d27b8776adeaa1e9c77670ad4c7ae102399be539535423a1d14e18fd4dad2b342c38baa7b4c0fbe1784a6bcde42caf0f543589c01db1dc92c21b21b8b532a60620bf518120aa1f78df6fd72f5285994dd4299b239c46e526dc6a9dcb9f2ff097fda7417405b55f6729f94f4b8f5a2a545cb84f68960c5fb1c7f3982d21f06b24231adc159dec2c46c7be885215c8cf92121f75af891c36526120413c23aa5d8cfb4089f64825917ef5ceffcfbbad1693bf975ac5324a7b22dda0b6190b465fbe78fc090b3e54d0d87f3321efa232d7a922f8a7cff87bea0ee921070328d94af75e90cb54725d151045f1e6d0d0d12d2c015e65f9c61d5df582d6f3c41e9982216776af5795b95f64e0f4d17fb2e1173db577f0eb5bda43650e40b252b87f6d4a61ab8d65a6d04ca456ebc62fa00386e6e0a48550e0eabccf266c386fccddefb79d9bb942c76a9a5672e80586e46ed914b33c98d06acfd1e5df00e147e5730cbd5271b0a7fbe393281b11a1a35d2c814e2cca45e4f0415103e2f9299a9eaba1d288d497bff024b482913c284ba62e6a076d59757f8f34ed03363554c4aa4e48486cebf36da2e6456854255ded2354083fef049879bf8810f81e4f8c37fac166d60e7f86ef55883cab0c7ba161f08ce0e256625d15f7c39642290587a1c67327e755696807ba996ee83b1368d2ad06534e102ee45fa8485dec44130cf2411caa3d55a96b4cb71580976f9ecbef9ea9af545c63c6066ad9fc815e658f3e6bc9926acc27808ba3098f7c65540cb36fbda3dfebab51233a9bf8ecfd8721753f993f0c1a7f52d83490e276c678d6d439fa1f3c514c9fdd4f42efbb2cc01de25e9f1e06ee5535c95fd9898aca993d9d8fc5252ba72ff84c2c2721037a2f7b47607c27783d97a8b8923f0ffdac136a6e6ad462fe29a845770b2133fc0cfc2b9d7d6c5625510189ee6213f6153db80cdfafef7f31937bf05a93de78616cc148224fc5fddcb413f00b0b66e93c44711e1eb9acc8fc28d418dbc9c9bd0d051149c5709207b4972fac854e43adf3bec5ccced6eb3f71340f966adb6fedb7b1e1ab6afb1b766f2df4bb94a68dd3e6118950776564c7440b772b9d3a872980e648cddc4bbd54cf6830ce0558f347622b2e45354751e64779ec7dfae7a8891c7ff065857b6c08046e31b6ce00526356f06bf1c5c604435019ae7a8ae09e556d2b0e0767295efd8ba97f44caf8b8af0a95a53d4609f724aedca69a286073e8d8bef166e4779d193e60c6f378e2c879a6d674ce9a86a303e72642e43fda9303a2a2d10a97f4fc32011cf27b2b22ccda27be70d657260b3bbd665788f5fe68c9e2ecfdd3455cc5057154c331be8cf2eeb6d5e61387642f65909b8d877e27db901c5b1c0b33ed344e6a9e96bfa5c8fb2f85747d195690f2ea6cfb85ab1469dd2926bc69fcd6d4d277293fd07fdf64228deee6776c6ce07ffe2777ee655a8bf456eb74a22c65b260ca8b5c65934ae43418c8c87d8ed51a27c8ccfa5e8abf66c39a3f3ab25dfb5134b4ad9d3f8ac520a07a65ce08778979fe86de34ce4201048ba212ffeab59385af33c2fca7931b8ea854410bfd43a581e816b7bace1c03370dbbcd2b657427b076ef5594c813524f03a1fa326b21db353aa499518606629e176ce30f71d5122a9b5a29ce2f3a0ade5f93cdd00c295d78812942604a69ecd9f1f4cceca8ebdb99fadaed3b1a5b577d379f1d18b8b052a5a0b107569b59f981d6a17da1219083fba03100a9af180999687836cc183d90abd428ad9bbed5c085cec4f23e03ce0176a73c0a302aa02788499092c971c6a950905ce737208d3df6044a8a10deae157b0564d7eed12e280c4a4e14ff7bc851c6ef112bdf6b1974b65c5a721e2d83e3af5fe3af88cacf29d8cdb10d37354fd675e216918588384843617253ebec663415da7de89b1675f893aa604b7ab8d29452d9c6ac808610b662c8bad6ae457674b569449c0c87dc393dd91dbdee90be9267b8a73df684d9c061ab8f815bb2e75daf3b0ffab59bee24d54ce0c1b3f96e6b26e01c151cd2204a3c3a7b3096db68e7a67f34a4d91043055e806119270b7010c6f8e82fd71bbf2c611de44401ca909a18a35b18513a26a340ec9983bcca81795ef19a35947a85eefdeabeb0248ea7411d74082d8970dbaeb741574ffb301c18e7c37365f8fa17ba28cfb0ef07d744909a68ee75586cf17ebc35b3ebbd94da343704ec8a96e2e3eec780c49d4342239872abd6703ec36efd11cca36eabc65e4ef7c917d1a5c9eabe0be58274123a7f04df80ffe5cbff83991750bf12e39062c47e66a8308420811cfdd9fc058ff9a1a9843d3aa13da42d930303af4224541f87d9e7987d579de2a3c714af74c9bd9bdd6d99ad9109bf39d509bf8e1a6358047213a68dd8df29fe84a9afe84558abf4c2e0f2758f73201c2514e29665452627d06af6fd82109f73d54201482dc54bd9e8f766c5cd592d368c3612d7c04e247b75360bc3a3debf44102e80d091dc9a8533db999c2867f12c22907cade0ff52bc6eb0c810533c62da52df648e6dcb268342f55897fad3e3335f5e3b0962bffa614b3458902e1c66420fcba10f3d29ed1c7d72431d032e4163c483a5e4a90194474837b00e6ac56a2535c31be909121d41180e17dcf729a26e83c704feb11eadd9cff4bb5830b9c0c8e93b3b83c556e61eed1c12747020c58516376ea637aab8c869e94c9666e8b78ea77af9780b796b3f5e4995a8565d9628187bee588088438f9fbec12f00872c5a86a99631208baa55b671ebce4071af0055a172652309930f1fcfb3289bb2f7535f0d3ca6fb75052d4b6dbce1dc2d4c246e9e8b1ccc32942dcda860ddaa2b671c65bcbca6f149a97954799c85dd3d9046aa7e1d40c9ed9f9058f49831958d249766ffb29ac20c1a20ada6022ef4d9ef066859dee094c5a5b21abd4069125be3a8f3eb0e538ded1d22d5ba8e235d9c463800580309186cd50eb311cab991b1cf4884a3e94b1bac424dea9456b6b7cf567c249a5733a9897c573395ac56d478304c1e5c886e01ece95fb378345aaa28bc6844cba4f217b730e2e9b2037c758e66c95137e5c0af971ca5eb636b641d4ebc3ec065d6f20e9945507e5647ae59d224fbfde42231e90961732571d5c7160c2c43da613a7e3ddf9d0084681d443210b344373a5a5ba0c02c3b07db4e34d8a9110c101469716041d1fe0951d757b59ea93a4a3414d184332d1cb58e72ae40b7a8e3e58e8afec66228d88113df8df272771dffdfe58a334fdd217282ae4878831a434eb32619c230f66074fb4205bb7332647ebc18059b64b9610e3cafd176dedf9da054f5232ff44e2453884535ecf8610501eb7ea23326a0a6c19eb1ec9a9e714711ca1769824ac2e9d770ea8a7d49a42916165be41b4c545852fb95365833ce5e6b775728d347995f73d50b123fe180c8d7399c7f0f20b820a9690edfc27406227098cc2c302a886a21ed3e97f707f4afd473db4ff65e1b94eacce92b3c788c9407fbac0b3e51a1e38581e092321c9ec835c1f865894b2f2011b3fb14f0308b0da36f9819ae25d87b12dc9d06a56bed6f3d7584ad6204b3e86ca7e7c2cfecbc947bcb56d804141f848beb86dfa046e87d07202d337ff63ac080c8b4ea60b1e1193341a48f230be62d694e0a0728f8ea9f26d62614c53b3a033d61da35538d6637f5f4e8c8ef3fbb72260b36859131b78e3333c762034fbb7b02c1f56d135abdfddce33baad8a81e71f557c8ec78a26af03e74a588109bbd6b7216c2edfa57224c4ade9a3dbcbfbe4e54b054123d444132f0395e52491aae9eb8cca271d9fda32645fb12e304e52f91fe5495404a07bfc064cb677c61aa6bce3c56777867304f2cabb77b3b8e5ff7fc9b6bebc3d82c03852515ad8ed2f5aa5a7c1f818dde0cb3527bfd90de6a8d691309215f8fb731620c1ec39da2b5383af07eef6324cf5131209b49dab1284944c5031668afd46639fabab123c71729752e100aefec66650042edeebd9b17742c03e55aa80afd5414b2dad4b830e890232ad92981f860dc0a50959f696ea7bf47c3ba751b5e952b5c615b49340cd4ee8a0713586407ff0e72b102ace53d4f48f3d9afde9fb7a0c455be61c657c62a9a941fba5043132328cd433d4757f201c4243e7670f5cb5ea52167dbf587e53789b3012c1e7c94e20a916ac7c9cd4d79449c8219d858cbcddab7c719326b9555aaaa6abee74394b5e7aaed8bb7c6d721f6ec5066cca66dfd0ae994379231ee5515c58b9237d53f30b80e06b47b1daaa5da787a7e062d259bf49ff880cb5a22e71a88ca8969b5eedca5858bb368f8d7c646b1176a75c0745897db8d9eb38b7a5ff85b5d086d33d063c26716c092daf4e8b83319600cf379c7619138b99b6d6b62d2d8cf3975bf8d1ae46724b5a6bca587b8222a8cb0ed9037cb0629059f60b3f9db2df09deaa31a432b05a0e20aec6d061f52dba48ba567c06da301e0e5ec523076dc13962caaa9bafa99f45fa493990c1de452cf33e77f6e58a6c4d27e9ef17e69b0bfc86a2b5652f7eef0972c5d1a706e8b10fc9e4ffbfd985fd75103a56fa353d5cd65538dadf12c1a6a1308b729478ecc47d5b7f50dedf437d4fe77393dd92a9528553038c0faadf09ff9009fb245c687288f2666bac45cde62d8eddca925fb31ca8d4f08137517b684a5f871e1810c7a18d0256a488419ba6fc43cb2536e0517331b040277cfa10b8faad55f2059b5fe02d09f2da112d1aec5ea7e438cb5920e1e282fab98cb95e12ef8c73123b23d41b2a3e0eba84f65e741674a9ca7f72e7cf1a8f20fa8a75edb0e1d99d8ae1880018b0ae224fb84f41fe299afcf87f693b3b653c63b64534ed5d00b4b1dae38976c080489faf23a0de7da7a40885f80632767fa5e4cc836ab5657e4cafb5b9c6e0a43401b3e718a6de7e7dab763450bc8b9e641272aa078e94ec938f8a564a6c089dea55ecc0ed3ba018c8c4f551803a209e19f2f2e85f8663b92d92ee0b098dd5c095cf652f2a4f60dd45eb6eeea5a40b37384b6388bedd06de358cac6c29aff4c8c9d9aa3bf2ffc375381d7ce069e45dacff85fe61ed23751f7618b6cf9b9be977f0f1360868981fe1693622acc7162d26cdee7caef675d6f1f7cdb6dc2f4f522441bc2d93691c9adf149036c442f6a0e488918d0f9c290faaac76974fe661d8e6c8a6d92dfc90a565b10679f0b62e162747371ad987265d4c248a1b5eaaf03f83ecd1049fff217dbc42d47bf8a284876269c9b0e5cb34ad53cc9a88d70d73ffe5d242692356a0e0d787b3907c10d343ce0d2f934b18714341310d9909feb2f51762208c2190d8d0ab79a90f808e8af190656c0a8dee7fad4a9f86836a2f1dc47faa9ed0855a2946fb1343afdd42c50ec0123d34ef2f8a9e708577667b44afec651f5cb021dffc2ce01e6b54f9d813e1131f595dfe86ac8ab4b8a98926e1c56619452910d43d757f8a56267d5f759a3592413c36d8823d9fc4e1875ad9dae12ee71dfe58938d18b43ece078527b923d6755523d6eecbc354336e6ca2a4cddce82e9155235c4ae72632c1282044949b5bb7070b6c8d6fb11460ae13d11f42d0a264c3c83e8360184182597267f6bd8554dbb04ae383cdf9f3eb1dc4e657e29878ae6e470db80f56156694b2745bdd7e5b0f2f83a57b8cede297b80703617d36696c4df27dad2212024ee0c11833b2006e605f95a1b5d645683d693bf25719ece2f06b9d80dcf611c2d4d4e883118e82d8a4685956efb8525e5a182b48217b2f27cb591247d995d134239d8b3850dcb5ca5c070a12759d3f1b5425bfd352f156278b546c9e755751d678e2ad8b5721644d908a9b9c341c08d5fdacadff2781ed17f7c932301c2db3bc3d1cc122e7a9814f3220c6a55060a55e3a0d161217e93eb617481b39c4808eb164ffd8a9ab6983b962cfab708858f99ef69ad565b11e3636e1781abaabfd401eb961368ec2683b05b5536ed66f4d9592fbaf64083e9fb2461d86919a7314865ceba66d87dd697a6ee312cfec9a6a34708880967bd4bb3b7718d2060ac553b20f53ab0dc137e44b6e355a71a4f3118c83a84d96e670f2bedc57c98f16d1a0a50c4e3e678b35ce1aa5557745742c30f0e2980f2cde2631f3e0be69669442bb5c03d7777e4403c8405822b08ae9ab3ce452903ddcae16f5c9853b11de18a350181bfd8b5da61e2592c0c04d5e72399a6e841075f5d52e8bfa158fe0aaaee6edae4e18196c1b1ece22347ab863560ffb303f90af427e989ba5987d60e829f2079c5673f653f19a70ef4a233583265ad9e59eee05667f385cefc8e91f10774490fce10cc4e51be50f18e4b2fdafab647ac1b69af36ac0b3834efd0d4c33ae895b2d12b928d4312f4e3463de0966ca4cea07c145023c5c7598dcc588455ecfabb19bbfbfd404602d152318b228e94205e892bb76bcf47b1cd293478abe6cf4551b7ab975ec21e6095563060579cb872a929eda01eb44b351977723ed046361ecd4bf09e98437bc8546df5a87684f92a7bed1235204a8b91cf6085b6e8d80fbfa9065e275a1927a8d78c275f73a9e4c83869e0c96d49eb70d671cbebcc13dd5713384caf61d25b829bd21349ec076e5e8e803a404ad8a2a4f40f4f5ead6d21499f619e4960f55bed6d4f1c2bfcc9f35200fd1871b928cea3794c57f245208b948533d8a4924129d9ee093f86a3b98a40a7f9ebd1289f39724923c4ede2566180ae9419ab06fe0c8c15d5e831bcad4a5c68ff455e8244b6e25f86745eaa86c8c16dd7d48bce0d80fe08b607d744c10b51c413c64a5e5f6d91954a7b8fdd61cd58d89d6785223f0c99ce35071b5826e7e47c233b2a4da4330dc55bd02d1f37abe378f272d847f8340db514cb3c40e348aa85576167d29c97fa2c30da626885a1aa5b0f1784107ad2e690f3dcb35a036e2c46400a3766e7465b97eb3a0ece8b80a1b08fdbfe28cbd497d6f3d8f2b158250899bc0dfdb315a74ff550c40f2975630d4f0f59ab97651369a34e8bd5565e8761c75a8cf20d6a4015884deadc6918a00981d530863e30e42355a1242a39bc18af9d96f1fad86a01d1f7057bf7f8c99a874901875785df86ed3254400e03834da2ecac3eac769b51fd6740675898c1a350a681c75d1355bbce1884896c56761ca16306498cb1f50945abfca3691965e6231af4e5a8e92bbbd0e79f9d69b60cf17e8dca3fad86735887fb614a730a9dc2a4151b20ddc3cfc1e7e10ad41f4aa4a28e28b6de17084811ac5ebba2bc22e9a6e76a753bd427c21d21c9101b3556e8944b728830d1a5437e054740ea9168a16f472d56b0de48e0dac35a766697d7a65d1609483bdf3ab8178cb95863b1535e1fa1ff654de2a047bfe236ac8b09950fe33d326a86c45dbcf83c61fb819a2ac012f38675436a3397ed4342eff1861f550f987a4bf05cf17f3117fca56577ba5f5d79cd404350f84c9ebb3654451dcb2cee2d31d25d9fbc8e0b9d2665bcb3be57eec2b5be4f7606687623d9db16ba3bdeb441d2e443047616017c4bbc49bffc5cf07e611893e9b8c4e0e132a4826533c9b61015ef59937549b6622218810549f7fd014df2e19175f63fee8217695b654d7f9e82f63e06f8d142c1cbcfe0adedd541ffc4684d02ec9471e5d81030aecf3de1b9950b87d57506206b0a0246692fc69e9e3d9099148976635998a176893e7692bd17183393e7c68bf7f9053e98daaa02c5fa0410eee74782f029ab3c1435075c238ccf1774a087064413f43407d19538082b163b7fe9983a4be59e27c11ff6b8b3880e949eff2ed4aa7db7601ed16a7c7770552eb938fe35f9388c187069cf021ad9cbd779a59da0fa8a1f5e6f5164808682b74c7fb8ccc0d0a54b4e546e7f57ee77f7452138cddf7d5f461e644022923e186dbb5da1442348fabf858c7fee68d3c674011476195aedf91d5526f3a85306714278eeafa2c24d823ac8c942c6d69dc0f360199ab820cb85c4a3d70935f31580b210494dec30e97590bf0b34df069b9cdf63367bdd49a8195f8684c06cc480ea134c146c5bca38e8c4696a66cf692270d8d401586057dff160371913e33d94435b84e07f7e171ef001820299c0a73d4b8dd1c984966713e4511c66f49be66347e5af49c8a7821988266bff0a3f996130eb042049a3a94bbbe2da4a42eac24ac9a4a40e2999adf37b094d9d36b2d4afe85f9de5990caa9a269f2e42a109ca69ef7d67f876ea2f2359d68f30d6007a4fc2fd7b144a64257589d18ba6ff431d9eba54605e2c2f2229131aaa44a6c6e0518fc09875e79fffe7b2497b6bbb5ad1c34b2df8bcafb18b5851c1b4760a0270b40996697ca88b579e4589f724165a5d6e2e6678cea2f9532b6156977d2a65bf00ff63fd042ceee5701e7e955025b10faff32aca38ccbcf334689de079d4f8287f5025df748e6645d04034ac26002be6296f130219a3a6439169696a805afc9ddec3ed50a714baa45b346fb1797659abfc99bf2607f65f20094b37312f93f7fa768dd6e0a09d1db58aa712f27054fb55ad51d67e4dff466aeaff9f109fc4bd656fb974916d2a99ec5c35875ce3223e1aee6e5bcc1ddfb3f7a169e4fbf4cd4126a39811c206168e6f2b0f7bf135f2fe34d65090729541cef819c7f61d0a5da2acf263a6135d3412d51248ea9c0fc140c30d8858fb39dac6582011a143f5262ecbdaaee2e383ba668dd2201960ff55d477357dc26d3cfcb44249b96fd72ccf4877d6260325a85d9027ff89020efb978968a9c4a240d2ddae4004b76d2917eed1b19f9f87cad6c26cf81fbd1c9b828d945e62f6408ef2a2ac609e79cb88344e5911023e49714e9ef93b6ca9a157c02034ecf752865ada1fe24723af5bd38c7a8c81f24ad598305fc82ebdcbe31fe4fdc4ea67acb1a206f18a9933e3574dcc499e9ff03c4ad663ebf11e6da1fe2346d46cd637a44a934e2c3109900eacfc4a7f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
