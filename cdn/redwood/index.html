<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca56fae323a130026866e0490c37952e6a7e3f284bd33b501dccac8ab2d555559717b7b7bd370984d8285822a96726a8c79c7d63dc4cbb0a4db0990a86c71fdaf422ca81d8adc99c51cacecb5039c776164b603c1a6c91bb967a2453c88556e4fce2bf7974e36006456c7714882a76ef95291f8c4b218809336978782ec332b7e5258a20c972a21d89e5f52295ef92b20e36a58f14735a6fca99b6a4b95362a3ec9f8f4191add36a09428314a5127e0d89a82e95196a456fa1f4b492cc3ca0890837f5156f3a09acf6d5cdad772ea19520ce0c0cc591c0267e1c800faa54b3fc3014d12dee55caff506f81b79583bc4d362b731595152a42c3e98eb0942e89af99768c836a77e8583a907332b00d0a8c6b91a1fc14eb18b9db8c9edc640ff8a71ec74a82aae38db9222c71b6dda25f1990f3b7cc29196c9de7b417bc5cb2bdccdb420952de9460ab25c7ad1e9753b8822424cd12a90892e3619c1429e61a238950011eed12f7ea54a07813f003661f855be8ef26fbc90e14e9b910edafb5a7156f3d8d135146871d2ded0d8bc7e22d8bd3d483b61bee47b5ac9a2679aec917bb7c0b85590e8ef05a5b1aca33e8cf3f8f76f49821c5550663010846961c8d43a31f4b0fd371c84cc7d4a6b8661e3bdddddc6228e8c7ae8a81d8a915347dfe81457466203ba000758dfee3ae9980433af660dca34ff870b8e921ec42a9a781c10234a8952bc2d39bf0e9ae1201d80a190329a52499d55ba1860ef97638c0b72ca064a6f7dc3cf54d51b7a85cb86949eff7b664f694979d12764b4e1a5462563e085eb365a3588d36c3c02a47fa0c9e2e1ed4d61e3f8f8c539d8d1143fd803e5ff379dc8ed7333103a5faaa47416a2749c6cc967713f49904607c4cfb1be5355350e18a74e956ae1046d9f447b1152050930d26f55234503287795a9dbf5fe288c281c2fbc0a88f74a3f7f1127dd936da4e32a6db184b55c1f6d3925c8e3aca8c07edc5a6aa7332850cfcba04f0b2e99f7950521b859f610f04fa134ef1065a82a0b24c36abadb291d3ec7bc7234d8e756b35d7fff9e57775f28a5d9d8b159dac39156732cdc2011f6162a4a116648dcc2be22684c5c81b61399f8b6e67892b5b6ff491946bc1771a940cf54d9e3a4af924b8f246dc9dedcafe5524ed15809a97a588a933184547a8e66216b0f77116d2075c0287e379581bdf432f8032303b3cf03a47f40565c52e7a25212e556ca941c7c6da8dd6ffb626e246105700b72b6569c9ef5dc320b504db8e4134b3b85e4ebca02e4e6efda45357b759446c2e64090dca246f43f7ccdb2133f3e380a7b8b3b50156e0bb88f675e181e146b67ce91172166af36ce6a066dc0da0082050ed1359fb3ff6dd1ee7eba1c4f3cfd19fe427bb780971f271ffaa6a14c3f4f2cdb75e6a09ff21ffee4a87a45b15311299c22aaead38bae9daff4ba1f23cd7c67df5abeed2082cd8031754e30dc72ed1299ac4dfb469dcc9dc8133b606c2f7ecc620a7120a0167c213b96c4affc4e7472dfe7677cc0c655d93211d40644643d47231f7485ab63959078aaba5699967ceee554175e818e05bed506cf2b99c1fd19eb4541a9863020830170ee5775f80c87a6ed720a5856f74dcc2e02d584b59015103cf5e2b5964cb916c0c6f37715c512d073308dfa34c5ef8ee2b16d1518d2de93b857945e58c7e924523a92b906611872eaed4040c30ba31d160e33ebad49684e36fb39ccfe6a583b3b21cd9b003861ef97d1d792152fc6f134be3a7d43ffa5e74efabdb0f7387332ae4b1b5eb5b0b841a1b7e423aa7017040944083ccbc874aae35e7ab403c4d38cef255e713d1405f98be224acadf0820fdb7b52ef537924cfb509fd8b47d2a4ed6a359e99e6b49c3a8a4275a34e3afa21c84732ba2017dde9f04dd4305a7e98f0b574e4ccaf5d8a4c2872719c713c08e6d3012bea6b92471f41b6cde5793f23607f4b25e60a76b17385b3d21c375c2824e9630994e613b6c415cfeae3fe39ccb459213ee9a33d24d93d7070eb364312bbf4ee78e3d3e06abbca6d1f64df538a0d8426a77ff8de1ce55876cc09d0199ec1781dbb8316a11f06eab1b454949ac6e80eab831375999cecb798cbc05a713660efbedcf9f4215278e42e1f00d8be7b36b5c7cfdfbb851053cc79b060534ce39ba846776c1b5164abedd864387d84565319f1134d9f18f00fb689eb34eb4c27a9f097f3ef6db1427886010ee84ed375184088dd36fdf388c0b8851a60d7e057a8a32ebebd9e91ae8f2f68bad38c137b4eea7b60c5e51f35313aa2d065029ec775df21189e4045a0a5c9c0fc02debdfe7bc342f8969fb345b50dffa84ad436e18311fe261484517456dc28e1a4f7425392df148fd96a8d3e9dd2f44b7a218803bded949f78abc863976a2378de42c16daeb9fe58ec157dbe2afcbee98b8bed4b7595c5088d5b87604be475eed68597d046c74e9007f7e133e0bbb8c0eb68f697c0b4e3bfabd736b4d971e40e1edb5aa041d9b58e9a72860f6bfcf4a776d0d781d232767bfe102f7c8f735cb2946a64f0e42bc8b862265b306247ac26e21eb056fc25bdf1eb102cc375161aed18cf89b3c01269182d2731afa16d8cfed9a2909af43f622a5e048b427ac27ee18ca1f31c43656b873243dbd78a0b0231d01a44d54b10bc49a6ca9c23562b39aca43d35faa4f66b8073e762be810179c0357e7a7dbdd908ab2785b340a6c328b516854aeed223fb75024a704c0979514ff3ca3e5f1ad0f2f46f3820f39db337e373aaebb4f3ad45d26dd82f26a29f2d46b0e1379a3353bc7351dc1dd2aa842f2f8a682007bf5b00a021b95a0213d58b432e61728e3ade44b0560234ab9330b470ca400143fa4be9550e322b587b3740f13ca175f1b2e4bb142860a6b5e1ff4e232f83ef6a3d5443337aefa786a6591a2f541f0f155c12a4fe12f99c2c3f49bc57c1754f86737c7e77dfdc1145e8748595b0f113f4400f0ca3d2c311f69e89e4f6159ee57ad40f02ff60be2fd0a4d38d7eb6f564c8c37af203f67bf50cd44a1e0b7e35aeef8fe12caa33ae324668a5b10ea33b12e8baa0aa4d6998575758f3028aad0de0ed7b5e50d40037d64801b9a09fe19846e018efb26ecd5badb8be00e6911a3ee6934d27012510a0b5557647cb9bbdf48687ddb09407a6718ac7a9583cc42e0738b6f0dc1bb594996ba9779c82963be0e4f59152ff14e69cf1bf249aadb43d7e98d97380644f280411c806d21ff12cd2b4fcd7ebaa413433d9bac6fb96e6255bde59c30f98534fca8a9a6d95c06ccef6ca54446d47e98cf3c50bb6e54c264ff23b3a46d18e891099eec9408ba6dad2a1fd8b52b95f8e265ddfa66d5039b14aecc61cf2defe490dd290930aa1b447348ae8c27df14ce6f0d3bc12e6ad7438c50ed5c6ecc6526b4f7545281cdeb240fad041f4974541f58fcffeffa5c94dce11427a3a6fdad40435eb41fa116c2f1be11a2b4ba74958d3281aedbafb143f3c27676c11cfcedd1af8c06145edb91f9b364efb05a96b0debb13d6cd469ed49f33f2b076a733e776c84473f7242dbbdeb5fd1810f9078490010c16cbc04edbf5a7eae1be13b1d1147ab8fc451bbac422a435312f5232a7524ae51980c8666281eb30e95605f90175012e7dfbfcaf4f688cd24275398f1bf025d8ae1dfd6c8f81f7990b04241f111e04723240ac1309dd0f38806b6dcfffeac235f630b9c80a6985188bd665ddc9bfda3c84e07075b5a961bb7bfc08421adbfe3757a09f2ad6f4167bf9dbd65f43097a55069bd6e95e55b9acbe6ecaa8932ef34df8c8d6d33d6e912b331e66049c43eaf15ba7013e8dc90d06785465518d95b043d401edd0e171ff8967c9cdf11f260aff0237a80b0a72bd37b595eba9f4274e67d36fcb0cda4d59999fc95f7b7e15aa8e79858a215b752aa2aa62fc4b3de7066ecc5ad733cda42472ddc39c3d1f1237a25569a9959d015b8c079748fc2a645544968ab059e0c70781a896207a7d549abc9eac245a335a9fdff25a2b6303cfdf2f27526c2db860886156ffdd52bd98327b882822708300db6ca16adaee2689378b7a55dfaf4c3d78f35f3927edcc783385ad2c0b8062d76bed947cb69a37c6dc9b11cd099fe75d8e83d34da063725d59cba96225c75f38d892e5a8eaabb8d61d5417665060dc7894dc68744e889cb03dee343a8250766076786ac78e7d52fcea9102b8ca4cc8599a9b95eea746948dae4fcc0ba8dfa9c099597d4e20e3ffeba95ea49ffcd4aae7870eebff59ab352bc49d7ad9ba8d211a59666e0486c0bd1a80837965934f3dbc1fee5269188104d5e893cae53f01b2bf0c967936cbae90230b814d1dff234519acf34493ed361a56a60b601f1e5f8470a11cbd37ff692fbdaf7e4f08bb8b7e75ca7e3ff98aa45ac697dc7c0ea89d63ced10fbf02d1f887ac0d31394840833f1dc03f42a4917dcd43541553ffaa03eda2900b72d59c0831f21d630b4bfdce37488d133d3daacb8dc9083186dbf355eee2c9db4d9d615ea7bc19de4490ec123d569f94bf4305b6887da8dd8fd38b7b3aca59c466ea3a3cc082cb1aa7fa6b552cefce63bf4140524390a7696a6782de70d40dd062deadb438351ce8742a43a97d39ce78f516a21ae315c550923accd800a9e85b02643395c834f842ab31da83d687c2f3eb865b919348892b8db176a7e7237657597b39c90a56618bf21bd1e007c4b5d40ab187642ef7189bb72961efdcc396e4506027da92e87f0263211b9d61ace0266af589b51c6fc49862882ff074befca9fb6558c6de45441d5bf1064130e3155b0681c904885951cd7b893d20a58276d84aa91f1145ebc02b1f1e2a632924bdacd88a4d609faf3bd822dbc1280ddc3bbdfcfd3b4b510bebeb2b7deaf9addff30f9004fa9d0ccd707d7c4459ac4b7edd018e41fb84b806891bde2dc847254d09c7a98ecc097470010d66662f9e782ced40d748ae5b4bb009e45f3ce9d3a953afc6b2f3f4ea5fc714b541a69c3c5ff07cd90d8f3a86d73fe3ea0476125febd82adca3041e2f89889bf2347ac558691bc92a94cd662a6a61007df29ffe804bdf7becb647cf58cfadfdab9e35501846fd683ebe08c32d8dfcd374814ef58daf08c9e1bdf8a2f8c6681ab1322ca8e560568f038465a009215ba9dc2392d34a98350396b1fcb34084981c9e70ee6f7a08181285ef98a189111decf39e4d1801f61e6549a9b09d90743521dbc3793c0c52ebc1fae1b5f2afbb94396fc0af0fa278a22bb9235e28deaa9cf5e1aa4e6a6c7e72cddfca0f2e9690b1d2127f0bdfe886349539003b5c528dc3138eab85a90da5acea35acd88c8773ad8cc54b506e63d2484648fee741a32f5209dd8541d6fecf18206acd14ecadfc2332b83cb615a0d56132c4ceba41a027e090c4b1928b33aaa880936937638141451a939c413a3b51f26e401a391458f65f980b291ae7c7b822bd8ed2aa4090bfcd8af252d66bfa2070d65ab8989a7bc49c9c855b9e26757e62de0f06eb0d394936c6634b1a5de49299a328f480a921efe3943620c437aed662f079576f098ec771b397991f632411d74779abe2c8e6cb09b0277668dfa01d05adbd3dff7e453624c31f3b491f5bfa83cf7c4c5a000124b3a3cd85bd20812247ad03533122238c69765de60482eaa2efdfeeb25ee5ae8bb9ee073ab317377855776c89e9d8b22f8cbef7aa746363e2db09f84651f09f4b70e2842d621f69336531d43a852258c4f0f7e42775e181987c83f94cd874729c3a7a92f74621bac815eeafdc94ea95fecb02c835c5735764c5438348a88ddbe4d33743c601180c67c576ea59946bf5e76cba950f69249834eeda23f01019d6c2a968308487f2a17d4918d99d41cd8741ea4d16f6cef19b5f905e50a1b1db24369190dd5c6cece58260c97bb2a328582798cb9110f5c8f2a5a2ddb3a78ae5d6013a926872760be6b6774198aa3cb3e3dcca741ff741f0d0c948a14b990946e9b6317bf0afafea5e793178727f0467bd237ab555a614c3e0573bc8736aac0b4202ff23ffd71310e692495955f1c8f10f4effcbdc7e09d8af0493d657a910164333d61e24b9731fbcc9854682d208c4b660a0374e879575d7012cc0dd01ce0c056ede6814d3f35a36fb164a0af2c830341d3585b69f4fbd9a2d7ece86bcd39dd88ec2913bf7503bde03b35dcec31a0fe5262176929c6140f95378c9f9c0c1f57031d04d0d869c26ea044521737dc51f6dcd2795a35eea9065b6bedd6e2929f6059dbc2e6e6e36a72c6ca76b763fc75d1acaa5dc96384699b8a14934c0085ef906263659ba2e2291d0e345440efe66635122700160289e1834353a670d848755d418f047f987304500ed1f912f3cad315bacd5b6254d48a57b4ffae0cc3f2f9591f8f277660426779b8852633e06d6a2d67330eaff6bb5dde5bfb10e18411a3dceadee0a712db3a07a80d109a8c51150cdd379d3eeab56d9c17791a24906e2d13c11a71e042921fa91967230d584a714bbc845c2428c04502da42b57eb148da37ef061389555a5d7dccf9ea5c5bf74619b1c7b97d0d2b7e791fad81c4a09074e75812bd805086219285c858be928e2626b22070ce205184006314ee9ecce14028ce5fed959d4705c877767b10ce6f4bb53aee34509ea5afb5c9ccda7a880ded9ae538ed41207b98c25a87712d24e45eb067a9a8a819164fcdc599d6e12b1b00b953e2c7286b52793754d4e0dfe7adc5991ff516ee5290a53392e9e7baf1b83b501c2b29ff8c61cea589d4a9fd60aaffad89665582b8345238505c92050e51a0fb297be496add45fcf731910ab90996f9d153cd2d3659e6bbe9ad4fffa596d90ed528b977ac4de2b3486f4181ad366428e66e6e8acaaa51e458afda6f282a23ac5895b7c2598f7dea7c40743cbcb1a385f15384392e34353eae82ff2bb3581f0fa3253a8078f2e790dcac0b67b722c5dba87deb65c7809113ae6e185995cf80e6d3c51bb6a6aaa0486859490eaad5ffa15aa8c9aee2864dcbf8dc61d3791b137e54ecfae8654c3eada3e310330b7d340916fd54c6a3a6b5079e6b6d82d88e21ad85bcacb8d99c23ed5e78a54f9d73724a941db07ad52b639d1e84b52c1fd830da06e7df4729564726949ccd642178851b328c0f0899b9af9bf10b1d9627f3ae470886900508d6c7d272a21caeb277c9af3c97690b9510872e061e82f84081fb6355a8ea807617164c7ecf848d0f24cadcca74922b36885687608cc1c5482fccc8e2cb224de035d3614d4bd80ca9040f60c3a925da0f5cdf691d728c2766e787110e4ebe4701a9a51e8a64dfac847a6dec561a9e7dd2bbbdc5214152d43fc019a64dfb35e89eb52d8dbc1df813c8bff3056a35cea3f46c2a49a7e1ad1e966e48f06a2c0837f7b13943a40fea468ce599e24815d077d5ccc6c027baea8bd90c05c2ac084e2b27bf31eb4fe140fa7466704c3efe97d8d1ad6ca87b28ed34b49f8b42ac7dba4f47a0b3ef270fcbbe75bbf80279da8889cdd7794040dfeb666aaf40cb1330a87d0d1667a83ad60a439ea60760f92519b956454bdc7d7cab0b7ea53291886e11146c5cffcf00ad2bb7e449b6947a289609aae89d2a7a1d93bc2e03b0e59ad43a0505d4103747bb8eea7ae573a2addb286daccf1798352014cb0b285b9ae252606ec2db15e000ef0570f31bd92dea4dfdd67751143a7585e8f409b9e5cd96ebc51f881a61c88a462822ec2f75601bf16feee92488284bb59b4870f687d9a46ca0dd51b24d37a3997214b523b103e9793f803d5280711c4ce6dd76c200c48c3f709c91e4b9dfa6731b859596b954b1069a2a40c82d61933a7660c48ca99d1c1fd668c89ed9440fabf0aaa8acedfffc74084094067f5d9fc9c4cdec44f8e24ae261668ea8dbbddc95fb3d825e8d09447a944bcb6da4c6bcea933b248361f96e3d86ebcbbb46003dcc164c179f5fdfd9cb79b79c6cec33542033067043f2e967c64d0a94edbe16dc778e362bf22bd5db6c2985ab09484b0ac7b02ef8e4085ff8f071156949fc3421797cd43d7cf1082768b0df643cf08b1d5355f44772b5e1814ed6eef72a66ab11eaeda576d2684e5bb62d2146c47c63ba1447b9d6e8c2d306255728084947816265434985054a2e86011cc21aedea218478ee34125479d964a3ffa98c4cdb9f090ff41febd2e29af274cb911916917ed2733210ac55b4f53688f7779c78fbaf15f5670cac384219b63437560412969dfc30f8bf737f71156d73f00fe1a9e1beafa01be8a832b20fd9d24596e7c157ef6dc10b9db08cefb353f5e8121bf61d98f515f61369649764d4e89ece1c708484213355b612110c78e03032f92c47a911a751af188cc8a692c3246f5a61c3991cc8f845eaee94cfb078526a01b3209ed7b55f4aa19f605ad202f580b2d2d3f5f6e24f17e9655dd46ef0c849690dfe627d3ea55d95c4216b31d6fba1ffc1819d17da11701f9282d9ba0afa8b4c12b60581e0efc6ff66f5ffd689873e84bd7645808608c7a0896864110f5f967b683e052139e41471e1aaedf6242800f4e514d9e2db75b2670dc31bfa466896bbb4285fbb7cb31dba5d784afd1e77d5b8c6c0e0f1a41b1161bdd54c267c4699519d8d449975c8902d747c2d5693b331efca657d3b892dc651151d962f86719fe95da7a3755e58cd12706a9c9373d0477b71f964c3e519cd9aa6b043eee86563a1eb459483e6bc0594693234a2dbe2616fff6883f22ad23319d8ad824d14321ddac4245dae0f848ba34358715404f3731107d30139526bb41582250b7a408afe641a98767353f54a3b8b49e41b52edc97491c8784b1006dc7c0009a8bcbe8a4273d21ff4b56e699fbd96883e1d965bec86718fc7786193a00cd0f3f986dde4995f7927951536edeacd1b2236d8b0dfec092f31d5f995995537bdaf787875bc4a122b562dd42ba9327b24a6f38cac8d6e3e33485e78cf3f2a6fd47bb508fe99c289edc64eec26cad64970f1a969c72ad85f2196e507981430b7de6ee3726be85721edb2de678a88b7fc962075bb17895d840a174c277ce4f46090724180e1ef55e21d15d2645d7b92bbf2fc91bfc74bbee08c903e14eb074026f5c6dc746889990d0d32f949d59bfc11a0d5238b8e3d1a32eb756f9887d5fae033a5412819937442ead506ac2c7845b80450df4443a4c30ff48794f70f0ccfcdea81de0eddeab6e456c82bbed16c69402a861357a935fddbf1e54f777d58a09e52bce215e71bc506b0c90eaa495a5520636ddafd9c5614be14837743a91f2b4feb35e5dfff17820d268cdeb971cf7878a52a7eaa04beaa7ae79574a54eb5637ea3ecabfd51553507bbf9550f98b6dd5bd927d84a8508d19a2692c97bf4bbb5e90f9c3cdf8436d46dba55cffb8aee5de118c6ac1e25f504b01250d6be18752d28b13d50506807303016ecab197352871bad6c47775be07c43449290348cb39e93b1ab7d3eabb416db00cd499b8478bde63106ad83a13c5f68211942dd8fc07c8f913292efbefb373d9bdfb356f624bee19859c29f6d58e8a92dbb49c9cfbf87ee1d6098b484e5c4fd0ffeba6086a819b1ce1390996f8eab730455fe940e56710258bd268e59d0aef9dd8cbac6fc145a239cb61643d92990ae38317557c4bd652382cf66f5b5e6f4a0dbb24722a01facfef0448b31997f7ba68f2659ec19c858aa84b664008739632fc191298445a4c0731997bc457450bdf0522bfd257e9d1f31fc4ebb6b154857861aabf998ef8dbb57390714ef0840fe07907c7fdeff32e6c4b590f2f1cd4a52436cf8a105ce63eba79e2cf236b6dce69face87674ac3fe27a4a0a03eab0bc57759595b623d12fd9860b986e00b5a7ce5a32b085c37b5f36a20a6738c1a12235a66b74afa83a417dc6214081599bc5d524b26e5038009f63eb9ecb08d03a02ff4c47b421a4fb6943426aef5edaad53ea7e80b6b45d03a8b2968ec46191f41282c991da9b82cd25aa511003ba683370d404b359bc2c0df7f434f8846f08d8829d891c6fe7e506f4997d79c12ed3edcb0305544007c301a289ef0f7107fb74d92996ca6a23fe30c8a30d161a518c0e6d9a83f6becee6499cf86f9758a419c882d6f166efa284b5eeb1ea082c061f1f7d8d4331e90903aea534b34453648962291d6fb6ca729719ae721926834c9f5ae6f5dc06b11fbfcd5017058a6998b9b8d9141caa3ec3416e8e5a9a51450480e25664d302bd75d3b7ff22aa8d0325872e7584a2beb1958f15f397ee9e20dc2f6843add7a5eae07e468ac9a931023e77eafedb904c277fbdacee6f4f95fba7e2b50075c026b897b978993d5c298d339025522cbb302e98fdb9be0aad6cb9851c8e56e0f92854f9b51faa5efb52a4cb2476cf7d3ac3506bc8ea7f8688a5778c6628802716a726b40ede57da742bd8d6b69ce35e48edd3552da7ae0453ad2c350f04c7202c50f8c97ad960fe4b2f40ac971826cb37bfb9a7ac73a8836dbbfb827729c074cc80e6377ed93dcdb6fcb6310882245c562959675098251901b2648db53eeac28ac89a2221b2ee94a08df63059f9b76d87aca58f233dd2acbe9e7360cd929893a0dd8783a0e9e80ca84f7cf4802ade88fed60fd6722fe9c95a3bd47a58fd8f4a8128d6198826acdd5618fa367aef362a5e208e43bfcb30b59881e7bffda2c7c751721b797944d8876ead7a6924f1f17f9d44818cd1c50b6a4ab5ab3bfdd9422e56c0d046c51a862ddca0d1cc8a90959c752f1d12db87da3a08e928cc5abcde5a68bbdf982a02cf8b745a488ab8036559dd1e425cc982c2b3d82cb863f380aab0ff26f10e5014b0efa72481c968e126857b565fb7c1ff5d9470e0a47421854d7850871d2d486c02554b1300e0c3ff43b0e3407080f9778d667fc11e55731d48ae4fb465ed32b88753c047b6643088b1f32bdacc05b4860eceeebd786a3746e58041fd6ddb5c9c57d3c4451c1f413963501697eaa14ed4b59ffb7e950aae07bcca7fece2502f55e64a7650df687669f838509188bfeed1daa6f6532d6df6010aadbbc2b887d0ad55dc5133c69793d13aaf26d49dcac49a78ba83a823a21ba850e2a4ab34ac1c19ca50d18837781f82ede8a121d5c2b9e7175517a3f91d919aef6a7159c2f5e1873b7524704933873daf1baee13ec5daeab25223a4c2e471aec71e5411ed84ca488d6f5fe3bf3a274821fd8158364b07bbbb2302a0db65fea79e62cde201870fc6c3d74cb4075392edee740bb1b18e04fd8c4811380fcf06c15a39cc4bc1478cbaf54b5aefa7cc795557a6e56e712ba590f1cbddd250f53e7d72ede86a7caef9b212753a8926d956a1ec08c7cfa3ade5202dcce8bf0cb9443b88e1bbeec533988e0e829bf9cc2e794b18dfecde77bca274d6c72ea78f0054ce1489348f1ce8e8d8f88d36d01bc963afd95160cc464ad3317c4048bf181a39e77793c0f23d108d551a3c85d62a3fea29c5ca4af3ebf35a695346e4614da8d9355ab2f001094a5fdd40e783760806c9a01d8cc9603b56f237c1f47f708e3351a8044b15ae09ca1eba2b6da8cd6c061e85735838870bbed0e92f632c4430209ea3563bfeb8659b838540198c9e3beec635c253afa1ac9d47d47fcc78b63809d38363f71614d19b69b0148e993b463f54d6602f74644427dbba4af69d734b5926189fd627558e0519e4c404a2b44ff6a6b02f1081ff5bd95816b8070fa472e8229076c9529d46240a0388e55590178edb4ea43bf71053b0253a0ba28ca98ef2ce5f47bfa52c03df79f0ced4b1fb5a06e43a68987f99b99c5b1809882c57550836ae4b45103b7c4b5024e83a29d4b61efb2470ea7f6f0d2af9929e31eb8eeaec878346fae15f2a20e9b48e8cc37f4c72c2dc59e6400322d3321ca376eaed48bd55b512bbb332a59309544618ce064afc165f57666f94e965b55ec6fa6fe28e3ca355f1fd53a5e46073adde35057aa09c0667c91e7bacf87f226021b9ffee9968ce1ad32e595abfffd452c9c240ec0809efb3e4eca2b8fffe70bc94cd45092bd08af2eeee13a8a132bddcba7d09d7713b1b4465b880ff4b1d19c61afb1ac1b786972cc481596c8a8ef0710c8187949bcc4c4129ad2a3013c811d196c3c8121ebdea92525310c81a96d90d2a1b5896c1c6b66b3ed3ab06753ef65c1efd83b84457b16d0b1f6425ce6eef65e905d2e99d4850b7ed3eb6012b9b9b9dab80edfa0f783306fe16087c8e393799cd405e4e8619171d7f0391df184741fdc0febd6bc14de9b296719d8450e663a9a2be997ef1642db4716b010508a6a2c1ccfade19a735bab3f4c571cf8bd27ac940c92722de3e0b8ab5357b7c73099027962dcb943d1ed97ef7379ad3351ec7d179585137b797d28097bc550afb576374afc7b71fd1027be433cd3c799341dd4c40dac2e20dd2b515fd6276c49e2e92dcd31797e40a19eef58f039b44af27199d6d8604faccd490f321b0a7c078f49876dac435f33866c69a15b5f5f85d1fa26c37313fc378de37289fea1ad0f1a7d99c4d2d9d3b0c2425c2f5bd23b13e0c2eeb06e9badab63ab8b7caa8efbfd4eb05214fc8b5ecb348eccb024de7a082f0feeb945d8761d74f56c955f304d4c6dfc43a46752a7fc41088b815ea89afa2b0e69c7af22c0d1d0f35b5cb4f06c503f0d869b9a2bb1db0d75219c924a0fece3cc9718974d4bc0f6fd85fbeed7759521e78c9b7377e612a23afc5f67c1629226acb5edd866e6194f1113939ca93eb1043ce773dcd5fde4a60bf2111f03862fc589315f6c9c653f29dadfe65b3028f80dd76b95187255ce880382aad4d7c73a2864c766b5445fb96a3d189c80686c008ebfa604a16477d223df8fd2ba244a454a334f1cf8adf0489d0387da0b978d1c92d9140d50c50dbdf570834a8983ac738e66f1526b89adaed85e9256370b13a94347f48bd1052d63cffe63e4490e66f138096f6bc44a8fc25c3251a3243c3d9c89a27bcb1374e06c07c5a86f664dcf1f446db87edde0846bb22cdb3093ea59e09594e55eba04962fc882680bac5ef63728fa69b7c7d8cd3d7301f2db9f272eabb7c7e987eb3dd00abbbe17c7d6323240af280179d1fbce3043b380fbac002ac7012acd4c68a5b5845cac3b187a354a3f782f7b87a50744740a6e1c098ed3049e4121223c61456fb2b5ae8e2a445c64cc33093fe30780da6cac80e7c33d79b4e235f340788e2f7db50f19e46c244d5ad4296359e3fbed07e193a74eafcefdd9242d146cb6087feffd1e77b00ca47da97f1b59446b74a8bda2ea7b484498d379e89483b56c0de117e2a22c7e5c84bb71345302c517c6711bab448175bf3c68eda86183444d2fc04949baff143de9910f10a5d6fa970c4e054ca08c72f047db359e401936220285641d9aca8dd69fe991cd28f39d530e862f13017ef7da29e42046126556a5cc3d07e0b93e607fc714f51b066a4df80e62581fd9b55ab921580327e7de7e17e584b4d086f27582cea5902dcdda57a9122336c7cffd7dfd9b11f7445ec3cf363524646c879a7959c5769186b02906393846b8f13c213b5f8830213992b20fa379a785050057f9d8b74410b8f02d6337980a71912633fb310c1b122424fb5a007144a986b592abd5e929a95dd59614a32a9170dc811aa507a7bef457f33214d4685a3c2ef23debdd75295691b5567eb4f0c355b422c2dcc6f2c9a15b68d3cb0f1c1ace23d351922b5b4c329380d0789205907a3cdbbb373149efa1f3a6af1fe4d2dab3fe03edd787e2370e529deb627eb91fb34c586f3185aee300894b6e4533d2702a97eddc7c567e2505b8e1d0448b770ee2290191e278df117aa3f5f18c6207cc80e1266460985a008b6ff3ee4d1592120e5ad662bdde1fab8e80566ccaa48e475b163eb1fefaefc42853e92b17e38e66cf90b34c8de4c0dc96fb3310c4aa393ffb6fffd7985fad901d62f98064e4cbbf35d2818cd6b0118eb775a5add32706309a63e385e2d02c678e180eadbc9717422b761ac8e92b4bcaa46127e50f798c8d6e9dc487957b7592b4e0f5acc820d48b773d59f339b81c8025025c4a2259d964c2b6b95538327e1ee05900534ab63124e1f89e10914dc53887a008dc1ea5d7c6f85182e0f4e75c06d303db660fd76dd33f6c818eceb208a3312808d7bb11f0e740a450c064b6680e58aea14f3caa33e540336740565e457509d4a2e0318b0c8d89dbdef430cd5154ac108fb48371d625a3ea072a906ecec6058f2a6494d34159b017fff575b00a405ef7b84dd3358c8b957f5f3043b914b77ad202574738201af29d10e528dd2385bfe56c9e395a3f0f295160d7f7390e8b173aed835eabdb6dc10d16dea3625ab6b3810b8eabe80a5b80018249a6afd22bae7ec5bc93f31e6959123e41ec5aaabc91ae5fa6124bab0bda664784a5d8c9da878378baba306f268c42c9bcb335c61a2fd1ad1cccfd6a9dfc849841ea932156c20c307a7f02a70d7453de0e4424d65b682b7fb44d9668964576e230204669b9de1dab0ca383f89f16cfb957ec51103ec8a8bbadcd6c332e7f7c5b262adfa31408ecbd1c432e79c5e515d5b142c9c2774ff1aad159872f8e005c224ea4d62f0838453aba97f2e5bdd956f63ef8d394cd51b5cefe8e85a9cdb30af2b72e3a122596e8aeeb91e1cc64d7489511c654747770a2c91e363af4188dfb9047568d9cd957eb76a6b13851dceebf359f58319d5151e77eb0e0787568bc87ef1612435bbed1459e52a286db20b452ded0b401bd4a51caa2265ef4a67dd23bce563b0ef832b0a1321cf27c4f3f6599564a904e24db92f2487f327042996cb8eb3569eefdcc43d4e9b6278b64851b6d7cfac0a34cabe39e29d58b24adaab35749213c4ec9d69d542178d77ee0e131517f44f3310e42c748ca68babf9e35acbc37a90b9514cd03f23407ac3acf24167b7ea06b9c3ee674f80962e9c69e3d880c867a038f48c578a3271af3dc1b3b902ee26a65faa0c02fe68550caefd05b7354a0536093747121b9ae80daea8ec94b4a1fcfc0190a46949cc599f6f66bfc07ade00d97dbde4fcd4d41c49ff22c5e9e9a4ca72ad881d14f3ce8ff178ecf3a6ef263840472dead0d8ead882a9840a8fbc609ce993ba2a0719c78e908ef0ded784df3fe2c9e78438c56f77991321f26abf321ed72c46ab78fa644f40086ed8104274012f7a61413013f24c27aaa643b18d8e051984eb954f731d24346a49aaff8ba2eb91ce8f85b5ca4f13be0caf99e4a683c73d334bacf736e92fd63c8298357a07c7035f4dcf86f9581a9275db11987c19c2c44218288d41196f1855f91037754a7a8106183042c3483ca538863f5409e2d0ca90c3a1af1c1d18449fb426a63f48cb971062e26ccdafe346d734522a93ed50a061922941eca9be4796c35f57d7fcf5959970acb8a63d7577a99a19e39b2d13a80ea48631610efe26951a3960d21bc1aa677ac043888ff059aa98a91b7bc6a4901eb54e85d5b662634293f05678c772696b53974c77cc7f5e106c13ccf8e506aaa791ff7bb726551ba068291e217453e1e4ab598f1e22ed58fd0ea4600b9d1f0cd796900e053cb7342b3f46bf45e50a736e54648f61cb48c8fb5970a258d30f4c2202ea74ec761847fda294444e3c2eb4c3af549f5b9206ceb98a5ca6fe56592fb17d72be02ddf75e5ff75fa0f16fb6c741d3a92ed07530b7fca74b4f56a08517b6e3781b2765d70f6d210f94f995c15c09903e0d7d3cf4b6719d9f8ab5555ce5f2881572c5f03feecf5bb5f3ac2ceb841938a61f71a06bcd562393a822b1336919ba0c3a9d0768e2330d5c40d3ceda27f8e404e2a2b99fac30e1eaaa9b5fbce2605355a051bc2832ec24c8aafd1cdc9992e3a17b2e4dc451be11609fc857477991e43b1ae22277ec4edd99052ccf36f2e71985577f8e5c00c62785db3610431e3b925590dd15b8f33c489a21596606fab215dbb55ffa51c7b383dc625f6ade2f85ed56cd777e578bf79f387c5edb7213fab778d8096510956ff9c051217762d6fcf149bfcb422974852e077dc351f578b4d2c122620539f4861155518f4e25cf82f44489e368f1a4dec15ef906698d2507f54aea62061fbac452ad02da028680211b6615c028124d134458552d3de706dc83c5f4009ce3c5b70b6d51cd19e19b2d22ac0b2d2107d81c050d0cd56c65e68dcdd7dc640675234442291c7453cb0b490e193c64686c7f6120460ae2a2da89995ead4b6a559e77e6dff4a304c79c65a3f09fdad471e2b75c01049d9ce108ca5fcf7ec6d1aa71131a9eee7267fecff65ebb6ca1910acc9503e369f006740c041a2889f2fbd19fce9de82f78ecc57d030757a615a4db2a1c8af0d749b6a0605339e4fb35711fa16cf11f05c1e2f17065adcb3865fa0d04a99b3c7e833c2e1b408e0a1078536f6100edaedafd22154e54a77e24eee4752b75753ae2a9abb58c5320cd268b8be4f612a96fa5b29ab71be282dc91a2864b512a81ac942aee760fddd01e63b8fed1f7e191d96cb344e88f61056fa213f8c2dc0be9a8326203122db2ab17a3468dd81bb5ac49865a7a9cbe08d84b45ea9ba62529f1b5298ec45fe7f0dc8e3ed498e22087abd510286d430a15bf27ca0f988ff9743473fe2a8b69b1e047e23df5218fa0b185d75e3bc09fa4364860eb2936853e1597e2b5593ac9216cbb5eb983e922f601090569dabd88e82116dafe18f98acf8ca4d4b15fd8502ad949785db2dccf7b2d3e049737421041723f95d87645f2fc21313c08063a2c9ef342dc126d8f6f960e4e3ecb7250d4f9ebb18e3a9d8e7a49757ace7d243a55e50e99fede5095d86f600cf802514cc632dc73aec9db85c8afdf7f95c0b44282a1e746f2e964c29ea1b63f8263f154483ebb9292cf92ec240f43bf11bcaf912a2b5d50786bc132488a76310def22f6a8462741474a75360fc513feb7a7808d688b9626e9e405dc7cf4772b7e77af0360004853fe97c52d0490b3d350f86e9601b20d0e77b8c0c166c486e2a95dbea1e32ad188422f37b2ace042e329e24d1797538374d9d16ea4f0ccedbd286e0137ef358253de97837bd8ca00a772b48f3942d07d35fadc13f017e3be48404fbb9a75f92c5d1f63a22f25ed2fa339ac792f5f6d8fd33979ee19d4af518aa8b6f42a2a2971354c816e0a5802b40a69722a96f005038599be828576689466f02d6c4c12ec2c5fb4f437c53ce4069d5313abdffaada5a03faba1d346b888dadaf6c1e69b05758edde6217ce1b5d715ab486ba06eb5f7f0019680c410137e668ca49bcd3eb16bbf39c9dc8cd62bc4e4d5ee58f2aab91d9bdc3d51fe411d849686ef7392393f7ddad0e3a48bb982b4107d5e4acf799c06598476d2313ae168657da4dd45f9be01daf6a6bfd8239f46fe774ac992e07e1a55c04cf06d0814d24295154931315c5da5e77fb46c0f95a0b9e84a65a6761a70c2b9efc0a87555b23b7e6cbc63699d9f685a4dbab459d65702179e1a78a99b99965689fb45508ce764bab18ab5f156fb77406d2a46e2d6c222a5446d7e466e32133a1993bb2d42acaa31202fff60b05597b74f6cd980dced76fe621b78015d4a38376d1ba5791e4fb95552b22b0b2f1ba1f9bececc5e80aec4e69e3cd5db930ec2e87eed17dd698f9eacba819a5fbcbe6ffaebcaa2064793f733b06cad3af5950e58c188c192cf192b312ef339da797ea10bb29d5f9aab44a3e8fd1f1a65e88d4a2e2ab7828fd96b4c425d02d737acc29f698ad85001c833c249723502b59ba6d221991143f0bac7f85b2b4a874d3f3d931e7e4a50c2ed1fa099477ef7beb50779a88c2616865783f6513becbae657645c6edede746914c2275d767320305d82cf0292128a6190d9de7641f2002c887608ef3f1b4789e8a9d1ffbf70eda24032e0db3139a425aa66059712946b1e80b259564ff75d11dca92ec70fc0da8f91504e1c16832fc250bab871f9948aa93f82173fd120bf5b52f80607be37f720089dcb96963798bb9997f0f9a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
