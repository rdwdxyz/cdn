<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4caf9350ba1c0cb1099315822c9cc93796fe696a7db39fe29d69f8311937b7765e5a14401f475e7887a1bbb4499c31937cb51247e7c34582628f443773e5f55860537e2ac8f855b4d98fa5498bcec3b372ad42fa25bd522e329a43031b090f7d210b455836b75eb557f9f63eb8d2a86d9f8aff7eafa0c9b5b5ff1679c391ad7021f18a68ec1dea31161c4ee1edf38e8fe90d18555f227bc0b5916e1d07511a1a0127fc4103203081146829d00cc254c9398b9829e3b926b510c62e671e33711a4fa108d0c4c43389df264d6360e67a16e0a476a95c31c29084d2d958c1dc15c7db535918b0e08ca989324da49f9308abcf65fdddb649ce584c2a3aa26f6870e7829acfa7409d94036895e1e99cc97dcd5d50bcc3a1a17580b42f727b9edcb49998f2785cb41ab2d5437a7e194532e68db40c37ae5e51c6c3ba79eb1a197b4895c787e7758af438b210e8403f63b4dd02fa2cd7cc351bea083093c7602256f046558818d15a90f63a4cda05e5afd6b146cb15b9852c370304f75deac3abc7f4068b016f13a2768895216cf17e0ac67586a1535fdda69ab92c92aed43032da87002c1a3042f7a3e27c749af8d1d1919b8e205ab4d8d703d855600129152f313fc4d363071fd19409ba5882d4e83de56926c989d8f59f8ddd8b0bbbef3c55709987836dee684459f12eee26836980f1112ddd38a708ea3e13348268ade574296c05597993f96ab8e6a632770fbcd146763e005246c7beb7fc1ca8d4f092fe0a2e286aab2d7fa84f68b43c4343e8f459d209bf98a20b16ba2d4963ad7ad83c13a4d3277f2001d82d02a5c489c870ca26dda1e7524cad492a73a7a84af6672597916ea1d5632015f3bf0c953781e2e0f3e17f8ff6b01a9a59aac4bea87cf0565c0acf8925f6516c13c5075a719c8b01ccd2fb7924b3e6d6a6b5b1a9091d116110a34d5884c1cc798128697dace6c080b68f2877c9edc1cd91cae12436ca023fe35e91b4da68b9424e756d8762889774932139dd52497fbc8d57b056bf6575fa0db2496c25a04b850204cd2fedf5d7f47af9863d963ac80913067b40ac53e10257a446f07281ead1278f638ea6f1ad920fe53449529215c4310c340956c1bed651c8616347fe94069b060d424b02330a5aba14b9d424b387443db23b9354a8667d09f3591e6f95fe0448103ce2d0026018c5f97090324d5ec3b29fffbed7cfb3be9b63bbe82930a7fee1552b35821a415789d3e112aae8bf4af5b7d5c66136a2c439b6b328c55c52faa7133cdbc5059c476ecbb02f1b2e55b70f0eba3d0baca052056d20af040d4b74f7f63bad4e0f70651d55ce7ab3068aa1a99d393eab048492a0df1843a71dc042a7b39290d8d5926670adb83cfe3b87a6e83d80a2a1bfacfc782474ac2c664f20df118ac3f08073089bef46112c7529cb20456ed0f92dfbe68941aba8bc6d29e7673bdb6b26e1d19e8a0538110824aff01736a66b0a30c4c4266ccac07b4683a7cc9a8c09d5e904623f0f917cae24223de64a33a6846d9e2df4bef8dd04cc329c6f791ddaaeb66cc1e517e712399a8078f1e05f941a2c2252d7ad82924ef016ff090f0eaec9bfd6d98c1d2b7fa3068680a462d7db3dca4db790b2c277983e3fc2f48790aaa61e0f076a890ea3069acb46c2bf72dba1eaab73c558925e8d221f1cab485701f6fd6f9edbd95b66f1ed3a397b96203cc36aaed9660d98b56e15dc14e2f44e560d378cfa034682f6965416659af8cd5c45ff01e0ba97543328a6312c98284af47e55e12f4fa1672a7dd1a30b6b24711587c1c8a2f0e3a3d583f47b618c70c72e67078dec1e6519d288b80809b31e6f8024a406b0082308f68e0b67798dcb8ea67d4dbf66f6d49b0ad9799c117d8907c968714f27889454acc085e467ab8d8dceaf4e6584e67f5714c191bc501ef016c8b6ef7408d99fe8d51ca7c98be7bf9374affe09b860cf4870b4f1a97c0500b573e072cc957fa90e111c1350a68fb129279207a4eb2c045aa2fe2395d8242c5487231c43e89d267ead48b0ec6ea19743bee8ab1c6ad84f35a512ccdf27db781f3b98cf4c00d6a3d78f30246e30cfbc9b231622217ab1d918a4df9770427439b03f8d066aa70d80bdfc8c4a6f9039f43bac825eb1875b77d80d08d82e253faa5c39f53c74072290d5dae95c18edb0dc6cc0c7a1ed6e91d2c02bffb6ad73e85f32af2d070b9143eed1fb9b55ab8c2e12712f0e9add89070678aa871d8e86fce6ff2786d89efa00de3a2438be1a05e25f2560188874032cbacae3b10650e5ea65e78df449816784e81661404e79f30977191be3961d68dc51039323e65380b54ca2bbd22be8db7a227653c82b25c785ae8adc502002da5ea0f0422c07f58a132651cd5ece5795ab217e43e53a64fa342f26759c2c650fdebf9a80dd824434acff10aa24c823b05bed91a383c3e590bf4567ee270d3ce059860a048bb74fbd4680535d5d93be1949f0bbc2d941a9bffc733bc86219b50861ed04784b827371ea64471dc1e0610a9f45a0e0b7667cc08e114b16f12ddfeab7c0e047d305d8c5f336799f1ec2e44c093db9770331e726bcecce7740a99a66f7d1e0c772f416a17a7e0abbab620594ad7156c13e87f761bdd027771b0d6e78ea6e84630db2dacfc704c28b26783803fbbb458f80b18673a151ec712f64563b839c1a064610c2990a04a60ffdb0d940cb47992ca35b190d21f01cf9f84f891e947d525a2d6e6caf054159c5edefc9ce0e562b342fd7a68da189148ea8d1dafcf2a9104e3cfd699da97e7cd72fd52ed473e3724cd0633c89a1d20bd21ddffcbee9dfd18d1012c983277a865fc21ef10d30168276c8c55fffa436c08ff11c3a1de6329d692187436c87b0495401d00f5f9249303f5e16422418cb2a4c28ff70a7c4bd93cf908853f8d38863bf3374b2faa1d25ea6bd529b96706af635bdf666519dfbf242e84934d8a15b95e30de6dcfa59e14852f9bd7d3c9fd1be8b19bdb5999cd4001ec6f39e7ec97a066961c87a97bfca2cb4f7daff8820729996b1670ace1e74fb0c81d6bf2d30ffa7ac32c121faec75cd142c255e62aa8bdc770e5e83bc599f3f8141202fcd3b9db05c14157a47c99a7aa6aac430cdf7a2efa03100bec6b717bcd6f38c078fbff3fd23ab67ba8bd4f8f4b018e2c2ae061174c9052bc9a1135847430ebfc541e2caf15c612d2d54c83a1020412d03de9f9c8781f12f74cc2e38f0436dedad50c4f629b70c0f7aee9557d1c9bd247ee7adf0efd60d7aa50d3ed19c02eee0737dcbf86af94b334f3a93d8becee9324b2ede7c66134d81d1eba08198e122c317433b97fe036b7a2ea473d9aaadd3a44ade7b1f4a039aab40dd4d21758905f31e88443c53c222852f61f444f67a71adc4072dc67badbb6382f7fe66f95d5d319c1af84d0ffe232fbd57b5dd72f8c0e017e54a2e4eb7d7ba47324aff71608a80a1005809f7a200a890be25ad66545e18b4e7445a4c0d49d9f8d051176221139ab7f36da692d14d65b7bbe9d50e30058704d40a38be28dddf869a6d3272065b941aeb8ada4817534a0e85da338bd3c0cc11bee6a58cfb66c95c16f5dc561e5031e63a6e9879293a53dabc1820e3a0e2521765711560a08dd4b45e1a191d681435a9ce846ba5b30445e6d7f105b526dbd04bd74c957d38761603d810852e692245ee384df3fa7eebbf36be0ae4c06e975f533c3a36b33b49b8d61acd30eb14d4b675766df40f787a0bfc24a63be3b30116b0c26cb9026ffef445f38c542ec2b9434fb949ff4d1e24591808656facdec2d947a27ed87bba8b6356027d22b9cb1e7dbc84cdb13da7b863372ac60498fd265cbe7809571e1164c700ca191ee85cf3eaed83aa841fa38f051439a0ebfab0a005312855735a3339d934494ef7ea78dfab9ca9e9357d1d0478314a56bb5fe0ebb8f1ca695d3f04f8e58928793b159c74c885950beb5336457249f87408316d567555baceb5baf5861337fcf2749821e66b999cff425525f1a148281a37d65e3e4877c00f057b0fbb8c8e97f465033f3185d57bd3a9ce264b2fcaa22d9e1f0b891d2138bf06cbe6e209eb6e977934ce588aeb4f3e7ebda25fb67970b02b280f25025aa52cbd2b00a9c6621f8af16d1641b0ea6a5eb99a486ee986f5a59bc6d8ea5cb15822ee78cd36f343f73f1c9300ccf7bb1e0521f87f6ba1af832320b851979d6835040de553a2343e6d3841af95ca65db29e823d3514ac96360cccde19178ce410183662313a6061220190405448e3ef6d02fc39fa32024e2bb715c4041dd1ac76f824b384f13aa2f772c18e8f307b8eb59851757f55f28fa58b9cc6db48badaba49656055f4f8ccd6b2dfd2989041dac6bec77d3c5df7dc8748bb739e121ae6c70f6f51935ff2bf123159619905def823fb90d8e10c72c16dafd81d662d4905c27221859c3d342af05eddd976d9811e06914f39de128a88bb2f501cab2c9f0f5fea672dfa84ad420f06eee7f1fcd565fe9d079e4f69f9bb00447b04ea1fe2b0c53e7b5d37d3ddca83de8679b47cab589eb188f435bc1ccea6d746cab84cd9772b73971a66c3164e3485d25d3569e85c4ffef5ae158cb1872c7310167e8ebbc6c9db6f3fa24b1b81888dd3b6e71e2536610b7c64899337007be509ea0176cf656497928d0c9d897d3c046bbc99bc0050e1c5112324ab55f3b7caf029c25f306b88bf2ef586d7a53e0b47a42e118ace1e45be4e6b92bc6c8e7e50b24beb09c774d40abe975e3c29b3331a4fcec65a51d25786e7263773b24d08f80194af8099e76d69dcb988796a8fd27e5409b93b1da4ea7a80e57cbfc2e3e4f78dc5b7215185ae79f5d48cd68bc2c648d6717ffda169f92e1b6bdd23fb802f007e75d07770615f44877992ec3d9866e43792bbc4ef56cb989a278f35f46ada2d856c231648a8f8e7374d7ec953692db353ceedeed5fe234a246cab2c21a00585339485d46d32dfa12f0356a6b85009d95b85be31499d5dc04b5e57fa09bd2d3b33a511dc55dd59d62a1e6c4d43b763c87309464271319c0455e061814a77c40d6af801fe4957a77dad31972cc0b6c0f7b95c0d7e15c6b67b879675ea88ab287eb0b075742490253a4cc8fb1dd260386cb240e6a879c7e769c07aa48ca1cb7bb0cc7d836f6cb81f6ee248f79772d53a0068dca4f4835bb9c0f16a46dfb5f8391ec7d0acf89f5f171eee3e2cf47a85f318ba86296853ed6d6c9b7b5ce274b287e191a12fdc68873f7e16ea214a0cae74a63851f3fde5411d6485fd026e4d6b5fedee2548f93f0ad82ad74768cee1a8e44be2769603d69269928dfc9c2361a39b7729b26a253d8f5264b4039fb9db594b457ecba0b78002e263604c30d8fcf157af73127ad0d9e19286fa0d5e13dcafc5f606f0df1a727c1449e9fb3d161893e0e7cfdc924cf639cc2b36db60e5f57eaea2884063c49839807eb19adb13359b06e5b28d209a0e10b5e93be11381a16a8bf763d88734916822fddbc9b20b0d6e6917813220d875a644fa279398e9636aba4d62db71c3031ab014a6da0ef5efed6b31854a33f1007fbc475e7422d2a46f1f9732a9530aa7ef1102c15ad29ee0233fe4e3a93c468046e3fe24ca1270f4807409a28697a8af89a53c428c31c0b95d5879bbbc683f134c291836cef5d8af66727bc5a29ed6b3ed12d801db5b833eed2640cfedadbded7e343ccfd5896226b30328fc7ee7ec1ceda0227bad5fea6488e94625321db32ef4e6f966877c5cd5e931a63e4633845127b430d11c706bce36b2a0d23da26ccd47c0d7c5ce76b986bec7412f10e20b88d805fd529fb237c47dfeba7ca75dccb2ca779b84052554b016c2f314cc237850a4c57c066e0ad95f503e08488cb218f1d9bc89b4e4b89158095026c551e26c159d4659c4bb798784e54a12e6c3b7dba7413d1a5d72626d5a228197fdff3f09f66015fc103c4b4895c881df74fcbbeb116d15b3396094661d79b6abc4249c8403e3ccf8e1d715039bd544ce7391e78e8714a2acb761c280914c067cf10322ef4d52416ab8689ac26637b2143e0e99c67722c715fa62dbcef3029b4a488b6b4203c8aa27471c4e483722f4281bb99112487367dff7fb8fe640ba4294a19045031bfbb3d1ab923ac553f6c7d5385f726b3a991ee1fa97f5542718fede37ad9a10ec1f2f9518513e546b7306c62e3144b9ab09311160104ea439c4591bae1d88c9571d89fc0a21f1663844f3ec115f9b0946a896cfa51275dc1660a7abdde0aba0f39deaded9a585509bab47b6018677bbf74de3ab5c8eb777f54d03c57aa49d009b4c5d2b3fd5c6579c21f62db0d1326e3927fb64fca058767899250cb31de6b0ebdedf64c4dc96fe71fc8fa2a3f20dd7a856a1e6bc3543615f30fd9b6d53981f4a8d477d4d8d7dbdbcb8a4f66926c5b5bc16573ff45fac14e1c1f6b459b8a7bcc8566eb242fa734fd3647f036fd895c67b1a3d4ea2716abc3a995d3f9282c988a1e239cd4ca08645837210b3ca86362c7a0c26a34993c23862f4358737717f2e8a005f00a5d3381673cf1dbd22f6ef7e628d2ba6a95f9504fed5add0f156bcf87a21a11ad86336f9f5d33917d2e77a8d57c2bc9424e5587b472cadcbd490a6edbee8707be103086ff842173389ecc9bfff0b577d1a985e847c3d28e1992c09b6759cdac63bdf54705d0e14977394afe2c3a6888aead3c0930dbfad217d6b217777ca50697dd576dc9207aa45478cb3e1caf14888e6d72d6a4ce8fdd4b9c2c4575f1b9eba36d237ae9db67bd37251377f47b4bda0772a37685194645d4b4eceaa9541c101ebedf5b68435b34558885231da78da143baf02768515df7ae534e9d14a29c94b37b00cd5ea114319f9488645695de0657c87f13b833df45809bc04fbaec60db676d69ab547f09709bb2bf5207d990a1867423480f2a8978905a17c3d040ff3a7b539c0e3b45f2ffa236caa6c09679abf29d16d964cf9f2e1dad44fab76a927f673d52c59f28a3a47845c9dfba32d086db28840df71764bf4d1ef3e2aea47f9d2b7d487ccbbe0f1481064100385221fab3c45417eae4a77cc608c4926e5bbe5257bf653b29e292ed88a52120d0e396651777207f586e82fa36cb6d739e9e848959e36a1d1eaa9da231a95a1ed854e40a4733831684a6d577e77dc20334fc1a0da2c1f441ee30e5edee26a139a422aaf7c32346d9d934c795af411a745a58f5a1eeeb881b1f3ab727cf815f9f6ed6631e2135297ae4274fa72699826f0e3bd6172b10a3df0b69e96ab48bd0a8c8208f2cc2acc3bb35125fd11cad49e8d7dca43c8e3c5f5b5dae27faa468706697a3045557f8c85cb77088ffd90392fb926fdebbae893abef2798fecd88d0abf00a72044360db841395e2ef450fe41364a5c0942f3f18f99dd733f6c3a0c05be4b137431ac1b4c407e76380ddba25e2ebb3fd2aeab31383a30f1d7abe2ed29728a5b10bc58f03521269c23a3beeedea6e07ad20af8f20b15794dd0d034e8faae5f1aee70b747be64fdb93992ca6977df0118ac5e61567d716e8b1bb7a7dda6a0fa94146a3023c7f5a571b3ee432600ba1c3065727883b1ae6ae12dca67406d0278d209fe38c46c1df5d9fd5a9949a992eb2ab2f20d7268796bff4d77999da12b72c50de6c066728c7484c9dd1c64e56b022273cb3561b3dab5b2d770fd4343eb22f72e31a72b0814dfe9ed41b8f5f26ce938e3a6997a1c4b7fda619c1af389aa15a9cd1b693d258cce586b4298d1fd7227d356e42dceb9e5985197e7d1d0c602f1641a7cd364de2f28b153524589c5d647f1c1a1700189772e4dff78591830896bb0a1e7fe2e911666bfd09d49aa6af320cbb23ff65e1e79e2b2a0c2b95c9fc92048e506996710badb976f42113756829d6d1bf23963563bbee0e033b9217221a6fbbac8d789dbee224911ba3f619bd6d8bfc2877972c711c15bbeac1938515a9518b00d0e41fa3b09f14954e860be681d55c91143c1b168615ee57f8eaa0300dd5c9db4d7408bba8264a2dfae0c4d40c5520ae0f837b7cd44ea9a6ab3fd345f9b1c5109be764c4df3476931e5c72c618c1c446773f4f2195263ac2d5da0360780e7f5cfc041ad3b7384f5c6cc38f0244fdca103f83ee0a83e781fe7b3816ab64fbcc3472bc567833c9f97d8ffae35cb364afb9c07adee25e7c4b9de66c0b54b3e73af36ef8f54d1d29133a36e40c9776aa7a3671cc8af278a911374ade5c87e278a407ba8c58c00fc0f6dd9cfff7d308f06bae8417444cbeaa35fbe0e408dfdd7c2f739cfb15183a491a0f53dbc7f825776dcbcfea331e2787a685737554e14457159e8edf1f7476aed05e6de733931a6b681637a8c697a2cca1abcfac9fc2febb86a7e746cb9c8cb5f0a8792688f488a3a5ab40d05d94fcfe624349999de5da9e73073e8be5b845e1f3ee02576c4e2ebdb4af157fcd073c322d0e386afb5ee800d9c52388a36f82b3cc4bd102295bb190a487abcb816b79be30a36ff00462d4f9f246d84a039c3eb0f90d19e6398e839eb67c2d265fc7e08510b540a045bedb26d40a6d92ccb0b08526da0c1f36d764bdc2bb0994acfdf3e2e66bd87146e62a9ca3d98ac8115c4ee1d44525bebe22354d6aadd901139ea3c1818f14765fa8cfe29fcd276822bf9a4ae9b0aa9fa2265e1f6c8b3e09ea1687f23fa2d9f662841b57bf3009ee0ebbeba2fb5531f966691392143c723bdd8fb8e436e612bfead54519de7a76b02f4be9101da89dd9295f864a9a55a17fede692a0ca5326722146aa408eb58467bb068fe38763023a97a4d045efa8d6777050cc3e6bce744780b7391d5e30b6285ec4a48c68c3e02231c0aaca08bbec26907f6f88d8ba75f1afef86f1ea7b5aa3196befef40a613ac1853d5a5264c106e11215fd46bd6b50e452e996cc8f2ad5bf7aeea448002e62c5910082723c9baabe12636b3e00532b5a6826e5f8d68ab87b93f318b47b83d4704d2a5b23dd01c9389da838ddf63e9ccccd4a533aa03f9d290f91fe20f0d3158b8b6f912cb8e7d34626b757f8efa9fa81511ca92f592854821897cad443aa622b40fad55cd2996aabc022da12be669f7892678c25c120331e4e7cf908348d0ec053dda4a1216585bf340f5df253bf347509f7f63a0fb1fdcb7a55145db0b2350f3ec66cada04a50382385f3a59aab0b50f7e78bc8adf8ebd246601c37814aa5a46d4f87c052a31eaa470f27f6c600fe209450011e019473aec2ef617ecbf1c0ee4eb65ff7dd5462b297b71e327f79507d33640c0ac0c6e36124a0de1aae8e3ceac11a868e51450b56f99b964c3d930d32c2c4d669e6e29a4a7c166fde2d4083fc46659118bd50f7af9f0018c3edd54dfd4d07fa8dc9861d7fe2e6a65888809563d4bca0d50ae82949ed2b49bbc4f97fc30e23d65e085e2c73f3b75292a8be4e1e1471cda0ce059187198137a0f88de768744a2e672cc77fb0869448cc8c8b2c8519d9a3a4c2f3128e0b7415874ec0931c1e10e60001ccdafb366068b1070079c0fa7653f2d4ee80d99e05a14d400950e91a05c5f4babadf97efdd5f68a5acb27c1631b84863885c0dbee1d88777641a1a8621d515a630595c96ab29e620ca8ff86578d7c47a7e52b92ce9cbaacbca315899fe1635e728d1d9be1b64035af5081f71db4ce88634f299a38f739eed7e162b98164225b8d3b285a51d24499c6cc30c815b2e3fd9d7c9c782901d1cdb2ffaa2a13488f31ecf9a398338c317554eb501bfc68a5efc9ac24dfac9a107d0dea4ba57350c284460179bc22aa7469abe1450802179e6599d7f6d877f22ab653bb0006cdff750bc87c985794ad518c9730248d8ded3a029050cb487b0436b68916222d6935d04c9a4badd0d0419790b2396b5ed877fdbf3efd5d2af5d0e349543f951f4f8c0dfd8e425a9dc6ebe1d5a5f0d6992a02ba2913c2d3e9f60bdc29c372573f81efa64cc2582ba2aac0558e8500f50806489b27490f8533a552e37fb8f233af724e061cc97f9451a94e6fd489e354ed06550d05b45657c7abb756cfbb7724a66940cbc59e5738ab89c95818748c2466870775f6a7703ca65263b16d12c4daec2439096c3c0570e4ec81230bdd80ece17f6e0f032b439630496042abf144331d363781b34f1f8138c668fe916bd11d7c3063795311173b8a1bcc4fbf8557dd25842164d792a99800c316f318131cdf84cc048e86e5aa3f8024a9aee0413a33faadb21251f706a03716dcb2fdacd76bb030d425f42fd13a2c00be243fcd7a170e9584cc85bf1b2ecec380b73c2345b6d02c0bd41ff8d833ffdaf9a40ec30239bafe6f9a518bb570a093901e2a00aa8d83bf20d2078af066c2a54acc53d96c1fca0b85f5b511055265255f0e1ff4156cee7855936af489865f4980a29957565b2fa2c6e2484662ad2ee74a2b71bef48706470b3a318c5f08ba10e00288b3753a565621caf3cd073e34b3b9b8116ff097515a23c68a0a37123031e9cb1595586a7379b251ca5695d74bd48047502a0a729715c29ce17e4c260cd2ef1739afddc2db291e2cfb48b23202a32499e7f2c283e0cc9908ec4d0135bd452de14cbab9ddac48886d2e63ed8a0bfff78d78b61528bd504653660bbda0e8537fbccc559cf9063de908a37ca814912f3ced9162344d855e501ec86de12dc9dc9aad95e2ebdbf9790a41f1cc85aef1e7152c209686f2ea30fd6b14214ed58d2f76fde76a1886f6cc65d04cd9dfc6c5f505c48d7e32335d8af8a0eee2a507a57f91c7ca2cad547825bed1f3cd65a9ed4ced1ebf281fef1b84eb1ca29124d365d6a9cbd53bdd6af27b72bd697a42e152e33d517eec83fe8014b614fce8a74d085b3a2ae855ae3e32f4fb6edc471cef3af25f0b6d9c9b0bce4f57cd5ffdf8dc732d46a515832ab8ff67ebdbb85a8163bf2f068db72a545246f103eb7305b5efd9301bea21016725e6f7ce26a36892124466efb7b1ad9af29b23248be023089a2d0bcf7b6751bacd0907f28f55cb3b4730193f397f7e80c78cf8a4bfba268c14bdeabe2b274723789a3d15d98d19b7391d294106134cf557ac996c7983f255d604693901900fbb2d2355182749ac6fd98139b5f919af6ae8601770704d2f2e26a5fabe173cedb4ca1cb2af54f6fec915ae5a1a2f4b8fe90bb7a9f393bce9ed3ad4b6fb2293e5ff273a1e757ac5414a3a788e13ad4f8d19f0d5d07bf7d28b5c7e7be80cc22402f7f73450ef347eac1fa008b397b8b894a068c21f518cf5244c490ae3861e0af35e0a832e5b19d6e1901dd30fcfc167bc101440a7b66b38ecb794beedb55892ce42cc2807f009a55ba6153301197f33e877020193c735290525daafa6de117f1901a582ba66fec7e5e52438841b0d5d4b180296625d94e5a4ac68b6830dfd533b75b2fe9d20b809d6225dd04f1d573c9895dfc48c1ebd51b50dfd8049d4bafe3abf25a3850d19165e7e94b90372f9516d0a61081768681fd6f58f2f9c410c65b3f94f3098acdf50b15c0d5ee0ed47f080ab741bb26cdf6593d419100a4fce626f36c7ec17e0879a9541caef9ac27bf4a9ca9170dc5026aa90c0a8095a0dd0fe637db83fba2f8674d7ae623b59bffb84ad557359dceec06374ee427c1c3d94beeb09a0a0af899ebfbf80bf70e6ef4277c12715db118b8dc0c73e33d20bab73cda06169593db27cae4320b9a8c0af34968a4080acf1e0d8fe03fab4ed3d6756fcd7f5a228f73dbfa212a594a208d46be72141955a897ca5c53bc4a25ca2bb078e17c87858ac7fa77b49b2a7401bc3b7d54ab25b7af6ed7ddd9870729b3d9752df3e8aea5418f56c6e4378ff6af3b7afc184663051f15bd229c814d98134d6641940906f251c6a1fcecda69b47d886d56f78b309c4301899b57ffdd8ea616c8f118b94aaccd172a906ede0f4bbd48315c1b17fc91ad74e189554a1c866eb957f67e44e84e1f83812ff5273887ac539dedc2f360f9693671665baa99813196b9685d63b3ad81a212bdba1bc49ad7a77cf350165bdea33a42593251f3f45e2c1032702a57e269821d4ce862d1ec1a5992f31b857f5197a188df5b93b85599760d4e24fe735358e33b1c6cfa96b4d5ff7ce4a2b5703a81c1f4be5689ac9dae51ccd431bdd41518eb18f1fe50ef9d98b0e520cead04dad1f61a4d8e37ce4c8a412bfa8ecffd7a695c536ebf4d571d8a35ce926237d225a0586e778cdbb22ec429574524ce4fe5c297bfb5dca5fedc523e1b00ff0b675d66b5f66e11a7f23051fb3a4cdef6376078b23c92eb35c37eb2b9b597f9ce71ec6726a66b73df9a8e3c5c942b0b2cb8c91b14c69680f215fee9fd009480cf66959612c11b709ce227426ea34341f0ee9aa45cd96d03942f736e69580e21cc59287e758ceb4015ef39edfc17b84f0a021550aba833c785b4aa8553349fe3bd48565b14a4673153b0c853ef7e3e33d518e4f44326fdbb1edba02bcfa9983f6ba62f4daad610b83e76d8c516020cf7f6d43ef5bf64871ca3591d24fe611dff8f260b2b32d3e179cb203f63f60d9bd8ac6a42c292668df6c525d572342afac8d9dd80d029ec6aff509a71ef6499189eefb4a8293ffd1a46112a6062a04f01a07f3b7fe2a61aa71028683b27388dc0be60b20ceb8bcb9b287ef600feca88d0ea45ced03960c4d27e01025f69d86e539376898dc4865adf2354f10c1542be0f125093d317652ac7e061e88e47dde768524958afd214da05878b48b0246ab8184c6714ea547684ee111e8d13c0e5644a75ac6cd41c4597bae3ac07ea1fe553dd35f74435d2a3cb147b08727ab95581c39733bfa0919f294bed703054d4e2e6b7ae0c7297573b2ed0b918dac437858731e6bdb21afe86f8846314bcd118495560abec2f53067b3152045baf8bb5752c72955ac43cbb4f1187a815143ff3a6dabc79b3af892a3d682805a6bc366ea34501120d27f82c687009428cbe04c32801246cadb1c7098aee4ba99d92963902ac0177503b34e2328ac8ec336cf88393b10bc5af9bc4526ee813f8d32a34de638552d8197a08d1153699c18c1d5390e5bc4caa9be33e296c5676bc673cc25721ce7b4d3a212a3e14ca4f9b4ff1aac87234a742967c55b33a4ea41877209f2a9e3d9a6e1c98283ce070ca85f638c2542204b17a240a608b769044a8944ef050fe1fe0f1f71fac32f302ad21ad15a7c79278adb4721300b3af088d91d28e9be5498e069f64656e621cc7a7049c3d99914171c6ae08cfcb76dde8f7ffda99d1a887796edd10c1e70c0774b8853bc8d7f57d0c6b13477ddc4b351e70c4d3d2b4b2dc2672abda0c0a57b41223b80d4054604482f172198dbacbf6af9a1d14ba04c9d9f4b3e409bb07ed6f98ff38ffa39961129113bb2c26e8ed6e54012597785550f08db7c2dcd1d8e2d624cfbdc91f165403a079b568799e05a4aef1f0cd822decf8627d76a5a2e1db036bafaacfcfdee3b0d1ed15bb04a65d0f09e709eaf8c3d1c5c2b2879af27862fd853c14e53b79665034d74f6815a0e48a61493291d158a4152b2003c4a4934b957208afea43c8b20a8c1746e3225c61b222bd8f2e42de12f2c54a01431ad5dc01b34b1cfd821452518f42ee5d4f330ab05156c377cb61971938aa8ae782c07fdcf9ca0ac1f7d83bf8faddb2891265ea1bbd220d09c2bcc83bea521576a6b595ae2f2dd1631446cccf37f025f75ae4b7549b8739e32771c4c3c0960f0911c23c721e645ad1586c74d02a27f93149a1d15facf73601b2ad3f7e2fd027146fa9224a1b4a26efa158f2dc19aa17c600b02ad0eaf19ca7aca982c04e4777b0ea118203d57a47bed099e5744325f7c6b44d3b2f130feb3b41b285edde934554b0e2a3d25525be5e94309747d691fc0c30514dece0bdc70338ee8b0ab54d2e7062a5876280b2c21e8639a4c8b2cff59343cdfddc9d77693da0f968a8b38e8ffc764b46f5dcc685e2afd801322d955da9e6b83e3fa447433809f6725695451020ef651c4b84ba0dec0f946b354b1b5f9c02c2540ec16ff43dc3776015104227a1a7695a6887c8295c4c39cbc35c7ca41419ef7f71bd2eed88112bc744ae5fd0c784ae5056571cf2efff9067128fa8cf5e17174e25e27c00d3b1314af61209100eb7e8d8384f114e3e15fd89783c861b9085bdc09c170572b61c5098d0384c6668e9c5995189732b9f5976b130f5dc3aac583e7263b1a80799d1d9c7b9763a2c51ca7edd261689d00f9ec2bb7b56b8a3a032d14d16ebe9971da484d8865ce317467c85efcf88d87232ab6918ab1c9caa8bef31de9001ce994e629a11923f7d7a3e4900bbc797157683e9b883f31d7f1ecb5e99e3654e6f40f8426fa955c882bb9159efffb2ee119c90374589946835df54ffdc0f5299db58c162af4e56925297f74744625d29407884812a2c18608605b115cd599f9078ae47c3382e27f88ceaced2a2ffc7c1edb676fc7a3e791e281b3fcae627a5b10dd24bdb1b6b45b5bfc9c94dd1179804bba936ff537099715f50778e802eff61945a34ca1a0efca81327e5815a2ac5c357cb2856a7b8f047e68af28f281d5b2a099a6b24fd545c4b208abc469bef6bf52a8255f4e12d4527f4754691f62f1da2ad7c98534772724fb424e2071059ddeef533718097ba6d4648b648e84ab33e95b309152bdb155b2d4deb591ef8706f4e6b3ee6c8a385b6e9988f9349d7609e08e634417a0a65d30d354b036982128eb818493d79e0f2a45cb9cd681acef588ef7d95ba433d8621de7b4106bebb57a8ea42fe62f603ea8f2ab2537e743879c007045cff41c54cb404a2a96bd1f9d6d5c1ae951d5fc5f6feec11bdf6486ad04256450efb62fa0e2b20152575a8cef89b4fc96128e1203c8e041513a045b6041008fff2e7025fd85b4b9611cb39002cb5fddf294a228304f7c9e3dac195b30a4a3b74e79d03bb2e9bef34c277b1b3d2def3a810966502c24204eb4108c2dcaf1ab7c462b673b87edd00fa26cb91dec11f123bcd903d6e5b2c6aeac468894b9b1690802238f800a3d0a458a754b82e804d047282272f088803b3dd8f7aae56ad8604c3147a4fbd326f8f0bd5c1f7dce96e1624793558863f1ef41034ac022372906b2d05505a484d9dd15786a571f42d32e79231ab7c2f5d98c27c3bf26b5fc4bd4b73ab07757f4449a8135b6539d6f7d0b127f0b979e523ba67ca40e0341c732aeeb389cef128c4e0b72bd1bb93ede7c80ee8326e9e04daf91bec6d6333843c58d5441f5c47ad5bc3e2f3877b2c70ab32585b96360f6fd3be662c8f009906a543ae69e587ab950edea08f4a8d500490e7999d80310d21861b98e588d8c0a381e264e55b6f33565c18d01f39529ac92967d9657e78975326fc738835d5c84fc44c17ea9fa973f170c846e4f946ed9ca43ab1356d0c0afdad4ffd0677c8a2ee5740ec8a3e41ab62222ca4d42de96b2116f214668b3ff81e75d1b7f482b2ae0720a2a626b808802ab511b6cfea93e4b734ddc677042ab60864c8a4eb11f45d409471eaa102ea3bfa06cc3c8aa6a37be111d422b406522a0c157bf32ab792c3570820d00c37ae9bba12fe889973f1642e60cda363b7275a758591a53c838fe9a2c0cb97256e9fe84b5e6667e36d97530e32d7282ca08fcb01cd105debeec4ed548f30fbd10731c2de29bf17df5e142d874483424e6ae4c93437054ef182c5c11f5355fea3f90696e38c15686b03b0c56e82a22eeab0c4e31aeb246a14bded7546cb1ce9d8de54ff9c985f043604448df744c1844df76f0cf76b17d8a0149ce627ac628a36321bcbd9d821f04c030676afbbca5983ab6f84d9a892a2ed323d959ed1bfc9f3a6e24d022684522f67f36443c87e6f496ed9c7aac0376ceeda1dbcbbaa2d7a9871389fd643db194d269aac299dae3ec6ea9155f1bc6232ec8c16caeef952c5390f6386476a671f1b99f53bf8d4f8780381a653c71faa3163d5ce7904895c1a76c2cbf264d8b9f335c714e64e584e3e34192e5a77c6545fec025b6f8419cfb64b275a2405137333c6e76d2869ed0bab371eb03ee2e16fe8a23542a0e7138841253277effb58e0fb6a00c539e73dc243b30b61e6287cad501833ac01bd662d170578caf5e0fa12c1f5a6d73137d681334b9aa4a0162c9f154c46fb33cf02bcbbd554dfca1d9919d74cd1ad0d534d0ec3bc707be8d0d34e30d3c237c76457e28a57099af6823da4e2a60b9c5182b67a45639f3cfdf252514fd35f043cd74decfbe76ad0bf8eda00bdc59d8465671c5e3668c462c98cec2cbeae8f54538015372c216be21c144697337d7a0c8362b88bf350ba9b082b7dcb4a51b2b8c8dc319d5b630dd1c7db0859c0733c7da324cab28075b072695584edb0bd6e0a2650ad466c0e99f9121963bbf2a6ee92c52b34cde867ff7692f536ffbadbf74fd4b184f9dce1d5919761147d7964e2c0ecdb35ff611901292411e14806fe9ba67e0ce29cfdd32055ce8d96375894da4f74465789e8e0df1e731ecd47521c27f0b5de79cb1ffb7fed4fe5400b75039e84454383d7141f2e87bf64d60c895a97829d05b5b62be4e8784c9fc8279af4f884ed777e06190ac09cc05dc17365b0e90dd382af3836657af185f99f3eabf4e2c0e42bc3e89d1b2c9cf4a225feb41166ef1629bbdc90a4d63df9af8e56b945c94ef8602a235568877ce0a90c82b5f294d27825330dedc65a41277662e2f7ed85ec5b44a890a49809059031a3183bf31b403d801f679e3cef77071f62bc00adfd6ae5ea3b2d59220cc248364b0d15190b3b190c8e925887f5519591e8742d4d5b106e2b423d2dd09108ebc78106a9784f3691a055d0abbb798275db712c55be8c48b2a3e6afa74aa726d3a5fe3b75f583e15b4fb64a2a25f875b73bbab9b89da09616a362757f20df14e650e77e27bd6e9533a125910a5f6cf603f567f5430d0fb65b1be5afd3cdc4eca3e95701d774e04a45f53393cd1921ed6085f66bbebc939e739675afa8414b1ce321ddb89f79890f4d8dee9446d3ba39a70ff390713debf110fe166766ecc2e580ff80876b92bf3e697dd9c1330c78a8761503d3bc2ac7f108becf2c4afd32de880ec0a69a4ac84e98efea8705b1ebe627085fef824c07e3f11dbd4ad29a76fef45a49fa4da89d06437cc45b38d0d94a04a850dad36ea1a492725cb6bafba6569c82ec2e650f504be2dc0965da58d5ff90c60f0a732722b5cdb7f19cbbeee02bb775d7c1291ab40bc6407622994c6537902365ddccc61c5ebb293051d7deca29c11fdb4968ec7edfb53cf4b24ceba8c295c03077b2cfca1fc9c9035b3a2135e34fb4a2c99334f58bc6e6d8ab5391f7f04a083f84093df20ddfaec88a48c47b688aab7626b8813baa327e045d271ba5c27aafd278fee7c8be0cfff94f95fca1b038ecc6c318b3642ac8f3dc2f2fee0f967968af83b90e2d9884501843e34f5a6636e26e2bd19436fa1a9a2765751412247a6fffd4a9bd356e7d093e0cea27c7bcbb51ee2fe6e10247a275c3d0b4646b73134707e08d7d18864deff8c6ed05e4645b0cd2bf52799e743e0c75b0be37274c35c3ed3c97cee196e30622646e6c025150fc0acb21ce9ff01d0f0d1a80bc2a213484dfe853d56d4811ae36331e9dc051f841c8967eab64b4e6e128e9c3be52845e4abc8e22a7fe5f5038272f6a16d6de8704f8ab1619e84bb1c6743f70efe3428303a0dd484e4ae0fa9195a87c079eb423c9a20f86c166c4d2b2939cf4a58cace2dba41d94a859452be5c5ea2359fd8ffad0e12d077890f0f6d25015ee7bee41c0d9fd5df0411c8f65e07e5b24ddfacc87ccd6f40436991ad3ca435c9242b5c8b51dfaffa7a48ad41f8da677185626ab553d8d61024dc61bf0a29cb2fd185c16645b8d1ebb1bd135560895cc9950fc5e55601e9062041bbaba5b11e0fcf34b1ee99bd2f7b06c8ac5a0ef0ea91350601ccd468c58f9169b859536018b9a97ba7a5b374c4ac51e791808718480515864edcd0c65f3c98f4cef4fe473ffc97478b734b92f7ef53f5f6d8d7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
