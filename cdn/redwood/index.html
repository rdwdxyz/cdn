<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c953e886c06bf3e2d88f93a6f8a44aa98608390301dd6d0cb6432b57dbd21307a0ecb4d803b919424298127a8d025bd224975bc0b48bbad2b82462956ee57e67d165e7a619f1643e31bb68d2a4eb05caba3a72759dc83d09f17e654e592795e79efb5381ef75383c99b8c8edc591083b10ae99ebebcfd246a3fdec1eceb43a4a1d48bd62f6acb1f4d6af72a4699f1eca1fc7ee683773b46b44a5f99ce57091f206896d169067d755bf04c7233fd2dfedacf222f0e0033b615d1935b2b4966e521780882ad30b739a9b5db7c0562b6cc597549e7fb4e2e30b09f7accb07bd06c7fedbc1bc77a03d3985ff237fc00cd9dd64793a816ef75e3b11283c55edf02f4c1b184342006318c368b8e84d169a21236d22ae4b0daabad99f7e422a1a26d2ffb3d8dda66e5ecd89eaa7b1c62be5858ac443b8b25d527b8ce87d98bd61399251864c7fdf001bbd0470201603b26bd375128934531c9c6088797243703b6e009faaabf287605cce36716bd1eee62ae846bffb13efc47bb792fee0f4fb2b1bac767eb0fce47fe4b0a8573fa0d80737d6bc4aea800143e2b69c49c3a01f112c9df654d53ae204555c791e81810bb32e7870bf039c351b0782e04978bdb99b8d1427b9ca74606478ea9eebac549eb422e76d3b0bb13c27d511aa85bf0d0179fe5fa9d0763d2757e99afca68213bbba84a2b16b3b4e17b148179945042e764638a68fd623e403c23a4d87be2ea1cc39a296ef4d7cc3185f7c4b089e2f27a5291a441ee993bdcf5629b423b2301057287484f69276cd9fdd6c37972cc5f0f94c58fb36ae9c27ac299ff42ed6743ad2fce065f45af8c1c4bd7ac46eca2469178382806a1888c6be4ca758e660a5ef249a9c350732f7a4ca3a5ab293fb7ec676d6ed75cede4f3dc42fa374ba551e42fa806b59d31bc87ac9413d07da6937b0000184318f2d939492c122d900ab8609d1b5408a0b55d85fd5b2c6cf215973de5cb63282b496d36017131e4d4472f58974de5769bad79a83d89732eb4b24d747fe7b52d00f1c0db1ac352b9905a5386923ad6430c9e0ca152c94b463a1db55eac3296a642f6a53dab317f95e2a44ab5859f0141ef31f320900eb40b441a6b2e9afeb29b327d1c8cfa36837692b6008768a32c5edb846048007bfbcd16964b7d0f1876b69867de02c82d34d80356ef990601f2b565734d712d2cd59a9188664c62ea22adfd0b6e5e1a7a731d4861fb96c4c2961ccebfc755c1d1d7b7370b51821cac913a86dd5a24a0b5d0b869a5817d89818362f31e33a93211690a1658a0a0315952112db047db140f01fc81a5703fba4fdb19ca82bad746b292bcd8a1ff3e34bbb4375025fc60631ee57ee8cd01410bb37c2d56e61e545b4ddf5c108ec9c3b500d77954035755dc497a513188c673c4c71e99dcb853093552cfa45b0631e1153e865c2bd24d23fcb8e7a553c3c7d7d6729c9100f76f05350fc1f49f77d7b7184fecab3c881239ee58f95856a07c6337d791d345c03863c10ae1ad438e0ee34b5fe63c91b58d483a201c5d3b59c006341fe1205a59e50f125fd31f812f33895e4063ec64e7678d7176fb807de71ddc21efce7bf36c44521f268c3aee628ccdf3e50a98cb9844b742455318e178aeeb30b23945b4a903be32d1e9e70fe6c0b3642b1b20cffbf302919d3bfe1fda781b72c030b672b14e7610bdc6719daa8b24108bb1e56205c8cf5e08fd6cb801d825f4369922afe40028bae668ce37a5cba88905ec99d527c45589789105253f5faa96846a97c062a464703b0b03c6d1b0b279af702dbc1fc7a5ab4de7927f45b61865cf8025b1584e5f4e1699154e708693b1c9c32b2d4cd1c210bc2f4a4196e94cf259c8579e0f45d83ba6089c9ee256312937091c41927a8600656cf57da65e6a96da32e6a940d5d8c5c41efb3e7720b5364ad8d7582dc875a8269ef8a540a0a8ba50348f000897f8f960db78107b4434a138a6059a50ad3ffde8018dbcc846b3fa4436701e8cb07b43626518f8c97fb87086d2996ae2dc55b7d4b19bfe17691972ff44e702e10cb4b5e90b94bc6a2309533b8de43f10503428df3b8a8d1fee85417a22318eb91d3675202bee3fb843ef7f0a3db4d040e620ffe11301bb8dabb92332bffb1fd4a8036837d8208c5c5e6676132d164d2beffd6b05a8c20863be7fdeb01f32a823df873a1ce47240ca13642b91573e600bf263aa9cf0ed425216ae038826fc97796e879196dac7ce28df8c6dda0135e8c0800f9590dc6b0f9a41ffed206e2065ef2af0ee66153db51c8c4c50840c272e0551ca0adb0b2f8188c7829b6ef3be84806aa57fc2d409c58dab9d1fc800c26f0d1735187c19496798c116eec77211290dc7a0470d769827130a8875bba4421ecb2c4f4c8d1b09d4dc26dc2e7a5eed584eb6482fa264e60d2a07c6e445dee231464676e6624695246e60abc4516c9086168784c02d6bba05366a0dfff13c67cd03b7801729d9d0524ba718cce9cdcc28f85ccf4dce3a74c65d8010e47ce08f9aa0e616a3e146714ed44d7537f653bc43a79e90dc599bfc77e1cda6c2b8b71695b6d3beb967c676d5c9273bd3e2843adc5a4eb07e0d40770042885d9d0a1c946394509fcd9208aed0b76b2f27d67e036b3c0cb832593bcacc09418f554500276a56649250d84f555bb2a964cd427cba196d942556a97decd0298cd793f9e3395e81593319e8eea1ba789d7833c2cb2128a3b821fb6bc6e8fea81d3384ee815d73ccd99bc7bb82f8d0cb16ecd27b8c78018f1f00e90d76bac7ccd813318d74e36071fe4fc28954c387982294cc743b342c5dd10653a10c797bf4e8825a3c499042b9d9d2107d15da4e54cb7e1f73bf6d25fad1c5235650abae8c8cb8ddf3a87b26cf5b9856830bd8c690a153f834d1e95f70e4c64beb93d3120288dbfb7def018f65ea50bc26c3b8a3bf3864394e09f2687948bc076f4539dedc545da85b23d43ab55474e48997119dde9c2437537c9af95280c4850d60b345c56686519d554015a17f83998958f352846520f9a72a15eafd6f8238efe35c4cb97c19203632b66154c639629ec98a0c4e796adf38ef19e9e0ef4da3bb6fa0fbfe130dcc01ab97f716602060e4c8398a8bee528859de18c2bdabaa074865e9a8220b6e24a61c010809414c6ddd7a897ec25e6e8d07907f853833ef9acd4e72dac0c7858bb2691e1d87e0d1206dcd71baac45c113e3294f773bbae475f02f6f4a97be0cb1d801b74481eabed51dc11fdd63d654c48293c5317d0e897887ee6a7acc79ebbd0daac46d4bff85b09dab39e7bce3b032d6e5157463f88a789313b0e5b94975ef19ad5bf4ebd7f2990984f47a42208cac331f8640ea1024c0ddaaf598811b9e59ed63b3df1079d659e085be7124b36c3c03ed3dd388f29970c0c55850d010adccaa12ea6c9dff5667b6a09dde7495e42e98cc39e2c38940d9c8bf83c8757a9157e20b3f4de728be4374c4061f9f44469ba866681d0839db8e1ece62a8f6a8a3ada373942c9fbed383bf71d4930e0ae0c66eb8e7759f237b1f0f065f9e21ee188fdd6e9863cd93764852c18ccedce3faff65cd904c5c1d8795b09a6f67d5b3bf997c13c3d85ef24cd4f2bf99938f73cfea5bdb512e3e50200b61bc44d0af7cd8645a1811436cd00eb1814d745fec091b7244539729e0707cad117d0e83a4a897ca1b81771b81b58a3738e3e5b28f5d5809ffb62319e98ebcc2009a77407ed8e697dfed51cb94bcc87aadf1e0f7eedc2eb325e75f4f54a4899cfbb72f99f145165b6d62dac17042c81d189e484cde2ad94feddb123349a3a20b1da8ab0b16008c41edf09601bf28c4b13561b2f92c8a94a37869b563f0c88c728106dd51f5e49d31cbfd86e74afc5bc408cfcfa66cf5d656849e4be5d2c3765624aa248bb7b67cff98ef798f75cfb0a10fbc6ba36c425ea4aa0c95d9716bb937d8873c01fa67c85c6c3285729a6c07a2adeaf6665255fc161ef0d6ed4a1ee4bc698249cbf83730062ca3013b06d0ba46953f9766d65d2b7f81756a93db5e844f764b47f7fc4a00f420de7e7e8a4292c64cfe9bd5e2f9f850f1fc63196300ac8b21dc6aa6f9648e38e4e98fc6f49ec1dcbee66615bc8a6b1c90951351040c29e498528ae31bc31f959fcdea17449aef0e813b59c2250e2bc28c0e221066fee1cece9567f6d56c9e1a7388ee7a05e2e0912a09677efc89f843999b33efd8caebb61503e7a31593f98b447e12427d7c14642a1c3eaf537236bea4934f26ec560bba95db0fa4d695fbd25cb9be28024c881baa97e79bf994e7cbbdf33744b22fcea46a9326117f1b568646ac28000ce0e8ffdee63b0d15f9f527579e5cb8dcb8f5bdc7fc45401fed56b52ed041d62a023562b05b6263e5944b1ead929691968b25367d15117a29d7a5b66c44b1e831bcde39ffe5e36ebdd881321cb27dbfece047c488608643fc2f83055eb2b87bfe3f457d167864acb034ddbfc29b50a1c808d2705feb2beb19631caa12e4ad62c2db97b2c132c76500ba76e44dc21ca357b3c1c95122cc0e8ca30efb2ca29ed975bf80b8204c463915ea57c165e46d9db566635e3f113cd8da925449aa4c87b59f3b3f4be01cbe04f2ff0560e383c56aa9d30dc269a096b5cd02736f7bc00e10d73bb446b775a0a7471a1533e3cd67a8db1e99043b5fb8df3c86c57008d2713eef2ed8cda7882278118137ec7d2005ee7888ae17b0fd66b0d1662432546ef1d0861eea4c8fda1a000495d18e21bcc35d34dd2db9d56720767dfad018c5ffffabed226d44a58322560b90d1c05cb18018cb851e01d3e765a76f6d9a978c708da84b24ae1675b249d6e2fea8b4ff15cd50505f4b2ceb2b12bf4746b07c7f6b931d9237b37aab9d73cb67d91297846cb51d794ae182f2a9bfcf23cc329e225467f20dd02c9d87e96c66afdb96dad712443b5375ace515f55592644293d3b465849d0f9fca9eacf80c4b3c228569b7235a3a9006f67cf2077ebdf1b1dabb5ade74ce9349406126ed25243fbd9ad8196fee3ed37a86fc2867d9c88108ecca19b83596b298d981b8f7df850c35b072cba663c33e9571df081ecf1de27488d9d175a910bc6386fd28bee450993fb9fc01fe8e9e62f3c8adebd75ff62fb4f5d35179c63d33cf5c3c05e63e1e90627828da7dc5284985bddccdedc4ae85a0dbd0a40d822397e492a08a6a80635ca330b00e5dc607892677ea11131676e1d0631658489e883c25f34a7e2dfa3750777843b1f9d1677cdb0db88918c055751fae71a57187e0e830d7a5f7339894ae319178b64d235ac8a7b43820346604c1553c8e506aabbdff975e8e48d005a0f68ac3012c159d707b1076a8b0ee2d6b3ec5aa18afd5f9bad58c73af01ae65fab2779d5a8bbf770412eb24620c3bcc6fd0fc0aabf8c2c15fa9cb57e312e3ce6c694bb971b3231f602922b1a6ef86b2cdacf4bcf20045b9515cd436ba19dcc51b56d2f3ef2104251910b2b9c8ec9d36a1f5777c7cceab759af5837a8a1eb6e4d0c11de2fe4a7345adb37f1c4f6b7a527eb3914b79355036b08ea6fc56adb1c83ab9ae4478a4019ae3c1ff4f2d85eaeb667ed418da6a7479f81d9f631a4cda49fbd4a790d4cafc777539267c62ef36405da4e5c449dff99a51b28e22395e94340404f997f69c5e9c0053bec30eaa18da8bf109a0170dd27e2f13356d1d6301f6c14225672b8f547984df5cc135eca0874835eb43fac4cbb13ddeda045b20368b11dc614b1c5777fdbcbd977abf0d4dad79ea1b5aa0f1fa8dee9ab6561a64adc80f5a00d831559d7ea281e90a9f9e8dc2b256980b20a7f9f83ea3dad02920dd7d2a9661313be5bc1386f651c2d7e4e72dd3c3ff7f6363c30ad742fb5483e59206ab1bb9b6183eba70941fe0dd72cd9560bbda1935378b92539ef11ff0bde9e9108500ffa2c39c9d595183e3e2727a81db111fd71cfe568f7f7bd3af5a160baf38245e51a99d2c75502b5ac85fdf8f049f3edc6991f4998d343886c7eda94a9f66505209e5f97f42c8912e7dfbb02cb479b300af14d2042ab3ca45e22c246b6ffbb5d426bf92ea43f7b0da4c4e8ad83f3cba08fd4663a7c7f789cca2056f922bc34a96906fdec5ddd6645f2a3ea46b44a3d5f7a1d11c509fb0437a59dec9e1e4b59e58f2b5d3123005207281357a55158769ad0e13e1240c8f27fdcc5085c3794dfca46f0c4714090d64302316aa84e12d647794edc9e95c242edc454c1d8ccc18d2caa393ce7fd31508b11d77c56f6b788b664caab379c33c783ed603b4d5b81a264b2319e7fcdd03c54996941b5ccb0f77d0c1999afb9c564fa55670b909a9eb0c41812d22d7b76fb720018510afb704f54f4a82d74e622fdf89271c1b26512668106c3d625133ef0d82b816cece77fc47f2cd4af9d3d4905a5593a522f356f7f3840cbf49205fda28c96b56b1700a6a757cfb465d520b89678419e8e334302df35cfaa871fc25e0171ec24b9f45483ebfe8ce68061319488c4449ce28d1bbd437a8e5327bfa35790a8f64ff6c9611a71aba2b687faba8e1bea132db72bc85003ecf74018565409ea719c6608f832d3e9b4305219a7d9fe2f8a13ce4e96ad5ff058cb23548223a66151cfa9547c924348c510c98abd312ec7542ee35fc8ece6f42b13e85a989edb49669025bcede3ce38485be2a934d3ccd1b8665234af2250101cc8e6d7024780afb50f0a560af90cd87ea40cb0e01e124e79495ff1522715d5af148aa80011975bb8a65eb840f206d3e14dba49f3cb8047278e36b2540cde480ad6a871b16a8cabe7f726bc0a12d2eda0f66e6006422f68afc31a25e35e7f5339e3b947c339ab30627502fada1dcf0308b99265ca0394bc335e711160b46757c024da9ff015798f29f0cf5598d60eb815c94abe6706f28369e987a0b9696fda28fafa8499d87f5f6f601d5e6019ffe0c48aed6c04b904e28971716c46d64d8d68d91ffbe103c02edc7a2cc8b65363677fe6d6784d7c8d75f9ac610eff31a7c27b6d5b77232a5fb0e165bd6c9736f552e5611bc9562256aacd23121fc7786b5d94e88ff767461396fbf3f31e23cfd59cfd1ca9b0ea1b24ec767610e6cfa6aa6be661cdd2e446d8079f53d9f6ef60f824d8f1ecbfe166179853a9c2fb8ad03735fd10229aaf1e5b9920a8134bac66ff0df6cdd15e58f93fd6785bd8bcd0e36767c5ecc56c8cd66f3bf2cb54fd8a95daf2f7b321f5209cfb877da2db59266eb38aa071df505ce8beed322b78f57017dc51a8462794372e845d2f1fbfa67abd128a212e04156bf5b7b366cff9e4f99dfa00453cc123706f2b96c84052a4d4a142be29340b9cd25b01a81b4669d25b6ce3303d7990ef6f51950c5743df7f0a99573b6d46afc302281771d51ffbbf909b4367710bd7f18c05bc60de54f7fbf7053c20ec619cbc72d0928c3099c9405fb358ef24bd4da015f1f2ec76233083a6b3725a244a22cce4594d6c659e234906013eae91559cd9855f2ef1a0bee059118100433e007eac6fc97d827c2fb6139efcad7bf12fd1f603ae0a0dfa87dbe5884c1b4245cc887136723c5275c0f0fa14193fbc51f4e5ac6809a9db0cefc20a6f7ffdba9e57b46fe949bcfe0caf42faddb33084a6771c9771f6f38aa3a9da3fbce5925b065e095a43548743a2f09447967050c39a5516368618bbe5d4955e70ec87c86d4e2ae7dcd1a611f68d6ad7dcf83b18b00a7a103e1251ebf71cf9105289c19fe9622d292b77cf1a3d937ea4856432617c33ba331850d05507e24cfa023626dfc7a86d45256198435a14d9ce905398e3ab03219cac40e2281368b3116f2da128d162d6f6e76fd5f8f05b1bff512f28e4eb786dd2e4fba9a73ae6c22c60961ba9be978813897c91028399f4f38230c2c7ddfe3a85268b852bf0af363545b5162b8850a35ea3d430f8e851418a592ddaa56a7f1b5e8a8d3f681b911c66e315af0645cd13ccb252b0fb313fb09e7dc0a26a03f233b950e831da87c99a71f4a20dfbea014a679abc5fd5af8b8b7a0882c0a623adfcce0bd4f1747b4da524c700e1df91d4b97c0811e2ad1191484533fca79b9b7ca0458a7b1071ef684de71963cde8ab8ea3651750749482f507771d26e1319c62584f6fc432588986312807548d1fdcd4e3ec5ce2bab867d417e832d5f23df8357544c1a40a3af81c3790509852c17a98af9eb2f8048892df0bb9d367a4ebe311dd41cb572b89967e8b51534d3707f08846fbdbb80c407f5e3accff01216b2dc26ff92969a7bbd4f68e44414443f29b3fb9149992392dab4d94201721b1fe7c61d798089966346ff12dcbd1565fff6aba89e6bd35587071d3f63d046db7177242f14ecc737730a89eeb313a8f9e352fce7719756e0a781c6369c701a4f980c88870bd9fbafcc298e50c4362fda3136b356cf682fd467854d4d5e5809066c9c32f49b3d66b1142839ff6e7ff8f8dce37bf2674170242b84db47f050d166fd7214d7b2fbd5b7ee54fe4b82c9513da0e921f8d9c4f9d9ee91395e7b1085effa4910eb71d9ad416a75318bd6a33c18d8dad8cbe901344eda0f6e12cb34e10423bf392ef815980549e256a86e6d097d880a597bfcea9d8b53c201ba12e39c4c3a7c43a14284805b32eb7cdf7e6199907aa74e1720d5f604c6af89745934933b40a44b8df8ea132f448fd43605947e5740ef3d40420ecfa1795a67f2f1eea2f248adfb7a164ba8759a418d596a3a42a321429cf514df9bc9e1d04d4ca22fa19fbfbba2784ab8d59553a1df84a21caa0c466162bcce1030824fa452df79f54c3ceeb039aff17df2e348c0227fd77bea091387db82914d955bcfc1f43369ed0a02d720e3e99e40cce4613961f2939fbabdd31490f78f7f3d7d2bd81090ad5383d3ee54e9df63af049c38ff5baa6c6441b593cb3451f1836f09e89a19e74e7b7124cfa6cad4072d72b474352a68217f4f31db0fa5c7be4eeefdb4c555d37c353b8dad15d864ffa14776229c14d8e145bf76bd16521380d307c856763ea799c74092d1471f6ad5c5d30cbc504f740843de58b46dee596f181cf4ef004329af189c993738eb693cb8470da36d15229cda40047734a678e8139dfcac9ad5ab1825bf2c15df7480314e15c7cdb7e044f3aacaf27cf1159665b8e347e37f88b1f01268ff0de2f174d48fe7ecf4708a5c4c1e7174bf87c0352171379ab47e30e07d8c95c4ee914a8673f79a6fc656e5c6376adbb82fd64f05feb5040b6c04338287e7c712a2160f49ff5c0f7f20c6cc01bb4a0f440be0e8aed0766b2c06fb4d0985428bb173eada46b00803447c365ec918c5f50d047f8c8b5989f80fc972de8df278f94917a5e74f0c510fe4b149efb5468c1381f52cb9178c7da25e2a7657a7c2a1106eb9c71fcfc6427f99d2d43a52716888b15b378a842a03fe45ff546dd4afe0ef9aaed2b6d2a64c2d3485313c9dd5351b69b4e400c235ba5aaa0b2cd5c279c76ba8fda39972d1e0d4a1d84ebfffa28a8bd3a9c5a0567a38d7c5292f7776fff5de7c1ff3faea9a0c8f778ed45be9a70f1c8f8e1515b35d8ec23b570b62308c9edecb3deb50633692e731226a8c84fcef984d7f9bec966e050cd62b0b969be094b911cb9c84c40da56afc8f9cce684bd3c3935be6dfbf8ad703b70196312c7500abd4a0ecfb30d95dcca3ad59ad8d21856163d5e2140a2486d70a2dc1ae864c349602a2455853e0522559cdec7ae27a2edf94912d4ba77f35e66f1e6c91eabfb502912e80d73b0574d37279b8bfea6625e9c27d8205d49638588cd72d2c89b06e196ce7b6e89053c43754236ef1991df7be4fb4af46fc1a1fd0543ff271b7696e932f69eda2d8af216837d22b272519f9c8b76a8001b69480af27af12b5b81b850b570da06503e1d1209c0b2c64f218c55f2e3fe7f77bf98e2abc818e7e4233d6e94d698a6472a1eabb67039f018ac22a6fb36ca3f87b6b890d4854d2b6baafc26f13c8ae5e39e92d12a0e10c96d0d00841ac4e84d0756768c142a8369faef26afded7842694e3cc9f842bd71af8b64f35f0490c842acd10111a5c164b0050c5eb8cb4035d72b5f9a28cc04db3f6d2f27caebd498065aa0e9260b9dd81af6258afcb159ea27051e6b6a4bc46d88227539b72d455ced0df398442922acea51c59897ace38cc080ac59e95c13063b1ccad85e15c63583aac7dff8ae5782bbd337b9cc102d589b4a70323ffd1c133ff039250fb49afcc03f122d7390f91a55a063549719a5eb2525a452d8ff7c6bee424801ccbd6a0c45e184d8047c9d275f69aeb327a853979253ee76900afea9271a94cecf7729b90a256e937066426d11c4e35629be62fc986b3daed1d36bfa184d9151fbe50274d8093863919bc09a93a2742d6b4c880547e648d4a4899a1e2d2153e81779341a3a5c51f89c39cc0089f6492b89c522f4b9f75113e12612e4513a323405a6ac52d375b7dbeeceb6ec5f91e8e6b01e0ba43751a9826c27f0a9275b846e1d7e8acabfa8020d679390f5d059e3f11d6edaae8837a3549d4b39a57909412738beb1b7d6df032deaddd8a0df50fdf3232c3d132665f202e6be8b2434322a1f4c8b579ba6d7e580dc87bf0dd46850a0becbc6f20db57936dfb4d5dbef478d4fd4429ad384219361c6509049d5e612a5a155a3f1fb8b262a5641efe9f65af9f4b4900729c3c42ba305a538a3746e3669258338db0c8bcb57dde023c3bdb745338bdbf770451ba39e4cd8bad2e828317ec7512ce4db39ec8d94a1ad545049ad029c78a1f51f64d13f45b5c4c942b80d58f209aa471ea42b16e134a3aab42d70c67b59f96c4c92039a634047dbc73d147796c4125e9fed452a7bd29bc2a72560317731f43078dd929b15a00d869cc78715f5ff3f07009e728eafbbef706f6019c18ea54722e21f83ff7bf5c1c35a811c010ee0e3fa8046132e1c61426c313c9c1f956371ada2729df8bc3a42b658f569ab14e07a0598d0d9d1987383619a0c06d70d1270d0d8403a33929d9e4d3a4b2fe3299475640eb093839792f72d26f986e99b84a0f32f7eefdf64b1e20cefa2d2c533e0f8be516cc167f5c35bea6873c6eaece1f26afd6eb05a5a4ac8b9b1b747b4fd8485675843b1e6865af11d5a845effca644f35c3c34b72e6f2f56d9a865a97a5383dfe9babcdd0b487535197c11c211d7c4fa2fb8b7b45aa1538ce196308e1aff961167081ce74627143cdfa1f5fceacc7c89ab349fa393276abb870fa5f32f44e9b68e26c4d8c7dabe7a4fc21af8bee4d31734afed146dbbc26aa7d587da74338ffac62f3200293192cc84e6185b520c5967ebc9d42028200214b1887e764a6e30aa6d7f0258c0df6e26929ed3ed8e7091ebc40b0075211e43968412be245df7f37d31237b24de9cda66d96066597313042fbbc4b3516895e1f596606aca57bc8e56c20b56fcdad9bc741f251f46ba30661f90b1d511ca7cfc9dd8de7639e11cd0c20c34c3a8804c9a365825e24603f04dc9c3197213ec3aa9d2a978234859663d76616faa95042b6bafbd50d51f3ca7d6cba1b7810cc4bf082fc00f37f1a5fc48748a9028942b18c4b8ce5b94f063095d5518a2a7baa8fb9ad7f1d4eef32eda689764a1f1876823b7d9a2861fa05ee2ef5429272fa085db36b2237811d6e459c501357f7f5a6aa320e78d0368f12518a6d915847771bb5a96145f383e72d02d4c2f11eda75584135b2968803eda824b85e7faf65dea6241700d04ea8f382200e1e51ac469a303b32dacdfd953361e77fdca434094ce040c959d2bd511fcf548348716fe9e192b03a379cf7383337f28e3bc924996a3d34051dfc742c0ce63f65d1737a7385e1f2c25b3342bd27c03e27aaccc479e6a36f8195b056702ba5010fe551a4c04c76d07e3ff85cfdf7fb51023d879080b27437ae827b20b099eac10a522a8e47b038a1610895d42e59a3ac87103095735a1cbb72ef3c9c3dc0d70bb1354d4285917ad52ea4701a8ae31deb4fdb5c0d7e424680e6b90f729b5375d273b73e725147901d25ae755ee2e13d2b53d66f4565f255b1c357cefb535a6d170ad40d27b3acd945b83a15fddadb293f6fa553539bf1a7d00faae34c4477a343b58e7267a399fb464d6553807bd581208b130bcf06aa543c6c7844b25ee27d57e2afa559ae611fb66d53670536ca83289900a2fd80811a5a9bc5b6c8e32041db761a4dfd0a743d72147f6590ec2f46ff0b803bf0a7d43d96489fc509a2b53ea87599a7cf8f3a4b44c4bb6588e7071d7728d6f4a6994290845d18863bd592cb555392481783a1ac24fd6d5e52402521486703635de92949cfa915d973c78cde38225859efb9c37cf2fa978e73723fd4bd88bd735c795e3903416f1fc4961f4f3ee9d9ec172ce9ebb0b5af651eb70c756f334786168cf8a51f503cb6018e1f9035dfd482981638bb7360aa75f0d24142775c7885cc0a5b7673e610b96b12d3b444b531772d12ac7d35291fcf44e024042aa4f50668bd1f1ec68254750040bbb4958a961e76ea5cf880bdc8e1e0f2302896e5a3bed0855b11b05e70763cbe069428cff9ccdb7d2a91fa4e0fca85daa2229a420f2c74d5fa89b2029f6a69fc21a36c3070a3d38eea6992761caab1bdf374a5fdd12102e0cf842812c04355d3f7ac597d3d4166914b2f905cf7b7230be61fd418df601e83894543671431037253092bce2a54c0957268aa4b9f0443ce34b16c8a24cfeb2f1192d7a7f0fd05cf770f6ac12b3166df692cace986146abc92984181efdc13669446ff8a84bc1177db4d8f8ef44767a9677097f77101a7e37e7430ff0f967589cee36dd52653435ab1242f166e363a749bbc9849ddaf4a81825c3cc8e95afa1e8b7d5d0ef6e92b128607b3eb4e2ca548758c3dc2cae7cc614d8bfbf06e808b3942782092b5dca55410fcca0474898e9bc134f502af3dcbbc2795c54c2489c8ddf2e43192949656a62091389021dc52fafd95f87c64fa475cdaa7fb111cec5a5c2ad2fd1f8b1c8b61d89845cba2c40dc7236a1a89a893d31bb10660e5490daeaf521778eb895a1a953301c2817ce67e04f79b09d72c053aa81fb92b561ae891c1306fe10c8b0b2582f062882f3efc082d44cb5b5d303384a124527e86a2323c013146645e598f073c4990d9fceea0f22334edee0dba5fe3c85adbbee6513b8ccb0666769715fa87e85288c348735b434c18cbd866b4e0feb47eb1b3655224846f5beeaf02616d4a226088ab2f057bbd7450e476da8e40fe344b44dc9f808b03ed3b1782e82212ef8c607ac000205b9e410628d1f96b01ef6168f2ae374ccc250ff8a4a7b58f83be86ddd83a41e0707ec759e39b625bab7dd2cef9527391c10919b6469ad7a7c7f3e5787fb6f9e01003e6bc1c5f0bc1c22c62237899cb9c313c9966cb4b16475ee06a973a789329700988b1dd89dd1028d9af5380c84313cf162ed45e69776c6645d7fbd45f6641575d6552d9834a02997e040341e6d519b44bcab8bf4fed36eee59ef0a0d39c5acb41d5be6d7628a8059a60f364824e0ce09a06c87dfcfcb0a15bb441abd1a84105da939d593220083ea00723fc129e22d633a2f5c42772f0d0304a8aacb37f7d3644791f49d6d77b1716770962554941b131a38ed4f5b7678194fde8b1d2eb8f34a7757e9f77a2ba2e457849f74e21f86db11d3e04eb8931995911b561004dbd598207e77df02f84b0d030de0d0496c62b4936edd4aeb0a02628c5066267cfdd5b6ccf5ed625230431a378aa07ae038162b09e452726319fe5ce9a02fa06a47a38e1b9d24fe4d3db207cb86ea4ce61f98cf6aecb39b567ca31ccd67cec8fc67d1d3e06f1233d80cb2a71ad1a670f024b228c2d83cf6365d0bad3df32211ed7c0ab2c535fb9ffdead2992fdf442b3c5d56479d5612cd188b98d0ac7de178753792d87d8ab3ae16592adc472ab9240fc1ddfb52afbaebe203f9e70e0559786adf72cea8833fe2a1b090939cd7bf5a2f4a3fd31dce813e0acbdcde04ed9ed99b6b02039f478682fdf076769ab911e010a4c8375f7380ea3cc8ade96caaf291896617acdde81670b53bc8f28bdfcb37d2bfae7dcd08a3e5cf760b5200062720fa79ec310b6e88a5eaa14349b9edd0590c9612b0fd73a96e9bc881f290e1634b36a351074ba43921abc905c94ab53f9416bc27514fe917973364fca5b268da5244dbbd89199dd93627522463776277f13a747bd9b7b3bf54b69064abc51268b9e35ebb003582feb6d32a36d4a73a588cd6f355063d16dfed8c8a32fca35b42b299a3a5abf60aa1439bd002017aba0fde68ea52bacba91aa6989143817cbbd3e67ef3613cad57594984f4174ce7aeef175466f3ab3307b077fcd648a1ec2c18574033df45312862f407aeeec4a5af8081bde4fb83711b2cc8f19bf879038b01bcc589d17600e0144c31e1af4d4526463e76087fd7e05541e20ec4cbb5d3495798cdd5d6c95a5ebcb8368f9e1fd8b522d02bd59e86beb1e67baa9054123040f5b7211f6ab3c95fbd36ffac6f723b4a158ed963811f83f3df0cbfa467d3cd669efce2828233a60bbf2c260c78009e3c12191b1d66ec991fa8584cb6317f30700f3b069901ae9196197293a6821ce9fe8f6e4a2e5607c9ea8d244abb5c5367f555489949a7ef7e48caa1b3bee1da9fa0f8eacbeec6bc50e81a9b2d42486e792812b9eb12fee97a9a99aa3553fb3c94bcc589ae65eedeaef26704b7b337801537010effc0e2aa6e637d4ab547ac164d935c0a40a9b7d0c39ed12279264cc4bee338b9de74653c3f641b9cf6b9e2384099ce86b5afc90d61045df51cf09049a45e0e8337e68078635b931a708727b946153e921f1fa98c347ad6171e684abe8860776f0eb2cf9d616d34a61f1d55610bb29da046b06e86f5b16bdcf1460481d3b8a135928075c9542e315549ad63b6795622af97fbdef5f8296cb7405513d002c3e4d6a663360cc82882f03ecf7bf5418d1612e92f130b105f4a14b715f08ccbc21f1688dc0d33d52f296ebc308f4e4b942514b8b58d8944cde737d3009c9f8f0cb8b5faf5baa7a19a0c8fadbeed5cbdbf5115736d26d3511b6780c7670440c47a7a6048330b4252e665180d1f95f9849cb38a24fc18dbecded2b6c2ce0700cf570240142d2cbd31b8a6df3df69293d650e4a04a56b1d5f5f78f629a961ed110eb17e6a9480517f36c4f1c1fdd8e0b643f752eb0e4735ac646bc9540e6699aba6fa0f6a0952153d1616c00c5e91dd3a24ca6b96b445c45ad686c12f8e14f3ffccbd5a70f7aa30a1b4b656ae382f226b48466efd4ef87f807a418748d147e9e0f95cd5cb8e46677fc7e53bd347513d2dc4321164b312d20a37bd02c53834d06777ce9aeeeb8a5be7a30d055e1655f326ac038ea83af23a89e09bbff1880672679301dfea60a403bf4fe7f6629c316a022daaaffc0a84d85555ee4d6f24d114fc88e3c2283eccf7c96febd87d75adf5a806010799c994b4fa7376de0a665684929ce82ccc0db5c11e6f84df8e3ec40d5041eb7c4163facae65497ee310d077b429dacc6805f96fd4a14cb06f96c48c27f09a5d1d8054e682df1c495705ff339715485d97880149da0d08eaabb007dd6c3b3d77570e17ce7f6378ee650787c582e445835e900207ae7bfb0286c47eb41b39f29369729f4663a5a7632edd8ad15a45374f13c1149408ceedbea836c4c399d0aead1d0e85fadc6a02f2478168dcd9cd45824f50f79490ff3210290444c81ab16b7642252e5315e9f7f02a9cf53910f30afea0ebf2759865af4f2d717c10e7ec1426cc59ccfc4d553d9bff8d4347ad7624b446a2c57ef3a7e08dc645bfd09459c76aa540f9a2109d297ea3116812b64f5f157cc1d7d9837c7d65908299179638db5991a97bb61daf777733741e9252c802db1543a7bcde74f45e1e87abf3f42c42e875b1d2b7f8743d033c53af8daa039ca8f752d5fc1b048098354c7f83f36d5d67d2a3e8f073ac47352c119e2d395b8ae48bad98dec4d03b9b5ff1df1f955fba5fb3bd8347c9e565e1605101ff5f73347a1b02628c09e137be5eb7c971f29841f7dabece5de17a1da1cb3180739143037e871cc19512251cffeb87d20783266656032a9f5b45004aa3eb41e4a05854d80f8f3900f80393db16801c36c83f6e1f867e112b5da9a2dc882850c82db4274adefabd0559975c7d3b406896b28ab8855c34cca1348385bebc1396bed900249e7c4e6f160feb7b7aba1abf0ef5683e9ce342b4f2a37410541495a97fec11d450fd584cddac8edb44e8ab0f931e4c13c45ce1e0575e27d5e7b14a49850a6a67df435ecaf1581c4074e90c1c52d40b7514b2082ddcbc7bce615ccd3cadbc134ff6ad4c5f0dafca7fcf6341c59ab79e027c720e4188c0a6a4771cb381143eb47ca9d94c4281ed1c14bef2b3fca218eb18526b7463f23748a16780a1b7d0e46118c2fff99b317a0757439d95ab5a54a06e3edf4ad8f960516090f8a663e27019252b2104a228079d3ec4508fba6ece32b2eba01087cf2152ad614cb6cc991c63a67d2c4d3395068bd355d9e487c7be09803d0e3bca8016bfa79c86c7e330441ba4267b1d8cffc7c4fe9d43cd43f9cb41dbabf0f77c62cd5045a170863cad8e783e0a29485e947ac1cedc54e6dba8524238edc2b2a6b50119f83694d3418ae7afba5f417b3ebc02e7be0e129f560090932746cf05eb1cda3cd68c8de079e31e64d6c22f80b4474375b92a933f7e4ac271aebdaee5ab74a049a29f770e519a4f8436510ca7e44ead36ca766fbbea2ab46c1b0abb18e88bb227aeb36bac5612f0b85dfa88f46cbf87ddc7e1a8c795e4a5753a9169bce9d861a5c5c2e867f501dc71933c5ce72e7d6f98380ea483039664c3bae72f87db5818d88f6e7c7ef4cb135325832d83b8f2118cbcd3796b7b4d36f346ab5aa8b19e4e8916580702693b338e463b4dd9e099359ca6e5b7b7f6a1e7adaa7eae26c335853cb868027393b21ee5cea7c90b7f8889aef247a1be2d5c07be3144f560b7b735c0c41bd655876996ae4ce91ce139598a6618d17fd84581c00f1f7ddad0d1fa806220f95677b98f731d8946132b6088950fd4e32fd2e2a573d3b493534afb2c6417985e7529c7c3f70a113c91cb04a77d1ccd43a18b4ca56a908a05af527ac018d6e30c6d58e3b321b2aaa7e7a7f4ef4059ee6d74289e01ca21ade5d4f8b5deaed28ad28659514cf7a48026d93293d8b2f109d813abec9740796ce77dc46416fafd8beb6181dd43d5b2bcf7930a976b21bf6b9ebc6c5a94e1fce327fd5f84a5f9d390ef1c174755fb0c6d06443622c99a325a15ccb9c3d0ef06744d4404ee04f45b9958a833fd561fb4c22fcddf8c4c4704a2bd0bc5c6b98309486d4f088fb4f913c5f7ec42ec92b9e5a5200828d08c878966903bc0da20f89c1a7aa7868f47641f1a1ee9ac4f53c76e67d9674dc4b2e314b37380776de8cba130b8588ba5711ffe6d468578e64e0a44efd6a3febd4cb7b0260bebc373395e182575910edbc56f30fbfca57b91b58dbc8c5afb01a7c6ac7c778e1d8903d8216fb792384c5a58d29ee7e3b92e50fca4fb08916dc042feb1bde4596785a66b15ffb9efd59c2bcd82a2597ff39c4de267656a37115dcfea2da00c5b4f539e7a5f02cd30b5de47dc36e27439482335fb7b94788cdbacf7e7bb418cddc90309d1134a1ddb35b3d00490d8a88911522a3a77b866f6d765284c19cd3f284062a8d06b180a225940ae717b525d62d2d43a1bac26df093ca941ca2746ca1267c5d683c0e95ff4367aff3a6fe5d6021a276f2cc6b40921a2e908215485fa07706fa6d4c237c16c119cfa5ce18f0b560850e6948f9f580b1f84c50221e9bac2b00724557a1ce981f4186eb088a7beb4475ba339a07ae2a35e86af3988714afd26697b670d2cd6ee08c8fd4b6b90c84505afeba41bb21a0c22628b5daf0e16432fcdcc2070072f7fd2b6ba6fec59fcf32488312ba00accf8619f603e31be5482751e7a30738980","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
