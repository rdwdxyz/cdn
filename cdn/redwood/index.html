<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a14d107a9b8a9f06612bc4c43da4a78d2719e467a3f6a1072ece0d5146301c24db353dec30fbda7b3f895b9d363062199cdb2bafadc49a9f3b32d783426196178be489116be9f29da871ea1d3890a52d97e4118c648e204a6ba137ddb9fdc0ed9c81eb095bc91018dd3c40340d7c526e652704c79c4db54bcabd7c84ea2377c002c1e4be5584344f786c807908633d7ee09b458132531f64f73bb42973a61f846840316617ca501a9793bb85a885588dbcf8e55ed18c094668393c4a2a695df896358ffdefc2d11f1b44068d89775c367eb03a0c8f69ed99756aaf7d4c34b07e1fb34053e818433238582bfcb681fadd90a55aec5ba9089eda3c579ecf546b9fd278fbeffb3b0737cb9925c1dffc7b864d9774dd9f822548875bce2aab660a6052f416b27538476ab796be0c2f34204929cdcaaba9b641aec17201742016487b5a93d054e356766cefc8b7e73f0f104270701e81858a800724b67e181e2d9270cc6719a673a3c385ec1b1cba935045d8ab1471b5cdb9107447b01303d8e42ab8884b6d1e7b6a0db6879d9fd920b1af4656ce5e98d25dbd6ca492396fe2366b2d6f277420817b86a462bb8c9484eacb5e35626756d22e2f7baaec275361bc4a5e4e9c2f87c812f5f3dc318eb1a5adeca4707e9a6c5d7831ae26477aeeca2533241f8c10d77cb417577c46a109a09d41e8628ca7520a29655a847d2c9788a733e55c7120cbbde5dcfdcd3ac0b08c51aaf09603686ac0b4da7ac5ad8044611914cb2ea2d441aff3cfef1bacc145655d3d1892b88502c9e82e4a1aba55b296b6470b2824895d0c8291893148669d39d4c9c84f08dfdd632f23d7484d314d42fa80543a9e3c29f3b1222571eda1ee179d8a59d6e110875729cc8d44631fcd4f95418a106ef80a4317d367bf32987d204689c6bc10b8d00fc34b8a099f36743adc40c9dfad01a0f48978492458bc54ea4e1792afb6c01517c4514f3ce3d0a324fb3e343f5632cba525ecce168843677483ff61b0332a54055079ac7eb82ea3f13d9a6ce9a22dedad664359a8eb54df1193e3d4df3afa062d9dbc26ca836345ac7fb4d6c4768bfede2bdf0adada6f7fefdf93e585e00c7a91dbce7eb8c01207a0e3ad4f0e419574baba7bd901912a75ac708f77a0ecb2813df1a76cf39be5633daa8cbe807f92e5a7af566775eaf50f00afafe3ab6bc96711ed95257f53801fddf1940542ec3271e6f06d5214fdb9b843afc5660ed3781a17379aa468af43be082f4d29e9221ce7d6e9c95aa74d662eb36898985954e456783129881891b01047cfeeb4bcbb2780a624d8c9f25866ed4ba1cb0221e46edd7871060edff066c6ecb777c8aaf711baf048bda8891ea5fdd3fad410592428a6aa9c81d5010be017757300770311c673f035faa6e39ef3e0f8e99dfa07e54ccaca3ea531f25b71b7618e1348bcbc2826d0eba78ca3b4fb4f798f923d14dc5c8ee6f675cb9c6a101f1c77c2d4077e01cec1e2db9e20d69a2f122d3cf4e4bd5ee20d950d0301c68e03900991cf089c49c9bd651be3efae46b024861119b435b2de6a1ae8985b9b65f594ff1e8d60a0ef65978a07ab07971d3bb766b9425d91c14559fb4c7fcb9a5515ff3a3d8b32d04fca82a82e47fc07595faee61c24dbf9a8a4af6fcae69ccab058c7557ce36f2037618d1e4e5009d65ce2146d1e06beed5fe35eda4c2cf39fea69d1b6410e5e94c00e3557760dd2b48c0bc8631c54bc79ed40b09fdd589ffa3ddb851b09046cd930be6bc9f12949a1f75b7653534eb7077dd8734acbc00c14cd8caed17b8a9d645b0a77dc272eb5a32a11890144638369f433b304ac0a574467f919899bced7fb9b47a0833eb845cc98a13a65f5599356ba3a2162c2833d958144bbb83d038563f6e82109b2f1b69a3d88ea51b8813d89b93a06858ab99d26c53ef668ed7c94bcd0cb02e9c7e1e168923d834fdeea2765689f2e0dc1a800297fef5a6c9d3c5ac08c6751dc0ba96d69025d61148c939915138a15ebd61e0a0cd0a33b3ee3796ad1ed8b1791bc4243d6f6de50582f17dea800caab3f4bd014f10c8ff76a228dbcdd202f098a72244126d33b19d3a2aaa295f89f7094fb5631bca3a24fc9bf8f190b7e3f1bfb3b99bff5481e8bb330df990ae89ca791dd6a1c0934b22ff8a583c63c522dd08fb8ff9f618987a86e54a976ab0d73d4d8fb949cedb5d1d5672ba6b60fe0d68aaf1ad6645074e0a6a9e4cf881c225cbbd6cdc4e0f90517cdc2daa2b2d276d43eeb92226dc81ed1bcea01e7daaa1f5f794dc3d6403b403e4786cf92a62cde788afe53039c3b1ffa412aba20de105863f2d36cf2f295a12f1ae54a09534ca939e91314dcd278fe2cb0871346b5c156c5ba80b527af13c5471c52fa4fe44e144494761ff3eb947149aec7d90b6d514078b9ad2af44d7460016804ebb2184146ccdf582e0e1f49dcb3e2ab65b045c7f9d913388f52b1e9459c7a1386f56546670edf5c9f14be790d68d08ec4ad290a7bd0a6990235af064dd142fabb129863c5be81de9885add3d3e9b4bc3904bf0980e9aed8b90814ee733d34d122ad65663f8e22323469dc24680b258a0efc98b346db2400d4941ade947c4d357882845ba512b3f8d6d2e7df511b46301ea6b0af819cff8e6568b40dff54f6c0d6949af8056b3780e46db19b561f24e4ccdf6610dfbecf239393a8fadd1f629cbe08aebdab9c50e85112a8fdbe3811771963014a011d29617222c0965186588ede4d9417c88c9355f4117b9128a30ea472431d81721d1b20f1233b714bb552da8c1753fae17f7048d5fcc29c4819f17d57c41cb25f608537d1fd3a6c051382b0561e04e6db56b2a7663268f352d57bfacd14527ef33259aa43150989952c7f2b680635737827cac9725cc4354c0004f6ee860a5180d36938e730c2fd29649c6fe9bf1d6fd72a7a2cc26a41b9670df621314df94e26d4ae032797ebe1d3afe6f350c35716e95f0fe13ffcae7791e04efb44b7215fc0f9152672b6e4efcf3d6a5ce35a183899f156e326546fde49e1b55f1490e8d260a57ea5859b8dc31eeaf9461db55eaf121d6b7caedc5a335d958597d2df62aeada5d282d501e2bd349fd8de525c007b126a32cc22929afc44fea58740345b632cbe115c37ab197e568dc2b2737c0cf38370d34cfab71e2a705675bc16bc2f3ae2ad88d86b30c1015242259d96b18edd77276e10dd50561bbc90c1d2986e9769a39455e1f28dfc455fa97b512734fa8cf2c246c5381344d9c96adbf9d44737033bbbdea6c23e863a558727ae71d5fcee611487abdce3b44adc680c5661d1a742610f9bbe75b73b352f418298395be7c7540731198ba98ad3af698fda43ddac54f4e5071e5109b123f2e2b8204b1ed81cca1c3c2215cba04e8a7557c45978603bfd4d87d681906472d5aaa0359d533f94dcb8b4644ac3478945408b7728510a34d53599a30d6fb5232c9376d841827545a57da61d8cc6e4aa42abe589431fbc719d899e7eb4ecb59d64fff2f7ae93259b910ccdd9da23410266be02c8c2c20db2ade1ac41e43c969dc4b2707741c4a32342279b58b297bcc591dc2642cd2c35247bfe4cebc180b597fb51aff2f2cca395e57fa282b590f48dbdeb3bb3b73733c716b8ff25f382a09fd8c52e5099b8b1e50f2e50e127f9e8666bfcebbf53d7be97852c290b008f19ec09553ef889049817894cc0a391f72f4a738418836ca6a383b80426d32efc94d90cea0f17aeb79f14ca667edd4e62cdc6cad4b4774ac3c382479be459e6b9de27a2245f88ded71307489ca9cd9c219ab72b7bc56c2300d4b3e455e4ae5b9b5a328fa245de077a89e062918d5a4d65001ac6bd8d617be7ed22312d5ca24c506a5d3fc31aaf785feb65c25de71e413652555b267a2363443d83a044356110947fa7772643e58f6fac3ce3e97b3c2541965b358a007847c07f7b287af42617c3ecdef16d058c084d2be60302f00f7990ddc101adced91a52fd624e16ab0e9e023ef7d0239db2b7c35f335f0b1892cbc65bcd9c685375acfe884d3a65621a3c4a38096b38ec6216fdc90ceda83365fba2e0e6ffa54b82b10c73dcd084a7388c2b96d02d24bfd997770f92ad488e1bf0cea90e879058425f293d19d5a8ce654764da6112c10b70ed425c984b18d4ecaf1cbd12f62c5cab4b585c6eea23d95c8e6e742fd930d94db1344d68513b0cb5261b6c90f76d707a26dd237d13617a54fb5df4e11029e3290c7074ee5725be4fa8980235cc11ee96aa625cea4687d63c9deb2c8e0cccb9a442d61a48c0febb849468aed6cf648178bf2f5538c717e7cfdb0a40b032d6536b795faab4ecde2a73b9408eb069b58afedfa5518b4e340875e2f1a345de0a1ddffc84e6915f623ac3562a94c6e15f809d2e08fb1f7061bbab12fce58298d60d000dff0d95b988b24e858f57385ee6d36982f54ecdfff7f148d1be4206c0f35ec9fa1cdc8040275c93afc6fb55e31b2fa3586286c2ff8d1fc04df235d2c0f1d7891009f1f3b1a9ed7a821331fbd55491a3d48acb974ece794378fa3466ccef4ceec80412c7f5246be488011623edf6ef5be2e090360866dd2629fa7841094d181668c37ebfef367dde8c07345ab0be9ca8a5f5f0aebfbb6698bf09905986af74e88aea720ddbef790b12a2804eb7491f16d08137726bc3e2bd30513cb31198ab2895ae85ff0097c6627854ea6a6752961d5af27d69d7d15243722509f4d413010a9d0c1e7a1207adf0e71961cb76fcab65168d634af1563135fb77b454d0a4f35ade798f7aa7512601dd319a6edb9a5546a22d959bddb1082e703d3a05f7c18077519995645625a8268bcaece6f23a8759d895d9bd4e2387996b92a93109655f57f75da5b552801eb51d0dc5e397a090489eadf4f0f5113a2a5cf0ad6639cf54f5cfc6067d3e0a7e49105fb94871ef7b575e37394449cc268fb16d00ac18032e366650be6c311f708a175c9f2ec8fbeb0334369e676f3dc3252cafa8bd890a6fc1331d58823da9255f0af8de2ca9a56e1f963fc68cda876fff9bd43918b8d53d852c2aa8de44f9b3d378a92c887155368d2fb74eaf88b931bdf5fe6b7aa27668852a78ef6131992487e5a8ffd752ec261dbd1037525e9ac95a5448197eadfdea1f90ef87fad907b30ba91ebf32b821a86967e217a886d7308cc293ded36d568a15dd14f38bb178b8c23f4adaf5ecd2a1aac84ad0098fcdc6edbf3a5e8ad09e316243a39fb10f4a2624ac7ab090f7e6d312253f1ae61ca8c636b3243cb2154cbb4d4b7f6468825cef186ecbb3935dc0e19bcc716fc9b36bcd1c1c1b4765198eaf156cc9e6070cf65ea5abe7ece271b4f471c6849a024ab02a7b6394891cf21270e023f97bffe6213a4a29552def03e8768ad8717dcebab32357bf538a150b99833e4b24c71c526351e85a4b0dcfb7e6e4cac66a8965e585ddded75e5bfc158004c0aa0cb4db67de4c64dcd81a4abfee28b72a6c88ae2aeea9f2c124ea5315678d3dd7ae5045557c065151bdb1013bb27ca63ea4ba58f50b41e8219e1e7cace97c7e52f7b8e0b77c5d3ce513138462128f802a19780f2ea3a5c954ae373fbeb1ba360966709dc8230359b4664bf4234a81054fdfc7cd63938424656252c7fa5fd8eff85b5272dbb991871e21c665666170f0190c4b8415fb18470edf493543a47a1e0813eeef05e085b3bcdf51d6b2aad414490a4978969c60a97c1eb779bf8314e6a3487426a0ab0fb22d74f9faa3825e3c23a53790b861c432344026e23d64cfd3a43f7da7b4e9bdcf31c773958f76fe0235336032a68e424e17d6cfef1f01002448a79192eb32f23c7a11a89ba624a92681887b40ee0814b0f0863c3171004c3aaf21edc9965a0c5a9d3745aab5fd810d36815a30c2b53fdfe4a08dd7e25c10d4df7786432fdc7e189b5fa217e4d31a2d7d8ab39ffee7bc2bab279029d4d0046433542684e8c28389b212a782b85c8cbb258e00e694e1ad80557a54f44598a368c54b616645fdd3ef32b9e0303bc2de7adaf8c08813ed21198133815579e350ea4faaaa6de6920c938a89d9a0e134c7fd1f1c3b0576b9b45198079b9ffeedbd015789a17856e8d04c0b3e2b7bc48baea222659f1b5c0a1630668dba03b0543ef1ade1f2a8bff4e1bf3960ee318bdb103cd044c9ae03d7496ea9b60f30dece02d1e5f3f1350fbf790bb4573aeeba9d2c7a130511982ca3aabc1492e25e7790f81a24e6f341a8ce0e2e94a8f68db7bb20b9cdd1af8b580da57dccd664b3f733d03049b4b0287d285826ad6d4c63cff919b2fcc8f1a06d7a0f63e57e22f5d4467ee991abe6e419898d95142d1bdd92ae90fdd4cda319bd716af305f684f298914b99b83fc9e328b33d91455a32c358955d8eaac6243e409b945f63612d19dee2a8d4193dcbba1b9d19044ef0efd1f580935a8084bde898bc751898845ce52524ad423812e45a1cf4850b7bf2dde37876674fa06d5bc3175c27870004344877a6e6710574c211fbb7db49c2ffa0a0cac799e02ffa8ab4331d225eb0871ffede900121107d57e4ee30f45e2d328fc275bf4cbbc3ced834bfba241c76a4ffc4f132e4895a5fcc916c0ce08f1dcb43e7b7b2901bb2a7ebf125dae2d0d38943b5e9e52cf55b9333c61e9b7df807aedb3c5b1e01502d17d9fa33fa454bb746154c94d03a1318fa893831cb952d2acbbc8ba1ba438f76c15629bea2a0fe523676d86a39ffedf5789e6ce10f293ebff7a1d4e9fa8e70359472f3259d680fb66f039566bce2428c8795f14835bbff8d663fc52f30ba43828b5cc8f801553ecc86b213a0bcbe881e57500214d8f9d5881d49fa812322f9b88e01f0dc2b9d8736d702243cab3fe3bf4827c86cd697085a2166e6ecd68a16db33e95b6659e38067841c4901cb1b322ba0248eaab845a230cd56acdc9a2b51e10051f79a07af7bf62213e1422c1cd59ab66aa05560f6cd56b4d8d374eb1812c718560e3977697ce3b95bf42458a79461ad12a309e93bca440cde27fb2a08836741e8f9966bbdf09f05bd213a575ce7c71af0caff07cbf0cb50eb4dfd4ab4a6a82c7b63fc75b1f954a9c0f48609f861edf29d84215fb03966a9699a12740cab8ba4baa963db4e93f0d5aba5b722274ab160fabd3d6dc82840cdb6f56de37d8e82169fe8e4a3ad196dd182b814732a6e8d810e027e86737ca6b1d49ca05eb59f10b7a147b6d7570be58301b01c9282f073e6de040e5c6dae37c1558145548d8d39dfea24fbf603ea6a72c2223745dff09885df20b3595f4f85b553b3e873cfbaaf2e5efca441455eb23e8f904583739d84f35fe6e492c5adf6095d2935681b8b4d1d95a086d074d99981460a3507ba0ea403e8168b6ff0eb13806b2aa23d9e6c979de14bccb4012a70a9b173e97cd3e5b05582d1cdc98f3cc34e608ad635bacde42d9b7688b2f801640bf15b1e9d675dc71ab10e469fbbaeca51b9949ed5d897e38888db3ed8b1d61ae7276a779ab8b4926672569ce97502ca88e9b56c0337ca02d9b67386968d7b788f8d6a92a996288981dca8add9249cb1bb7a650cf36757dbd92477cb5f837a70c68f5bce31b4325a325aba782e3a9144e786f24d1fe43aaf903611722a8b7a63323cb82aedd5374c6ad3a6ee7ab0e9f247a9938d6d712d43fd16c04cc9fda9ae2d90751944219602c6b28b0a2e8b3f955e993c9dfb6e867565a256f11f4c5e82cae02e099659d533d3ce4504a6be6ff8f0b35c6c9bb5add24854cf0753c972ae525b48d91d4fd1bf7cde778d49ad41334ac4ea20d007cf5f34890d85c0e502f1dcaf785d8be3b1d434883e44d7ef9894926396b8cb57f02cd2af0f4fb3c291ec1413830edd580039c76ebdaabdb4afd76c73feb0b0f56dac9a73e771f02597a3a806c256557eb2af6fb24d7fa154bb18c2595af2cff0238c50e96a477aa4c86a03ec5ed049fd18d95e30f2a6ea2399c6f68caf7fdbf722b45f7a8e42b4fcea638cf91f4cc3bcdce2b2e94218d0e5716209b184f0c08635319ae21d2b59132b64c048472641e6ba69c4efa698e2f159eacfaa8df74a2611fdc2cd8a66e6e97bcebe14d29f1386cb78deba22a9aab4dbebcbeafc1e76c7448256d54265d0a2dcd648ff22ad7dc602527fdb48d48c23215a0b6c030755a593b592f9ec67922bed4894a2f9d4913ced18c126a166dc1babd2176e8296679ced15eae2ceb11f8032efeecfe683fd82586a7110bf80b26503f6ad2f153b9509acf87f9d5d4e005c25657367571a689b3674c30156392dc8c3616dcdf92260897d316e683224b307525a0137675df6e6ff437e8c0086ade14b4471b126c943bdd0e097fee88971b933e0f89e3994395a6445c4e581d2a299ed978d687d150f70d6d3398d24dd4dbaa5a642254878de704d836416175d1c1e67a28a30bebe3cf351f853e28d8c3a1e7e1bc6e9d4a9af69887b58df3addb5093ec66484fe2934d5ecc8c5c513bbeb07ff82dafefff7a31c9d29c8831dcb0cefa3bea60d9aa99522d23094593654d51f980a562277377222e0eec40e95199289ba2d45e63ad4970d898a0f1bc9561fd6701db9269e85afb32ebc8f223375307a889e4f16b31f78133964a8179238819980e0b5f138f3dbed5032c2936c19d3a4f32c3ba39775e814d61022e9235f91aba1df5974d5acc495ab0e2b4ff7facc5c4fd1e421fb663b24061526521b00253741613fb16bd2dfcd9d81b1ed6fb4bbae56455d90d48b0c63ebd7e9e746139a11d446752d961a11069a7caf8ce24de33cc257f2f9dfd8c9e6f364c046095b28addc0a4a98d1a9d6211397e853aa479b5ce5a3a05e601119940109666e1188de07da6133a1e0d1df225f58725526de73be8bc7fcff9c4a1c3e75056cd092f2154b85efd40daa3914230a8693909c560be4c992116135c59e667cea0de9aea3f9475de711f34a1ded3b7552b77e64a4fe2d2ab9a1dbcc9fd9a875a88fb1418519bbdddb321c1f81f4900cea41efac4818341e5a5e806012388a22149a481660a4c5c8970cc365492a84e62e1ca45b14a27d810d3a28de3044ad74c2bc93db4f4ed9c4653fd6ae36df5cd1c4a641d9c169c4353c8a665a20392a79f96742d014764b1cf43ec013b073ae50272989d21b651f18453fdeaeebbd09b94e5d46e851a8244b599f18a987a403e7fe31d175cae348334a51fe2bd03b6216055f6dafb04786f063e9a41e090d6c610ee615527b7552c2ad583daf185d19b4a2b03618c9ef9c989e7b39a6b7d2edc173498cd66fd0ad10f833e60e69644dd5456b49c7b0eba136efb60b7e067af261e83edaa268bffbe1133fdbe66ca4e3a0833e7be47e614dfa6583eb0a068ee9c81cf99f015fc234042cd03545a7f6ebbecb9bb80155dec52b8e97da97f6735a13bbc8f09245ff2b89c0cb5bcacb77fb6ba340c954293bf2bfb62a87de1a0cf787bad49f308f716f0f1a041d310a9349117deeae6f468fd9ab9372ec9f16c9e55ad21c58b52dbc61a1d2eefbff5bdc09b51f85e6279e883f376d1f4963c5b9f56a7467e39ef26e67009d2841f214ce8270a8d04571db9f675952c89a52bfc98d8964b0c8a1cfdd51129a48d1572c2386d02686affc8d76647c068c45d3eb1f3297d4002ddbbfcda5d843d37fef78a086a6fe36e368a4b13464b645f3d8b81858b77b931b653948ab80a0d3861623dad79d9758cb83dc1de31138e17d2f7e9255bd2cc17b8ece35ac954ddca3fffea7fc06fb01d0b21db1e9fc8fff2e7c9c1dd59b77a9b8f652753b2c7e86e38f25200d5ba8f873a5fde2eb7a4c0bcf3fbad5f772228d3e5f7c8bd12815f99d7add1b3845ba03aada3ed813c00871eb32f0e9f0b937ab7bad27878655aca2f11e5c05daae746f8d5d2c810ccd591e24adbbab193d0d61632773fa5441c4d0a6646a9ee1da23eb71cee2353b92ef4fcb970063cce34a4101616fc72b8b0af6627f22ae9a32cdc45a66445cda4630e0d6afed8c18b6bedab03190a4ebada1b3613ee6e5f796a57e4d828ff2d5895ffd21c1b14b3ef6c01e0d4cc50f9b441ef4bb238c2c32a3f13dd084a50a7b327881de191ab864face475cd28effdde57c4f79d80b96a10e1565d331fb3d8d10364f0ec125646c960cfd482136783d6e4bc26bb688aeb31803277d1d3a4b44082bea7446c8eac79a139a922cac384c9df0496a6f099cf89c22a502827af2aeef0d6e74eca12fdcc4ec6851e04976aaf0ccf70b04cce85ba3a6f61459fef5d473fe8145ec84c0424a7d030164aee3d4cd26574ab7bc025d025da603cf914d9f8cacae0502bbdbfa797637eb098469f2a020e3bfd2f26f477c65bb1da3221642ef6dd63421594794ab804e48d6492197d50074166b2a203c63b0f3fc4dac14616d7c487dc6ee0c93c55b79e4bc13a4a6144c5346ef9c5696a46f8533767a2f01569084fffee1e55aad6f59134b9187b96d5501898203e4f5fe439e6ade88a0c00558a7a117765789c9a87fa8b1167a4dcdb23c26a26111b373e7a35bfd49e386227c07201f454ba737a2cc1c40fe2027f87e777ed9c4978b126d483bdc5cdd681cdfd4e21a2407a093f20a9e8ceb2cc9d89fdb56ffc4149249dcbeef117e3fd2eb08458ec43de9cb1bd012f1fb9de68329716a8218545d1ed2c8140ce3fe6e562054608c93480630f3ec6f154e1fe588ff54530dc96a8835d4c2f55fbd4924525ffe40733141d3d95185806e43afcc30dd531b58dd76cbc3f6d22c905f9d87c32d851ad6d9541b16159ae2988788ed04f5d61b4e8d2b2e2ab61e906bad6fc87fe8a00f38fcacebb6ab614266cee3b521139fafd3b9dbfc37edb5a702804321f39b0144d4ad1e405eb866e0c081a6ae9005c7cfe7612fbafe287f71ecde6cb36706eb7ef16d1f103756dbac82f59e190e78f1981513663245328d72d59568da79a180282b890f60ea9d9f5f5b4dba940f7177f8df280a06325aed64bd2a2cf38c626d91f07cc0a336347163b24cf70d7f1e14b55a0f721cf907b3c7ddf9e08d12d9de8742f4470e72b844fad788b3558723c4735b9706e1e93ee9f532df76c3a574c87ae655cb99f4ac034cb1ac701a621f73ebba48e78bf0c622108afda8fb8e33e2edf08c8f193317d7437b915f6751bf4940e7dbd5a07d9140be083ab94dc9539fbd6952aa779c5cd399bd45aa5590cc8e70a648078200c1efb918cbbdf09cac4b611fb96ed9bb76672463558fbe5198048b9c4e739a6a12593f43c8568e00ff51b4d21ede23101f26b7a90b37ddf26a86bbc845621b142f3a3d0bd27f9ae709fc3530a051550a03a9c83dc229b1439dd503a9f0352eb5aedd052b759468d03b34d569acf3fbf5febb18ae286e34abf9694e817d6f46f8737b601b4966bf886b06e04ae5005ed327350fab9c518d4e4b30443b93b4acfed719775ad156cddeb5822da1dac7aad78652ffa2c60fe4e1bb257a9dd2d0b2b2e08a1613e280a2ae005b0ed8d620ca9ed7d83d664a1638f415aa9e7a84c9cb03c2536231786a40f1d16968f1967697b0261f0b2341ad0f8cde63c568c8cb6bed6e4420359b5914b56ee1e67266f56839651fc41a062573ad8a21da3ebbb2c407defe5942ff61056d63bae7256350f514cc00cb1e13626d3f51d08fe2ea32f6bdcc0cf9213ed579d3faa6ca59b45ce99a541974f18c6496b35904d39f92d55e3392d76a154706b3ab507b41c73115f26a9703fff8a9c2cf0399af94e0dd1659bafaa7d2344c4c0ffa88800b2f3fca56034b2464b07151037282c457a387fb637082effd9cde46efd8491ed35218d9b40b8bea2d146723849d6b2b455f54698a2e710d2c2b1deef6e75088fb42d697359e773e610258bebad1df045048e530bc3d4b7df2e6bf65d88375352e74e4f70fd754793434d91de43a4a567831a223d9d84bfc1493e6e59d1bea544c261a0744c3ceab9e76e9b09d2133a97595e81c6f23787f08c57a95d61f03fd8f84d441eb043f962fa6bd632a32580950961a5baef4ff0f2bdde2f069aafbe68e43570a110680a0c3bcb11543b9c11c7eb76c04653f442b04c063014638c449fbf281744f6dde68f2875f5d885aef2afd025d31b3aef947877abb32c594c1fdfdee87cb7a2be04378e8a202341ed7fd51118086611265b8fdf46b8c6a319a76fc452c8ca540119bef11d5f849aba7dcef5bd707b795f54fd0ed7412cc3c82461acff885e758d014c82b2b9999e12ad89ab8dd1f42a34dba4b57ebec3de027cf6dbbd15743dd340b133eb23555bef2dd757f174f6e9cf14ac0be18618444fde7787b157da27398e3d390539a0320660869a24c8363344274ac314015d5260e761145756aebb4e114cf1cc4fb628842b2dfea3cac105f0b55bffcbf59d3e70ea9f693e438b8ea58c2709628bc2c631e881dd17bc180b4bab3340d6dcb7f757ee8c1be0349be7c3c5432eb2383ce9a9cabd4942889d34acb171ee58cb0461b29591f2f60366e30996c3430faa783b47b48e1fbeb8a93044646c63ff5f44b10d81536cfe4dc7c8ca50c970a4cfc3b92d6341ef15c2cb62485c74911d51cd059bb3789b02efc4931e0bff052759105612655ef9ebb4d813b83c89e419fc48aca66d5d2256df643ed275f4580ac962886a1635640069617cce5381421283b57d6122396bc8e51532fe7accf58a27ff14dccdc1f1c9a8d25ff9528e857d0167c8f696adf6338cd496685430610702e495428c7785b90b952e748fb8c3eff70d57f79a3b03f8e15f89a3b26b1b5b57cd4cb502977c8959b0857d9190b4679f880ae89c422dc7396969272d647ae48f0cd3e2d416bba2ae72b751f48b7bb324f882f50598fb63711b37e441bcafbbb89f07b4801d4d57878ce1ff146c8261d5d9ff0da809579547bf22b2b1bf9b36c47d2c8f2091b7745707d2271279a5552ccbe817e8862206d03079b1462a2a7cfeb7b0d25ae8eb673f801584d674d623f3e823cff80da8732cb08776b6b7310f863fde6bd10f15549c0bf3dfa30f8d4d9cb12ad3c45cd55d3a1712979d8837828818c5bfbd81e62afaf4c9b5eabdbce71cf02f5713552ab9d50f0f824ffca7c41d48473699129d7f405a402b4330fef6985872889e06556aa96f3cca2fde23e03b10a1ee86fa27285a5cadd3867165fea4faa8f7a9a416cb5984cee51694e1f54a51f3c18d8a13e4b1316d6a4b71a6def127a9c911d823e9b4f26843d93948f938e752bd520a1007e8823293fbd332afea623887e8c533acf0b1676081dc93dd5f2f07a5e520890dd8906905122e5aa77babda9cfe940267af93fa5db5edf69bab4be4158ed960528b32e8e2a5453cd421ba296c60c7b6d2319ac4dacbc7cc44c5df0272292738217410bc567b7f79ffbe33683c2fa1ca221fefd977043996c302b4c2ff0fd855ff2af0151fb4895ee6fd4a9ea75544c274965c386da8f30ced35751284e30786fda78ee523e0da9860fa7b40ee43e1a39034d47252b8e8bfb04ae583c72c9303647896d7afc5b54537e435eecfff0feef5300d4278604064a1f55dd697e4b293ce5bab614238ae44d2ab1cc2610a0ba1928921a30f674e356473661983d377958a89afcb831057c7969b70160df1e4625da48bb712a29047c108c8bbe5cdeb696015bc05671a1993c6665a0b1fc9573343b8f1da6b264d6d147c0c17e801f52a918382586640ec41ae894f2ad32f95e7663a77520b2b85283398cf0bf8dee04cf6ce581289e6c13f339b8f3824d82ebf62b39ed2436c5eef91bafaca1b6df218841caacec4687240efb6ced2381a35ba0f70f7b1366c75eb41fa4502b3d092fc07dfe07685b2716bb47909639263c3204f447989d3169e82ba959b78e35958a389befccb4b179f94673e0ceedb5f533820bc85abc3f16bbc5afa3d259a7fb03c78678f7f3834a3f9f43480a5b83a4e93aca0d01ab56ce5012304314e6d9e8f45e8d2f864c1eb4192cf1db83b7da385de4b40089d55dae85fbb726536ad81201940969818c323c237b0128ee44676180e8c2b8c328afbb95a17523b5cd0edf612bdb6a7aedbb8ea7e48520ece13c204ae7352fbb9b38053c5a3ca9372b7a85a2ac2c97f46fabc630f2a1d62dacb8c2f66abfa591c9fce714ff2dcde73bcfc18fc244e24511c9470708cf6848ea9ae22b4ffc76e3e4154820113b9d46d3b080c900d596260d60baab369e93c6d2e72beb595c89f4f14232e02b2c6a0dfdbb991446370fbdf8b5cd66942f22f86d1e61ddc9310a6d5dacb8a7cf158c0176cf45adcd8292f8452ee5b40d1338d92541f0c80d14b5d618517a3c00859cca31d069c2912d8148370b924edc92020b046d549b6e2cbc9eaae0f37bc3263ff2c051407fa1ae81fbe74f5c91904c7703762481d4eb7bf7359b36b8b7e67a7aa2cbe8fd9e4ee3455c9b375486181210f2ec2470b3e6fef9180754ccb5d6b6d7b290c65f0406d1723c7022f11e728151af67a2466a76d035c126c4205020f3f9d09c9dd894efddc305ca64e439dc72b536007c5ce76b8540b97631e90116f91e5acc1f78677ed0ca1dde5c58825dfbaff872d7d21cc6917a11b5e5bb21331f2e821e0a748a4015177c69146b11c2a76b516647ae5ed96cdb526ffac06611e6995b964e0abca972eca0c8a928f8718f99eb3105202f44118c8ae6961e0d2a684c008360bb7bb7b287c9d38e101f490ed1c7fb9d8ccc7ffdb7a1f259ba103c0879f5d5c597578b40d0eb62a5949976ac4d0ef896fe9e17eac68713d2e9df6e1f28b8c0f5349c01f08629609c2e5d7ca71c3f9f90f4a1173927e84047abf02cc196543172a3ecece35e2abc4017a7d842c11091a58193dcfcde24ac5b83aac81317cd084c00e8c73f2a6c9297969b388aba87e748f2d01450a604dacde1824af684b264afbeac207a4de17cdb5d6879092996fed53911bb3ddc4e6aab98116a317946bd802a9fe5a338e512f5c279b5279d8bad31c53e57e3380bc6e90388e402b15fd99e8037210ce1214f178386d01a64116f44cc7469c51c8c823ec240cef72f358881bf12ae014f4f496e8711bf10f0fd4a8a0fa2d0b4a27cc90cbf812cc8e71603fd52b4b3f6f15cc53c073a61760f2d2904042c886a857784e0f4a9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
