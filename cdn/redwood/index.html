<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"725eb7f4496b2feee8d002b124f56b86c39eb9bfb1353748e9bdeb921c4a7b300090de44d8bd7a3a15ef967e9f505c7ce58346b5a93910ad3336db3f309ced168e44fb68b8e1e2e6f3d7903552f34e59807d75669e736d944a9836378e078739859ce93928b9df21916dc7eb7b33a037b13b69eb44ad1755eb7d8b89787ac06ce02c3851775c786a66395ec09392731d6fa7bf270af40de1bd9e2abcb5c6a1b54e2f9a371d0d9df163776f27d64d113939793cb83ce0d4bd36dc5ad0de101ae9afead60754826832ae2a9364aee952af006382c85466b3a601f3775f4dcaef5e45ce896a76a070940d01dd8ec7b08f750b97e554ccee94dcee3141809966c69425774fb4eec7276d85eb34bc174fe80f5667e1e7edb7b79ebbd73e003f812b95e0ceddf6cb01b480c91b98349a9dfa2b0dafcbcd8bca0bbf02ec23a4ca2be92d63ca74dff10957278ef556a478603eebb86ef9a7dc37a6455dc263ee5d1d928616c6d202da694e0837ad1d283f099cd428e063078b19e9be76f98bea880955de5f0b73f39649164d286eabe8a74eace8938cc60cd796a26b0ad777237200a3ede0d5b5561a149071fc773304b46552fd25310fbe2de303152137a5893e9ced62c37e43a7dd91fcdd2531c25bbd6002622bd512416eadc3ec28623e318c82b81cc50d8df1ddffbebc31fb22a841fe45eb7ec15a73b98a6ee50e39c030020952ee1b78989269d748374aa464c0539c55e82e8fcac5e575444125e675292e7088b4727f2c6bb8d1f6eae8c9760f0da9a903d4b432c36eeca74d7867e938bbc64ce56d56f2dc80d3115e2b71667b45327cc8163c78d64f618efb42f6f9842d10d47c7747f53e7f147b2b966b0360b21d5e5ee560027dd1c537aa6e724e81cd3485bf50dc6416a63b246630b97df4288ce83206432c98407d4fcce1eeaf070b47304063eb7d67116e31e905b0e00fc3469c6022217339b328c77afe258fb00eb98e95d5857a21c96e497896a5e07abefa82f174a71b69ac267399d845b0b7ebe3fca67aa92b1d79be6c4c519d7cf2e5b452dfc8325913cb6269f7839b8176709f471e1e6db503e1bb79bfcb90f8368aceacb2a6e266a0b06e08c1041f5b6e05572733505e1de793f97e427efaccf30daec8eec49afef125e6499ca97600d0a4c5dcaeed2ea486089a5a8a7655ea8b4419dd3b322597a3e0d9ccc876c3929203b9f8516d2e6a1810cfa4100e594aa7c72d022e8462199fa2d7c234f2b5c94d77aa1a150c0ddf4ae9bad8b5cb7af35f7afa795963e55fac40cccf6a8095ea84ee201b11a1a7e67a228dfdf2f5be6df6b20055f4f2e97de5e4e00160c0056d5a185d693932197a2ba6aa49bbd571514d9b7d5a55b0be2e4b86b31fba832a7c5b9d7268214aeb060c2f4feb4d3cb0e29e389f8dc5717a3e9c7f754cce238b13b7b94ec20a727c46ac18f67dd053f71e2f3fb6f7ab130de93eaca879de5eeb6a01dd93c0c331ae3aaafa62b8ebe46cb33cbd37015033af9ffa40af32368400dc3c79596c9810dbce8823952e4f9d9f246d65c44c1d8323b013d0b315a993cef6d65a8125dc24a15ad20254e94369a0e146bba47b58247da70b67779fee9450f5e90db92758dc174d88af22c827826cff9f166322b9a05ce2fe55f0c6dbd511a0338a21aaafdd5f0098a893be2680be036e6a19f5bf725d506f301a15aac66545fd27ee529a1a9709b3a2cfee8a32923316a49731cd628502b1f0c381a3f5fe953785e115325d25145751a833fb973ecbf335f67092c2a2ebdae312d7855d1c2d559b7bc90927c7930ed327b42fbe9e21dbd9a1086fcbb2f85d74719f286487bf8ca56784c8b53b302e3e72ed072b3da28f5c90d8fb98ea004ca2cdf22269d93c9f1b90846afd1cb37f89c1c7729d2a6eeff4d9fa040c56a46e68011c1b3de6f18bf114c6c885cb5fb733a34d305e10534eec9be66a6ce0104fa9620f689023d90f2a8f7e16d9b47a033958c692e0f721ea843a164327623dda36ffbea79c30cf82e02ee3a74efe6f26b0c3eb445fb0dad26e0b1cad7aa45616688be5d1ce8ad1e7689b148c074f91bad5f4c7717694e22bdafd263855176297cca1e623e27347e315d8857297f7c076a369e596bb0d9846f6f96e0eca2d575ef9f08ae947dc939ceb102e5f8a45976d27a800f06ca4f0b57d71267fa31be1832fc4912cc4d9c76119febdb7a2749c31c4724812eae95535f187d6318b79e02674733b19a30f0a7f11243d03400d6f0bcfdacf5cca1399b713157b836ff996fafa0a36b4267cf05f519ad3c0872f1663bde83692aa040f3474d0124c79485c4357a13bbea71eae3c03cb6e66e2d3b666c4a1361c9273d716903f74f33d539adb96381d716281135ddaaca133cdf2c12ee60388d8f84da316a69741bc4ff4fcf35f66867f5867b37e7e47a763092a9cfd8863361279c34f4a80a03f15b0a9c8387816146f9d317e7f0640649139ba2b385eab4954b7db884df1ff1fd851bd7792334db4d773e2f303c0ad2b678ec27c64fd012ef374e9b76f5bd0d8b432ddc6be0ae895350600beed2023094cc7c4a9a63f3ca67d03a093d7149fa57535a6fff280f30e12294f4cecb0ade3cb1e5d6cfaeba483ff8afaed562b1e65967b3cc641617ec2093a48baa174db779cd6e4f2183701833887b303f9ae47acbe9d1aa79cb2cf78fa92bba9abeb367c6caf980b4681a8e833615c943c254e263d1e66858c0473c0c233a80b5216dc8d0c4968ef9175b783b6ce772553c1f52785f792ab32ef0c0165a407df6a9b608be172c7432f4dc10dd0b980bf172b8a1050dc1c9deca22220e7804c635f30d3c62e0e1b79f5ab50c990fb38d39a8fc8644c1875d4a8c8fd8409c39940974655061c3f19fe37e3b2475c9883539b802ccaa9e3e1ebea0afa7edd2024590e52c42718aa33d3eba8857910a1128194ecf1855495fae1273a3649d5361a7af7d04fa2b93dd546f5d32ad92b44b41e089ee8413c04f0c60690231bff45048a07f218744ca0bc750a116d281410d3a3c07e2ce1f680052a56fd052f7a505e5521882452b916507e5196b2e749c786efdce162e2aec21598dd955463e3d4efd3ddc91c8939837adc220f6f9cfe961d850ba0a16e7e434a6be96f629142d621747cdb4f382d90a5032db7c4933415630566b95b8c3fe18401dae2d810fc92ec566a6c2a7a80cf85d56f5af585796696bc2ad9ef0db5b797c6530edc8f4b9b0781995e2db7c84b25df4218549f925e32badfa0fa0a517158f3819da14557376d24967b2c8404158ad2be3091c5136f2057b41102979da12ce3484a5edf0fab0e85ae56a86d63b743644eca1b86020fee177ba16c3fdc44e7c2e322c9b9589dfe76c2aaaf78fefd24e8194b068657b5a7858e8097ab2e6ab7be23ca81c93e8299e64a173bfdc424665dee3f13bb0031d5399c9298509ff9719a698cd44cf71003d3bc0838456f434773b75bad47955044028b1cbacb39857cc7e8bed503ec2720d1bd13ae91f2837fd0488a053cdf8ce005cfbd6ab453eff0070b5b1ab33ff12d076c9871ce857226235df03c52dba6f552ae3b8d4fc4ff71722dd114a6de7bf7d1dfcea8b2e4c908674121f9b7abd414c65de983df63fd0ff71c29dae0f665a68cdd4401995682655741978d5a4c1cf47db0e3f833341ddcee43d1a809e61009e4c90c124e6926c2290d3822b0fc528e1e2836acd623ccef722057b5fc5b8927babb111a5784299d55f740bf56ffb3eb7549886b1b45cb65f55e475324b19806172d50916eb7ee9ef52dd4171c7c8b6935be6921b18f440702cb057ead66c61f6da9727a926f4bb765d27f4f09d76666ab938c5a5e4f5388839c45967540bc42918b69a36457f18205d1587a8483bf6806af9bb6d821c47d4fcef419482af84f36b6b17d6bc0fc2b2d2e318335957aa7fd4ce4d577a135d5a4901dbe1eeffac48d3e7b45e105c0356a7bcd3256a62fb69c6c1ffcb0e6465782996f77083f46490a1fc686504d06721a08920889b8ed065ef01239d3f2f63c7d0dd2a0c04a8bf65b26bca10a7b00767d67d8b302cf76cc67a7955de39e607cd4c64be7d7fd4b62eaddb7d268efd5a31488825c45345dded65a8681150ae73e1be3e0f1d73cf186b2f7c331a71e982c4da7905d4bb675cb0ee33a3ae93ddb15c343ae5b88fc6f49d9012a031974e2ec0191da8805c607c13232ad05d9363e832f24fb0c4eb1d35594d635af1d37a0c14255badef39381275142508c7eb602a03cd89cf74d08b5985abef8711dd502c2c01491461910799f5e10658262749632aea01cfc240f7f2a5e72bcf382aa2a921b91a0c6d60a8409fca1356075facb8dfd1db5bf34a835c650ba6c4db88740bcdbb6606037cabb8d9bace552b670747bf5e4b80219f39ca0c619a6f0dbc8de82e2c3c3aa7690087ae25d12f883b215981225bf320cc5b4d7c5ee1ccfa886c10ec91261ab2463c60ad72837ef3bad85e0d24286f2cff764ce1c172670488ac8eeda6e6b32c352b216aa3f7d3b542414ced46180f03701d745e1d34d4dd34fcbeb785468014abfeb37734e73ed1f9891ce6e0a9b52e736bb4e7b907d2a7bb36e7e9e8ceaa9afe40d7fc2bd5e8cc6e5ea20e6d555f7f6270d8d6e7b7cbe3f5f6cd98564718c4dbe13f6bba031678529252e9547c21431c32e7b06016b82c413facf6d184b82c5ca616834133c9d64f24ec60c8749c733aac6eaafdf8c0c80f10fbd00db44abe55daa53d09dfcaa871cddd9391b94418fd7fc306dff2dd8be07b646d60173970f40f4d0cf16215ac17d92dc0b17b9987a0ab4e21ea0ea6cba1a46caf4bb4ed3bf6d3d450feda7db10905e8da5b645848b369fa17cdaf26e09415b453fa6f242bde5e2d6045044c5bed50e21913a31640ff844effbd7e934485b202c9c23640a994922c946bc3a9cc7e2fef0b49abb825e29b16a4bfd0b4f0afd298f52221dbb3177859fc73bad6da96e471fe3adee077d2a3f347aab968f1ea4517fc0c05e14313b23bd791471c7397d55f7ab1bb3365705e8e0034c7c3c1883410aeb79897f6984f3661ca9e78820353f3f57587a8b9d2c5267ffb1261e35cf97a4cc0a36e05a309c105114ace010505eeed5c7046baa8190b516f4edab7669bf21ed9e68c17c0c1f9bf61575b4e5a76012bdf4333c9b42834d3133bd551470659e14d1848bc55e4eca043c014e70c14a012169cc70422d89f988b12d3ff256c207190e99771dfd079422d596d2c023059605d0a56e56ff4df87c21bd066fcb7bd9d02d6059d391c8a6b3f2fb5faba3bdfb069993ef9259f0f87a02465015fbb520de2954255312b437b7c2bfa4f9f234d7ec4b22a165032f114234afca176988a1518754c19e7780849d71074a34c9d4262230ddf385f6d2c2f5afbfdaeb902fb65ac4294e0dc0bea5895844d8245c2608cfc57838e812ef79a68dbdde6fc4a0022eb47670f8ffcdf2f33e524956b50d4eb79b62723f858c8566573e393f13b1f38980b3e82b5653be44ac20c25e817969bec7314a9e293a4a55a57d61891234810ca1fa745d01aff4a77993a29a97d259d221295e0ee876f4e13bb147b49137057b1561c3cf3d38ee6f2b9115c34d4890f57d0a7436d092296a172b0a5dbb0cdd68768c6178eb18dd901eda1ba548b60d28b28ded8685a36ad8943af6291c679575025cd8b9f21a26c4629e104b5b262280cba144790041277f99d71f5374ca23bee3eca77763e10dfd6151d2ec1c61917e5602d982b913cb162c3d183af03f2f490ced1e1a961e2ee4fec3f5fe22a10e2d8e0fb113be7354bbe08f33721f0d7cb3f3bcf4390c9816f9aa2c260882fd4eb1bc5c8b42f69338005a0fcdd09a6b249e9df7da82999feabf38c6d8a12022c08912ac9b80cfc0be664fb6a2d4f18037a1a657a217a2d09a619e008f4de03935b5f57bb6c7f70c115ed3167de5e5aece9d8f9e7087bce5af33b213881cb1df7035054bd3776d567e59df255ea435d0ec233521ce2114a3ef8012c60ca0479e6e75a1250b171dd936453d0b9250175d967283f1e4a2cb1c98c461a3ad2e35a608cfed74eada7e02b4e4533d795544b8905032964ce6d8c4aceff3ba9d1962ed5589271f6e13094afb609f0353859dcb6205f5ce3eb736174bcc4227442134894b454104add41917300c60a8fcf3866008e68027317e9bdafbd1e941bbb54744cf6ad7b22378cf86699c20fe33d46f10119ecd00155c02f4b334bbe420c041f7cdc085653161eaa0bb3cebdd75cffd8f14db0d2b34d839a63623cc9b67a3e0e69a8ac73d427408573f6281d5341f5dd3e7a62cccd8b31533b9aa5d669b7cd3027fb9c7374129561b3aa05bd23e689cf20607290f0e3a2797c0ef18eed5592c2f1b6bdbf26e55eaed85a91d546295c298bf94416b3c67b2a269ad1e6873eacb9ce0a8d5a28a9daacc9b24253607a6002591d3b3ce196c361e4e0e669c8b7b1a672a14c4d861d48c5194c0d5e46a4f51f4dfe876c3b5ef144fc88c36d6f41ae1cb15fd75f0d369b6486cd6af9cc42fb3bbb7d9058f1834923f3f16a4fa0d837003bcc5d28ccc76b8da8e26c1513009dec6e2a0ce681980316e80931ea49f763e0d56b82dcc21e9f67ac095d7d060e17f23e67d879d1c80ddbf21555fc7a416024001fafb228f55c0d9dac7c713a62f59392bdc24a6b3c2f005ab488c66613d13aaeeaaf391db34f2740ad5e7905c617fd25a26ba42429a343ee78b8e1412f201a1ad77159c4b8d5b8538d2c84e2465aba48acd641faafeafe5fbaec0b15dda5c83e5db1e0ac5a87e042565c79b593e58410049e4a5118fc1892699f729dca2f19fddf1858707dfc19fe743857d97b19cabc71c0767f59d669e0184863c42a7e45840f1f41d2871920bd8c3178558905a69dfeb15d797b9870ba4c8e24f8a8e3321267870d36f36e60061a891a224283158e3f485d9e02a8dac4d394a3d4a1f991c97d73a4426f3131aa5a68b550bf2d6d66e3e13485023726d01364fe5c1290ad6c4bca7655a81981949af0565a50e662a875df53011250764c7ea9126d4b168b2f29b87110d5d739e359e579af4adc0b60fff6ec2a2b93fbeab0296e41cd2ce7929b0bd3dd0eb52e2187ae6606dc02881aca289ea40372e7dd76d40e65d15c2da52d34c1b11db0ef6530cf40a4f4c0b260e94a9cf48f8c62821a9e05954e3d9e2da5fd1c1cc3fa8badf16bebd7438873358777ad8bff945dcad27c75ea056f98b1e5948e6de5ebcd2a9b003fb864741469090082a6677806da735a3f8b439914d3166fa612a5b3604f92d510e85a1a5b3c3d20db3389acc0546f084bf18489b1badb913453325801e80e764b3d23cd790f47b160c35b83e1718457e27c8bebf799908a60cd26045c72309db1d119a1481b89e5c7aa18a296029dd51b50c6272dca7ba432d65a6968cd48bece48662db168c4be73c849bc23d2b0498b561a110a9459725bcd5714249429ead61efb39bc41dda96b791457e540a3633aa544fd23d9796c0649b0638bac6a1f51981a7c1936dff0f29b575622368a2d1e70582db067b6e0a708410df2a81d37d1244710e1f49bc17335c4fafef89252f52fc5a071046ba6dd9af71a20bef68d0d1a3ef5731226a00ab546d28f6e0dfe53e1e0f558aa35346b1938dd320feba9a03585d1e842993c81142ac8db5589e7e2d1c3d01b93fef1a93b6ffa05905ba6a2dde0432f6fe10f3c460aa44846cbeed96995def9e6953c1d50ee8d93d0f2eb0fb3b805655e736c19a0167aa1449ef36089fed678faee3f575cbb83f16ed035eb7b92cf72bbdfdbd23ac23033931b0d17ebc30b49a8b66162c099b580187e55743d44c1381c402784727f2807c2b7c4539635ef6c65e05507523437c9740d0482bd3115e96f9d70e5daf92d1eef87c12e2dc2b38e076ed080efec34f5d686564500b9c66a8c8e25682b8be95eb9b7a38b47b7f042f9dfd15362e4342224500b4161923e9ac41628804ed6f268ac9894266ac806fb8af5f2c95d8688e9470515dc94ffe9f31422e60a9c93e7b0422ca0b727bd5dcb8853011faca6fe3141fa7ea60d417d82086d067f244799995867cc90425f7f97524b17550093b0ee7cb5920c819b6ace654a946daf91bd2400a84b2480c494682c73bde556f968ca7d6042839d40a9a9024d133e4687b056582f0b8476d0dad2605e40e1110d9c5cb79f9e597c44fa31ac146fa008d5dc522cda97f5e47db1b2f359d635980ad6d002e9337bb3d974515f8e5661d277be606c0bd6574e8caf2b612d81777b1e56943f75a0144a9962183ec110c2437ce0863d9840bbd3fb5d3e7e6c3fd58eae71b6d1a2be9adeb45f94a4bc19b5e2ad2288c826e44264155c3ef53f2e8619a8dcc55f95b22616b325c718b265f44e29e2908f4aaa0000fa7dd3cb6e233b022e5338ad9143cea5607bc3fdde0401fbb66fa95eddacc894e196b527a46ce012449903676937e717dadb5cd2b4650056a233e082fccf9d282bde64e928de0164af3ccb21de863add19f0d822a6bd46d49720d479d772f3a5a79a7ea47ad06ea777ed40cfcf759d684e594608a857fa9e9d36e8e3e5afbc979c97f2696dd623c62f803279e98b6e53175c6a2d1dd6bb8c8fdf7e7366ed4a6c18a9143879baa985fe567f271fc3651a678f886fad92e4090df940fb9e834589edef7fa78835d468c7d7296892e09c83be839d01702b718ab395dfaf1883667b27c42747ac1e3a3897298d0d787f04f5b052f60feb8b68b3ca83d9aa8c2a5c56e6bcdd85812a39e5f4cc28aaa9967c63dc4c87efd642bdcfef089773b29270576970ac1e8835079be550c471e422d2ac4609449a4d9504da46e4ecffd2dcb1b1e539137118f78300c84535a2fea6da9a324c6d66a1bc6cceb457bed3d73ba953f9a296db2322a87db10cdb5f3286fbb92b4b83ff607a353ef2ace5350891b6947e03ddcc5cb5e47bf0b15ce74b52ceebe8e6ea174d513b9a918e46577e83b7ed6fc62baa5092aa745771beb14dd25dcbcc77acd0f886bf3dc19ef24e435149db74723d73e0faa826797ae38a2367214f9f5836bcbbf4b02ff612a578f40af7cd653de0a2f90dedd8f6e85975981196d1d3296532fe8a207281a8d34fcbd1265c0d27b963cd425f705f01bce41392baa498982e86f8a6a4e148d4704f406df1321a4562db9e41c73cffa9b86097e9423ba4a1666c5ffbd3ddb09d151571d681e77055a73d45fa4fd4cc8e6a4cb63fdf5962c75f006cdbaf038113ab87b61ebea2d93c01acafe460e3a1bdc33fdbc5d8cb08fadf4c2ff42c4c905178f9878f971c36c9a300752c59ac71e1e54c2bb0ecfcead0b4184442425e4196717856f8050e56ed345635a7b121536bd2c91628011eed9dd5dbb3c3b8c85b60613fe889772257148992a3d45f52a0ec303736df09e23b03dce1c4e42d1ec990b598c2dede0b0f265a04892adc407791376ce4d32752938251ea49235cd368952a54e8ca1919389623df9495e890356d75e60b274b3a53a0e544da4cf2c977d7c3a56a2ec8a3e36cd9f8022a6439acd19f110cb04d322efa07869823a8e3763f8fe9bcdf1bf78a8978fd938c0c93275b7b44fd8390bebcba92d4c440c4eebe82773b94c965e8f84818c1cfe5555ccc7a5c61b2db7fa6fce6759be11a67d2ea51b541bc9daf96786ecc9032ff64f7bed8b9f8f9e7be5d5a8e102ff7a12d78c378448611b07914007c0c7140d80691a5aa3eda5f670c171c7aa2cadba11d2878e9d0fd74c57bd1e10a78e88bef98e97625b53a98b4dc249f1af580863f615fc1a9bbd672c20a3475bbb32c7cb0ad95047e37e46939598b0a6a7393a6449b9f5c1dfd536320cd86be435fd750fd9db1c5d7a3a807184351a0b98f0476562c3c33982aeb4c7a716cbd2fbc8db60a17e5abd280f9e66f5ecad13c88eb8f6457615cb8462ac134d2febc31d0bb679938fc41223cbee4458d2802fd4eb5bedab4bfccc3587044b8a5e0d712c35b32d007ffa02399dddb5f3eafb5cb5a9488aadb35ca18cb786a9573512d607549ff8afa05190bc45dc74cd8f90c644f3360d58215d6ad01aa12a2670f0dcfdced81ff62032cdb8431b48a995e4bcb8cf07ba5691643fd21bf2346487a96574372c7e6feb9f54b12c361b3541a3405237ef1a424dc0a17edf82de95cbef2f86307cdb7590baf8f1d831ed4d57eb3ae5a7fbdc17114c23d226f87842787c6a9448d5459f5a56e81b5695df75b8a923f8a9a8ead77c7f1f6a620aec407d380a55451e3e437a7e37cb23f649199d8838da225b52a9e0c001039eed0e558a7d58a1786af94dd0cb1893c3ae60d27b1ccbe9a6381bcd66e38dc94aac4c92adb53989d1aea72f88b523de52eacd4d37855d198f6f282c00bdcd2eca1711cbdb5926045da849f61117c668ce0c64b0aade4eb30f7ba1a8e6994b0e4d97a759a47ccf7cef99b1fd731dc95319fa803203d1ffce278a0a32c351606059c733f3cdbbbb63d34f1177e01ab5a5e2ac98c435f184e76ab5fd6f4539e9f5073fcd2be86457f5896a83ce440decf7c80669556d795a92d72f1f4dcb1cec7c043c0d23ee82df9edddd68f751220ca2c49c80e7a00565a224c7a04850b204cc83ac7ecb9dc3071d7f627a3bc92a1b4226abd65656b1cc03b59a76f19eed93c4f30da740b11f96b3e6978a547df3d5e62da8d4b60a1c819dd24b50383d8000e017e664b4ed32dc0b38c686e3cb546c22362d658fcc395a01b106a417c5554b55b68aaa168a635cf24b0c375e518f182255134b762fb2a07fc7a98c5c71fdffe2c8754672772e4cf852c4d50a95d7a17729070c92b039cc502fd5cb64c4cc29edbdb6576da7a6a7b1447453836fdc3d092553af18ad6331359b2d04a394f173320b09dcc5a3ed2f41e5009409159195f7849cc78f334092afd041693d6f35395356ae10e5916b08b9d3d077c20d9d0d4239b6e25656cb8a34744ae647eb20afecfef2c2ed5ddc19e1f537170183be94ed20f9e369b8d605880d7d6c5f1fdefc0c3c04b9121908dbf52ead99ffd13f81e25a3225ace9caa76e585bdae3c62465076e38b1a1326c705b79ca1cd2f44928eaa65e3b213d41226491b8af9311c17d5b145d114ac6b0ae9e7b48fca9f8d707aeaa33b3156ca9b379a08578752b03972d8e05b4488403f61bcd81b9dc6d0219315c9552358a1ee83c40664fea3e84578c0a26e6cfef5460b43bf2279b2952ac379408506ef91c34a1042ce508f316423fb5cba1129e237a9c24265d70f18b6632aafbf0c3d26c612ac82e2a862be09a54274767bd4c4e050462620eeda7a17788132de2d88ebb5bbc348f17988d7fd714e7caffd433c98c8e3348628378f2857f5b29df0f49ff5c81b2c03edc64ab56511eb85385afdc2d068b20f53893a0dfa9a59f0510e48c233c64b09a087fbeade4d1ed5b6ab6f7b9e1a6f65794d2569fa11fb7f1798a91952dcdea32cfcaf960fa4b6fdcf1336ada4d92d2ecbc711f7cec7cb51616f6d2c82779c846934e559343adc76b875c0b2bb2cb7e64e6672d5c6a214da5b042413bee3592e1f0b18c4121b9116591931a8d1d6d1cd9d8c21a2845854612269961dfb8d6bab7b59481962c9d0909dd4746f05458170cb4b6df962a4076843d1180911227a9005c3f83b3d305e8e5c94de27ae2e7962961dcb5b0734629029d8761fa8f3f71e7cf806904ee9852bb33a22023121599c624cbd403703127f35a4dee87b65c76881e4420423888e9fbed8d452087b646cb39f01360a08ff6bb73585dc0b7f2b0ba33ceec42a59c11a355dad846c180ec0931a0df08ee4fcbca53a675263208292a8ba84292536a98e2d77a4b9806cb522f18cf1ff05030f6a27506e97ac8c7ac18721ba092d71d1e45a531e22a60f742d1dafe872f7057a53db16fcee500235bc7d1800ba3d0c2227f615186951126202088abdffe0f35288aa2ef89108e14042fb3e6e95edd628286f4a67a91f85644f699a1de0350efa37296b6480b42e17919a882818325d80440285bc70f98abab138ed4a2eaed1a865f3dbcf7ad7a47105bd5773b645abc79fc0b5bff8bf8311badb64cbafdb1d201b043c2e9e4ef3179ab6135ee3e48b66edf3eb69c890b550a570c06ec09b76f5953b17e02d6d0320562e27f74cde484b24e806752aa94ec52290f7b3fdd98388bfd2e7dd875d26bece0973b7e1c968c128545c3eacd66a46487d5738e67973e382ea9819892ec2790723395b7b2d610ea9c83c148f765839ab9c6b0593d9275c807c3bb923403e1bfbd58e2e933e02bd292c1ae46b2e385e0a63249de61d0933b41d8a9bd05094135153313ad32b3942208a6cea087fe755f4fb072d5f8df1f267fb71d434b5471d45a99077994a0e85b30a9e55c446942b3d6e7dd975050ae33435dc5bb2aded7d02d3825aae628794648a6e2b15fe6afacb1cc75122676a7e9ebee1d231c9631ccf85453a8377da7672974c55c53b81674f8b794659a7611b80ed3113b1465b0c9bc7c7a6ca89b70ed0b9be63f2f2bc42997f794590d426d89d58c8f6268de036ced1104fcceedafcd162028b7741867035498f8bc0f41d4df9143f42ce99baa69d26ed400bbaea355879df31c3b0467cb2fdcab51a20be224d94f7f411ff9f72ee50fce1253f34c0a5cdf308c5cf7f1fc88d11d56958eb21c9bbdc05ff93432eef3c6289c3a47bc446b2b877761d9876ed333752f06b792c7331a56980518ab0d8e46916c7214774cd2349194de4ffddd7993475abe57389cdb7100458f6b85e395079900236e1b510f79f996842d7e828c8d105bfe56bc142ce97901b8a01151b80247d5be006f327338018b4161cc61fc03170925d26bd298bfee156bda411e33f65db7e60700dba2ed2d4da7d964f353af3aaca9b442580daf50aafda5eabefd195ed93edacb613c2783d8b10cb0869bf2ab4525cd7385c495d8d30e71c458524d77250075380b9a8a5fcfc973920861f5d8fca5620b55fb183260e237cba9394b4b3b13fe4877b066fea8ab99b2a1f1981f6fa4ae9d083a63d021ddb7810334a10fcfec409679dee08512e8b6b275ff4bb89069d5b32ec6fa3c6848a50beec79dad03ac883825a856ae5f594f10e99b2b30d649ffa01edd93a86d1f7348a531d54a169d91253e128d3adecc88ebc1f2478a7c8847cb97fe0791ef830927f746adcbcb45f22ee34be240510f9577c9aec2871a17af7e8d0a7c1b8940fc4b496b04d8e71e561abadb8b208848fefce04ca8a7f38d32bf2af70005c616c472eab989c9c45b6eb1ae22d208e31b5408350afd70d820f22e9218edeb99d6beff908dfbb9a333d107024ed30898fcde544c452523a28d2064b2627958bcd16fb3065fa2868bb4545a171dbbdc1cb6811fa708cf4260024977c2668bac4278edb579e5b76cf59eb175e8d03062a5263b7ad59464d3381f0550d755b0a2ec294465a83c39c2df532954f9cc2539b974f7f5eca894011c625a9da32c4243e42c3c3b07e4bca7ea69dad1f0fa21d26fd834c199ae8c2b37ec75f7eb7066c31338b75b290b6c392b258233cde213d0e44440332932888db4704786375dbd28bac32d4045c72b6afefedbd37fcce0ff84a4da51de270c0006628ce8e18cfc9532744ec5810c6c0f9e724b8d1a45418cea2ee457231e85a8b28712fd75e0323a868fcb0127e276b7f2a6780ca3789d0de9d62822d6cc74f29ff4d725c41c7e8e42af37189596949992ae4807097d5dd65c340d29646ddb7584f0ffcadd9fa2c4c86a6398753b0e4ac47da112eb1632aca41ab79dddca4bc714c5d088e34717d580361a53edc6143ec6448d957c13dcd5be48ccdc094cacc1ca866a25a0a466d386cc6af5517537b500fe4b5d7ef4c9dabef5cedf6c318a6cb01605b7c6ecb758aa20acf0a8f4ae56edf0ecee9b4c8cdcab4ab6f62271b1e3340a735f29b7fd11bddf26b472136ba0c40b4861ca34e8ab227580b3a9fd0b5ee388d797cad8cd056586fac71ee359c76306426eb921ff5916d7990bfe400e840ccfb070f37ffcbc6b4841985f06c0d4eeff4b722353a39a5539edcfb824c5ba58c9405b935eed14157825af57e57445861d413a93e4ad17b8a24bd088ebe3b9827d8ab75f14cb8a35cfa00b84b524ec7c53d32c6baaa2a474426832446595d77252e5b26a48596e0dbb3a4403f71a1d8c54503a709e9d333172216698b0f92763c8dc41f90e5cee32b435d675497c38c96a592dc4a59aa554cad58a95aedf9d26bbb53fb269b35adb4d62de3148804f40564183e35bccc6fc090c005fe2015e35100d66f519cd18966107e97a4f7c554c41c451b29bd55dd10a18dd88fe75f8e14015de8c7b16b266c54937c8202c48a863903654107074a79913501b96310383a96f8393b1fd6549b513fe24fe5b003359ebd4bab3f70982a0d80d97d468a9c2c68ea3d9fd7721db1402324ee05924a188626531c706d6263d8277b162655f05d40b0b3bd833e291ed94cab6ac560df03ae99468e89ad02cfcef219c416bd85cfd75a1d5ac6a620f9bc465c7fb197da826ac0bdce951d3dc0bd3c905cf8d970fdab1ed258ff25789584f6d8f6826d175635fd4c251f2b28755162d5163fc7e97bab94bc5751704086753265326b3370b9eaa2c35202cf4f875587ea51f2f8d179b67793af5488d2d07c366dbd76fe449da56a459f677fef6c5d9845bd5b9fcf5577e9e5129389c67bad7f315ca633d1e0ca3f8e0e8031f969fde79e36e0b2d64955b8d96efd60cf0ca6ad432b625148568603085b01046ade8d42d64c81675909b69d5c2f20d3ab521c2a5b06c3d1b451c490af30b36d3a768bab43d643edf10dda507568e574e7128442dd4f88b7777dbd002d10ea50fcb8ab889e1b0b8ebc87b61c82327f73a1b7a25a12f2e2d2d4d91dd9befad1b9fa058c4c705bdfe0c25417db72c5a7619cfd576707fd7f7ba167aaa49fd1a94f2bfde3c8daa0c043dc35de9f1b71271deb512b274b2a9a9f40aa06296455a2827cb10734d701cba27a52e0bc303cb7643b123f459a69742eb70de9e5cdf40555c0098010eb13fb31440042ff3490515a6a902e5d7b3390eb0ebc26d581ed07f01378ea1f3407006b98d4a18a595153216abedcb31c82c11eb0090be0e94ff4dc10f6754abd20caaa388fdc14982fb836e3b91d88197d63f891725a7a91f69dbd3ed25625e4f771b15c96a312e9310b31d33cfcc24b2f7b3df21a0d7c49207eea70185807c2f6b192611395a015ed1be4b5410d83f5bfad24157203ddd9dbe09bf8079b2686edcff60b53a69cdcc2437d604a441bdbde0907d873fab7a14806e37105d3bec9f9e0e02bc95a6e635d7336cc3d8994a66b988011d0d583eed0cfea771e0ca9c10e2e1caab41e30bb235a0a87412f5ccf0f6597ca091833841ceef0206b5e9681402ecba63fb6260e017240bae79b532642b7f2fdf10c0c3093b662a7a263abbcb0012b3ee87ff2458b001cb8457eaa237daf0c1f6c37d71136c1f72a173e8f830e44cef04de43b94628235ecec916cf28114b850a0dbdae45ec219d034ae2353d3158efeafc8596fe4bfd8b5378af4eaa06ac2310254a7cc2bd557d0691c3e30a30534cc7a34e145fa6f3e5f9403bdab87a41866934da5f73e6b8ed9ea162f50fb27b0f3f9d6583691aa20a4bfaf3bb396a264043dbf9ce49d0a371e338a85338c0a387bf36edc35fb5eb50174cdb228a3b8a2d0f646a5a35c5694d4c95509cc402826e55dc42d5aa31f788e162b6278169f853a4b2341d8fc7737ce4d170ef12ba9761f7b58947b45948bf0c28f9da97f75398c33f24c062a3958eb2a55f9d9fb879effd9e8c991b12683cd9e7f141d70322dffdcd670d3b503998f6cbfeed40df896e261c8fe4290adaea7861915088b83a94189a771e504663af3676be77126c8dc20cb29b1e7f417ba8d711d4cd0dba7c17053e68c398b832986e75c1af92ce73a98a9ac26852f6438afa80fca8735b8442908e8427413133c99752ca6c87724d93a77a1a7da2e4dc053b7a279f2fc719baa9b125cb7aeb702d03d4c4259730e164d349356945181ef8bc7115d23a58625829527b5783fca48d7afe86c116f4e982ed08cd5106517ae772ad90630ee1a90b86948797a3875dd83d792e66b2e63f31d67611edb33b68b37acba612ec54a9d93102ae636ca24954c009842c952581eba941b967296945a6f64d38f15042ec65ab1c746f0a46576b736b981dc589d445a1fbbee1cc553ce2f9bd47402689bb811a6b51be3576138b797f48aecfaded9ca4a37c5cb1f23861e971ee7af303f52253099cf6f61c48d2df0fd12220443da157a5c7ae5491ec61aa67f5c4d5c2e692eb159f4cdb90a544da50b827ed630b492396232f733a1f2a962739ca0db85530b838fb8423c6d8a518eeefc882836974f9c704cc072d67320c57567ddcaf682ae40a92f02f1f44a1e6c8eaeef860fb1958d370dd7c8d5267cfc8bb78dbc5b4b8a9bbf8c31b1bad26429fb539b4eaf3b4791fba943958cfb7a3b52979f4504f266588e561b8e32e4c289937ab0a5768b0a1cb012835e31b0e41d6db06f69a9726264b40256ea3db5704ee6242f83a93a6bbd23780c050f327535fb1e5d253901dc7c1f78ff5db5ee3fc3a847488f88dde4609de8d11271960c526c1cd6977ce5a7fb2e05a86759935a260effcbefc26748431fb7e63f8765401aa80d9b37cdba6a4a25ebc16e942d812aaa360b6a575aa548dfb599cec3cc6c944e149d60e4530badfd5fcd84b8b9c410991a154ccd4d45ed796d4d39ad2ed53952b553a8d69af98bee8b308c7770fd8da3be3ed92c72dac1ede5931a53420a7d1e1e3774b01c987405d591071bdebe0d4c5e53cf7f4aa03b646aae9e28728521837299120931afa406a70840dd4f06bc9a2e8efe03abe4b52b3222ccc7acf72c509e2cad1a11d24293a6b3fecc54348a3abed8f072ac32c0b934e2f5d29e7974a31b6c5c4c5ae4f757a500476f248a0b6f3f70110d3a10bfee57daa45d0725b18cc870669bc620f6d3da35a5122e05e853d2f7d978a83a261ec74934e17831842e1946d60bc86fafbb5571a099111368929b807c35cd61579f12a1e15fe4e937e71a05594a9c8683eeed34eb999188ec93dac0489c7c11341b64f33636a5dd717f9475ec33118ed2ebdeed23c3ecb576fcb13cacb9390097c92b574f486857b4d5e78dad3574538ac5163d94bfca0b2bf2be2f4dbe92684f95521e948531e58a2cea2f08a81cbd015d844e2c0763a84d2dd011e9defa44277a5329d5229e4bcb0bc27bd1401d4aaffd3e5e8481e87950821b916b9449f342f6de48c75dcc70fd70561c83e0b751b987247dfa96541305af54066b4c498147b3ff7dc3e2358f32307e4e44e04d5d838bc2cdbdd8125945f7d2b4596bf9c364a5c36288b8f84c35e70e242b41980d2553bd75bacaef1c43f28b861e20f3e8897768a95a0a683fbe2997006a672bd1cd7f16ff3a692ececefbfc1301ab0db2e2ec7676c1afc3b1701843362a6e734c900d187a7aba4c2cc7cc5ad68f45a5c2ba33503608ec5db687668fd5d0f09794611992680395fb21a5f194f413f7abcbf4ff947b263390f435a4758bb1d91ac77e48c2df879fbf0d896a5dbcc804962d07c3ba0e51d9080f3daa68d8c73a12c2bb2f51117839b5276e6a2270d8c4970b6d1af34b7bc5cfd1a3ae7c6e1774aa76b3c6aac1134c56c0736d244c5c270a94edb901fc1c8c7e466080c0b244a106eefc498af7bed101f2bceff61c07c34f5cb8916092f5b8f806f0b659981d88e371ef0a400cf13bd339dc9587f4ac842d584f9a1bbb914d0051e928b436654eb13b04fe4974cd42c2aab47635bb2df711faaf1c8d4e53bc4b92679c6322b6c8e56b486013857c763acce91130fbe9c1d5f90068aa0119a8b05ea0da7b56c755af42b1142dffb5cfeb537be4bd26068f1ffd6bf34d0483161b0164a3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
