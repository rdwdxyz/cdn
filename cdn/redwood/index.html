<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e96eb2ab1015a019cf6e955ee54439f5e4e1cc7762eb6eebf267ca2eb6e7b3bf4c416733c7db9812a30b24d732c0aad2d49ea09504a898e9236216cb6d2467fed46b3837cac25692deb4e3306bde7a82d55afd226781eedc71304d0f5a15a3cdf1525558d67bb13ede528fc7d22b577a1989ca81189e5b96b70df1e0594e96b14428ce039bcc0a691d5c4de9110b7f22a009fcdd9db4a69ad4338d5c5317b7cd32a9116f2a2f0caf09ed36849c2b7a8a615f486afa1795c4a37331abcae960482a1c2fa6c38de79d040157aee0cc924b3256d6e95365c1461a693535f60ea8baebe75bb85f490a43fc5152326fee9d6cd667d2a8f4c5a2c2f0d397700e513d1ef7d913de886357d3070034c1b08a126f2b75633339d051d2ea7dc088680fab339548b8fbd7c245b3a38ad64ea6bf762598da4ed7de2e96a19f197050b1a2d595ee5b90cc43a10d7a7cc98f7dea56795cb8df869ebeda705f1b86151b0e5c1cf5cf7157329162fd9fc80a8c276bb064611fecb6425e2c17005805016eb64ace9b47eddf7feb0179a0cdae59869b82055dba29ab8f691c4a0ed3830dd2a30340474b960b47fb7bf7e8c892a1535962ab49d1816228ae81aa43c5c6e952f9f90e5c53d59b9e1cb828d2d6c516bbd6e23a76fde916755a7c05f3e10d94ebb46989fb73d4ab1af08a6b9f8dc8f362e3f96196d026f6c44f65108c242d4c30d2aecc5b3bbde399fb63368e079f69d30c58348a693f22717f411b9d1a4ff5e3430c47b0c47c9c910689b21459b5f2dc454cf28eaee8c55a18a9286d37a4942a515b01fe141dd9e0dd2f4d7cf0d75e83f5002fc667534930ad66fda3fae18400b6468a1b8cf964df9e731c6aa3f0d0ef4dae5d92464fe263a68f0101692701fd92d43cd7d5447a08833edc5c5831430b7f76da35f7fd19d4383b9e7b0fe05496c5e5a09a366ab9f9a43a8d7e0501b33c40d4051256be4ff791463d47387e4232170f861ee3376d535b66e2402eec5892a2d6b884facd71a53b1ecf62e8e6851393710f5b307937459edb4e29b45ebc343ca389f1c42188df743aaaacfe6f6e84d54372312b7d470af34398ef69a29b8a2640147b7062abf00b673370fc3ad514915f695317245734c448dd7564095522247e1dd0d431901c436a4b06887ad658859db7fdcecf54fa0cd89a7fb429e2e645b9e7612443d93317b2ad78048c278f270efd0b3208364e6d46eb83babb01faf3e306cc539a92a70c5c8934659252e1b9c0c98b6090a4a52ba144f6933ad7022c48113085b501c46e97c29755483a33fff6b9f1d5ef8d1bb0a785bd9e77eaaea766a720f62cf76639c91a40472594e2ed6e3113c9ddf03d8958fea473d47125ecaf35bd7c2104d4b66bffb4480057df1333d7a0487354dc78834b8ca482cb583d05c17f9cb75bb7bf374b6ca3c73a4b2f24153464ec13aea4125e6a2a25fddf8ac5da36bef311012d7af8a7ad5c6c492c57e855114eb758168f3682d3dd44bc581da1b912b45502a5ccd5ca2d0e439627a6072e45f4cea7d43b4f78eff50a8e37314f8eacc423bd64a029ae92de606d6f3d2f1b767f154f601878488dcbf82a888a712466f2f9f7811ca1a0a7277674981daceb28b5cc4d30fe07381c971f97859b0fbb98308d557f96ec1e3ac388d1d641322f51adfce5e5e05e8122e648d51d20432e8ee8e8d7c93d0cf132cc37138788708581308f8a0d84e80efc7c8c303a03b90a0452d4f8fc04f66b153e2b549c701cc85f6adcc8187bb6513d94e79d9608f0eff3ed9e6aeae439aa4e24a7e6b025b3e0dc84031a9e826dd5723a06fff0418338e1c929e2ae827c971e537c396318f84d8662e39a5dca80eb5a915b7b289242c62aa900fd50fdaee5a480ff6dcc057b09e573c2942659a64a284a851fc8e22c5f08401b04fb62f3f942e2489aebb9bbb39338aa7129ef92f9ea3422421a41ef4b93e6e4cd413e0fd96a7befb7ea8e2039f67b6bf62b16e56bbd87d79aa75ad62de04d6ac542268076c825b45e3a08be07a6969e0f2e7110c8302b6466ca6219b079dc0611a7dd233bf20734081c42245ece532cbec88e61ffe618d3c08bc2d564f0ec2ca6774ffe9c8a0e8437d962ba2b7413e1116d7c0bb876d42d847046c74ba41b93e6cea39d02a52c11f4f470f4a6a5c38e62dc20c3db49f2d14c5b39bf7a5c721b78407dc4e3b9edb56e073a14a7afd040b38e264eeb4d9f52311146627e573418eb7a743796723ce14d508f0af71d1ab55561049907aca7041bc8bd5015fc57b7d3eb6db76ec28cd88fb6d0cd136af3ad341b4dc0988f52e8ff0d21568caab5ac9d41cf9bab96b3aa14a74806fd962b7fcb8b84b0f4fe3ceffd00f5c2f19371c7aecfe6437b9bc3d5e6b4f5919c2ac824ac37257a410abf30324a59cdd8e4dbe0637c19163a2810a9cf03d830c72dd013e7a9c487edb4e81578c70353cfcc52765752f1870c85e789adef33ca679449964139255de221bacf81f83e4bef60706869402e9c478202877fa93c44e1af908032a4b191c5c113fd52a74c5d9d53e2c3fa7c057e1e25124abe4a6f0080d6d49d4283b49925369fd2a663dbe07b18ce39d6defe14aace1e79c54feb059aa7464d9e58058e9ef79e24ccfe4416537af7f0d1a1e2642c5466587bcad19e22d33a335a39479a6818ee85dc11d2193cdc0ca5237c97a19ce0c263c9a2bb7573fabd9578d0f4d5dd2c4afc96ca0c087b1b5f5dc5e49c673423419cf8c8b59d72b14ebe776536d911889bfb67296e5b3a74ab7b9a0e4e18a3f91131af785df1d9468986dcf4e102c090588cbf778ea70d4201bd8256901e25b6f4ea9d38403752fdf6c2651c191afa119341dac487108f6023a1440abf664446ffe100a1a5d7f8e8a4dcf3959c4cb9e4cf8ea39a58b7cd55117d5f447c6cd10ab6cdfe196f5b9e5c38b19519a45283c0f430ce882039adc68c0000cacded3c65c1a0ab4404b9251ee1b6c29e3a1dc637b3f6d444ce8c84d191d69bc967d33c92b89be3257206fb951e9c48e38ec88add6f3244d44fe7ede55a00d45d21be956f9bca103504554df18a2f2329931150dd4921b59d94cc1f81a1a5c6fec7881cec76b2091b60a4f5bf3c35d4a0ae6914299c24b19b309549234e7a4f1fcd1bf7d2901c1bf2927aef22620efff38684293b94f9df62953b772d06c9c43f7c2f176265161ddc3dddbac526cb299feb70f17ab691bcf06061049e0f6a85307a114027fa3a480c10ca19a60316f078b9429202346659629f97310ab1c03616cceb87553e66d61d2d96410226d204ecd999be96e2190f56e38f725a3d6bbde214a45b78d926cf53d6cfd1a06292dcc8f7c327b37ecd328a2cf9f4c3ba3b8fa6d2296c5cb37b855d99070d398a94c87737316ff40cbd1482e458dabc9b9566b9c733f93f2b100044433fb35f43b95ad2e0ac87b57d3b56c09f1e9069082d1edbe060caf34c785623b5569863d7a6a5b889c05a02f7286ca63c853ba0889e97cc98c6db94c7285c050208be825d08b6f5567cac3d90776b24eeb6bd2fc51d4e7cb6e4d84830c845584f69997c2ad235c2a65cd96107b2c973672097146d3cc4a7a1a64a4daf1c1541275cd54322d8bbe719687329442f8a9df529cc8104249269d827b975bd809448ebe13a299077a350f39ee71eda93b99afb9134351f871879c3d37adbfd954c1fa9d28d3d0c7581aef65fc4012b61987b523f9556c0ca438b2bf1e84bcc242cf2e55f7c60960f607b1ff30bd25403c42c55df4ad7288148556e7ecb06800043e1c3d75c5be279e41d7a32cce2cf62848f99ca76754d3f7417513a8f9aa8538844ee057638b36ebbf713ccca1d8c85c103dbe9410df1999632fb861a0225bdf211fedda2ef4d0fed2fdb5bc8a29771c52cc7a935e77ad9d783a8bee712dbc7abe112e905e28bee8b7062f14b5038e83c912b3c4611af6a44fa7bace0a551ee225a8351fbca5950e9ce67ce7ad96103015215f8517b9731ddb8ff868e3858ec8ef77df01e965c4f1a5fd631955adf509e90f526c9abb5df967e648d373927dbe2fd7e2a608708502bf22cd2eb53643911cadc812aaf2b2a44e626c589a8a2e18348ec47c4002e63c1c5b1a49467e9d3abd3243d3c05fb1905fc83ff84a5290907b21f970b4d80ffa1d4c7e46bd4583101298aafdbd0820f023d6562e8dd357527733d4a3cc5e0b337e358feeb9662ff3cf2625bf0cc78c4b59b55644a2539174919b3f82b9ef1ac0f06590d40d79fd182c66b699664c1af479ef74e37e4587dc3227313cbed3216061d5fa1a24d4558c8c0993e4f0cd86c27d365b34fce9cbf2919b0af81f4dec01797273c5f696a255b4a4f7d28c393680cbb1dca28babfc1c84dd28f01f020af9d8b5168f5e42a6dc26f152f249d6a9d411b3977e5cb20e29f47e47dd4895347604f486ebb50daa618bd6da2b6185d1b3a6e59dd3e4821364b1ae446e564b074d3df6b08bc105f327e0b0c81bd04de2672a9faea50b8cfa046c2f96b23f166ac256fc70ea3a670ba530c4aace1dac1d34d4ac3577b8fa397e832cccdbab697734b19d90b0a1ebcbe831b6c7397f02f4d937272ea4df6df76bd0f2bcd0cef5474f9bd0ea7a1a99f8401059c2d1c5f4e623c91f448d506216c39ec6a4e4c4ed55a7a9fb83769fb60f8d038e7906bf77ff145c228997a63cccf69efca58536d278b586298c8f1d640ab2100e527eb9df022f15b96509fc8a053cea21825389facfb8627309ac5b2712fd56629121c33c11054f613dc5d64ece7a83fe4f01d123b9234ebaa62ea43b4a93dd4d40b9d99c3113255430740e6419663cdefee86ac34dbe48dc1e481c2365f049d5dec7b47947bec4ae540209361d6c9875706fdfe3107899df221ce7ee1d204b84299ff0b8a37e9b5cd18f7dd7d38c73e1f9bbe3f3caa0cd7cf2800907391e5a84c05217c0e40b9e3df5be30a70edd95f3fa5f3a0a38bdb56c44b05df857acacea3857a7d88fb7a7ab91c6fb19c2bdd6e73e596a52f229de06971d0759d0e6ce4da5d0f12229f63625052b4d717af56f75131337f6c8f1556fe65c6d34dc6a09aca81b1ef452635523d200e13db1c3bf9c2a5b762f3f960ebdd66ad180ba66218225b6a12d4e0c124c8bb5641d20ad0e515cabb4f5fef92dbc7cf0bcd79c52f129d3ede760f623e0feeca08112e5c1263e17153db0c7fb807cdde4fe49c993154b3a9141e4500e6e0cecb2c1d5135f77451b7eb7a76f48eb012d82aa6a9d60edef48310c71c45dfcf031082360f1ee4986ca33b7026bf56208b4acbb56c74d1677f8ebd4827c8f89af41312a7dd1bfed1ed502087099810ed0a7b87a16380f302046674116addee2dbb5798073a9737a32dc44810e9e06b135c665d5db60d84d73a09c1f3557de62c1631fd061a38f7db93032439ab4741e8fba54f1d072b2f570734acb5d672bbdd08514a793817b19b880001b60e907c40929504aa0c8e36fff4df0f3411aa4202393a2c4f58a87f76c796c01ee7df35924569ebf53df3fb7312182a12004032c58a133871892aa9c96a1b76f63f447dc2a873f984655cc4086bff636f139e7520f444f642435ea898401ef71246f1de6a0be57095b5630eca7de6f91c8de058e4684845d611ae049c61df0df49997e7df29f96a9f3956cc1948a5535bb82983eb948218f128c526c00b0648ef8b92fc04c3de4ac3f995bc886741990be31c8254214c5477900b18794c4538a988e4220b124b73e60d072a1400ad521e88e2c5805629ec86c8c789bbdc0fdeb7ff812882ae9d447e55ff2b88c7b41713b3aea3c6955b6b6957a1561417e9eebebd393f9978772dc684e4b067ea5d692c0c5a472eabad480f144edc207fac3da527c81e96952fd0bfa1a5602919091f59e9d126479d7619f46da8bc72d81f332ca1ee41b9372dbb3e95389818b02cf46e4b53bebf2eb65224ffde0b60c04e40c71500b1a3adc6870533f5b9c7c45fc872d2560f909f1dfab606b5040268b3e0a5264ad64791bcc49cd166e452ea24059b8b87e656340ca85bcfde65c7ece3092f2f3a388d74f100949ecf3a0e600bba2d8b36341a70e0af67dcdace5636adae8435621d17c6ae93c496f8388354a526466ecc6895f2e849657c29ceee6028d4f016ea5677a6a9c97392b7bf76d99e94e8c24d536ec8e32b51aac0a8bceca3cfd563e6edec86f958350f943af514758888335d5fe41aa0644358fea5575eb62f22d8cab9a64955cf99029421aef93156971014fd529db4a9e100f7bec94f1c9c30784d3cb9e7fe58806f3c6862dda9f3d7381ad02b0ba587336048a5188666440fb88c9e9c123fad9389909f654eef4de95a7f3e1aa1bfd5079fb1478fe2acc94b7d80a7ca6800941836ef4f4d385465a3a0134dcbdfec883f0117daa5f689e58ee46cd7f7cb708d120fc781dc474adbf8b48db0b4293758e9d8ea7f6601d0e653a083a9a86fc9062cfa7992c68eea8d13e2d76b1be862d43b3d2cbda5937248ead2b1b40692e09d1cb1a172501d0b1f28b9ce0b9a6350ccf49ac4e32f8a11f2d10a9131fda15a27213c80b3a5a490bb2552b8481ee8c5c87c017113d81a521823dda5238c5b90b631450617592ddae914d329ce28adf1be06992f76a26bfcd5414964ee9b04d42995a0913cc0b6466c8f7da615bb1c713875abce6ca9694292ec4b76f15930922c208ca3cb24e45e09fc497d8ba5b773cad67fbdfa8614fd0a581712a187d8d868ab8cff865323134934f11a8e50860b975721da2de244a7c7b76043d490ab0cfdd7d5161df9ac5f75a54f74db024329f67af92c568e8cb5f5e6031b2733a8c983bc43431c47f9f6f7f124232e143bb13580d7aebc2365f15d4ed6d089ffd2a481c0a83f156b0e5ca0307f3ba3688cfad108c482c97636598b91df0a65b31e6c4358d78795b4a13748c83678d2aa3fac209fbe33dd3d3e5fba170372e8adf503f147e7b1a35b4050a8695aa8c34c1d3a9789a0eb7210df866284d180d4160ac499fef939010e3ee4b51c0dded259a07705ecc1986fb1f21186167fded0a8d44da47242e802beac5212ecb8d15e8fdf9b286c833f593943f631e639361f98c1779ef3e63c34f6e350954b398bd8de6d25291535385bd875ff9d791d9d52176169b9eff4a41278913e704e452b704ea226a1224e9032f90553682d6fc118f74ab7df6669165d50afe0d1b7a1d3f9709814b0945377482cd70fde899f624ae08cc76752c508bfa92e4b856d6f3ca7c2dc648a5eb4e94285f5412ef5a5a3e1084c2302c0050de4d3113c4f2b5cd1ba99923643470a5954daf0058ae8e74410a461f60a29f43c83ed3a85daa4263db648665029b1b151422e975fc1df858d1578f066ea9f2ee4931deb73f89cd97b6998d3b9d5a7956d5291bba70b3eff134edd31ee43a0af1ef510ab99640435afcaa55b0958fd45d1172609ca3922977a9500dbbe814c287267dbef5fc53fd79746822f8f35a84079f9efcdad1e763c4c821bba4a1088422f56414cbb45cafceee28e7c242841e063f8b096cbfe32323aea02e5bb36e1a8a4f80b24d0e481ae78e408a4d693037b43db1862187d4ea9e6e04f675422338258e258816083bfc1ffb0835c3888bb6fc55da3fdd2c479cd4fa3ca0d2c80907d23ace43c42b6b761d200793ab668854a1cb387e33695a1149d8a18f847065ee38b965147b1c853cebbd4b56a25d5f73575741f2ee83f03ee6a0f544836de31616b6738e5bb4940ade719cd3ecddffee8cbda27729ce30288007ff785828636a5007b1204346cc34ccad0446c4425f7a76be8b9a647fe35c250c21bc602e1b32d207a0eae7e5c174f0762c08f603c96ba2cc347660ec971a2910d5c26126855a0d737617f96c3ee864fdde5626e0d1e7eef98268ef3ccb8ce2d613f9743cf3055855044c596353b8614e613fb6043189e30b78d1a0b2273c8f69bb8f765a882e1683f461daabd86e6e55f1bfe88152a647075fa70bfe77b687ca9a60a2f4e3a4af38d7584dd778e78913a8f00a97e11f6b4d9bb0904373997848c02b72ad6be0c0e0b98e738a935b18fb229513fedc7ca4f46c34cb29799355b4588929a6a77e69f21d1f21fbb54849fb10f19b60247770150acad073bb304328125fc1434e0e3cb8a00e9ba4d732447635c864ff9d7716ae9755d73ccd347969637bee3851053619b917a66a5a5e4752f917ddfec8b73de285089c8f6f1127514426a46b7e3263c33912e331df1e28faa27cd548d3db568f7d111c13fb778bc636fbb21ff407345bfcccb5cba68d147bea5821c5d553ad4d3cc2e2efe90293787f74ad1b4c87964213ac940c918b0352631560f8470723b35049f82b644ef53beee9e3e0b107589789feb991d5a30096d71c6eb31a49a3dc16374b98edaa0b10074357b2461aa51e0519031dcce9f63edb19f0c4f5b80feed456043c38ad6c52156b8699ffcdf8ddfde1a01d55a09401413303de5a893ddc30cf2e12fbcd6688c838838b50ae6986b27522c5a2369fbb3b85e9b4648d78ad76f1b048a0874c5785d717d7d564ab131f22ebf9e5f7fe048af72c3d77b3aa3dd3fe595ec8b6a112937c6d4d1f0f06763b6bc15a89d85ea375f123aae3749b6dc6619ac50c990d20c7f0b596bb7721d7148fd9685d24b12c18e6484e95eb58e7f5fbb328be99f830db61968692bc7bab9a83a90a78e7b27e4542f91155ef5847b6ece1e1160adc3dd5ffdad95c9426164033d29e482629b366f3d697eecee001fd198977ab624b12d4daaa6860bb424e8776d696a5be189c90235fbd2a80ca726b57654308a5f3715f7b1624bfd95ac73e5ea2a03a4c43c20104a655831f8175bd13f353280c19fb175a62724433c599ff9cb3375f5a1c8c67f10df93d690b68a7a0f40482922ad67842cc17c6f8e6e24bd6f1e418fecb98a47950c1e10d93a16a4d79c941322b28945ed27b4c5765876c5006e8f81cdc5a17362d5fe7d840ea0d57990b26c586e4c32c917bff8c09f0cbcb498fb4a4b7795657d1a8f0432cd7c0b27d048596e4e3e352af5148a56f5f412d7eadc41b814a098ad8d23431956d86db57e15f2072ac3f9bc9017b00ba3979050dd8c68f22f337754797ab453a8fca9da112de7fea3d0f166ebd2822b6556c99006626efbd40b978594e97b6dadee93f45b11353acbef1de6da7967dfc028b3a2709115f949843c8868cb9c20e1c5dcc26e930828c737652333d88a9713e94e56d3345654360e5d67e630d82c7080e618dc819ecef0316fd4bc4760c745597cb55a9f34c49049fe723206ee6b9c6c102f8494b5bcf1165e7a47af1756a8a5a21d45c5d28d97c8ac63c33400d58cf69ef5ea621f128a8656973c2965b06a2c516ff155ae424f8cd515b12a6b22a02e9813f61128af1a7868c67b1b14945dac6fa86d0f82c3bdd3002caa8678b79f48a4546afbe9ac2a4af100c0d71e90262f868ac561a9f462c4d3400864c73c67bcc49638528b17ac860640c4a2c452938d1209307a8aed49570779f29363c27dc9e16015681d067c916599b8e45eb22ab7272e0ccce076d63e98e17c8acfc19f96894aad561bf57ca96cf8091917e02af60024b20c3b23548e56dcbf87e87b9d835afc5cc5bd868888426b52f11ac018eca3bd435025086fc617047e1b052d2f3f821472454bb0619c7282a4bdb962dee8661741a24d39d542b5722885fc6ff9db09ef700ec4d2bcd00a83442e23b36c1ee164c1eedf1ed67fce58cc97f8286e95ee7d8cae92f1076dc854507341fcdd294a50647522b6de057baf8811df4b4e1e37c4c403203f09dc3972ec181f7e87ed8fcd613d10983bd50aa9c1d5f7381dd615a38ef579b76955b19e187404c5aa39f5b166f035cf64cd2472d05a55be530fc11e43a98c9afe3e5d1f741d79fd4618ae066ed070b1298557e2d39e2f46ba11710ac3c579014aeef0c4c549ab04acbd6df564297dd493f07b8092fb5b3752b143a300b4a075a9a8c304308a044f83add476b4cc18f37d73b97da0f8f784fd1ca9e49a759c915b2b4dee36c36ac2a5b5e2dbd80351f94be72ffc27cfc2a5b9f6f58c5731ebae75cbdc066fe14b1fbc91d2e9f9369905a69ac36ed4dbab54a8588786501a3e3318936b0c84da6e11dd5ab6cacc27cf6df6c21260de7581e33b27d5e6524572efae5a861ca6c74573bee453be53799c79d0b644d2202ff32f2d93906414f20245527bb9601353c3bb375d2e0e567cea746fdde5384910f95e1555471be034e1f3e27c3bb801768e72da48a1f66521aa1e33f6a78520fb831431ac98430987217e7cc34e8df6b6867bd90038479298fd9fc63a0232dfbe1e6fbf7caeb76c3d88b970807a16f8c35fa181ec4ada79e6b65a4c98f6e6e36763e575a4989c9f5f86ad7e235ba1c3eaa35e1c69cdfe7d697cd8839dad0192868d2d663604fa697a899b71804ac24f4ca835a8879d9f0560949d9dc5c8b355132463817e5881573a063eb836ae480ef5a66199efca00bb7219f885ab7d4bb85fa1d24bbb0d1025d4dafdc803deafb625be2c810e56a2f4e5f3745b8a5e30a926a141f19dbba87037247d04430029848105211026c5f841bf02cd384c6ffa6972430a0f1a2f0f023d2b9070624d17f73ce96fd9d749359c3c4c59381aee11defb87ac7e6373ca228abd34d35e7da1b3e1e84036893acf84eb9083171e2539db4a6c18b1d4fd3743fce501d16ea67c5fd7c2ac6685852746bf21660b2e40026211302678dbddb5acd1c39ea42c777ef9b0c26e9154b560443669e0a5e2d97ddc9f03c2d7db080b96ed682d0558394a90a4b987a1fae21fd8d814ee5fed5bed4ddc71783390e2c0eb2d061efe96450e099d86e27c4b6307bb35e722eed7cf4d8d806a34fc9c474f281e4a80afd5c5889958b4d6cbfb80a66106545322eb0fe97fc031733ea16d369d9d907743ec2c570592b2207412bf51c4e5733fd547e6736d87ed249602ce773c7295d5c871badd2efe8f3c7c19a52e38123439d98581f881f020c57680aa37e7c1abfdc92c91632d2d62c2d85d860de975ed7d63f6dec0d9fbf3ffa6a8f93a9955c0aeb59bb3e4a8170acf79df3363a7cc5430838abc58fdd3cd5fec4b68c5a942b911ea2df508fe37a4596cd8f7ebc6bd7ccda441385ef7466a59a66b1e87289700148a8356b8f05c554c683f5e5f4c77cc4d28638d48839a69999192edaa9061ce698542b47e13ec64a35370c226c0b8d72ac5708776b354d40b095de8687eb9c9966ea08d9afc7e16bcecc772ac408d21b61f2d52a1ddd1270c44782ec6824b710b425a4357b9295256b1b408aea6aee57c1a3e657625283ab6183d04d5b1fbf30ea2a4e6ea9a6b484fc715ae654ddcaa602ee39574f59a122b11876e3deee70dbbf16d0e19f387bd01d41a9078c7db8cff27453ef9b277a31fbc9bc05645f81e1b849b8cd135b94063c38b5c6df3c3be5c1088a02e19e2196c56fa9ab9d4b531e283b45a1960f422b1c680133074dac39de4f9097aa2f8d2ce3aa2489cdc666d9aa4c510d1c50407e3a4611204208c43a165e10ef611ee625a178cfd0f00409ebd6ad05cd70a4081003801811befc6633db0d75cafcf9e3b1e4586c1aca2f7d8c296985c05e2b4d9067a801cd10cebaa894db56f8d5445713d6b0c8c7c784a0537d7d8b1e2cb21c1160f971a0cdd6805d9b03204c82fb36f910037f0ca5e727db0937e1cc44bbc4fdfc183ca65f36fca8634dadcb6199087b7dbd491b4b620e526e2d1c32e2248e13c7927b308e901c416a0b480bf37d634bbdee491488e4d486c4840c7dfd5456de61945aa143892d2f04acfb2354071b19bd5d42f3ae5d37b1ca006a780a03ccbd33d7ca11a1b07e97ddf282e1d0c9af28df99f632d944e1ebad7e0ea0928b7062e1cc41beeacbee0b9d957dc0773c2118fc5646ad859cbc396799b8623f9e30d912355a15d74cbe1713184f2f633d3b624bc7f729824a6aa898efbad0da855e5d27557881b2267df7a92604940d0ba6e40513aa84269fe60013c506bd20abeb2f6c34d16482617f306458138f224c0745f4b6d4ab38ee3bb5e6fba5a526261bee80c6710ab1aa35f6042709bd44c14687b59c1c22b16110baf20b86fd4c667ca4a3b67da767b8708d049cf88b14ce6fce17a0b778e795d62571278b76d6118579783e13974fba1b95019cccb6ebefeb87d4fc53aa972604b7e8e1de789241df0899c17f13fa005e207f731b4735484be87c7757958d449ea1cdc3fbeb32c215127eb43f4eac161d26e5bdd4ea07158903781a59137699ed8cde46059448eef723779e4c0eed784af47fdda90f034d6704140580b391ce154b935fe95b6dac8ca6384bcc6e36d3b06e7a242460a4f6d67971c2b178e685f33b6bddbe0a753532c040fa84a1371748fc3755dd8a98de14b1df5372f1e42bbcc551e0d716bd2c8f65c4ec57620284b130ff3e91de78cc10b77a12b7fdcca402ac8e553f506da8778de7a742312e3c12c437bbf48b265ffb36a64345c356d0b0883fb93b0bc38f66de3842b88bc902a8f2332ad78b7233768d65041d41fd87476845d32ea3cd810198cbb4b7f6dcbc4a88d0d193d67b19f67f1f328a6a076295b195d8481699da617cf9bd04e324c02c90810955dd56896a6848f41aaa88dcbd2b75830d50a21e55f1d0aaa6fe1bd79524b2db98712e7902a2af29d8659fd430e7718e886aa4d74aabde1fe3865ed2892ee6b5e8d22b12594d853b07ce1f784e7816e09268dfed652c072f385db191d091387a37c146c07198e8450152a135dcf5c44e340c7ec7d7ac4e67a3df14214d20db9a2fe92ac1bc1c72b221f797cb55477f31612f4af3634e7a747c247e298a8bf1bade5960809cca9d33f1a6c2cc763788e282465f6a5439618be13c1d32db617801457a4917d633837e1f8b70be1393b8b7fcfcd25f12e1b14d6b7e61470fc65a3f3a7b79d49bedfb7789a0acccc0322571edc02c2222e4970fbe9216ee33bc5394cb40d4cc6202d708c1785b423b4c2a6c3fbc2e3879e69ced242b41c5586ce657401431d073460803baebb1ec2fe69db6dba10c8469cf18105c4355464860a8e7cbda38f4229815268ca4da82b98cd6310fa66edd4ab8426ab5e247c5290e67047af51266e6266492ce53126f0ab445e7e4c9e6fccdbe53bba86fa26c0f0fdbb2d1e6315492058dab471dd373a5f175040ef78b0d8233a3037e3198de482a624d1c62f3797ac37ea89b5ba6d83a631729e794ebc835e0a1aa609004ab98df52181d6e8f9dc158a1923b2f6234788bd4b621b3d32415f3f998ed0fe95c62f948bca13fd99b181a40371b2eb2263a7ea88a73caa8dfad13b4556cf5da6736dc0c1baac1c551ac91bc8e9b8f6255221a5e2f4ca6f4c9f4111c90a28c6e8b0a2b34faf8b2b9e07d420fb0fa148c0a201ed5196a0b28a53ff28e4f59f9c4a9d0f80a0a86b83f613c381c8378e1e48f416cbca56cd4bc803fed23ab2ab4c92b07bbe61519b657d50bf397ccc10f773268506076a389f83d807521805a38d5516744a4ab4d9c1ab2a0315bad8648f63e706e7b61b0611d9db4e60fe3f4d85765d3ac2927a13cf9be74e0ce6445005aa6c860f4b28d0b50bb2e87e61e40cdd2b793afebca5fe30160c7172590d543542b4defd8a46f39ccdc8935bc2919fc4c6f85c5458c958ea0fbc191b60608b674cc91e72f8350fc272e60848c77d895593a5868aad6ab3cf04b137dfcaa0acaa29228918484ee31c0fa1052ed0721b90ae73b5f64ee336066ffb0a27d60e78fa43a46c18698337252cb7c0ba75a2f4c11013ebd1a71f0e99b9956cbdfdba5dc2f985da181e29032abf6b0cf18e0bb13a0b3f76e4b5f02dc3543919f44106517169293f8869b64fb0f49d36e5096dea8d9dacdd3991cac36a9f4bad09eb054d4fce3eab0bca6007320d8fe7b8047d8c9b1441946dcc8c59538bee06026c43e79ff2698a9845cfa3ff5db3306591b39916e7b4e4331717faca69bf3889cb640be1bb09a0485e6d8677f10a5f30b73d96badb26e20bef80175b08245fa03109b2d5f7d8e9f16f579341babbd0153d12e65823a87ea57431319b0ab7f7632c855d09ac6a36fdf92607d8c5b301e9d4330e0c9b1a5eabc25b99941a3560f59cc31e9b73c784fe43225cb919b2b4cc864aac1bd39afe725e329402c0717722d1bf35970f9948341eb3455a2a529e65e4e94fb60353cf4e7b344f6b64181fe34bceb3c703796512ce60fd9809e8c6594ea45f619df4895677aad7c822fed1432d58ff892409def0d87da7bef8694d53268f0ad5408635aa33019e48401f4487eacd05c6a28c070c0d9444faf11d00f0a7d56839a4c0ec41204ac888417092afaaa0444236e669c59b5a08f7ab5d8204cc379d98cd94c1622f943c0e322c841c1e058e5862456555e749e91565f52221393ecd75fd3b42abb75329fa5785c604420eee514ce65689810d9b890d4fa5cf0b154b974d672c0d7f7371e016ea13523f387114def73653d2b8e5b6ccbc70f9d0ccdce03d8d62e90dc38147b4b49c956e7342ea0698a93cfd834fffbc098ccc7e36fe0959310acbc3c76722b1716b960286cad30390c3e6bae830f3829e348e0d15bbb0d9550f161f2bd106628c98ce47e6d3a194d2734c61dd7723ab4a019feffecb141c6e50e87758ea8f0d003b4c38c0cf26f95608e8252c635d38d219bbfd7c88f489b406c307f68cda596b74b6489b154a3d03b3b6bdbe7b3ff20b225b4a923729d90a1e5de8ec1c0401f144d3d352e580892125fcf87fb927172eb76517a97f5a308a335f8239ec4343711d6dfb07c653f54e29e3bb5b55993e047825adaad7f75def06f40e01d4c16d1f8a2a486c3c3d9f33bc65784b989c9bc0030bb071f266b015e6c71bd1b0af899ccca7309e875b07bbadbce090274a1db006ed994b7a5f74c6bd9a732bc74b409311c30f530e825d3b49fd01d5226b514b36684c4e2b24e23dc975d75988853852eb53dfee5194959445641b52d580eea5412a0dcfd8dbdb55cc500fec11921203ec1df58a6c5e38e68a3887d29172e3a5434193c2de467b1cb1e22c211e88d381fd6ead3eed092ca46a2ff4f736e5781dc38432728d13a52bbea1f9aebfb6aade80e4cf30b5558691b2d18af4056535c7ec2ba539f148a4b202aeb1b5c652fa36d12057f0b8958159e7ae87db6630ccd930ec941709f7a984e0333a87da44cb26575a10a0a1cf4ad5c9b1aedcac5a5b4b953caf6601bcfe6d2f4f25185547fe63c315b8d2abfe7cf3f09f2fac7bcdcfe268f028660749e49a9a8e85fab70a9a10b2f525583224a2adb2f92d845c5fea9f52224f57a2f8245ec7cfe0d7543ecc18c63006a76b48b949e4c4d537d10f47f33c13bb174af1332924d65abd0d721d619335a3a49f56985ca53dd8e70c3cd051970629e0dd29b471537ea2d51b63cf62d062bda48bc4cf70ead6841fbdebefcd8eda730c7ad9b2fef5f5f3d051a898aea95da205a8608a57f49ffe4f68eede0e2680f889b848dd09ce7c1acd606bbece1ee0dcda3c95b3da04b65cabc80fe349ea58fbf5543987684af8d8a8c6ae7e513e357088b79bf9b4bd7fa4a0798da02a0e07162af2c4aae834241f80f5ef95a594ea69be2374bc50f64bcd764534022ae60c5ed6de1336f0a6d498f3b768bd5c6ef68423bdbe8fee760b16ca148add49cc36e87adc36c5b863aebca91132779ca79ac7051706ebe24f07ba785bf8a7564d94f86ba4a37845871340e1a1e530ffc1b6f97cda2d24c45894d12cc1e96b0e7ea53ab14c7c0c151e5d2e52073447347df5fd6faf3c7b4233a18ceda2e7a9a5c31ba6c1e6a543d79049ec8be5ea45633dbbcbf51706c45211b0542d4103e1da96a28769cc0d298a0e1902d70d9aca0bf91b56fb715000466e2444256461f558d8b1e274e2d0a0b5dea75a51188f793638ec13e70819d79f6c4946ca463e5f0a4ab58c926276d6842a050c335680207ffef131baf9345061623d50566215fc7793ee37679fe342dd760f0041481be4199b21675cea6508f82e8f128fdac79d48c7ab0330528173a57a34dd23d90b5d84f684ca4a43f877bf9dabf7058f79aeeed85de1bd59c94f46282dc127a9e8ca98282940c5960b44518ce8b1c8e243e6302faf4c5a0bfb61f3545ec1c310bcedbde1d1dd037d9d382989377f5e6a22b2f43c2323095993e2a27c3d95f6d888c02ba33a470f71212778df53794420c93f1161cbb9bf553c8c36e6631c5320fe5c2478e867882ef2f26532f7701f672e2914c833052144ea676c75337e9e54b860015409071d4eec45255d63ffdc87fe57b93fc520d71ffe0decfe694547d85b12b95201d93bd217a91bab4a4d8da4947deaf09a7183af1f5b8fdc34e93bb1b4d4e2021e87a7857ac412954464007e44af47657d41edbd5f0d201abd34fa6455f332329caa094e3f3219c3ace78595e22eeec13bf5aef35385b6cdb0df1ead54614eaae9c6022945c338f62afc5538f9b1de613abad45bca82be16485ba1f52bdb5fedf7e889cda0bfece392ca03fe894d91aec8d3846d0fdc175464f96ee8e9cfd5f67e722bb88cb72362cbed0029b118de6cf1b72f32dfed81bb4c2325f71e94ee6d9501d384c4ec4b28b4ce45d080958552bffbeb67735cb09693b32559d11b0571812b9fea53db4b6aa9e514eb77ce3d3043daa4e742d25d699a37449e43e6c8935ad4382766cd5dc77aad066108e0491a8252a7113622c4fa7097e6aee4c5c54db8e8acc7dddbbdbc73d1ece0eacc23f6e8ec5493e4da44907ddb55c95d48cc844c9bde8c372295e25954ad4e0fd1a8d1cd5506094113f7d92f2439ae91ca87291e096d9e8c702ea6c7d1bac34cd80687244a1b7ea58a791825b6300d43b4707592b1c3d9985899286faae1a8b9cce536e9b2541675a72c4d10f423e41b88cb105dafd40b83e095f2912a2c98f296022de5aef08c243bc436fc80822fa4f4b46bc5d53174d126fcae818c5f6f370d27d7d22df393393096a0fab27b2a8007447306bf6fbaa2868c0ab473158c341d3e2e4134949bbfdfe8f152dbf183c2c7256d8d112409d20bf7f424d995091314137f157d3f6f168a0a9b75ff43aeda3f98ed28fb264284722b36b04756c00922aa0697f4a707f975939fd5d5a44a4c95f0eff97a06146e13cc595b3e1e2dcf7e27218eb60b753c8e760cefce900342ac4d327ad8fa5d1f2e2e3284ffd35f535e5734c9122790a6c121df7e87fc71e6c0a7d3d65c5670d0bfb335bc4b2a22f8d489ec1866b4f3ed53334a00ffc7ba745b6d18b3a39220116682af1555ffaba1f2f726a45aee47108d0b11bab4d12608c27c8469af49219403acc665f16d6a2f8f8791c243a9ed44495e082d7f0c4d32d73aa0b9b79df88cf88de0c1c39abf9aee98dbe324b985ff5261933ff47ae4884299dfbf30f431e1f0090fdaf0c30f8997c3b5de5fa6ccd3d5e7f9104efd0516b17072ea4bae58d67cb5109bfbde40560606eea41ece871ea624ca1827d48a8543de11212adfb1e5ab64421f1442d7fc3b310105af749f2261cba5ab9001e7b2a40d2e6364dc526a433c75b37f556d84d2ee6aa0e7db31ca965f20dec9912c00571ac926fd82807a906df4b7ede4bc8f8f4d570e6f7b413485d7125380d0a52d0c86c649cd691636f74ba4c0fb8d00815c5a519e7fb691dbfef32eac230353b80a2bad704185692e001021a74a05e0a721c3446ec1a939f991c50fba1b4eb4c7c159908f5c546d628737097c8b0350b5dd626d67123a7534396ce8de1f8e8e2721a014387bc94a50c03ae8040160a45a1362078a42df346167dd2591742c2513db57cbb0429aa2929baec5e4fb3d24451116cf75380b2574adad169b600272800d39e48e66cf707c7ec4360813c81347ff385eea46cd1f4007d3d27bdbd42797702fc6b71bef374db5c3a32520272b32c4f100a9b0225c6f5a815ef2e695c305e6899b52a6c8fc918f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
