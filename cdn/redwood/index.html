<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75b6b0aa8d1d1ad139a641bc4f471a0de3452c8ca92b8e7d9b261c8f58e0a36d491b37f8c8e908340a18e6053525970a986c82734da72b811eaab05334f87dcfd4e1a5e7059a22520e0c75bc2dfff8de61194ea65ac41c1ed3f9df400317545afa7622de8847a1843942d6f6a5cec280ca944986b077b84950dea83ccd1eda80ac67968f7fbcd5125ac4a30c52616c32bab86370d125b7fa78bdb5e19af1b5fd2877b4eea852a5f415a655b6aeb042d5ca692f20114125aeb652fc48c2fdcd005870ce53bbffafeaaa2454705f272dcb0490b396c6f137de5a5dbda538d4fbfac40b8f8870e4013cbd9b0dd95d48256a8c1ca3bda5a1013745c32b2f6e22ac5dd3ab17bb6072b9f1ccb616dd12603ffba0a319d3bdcc429dc29e165b50cde0015658183ed83e447b7bcfc69f4bcc40af011ffee2cd64c1ff5e19cd6d93866031daf1ba60907a7b8232884833f06c01fe61b6feac17b405d5f56b2c94b9db18eefee9471e82b6f7a70f3b2695e0e4184ce30c4983bf528d081a4c4c382e554c359486475e976cc26bee9d3f8cf5fe93ec73262a4b17e8146343663473110e64a2639f5eb96451d39d8ac38994198e2d1a9a5e2eef7eb057c45722f9451129342bd4929f72549163cbeb0680b6e133f17fd8e37fbbaff0cb8b76c7be68598a0765e75cb2a342f36918ccf9efa4d2c4871d7f9490f0ffeacc0c4b551234877357e3cbff30959424394826e7c5e44c93d2f72d966ae7c5ef206f9c1375aceabf091d842e1d066ad268c83e4d135e8105312c6effda100576f33452a1375b1ff2359132c9f72995dfb93039f513328cbd0923e4435720763a2637a3422734f8cf3d4fb62e5b8d3ba82f7b6c454e46bc505fca2c08eac2ab87549fb8c64dbc278b3b4200b3cce47fbdd0d182b23d8befb44d1f036a5db48e1de84b0e6cb58006135b09be013186d541afcf06a1f29bfa1012b5f56a9f8b3b0729e4e9e88575a23ce348f4298f9c1855faf3e632bc6e08fe3894fbd300987a84a659e7679966cfceb44142ac07852c5ef2594055ed1595dd366ee5e38a468c9ce023a951231f3a41fe880b124f506612ace7960f367a7071f396279bf35348953a31e2183f85b295bc7e6a011f23e2a4986d051dfccdad73d67f580a7c19022e9266ec3d8b42def5d76cb9202260a86221bca357742acc7396d92e1c851e9b2fe20f0d5f71eb792774750f41d2a8921b9758862045013ffba912adad4b26c485113f087461949f83c9bd71b5c51c7bc74673beef7a756c4b01f99c960c6416d947b42c893ee7ae9ccc4eaa01c3ed6b8745927307b6c38e283c9b82845c66971bbcf8f9bb4bb3da0798ca443cce8d179393053f0d57e7b8c45bd531be018725703213a3e1b5f9bc9cf9c52ab9aa52ad8361ca05f349a1a8f2bbd19fdf230d7332fe85e33ed64c7c30e9c6754d5e40b7fdb0115866be1b6d8a41074bc70e79c236ee5ca4cde7c0db6ebd25c580c83249655cb8f1856e17ac62a0be49a0154dcf4a9755cbfe08f4ac464ab3b9e1ec2fb34a36ac3df25cf0331dfe5c0ca7074a0134fe5ef28bbb1d227ed85d9dfd31ef4fdb8fcb0412a5ee835761477cbc14beb62c760c852c8ea55216cfe73fddf26af5df45a7649150408fe940591153cf6726adde3ea4c961830b878f54ead20cd7f048e3de79141fbd06692b4881aee05e0f842ac3a58484f67f565620348b618f78e60d5c119bcf4baabef486e94be2ed03491eb63f22475cacb609247b0788286078dc54339d8af3ee077d889f1770a75acde7c0c7737e0e0cab46f3402b6a803d4d1b10cf6c2d95c7906da038e0d7de8f0cda86f64ca251358ba1accb172c958a4f11e8b195c4735820e15a0a53ed7141fb78d043f899e74b893d4de5d86474b0cf72e9a5f5687dc33a363ca08041387451b4ed5fe8aa70a8052f28045d740cbb8976635d8deb382f1b523912cb548e04e4851712f5d53cd6aaee0ef0b0c35fafa3215a76bd5fa271139904dab35299a8e39bd482dabd169613769961455dd3e19dfc53f967311ed60ecdfd65f095e3f268e61a4843475d7ac3a6697ff3e348aacc5d206c8a7fb89d155963ff12e7329b0cad3051c17be5a807e90e2496b58ce0400e7f79f76ef99c302c7c0c53eb88c39bc0c5be40916a384e4906f9568cfab39ee6eadc0a2f90c0dda0e4ee909b3783b25b70ba4cce7f23dfa303f192fdfa0027a3544f2b4e8335d73bdd44585a935184878ed51b2f8ba79fdd35054f4667e32d2df7223d910e7b56fa9c39b542a2ae00375b6b24a8f4274c7da5c3e1df135f58d2d44f7fe53934298d6ade2e2b57015a272c20a99ceeaaf0070539a21fca313228cdd7f850ea90c6531639d81862ac7400c32f5dc68a17661b646f72f0958139346160c0c46fd9d4ec92715885243185ca29024012de31cafb9e5bfd9339ca6e271c80300dfb05edd5df58f1f012145167514f68a62b128627fec5add500fccd11c1350b425df82252f9e0760c17d87841d8cdd998214a1b8a4efd75ae567669fd22484c2985b856d0359239cca58a9cb8bb2dbc1c8c170f59e17235b652e3017e512dec52fb59ff7daef1e19644ed83cc889daddb5abf7f8efea39e050a3e83d886bac9612a6c186182246ebffd5c3ccd511587064a558ca96a72e4b53923c89e264ff8e1681e6f5717a721628abd970d11c2c47f37a3fdaef7b1083c73e77c38e52ad85358f8758bb45ccd2043052a005657f3115c3e9c0940f5472f3e5048f05e6efcb2da8d9f0027fd3c81d4fd9a7c1f3df3b91ae0a4124ddeb542a532908c4bbc6f2038dff7eed3d21f2604876a6d4c415cfca315ee195ce82e462e07c977457147dec8d9e480a85520074a3efdd74e3e833665a78f05940f238178c3af5e0f6e5834a4587781058bef55d03e192cc14e454cad4cbf900049acb05e79e6f7dfd8631dbf0e71dcfa0be70e22c1a8a7632621b5353c7d1d22e36692b5326cf0aa72dd7d25b4aa1dd119668da0229a43e23d29aa8279332ad074b0c3074673c611ed130ec36f64962c39e019178f94075780c4282ce73343166019022a8caf71d2bf80f149575e6d174a60995d588ac20356aabde62ef1057f9b8e91cbd59a3502d310c3360a735b4025e68c2331352cb3d94d5b69b992e987d36ef7f649c0d12dfadf8035f5ee3c3c592fc202acde186eb938a395758171dbe7f454ca00f0e6f80567bcd1bf0eb11e08241b212b07d12c21624b4164011b54a412ffd610ae15e4d10d7068d056b7067d1d615af0aecb99d3bdd54b2bfcef858eff6716979f4a40dca9770455a18208de91757939b2648465bcf6f9f5641e923523b69734ec9e5e006ad9ef00b58c13d7857644ce13850cdad2fc758ac6ef096db56e3c63e3f88dc19bae46b7f97ac17c943f33e4258072a165e7fea7ee8791b4ea4bf87f8b49d18deb7969bcb24db8baab20b0d20c503f16131bba5d46eac507262184acc8c7d13c34dfb961b4a2c8fd623f33e1c05dbd404ef1bdf6174f5ed611a5903d98f42664ccf06d2ca390a5152433e6af6d7e803207920cbe6e4f4d982545b26713a997c90e91d8c9f59f2045e93034e0652e3456ebd2f7e776e01c8dc5d15b17dd9855effbdcbed449a88b950334decae228773916d60a9564fe207cbb1e923aa0a32a4f34d907d3c94573d159dda34715e458aa6e32d94f924d897068ec8577dfb061f9ae9697842b9e52ae445363655aae5457ffaca5990725f8b088766a7968d6830f8ab7aaace0e0a7c09d0dc2d62d1cf191a149b647cda2c421269c3694b6d16a645d0072c8ed9e214cfc2fbccaf52335de566e7f74dee8014b83bc345b9d55a706d694ad5ec1b2ee028e52c5dab267d8cb9b7487692f63789343ead7eaa69f1cd678e6c32326610768d09dd15f5a636f2d62df43181b8c08f7b9a06621dc7f3bf374bbba7a2e60d95bbf097db99c193f8e9740ce2f464e64694e6d138f3d7295d04d6e1f52a408fb2cc312fe8e9b508a2467640cd4ef64e490cc608280e148e8eddb111630db6f209be6a02965d629c40dd1099f2b8b386537ae65418529ed1f3850aa3f66d8f8baf34f5ce06b816eea438ed884c6ab13a311dca16f734e5ac19e102110cff5e477e59dfa24678a2a948e773d83e66cc48f84d708449195ed8e3792a7e53d97cea056419cb019d227d5ef3886741b0667e0330e151a060be02268df6a39070d0acf626445e62545c0ca6a69b4b0ed8e309b3124cbeac6ac0bfb9c55a9b5138f5a5185a87e9cb7345d6f015e4a010703d2fb34778ba8719cb8881483a575d4fe0159df4e1a743cc2dc7862ec2f883a09e6279bef8917bbae9f39ad97c8e7eb2e13b042ee950082f949c8c0bf84113b8c1276d0c681d487149d40ebd8d72eaeeb73ae44b90b79b7a4130b05a940a72af35ddca73c3cf2531b20132d8a55267afae48dfc4c08d85c6d2a9d5fd9cd029b14d3786b4538de9b3d03d98d0c99bd10c316917e3c24b81b2a4b6db7eb57ff769c7696485748728680a95c7a47c7c0529d659b5f2a24ad5213175c42df2589de4c891623d4a7fad55d5ee7bc526afd2d7805ecdfa242581b175e43aba81bfc3f2f99d4df35cd4e5f3a8a0113c83d1806ea6048d8c356fa81e40892788545bdca26ba2a6ac6691900518486a0b7f7fc59ca44ae9b38af41c8befaeae0175e456e1dfc29f220d1a61e56817e80fedd3e3920240656f6779534ce56ed05e16a3b691ba6e6bf1e1100b260272c3f7ea2b8f87b54ac4f811a33d5dd18b2c86f64b821190f2fd1840b6da191a1f41ba0b1e1757d7f71f2584f2a23b656d0fcafe8bb740c1323ccfaac2b885a0f319d6df22594a211de2536ee52ef870f0bd402dee9529648787aae8839272aaf37a742c7c67a7acc1a1ed9ef324ed7b3be083b51f1aa9d8a2fa68b4a88a2cc956dbb15af1e420c0679637a493d9b8a528a94c123f8ef9444aefa37a3438ab2974cdc9fe6782cd9eb2ed80c343e92c667635169addd430e8da963b0d49ee17832f0954a134c0b7764a999071b023e7dcea9447f53278f448dd43fd77c9c38a2c616cc369cb801ad16a505bab281690886ed6cec3c4abb7cb4c29d29d69dc352e02cffa6555b1b980c279316bb5140caba2f531f3b4501a0122d55e93b268c4f4473280cc26115dbadbc86acc6e2731b428fbcba0333ab5fe3cb9fe48fff51d1aa02dad4b4ef13f015923b9b79e295160030b757f86b84d7a32173a50ac2c9362da8d7e8dfce93d28ec8478eccaa227fa8420396968b4053ed054910568fae86e0295327cba9d2e911587dcd6c2da641042da86a94ad0e6232f3fbb8787b14a828fcea4b25117b1a7a5bffc03b9508986806c274e5a93c2530306ed3161df4c415d1be383c13d946d1290bf4e88c339659eec55ff3a3241b055d33a861d0a44efd6b0eb938e8bda875d4a5f88f4adf8ad0153311da83c10644b42f54f36d1d814cce605f625a3f254895af7cce90912711d76fa1872fb410c61d47497e801c77ad31335ed0e43db1132dad0bad38a4d4f387c1f990e087f296bde1ea2ef5134914d97acba4d00c7f5223732cc26e22e2981f7fce54f4cbb36840f8dfde39250c56e35ab702a1776ac0c9f74915ecb2d96d422430f77fe98ca8d104c7d41bf9075607b0cfb2c7465557c0308abfba4b366b8cc252a928c817fc3fcc23784d8fee8f5535f2c360ad28abdab4c77e28d5386b95fac0f11e926fae9c9e58a3985e6910f963c68681e873051914277892679ce5883cd855765047abb034db4851484cf90776edf15007d096f91b408899bce2f473e5b19b6663b06da34e7980e44bd94e98948dd0759bf478ec7a20db0c1a1fb868f1c3d9d3a688bbafe61c42df11435b04acb937fa779973c077f095c852102ce705903a53bb9ac8770df56dadfa8d5464dabadb10d3ffb0a00721ec6c105aa4578c73ca8f4b5c701cda2d329e6f8f90853a05c97c5c41950667f08e8c2ec761b027ee36354f620e1f9950e33cfd825a0c8dea41baed9d99c0f31d7828724c1a587596207202b26caccc914bf77685127edf9cf4d7798bdb0abdea6c06d8e6d59ca927ba3dabc98a1ebd7c022a521a4a3b6cc289a0f279ec4a97ec951bd22a47d8117bbfb1f26a801a6df4b41888b778af7b38e44d9c50af2d0972eabf1996878fd86fb4e669ba879b1b6a9cae3130b0e1270c047c02421cf1136f91b239fb781df7fa0edcba3fd7844cef944c03c220a5c96128753a75d525fbe8147c3bb6514ddc96cb5d62364f6389e47598664b2f4bd6adb570b31a49cc39cfb0d096fc809cff1277a9c610490ed5b11671f0e807ec61957823e0b14db4d5709dab406f20c2eea637023ff338fac12e491db387799563a535692bc0812369b8199e4bf4fc8e0fc51b65a6d803ba91487a019559583d3161dc49f540ab67d58906a76c963c1a0626b17d3ff02635940158b400d0cad760a7c58c022e61527a8d2a5ed338e33e90d728b0fb27360660edbe0c0cb280982d28baf1b8c6d07276b193ed82b7343ddaa9ea31371f2cea0e3698451b8323ff837d38a0336c8466b1631d1a332bcd1f44044470e911ace185fa983c4bc38b33b055de26cf75a90824034ceb38724e162d7344c86631e0aef612ffc09b5bbfbf05e602a96e76082eb8f5d6605bcb79936faeb221cbef4363aeafbcbf06482efce07f4fb171826d9c2c2d2fc5d8d3489628384996f89618e086e930d550e1bd5c1f0637af56ff02e6051e0aa52770c50db21c993e2220da48e81679cdfbb890cfdc8b3b533aee3a9f4b63be41727453db910f978673986fd6bb6c03252975eb6593eb1a869b54c9745b920d8dae1f381610d1c34bb0451495b9e88ad5d4cf24da444c79e63e99fa43ac9ed3cfdaee846aff60ebaca1a0dc7127e83586874cb3cda27c307c640e73a7189a726c33bd59f77b528144307005654b1024db8a96d676d1f07c957339ccf68ee4fc65b86c0465f2bfa3fe8c8b50a30344cc5d8d609a50863373b5c06f5b903e67197567a1f7289928ae4255ddde09552f35702816fda90e8381103b316d4dcaa2fd918a67afc9c5be7f6f149a1bc95c6bf971fe30d3863e274ee661629aeb098282ddf9fd27983a9407119dabcd9f9c773ef3e28e210789cd0a68e0fc4a3247f5d90890b6a3721340d13687c9af0bcf7c5b489e1cbeb72c78fd7030795bcd71ac9b73edb4e8d32ecff56db330849c335c63c1f4b385bfd63f1e04302bdd591db665109af1fb21499a5cb56001d69972778bda4ad8db74177496651a65dfe9ccab281b9a143d7d7f780445ebc2d057f3b77480a9bf3c1b312e547186ae5440ca181756645f7f614a713c1d298f909361d24c904b98d54423578766a1a373f00af8f8c4289d41b64910f83202b491861a116333d23785fa43f3491864f581419e45d4634b402f4f56a72da82c5782ef66167e015c53a8842796ed04edce4cf5afe379736c82f297b58db3de6993e7e2a1ef27f0b8638dcef1c1eec93b408717afb88a5f965206d33f301c521b1ccfd075d27899c28668e9e5743644f911baaf2c5c64fdcb834b4cd7942110848387dd4f3817397dbed1e74c7a43060391d766d3659c3927cc42b1aa8078dc24e9ca4407bad5a60dbbef75708229bfddae30466279fbaa6eaa48375804da546e1ca95b440f4daaf0bd22891b4526a03dfd0d9c7887404b0bc44aec1a8c55dfd6db30eb221d75980dc22bdbedfae10c6e1a44b6aeaf916235e2a8b868c10712728e58dcf6898e6fd88d5002d3be967edf2ed01f766ed4ce3f658aed8c31e42c8b887a7820586bef93714f7483e47b57cf93aca2c0785959feb7056e3c42a5a06f08ede76d70da9ae014fae97aa4af6649a91572ccd462953ce7ccf07290cfc302e9cc713ebc841e24725808ebc8d82b8b13df1c550afef817348f4f914554225dc70568cafcfdfe137fecf3fb254d0145bbc399ffb5ab4ba8b1271cc6af58dc979f3a6ab82488cb8a74d837d425bf96690163ea33a47c6c13885f865e1919466b69dd731394c2e332d867104e3bcfa88f6b64f4d23a2fc0fc1c25fb6595ae8e3e947952f2d818f964cbac853af9556daad1959ab5207d6b683cf78cc71515e584e5d023dcb5bff42c6c67d73df158c68efc028a7bb20020862668611f90e50b9dc58ec560d7d8cdaaf8c2934d85a5443ccfd1b80ae019c7a468c2a4e083e751a1b70049241605b4c3aa5f0c6ff6129da40d6af8f8ff08c3de25941211b7cfac179578b904069522d893c736a5a199dbb2f196e7e128514ae737ded013878664a8039f9a308016897a69387d3e5fc687de9a214aa18caa7987359f6f0ec617b2f06c416bc10879008fe9fba9f57d913ba8431fa71f3e41137d99aa0b50b3814275e4b5adf853b58e57fad4003707eb82a34ad2c492f651e9ebada9399628cca49f9f85cd34cd5b0bf849ddde795261913200b7b0910dc266c33073942ba721709c461c2d9bbb3c0be9666226ae294e4bfb09a7372332e2b5636f08468abe8576d9ba2394749dfe0f4d308b7346e11401aa733cb73d3820dd7ccad21329ca3fdc70c8a6c21cf94ed77dde3b8e4f4412765e2f0bb1b7a780c04922e48a77fc9105a1c7d3550079e1a7a87d6f8822f5f949c6841b7338aa51d311652245cd5082f30721be47a655bbcf3fe0b37e2791b217d611012c6631abf4321005768262a9f2e792c376c50b5a987bed45437204593894ca9d2fbb6e89c3c7ca63208bbe7246be913899199580c479416dbaeaf761ae37bb85420fb24d27846caaa0d1a241db3531d952153d71beadf8746780eb40bbc208778a2add1dda2e3da4686557b25c1019c914b6f2668d3a683db7840a8909e20f9f2069101b32ea9c0a3c47c4ce5ad7664871a34449c14d3ff7930f32ff5defd47fde7e0f3b0d852abf7c5aba1b15f037eaa8acdfd4c781b0b620bdbe1ae10f5b23e0dce64223f219cd9bdea1a4041ad9896cd22c60661277e5a34bf1bc7a98ae16bd7b2ea62e19c580e434066cb3c362aa37c040c8f0ccd593036eaaa54bb2d1d0fb2a8a37ae5dd4e7194affb3bf83aacd6fc39acd96cce03d0278327955bcc6354027ef7f406ed62e795a05cc389cbabd9e9c5354579cdc1e18c94cbfbbf0f719026560ebf557adc53f18af9407645a91a71cf1c17309548482bd60fe5eee7d3a5dcb55fba74b15d36b9a0586141412784e19297d306706fbbdd5a7b12c85dbd36dbc1c442e0c624b2918152743ab22c6b4a38bce0f086077e60aadb881fa39c7762b0133b66adbc9d0ea8c0dc1e8461141c492f74f4572dd1e127c41ade5a698a7a79651935a072d29dd8627ac169c584930a68f730b47b436e877ed2dd93d8114fd8a560731418731b90fbbebdfd3c19a3563d9f23bac0e3bc451f1edb9a651b3efbcfb8373c7595f211c33edf6976b81db6a588266e2faac4c8216b83355a934f835acebf56aa0af00d5ccd9c5fece5e8b7c4cb058d13930fcea2f729d5a05d73b279a0217c5aaa02f3f40ce3764da013459fdc29800bc7411aed3e438f892b87c7922895942322463dc1eaad8c192e5b24ab07c15c10a023f4d811edc6df6e01bde600088c33306abc049a8b15b929166730ea296a251fda1b389af682ee66ccf526a59d14826b6d6671527537c187646879babcd16e56abff93068546054e29363fc0aca77cd5a8447654fd7f261f4c16cc66e802768986643df2f765396b018e5e26669ee35535da1d650f98cdb9d6864459fd1effaf29b9ee935af3a41b41a89f636658b699ebf3158beb33d06f2b39ae66c073ec339b83b2b224ed82563fe3e0e9c849d56d2512669a72e627b687cd8efabee501ca3844a13ca1c5f5bf6008d9aa3d432a3145a31e19ec3f15d1fb39e12ecdba3fa24dbb1c9e22756dcb22155b5cb9209db430302f0f4a028dceb5fed2ddc96a8d1fab08daafcb4fca1535e20487b5dad0f314a58f9ded63487b02b0420ddaff21c67d86535a3349e431cd14fad687ddd436e057209d0f115ac5b606a012e5dbcd53d5e25d12090192d4e7fcec8557a5d90030bf7ad0b22bfea54413ccd0ae09118dfc8984b51e1e89e9e4bf08a4d7ae4e402e9be81435a9a46ff4da226d5826452b4366e8efa315bb29fa1772bd19df398e105a40c54c9d4b8945221338103c32cc9966015d16f15f43c84c2e8adb129d9c5b879b50ac4d70e19f966fc9f358d36801a0884131d0f15252c3b62a7a531efdeb3ebbe111e4a731c789fb14379a9036ded1c93d699a086d0fe883f55f3daac5edd098554a53be39a66472bd420567d017455880e08a70e5f426b616187f7f31d367d2d730d794b4a76a54599c0730f942e19597344809b4677df76ca74f527280bb34d0935b5933c9577e6bc88d501517f3889ea4a0507b7f6fcd54011b1799327a003baa3f919be78df80c9383cd98ac803a6ce1aa40842a1a1f6dac7a77e350adb408c9f22b9a287de13324a2a23c20b364e3bd8c7c7b9870493b5a4db6b16505a9099e0d6415dda851813e76da86a670194372d89a03fefc181dae253cb0ffe119809233458710410b93801d32818ecb635192196c98a2d7e9f2c8d515396ae4993ead16c842e9222afe3eb532f9ccb6c7476538ce05332444184e187e6620c079d4b2b59812190f3baa86225800da43c42aa2985c4d64a600c4989a8eb783608ac25460027762c7098f14b88e3a3f98203fdc589e1c5356416302fcc1c2c488f7bcbb4ba06dd37cfb638f76e070bdbd153ec97aef3d92884e8c7b54cbd718667b92ee85c8319f63bcacc67bde70761a08ff63888d332b27bd8e0dfa20ec948bbeb6faf1479de25ea5094002dd1431cfbdfc14ae7244dcb3c95e5c53e5effef799de14bf741604c798923ad69fa60ca09a3ab8f508d6d3fc93ed6f207d590e68bed9011a24b7bf9bf26439ed87454f62ab9aab88fac7fc53ed75abe2631e6d5885a369ebbf5d2a7603197dd468335fc920c9a36d6927ac69c87670197a1b9f0ae79c05a8bcca6674bdfe42fd0dd72a2051bc7ef5a9d583ba6339be7aca5de45e895f7f765f56aba8b0c20dd61c742262bfe868ddacee5cb5af4e7f46360b18f91e9e992c1f149346c3d29561fffc9709e0d368e005d503826b138438762a092e2693e615cc65090b98d63618d1d836170623c2265cca3fc50b02c64feb62ac941f47851eecd53e62db7f9b104f93c31a937b08b735b354836d4c1a91e0b0c43384e53ea85257525c1cbcfad11f2558abcaeb57bcc479e3a818bb1c672aa50a905114244688bef9fd85b14aa6689541bae34c5b780a58cae6d3a5c5779c111f1059fb8ee97bb9b7922be92d48e9d0fd8cae4b4f3c58ed274e89be46e436eac4d5669485ceb51e0c24b1c4117dd275e96daf29befba7ea8bb973c7ea9ba7871c3efefd26705582ad45384953e94920b0cbd8f0396efb4d630b411d62c32c5be94ca39bbbb8503225cc90db6d307c79b1074527f6db701ee4844f819a27f13958a5c8098300c8b32a6d04bc2e7df419f5590f068241a242fe3788138946982dac2221fcd23619a48c9e04f16334450bff09f9620e8185a003d7bed54b12060eb60a9c33f5b3f37697af877bf4bfd36c9c48eeb285d90974d3bca6e921b4022ac8f573a563c31835ded2d07e9439ff4eecc4cd321fc24ddfb7cdbb7aa59d5fa912c2f5c78094d9251c7e8948d509ba51e628a985cb1160b1e751f78b5a277393864fc16ab8e0a346f86ae284ae3da2429daea3e54234ebad5a34c7c861c580d7854dfc8f89fb0a8920a08ac8a1ae0d7f082c8f56899b3163609d0ddd85f619b9d7cbed00f57b42853e68bb6042574f1e735eeaa14359b859de66d56e07e44e550eb97c5fb45c83a22f13bd1e0ca7cf27ed6c425a9ecf3ab6a9c556a6f4daca69bee8f7af942cfa12b54228f90de9230c010d0608437994f01bb376d4e64225b181d9b5a8d69bfc06274413340e7fd2161a946ea8332db54dc546596120c914cfae0f1316e196391eae88b560ad5555c176b4e53992cb3476304b774ba856942cb64d05bfbc7dd7f26a12424d5dbcfb78fedef96fe772328aa3d99e47efdcd9853e7b8cf8e06cd386e8ea589fc48d39a759ecba81b61c313100a8736fe13058d1417a249eb3762e93167893127f11c494789bf9a6221ff4adc323aa0c0b72411e0950de92438ef186d3a9d8f34b111f44337e9dec1d350c1fbd171b5dd52f14d033d36f43a4539ab1ae66c8cbe40f438aae91e9ab7556776e4d327dfb92a1bdc512bcd8fbf088ed9e5354922b8e065e4c49fcab492b4d059565db74ab74877365bf0a5959a9b143736a2d11e9c5cfdcd830dc97aab93072e23208888b9f36ba49b11f2ff7265de1f7126b98ddc29765813744552c1f53500f94594d752eee2af951e488c2f0a13085e2450e193126a48b889189e036207ff2ea9412d21119bd52d986f0021a973c737d3c760d260a944243690e0f64920aeb6cd6603e4f6aaedef44f997aeb457c0e3d4bd34a1b271ed741562e162eb074baac42b2e6d6bfee4ac2b4ff5e89d1cf49a93d11d2fb3e1aab4d001f8ca37f0eda81d75edc35dd22d5dc891710f6a217a041dcbf393b1b62e8ae1c48c234d9afc312e108f754f06f2272dd4713fa454016648d05a03b320f70143a4ae9d236bdef9eed1ae23dc5fc30ef69eed68128722ce44b318f986df267db6d3ff89c8fa3dbc4548283e79920dfa781bf42a7600b3c5720dcfa6fd8ca4e0ce624850da6d66a2aa39ee293b02a66030b3e2fb5b0e0c5dbc4116bbfe21ba2293314f94ef0ac8f4352ca6656df4ca8d86dc364697dd84e155c72d481dc65fbba6780e83d8fb907a67052a8e5f98e9ac63efe15fce9c96b9d809d814562519db9bf1f5f939f2e8077fd0e183ce48588d256ae98ad73e9ded3b32d2219578b2d6a16948c4cdceb94e40bffd8755dccce2f7a5c8788c1daa0ad456f1a1cc4070c8381040dcaea388558c65594a1ed8fe835f6671da7563903f68c330640a8ed8e72bf8a0a537c1ef0001ca32b54b8f94b9f058cb3c0c6a5f93e5e118d5892576683ed65118871ec4afd91af4cd563531f14d5c688af781d1ba3f755df17a3d3a67561598beed874c7d0538eff03db04b65d65363f7ef48a7bd5d8d53a1ee7d335d3e80c2fb4456cc056a9dbeab98e5bb47bdc7636b8a922f17553f7365d3005813dbfb8347119a9103ae881a59857149c6cdadc1f89f5d116db42be2338b36a284a99b87efa301f0bcabf465c778c6b5cca8d2b99582471926af0aae27d85de0d8e09d83b0994fd64b09d4054d21df993ab6305ea8a0e62ac72c4bfde446253db5554079023f63753dc60f79f5abdacdc1a1867d0d8a323b2959ada8bd058530bb0d400743241e955d5d2a082470cb112a050e63afc4ed2ffbbc12404d907399f5040fc249d418e3446073bb51fb9bf26e2391b67b2423326b693bf0fdb3eb509ad58561f78ca8e9ddea0c2b6e5c4dfd2a549d2e38fa5caa4fed4b1455b69287284ffcbdc89d77e5abdd4b6102d7a9bbdbcd627b944b96c5d93f97d4c1d61feb0c31dd1d882fe3f78db212145919154aed912aabf216befffe2b153b3d1db496bb5e91e3d2934fabb087b29839ea75563a209699d1e47f51d26b69ac0ab59bdf8c7cc8abdf6902c48e620b5ca4c5703df38c3ee1211aec61dc9c6808428aab93153607b4b9647ae7380f8b613301900438f7f7a892b11ed3eb06e675fea9a4876df8665771d33e27509b949ee00f0af3b9061b27f6f6670f2569e5e2ac7e482656de4dbb433a819a02bea3cfeb12119186190b3e127b719b8e22cc8ea48f83d2c1d1d2f8daf4acd44c5b7fcb8588b9427e05b9d18953d9924a2cfb4fcd4a9023b7ec58bb0ce4efec442fb1590ed0a96e4ac0d6a5d49de4f4a46d36dc12dd94dd14c42ec0ac5dfaf61aa161aa068b52c34ab3a18249e243ebf752297d4bf28935a20d735ec63288efc26a28c7b8ce30f46a97f0d4df32c39eea967114f1b44b4880b12893293853ab74e8f69b25eb20a3e48dc03a659431a5cfad6ef27ff6c5b748909380ad14ec2ac723fe851efe0eeabc4ad8031a7c48024a0fd9d6e299740a48c03db5f14353247cbe1b974e6fcace080c79324d655d24694339f174c3c49511ef8eb42049f13b76bb47b3685430505e3b41a95abc7244fe35e6b71a0a2aae0a8f7747bc6e0eeb4f6ac6a3c30f4aa988190894313526c31f30622f81a670f53d8fc11eb1ef57571c6671bc3b982f85f7f2a51a5822b1a4d15dc31a671381c7c4c909e3bf9b58537f24ce4f87e5304eaa323ee6277e39e13a4a7fa34336d0797775e441ec99b300facba4f840a3b30db95492d150e0c2fe2847382463d0c93cf6cfe8da54995455bfca69d71a4d30cdf67749fdbddbc3daa15a08a2fe9218284b4ba163929515ebc8cea609fbb96ffe236f0877ce716029d40bf6a5d1a7af81e8fa459abfe5865e74e9f7b23d1209b449e204216890641deef49eecb6015d4bf9ddc89096cb47e172ec9bc013a23fb717424e52bc171cae3c986a38798f583a296fb41be60be276d9a70cdfeb98f913d7836a3be6837d503d48052b09a9f4fd05f9c056f0953e84258d59a966bd0f2a6992720fbb167be87791bf804b35101b2cd456d7d7f70b4060a18bdd192cf97254b49099f61b97ec054329ca77d8bbbd4ab31c9be539d22c10088e0efb026f704aa33991846bbdf70b97203ea753507832dae318ede367fb0eb15002e5929f3eef6c312a0627dde2303baa0ed162c6ef27e149d4b219c803ccb0f95a6c083adeddf047e4d1802a03fdb8cb37924431442959ab4c0b25318c65ac76e1d30bc9cf3ad6e33f5627f6e85d4115aa56cc2732c378356374e9d6040439cc805a2f7222e98c4349b4e9c8377678d2bb980d6c1d4d37334569ffe49ea3f1d563c03ffed93f96a54b0308e0f3572b61dc272048c140fce5d87a8d1b20aa5f89192dea9e22a842fb6e0c1eb28f6f3fdb38b8af40bccb32adc64a72e32adb7c9efbb2c9a99d83b157801d2b1f2fb3626c04b88842fe7949d8f8ccb1f6f9c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
