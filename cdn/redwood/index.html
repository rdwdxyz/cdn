<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ddba6f8a7706563b81275d6e3f746c9e63800e5d55e8201f5eed5728041fe399ba373b0719c082d6a6e3323f28a8609a8a2ea02d5958c0a25b6522ef91be567a759f06cf8ea9f1f49128ba107610b5a85495158bb43bfe6aad400517222da0f21b0229cf0912602fab5b6a220f5a5a53b7bb79a88e5c9b5f8637531e4c19734c02bf76a993d41a8aae761d82650f36c9acc083f6f56bcf108875d86460db8bd95158fa5047f90603c21a5c86ab8101e3e80023e557f49445010bbe8f7c6ad808af456f505be0c2b1c45219096fbe6e30b213ce4123e0bea896bc0493c049aa92fc3660cd8c3f699feba003e3f77754c2fdab2aa18645b854a804adadd08fa15e7576ff415a45953d2beb4f6d47b8c88ad937d3a1ce82f4b051d573ec572252595ab51ef26c3b2a6e957ad64d890c8bab2b175ab60fcab2c7b4ead3f543eda04fe35041e0bb909a822627ca7262a7c0922ed5c9df6f1b6a7bc60a0cc13abcd893cf6922ede11539c5df6fe60d63820a58e5f89d7bad759c64e95d00c260a8e66ad752745c5c6a22afdedfcad34fab92362c989f421563b828f8e9bded6d72ea66fe98631cd2297a9c4b4527a002cb1f1e74ba0ad1aa56d2afaf8ececa555bee85e33702effe7085f81c60e354e27e6ba73ea6920720b8ac157fc726a96076875945ea9830fe62e56bce3bd8b5b2e61f31f0d21cd7850433b2f633f097b0f55135297d89dcae33ffa45cd3eb6f3b3de2b7e5e3d7e4627b9e5c257db9a281ba5bb05c73c8450cef1a8bff84ec7f21c46e8b1f5cf79cb68929de20cd10991f1509c1ccb58fd9562d365781291ba48634f429c5a6b467c73fb4736cc0fe2b59a2502eb03573000d344813126f74655679d8c89962c65ba2efb9226af0e55c9d9a6193932b5b7617873b8458c109d3d9935698165ffc1edc7bdc5a64900e1c8df53145f1ebd25d4ed2b02d7f85afe3a0cb2d4f18608d519d87772eccfa59614a10ef626621c2a736e32b9bef1579e5b7008cf28b4561caa55c3a439fdd74b6d18f82f7899ddb1ccc37bfb8b8f0283037cb90e138582c91160c9757873c078e1f962daab4a59dfb2445681968623f1d0997937337762213ac4022606979895d12298c8e1541019ab049e29e6c999eff181fe1654c998331a0037898d14f444876b7b534db3240534ec73ad1d3cbab7036b9d2a6e4212ad598abf03708eb81fb11bf6b47b5d98097034644aec1f6539098728f3e8c9cb1a71d80dacc667143644db68d77a77193acab68e9ede00fa8827fbc66a17b48a9cc022312fb19b4ad2069a4954460668146e5c84ebca3c81e7710fffb2529235b434dcddfcdeb48333f4bd56568dd7ae2893210350f1c3c67f87eb0a1e2050e83a3fd2d7d594bfa694f39a442eca6b38d0a7b4fd08c58658e75093891761c1a3a4f4fb743b8aa4a0f3b93fbc5de9488e6f3000ed3d167c9681ee09416fe1adc4e6fc38d4a7ed6e0eed02302beed7fcdb379414bbab56f571af6e74f6330bfaea6a59779744a7735fd42b855e5907b59bc1920ef85db1d8896f62603e64657626803d38b63173661a2ed74b3b9c98cbb4c65357e48638937182a38427caa032ad48de462c4704a413f1c9ccb49397aa5d10dd7f68dc8333ee0365b0a23f67771efb439eaf866d30a1f2e1a3a2b74b9f2ec51255bb619c694bf2e530c89251c0b10e5de8e79a9cda4c21cef9ca7950200ae585b869dd8ae88f40420c8f83e9c6220e31cd575a897311ae17be9462ae8a9dddbea68422b85472e092229fb9526b2ba4b07ff337bda60a8c1411bda24d5a05ca6ea44076dddcb09c4581b8d90fc879062669ed84e9e0a5d908785be715ec06e984a92bdef6b4e0da8ef8825a35305e08f3547dd74771e7ef21876503bdbe19a56d154f766e0cfbb1dcece67e0cd7ce54c1b4b6c569bf2ade3130ae97b688c863b5f73b7148ddb88a76232e509e1782448a5296ffb368d3252c71f2805af77351db301db497413b7672cdca2d45a2ce8fe89cfa965c021281d7240ecc28602ee9e6d5e9849faf41a1864d0f11770791d451a705960cd92e459f89976712dd9073af097596bc9e255d319cc41f4f8e03c8e8a4ed325f02cd338bd02a79b0e976ad85b869fe09fe8b4164c03345be02417dfd4fe73520bc7c2cb55e137558f1d7635a84e725f55254a53f41159044a0fa60911189e2eabd99c7d41543cc450df824f46a74701efecd8eea2af5513db08afc719b1da5c2349fe3fbea250369b8f7055b9def11a9c7fd41ad967b068c72c150800b87f867c099df261cd2dce2a2b692a4356f1b5856eca6f0b5ddcae1e211503394697a9f955b46aa3c101918377407f116cc65c67881c37d03d53db175b13d0a1b400f07504e94e3aaadc76e7fd9461c718cb46b38aa8eb02c372e160a25e6daf663f0c90705427da760b6fbd8d09f0180cd5f0db974e6ec4e79d377a94c83ec390b55d827a05587f1f403e5b776a5137cacf8fe1d0b8970b6e332bb25eaf5b3d707365768c79e8a4065d159557d2739290089a9c1f107c508f1911e8a9b1fcd148e9b995e744c4ee4025f2051edb2dadfb8602c68404b3c981d2aa067250c70de61f42cdb80fb3ed4fb53a7d2926ad16646cad8e5c9c323b0df744b7c3b9f6b859f699d5165c970dc45a8788c0463544470c6869ae742c9f0abad8143f2c4560a6e5587f51de5c0017f66361d4d8fc41e785ad3d07918da767b560a7ddcffba7a832d94071390319589d6afa66f0e04e813707e0a20633039d13cf4d589c506c732adc3955b8600953588cdade81a37be65c02e6d1c1afa15e15d801e686e479e17917709cf497f0d65849d48a33125afb6cb051ab8629d1a0f2c23bd8d10274c3c2742698446aaa5e71d3420fa0432b566ac12047afbebb4ae13d6a5c869b86806b06ed81f85248a6ceae5381f33d8dfdf63de0370026871bb79f55bbbaf717551ebb98171710715ef28a301ed0da326618504cc6050aae289be1a9e443eb4d3aa24322583f57fa443ac4a263a410566a8c980e079f964e7763010187f5a1b264902d3de985023b7632b1aa650122961cdf6ae86681d539f97de65b36589541ea73108fbf34bd4825a9193e51446b966dbc2cf670a876608ef26ebd32d3c16f3b6e352d219a2394759af1d7829309caf57a8f2931ee2e5b43ce80806fe209bc3e580ece38068d9da41e81fa0b9ce91ea214c94214a6b2115b40c37578a21f6f572bacefaf292a087001982839fb3a3f464e99010594b9a4857c0bc84d8e88a827a84e509c16af6366a261b8489b8e45e4cee4a7bc3288cf660862c74f16d3d7b788bbcf54333a9c1d33216e75c674503f6db5e00683c02e282d7da686eeef02747fd655959764e6bb9ad9368632548fdd40fe79cd3d8b1918e114276ab2756303e6eb53a480dc40644a0064fc11baf37abda05e5ef0a316dfbddc22d9998267ce428d29cd803fa63e8078246d5fbf977df6f844adff1970abc0d65fa5cf01292f90497e4d04fc9ecb425c620c9195ba956982edf3674aabaf6ad4cc80c03df080239a48aebd0a23bcc9a3b96cc1e22cd45d6a38923d45322ad9ef0f16bd7055bdacee99a64f2a92c0d3afd1577b851f21a4f4a4cf8856cdb681def15d6230411a3980049775ccb7dade7ffb21d7951b8a14e3106a197fe5df0bb4063ed0ce7e703fd80448d8b85fa6b2acdcee7006161294e32e2c9c53634d7188a977eb8b69869e1a51f51a95c1ac5abe35c17bc5e056b1ed569cf54669df5779440301b416313754e14223c929ad712d9492f1ae4300afdb9144e1ba68bc4ef19c64b0b0212540cca40c9ba584672f4a2382cbed375be7baa707060dfff3391c5b5b7e44fe9ce60f5eb9c84c0702115a4ea1cb60cf41964b0cd0e80a5210606c14f398585e52401363d9f76977ddc2dd11c712c16c278c69efc839f158b5ddf3eaa9afaee44ba6b49bf1cba2c1034390d5a6a8cd44e5ed2a499c079e76fd66c11e9375b46b489c88be19b833cf4fa6ca8c0c425e694f2f7be7e4119383c32b02f3ad2b6db08994335300736a6710b8d0a0068ef93b5cb27b2fd838f584378a2c3bf68bf1e11ffa7f2bc7f4f7e9b65c40b526b48bd966cef05572a694088ee9bd12a2467b0ad185d110a9fe25168911af484de8a75f8eb27280110efd14d5a642b94663b612425a6ddd6ae47a853e30e08d949b58aa52a947f8820b91d25a84e09f36cd39ec6649f355b1251e70d988e36bbb7288b030ad11b01989ae96a224ffe4867f86a8dad749182f2f3975bd890836ae9bf645e718b5da73f36cece71ca8e331a700901920287c697cbf560e4bfab230e2c93b19916b6dc09bc9b2606f039881767ba2a852a1cc2e31c0bd85b46b4e75b39ce272fcee0663907f4ee4e83f51c55e4f52fb98ae0aeec5eef68d5a42c9dd2a32fe30ab8047d7da869511e044553f43db5efc910c2ac26ef8880c2b47231511684c00c87ab36c0cc94b3a5d39a2f3658dbfd8d159ab10f9bc6340623bfb54c6f853fc759ca2837d273884facdebd4f6a9cab27bf79d5e285daa93fb80a7c8120de81729d3b498f2b6c3b3341a85fc6979493a824edbeacfe062cf4b133bffcfcdfe7d3557d29d8fa7ecb8dcdaa05e2d1cad5af68dd76e6114e942f8b3ae5f156ab6575162cb797392d8673220322d51c2dc2f7c794552ec58915bf260563e6c84c6f49322afb8832ced1e3deaf4ed8c1c17b9128761183f995f788cd4a3970f44d551320ddc4a0a750eb9235c89f86b4fd58334daea32db50b23346cce4f85cf7a2e4bed2ea8cf0f96b3894f48f346a3f999ab8d0f7238e28850eb6eb07f407b8366a6d14c6f2deafd3dcc24855bf0c56c06dafde801ea528ba9bf19fc3892657cf787b3f420121d2d28b4597daeb97a6093d28a0159916f6b47b43b4a2590ad6aa74bf1b85b63e42b37eaf1294365917e29e7e5a1af76b8ddfb07822b729daf4b8b267c1e248acf68eab0a200482d2a8dd2cea04fe329c13e183c025939c5d5d2e87d16f1403aedf645c9aadc096c6d0f5b0192a46fedb9f334a0a59546b54c895e34e59894fe928ab4b40e559ab5598e4aa48ac7449b91a08192d9b036393fdfcce9365cde2a3e7ad983a77e2b8cf36cd20eba47ba4ef4336c93cae4cff372dc76baced88ec1809cad8e77db358ec762355643739d4d2b9c7f2e488805ca8c96756141522379458991affdbf24334963c9ee51f899f5c5f17cd9de0ac78f11aa4e0885584966706e551cc3537464b18a34ad7cab59daae9b79890bb8b53adddd074bb198e050ec0de9c4df1488755c0bc376e9f16d0b96967bf307f7485ec54e17d056eb69f543e87c481f16d180ebf2bd5f2ded89ce8596e576f46db079f0fc255726e64b7fa4c5fc4752f163f1d48907fe01a658f333b530cf5d59d29cc2bad70663cc71482defaea250a23f45f003309ff079040d4fa06dd04feedb4b614dc5eaf8e9d6faae58852cc9d0b4aa9a76cd1bab2241ab5a0f45d102f7939a8766cf689866c09be8da47147f0da29321520d749b7a40670e40ef1cac93693b41d1b01af2df8914216e8a67e95327a4d729214104a7c3090f98f1960622185c5f6766755b107f10f11f9259cda839f7c16e0f57c4d36c01c839d13384b1b8628f3ef0d5a2caa1adb605586922eff2c8f58703f30b014e3efbb178ec4602cfd8f98fa311f2af76a6400f3cd29880d3267f4f7328787c817304a59fbb53286ffbfef2929e1aa61c45053f46f5e985bcfb982d57a4e3c3f20754c4324eaba2151ab44c36e5c4568eb5991a9e4bc48fdda250ea193bebcd6572e242945a942c5ff274dcb06b863cee5a12535dd9e3458fe8b1b72bbbe1edb6d63558138ac8b7c5a23571499e26c9724e4c8c9230eff5aa2d6425097aaefe3ac2f84166567255bdd142ad71ab038ef620aba27250ee4450c1b42cb46beedf3eb146d11a9a3792a10786b4766b991c5d01dfcaf6050fb935914f001b1cfcdec3f56127dd93af237018a33b7a25dcd8ef162b72bbd547bb7d598217e92614c374c51f604ffb42aff05502c1895d2953d6cb3113a75f3c0bd187714377dc59d7750503293697a6cf8aba6ba12bffdb7014587ed9704488aeba64224209f609498841851e0db7f4e330b1f8c10aea5ed6af76d99243a2dc6755522cfc68597e1177ba68fa3218c0db6b59ffcb452a76355e1862ba7d44624ac1bf9e60b0828e891fcc537f9188bd8fcd89ac8504259ea713a61de8875a8f82f595a6b89903b36881c55e5e2b98c27c2440ea3b6592d2215e15feaedada1b3bd47f29776ec11cd72eda18cf4e3616f6512282760f2ca058d33641ac83f78fc3152a06dec4a12dc34057e5794208b73776138aa4cef8e0bb135f7eab885a7a10ff17a454e478d10eec84a62ed2f5861a0af61ba5196a63c9be480368668054ef4652cfae6954976286af0911d0fad4bd67b9ad4038eb4f9b5bdb99155845d6d528bf83ec6c74c5be48a517549fd9fb04de16544dfbe78b375321ccd87d789655e73a9116d5caaf29eb61a32806f2aca437e72699c7d86b80d18ef72b9289c5007f32a49a25e79de872b2bb1ccf537232a882be8d45192ead567bdbce66675e33dce3deb4ff125204bb15be385797febb15545287b261fa662281315edb6bc4bba6fac917c44caff10840d2ac22481a0f46dc4e8a3b28fffa26348645745f5b8a3b2800d92a454c0b8caf0f0e1b8dd907d3ec7d1dd6433e5b7ddd4c7114820db27c19eda1c9d7af5055e85efac6999fc034d30bd5daf9f3fb5233881d39eabaa4b3dc15f6d1743ad1d8cb9bce6873375a2e229af1537faa0cad63fe394ebbf87b88375fae13018c877cfc8a10291a1110a993632cafca8ef983d247bc63f201e2839341aadf86ff9ba5f01098f25d7bb625ee266b015f3060904e74ae5b3317f9aa436b86a2bf836095d3d6c28e7f48e960c2b11383563b2f82fbf93732f289613305169e694bc522cb11003c6a8fcf02aee0da32350157fd433c359a0261e9e035cfc7d7f2b0fe3b404bc60cbc15288156924d92c1f134244feeb0f8f5a12ec9810c1dbad8e79cf4ae4de7b988272149fad57c88754160f6681bb07a0248b7b6d9397e8529b102904fda16fa8e6a5eb53733c46c3941c10c34e0f514f08a0d1eae974ce2dfdc643a482f6435f78a4be2b5354e22118e03ac9a24b90a0e33fd2c60fb17d796d884bad40950202522fa5b06ed05c0db71af72d0656b55cbcb3c391463cd1e3c6f3de3b923a8f79547a30860a7d1cdf9914fd005bc4f45d9c7dfdce4d8206f4f00bf0e6d1f07b7b144463dfa2920c36f6a2663934ada2ad2b9f02b3fd76e4d57a59bbc0001499be8f0cd602db4e7d60630bb6538e6699e3daed2ab4baf76a9c19f51e46962be3be749d1cbf164544450b0c6c53b82548a1449609157b6641d059dc64cce138dc37d784b014701737f84fa7d17d0988f9926890c52d278b5f124b57a30e0bdcb99d74c1f62711f0a01d32c520256292e92b56bf0aed11c3d7db6fdba2825f07122b04f3dafdd9feecd006b814e295e51aeb25a57a2beebdf849ee9a8953620dc2c70d412450f7a2a3f7134fc112f2121a80b053fc8238a9e2e4f84f224a92c2e7bd7458dff8fd410fb1ebfa4d20b0d257a679aed2a021042dd6a1e402575d09e0b00d632a16fb6e924e83b88e737da0a86900bc6b1e908d6b4fa558933a2472b44a44eff3d7ce8e5387ba72be228c2a2aa364dc7dc0190943187f53a881e587a41598c0e86e6a285a66b4f05369a2387e59eb65bfea6832ad9615c67aba273d4122bc2066ec3f2991990aa20809b4a688ffbbd99cb177f52a914cb8f87204387f198127339b098a3bccb4638b3a5d35c8d85354cb78b331345ced0502981707c4a78410e34d9924217f1c68522a8a78a46cd9819e92e9509e9929818689bdb507e96795ea1aff48c48a533e1daf786e898ab1b5ae11b0cbfac6ffeae00313dc2410c09bf955820217a06c2c5a5ce43c7337663f1f2786da6ddc28c84c0fbe42361e1028c30b67ba09dd3f37a91b57a4e37d821d876196d756552405ff3b112bedc587bed8a6f9018b0a7b6ec8c77bb45af10c70436ffa2a69fe1f0a48f110e57bf59d1166b80ffd9a01e54a978d2af6d34ad84c9120f101e866064c951a3a81c7d4f655f769b95344d0509c752d3e86afd4d4221906c3b85f8bccc4ec17ac01aea67d938f504bd4c6a9a0267a38511a1ada8b5043148411de72ffc8d02a5ac569ad3de6721628fb6899d3416ac1fa0ae0de0c1278c6820f7a8a54a27ce04710e5ba488f810bbd2ec48d93f41970e5dd33cee550abb004ed86638a1177333470c84c196e87ef733f6946e10369de0761e95f8698633e572e615cda5d10f5d8b1c4132009f06cbed8228197335a9806bbc3c0a0f9a068132311d7d201e58c2af62b0624f5e2156a22ea6b80eb2b13f1e0693bd837bd156614df6a926900e5fb11958f459d4ec581e618ed0658b3294dd47451f31e8e25f06dc2796b689103fde3408dedec44ac0f039bad81de3e6ab1516d43f4d4a5fee3a92e3ab3eb0805324baaff47769e50ee7399d8d42776e303fa0ac1058556459bc56b064cdcbbadd646a6b5e081237aa02eb14e4c43c405edfec3c38ea8355954f4535847574305b24dd0e0c3f4905f23ed49648df90898c38402844037c3fb09eec5fdacb9744cc3eae447503815c4d53bbac30b2717cad727d55541fb00e604a9b426bde287e42de89dd9f03bedaad9d74139319b6f088b5eb34e318c314f3ad0d1e05609fd829edc3511ce9f444a0fb8a305e280b4ffcb8e169c2afe0cb593d272adf0f4e3fae560e656fc2716e88f1bf5d4ffc485ff98cca6ff0581119b1e27c63c25ab144983c6c60648e3648fce7bd7851da5e499ac9b83717013185885c0d79ff4d6403fb483d486f843137c674fe411bf926c110872d7452a1c10b68e00857973215eb07b3af65a7407a5937a0149f8b3e9ff74804fefc81051a8319ed6faca4546221107d9dac4ad162cfa5a120c1307028a242dfe9fea61672f56da8f60f9fac1c69c83198a2550b0c3a527e351348a533ddc505cc19d3c6877392e8c678c879c0a80127d1ae955611da31b28aa143a02383008289b7de712136450921e1a45538960acf36767239a855ff621b72f30e125ba38188ac4f3d6e861a001007986f5c7cf759c167dc955aae5e4289a55dc0e86fe8bd21e377ed972530992f5c33301677d4413275fce4b74cd8d6639884d3ccb746e38097063ed8490a8a5771063cbfaecec13cc6f30d9be75f8a39322a4c997a5c87c0a51116f5c5b18a832ed2fd9202230a2c0161e2e00319ca3b99352a2cf2535f38e644f37395ca5d6051cd139a3fc63e79c01bc94c76de9fe45426565385968924385b87a1b23efccef7b8c63ad7b98234f53b169aa62900c367e85de4864e8b4cee6afabc7507f07d417841ad01a204460b87ff0b753fa14e3c98b7db8516110ae2294eeab3f922a9a903fe4fdff7a86b01f0f07f49efb3d5e790f99e813a3b8d2f895b4068791d8ef77efc3c38e656ed32cc358c623598d5d4e1c053a0e2d82667b52bccf43d9873bd8fdd6abc8724edad0b9ecf93744143676d8d2b3af077ad27008d793d6ae2a3f3c062d2649df5deff7bbcb6e3d4a0edb118c1e8cba739fc7f2d61f582ba702b56ef9df39673bf3d50b8dd70917227542ae77e735cb41c102a39eb981e74a143d66152affa95643c5bb81ed4b1d87f3fd9a86bf894f9c1c055358c4384c47b449003f6150d4fcfdd7bdc98b32d91970a2f02a19b68775ffb95cf87d00e196cea494a480db016674deccde0d7bcedbe8f44c67c45594277b271bf008e623b2cb98cb0a0e475a7e99f27f5384a39f83ca36ee95e7bb1f893f589ce65aeba1d543080c207d706a13df48385464c84678f518c8be5b48dc5c320b4f88fc9e2a530574275c63e79da6be922f5e4cf4d32b4e37103e4a18a013ee0c1cd315eee08a9fc2a37c82d854b60f712a5577f84a15d9a8dc98896fe458b45f7c2c9fd7a26bec92b295d9982383d05fbb9bb19ecdf75d393057c07ae666724cac079e42af8ea0713306e6dc2694fedd7af93f6ccb86bb69ef232b2536e6ba29da3dd2c4d06dd7f21583a0d04a13c558acab3c8637bc3a7f13445b3e94cda10ad9243a5315d86b4b7f40431718f1ed83dfc1aded04443a4bc768d43d38f6a4d9ee35ade027d322596c47c88b1412e096a55f556b220ac63cffc6e546e398c401202f022e936effd7a1bdfc031ea7ad708eb0efaf6f1b5aea76643cc9696e1eddbd9ac3d876835698f46465200b38d2ed92568c442669a035fda9177b7435dac7c11f939e8e017f8a491211bd41d37acdd72824f69f69fca6e75515eee62fb09b4ef926fa4cf12bce2da6aabeb5de8d5dc07cc079da60641a7dfde58799e7d9a3ef653b04d165ec66f41edc40d06c3d7aaec6a5ffd6d98f88a552105ab156084c4c41d408b391f4c6415b3f4f0891d513c376cf7945a393b76a63a5ad66c71ef133f5633fd391826ff668b7d5d2d9bd178394181cbc3595dda4d1cfb2389c0ddabe9407e1007aa2fcf303727016114e332b14b2922ffde103c21b0faed88a9bba58b5d202ccadb6c7f64c54eef82a85c8b7c730eb8b4a577634cce9ea9a887aa4d99cc56dfe0be957776e76a27c2a19826eb2208a1a459ba39cc358aa220caf0c89dbc659ae1c6602d5546aaafb1986d52f6719177d0d3146baac945733ffd7518ee64a57f1654f384bdc59a39d6880113e1bb25b12dba77e34e2e6009d8446bd3b29ca068b9596eb8aa001803d0a4a95f710802f0566bc7a7bb219e63cd39bd607689f33a5342affdf05a54ebdcbf59eef2678613c832fa3bbba530c6a0fa8a8beb9e108d2e2f60273e088a140f021ea1e6cf6fe007edf70fb542ebe4908c9b16cd1e65d423b79e9314dc4cce252bcd6dd704d3e9634ce0e23c5f61ec3fa6d27d6a4eb2d336f44b59ac1d7b70f6e718f7b3d8436db42bf29d2e7b7cd9d192cde1e3661627f86c1317abc1244cc953b55f6f9ba657d502a78b04140d6a0ab168f286a4b68d03f0f338b8c047d3044304f144331f55a0f84093ed7cfd50193424353d5d54c7cdbf2ee3f06c22844882326f362dd9e45808671b2f7b0f2cd8cd3a7db0670f05b70ee7d51664739e046a307270b1e2e79a1eb4e0d442340ad4093a2fe050c48fd20403c0bdffbdbc87b95c5d2469417e297e5ead06c64b30856ad70cf96b18c3e5309f4df1130267c69ee4770a53f5c76fa52c857f05897c722d46d13a09b4816b86259c484e98e3e814a49bd05be7c72e47c2b506503a8a714478a017c96ddeffe253cb40e281a23f17b523d56f3a269873e7be2aa300f16b7568e42b0ff05386a5b495eec7524cceda4a6fa0b9544b0c196ad050be9cfba7aa63812757f8d1ce6e1cbf50579c2354c8b8202a1454e3076f5a9a2008954fa1be7004f77fa0777591dfd1e6214dece8dcf5ceb70230ff95d538d6a580fc467ff8ba66d9d23748893f0f485c3b084cd0e8471ca6b4903ef482d46b9bba87e018007f35a7fe6eb44c65d6fcfe665ecc31f3d79f2193821238acc95062c4007b271dfef312ca607c9f0e5ebd1b4001a583626ae35d5776e7450beebb3197b798ac1749851f5adb4bf42c733360bcf28d782708ac559fc3f66d53aa33a725c31e59ed57db27735dafbe40cdc626e15c036eee7a0d85e61313691e09243ae0657c390da3d46744b13bd10fc4705f56536ee80404108cf525cad000593e5cec33b43870f1c7b387632c3b7e139c4079e0b466c8ffd8adb60195c8c032c6377e68b3326d850efdb3c28fa00c0a56e298207cb56ceb7976d3e41ad6254cb9930f71042b4f07e398ed1e0972106173b31fac68924133a6a44f49f1d43117924cb02a32c5de3226c5d870515b3104167a60996b5412a65cf5e684ef1777ee3e219ac23fb43194ea45d5e9d8fe54f4f48f8a0af79affe42dfc952240766175201fc3dcaab1fda70fe41900c10bdb980be49202742c51d75e528dbc9c5c8f24488f371d28bc88377af8e2a11fab4de2843a42e4e5782571affa29b75ac337b8992e6558151c60f83345c96facd5b37e26ade03e78f00c5454e87f8e2611c60adc2cca56de91cebb9292b943c5a17c62d2efe25d26da66a68992e2f8663bc7597806e8e888adf7171188b0fc41b786aaf1b2c9d356df7ff4a04697f8cce71880975843f150a99e38116a503dbded1a715ae4f10922c10c077f737dfb82ebea493824d4299dcfc5b942de81081f55538f23e320d0f30b9c2105602e6a592553ebe03a1fff11e715913eb6d13fd9130c453ddc8eef5fda76378ded9ce18dac93eb73125dddfc35c17536e3c425f9a391a80f4da734c8e4d231de32982ad4a335fbc5ed17cbb70344b780cab4a14dc4b5e638c757c6c6db88f2e5d972427f8791adc5294759141048ef1a9f8be20c91e7a56838ac679916b41bf24034959a9ae151c601293998909b7b4ee3b337645e812b8ff437de88cf0cd6ae2d8a1ee21d58ad9698bd3620079681e7deb3c149b322329c9b65ea6afd7fcd1ad905ee9d4c4c661cb43174ca18461921ddd0843d18a0dd98c50065210bc1b2c87ae134cd0ace077e997e3cd7875c8b9b7b3039005e5fbf269822ff94afe4f3151bc7fbca34661e3a9b4c25e68232feaa368a39f256593cc0421de773a422006a446dc14bd61dfac9b2a3485fef9e34caa096fa7b705437d9954f08a2ebd6ee88737b86afef1fcc68f7a1a0f62439514fec62d272736cda12ddbb865ad65e9ccf105ad8971c9a1ea3dae135969f9ccab9e4117e6d60ae5e69d5de3e0d9e14f0a4562071759a22c8c5b3cae7631dea1642979382dc63a8833d84c9931f5cc4dbd9e37194700d8298197c7bd22e15827ef0d20dbd4685fd99f41de2d1b3adb780b32c1303979ca20c6b0c43caccb95fd02116def37f9d4964d9bc0435fc59338be87fdc6f07a21fd1a66c8ed083d0b1ac1dad183474ec7a084dfa25270be206c5bbe6936226c94d3ecfb12eeb9c8f4da44624442e75b818e9b02f85851147f4ba78823c56cdf93f9e1539e20eda90dd49dfbc6a136641fcf2cf1f5e7b9c5a9d38becc829bc3496be0b3ec7aaf9a05fa8e79152287a5d0d5abf6db290121e435a3273b38864616f685baef1bf9ccf33a809ecf436d3bda3d0bab8f53902554439daaf98d2a87b6c58899f71e7bd52602ceb7b94cd5ec6223c36ccfbb1f5daef3e7f1a26d33748eeea6c8f2be253014353f37006b17e6d981879b0abc85035132eb1f6575ba1b64029762893af6818c5e9b884c6ef1f4b08c14c1a7e49ef5fdf42a6764908ef40e709c1a96b4b4e2e939f4f51e120e3324005f497f9819f1f74b8c58eb5b3314831aac62df80768d176c15903ac679749bd54ba624073c3a9439e0828534a6d0f66ffa881397a775f572768bc4071b0098312dbc81c25f7d004ebf4ef30da159eb99abd92bf1eec27e4c5f8e38305cff301effb5d69e48deeb23d52bc54e5ee5e99cdb22e473e09f99a129eda0b6abac4155e0d18bf3647db022b13ae275d8914572e636431847daa4acc399939dbb8c1bbbd2ad0f005b76a241595ec9a712562bac5a21b9c73253cc77f77060a648b3848b3691b6085dd2349998333d42853540d8d07e55439871144f7f777f94c5050a4312d14360544b618a715ea232d6e00ebaa5380880e8d411f452dbd73d110885f4f89f8e9b75ee46a0c11ebfb2aae869a58831509c9b0be1603bc6021e87f4b43ec20e40fcd0baf8701630127e9fa05e0b3d01652b8d7659bf270067a16f7bec4c08fe4dbc1e097cb2001eb20a30030bdd57c86a6afd801f710fa4aa098b3a8dd851a2146197ca2ed2a01852346eba7c1cd8427d971d4f37256fa477c0d752212ba882569e8cec8507e5919cd22e313e2098909004a6dfa2d8da251bbe1853ffd5966bddb2c1aa332990ab394072145f7ed3e38f29c424e1c5b387bb375ff963f43e3182f81ce1540368de5e5b209b7a1e5a3ed999c4f5e1576cd76599f70e6e31eccf286b1884a975aa3c697d1e53c3bcb571c3106b25c569dbc58ec7def43b79ccee3eec8076b13f1ccf309d4b57005b495842402a8d0c85b2a0f0f8a4d52fc349bf8cc650e2bcf10da30efa2d0e3dbc9fc9808514b5208f9e12b33c29f9cbcee3f2b67263a92f9ce033823b638af5a67c1503886c4c11bd643009b954fe8a53e512d1aada4b7eb688f3f7b0d1c48d7204e84d1ae39807828a5fc3eb5a51271508e668950afec849774bfd640e3c228e485a137e10013405103d6fca5c91d25b6509a20ece9c8e2c177bcb6853b50ff1133a88f21fdb7305e2699104fe09e4eaae8dfea1628a0a4d4437ed68babc4a59c9c5004b6811bb432cb0adb79075922dc3df43a7e0f2e21007260e5725a0583a1c115f58e045048b515ccdb80e43ec439fec8df88ff5906fbb17ccb798d55aaa8fa44e2a605d00de57be43f3c894478f244df8d876637204680df3d033d1e1bf56272fecbfac9c6d264cdcc4882c809c7fe2731f86860c09b927612d1b9c0bed9e748247233adfe591f1da6d1e1eb21d3af9e50df948b5e8b9b4271fd3b8bb2707f04b6d735b3779830e2c6db452ed75dcb367f2627da18f39d088de7460c5306c383cfff6e430e2afa2d61595cd301a544d7beb99c9fc31a2c283ee73a6d3564557d9ef4919a7d6b57ea69ee8db97d2a9dd7e25a6dffb0f555c229e673ba7061cf04e43b092ba28a00e97a3456f6b32ef190011f1bf3b99d7bf0ae01c1a4e94b71773c995b64f3ff94eb169dbebd3f3848793a6b14ed94de9dd388714c50ad6da237d4ab0d317364d5cb0675e133bd3ccf2a040d32d22657d6a147ee90391c93b619471e5ad71351ba639a34187d5ea358619ffc7c19be3cba2d23be57400f223c4b8970a6760e0350150515074bdb10aee3d9ebaec73e908c496cfad70406acb5ed3f9d7d4ac0b60e33dc09040581b7d6bdb1a22e34fca7ea1ffbfe7b66a01a0440cbab4229ac25a2e7e8d9014c382064795d897f2b642a0d099dbd8666dcf09858b2c01aca6b662880b313ba8484c4c8a6e5500b5baa1ffe8492bb7a55647d84b14f943d62fdbed9e6df9534b2c5f8b1d1c8f8936ee8a6f392968f7c1ebff7b63f098f9c3204b4316e72054d0c010d2e91ad8c7625b7b8f8c9eb115dcfabe5f195ffd1c9a641758a23402705662ae0b74793adcdefb9a4f6264a19c33ce94faafa568f6c4ea03f086ff7a0cf45c5a502e2597081d407b9cf72d5639522b30a36b0683e9032f01307604887bf135db0beb8e90bd71ea1d15233fc3983e5bde4d6136ef7f0469776f94a0c0bef9c50dd30d30b098727f4272139c15ef96b14166e6b4f0dced4fb6db982ca89f0d7756e6c5f8190f782d0e3ad44b5d4c76fb63ca552a66c279281fe490bd573365037fdddefef9d0ef539845329d272712f9aafefe2a60a79af7a2e79b99ce99f9d2b4f1c3216e69afd695bcaa75bf7e261b427f0817eebca1a28b030ba323706cd700570254f29479a255ef143ca00173cc15f3e95d071cdbdaef1ba3434e6d6dd194730c4aafbe004cc4dc197d6f4406a175cf23195f81e6ff7b837a102892f1daf68ff16d3e7f2cb7357d9fd1ac969e17734bb41f5f01dd7c9b011766ead5c4ac64fb9a3bf03d95f9a24fb83b689b512ce869c0391780084eb38bec2c984d3d33870876cd4601c6c57d6c64d507672e69a604be290c56b5507300d166d7d37e55cb8cd4809bd05f458cac445db9b8d6702cfce1d5b82595039f894146ee3494970d113bb6b4e47996c7371ca0799c7058773eb15171b2689bee62f6dd3b0cc229ca01c119e44f0b7f910b679893fd085cf05a52ede51999d0d6e2fa729fa0435fd5052c0bc46f8d0c82f3aba17375e94271ac0319998f9feadd13b427f05d33f1930ef6ef2ea0bcebd2b25a30b871d88780db5fb60e9ececd5702a0d240352c63d6a857bf5d0d1473a95773fdd4630231f1645f85afe777d5b32881e267f1addc98f127b3e8bbd58b4d126e9c3d38f028818f2d7f2e9dee5cda148615245625b6eb4a76ef840d3ba92df9657f36585f2d661fa0302192fa769971cc7f20191540eada9b79df9a6846cb7b39d77abfbf75c8fa428b0f2bf5983e5baecda89e5a28a9c1ee80e03d1b90acc5d9c8d667ce8517481cce8969aa50a1e7531508ccb9d2dc13f10c75b9b8937c288e9e93535ad061f764145d0215e2f67f65e000963c9b1120435229113b5d433ac91c135fc2a63b64edfb9772717b75decb225e04175b2b3fc60e61eac0970d1c2e87e9d2a07033ad20e6edea78cd52f139cab66dd81a675cb5ac2746ac2454141dc84a33e01caa7e579012176e5a0cc5efc39cc3dd16d33ee0ef8ec011e4972cf03ef6d58f86197bbe1ddd07151e30419a74f5194d9857a391da5082894b16537d6392af80a2293819f646f62217d2e527741f72bf9267a3a0d1dde68e23c1f77ed78eb0be448b3fb0a9d6a7f7480568289c6c2f61039e46d1eebd96f3b9b073b9b82876f4397f6a4ab806955f924b8e092d07d2b3fa2fe8b8cca209ae57fe65483f26f613f4d0efc028b6b75ae52f447ec6df1c058d1e4aff2d12d788f501bc4c44e3da0b348265bab789b2a4f42b72adaaae17df0eef1ece96a0a7503399735abe70d88543f57b084fbf1a6ed8a348a6cfe84ac897636036bdc0942104b91c3edfff50cd58542c4bc0d5d4e6d3725bf116b61172c871e377e1f12288d982ea37d43417e848d9c0d3e480b54e6b5cf3f77b8a11741302ce0d6264a3dc4c303c056e503c116fb54fd335729d44fd36b5e508306d9cdd2c5d523f8c256594a4046ae45ba03ef2ea56952abf060503bb9e0a055f4b5925682ba1a2b78d85003ae69acfc649b3f3f576bba1058b20170cd911ef47f54e0d8f062854160c96f9468b3f5eda6447db2829ca024e3dfcaf6997c6f4da37ae0088c48223062055c4770533fd96aee734675fd4c6ece0e0e61d48886435b092a525564dbc65ae8c54d0ca1d0ac35b309aec20fcf5b94fd77ea5de42acd7bb041d4476ab95c573782c958c89569740c1d9322e34a3e32665f62f86c195e5f53c6a3bf06d697bfcc06452cea26c436c9ba88d995f6ea61f726daf74a8d6ffac1ebaf830873807e6b2e6daca02b6ce9c60f30d738d0b225fe5f63264c538da0ee16d6a2575c30822f90ee779ca9ef201124a977e604c4bebed2bdb594f6da4f7b0be7a3a6d5849f8270d9238a3873b3669623058f9b5837827f8932d337abad2755bc84df2429d93fc3db636d09a0bc20945970ebbbe1f35a98871a5e7afe2a313a2444853bc66960197d730f8664422275ab4a374fa01d916ac04c1b2622740f145316800af4ec5389ad8db9e334ec72c32fc21f0b27cb96c8721c606965c8e8ed05bd73edc72d74bb78930eed2d376f3381c86993182ddec53ce5367ec0fc802c76e61ac8009c7cc4401d2769a7ad3a8d90a2c35ac9b4a0241bc4faded096a1fcaf8200d1a95e2788a13a075f0c3a509100e444e8fc66529431cf9d03ec586fe5fae4002dc070fc639c77b363b6df390aa0018c8f50a2c9586f34832c08fa97a79cddd9b894d3c561e286c68f3b623c36ba716131eee92946a9d6cb71aa5be4f7760feecf08810ff8a1c188045c7715acd32760889f10aefb101dcc8ea54ff7ae783cfd9d623fe1d294cb7a6bc26ff5259b04d9e098741018477eb22cac1284c87b29b22b291a630f3ed025d8ad70168217d950ba651eccc25a7efe5e053e7ca5e74ab963b3e1fe9a47be1b551e1d8c202284fe7ea46f17826408dbee7979fd647eced50ac2883b6ecf986679aecf9c725cb12d58ef19a8bc3bd99b6593759b76212ad0b099354219d207ab43ada88e5032628c9ebbb7e250159aeeef063a17248c383df7552a320bd46f91fe10114","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
