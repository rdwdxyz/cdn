<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29acaeae5e8b6e27ab15de6b7060e2c74389414d087f1333215bb009fa1f00d7a25700bbc210ddb4a7dc873bcee38f58a93af097eb17849c6c58c7eec689fec07ce5cc46f94c9d774fcfd4312f786f832b0b5ef4cab69d3f1e340b45ceb78acadf55420a3b61898d47a1b0c5dc24a8e0128c8066c8ed782d12b542e730915d478da64bee6505f9350d880c8442a4403fdd9fd00c132bf26bb58f528739275b258c17bbea6a1fee3999245c0583b8c2ce8956fa1b1cb2d0be511c43d497f1989bc4c76b59fbd15e32135a1135930e29116f7837e541b0d46323fcc57c90043107cdf10fc46b2c9e93e074b04b79b8708ea916853dd9ee16a93825a67216d3182de51b50aa7537f2649b7d4ac444271720eda3b47a2bf3e0c9c6697d41e201be9eb144120c5aa6ead866713a623f8d87ad96ee10a7195ea0220facbdfe68845fc64e74beadcf7fcb94e7b76da401a5f38b671498395cac40759dbcaef915d15813d38ef5ebee543f801c4d365b3611fd094e6f7b50b95700aebb6736ad99113a427d38ad9f3dd6d20ca474938ede86ed8ce3e4e0e23754e7e3a93b4b898b814b7a11a8b8ea087241b1764a2c73c57b697a6dc0b6a2cbd0e8fd08c6c8007dbe19478c7117b60c7c4815f29755d5b3fe447a1288029027adef28ee2e7e8971f7ca484cb3dea58e55768f810fdc339a0ee26f67039e34f8f92e71948eb05efdbf18f51efea16293e06ae3b0e54b7c15fd2baba078558fe423a62644f8114ed75a590c8ba3f3a4d664bca02d8eccbce45b45c9667154570b6723b5c33ae60b17584df39ee31a822d5587d5b23de311bfc081b15098c6fbe4c5d127d0249dbf632b8aa6a84965e8f9f3c80fd72b0fa90e8d483377fe60d550a0e2ca87ae8eaef01fb6c6407b3accc1f2f9ece934fa61a45bb0c5b6f83c74d26c37aa8ef2a15f42c4bc85efa4cafe1fe1379a8deef603a39de92ecf5c88921fd5631b2c8b761c912963cb68dbce166b01d7ed11aef087808617e6a1f6517905b8afe5a94f271cfb1a7a9ba964f589c7a8d960d770590f149834d7eb44b786cc7cfde2feaeff2431eaa2a3edf248d199a72eb95363d5b62190fb1973d85569d9aa8b1f03d5ae5e61b66c01584ced84966ff59b092eda31c3debfff82f6aab3b47b227ce8333bd778723ae2a8fb1e6c32f1ac60864aed2d7237269b3b65814e1da073afda95e3526f7ba5a4491ed6560d4fc3fe034df86e6f89ea94e1de69d8ea5479f5edd22e8faf6189f7df70ff5c4e3b657c3e58084e3ae48b776ee867b2cad06b2a5197ba1f1f2cc331947a1584fe66ef6b48c89c4bd984a6ecd490d7d9b954dd1c7c5dd274797888c915969e8bab144e5e2ad4157f458024d5bb6e3c3bd57c04e360ff5ab07215b72357899b0d515ffa90c110611ad17dff728a14388e07741c7e85dc2edb04eacfde185c1cd7381f27193e644a1bfb3a61ef4b408393c90a4d379c2b47da64d85d94c0e180bb8af4aaf6130c51aab442653acc37ac3ba8b8376c0a7cd46803667c1c518c1211dd568fec15d88fb241ad95513b2623916547f3d948e67995788fb677a0f6abfc68a26e38d56baf1ffa4d62022d04dfd31fca43b2a25c4fbc57ca7b74529ae97e6a67deb8d4336c2430be29cc9ebdcd491f9d725e87eb1c8a56dbfb0a6b05d5de87108c062d541337f6a10097a0c0c49d37e498382210a049ceb9dba8b05712eb9e19877efedb7d69cccb9ced147ec2b65e71e3a1a9616c7dcf46448cbe5094c95e2d22bc5ebaf84e78b808c08dd728e280293d193eb71dea15852bd564ec3d37215c367a779130d3e1e0e638a5b80ad0e44007f4d0d587a51a6695f77541a615cad4fb37556eef6291c5323d728e853e7ff36b92f95bb2c264ad7d4ae282027db7f72d969ca7aa413ff3be678ac2f2b13b1abdf6c87a37e47c4848a60d61605ce93f2a8af0aac6f5ff0f9864dae9c0a2e908b6c5b66bc3e312b372d29f37c509c513ec2d9aa57149497bf95a1ec90750b9d13154651a5b697b63b19b1e6cbce2d5e498cfdac20037376b375965dd53be3cf5812ef7c006b5400215807c9f7a55ede36e5c4fdc4f4be8067cbde89dde2a49fa952eaacf2e2bc8adcb5e4ccf078c13734490a065f8c10e23e12f7f714dfff0b64061448cffb0121ff679031f55514192e65652654acae23cb517b949f5adbd6bcd471e5abbc2374808352d8d3cb6f51daba3afd9fb6871dfe4ee41d38bf1e992af3335dd592a65c0b28113c237cea8c808941b61eb5fbde6904e131eea7d2f153720f86bf4f18662e1a2b7f5446e89029ad6f857f2ff73d9214aa78efdd6bd48a39abbb077260089e028c130066b59071de67aaa7641f799ac8093e13bac7fcdfff2f1194ddbef0cd8b17654069e0b41a1ae4a91591cc774547fe924a0d4ed889d02090ef0323a9449f79f368174af53dd8d026e2a6b759c451278cbd71d098cdbabea15c5bcfb7e73526087971c19188363c630d6aa71fe486a3a81baebd9a8bea4301c2ed0277a64393de24381e99b24b659d0645207853bb5dfe67d2a44dc30d35ade7866bd3fa98a72fd4395cafe3a04cd4b733fb70592b72fb29cb9c38ba4e644136d576cfcc6f6eab10dc3636c7c34ec92fa158d7451c7f63f27cf336905c051eb39f286df6e1f5a0504257c27861c383f1a5f484dffb1cf0238a913a0bb5c4f1bb55edfaa3a3e861f336ce233866095616d8a521576ce86949a20e2e90904314ae3d849d6817e4ad63abb95da448c258e4d3c83e71c71d1ab313cd97218c684f48a8883446a833e704e79fa819e845b2e4b94bfc85f894ef04967cf9996c210c5aeba941b634e4bad374801b4fc9483da69e13472daac2a3eeee0ffe5f51725b1924a01481fc70fe811de859b56c709d344f9fb1ec63941c363749f25e9ba9670dbd5fccd5a1e3a81799bcbc469893497e04ccb01dd2d47f8ba0bceca9af28573aa841d364f7518186772f7ffc8e400664a1f0e17c756654d2b3a39176e008f480f8a2ee962b8c3ccfec0fe8dc7308cdbe441123dd60c4a9f5c50b1bb14b064e8c8c6e4a2215c433ced64bebe95911a0dd95734f2df6275ee3d068c342a189583cb3a5d5f8bbd90c3a14582dd566be759d6571fd7e122a068e790e87a5570b9d49613de2f99cb51681dfee07ecd172b3dba5ee0ea624684995fdfb1ae45248ca844ddfbbbb6ff0e0723f6c5a28a618315a8d03b48890314a68a396fca3bcf75e3972458878eec027365ece63dca290cb6429a856b81fe08eac3def2153b3a76e830391252c703f9f26916db1d3cc7c9664ba31debaaf2bbc36b797bf12613010adb92b96666a1a43a7ea80909c994928a9830843bce38ebab43c9b05b72ade97638a0eafa3cde2c10c036b83b200ab092e59415105626e5bfc22dd43e44e0d216131b05107c921f2873754151d102377b7013cf39f2050207f19f7c736a1c76a16961adea2c04cf65ae3f230c272675d508650dfed9976dbb0bdc82b3c36103b198091b93dc6dd3a96848aaf4a39b40a2a5e7498534ab55cf843eca96f1e54542f107ec2b5f62575d62ee2b949c016e37618647802bb79d7066d3a4268efbb67bfc8f364a42c5001c1046dac1e6d860c72fe205dbe77711f4ed3d02b1ed72bb87092a4f7479ab2f4b1ead415d7eab50ed55537f2d74186b9574e50333f1c726e80ce35dc828d54ec2b82097701b5f73baf0f221d233cff0b2bd014dd9036f9b4c08b32c0b2429dd4f3c0fd241af42ebfe617dcdd415d52613182e662678c0a4e4333b360baf12ae1b3ca0e2ddb0c2291d4ca342bcc9b212695ae658e01fc1194591736b9358054fc8eac533ca35d4e37f449d66908111814f956a70476b52f8f7b0a7610b42b95427bc84d98ec9f4dc63a595106a83168b9b27dd80e1cac82002e09a6c029ed3ade6385685af17ee79fbbd416fb54d9db28adc09450ffec3d82e3001b7d607dadc73a7d5fc8a4f0630b0d6d917495b859b74ef5b1f9ad413ab15f247c396b8e4945d5caf491d935204a9ced1585703127bd96a8054d76975385e3409d5b37ce4f527724c1b8e2263078655d65ca5974c0c39211f5faf69f558340221cdc2452c62c73dc2b4556a868bec63144534bd4c4089b206daa7d8faea3ca0ac9c04f100b2b4d291c0b06e591616f8f995fd6b3296d691a6b44a5411663fe082bfe6be677e0cb3af088f57259bf69b58cc7018fb34efde96ddf9ffaaec327387a27ebbb9184f6a4d50cc3ace1e659231ac518510225062ae6856969d9ea8bc5864abc163b058dbd42a3b0794bf40f837d87917c6583d56530d21da8cc08b75571cddff2bd977e5acc85938686491fc9da0fe4782b9d6e001dedba58cd7c7e9400d9b965385cbb418babd5bf1f4bc6422f245645c5c92d3bedd3360a7d0911a496a88da2a3938dde936597c34b01eb4210529411ac2dd927ba96d44f095a06e1e4ffe16055ffba3490a46e2c19f77fede577c767d7c88f1035c020a9a6af5c063f9754ba0e11e26efb0d0112ec76dc3613bdb6d8afc72bfdd7ca57c0a1f7544ee183a3a93110181c535c792f3221ded7848890ed40cc18955b7e55af52add093019f3ff14679768dc6054b93f390477071bed76eed835856b79699718ecc0dcd0567e3c822ccbe5db49640b2af243b4da94040786ed14076be27d0c0daf5af8aa7c72f068f1f567f130e4c9f11c475c4af3f9f81906cc0aecd427154adfe0cc9ac650846224c17c3dd9ed14071d90bbd18e6e7a302b5b9cccb45a21bd87717931105ebfbef72dbfa4139585f6999efef9fed6e980adde5111488b4f9cf558049f387949b652a96ce047e851851666267dddf869feaafb27842bd7afc24f2a893d93ba21c80edaf7f70a6775aeb92e06d8a2254c652ee162c2e8e0edca193b6837e6fa02bbd36b98355fe197bcd9c72ebd137e9f060b44b431ee34b17f4cf5216aa672ea02745e682184f8472a408b6a58445560abb3f233d5abfae0745a0bb4680a9f0cce5cc947b9812f949afafe7611dcdd7e8c58face47171af514987c5f153577041df6db8fa55a336906d5753c236de27455c4bbcf46c127e069e8b74bae4637b6bb99635e75a5969b87c1e35d0d20a84f7ed41e46005427ef6818f23d0600f6dbc8a2fd4e3d04f5f3706db3a869ebf0752eedc08da77381d79953be110be24dab259d98bb42eae5ca88e5186caa89acdcde2f924377f4d64c9fed4d5b5aa02e9d30686c37b43c5b31f7420dface0208defc95a009677b74f00155805e5ba5311d28ccbc854bbe5d13db562639bea30c31401802f55d2c60b22e2c8091c4e98442a1acd04818535b4ad551e3d620ba9f8700f60290fdb5fa8a71b2f2318b4b8fc2d7d68b1937ed3da6e407aadb0c8474f4661c3ae256a2941993702288246f35cf2bf18dcd19d07ec7fca5d642bb2273149fa8ff8586b6c952d52977bf19c5f49be2d88d96b7831afb340aaa5e5e60d54740ac7a327af7fbb547f8469cfc1789441ab0d59622dc189a743c52550ac44fde7db45d243638a5b8f1fc6ef6b29903255bb349bdda4c8db4d0a8d88a2ffbcffbfd0a3aa33f8669c2b21c0ba94ce2d956867f0c9d216af57f2bae8342e16b0a1f1c58cac87dc62cd18b4a75918b2164c2935bd5870439b1b89db99395cd9d493992aff5da08e19d4cdc54c01554366e7281c6636ef287148900f4d3ef285b422b28c7ab5b752013cc03dc5097fd7811586565764a20e045452cb2a8f894fefc1d4aa990512b0a6be25b26f594e48966107e8b41eac727e13b163f1c94a0dccd72c1d54a876fa00a4fc68eea6e8875d6274804113555f71d30d6861dfdf3908489ede166446fa17f08ecc73467a86757a4595b4f8dd0a8162bf9e19be035db0e57a37fc0115359431e040000e2bb9cb3f47c82e9228cec43a70d66c19ba75eb2f271ab3b4dd023bccf6c42c7b17dc05e69c395147184aed6c4db71c7be68d5dabd11f6167599dd30d967ab2ad99ea2951f00673dbfde255b475ac3011c237f13642b15480fa0a53dac15fe2a9b4d47e860d5bc88753d0dae5107e4fba02a521888f080f543c7b9e869047bb04c876fe83e32a90f15c3cc096d5cea5efab1cb97af8f0ded663655d54e6a57de1cd7b93731b4277c239f50e965df2105b5046e30ab1867b04f2e1efe341cad2900ac1f3837ce48c233acc965c8cc71297414b24dc346525656b259c8457c2c6cf2b32d0e3ba659657d3930c3a98d78ceb7eb47d10e18d3f9235b457a72d75abae53b7968c16deb694a5509db1714bea6c5a91aa7d428a94b9a94d50e3554bb8431d2d4023bdd3fc6ecf8568133b3007c9d6185944a1806dada6a722fad2de8db14ef9d772ce4af234e2c07af649e026106232a68bf0b0cfcb8b8c32749eca57ed17f864dfa2396910db1c3d4bef19ebe3162c26e5027a3ad364a4044582749d79b9b523854423757f84ba3d76d776bea3afa36a9ec667548c564c183a20f2ecf321d721482fe0dd92a4ff85e2265498f0246c10517576d37eb2b901b0fc79cf37d28a3a2ecb4acd796f82867c20345492b2bbda814431115080bf950f7c46f4cb4700256ecb280c99dbeeb3d4ba7fffe49a4a7d7c3838192c8d33e74c8709d104e588d736d46d69dfa24779330f067eb73dc6e85faf75a988513f931ca24a506347729d5f736e37bcf284147c0689f9e4df5785315f1cd13d05d06804ebe940d2750341237ab3e056b0fed221a71a806c1583567036e25455f30d6c8151465a4754793e509fa3efb60a774f4505d3c1db51648e76b222000f249a6de5d942b25381d4a54aad4628c439e8d2075c36f0cb2eb1ed09fed63c400e02df0cf70f8294b06120af1e8f2ac875c0af26845b2573f43e06c3718e88c6746c16b95d6755557f240737d2bdfcb468e612827e0ab4e9265548bb32e216eca8ee352ba4ba610e49c511d82e513881788fdcf53b1c3394925730eaed75caa28e8b80bf46db016dd3c802e7ffd08d9dc065248058bda0c364da2c59338b066c22c3bf60b30154ac06cb597852f60556c2ff34bc55ee56de5f4693ed1980e08199834c8550657edda43d0bcf4b25c3c0859a51b7c56a086b3ab6db0af487813de4d6933f7e6039869c3a528532eee6eb5fbd63fc20f4586dfc50a82c4a17b57dcd04073b92c819196706f697b19a044f0667801a25e72d3a88c8e655d7ad6b077773fd3da5a281546df96944742fb4f72b572925d72a237fce2553c072712f5969909d134f0c52897170833e57fc43eef00fccd20ed31bebe99129db1bac421fb959099695d69eca62f028b9ec962c16ab41fc36cfd397e6e06dabc60daf302ddf602398f6c8bc3a9a6dcbbf0ee470f8abb2a9172a88f00dc1f1e3846b1b648dbeef7020915ad41f532197e6f95073733e26f2ba76224250a6ecd41da1238e044f4a77c410bf8954ffd79f7ea32fd0eef002a3a5d4dbaa2d7774b00d7a36c5a082f80aadd7587e0df427ee62742f7d1273d2bf641de975b7e244f5e24d798e1d1044b2c9de8e40b47af094d774e5a21def80f7fef5747a3c321f76e82f47e631c8acd1bac518f0c00ce76081d0f843845ea874859b4022a7d2a70d7d2c745f64daca5ed773937d30c4d1c957aa75d8ed5a69c976b93a255cd950595295ebfb958ee1a58f779a536940bf28cbf1620bad8b3918c9fee535d2b00b7ba9b48487f7a26e497292ed18da67424ff0217df80b89667e5c781b25d8a59c627e5c09a6816f6d9bccdb6788bceea8bc8275976e4443b23b4a9b1e6ecdb36bb045592e4f447e97de36bbaa2708d58b086cae1db9f2f8310de5f2db10cbdbbcf535b42c2c9caed8af73a7b6cd8490ab285fbe6a282ae866ee8258cee662bbc403ba288dd1084cfd3b5b19acbc37d6c4fb1d5eb360a097b76024edb6061b71837aeac13af931c7d9f71ed1db308dd21a373f603338c1f58b5b4463a356c856c099ce73bf47ece25b5d5c479f4830edfac5f5d80f6916906038669c5687b0560833d7d717bf358e0ccfb249f953297b5e6b96d973d46364ede32ceb1994a9c8d92a1d807a4c13489f10e4d5f6e4d6042f07d63842144563e6c84622a72b10b0c3dd3f8d030a5ce41565f1dccf1349b6eac3853f982b29b73bb8532ece442bdfa9a3e6305c1da1eff6e244e1869a8a57ced093efa18ee2031c7fe9a34f08bd99abcc8c595397d952b30eb8ee7ec4472d57e00a24b1691a1a94518a68decf864d9333790488d868909b3622c92e73ed0944e1be527fb962852cb24720bfe3ca771e199673ca61e87874cf37366ec9655a658149eadf8173b6ca0f13b2536b94002bf98a38ad8852154dae6ec097aeac16a506fa144e2b7a5d62e5d99059d33f89da9234fe169696cdc7f78bba59faf9eb54c884dffb2e5c7c7c271efa4b68f12209b73ce2c7a4cf9f67290e4226b7883c0cb0c4af15279f29b5eefe1b5fbe2bc3a06bb7fa62da183063f27dbbe52a0cdf4fde090d471c0fb1cf3149cdb80b544d3d38be3b94b7a3bac14c6cf8fd965032eb37f41ae01474801cd7f6e57816dcddb79ef1166fa87c5ae0420c014a9255682a24de5d8118c488d371678bf3323d557e489bcaab06da64e6836a1cc7772d37cafafa8b86803c1cc774189ba45524e862bcf79af7bc1c78eeae13b1ec1f0f43cc54b5260fb9962bdf3e4c0e5a199efb5ee326d1b9b673c5dcdd41c5ac468172abbe5916293d424e3274b3186a9497851807a2c5c4b9ff45690d8d736c2d298a18add19c96f9e008118e3a62ddb1bfdcb0e18e437a1bcd31c23663141d9b01393adf2df246d413fc6dd590a1ba39a684146970e286512f508366fee8eafcf1e068e3756ac1ea393c77d5947fcb4bfb191b57d18297bad1e10d8f307c10a7c92f07c582cfd56cb801fee5a118bce94d5a31df22eda1c77ad13edcead4dce057a8beb4eb4ed28fe68943a95c34ccb9ea25ea11f6e15c28c026fd75de86355ac99fda356ed5c80d4a7cb793e84ca0c4389502fa0682aa784e42fd6fa6ecfc97bf6a96ca0b9bfd2a81cfa20b8df947b0e9fb1bf5ed4ad49b2909d286019372ecb963432497d3bcb5ae82bf5652c3a962228e7281b38753726e0a384cfc9b4c238a65526aec12354db3a61252f8483f9d5393105a5e07a6fd72c0c40cb2abc26cc2b624449ca3dd1e8f3102e049b1f5deb8d305a00def2dd9d14d44f8c585907051b9b216bfbfb38384fae0fa72a1927246d7f4eaf007e3ca4fcc95d6fd56af2b8ebd979ce5fd6ea40a07441a86245a89f744725af57bb324b8667f321d09734beb6a22382107dcc5f89d15b3db886439a251cd3b3338218d7bbbf532d3cb19983d5fca4c492c36e4dfde6230c3f960447560743e3ac2ce2d714b285e19eee8e2b051495a63ffc1e99086eaf9e2b335f6612d067a1a65fe1d6551920340a5a0db99a2f31ac317c4af273df8595db65c685d5492f354c0f97b068c14acfd16354b0c68f581614854dd12ad7d26927b418585d52aa585029ff76433710f17086f909c946ef4114ce737ccc7b19f441bef8f9ea26e29239cdde1fb706dba94f23aabd9ba2b93bae944c45c0410345431d106ab7654878751af13289df22969b257338df9a15a636738e301e34b1bdc5370af4100bf11036e683ecc10d780b88cc24ceeaaedc226bda64eb83e2a8630f4bd086995a1de89964f277b1d7333dd7c85d5abadfd7a83e8d0e8cb20b704a945fd0265bea921d8021ee6d92d442ab23c021b920f7017eb55d20a0f655b8e5de0a69391c5b917a00589fa12cf9dfe647be3e598a0767cd67740bfa6228ee13a37358c308505dddcdf226e4113f1a3cd1e72ccd759819098b37c4fd3d7c26938e1b89627107f6e74e999cf00c6f6431d52f86dbad2ae6766182e2e91d1cb8f298833bc63b6c6b93d8b4247287c095502428a78f9eea74f6db13a66932effbb4ab8223e97d7d0393b2d5c008aab668ad1c4b5b904f3bcea70c04f9fb11a87940c7106244bec5c43143c6c237047f44f3a2e9d67c8f8b0f53318ebe3fd96f639075f0c7bbc71150072e4f0a5ce968ca379f144dfbb338ef26abb772c5c751bb9897a00d5953e0c6909afe8f86067dd9cccd4b39b7e8e60bd1b3839f767e75a7838f6d659367a6914d644e5b592cba9ef853c78135eed04aa0325d1c8df93e249dded9b2dfe72d7b991da312e34da621bf1b825420746708778f2861148875ae2a56bde7ad283d25c67b5a0c5542ef326f0fa404eea9dd8a455610ee782ca79298bf9c835b9011568a0c148b294cbd88615c9bd78d9fb5d0d1d49c1bd626f2aeacad9becf9d0f20f83173594d65f4fca7289188da7c33b7cf340895a0b3cd08e5bded25a093f3e703132b4d2e5f58fe082b7bd6a3a1ebb24fe286d631d6e927221d28742be95ff3ae6e45e313f017546ffc70fbb73d3eae9e1f57e49a816305dc5106a4f761ed33c0e4b5b43760e10a4d6da4842f03cf2a508916183f9352d7dae4a23cb45223268442c010d3fdeaed34112a99e850c1ad14ea64aedf365e5c2c5475fccbbd03f3ab9c039620d72944ec14e8705b05ed8a2599e8d43cbbffcf2a2cc6710666d041add6acd27998d574bb91677854d73c940180a70aef358c0868c7ee6c71e19aba3e2a62d4841ea2841c3f1a96ccc7503fafec9419a5153124b4ce2d2e9f3f4560964cff55837565189af65a2cce412da7d13b4291648258ba30f3ae669b8ec11253843fa6fc526829f9460f67e08701c56a2d768163140c301ce0bd5c1c2b0281b6bdd82014e6f5da6c0398573d784af8e3597a642aaf1518ec2f33342ffa36374e8a81724408bdde2f216f76be86c09c6c17a59e9a996d466b72343e490c93848d10f16f4da0e61087bf2d326851093f28f24744b30c00edebc3922f2b986e5ccd433e3e6037f96d4c19c0ba1d94621fa695aac9ab3e0f0f3d8defea4192402bcfcc4529294a0aad9364ee408b541cb975e3d0495f8f6bddd3bdb8fe254f8798e7cf11aa5b57c200f5e1b20e89401b449f500b7ee9419f4286817effe979c0a5c073e8bcfa439441aa898d5507101a9224cb94ba773dff4ce05a6b3551055740c7238dc5390d97e6577e9349ada4c9d60d7d659bc4a9653527a53740069a1d9abae3a78fc5411d18383730fdfa63090b541c1afe95d47b5d009dc7cc425821c04262f2aa8086d236dbacfbc8d1256d86e8f2e4e5345ad0433ee3609b9376a40c47afd6608bd5d88b9ebea1c00808667dc094322d7d8ee5f6963a3d920b4744fdca528a6a291e988c1af95624cb678a32310dc826a47b881b64e4e4e58bdc538e10e05a2111d8fc442d62864275cecd7b6c5610c72ee1a70e7c6dc36ce84253a2c41152f64de6332fd65f2d31aaf6be673e175759eb518cf4a1f07debe823d69ca2f245b01019150947773922b97478d25a075ddce8119d0e3c75baaa6bf43f44727f5e7323be7092115f5678e42186f7a1c3aa54816f5463ed9ba850371cc38b67730fb8a9ced5bf30413ba9f1d51a22972a4fcceee5e5124ea53c52b4b87355a09fbec9aa97b37b999f21a2327cfaa28f395f6b146b59b5bf56892ac93b1d20c2dbeb592504c9cb4351fa84fb6529bcc9b74e22100b2c3d917a3f9dd12a411f736e444946d188995f16a80f03e207f92f233c9b347239bfabd9e5ddacd1a5e6a1194f2e46c0ad3c144f72eecd75b6c42c0f60e092217a29333c36604c0d18899e7e0144049f0f0b0f5dd4113a2935cc3bf602a7d2b6396b34d1058a6704a84cd2f1c8aa6a5066d4ef0f410241601f0eb9cbc9c28aec7f32834f697fda961953189d112ef2ecb2f3f17b890ab316b07340b8b33a3bd49b03fca00114e67188e46ce826a37a1ceaa3c1e7857d34bc6245d32bb3e858f319444929ed2e95fa371d6a6d66e79ea36a5959f463911877fec93b103ed56dfe38b3891c57da35bd126c91515aa0db8a74d773f4176b11a53e0291bfbea500192c21f23fc9367c949004cdb7a6ec13dff26c4b1a57b90d3e28bd023236248727cd074c1ab6e95bdc15c76b2a8eb9d0f1b289e1f2dc5d599fe95e0b1822c89b4722b71254c0d0f643cd474d52b812309aa4f852882fdec2e31e9aff3c6c435dc2cd2ca7e678b6f0424f6649acd81a4800230ea824534493e94f7e24bf07f0a36a19ec9edf36a8adb563603871d7cce909f4d2695b8ab8b322ebe27d40619710fad01e76897994c2e90b281bf33f7604e106af7feff8dbb0b44495b9babd51e4d23135c139319d1261cd08eeb3faab1db15b3fff8796610169f526a9f332ef00a7b85b30dc2c1a00134c8ac28cff8b2c44abc24616580c3f87366e5a428e00e48840e940a25844d6d4cad8f5768f3bf504a4d27dae12a5e8aa3881ce43e5a70c761c0db2406dc87ec20bcf8bbe7c93487bedde2262eb231b849334b03904249d1b7ed0b1dfc8f6e2aa97552eed2b013942f32ef03ea09375d331efae957bb73b4e3204943107b8bc3073edc6811e5d4e1852fd7e5ae6124d8c231c63c7f4b7fbc361fc55c053ada3707bd3e5c7d1b8c7d1955ddcb46f0dc3a9a09d97091c6e6841e6b71a7370d581e103b0f3b19aa04d7e3fae8172ff929f1077d9cd0b757465886686da33bdfa48db5048dee4b8b47c7ee1740db2dd850d5ab59b78e883205800d1d2d44cfb38fb5191fc5e866da8ec63041b96998c524de4ccfccfd48cc8128cf14e40069c77c9ceab7d830a99e5efedf5d5bab7a8c268fb92c1711a106a64666ab5c9816eadee88050441408110d01e3e06d8f02e539d9ad65150dcf536bb66907da5f99c454eef71385875932f712e3c60225239e2bb67f3e5b23b87aecfca1227ee11451f3dcc5682bc685f19feabe60b038996d021ca8f15081b04dc25a79f5f64159e9a3f087939b04e471ab39fca87e4f80375f70ee8938fafa22eb3bfd4b7d7d54290800fe42ce0d59291c77a90b8e3933f08d162851fdc15a0ed1409927b932a6184d05fbc05f451f29146059bfeee4c8cf2cdb763221803155a4d4b3ad55f533801dd5e5501ec48e6f8d78e39ee7428dd1e3c69f81f620c5139d246cd1cfa49b52c84ae734b03994f33f6a57584ab503ecf0b7cb8c1b3fe62770bf44d904577c18a3a2480df893733376ba7b0a56465ec7c9fb079bdd1f4123de5cc7f5fa13d9fc8f446d525bf82e25d84c36775126d8480275e1d6b9202d3dee1c3c2e05bdee568de86f488d3645c442bde71a7b28f725c60bb6ed1e6ae84c0d38fb672b8edbb1c5e5660573c397e4ee1cb30397936e4123c098d9af5877051edd91c3486919f779c627816ff115252bc37c46f1de3da3b5b2a11ccaad48ccc405c3a1272df85f6ba2e4706ce1f02220b8bb086c2fceb4d0afe8457b09a56000767a9d1d1e82c89bd91e4ecd358614796acdfeb40445b003ead38248c358b1c53330a413fac491c065995254a742d94091179c4383fcc6268e366922e2108b02be201f2f304575d53d3d59e3d7598ce731b4806badb83c93c293c9f176b1194da59572237a2580bf6ad81b689781972d44b14e3f3d5d38f27dd394f90f8f77ae707636a30ef60c745252890e0097fa4dc5d409a6cadfc5760cb65597eccadfab6967a0f20319d99467f8dbd17c36d805d99155d1cc48e47b2d8283b787bc5d58ad219ee0778680235aa05004274188fa80c883c99e8025fe6a6616a792ca526fbcffcf1b6187ed002bf000d96e564114ddab2de7eca75c4ca64ce31b264f0cf4492b5d64d8b381abcc5c0394780bf717fbc505031d44ac496fa846886990802edff4a6d1f51186b77e96fced6584482b3da7ced681755281dbf31fa912db2c8d24acf9df74a099ab77ce13066b42320a0af22a72a9ff4114af29d74f1a03f2c6b33cd4e909f3a22c07cdd3668307058bab2bde6bbec812353b4ab394f809e427215b92df33ad9e26a82f2b007ecd6e3e6ce70a250f5d7adece41970a787e1c5065833de1e0c464722341732f806d39fe2ad555fb2add05673ca0382f75f706f4bfe0a3a5f5ec448f7bb6c0db6db12824c78e3522b209a7794e514dfa2ae94e1a22b2be22b736887d3ee6d29ecf219579f6695b40d3c0486c4ef51fb26ff14d668c9fc0ec4f2d8fe94de0fcae958e3fa9446da8dafc10bd81ddd69de16769e69d373e418b6415befc6e27c82b50658e74ec94e11a582e09b40931b6bae0f7cf060072711a0d52352005bbb2ff102ec6f3f94d401d8191cb24ae58771e59ed549a8ef7e23afdbf16d39e992b2cb3d7d26bb390e936fac7dffa9716e98ab2d336d34d22290f9e11f13ed346e990b6c96cfce4daeb9438df7b32c50da8458f9b5e434302a6da33026c48626331b8f01b50483dc5200d3cd55ca3b3592e0cba66227b2c5cae2d5ecaeb12bb47a7b782e4f77f4b04c8cd2c19fa2700297e20769d5ed63a71db9986df2c85b057b06663c0aa047283a04ce23dc5e9e878aa4a71465baa907e0f81ea325cb1bbc53e9bb8f58b3d91c44d4bc5fa1e7ea7ee57e2cc0a1f14989da8a88716188af0d57a02c289ef35099381c79f5601904a26d6e55a2ea898fb29ac29a7b4a6a8c4451af77563c98bec3c18a00aca0d64f3eab2494f11f15a7c7c2e22c228c9cd0e080831dcfe96f7e434701fb92301a173cff380f520f3233399091c347f6ca80fa5d0e18cecba7fd42c41040205f76bcd885f5d022c4041a79503c52246d3ee3aed9599b38bc2f75b7047687901fa33b8062dc367049bb32cd7a04f279da790d6adfd1fbf1333eb03c48cc908c7a63a1439aa64de3e9422b241c8cd6f754fc06fe6c716fbb7a4f3590339b5919a77071b8fa6a5eb800350d2b9ceed47fa29211790e5088dd24de4b642e05cbe319bb2be8a720a5af32ac6d9248df87118732150038e08d15116d90551e491b343d9b973e4f9ff556f941c6971177b64427f18a41e699805b177ed62d8438b38bb0b0b522fa51e18f40659fdf1497b1b2848bd69b556191346b72f94ad46d5fc85ad65f00b475fac06a3ad34da9b1e5429f93d48fc1760955b149e3634c9ba36e247ee3f466d8d3a9cd4120038b2b75f33ad2d3a031fd396c6c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
