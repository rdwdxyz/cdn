<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9534ce537bc8816b7baf7ba3c1357bf5bf5e313f364d493d9cef7dba28ccd2065aa8a257861fb4afae3577812ca240a2e04a8adde3db065f2ac13f81129b22306d3714e65b70368a06af85ea7df10c101693bdd96ddbb7919705db1318a2ba3945e5cd0deb02792b70aaad9e4678260eff8a61896b75bf748cffb3230f6e3b35d2dc7f8f8cd49fc27e7eef42ea0c72a2f6a3e387c113d631bad89f325203a3593d269330dab71fa7f7a57063103997033dd338b8c6fdc952f2a8dc46cf7c0aba59127e1ba13723b11589a16f405b9a868a052dc16438bd7694d48db44c308e667b22b9a0e64b183e017774099d972667e16b3cd6147681651490ffa61b4a62132d736c5d2ed2bae2061a3658f659d13df89c1dfeda735fff63d05354b536ed263c7aa5d5e7afe3df528c80358e6835d3bfd46d3c0748a488e3c89d53f9d5b4fe5bc5c9e68de99b3b598664db1b05c62c119750f4b519b800a218e41c159818fcb112ca2cf2eae660c52526357d68c8e621cf87e019d481e0dcb20f2d05fe61b8eb08a88284c89a1cded8de56e4867d737d1b6674a8b6d5afea6e583cd829382a6d6645a033b9833e6713620ddc79036cfceb5313801271d0b25b0d5df5debf15d443c27b91f0d23583eef2dc035f008169d4d9c7a4e6be6d1d09224dcfc16dcc5c47e6cb5ea708ae07a1fdc45acd2ed0ef0294d5d33f084bc31759d025014e5d18b3c152fa53a9119f6ffccee690ba3e4258071e766ef9e324ba307b752abec505e3ea94db1ba326e58f503af325a469fcc0873555fbd5b517156d400c4fec0f6eae4ce0b653d95812bb17aade5cd2d1bb097ac572365ed373254a5c4da7ab8998f97c6b9287b4d29790d74b755c9349ebd63b7f227f1ead02d18133205b44d7cec3cb6f1305331fccad1262cf79623ec248555ce9b57f502c84a3076f00c3de49fe6c1b04565fb75ecd5378185d7b09016fe25336123e9baec77da8741135c46d90a83a5398ee48d8eac4a75cef1bb0c5369ead3df447f01fae56faf9bdc8e7671222e0378fc325c8ba6903a68143b8e71dccb1aa3f818fd8f1fd80adcdaf020b7dc0d7bc1189bbf35ab7aac0cc70f6279d396926f0f94501e5794978d05e224b52e022018648b3862ca6f6dadc1fbfab745237293af7fd41c132af9766c8084401946878d883d79fc9bd48bc74ad2bcd5e6362101b17f9eeb6c9413395a28a86bf395d220ff9f6d252f9d48838d7986e1f3848caa6ded4fc9674c54cd5edf82e6e249bc5a70595cca2d512bc6e800892f190a2fb44027d9cb87c97963619a8d93f24cc2e6325e10ae87d374c612dfdea591f2e66bddc6459fa78ead57c4f739e5b8b6b9de4abd28041270a531750025dc73d5b6931053efaec64ff1159beaea70b02ed30801f5584fdb886a6d5555100ef0f476fc63ee6835d7ccf2d30ce8b845fbcd327f36ee4fd97b374d6a86ae4fd9ff5958185254236dd76d987be856691276064b5db9c5547d45a7660b6cf279cff724c44142d212c4ee1107f76ff561f17cf377358d140cf427e06a4528d8e3e087d1c3673e6057384eb09f35e23128d48ffb78a17bf8a273ff35ec1e954631e6a13e330e8cbb0cc1fcc8a95b715ee907c7ef90e597756e4e032a6f07a9344a7d7dd894c31d016309c3e443b719c059b2dbf9268778a9898f7612ad4383b58d17c5158ad998e41ef846e145378ae6756542476b8405d8a01961313452dc0305492d84241e6e42034958742869844b57b081fa031eaa8edf7d9d9d1f243349ec347b0574cdb6de747cfd03c441e2813267c6183ba984d79b0bbef3d8dd9ad3dd9cd6f5ef515e1a1a2637488df53766e66178f8d1d59d4da989e3b83876e860af5aa3fa5a240151de516610f3fbbd055170269850a8112b9a4659e020764c1bdd80e9aeef8f37a4de71e68c71d7eb01c26eddbe3dadb3149704a86fa80380e71f61db63c8bd5a59bc917a568f3ff3dac85562827246f88401fe174d2d1ea4f28b2b50783568ed4d589720a8ff01d88a537f148c626bfa33946a7dc9595729250d43b7cff7b8f6e4fb47496324b42bdb26e4ee0ba8c88a6a02005c072ceec64ad638b2eb3fdb9dc3376646ec4815ffa106170b2aec513307bf30c85cc63612500a290b959a94765cd346fda79cc2cb4040c0b15ff8642a8dd48966c2232e43ac3bf012b2ec1ccbf3827fd764b947290fef9c8de5e7c5a79c1a2dbe9b64509122a98d9d4b0dc742ead291cbd2eb557a50149f30e85244a0fa458457a69a0c31cf1b8400ffcbfc10e7eb37a0d770b38937946361f0e383c3f625a392c36eb63a6d14f62478d5094eb57de7bf06f9f3a2b8d28487c218b54499396576b4b57ea394ee073f2aeb7caa31eaf6b63c3fa18c6cba5ccc5b15d8f2b5d41f922aedae840afe91db002ecdae2cbc763e5d672db54716ce80a32c175ae071a80899ca49eca7b3309abb19148471bad42e9400d5c4052d659d30fcb3d938f94af1b2b1374f35262f84743a64a8d0f9a0db19666cb0f476b3499b6343460c068971f2e313a3b9e97d4a8b8ff5a319e525b50772bb3d46674fcb8bbbd3d21379804040f52d6f75824cd9273b1918723470038cf61063e60d60b62b1dd67ca2c726583b71d206461bb4b7b4e98239af78628aa5c240973e4bc2a2e2430bc992ce4cca59b5db7399470a544cee1933380ae0231177119da08a0a42155d3396476d995b4c9be2747e763b441b775a66b23649d4bfe12bc4cbd633bde678314a3e7df72d88f0d45b686b97a558c83d260275ffa1b95731fb8ee7baed18b370bdf2ce30a4fe694c0677692cf6e9d9003c5ab6513924e60e2254cf5423e074171b09299caa85c2e4929185671473e16a453b56b402aa38e77f0e743e2721fe12d37bf60ae578997cec7003be8c1e1928d5eab53485b34f002dfce6e3bf21439ba434ee41e184c267cebc5a2b26f1fb7aabf2c76472604192c0f2fb48382d556b114287ab6d100c643ba8e3b18b3dec6a5cd206133cbf1e100447b89aa7168539a7fb72147fb7282fbd13f8003af8a126a0a8e2ecf297c715d4eff9dc4e76c306bf8afe05dffcc413a444919c3ee6c11dc30237c58eccf1978dc4b29254ffc846056a9dba5fbcf9c8de7694641dcc5115037cea3d86dab81d68b7e1ab751b32c048ae32e9b6ef0a312092d15ecfe9b45e4dd1820dab7efa1d3e106d1c6f2e0e9f10c61bfde61aaa2a39a18e97b1a8ca3a7a42eaa9c23a03d41d680bb9f3c2ad5d229acb8400460f3641d9f11b9e98215680aebc6a7a3708ac0a084e69f69016ebe9ebcabe067c7076ffc9422f5333199a4d7f001e16a8807f3d0694145d53f1b970492e15177ae8a210c476e8ef11ca9911e01b09421d2ed5c301b4cb105dff39026dac375b3fe32e2a0111cab9b3441d47722b7c9256b28630a4af706d17fa764c5d17717b8e6291c35b0891cb95f236897cf5578d5e53445cd69ea6ea9f3480a1af75b79ae434825dfefb2505b288f809a7f7dc80246f4bb8aa6e6ed9eb0282a5ebcffefa8b1525bd3fe97c24049096c6d69d8dd216f86d102d872b35ee686858986601a1174195be4692c0d6ea686957eb406e8e07ef932517e7976c3819efb90b22b138a89b983474c9cac93678b2404fcbd6d5915efb6f81076ac5f512f7c684c4fe38aa972f5cda8b43e02ae6322a858ab32c0bbf78d678d344e4720870a6a72eef57c170f6cdea03487244b8fb66c562ac14dea2987939b34f8d922a0d719473466032a6831106c21ec1be19e07cfadcae6e10a92a585fd1ad9d439bb07b73929b652862d93b196fd5b34d83677ba31dcd553af59c899f3d1b95a1c88f2b5324bedaa8b67f103a2daf9a8b038d41fc511418dfd82495ccda4799243432fe79edd23c7d4386fe113f1875a1ffc945ccce4e333119b2a9e8ea4f1ff36e1b9ff80c37ab361309fe2dd9e15a6aa0acdb73f0de2deac268cfd9d4a715207f7ab7a67a2ce7a0f111b811d61cd16d92d971ce123553c7e8732a914b3075acd13981b10a58e6cb7220049fe167ee3d4565eb8b54cb495ca36e6a64e680c84c87607cff55c9656f913120e3ae954c3424e7c1085fa9b19b269423f5ae1594009583b05d04d8d5c49abf05189751f4a87dbcc157026ef705953f25f6166cd6fbeda10aca16b00c8b169400b601c12cfe006228f46fb21e058f9e1724bbb718a0499f48011d3aa3fee512dedfaaf2fad98ffca9b74ef99f564ee8ae47dd1e0f8744f980e07f4a8f53f0c5c6b64a49b4eb11ca19fd4930695abbde11d0190df8327a6b29b074adeab1ccf316c33753eb53bd9c8ac103491c01208e7c2006a7da25607d452e115f848d71b99280fb60298f51e09602ffbaec8b6f6de17eb4cb81b1a919af4a9f5463f93049c22c405931f6e825ec4def7223969910e3506bc7dd914261eedad1bf159076b1aa1b6b3de74b3674f72c50238bef7e60af6e50b687501f6758f08afda798a906eab32f81a521c1b660aa1fe263f08a608acbdfa33acacdfa074de8fac7c8786289637e167f359be1da0fac4cdd41c8bd5928ae65c3182da62eb271c4c309358f21e9692f89a23694755f9444254c19255bbc991a43b003de7af8957b4c8cd91bd9d6bb919b37860f53b335adffb276cb4a2f53294d3c602e796bd87f2a44f415b257a8d62d1b50e84ae4c7bb72ed338f0d5558050c704b5567f78e2d7b005091c88ddf9829e4c8a63c43479209c9ae53614ee3399f2dbf2b5bbed7b2c75c55e64f5a439a8c784ff1da3dfd8b455598b21dec0f5e78257f361f4488e2ade6b78c90d7a8f26d20c714a07b8d02d94494260cb1178bfa00c8397e123370d611868d86e116cbf7f10fd21995a4d0d365a4f494bf06f35235130160ed80e5baca42b4e24d0b0464f55433c10a96e62810cae3dd33c0c5210d8258ba8be04b6bb3d30db3639a9938288d419b93c5c77b7a5fd9edb56658ecfcf61df3b3fa8db4798a3d2686743b0692bdfeea1c73a90029f5e7180a65f72dfafad68bc1e38e689aff4e4c2bd8b01585e5cf362c6fcbcd526eaf2660b043d45b70da16bde201951d6c8ca366a0da11bf1106ee5bcb7b673e845e3d51a41986b801ea632c71f45b86b6e56ca9abc7b13f174e217506fe3db761583ec8636692b97a3cefa48a6cda8d1451e1a51d253204dab9158fb3337b45688f888c20fbcce7a791ab5ae8c841ed19389314d747a5c6d31596c4dc7579e4f8e24acfc6a459cc9b6e1122147d2b8390ff7895904bb0867b9113fa7af764fca8d2347b9f629ad7c276962171f22b991ec37875ae05a2312e032809e6f6e11877a6f2142c6959759f64662e20daf00e200682cb1803419a33ace16bf8ff473e475726ca0e2f27513f1e8274d25905ed9e804af02055ca4734200f89de75f02fe730641b878978961af6a9af71528b2600ea741079b02c0d7ecb7e2763a1eac91c62c5847c292e82f1f0e01ba1daf950f37d932c8a86cc47325353b79cdf0c6fd1cb107d470a9d5a6e1c33fbdb20d5f6c29baf8b43b6615293f91022c29ac40cea4184f28883bcf2ccc91b45da090eb1aeefa1a9ccf5958e45c6efd90212f9559e675889611b4d6c29a566ba9b40201a25925b0767814be95a3a3959617dd33342a0571fc7334a4528ed4e5e8e34dc60c53a0d7b9e9878cca8a2d925665290c77eba81235c128bc686d7bc98b9b2d578423b23a0949c975f805e76cc37be2b7e95c9603886b11f44f4cbb05e5e7e3fe3ce6660f01a5809a4b8e493c9d9005cf2dbedd6af8ae5f9367f51fb05e5128c07f59aa0d856f43e12a6def8f09a1e855e2300634d4d41d351b4a39825b66be38920e0bb1b26be33ec60e21aeb48326d90ddd9df13f9d3702e3e88a78611f48bfc8c8bdd75f56b5c7a04d06483656d9c804c5f4fa8c953f1e1e72041417e36513a3bb48a378b8ac55556f2b19e15f65cc4641f6ec00b28c06b4dea854c6c02cfebfefa4860385cacc668a8200b3a19ec8e46dcd094107545facab14d71692fb6ce65d8b884194cc07c7090df9d50b76c0d636a6a63b7a81c3102fa5f9315d35ed79093d289bc4188409db1d1690f0d4b39e82d35f4bcc66dbecfca7d1b303e16c65596afdc5c8322ae4ea828ca6f75a962d97e6443ab00c016e3967f0e32193a7c264517f0b3d9a9664e447878acda2638fe26cf9b0b45c5bce43f0efa6dc48f70f3e3acade86c01064f5ee4caac2238132302cca3715f47d0dcdd8bb6331b36dff98debd4b954258a3adfeec62bd6e0aea03773ce2adcf424b64c1a33bbea1616dad044528fa67f53136f2d28fe1f6563c631dca64f42180e91422f09d7c3e8f359e726cddd6e0d722e1977c20c3db9e6372ee7698ea03473f6830b05619b984e5ad16cd6133e3b6966ef8a6b5c69e348a4356a296fd2e90f6c857e765b366546f4bb246e2c199aaa70bfbf54bd63d6c17c07c80e51173c02795511822b7832fa8307188a46961f444e399183b00261f4246f48143e62757c8ad6d5e0e2564d43310cbde4e80eed89a01e599fa95837d0f7cb645847a23043d8e63ff90db6e4a2ded3e506428f7f94f5a8c874461020ac33b3a8c2cc875df617ed57b8fc7aff0407bec9436b7886a91033c6f9efe26adfdbd56e73b5d0b83bcd667c209f37dce06c40666168e3b121aac6c82a6583869016508f1a703867774a2c6e00bdcb159cb6ccd41abdc642e3b8c6487a8288cb9f93df6e971a4a52e1053af7a5bb9dfd1e9095bae956bdab38bef9020ae2084869c21250844f2e950cde17fd1537b91f71dfaa8477f43a89c8800359e8c157e1b18d90063ee83f4f35d795ad7ec6287e26d635facd980363be8b1ad14daaf87cf9e42ef45f5b69adba491ffbb6aad2552a3c5d3d55ab7688f2a775d5943868ca8c8522d62051feeafb4a1cbbc69b534a9c007cefa701703f99e1c648acba12ea8e61ec65b1fe64843809fdc26122bf85b0fdca5fbf5cfabf2c0b8e17622d17a73636b33a78e4f6d4955fecddae4f2b890fe2f9e4534ccb23c034566aa851f9a745a5f5bfdba4d5dc5afef1f4567a2da4bd2965d352b8cc2717f8d0eaa48b80187f3ab22d58e15894409e0fcfe8c36387e10529b45ef8f7a645b353262e7d53e2a9bf8126eab02c64481d47318b2115beb1ba95a127a02df9cdfa691023a2af8fe1ff3e91dece0160a8923b433d6608ee9f438644c98043179580585146ce2f2c9f7acc8f25b090de9c8342b8908f82bbb9e92f0c9b39ff7071e5677285f60c5ddee5809a9b1c3b5c3f27bc18c0a65685339221406d73e5b601cfe5436f0df1c98826a2b0e22b4dcad9dcb507e4e6d89b5bce3aa92998677b3d90429f55e254079563dbe02d591f28bf4d1aa339a7428ee1cd36331589b70f8aaf782ed88a353c9339148a4b16c7153a3dacf91616494f6ed151e55fbf5d55aafacbdbc4a0e883883733cdb0c8eadf92ef1ee1c6312ba498e62a6e28e069eb0a44a3c5ef3998a60676dc1eabc05fd2ba64ff2f9bb35b3e3256cd2d46d3d6ad65cd9beeb47a8041fd776a89eeb5ea22b3fd6b2868a140383bc93b36bb2049aa4ff530867968446ca0ee671e3cfd58d060affcdc356ec03a071a731841d2446cd72d30faea03bcbe0878ea96675347544cf0db6f53fa5e54d420fee5b127b44d0162587818d8953dab2a979f68bd1632488f49f83bdbcd4d27687b03cb34975353e4a7badf330988316bd464a00cb82881d1ddc2367f1509b1633ef9e185eec05c3a87f66f0a030bd0c0a0894ad71038f04fdb09a1cb2182f757560608bb1e24f9607ffa973371f8bd75c3fe5bf83e05d0cc8e186754c1e670376559ca7d95e8daae8d00e4a82904aed61c882cd5bdebc2424d9e7b080e82ce8f10e893e9da15cf2bb11ffab7b472d6c18774cef57b33c053c57f212428ce7ad54bd8686e65db2e74d2f31509239cbd7b7cb9ff2a286305e46eb30b203cbeedbd142be4e04ec758b1eeae5627b030797c72263e7e34be03d998567021fd3fec7a03f0da7ead8582eeee9a9d9816b8a587fde59425d36164d98d4ed3df20c20c51ee4cd912b9a2f145309ba124f159b8f14fbbe5b08eef527b121d9f724e216234a571100d2d78a80c429848b0064f386400772c032c8b7e96620e85043aac3e513e247f0feac88f98570289084365416a44b4a646a65991a2b3953315d8243c42b13c95e4c909e44aec446e07a435e4dfa4ba80e3f7792f9dbf2c411bc12bc53f0d95e67058071040a179f33a752c59ae5a52b0fb984f88ddd0c5e663b781aa768d46fa9677be2927a0bbb06460b230f212dbe3a873480fe7eac53fe7fcff2415c3849bfc1ff6bab5e4015c1bae68f3a12cd1f1875599b7e3fa1fadb6566d8501a490e2ab85eda7f3d161f5fda820a528b53d8a6c70e834decd92116a45a6eb3036b4b7182eea432104d4d7b897c6375f573ecdaf7792489637a086851eaf76d3224632089f207b87b88964b384578280bfcfff9425f368cdbaeedd33d88e3efd04cafe0d2e69ce9b22f7ccec48c312ff4b5b43502d94e80d84190b7a461a07c4334dded5f049e7b514b3f345fc719714437f1f8dea6316b4372840060a35cf5a990c37c8230cbbf324c62284cf054d3ca931ba7091b4abf5f1e4ef3d1e2155739aca13dc4f442f72dd1cae56b7fd12fe52d43682d9e6e205f34d63159cc55a1b5d9b4246798db35e6234ab23a941b9124ff8ad099941ae0589f6322c8b2c00ba2ad85ee2bdbfcf267cf8712667676be3a38e8a286eeb32333e3834fa63c6bdda2deb7ba066b85916d9bb8cb4611541234b977b07fc71168a7aae626954371da623f465a66d898132bd77c6424a481394b032b3d36ae6f4571df3a246470505d8f7a414fe987fa296570b313fa1cce313dd78e3a5adbc813ced2f4210b1f52fded5a0ffce3cb3353040bdf5ca74c4c7f5bd5fdae2f459d7e264eebd7765ae703e222843f11758346603364ed8d6bc687b789f5879d94197af14510efaf5414e73acf2392f76b1dd0d618fc217a942d7210a92e06a0e6e853c4b6640932b465d7ed078e226877961fa323fb1a611e98c77b45dd0636222b9d615eb353aa26a47888d11ddeefea7fb25f602543423a1b8d1cd8eeca37e5ce12f947fb56cedfa97fe158d498f48c3155a49039a5c7cf9958d47ce16115c8b13a86423ec1fa6faf2df692dd271fa12e5fcaa59f78f6f08521c8d1d272b16fc958cda1f02981204ac70ff7d25462c6e49bd1d2ef71b1242f44ee51cfcf622eb11670d322bfcf5bc3472b1a42bf6e2eb392137cca308a538363e1eebfc931acf678670e59518b39aff594fc3b5294a5cd83e279e1c7f8046aa8eaf0d0d3523c24ab755c66c2e7534913d3d392746d43804ccba689626b6ac1aed51518558f3426eca7ed9c1bc9fec99d4ddced9a8c89c0c63549b330842acc13560afeb323ff0a91427e6bf8669a1435f2e642a2787dbd4e6b5c4d8447a306e94188efe5879a399a100c47ee0ef8ec1a51aebe20e139e98a65e573bfe717d4b7760e31f80d93368bc28834868589c5cc5d9665cf0d9229f8814b19ea8ee473ef50de7f19fef6b51793058a56ae195953a15703148210d97dfdae26cf61b2063d28d2535a11c6b19deda3aa8f6a9acd2f036e27008e72375431bd5d3f044594932552f7988fcf53851b032af0ef692b510162088a26b9150acee3bc7ea27abfb96f645c3fd3666604a8b4c2702a99523559c9b1063a6775d84590e545458f4e045ffc397cac59065379005943a6ea5ae9d693ec326247bc4281bbe963aa770a3f611ae4a7993ef8160b33a16c3f86a48b25cd6e91d479020d4e39c47a87abb876afc4e9e5e35d188071bec059dc9366e35304bce357e77666747b4f10d63452e14b6ad06f129f8ff1d5b7d27948afaacb18a3f44216073cf8455418f174a656a9e5ec0d7ce0159fbd82fbb2420626a5b42fb6c1169a62f4f4f94c57d7620e896f05f7404866e4732e5748477ebabbae249b03674e7ce222bd6a0713abf37b38b249c83edc9738ccafeeb8c1002402b2edc750483981e5398980087454cc52863b6c0d8ceb1e9cfe78ffc60c098f43370205d3ecb98f6758f966e1aca13fd0017f89d3e72128c2a1444129e5bb0590ac99b06e82bf05339b4aa5701f4d0f576db0265c7de5c84ddc998e9efa7e5472ba8775ffc3c6971ec495a3abad8b70850f094fd055eb5eb1cec3e7b2ced8b0a25b6a0162bd7d7b704870b39f15e6d54745537b4acf6a1a246588f76518a92a6fc2de17c5ef29e41b1139fe0c44ebf5c3ac4e861a670aeae30d438a1f94821147b8912345ceb9708b4c1c541d47a9b2d4595ddac057123c9a49552245c6439858bb30b030c4f3e9cf4b8a40bd592adde48db1ab679084631c1aac5e557e94e526a1bbed1d287c04894b56e4e43157b85208f310d52be02628e6bd5aab5107f21dbd943a0e800afcd7d8447918e594e95030bd2a393b66c51c0917be2365c7c8d7f082bf177034452d774f1c882bd4d40ca9933a2d7204da22d35b9c5e1f0abaf024749dfaa514e15abc5a6c40012ee171f9cb36c33e3d6fc8f5734bdc85bbbaf7acbe494f4a3a397b97acc16617ae11ffae05b5cdadae7e41a174f5f7e91d7d18c8c97b851a89f5073be28a857bba7871a4b55a7dc628e4ffade5f71a24d55f3b3b8f383c867fd0118ca94e0b8c0b2101930548963c273242c128efb1f79ff9288b457e49aee437353e689ed2dfa68e1cc70ac11225001c3ba11cd0e8285e9b753d675d560d4c2a4c4bd6fb2b96ae37dbd0ec96be24b0baa09f177c621b3b35004571b95a40fe687eefd7edd792bdcfa51d968d1cdbc9816c43ca70f96cc4f38ae096b0a3f2209806eb6676fdab3869a76a77f356252d8bfd467c9ee8e0eacd723a1784ccff3b658835d8c8ca91dcbc078a4d325bf15cc2bce0f04f07a6e64b138f3634239a278eb60ab2fdd0a22e10e8683f0887940b78dc0a17c97e38468ae131d5e66ed08e13ddc9619dc6c6da10a4e30e0f1c30bec578f20ec249df545cd02c096e5a435b05a16ff835b704532e4f52c88b6bfb788f75673bbaf8f3477ec0468647946ad27398f3d4af7c2fac3a42e70ed16bf30fe02423feb85b4494fecea0c6e68f048c6af2f19fdaba4812b162444981fe00fb1adf8b389e4f1a0358b908a665288906b58537b95a0ed19065d7d48d7d6195c39a14183d57a089b19030deb40e902483df6f862799e5a5aeb91cd042567489d4a3c02a8ce39d1110469d7568da55eae7aa911af3629a3b8a47f14ed3c6eeb4d1fa05c889d709e93aab762238c3e3b7e53a207399c699fbf884c470b60c723b0439433487ffc23e46e3dc4a13feea3a9831f33968d8717232839213576066c1752c1e265af9e77fcdea24ebd8b7f38ac672d333d13bd83a76ee0b0f75766f282a3bd404e99936027257de4e11d9c918afd251cc97b50aa4bfb14cf5345da4583ed30a7d089ebbe12b84cb483d4aa29feaa9b14a3f1f0cc9fa00187fe372714c783c67b164e812adc8d98da324dc7874a0b216ef8c9b095e3399a22a29f9366c1b2eaa9f887c08290b8f986fe4d69336218d43aeaf3934d595fe550b98a5a5c22e9d51707035bf5a2bf43117e2cd8ae560dcbe7b476e1d9ec368f35df10dcc965865a7a4626fa23a9dcea2ea9ac60297dfa925ae1fcae82893203704ecf32e7efe538f8086835b5e425f620ba53363179bcedcb608fb14d7f6d1217729272bbacd6207c63c7c2b0b6251fd9c8b46fd5dee297876ea7929259dbc46b7158c9bcd87ec24da689fe4b20d6005460982d89372b0651d39c380a9d9eab43a47384575dbba5a28f410b1b61247452dadcc267fabac2fef293ed0320805fc9dd22601bc2daa3aa1d840b75a0367f677ab10d7f7729f9b70510d0c8d613f0b1945bd3485a2f3b519cac4c43b443eb4a00f3582d84051153c6d408ea46bfd32baeaf1b2fc8f3116ab05f7af497685cbd6b54834578dd2ff4d2b6482fd4cde8982bad13a0d0ed31688a900fa6df77a9da0885a9f42a31489a78b29442102b5329b4fdc40bdd86d5401ff986ee2ca4fbd858097eee984e882f1204e5a8e49620fc1862d04985e5944ff6d8d4e74b3f16cb4f8e53021ba6b74fdf1d6e1a1b962475d6f7b5912a03a68acee5de65a6bdb3d65b2540d760fdc0f7297faa18a293d1ca66ca508cfe4466273116213af5192685c2718da83cb854c20fb29121724e2a7dde02b35fd739cffe316a50f07b79307055da853906d268dd310dc520abdb4c8486cb09e0307a9212ac29d5265a1e5c8d852a851002a3782aae766f068061ede634dca968a9fbacf69e290c8790105045d3dcaf4bbb9057e7cf8e279d70f825181d9b1b0cec6cb6e3e95aa4dc6060d421dbeb98c6477b3b8bfd862b51c3b3363fca19dc79828868365f3333121429f4c1721839c28fb84f9396fa926961401a9a1ad43f1e9d479c2099d3a609d618887d32a3a4fb660ad9af0ce2fc59df8602199c1366d88bfa10732f2458f4623694d33048082ae1994272c1d122befded1e17c06adff1d3e8f19f85bee205dee15b6c7f882ed073c2de7fcc5a4c5c0396cad267cd08c697ab1d41588b09b7808179b2cbb055fb0dbedca4e48ec1abefcd6173c704e9e7a048fe882dfe55344a5ab569898044ad6cbb27f7c9da5f784213d23c59ce716398ddbb9037797a4fce4b522304ad6d39e912d0f01fcb8a4620a44391a1c71a46957fc38c9a68781f806f2b03958a093f6d3e967363f0964506e943a5498d3d9d16b6e61a5385f70d1838e0b8cdd7aa7f10a14975beb3f48dc6bdeb43461721c5b205a368f9c5ab0baf8b783b62b46195b4e0369b6531c315d974fbd88859008dd94e7f5a8fb65fefc549a79ea3e2c3cb9b3f0e63dc2fa1e279d1370b1f95e27d1742de5c7dae20560d1ecc57a21e1d4bcdc082b67f6e492c101c2f0b05e65d06682946c73cf29813e09fb1c4568a4c13ca1bb5ab4fc1affccc05d52e3b7d8cc89aa8a8f34379b20c2d3dee7de97c1f6b2592653aa4601de467a12502b5aab07793dfe91316efeb5725bd455a4b7a1454fce7953b16625b5d0bb0fef17cb03bc6e8469bdc0f6bfdb591d56cccc640864394d7dc8bef8d43254e72d9200558037b868fbfb55fe26ad2ba896891ec6c089ef60677938d4755a5c9d6dbad0bbbe449863acd57a42b87cf5ec2336c3fd4ae0a011a24b6e79b56d4cab4a478d0f95f18c12eeef0acb7f111ea9d64340e1c4cd3d1efec3346caad5c8086ca4553446b82e2c1f68b8e6ae0b91cceed84e8e617cd2581e768f46c92bce95fb43c5088d8b96c08ebd07c1e8ad1a920415a7fa6887cef2e20b42f000b643b33b9614715ff436761f0822cbe19643554b14d743dfac74aae2dbd04da30c8c790e446c684b404773d438aecc184b5a4db65d05cc0829bd6429f580f6433d1d461fa43b937ff8ae5d8c6527fed43ae6c29693fc38ff555f0db7a06c82bac3b5415498fa7a193f81495d6828e113afe360d3fcea60f4277eb7e4e0409e5023645d5cf4b61f6ef83b26fcaef59b4a76905c122ba3e41e069109758585504b869b3d8f09b2866ba597719c58bd8205f2e20feda8398599667047ff0aa44bd4e91a39cfce520ab8ffce915cc9c2d022b08dceb3705edddcb118d7a248c9b64b48815286e9a2740d0b1666b8046fec7d8e3273e5dfa6aa76f36cbe7d9cf740b8bc6562dedb010d7ac64c64f438b6e6c77895adb1e6ae40ecc90f20996d22ab6eae3f33b9519d4f1745ce7929d127c6f09a9e167302a84c385bb751aeb8a305c617a92ecc1e2e7aec8fa2690b628fd5c0bd7d38707cc23230f8370d5bea0abca6bd7e60b5cbc9e6703a03c37aed7f3b7a4aecb6c7fa28a6106c4dbcafa4d56192c52e5ea1271adcc627103b127f95d289ca55f39f3efb6adff77cb23f9c007796a6c4a1e330d5eb9825e0b62f5289506777f47425c9887ba14bfa55824dced9ce573c1085567c8f274877b25da6ec20d0f5c04a126433bbcf53bda58785a9583b5d1c3d087698e7b85d9f8f9292aa04e305b3b96b1adff6e896066e29047d3408ba5a0b0f8870e26fcac868c26314ee48d6c13ec17bc02dceb71e658be06eef5f9f8739295e43cb6b3bda06d5632312f279e815d700cc3fdabcbd0f6e5130e10c2d5a575d344d641483517228ce041aabe8e7cd8233b755b71528a56d0e5c84c9604a78791d8f0b018a4ef67d8ed6a96abaeca17feeb348373a70afad2c14a9946d85c8350519d82003bfa294a1c2a21b6abc7935bf01840ba0d9d98eb84e793d01f986c9ab85d3095ed56449293c8fdc5733fa182d762a06a991d2f95511568c8a42f755c161b6850052fd2c62cf76eecf2126f80dc0ddd263fc40a09351b9c06df03f9e3a5a79187838d5aa75d2cbfa4c76c276d26462ceb97eaff658ce1edf65b33ed1b149d29600b4276619b1703d63eaa85dd98e2f45ac7025b0f984c30574dd3eb6dc225e097c69c53f5ade446f38e222534ee12ac14a8a4acdc389e6973e2db855c9c1191271213ee2b77d9790847cfb227765cfe37dc94f5277ee025da1431627ef3e0ac991426eeca99229a56a13fc102bd0eb4e94b2177a31ed6f0781908a1513eb0d59fa589cacbe28dcc57ca05c1870fb52a695fb9dce932b288a4f091d57e95d7b958702d5c8e65890118845b92e35cf39b1902fc4babd5309d17b0d99197c7f72d06ab9c8340a6edecbfce470565b799a8048a20a792b3898095ce64626a749645d518eed1adacff1c20d2abf600af0c7254aff0fb049c5dc169d8f51a1c08c0d6c54347443db7ef565d3e0408fe0b70b24d467beb120b317a21de71398cd479e18c779d1ec59ac12b2f7e2a7a3a170043554da10d45587bc4ffdb20b2600804b5fc1808e06d2f0a3a7ff80e31ec55dd3fb8a5fa6202afe50ed50a642cb763e9894efd6f3d056043e098bc50430ac19f253ab83f095c8b069199ad1e8634908609cfb7482eb2b8a368480281d9de6a739dd4f8fc26a5dc456dc785c11788bda1934e2604a50d95dbd0e57d79764a7438f9a8619e7b8ec3a85469d909cf25d4aabc5d8766753d1161480afb4e50e0d343f99833982b7e00a2564e3db2e520d73e0ec8dcad2e8a18a8f68fa73e8746b00aebdabaf57f718b0397e1f5e239a9475e2a961b7fb14ff4c1794b8bb32cd7ca818a039636ae431b8c7f719b18a7ab8f16b366335937f69e22affb68d0c74ad7fe71bb4b31611f2ca80e9ff9f6df914f9775818964d3688ebfa078af9e37a5d0f6592d953ef46fca811046c1d72ccfa1b5fbb572d033410b3c26ff8fc1abcefe2ebc663f0d3f3a10beebea42e3080d4d5e21ced3f08082d4cde5bb20b47349beda3bc9e0edbcc887ceb259478cce8c7b5646dea831b2b24f80ad848ba15ff9612448ec86621eb90471edd9d126a95b26c908e3dd8807a24ba8fe4a4c11dc0d5fb82729f6d615184b85079814b8ed750d806be882e2dac1c728aa1ee1b6289625654f8967bbef686b12e59f4960af408e0f0656f0c405283cbf75e1893691659e6f4c2d3c8f724ceeb22488652e96cc2f047b9ee2844f20ddf9d2b7e330c9e8a50456c96b017c41d97eb6658f18acf7538c63c1dc4adb4985f36433aebe9fe65ae4f42c5f15d4973ffb8d1785deb988ebbd70c10b54653d02f6ea3fcd23675612e4b19da7c90f4d0a49d1115d7ecc5219b5f0cd015d38c12e22269e49c8bb76f71394b4977ddac628009c9ccd4f7695221ac52d2b7da54f7487daedf613ad4650d1b9cbbe85f500c2665ed2a595d021d268b6a79b8cf224955d5f204b7c55e3a23a491d47def4f55ff9acf09487d3f81affc84a61886315d09ad296103d5ad118c7e68b2e70766d75cb346e5b0beb07d5735a82f5b29fe7797396f8816666bd0b8c8fc88e245c3628eb8fa6154d0067d86eb66caa57ab655d510f58d833eb78830050c158f8c613edd43706623d0438e3acdd3d0ea94282ee624a5766bfda810479185caf9dba14d623152be690f25e4ae411ea2e6378e494bfb3d609ab0f987cd83d2eee6e46a37160f538a4f5304179d4e31989bf79615e6f7bb37f224cb8eae432ec053426ad956db09679d3627a763ac47cd9e69cf28a365368068b805eb8ebd0990af9897ff983324c6138ab7c1f07ee894a1d00a9e44dab654a654dd7378b90b20bbb24443eaf8fb05a45473791e78ea13cb9955550640eb37d2d1aef6ae28d678bde547206e7521192d345e01ea3c404c24103cc0e415c15ddfd9e6a2651fb43369b32e41b5556f7f580c9dd756b6c8758a1c6bb00d235dc54891995487fa1444f7dd7154ac137e6c4e07a5147cfebb844f22d5598438d6bc00c69a8dabe9ac49b37492ac04e16625e648c959b1074d0b4db5ee9b24c4094300dd8619a19e50731d73cb056b2a602864f8c7898d5bf120490f8251b328a555f68a6cb94834aeabe433aa75326a750e709a70a4bd14e477f948f13192b0b13ffd257cd7ca43d97d63fcce5bbc0265c87580f939394bf56b6288d05a03c1b75ad6fe4397fe62daf0d8888a95e5ec084d98a280e955241f2579818b82f58b4ca9b8935d7c151878c2518c76409de97012d3e7308e481bc522a7f607862de346a65c061f2e67d57b1562855ba777591bcdc087d57eafd11abc60a1f24e8dd988da520ba0039942f8c7df97a89e1e73b47595c7f0ccc07f1494e69f25271270e9787eb4b3641ad68a40a2331729817dcdd3cfb1c7307d3e0271d9de6f4a046d08b60b3e5b212dcebe1f4ab322d9044563956d01445ba8aa15ecdcf417438b876fa652760ae9c68e88ad04f2d667c8e535aa443f9961aae731aaa4d7660933bb8e1066ef1cb321aa2e14b57e3c20f5008979c57d63134fb9664eda9bc5ee6611d5b615abaff83a3c26b0715daf1e799f0a2320c62571d571bcd6627e061826dc2d28566433ef9be3af78ce57c5ce6be8275d8fad128439020d73e9ad7a0554c6b21e6754a3d63406b5bee21fe093935ed8e3354607ee697f24b65f42040b97e1b96d337be9eb85eafa138e0d5bbc022f20cf82f6ddf1e0a21f8e20f883827eb13111b2ddb9c267a57f0ac8a55deee27fcb1725ea582dbeb8d8a375350879c617f7d0c7c6e2dc9470a95b5f4ca5013c082113ba19896c090fc99a047a1bd1a0fbb6c675aee4b03a3192a0019167dfa69003f966b7b47f7333fa713f5d2c80b7ba333f8751d8d4c83bac4a425b57bff4794aef0ecf3de5c5eb680525bc77873cc973f049a6d2faf7f844b74c29ad82a848bd62055de924ac129a78b7c3302df3274fa6ea09f6f2fb99bf870f131eae49a08c98a8606a7aa07354b8cb4f3ac26c01bc7b72e579450f31008f1d1a498a8c98903427c38bd9765d559deb2ec4f250b317a513d8bc96a96c66c78fabaf0f815a559d3b035c388b151dcc036af5cddb20fd54405f4ad3ba420e3287cdbad5a4fed883e12ecc9d877347b2469a0770b269a5badcbe22da08c99343f511b0adba45ccba09e3f97155785ac0ae76f22974ead2c50f9449cc0ef0c7652344f2e1abaed345ecf044c7f0e7d84d383fa211196f788b26a537a3a44046b9c4c730a3efacc70aa124006e1f2a7b33e4537792acfd9454f252950743eb26027413271fbd9d9502fdffbfb709216f02409981773d762f3e0883c9f7c67fe56793756b82f9fd75c2e7c536c1ec1e4825ee92672d75892a2ead59e80b00e057dcec11b5157da11340eda7fb5221c773c8f6a9014e75b80befe812c9f1e594ecfebe78ee09eacc9bd0d16b325b44c1e34c460583c4513631c62d1f5d0f5bb71583479ba694efbe0b796f2f923003b6fee82d0a277e053bd0cdb2ed1be44dc9f51886c24897ae2d509eb21f461958ce296d4aa607ea3e03c44cdb7ba0d120541e18d9d386768aa1d67cd8f31302cd30f05bad74e379b1eec529d333cfdea0be934aa37808f6c43194b7b88c49b56962d454aa5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
