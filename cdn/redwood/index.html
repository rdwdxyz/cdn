<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90b10ae26f68b6665aa38464a3ea0dcf67828f4fc17109e67a785c618d72fbe5eae389951dc13ed66646ec52c7113b59dd5e059bff5d596ed0a1b45bd17b6ee98d535ef486684cf28d2765ac0129d4e0543ef685149d0beffa33313b736d850698022a201f1034c8b898d63ca86171c4d9bd983cf81277abf524dd4ea97050e32420669887ccaf69c2756a4aed9c0478068785e6b996720ba4dbe611c48934c460f29b82710b8c0c419bff0010b1ee8651f21f5509ca72c92dfe1f7c4d2d08fc06f7d76de3c315360598f591654770949924d26390741db03587ab9d2c7e2fdefad48b13f03f2febb35af1bfd00dfda543cadd9beeae235052e6257e83ffe1f73bbbfda79502b7a766bb9c9c22ac4f1416abd3cd9d0681647ca72a5e31075f3be9960dd20f135de0c442d51ad9ae0aa94912a230bd76de3680391166441cc8177dab5c7b70f3a27e169b0f966530e336a2eb1b2e8efded24fca0a7bec56cd165f61d1fb02f7c4ce4dfa7c5c3978d236a085f9250e59aca4c15398c457875fda8e83abe1a8eb36323990087c4181cf45c28ded8ac0a4de2f9fd67e139ca78886f6440e92fef87b76fa96bfd9ba407c925797f575cb0deb6ee746218a03fa191cdd181489c9367089bd839d09136a87035c233cdcafd04c0a82357a19892d778ad03ef8e838eeed117d267231103746d68e80a778c47ebc47e08e09d5f564693b597ad9b31efc06f6fa3244bd0fcb255708502aba9db66b404db70ea203265a15937d998798cf5fbb2578c2aa1bd6f91ec1e00c3317da1e98640773187e96d139b8b90d5a20ab92b05c4f54049acef4c3cbff65a7d23a787d317b8a34a8dee831ba8c2749cd512b0681210f47e18d66b252703a90049b3fec1c476c174e75ad241115c036bcfe7ea184d7662083c5b387211c4a26fc8df2ead5fcfd01f440160a22afcd9968c8eea8a1eb12a5d678edd1809e62f3088d38c90035d0a0ce4e401a833abd60acfcee1857dd3f786476a264b661cd2cb778a8310c53695bf7bdac8400e83720f21bcfa013514c6c2d0f7088f19a1b70df09bfe7c0cf045c2af3b1ea12aa67369592b4fe90ee5b6d368cd7d02caa0e905f238f60fc4765d54a8a067829026ece66a8368cc0fcd28f68cd80712e256af15365b13b63fa6a3fe1353bf5e4a051244838686d2f433f6bb0ee52b6c9282c12a4b785e563b2384fabaf3cf83ba61818a856070164e6d97cde6e7d89eddc3cc9c81485ccd5369399c7180a460349579d08846b5678901bb7ed9378ae65c5811c3cb3a48ced1ce306a0af2ff2eb8b59dafb35485aacd814e5c7e458b54bb4bedb31645694345cc05ef3c14eee11f7915e42a85e37da550010617cbb4fbcfe7ec131f17a8baac77e71912674f6b134fb81bcb4c46bd1dc00d87c8823a9e7c1ba6a6a56ef92136da4e3932c83a305222a2d8313feba7f1408ec92a47c74bbbfe27daad2b0474237ad33140cb6bfe1c1d472a3c4535b6119a365164c7364df11bd47dab9d91d64e41a291d001acc09a07bf2ec75ed3f0de563cd195a07044d1d7e3faa2d26f523183be8281ddd9ace2e9a56fb1ee8337d512e8aa71f873d893bb126a3316dec550b570230a6459095cc7394468bfe39d0ec07785b1b857aa5ecbc3a98314bab5a6cc40dc640a7b8a1d0f82a961a6d8c5a4981b7d80635649a6810d51a183ac35fc028f33cc0bad5169dc131d39965d94003714f98bd2b0f743c4026f7efcef73cc4df72f92a8cbb23e1cac8c3caa928794114114775871b2316d3e1fc6c4ec8994a112f8727597c2a55fc8b0dd7faf462242c6fcbffa11f07070301c1064095b5cfec8547b92e03e4783a8996f64216d205be95252d25cfeb4611d314c4bd9ab8dfbf078c586653e29a5f8c6dff6491aa622a258df18955e2545c20462da416ad2e7def5adbb9e33ddd9c4b901628ce548e8b29d2f628d919d06d085c1ca8c1d825c9a66dd55169e6b906b7ade10e4b9cdd16bd7744df0ce5a1a9bc2e26539efe4986c7516f53d9f3a9a23610a31071b4cb0961ba2a9c5e39b016efce1e9017fb1bb5b1849bfdbcdb6569d775d90bf3ebfe8e0702438e0048f72fad194613402093aff7b25f881f6727c6a6f84bccf6b25143abd4fc989ec8f3960aa16ed3d520db2cdea98711987ca639da2ad2ffcc6dd017c689a7cb7e77d1d1342b7ffa0227cabf7e01d6f1adb9817d0a5d0ce1bf18bb92c7bea37a2663d2d5dfbf86b2c835184135a53327eac96718d8e7cd985d5d86cd5175360d656f3ce1b5a166b12ef171530aa9ee0476e1fc6284e4a3feb5db8f33ff4d147d76deee0563fc5ab4878b5021f6ef991df3856171795e9c23a37e727cf6c1496f0920c7ac696468401b643b14d3b5f338f21a76b0ef3dd9ae59a196ff83e80c0d0a6ca3d5f1374ffd7acc5095ae5f6ba864d5afe321f25517cf5a364095fe014633e17c006a2305700c4d875a1f04689568ca4a1d008932aa7850b0102b3972c676b61df8a58be9a5e39a9708adfbe9a9c9a70cb5992c37aa6d58268ffc7f9f8472f7f1a19723374b726d979ee2d41155edda254e2d7ba5701cd78d2a665d4062387b6bfaf3101b555b2c0a51628bb093af81d5be63532313dd189f217c8982052201e21e72cb75cb3dc48db6ed91aee97ab2cae7f4f838da723ab180060f77704229418f8be026c6a67258c4eac4a5244d7e854a90d32bf6daaa997dd910ad8b5cff59519d00c4f853763237438cb69f52b0864b968e56f4b8dd5731e091b1e0f7adebb2cd1b32bcceb6e7dc08710e92def0fd53b6b2d0a6902523abfc441f8b4bd605f4f14e9ed6324405855fcaf2dac42fe80c936a30b740460909ce8295e65586c1bc5aaa00c5265ba5a065dc10ca6540dc6db1f831e6ed7febf0d82288a57d86a065cca91d4d15c06460accddfcac13762599ffc9f52d5546c667701f05f6e6d9680522826a9b5e3fa10d0d0903171714532dda471f42934ce6f0807445b8dadd51ceb9130f8058bbe59e2e066d83113034456921594afe7b8324934c0a4d9a68d9e02b21db744ffdfa95653e2158bbd8a364fd85fcd47088a07e1f6753b401ac8d3f369ec8e368d4ea7339de128047e1c804bb8d921b629a0f57a80186505e39f84309fbae9202afdcc2755b70b2f82f3417a15bdcc7ab780664e49f0af62a651badf39227d23a0c56791903f834f73c37a0cf699a068fdb00d74409f2b2b0722e8d8b3344edf77d9a40b3f9b6008f15206643927f89f7e1755492a899340491a9349224693909cd60e1a09da6f244169705787a6e6c89449861764c985aa0872770bb3684920a8b0b5ee5b20cf77997df9f2a0709ee30cee85fa1e0f86a4fbbed2cd205e52a27739e31da376229b71d50b1957f07279c0797ae632004394527a9af52fc0c754adfb3d85c4309d0cb74d7b2dc78e3db9e308197ad021b5635a3f82dcd4b10710b3a602c9e5a0ffe8dfe850927d7a9240e53ee3abaeeaf3490e33c7f183f4fa9cc0735147ff1d046a5903c3a001cb753bc30ecea9f370921e136f04bfab5728a6273f92a7ed83dfa851c67efcf02ecef62ac9c6eba99df702d583bbb8af49414fd584e074be24a14c78975ace28fa5aea25059916cad7d15c2e6b9453d243e1bc2221d5d7814dada8d20d0636189e725478ed6891470d0599b6711cc2651c77eb396dc85668bb8bbf88fca65d236670558ae9cf82e01864a2b028ca898d0977ca1fc5c899b476011d4580b41681001cf9d44ea828fc0624fe225684ffe164dc88082381f0ea7db27b70a30fa804330aadbe0f8768b6d90ed326ae93cab5d8d558a439d9f24ef7dc70b415db53d2d215e563d884ec424bfc35fefeeaca1aeb12cc700bc70a361fa99d48a29ef668d5574abf4b202c3e7a98a7b00657c7a99d5ee4f8ce9b3f366d93cf736d0a4b524471f1b11940d1abde2415e19ddd00248717c26bed07a3162c82b0e5193b05acc60f2b7151c0980014873e15068395806e5350ebd17f6c96f96eb8a73196d4bb9e1ca59e4fc065c5ecc0bb4b4d259f77f3e1b5e0b221cdb81bec316cd0fc5e9cb588a88ef829cb3b2db56bfcdded5085f0496e00a7dc0363d850b11dc6c011f4f628f7b44830fec0e60c6a0de9884e38db05f395312a50cbb1bcb1ebfae9d1e116fc4664161b05d3d99958b8fdbfa2aad8e709239db14f8f0787b8d2cafd84384f5705a7fb3993241e9d6ed66bee38bae5b36263f476f1e6aa44712f29c89a4425f5dea0aabab67611418649c399d463e65b929712dc85ce73be13ca90782d9e06b6d6f001056e52f874752175ae680e903f98ef89f9a27757596abbabe95644c3eedecf6c0a7ae6cd3e50f8deb910e7cd53c1ff499e1e2cfda17d33c29245401a561b8a53f3aa699770e4b6f13d1121f3cd00af14e49e55ba023cc9b8068a7518098b2469b8ff2210b146b2e399134709963ffbdeaeaa0058e37b53451acce1c4510c0cb5e82a939cccd4564945931470a6058184457afa1d6a831dd8c2de214db90d9d0a5f41faafd292a9e785dda3b2ba98a66f34d3d6c71248f0517adab71731624f80f537811194285dff9b7cc5cd22326638fe70bcb6652b7d407ad5b5cb82f835dda7602f966d51cc30752d51bb4a0c5d71664b153730ab5625b0c8e60c56cb488b6c9434de7081a29ae6733f305b9d0a9ba365a77dbd7d44ceed17002b018a3a7cadf9879fbcffcc1cb95b81bf29eccd92b01bdec59227fe3583102ea155dd7e3668f0bfb8736bf495570c6d6e36433c837be8a70ded47af105898af79c0e942c9a4e84c2b4f4d409fb7ffc10f58a02adaeb8c4c8181f2ad0abe81d747c17a507d46c6b58608a7528a1398ec3b269722649e3023f43570b98f5c273a0c86459484d09d9491a8a1046f7c281697ead804c3f0f14536ef659224f54860a036d1e2267c7582b2b9fa0e10fb812c274e7f0821732a058666a724505beb9466c65b9f060616977e727536ba4faeac2011cca418092efcb0450cbad0e225b053a806a154f793ad8a64e356226b0ca7bdf8e88d173ee382ea31f4633667f6f28864ba54ad48adbb751277e914f2eca00e6d12d106a7a2ee7bb806f5adb84d61e66a0e7fc85c8b22f3a084b9cc1bd1d6b622132da0d2f8b6c8f12f86dbb3a9e7d8da532f242ab85edd7b586d42e462af99588de6d1cfb0fe2b0783eba00dc9a13ea0d7500faad891f8bc25b0bf539b6e6f2532e066099651cba72029bf6a3fe8960f9a501018a5684957994112d2833baf4b08ab9104db16ddd5f0726bc980256a0534e2a0eab58cb932cdd8e2753921555ddd14429537952dc92387ec4b53e4a468a6ef6eaf6d60e0dc24c9ba255f31885d6c440bdc750386dd1b0624ac9b2469c844cf74cef6a158ce53649bedf4deefb9c79546f5f31b1a4a0d0f7596372a69c36ccea7168e8fa131fd06f7d7ad9adc7adbdb1b528a0ebb4815e1a6e905adabbc2ecb85086ff7995824097e613726de9df493075e0e7ad02fc26336fbb34f36301d4193308f4e693a42c62da1aeaff1253f0f4b5882baa044b344bd5d6ffea0ffb01c5bfea79bf3f9a0ad3985ee65f6ec00e6117005708c5027680b33578f42ea8e093f27806cdf6ccc46e664ae2941abc901de319e74be282365ce70ca03ff351ab7feb98070175a816c0af3179447c242d5e55539a97f73325afbcfb4917022f8a826bb86dc8012373b021b1311f2fd8e523060e88bb7d6dbaa0d9dae6155f4f4450f848075a3ae1824bdcf5ed1bed28b5fc51db7f3a8add13df76e89f213972c2a5805ee12608ea4a66d1dd2c5395ed3f35524a0ef396f3172d60d6574df48e703a420def5caa6f536f473085804ffd79b2e716a3cf0bd61d4904bcf24517a2a4701c4a125507fc5196f90b667d03109fe239cf20a432a72156964855c6d7cb71a92c4cba33878d00f7b8ef717b64f7ca2a6a1b3e983b74f744c60cffec8e27bfda65e7413c83c88dbe181ed1ce45ab7bfb20b89ba2c5d25a8bfc5f9f2d5383841f193f8c6a26be630059119126ad8ee33664916546dd1378d4ed8c2067ba64e38bdd0d6bb4ed835c588c3cfab6a3a5e07b43ae30516d0c2c03951244c6bae40ca2fe8066dd2364e4deb8b098d3fba1a07285bc32a20f4c471c3fbfd856d1d5af3b88134530f6062872bc2d7d0ad25b3344355dd98e4a1148c058b7cd5fca0b44e2eea847e247580cf8f2601cb906d7a1491f20ac0e4e793cf75fde91ca4843fe4fb7befd2b33da20a51bf98fb0dc4c04c96a9781788715e79b392ae7ca9ec8a887946bd52c0e4b4d8abd4f1a17950c6defd543439afaaf052d46c03c1cc1dacccc84f41442cd442b3700ad9093e1d4cdf12790e1ef954e634150a10fb2118a8aab1d48f2c144b8799929f39cf05e8d1a8d2b84179cb92aaf34aad4fb28d9107025de945c231500564d6b8d0eaa70344334a865fb689caf964360e90a3c53de33ce7e8b20c98b797cdacc51d312ff6a7ec44f1629e9cf8bf2e2e5876fc49b8a1ac474e45499a066f35595f372bd1cae02d44041c84fcdbed1370873bc2bcfe176efbb8a248d0ba1f6e2a8aa6dfdd9d45c1d4e12e32a4948d18768f63e0bcb5ca4e12324657a222380d1657ffd01bfdc3ca66394c76d8698f4c251fd288504aca13e389e03c878c6ac46cc538bb8a88a330f12d78f318b1bb50292e2d64b62f9f24c128d308d36a414100abe6768ab71626a271a8140fe833529356040e4d15b98bf78fec853dd48204721c171441f262bc0c1f1fcd12f3fe920dd71a1484c668138550cbd95e7e2cfbdf3df168d76a89e5376b4a084965046090aa63f92f279598e6655372238a701dfb56b9fdd110ad7a72c2908e0a5867895a7d18739fe70bf9b6259ec73f8cfd3222edf4afe1c821be16a53095b60b65dc6676ceb0a7a61c3dbf47d173bb402ca3055b14418b3149e7af4f51f801c81a215cf144f755320feda731c98d5b49478ef4e32ff688d4394cdc0f0d912738430ad009bbed76598384d7208fa3b53e681b981f4ae2ca2bdecf9d03b7148583c600d3490362cdb247ca7bb99004037c5d4ae743b14fe12a6b6fac7c2ab75accd3eec9b2735bdf82507bf1040a1abd4bcbf352cd649f220a8ed088b8d3c4c104ab18ad97b348dda97045fcf43f69e80233075dc114b92d5d46b3c832a6ab159fd4c65c6283920d94905e3fe1cfc82ff7fe7c753c482fc1730fcc793de35f07beaa8e46f58750c93ca124baf9f9918628f4d9342785b04ddb6a4ce9220b02b7e1f6891bc22ce12a7218ed831d232c1bf1fc75c0075ca200a8992baa3ed8cf660c592763e6d63450cb5d6635453319f1aead4d47d3a0883f5ceec237ecf2a32ccccddc74f907040fedcbe235dcb1a39fe926c5b0939f086adc66e9eb1e2949359e975b83a71bf8f86c51623b6d70094e449ff04824e1130cce649c7956952cab6d9835d78ef76fbb2806d488134437fa24948a91ec87525c8dcc19164a569f18ab62288781f597b227d7ecf530d5e8c98f230735c39cf980affedc45a8bc2f1da7227c48b2f0a5287bdaf7b70c88057f14b4498decd9176c4ddc0f1cff404939febb0183fbba48a03da97e68cc867be578309a112f0a420dac828417179e552facfdf72fa9ac13800f259810d46d605181eb1b91d29e7809efba7035ffaac576fa9191c9eec2bc87c0e977b1c8834a77f425abedebcf9db290ea327febae073c802782817c60b31fe65d7a19691c0e22417f6ef5b1c0fe954667779ec2b6242c799c1bcbf208da74d85b110d65d4a9b9e96a43301c867ae54ca7bb6b8079636e39563c6dc7525fc53bae02a5d7b5582cca9a77e502a1e2529ab5e9cff2a2bf9e4c94c3555ac13174fdaed47f26f3b161a984502a1cd4f5013f18831a5ff97462e23405320dc191aa85355346d1f4c2aa8aad0f67539e26dfed767653ea8c320a68d7d6ca617c9e1ff5c7d7b6effcf22b42481b294d300b06b9bf49808fc1afe91b9b5290a9f97e9b6379dd56687ff95f32f6c090b3a83ce34ea3a7e506dc1dc7c49632ceb9d33fed486ff9b1c8a36d41719944d38ddaef5155ec8da20fa187ddadb8213f360ef351883965b964b9c8193d4ddb4f570d9f758b35b99cc0e2b1c3d531d521f4300a99663ad13b1e8eb9bc1f0e7ffa4bd5b81b4f9f1792572b17dafc9f1542054a674727fb485f18e6b14c70f0eac26cea96df5a0560cd28654111321ca2f68d756591631f8f0d0bfd21a665e4dc2fd9164ebb02aa49065f8be3fbb2f684dee556edb5e02899a286708138e74947ff5022f08fe9292668a588b45ef467423f329a93e4bda14152f4b30c5aaec09655a97f16757087efb5127c23e5a8cce0ccc132658f5d29c41b7bedc2d2c50942ced3815983c2e7b2e8e759d8f0f2980248bb0add6b2ddafefba09fdb67b5528414072fa33fdb5483202916561b90a053bb8b468b05282f33faa33a4bd6de3104c2138da6d87396996d31ef4d8cf9a88da464973fb19cf14e9abe21b90b19a17b8a38bce71250d2769788fb3a4b2fa53189920a7be350b2c618dede7bb3b6923ee4d19a4fe6a2dfaefa87f5fc58d87a1c4b466db9f96b35d9de3ff5cb9844c16f03d026cce90be48a98f761ec81215108c04fcb05a8183d9a0a13d25cf5bb201d86586f84a1e4fdc8eb89e89448b066c84880a214f450c4a666c470c172490f0bac4c507a8675fa7a21716af9eb9f2aeb1ef34c934e78c5b99ea00b0b55994b32c73b7971ec54da1b3e167912067e34f7083a3b19c86f89d59a8fc4337bbda40409e82b9391697015360819d7225ef9a1cffbaee1cb7623e17ee593d60b1c0f8c3e679176b33ee1422624b17c7dc9a41f35fef0b996b4d38bb1d4c2694dae58b9dc9503b521649ac38b749cbdfb5a058a2da835c61c531c66bbeb8a4f33e0ce3e133fdaf4b50cceb7da58c18ce1f42f8b94da6a8543559e6f91404f93e150a640aaf3992aea838354382ef226963460da1889bfa490ed52d873d1681e12757cee648c29fda16704916e93a11d8392fc1dc86c67bdc53920d083d8d07749ea969b97cbd98575319f904bfaa5a1dea25e0f37d86c0da3811dbfaa25aeb1048cc67de64eb62ba20c19f663b9c92fd95043ab06a3c9f37b5b2df2a9d5d95b4237971ce36467c315dc6423be7ce77c38d430363f97c410db5e06b6203f974b825df6de905f0bbeb32a7b246eadfdf408d7bfb2f8531b6c7c5abc5bfc42ceaf14d6746136fd72cd79ad46d6d39927b1a3ac6c8eef00301e5e2bb01a751f6bd5218c47b485207b8d10ea328d5f752d3cadd9e9e49c63f60ce70fb2477c109fa2eb9769c22867957fff9b959d5e7e6fada5acc33120cad9a52d8743c7e0256b8dce628acaf00fafc836e69039d95bdfcfd021a262ea810918dd99a8875539e1a3c5708fb8e4c26e4cb6947b42f3bab97b57cc8d13ea11dbeac3b96eebbac1182b9e46915024aeac10d8f7ebe77848722e7bbb3d44272a9e18226432785b4950a550e401633eb685c1ac2e34772d6f1516de5a1f80876e33a6b5f22fa4e6f5d62ce299e58e42840c674d3d609c1f3acbbae7d89b955b0f2242a80bcddf26baae9d41745359d0b7f8847b395294c123a889446815a532d8bfb7b4e4c0634196a24f89350d0cc2e945703fda28fcbcfda3e18afc59e5ca7f323f729a2feb2f9d110ddfa19dae7d2214f463595112e0c5d53232600fd6e8d17842bcd0c0d1645c539860b37d889c5a0c7828fc8936a8fefc5805efaf08f15f0bcea687d4bd5907c236d12aad8230ff3eac4c4adbe9a941f1a4fc44181c4286be533533ead212ecfc17b7f90acb7288de8308a015a0e6351508ad65f91a800483398a205da0c7aedc62f31d1cb287ee5675c5218e36051571f9e66ab668de9fc39d814bfedf93822831aabe32596c38c93010abf22cfb4c32de4fdb5566b383bbeb8624ff21d34ed8fdd1659d1616b4d017265a8c5dadf1bbc4fbe1fe13ec0a67facdd8b1ca5fd10de7d938c61bd33fb9c67226152876477986e9ecdce234c9365342b129fd7d0d59e3d08c88eb3be352ba21cfc653da09c444c7dfa6b8e21627431fd022ceea28dfc72373cfc12b57871ca67aa18bd73bc1290d7824ffa71234d9357699f0a9b2b2702065b3089f318ceeb933cd6e375e18a48b6d6a781233922ddc86f210aaf3cd635b9b05501b8ea7777f677211da285562528c4d870708bb923db96740fd0016f299967d080d7063ec4f5adb94b6d1aa04d11e0b154b6a8fe21892b19ea521a2f83755d02f00d3d33c20cbb7c8b2fba66ad1a1e475bc5e71ae2c56416aa7a051abc3df19d4df8ba9c4eba1a33b46658926ec27ed6093549cc8fbad19545e3d96efe8ed381de9b3e66d4860ad870755e29bea5f344d4d91b5b4f201e6c3ad02c2edf2ed3e5fe23637c808f008b2c9acca5bffbbc79e5a271e61e0f9a3b9db59109cfbf0a2c1c26d6e246d3668a917fc42b55c80ad3c69ceedc1616f2664195b3cd3de1a02c7867e9fec7366f299f876a55e93f09e63cc1bff5b21029719994dff91eae1b527f88c2c0c60a65ff7c1ca51397512dedeca57f8f7704ceb751f2bcf3384c5ec16711870e4af89b02fff37c1df383cb7bad5dffeea38f64ef97098d834c655a81f14a2fb7acceabcf434ff5bb6b52f4130bd09330694ad87ca563bd3cc78b2046e623a0511fa8a9c96b74257cd29dace8f6369f6074080c393f5c53ca26ee73bb644212aaf04c0c8e5870ac0fa7d9f3e2a4a30b58ba8a5b4f5d38676519bda0e56b03d7dee76b7e3d2a449348e52ff4cb19c529cb828ea457747568aa677eb9fad3084c845f997a0ae0f6d46c1eeb8baf502b9a8cccd718bb8d9afbd6e8a984cd2a6a907f978e489610662cdf5d2cc2dae8163690112e71a323b8b12f656d81633e96326460e77123856b931a23d3b37d7ff7761f44960c0a951c53c73b53dc77ce3d24cddf8d02cd405a37b7f1e0302c41149b8c7904ae712fe110bdede9d9bb434be67ef238fc8954273bc83403a3112b0df8c113586678a6e68facf4611d984e4a66620a94705e4d1f2b1d48ac0ed9bb0088f270e8d4be7d32f0fd69af4747ca5b2815b2d46e9360da3a14dc5120c43d03cb9aa248cc60dc8b2729aa67474db0f97febdca0afdcef05579cb642a9c868e7193b8a69c9faf25c0fd2603cd57d47e57c3181fd839afdb04cbd236c1ca220101c98fe65f0d91edd7296d4859b855c7562ce742c743166e3df242ced47e7967afd03d8c0ff038125ce103dc29a7de39652c789a2a170a4dc9f81fe870306ed5678193969dfe12f70e569a48ed105cf40db985fed8bbac0091c3e30cc4b3f7352099f918d5da354a404f6456a526ef73dca8e1a7f780179cdf3caeb64056c6454323eb4a8c55adaec4ba7b4c3cbd3cb61f323997cee38f76472d0ea458dca0bd7c96eae8af8e2e025417efd6c073659204124913e937dd051cceefea7bf6cce26aefefa41ee0a248714e17de6e8ae657ea219cc6821ba2a39d018fbb3d0c48b359ba4d4f49ff8c3279e6bc2fa3a5d2f5ffce0331a226f3b23494e52b4e0ee74731e6398815af8a93052419f3d47bb64028b15070c353e66a276b963b7382e2e4d14a0a5fe9f1f57bbfc812843efe36de4cc20536cdc81782a0f15751c90c064851c758b9dd636fbe955725768c2f90c3820fbda6d4c393b5f329a3e4ee5a05142638d869c3813d35423c81610b6f383971fda569be90c2e7af4c235cf506f50f399d8d9f4637e030711257db15c5f56cdbb23a918ad3450419349cb550853b290a138541a080c6afd27825bc6357063ac6a5e8290b85ca4aeca0ce8d8a03bb633341c8307998f9d07213cc436c8f0a428af167ba4ff5b064969dbe0f73a480446ebef2c33f002bc48580bf6945cbc6bac3f10b877cd589c26c2da25f9999c8f3b45175a025a9b7fa3870cbcb6d7ab362decc8ef3f8571e5e3d7a3d5fba414a9b730d16eb2313e5a7e8e7db9655e2071046828f34aa022233802653e6a813b032babe8bac3e905f32a5f4dcaf6d6e3db8b94ec59ec884ae68df9aede88e5e8d76f7e2c099d094a13c258ffbbcf2fd198e7c5219d44088a5ee9bc4b03f06fe10eb410df3291127edc00e310941767da9035aa56d19d36a6c4ef5d6040f24b01a1740f22a39b3a8493d9e1e04c91389d008cfa0e002421cb48f027c3059c726f33305faa5af98ced8d4c5b00157928dbfc23c2478bafdd7f624d70fbbd38cac44991f304300e1a577e99e03367aa96ec389685e45edf8dc020e6b255e8a9e474c8adc94abafbc6a3d6edd003fc76a59bc6efd2c635cb6a8e7ab8898c7a2e47c0b8b5b360093b57c73fa77afe091d55a42c103b3f2686759a361112d4dbafda44f49a5b3fe9005194ccbe926609c79d30f24330e5d288581f6afd1334907ec7abb15e1b46348888296b35aae8c7b5e759c4f132c732ebdd757f91e559ed4376d09358ab71d18676256959f67c1d164d3cf73748e9472f9158cb9b34447a44365538c6d366aafc9ff6288e47cb51e3a6f3a021bb9da7b188e9195f36aeaacf2404cd58a6bb1f6b7d1856866ec5ac8f354f016edb3e144e2c0c906cf29cd70dca380b5eab1a704ae542acbfcabc194537bdaa60832843b57407bf7b87d6de0cb2e3d4d0c0395617cb3d0bb14dc5d9db9eee72752ee158194f65581031ca3f8059176f7a0611f337200acd44266d5210235616fdc0751bc55fa8ff8f614720800e4fc44a754f9e195d45fb5bc20cea0a25dd51343cb200960c8cdb7d0712cc51dfe96cfa8e437af046509147e5581917bdff621f03bff03d3cea5c61f64f90c4c31147a6f2235bbb871a28dc85d8f300f55ad991f95f4a453b7b21fe7806ca91cc38b84d16eceeaf3add07772aa3a1760033e5aea03678d6e547b2cd9d250f531f9d46512cb4f8ea665229a0a2870b3c4b183c8a030a81040e686466680b59a1cd1856a5ba3686870c936f6392d2091963b6b168fb9d3927e462e7823647ecaaf9b025dbcd03a1dd25c940cf34ff86ef6571af73ff4937bcf12356242558af15b3ac5e773746099e7312fd862738957a40da08b07be3a66692841c6408e08916d5921ca257dd3d937efcbb85fa881e820ac8aabbf28de69dbb0d9d1e9745e2c3347fb88e0b2ad317b16d69e6854896a67d01036f7ba0a57c6404ba60564c90c07abb03d9794bf64de78a4344c41749997240a06dfd031a952f9046ab5bb69009da78b52f1f92981527b3bb262fa89d154dae51730ce54ef922fb23ab8587f612ef1b6d7d21916f107aa4f64f95cd352ce6f26fd5349f36ebb701b19318d98ab4c16fb5ed6e278f8e483dbdf5ce4d7bd3700ecb347575035df381e4b3eb29e7240f66088ae630c6ea7a7b9dc6f51a344766447a7fee4a42ee7cdf963b4add313ca149dbb1ffb699b90782f50b63df851366e816c9fa5c5647d9c1d98a499d5784ef19e74fe25bfd967bebb5847e32f6801d319632b22c225c1d6d8657ad99426fdb270e9be52a0131a16d9bd36869966f1b905c28b63acf89be2589ac8f74c58326be0680dcdde079d0330ef3d8592c31afca0d6fd4752bf8152a0684bd23213c9e8b3ecc272fe6bd5c1714aebb415302d37888e6a81df0acc808649ce1496c49d27e63eab97bef204e880f33a84015e83dea01cb631be522ed47535274833c00d9af409f593c5a5dac1dd2fe7c24566ade83f18b4e67b47d1abbba5ee3249e6f9d308563e34f84f1053970ca34e209d76a327f563fe0dc60ba055a4848607524e316c89cba546327e7de194c6cd59ec06671fedd9b2a9309bc28e98736244b106b218a9b9f30317de3fcebb666422970fd49dc9b6403e00d698ff46bbe3530c0d8747f764de06583efcd6e59e0562d0d77f1228ffacb5a39d2f5400295407b417e80d67e8d3f050f25bfda3af53f7feb2a3b1ff1002b6aca4ef252aed8dcb17078d267cfe1826e7fcba53770d96ce3563f0faa08b9af78c2ff5b37b410acecc4c478a182db5d24206f17b588b63c71a8d1c44c90d170415e2ef5591039fabe92ebaa3d8218277922fab4d7107ccef7912a9811f58877421bae48731cede7dd4f3b1ae312e7bb13ccf88f3e497e3346e1d3e46c6349153b9837162e40603ed387f7f8b90f2ed70890ab2daaa6f04ffb49b2d24e7f6549af14b5c7aca6ee157d1bc3d99523e1c5e9e6cd345e044deef99bd796217e97547987d7ee70e4dc3d40ecd2f94590cf49242a8512ee9008169138ccbe74c3001c0d32085ca80fe6ace8f6e3eda1517709c3e7e4d649852011dc34330d325f382c975400ff665667ab957b5fde1d83207dc06b83d2936d96335f31ea6294af53d15cb11a270e2969c0e62781895422febb7cbe00fbf34cba8562d7cbcf4e863c00042c8cb6f677f39976daf0ac65e0b59cb210b3ab768ee4b6fd6d062eb412e92142fcc902bcc0e275c570f474b51958ddf4f28416f1ca094f9beff10e6000bd41856339e5c2615f0bbe716154a9291e1bcbbbe3d381a27fa43bc70adcefcd5f10cd0d1faffa10761e5970bd9ffa4c4b4462c15212b8e226357ede07eab15029974fe6a1214320a56337aaaa98e083193026dadf8460cf4352e0db62367d594fd2c0cfba7944d880c44c2669d930b11e8bf8d9a18140221d0bdc8387a985b67f667f82e37782fd2c833dcbf420a6c13d0115cb493d3caba56c6b2df171c94cd6f6167b37b1ea6ed2223867e201083b6191b76568664b2bdc9732c08bd368716de9f537229ee41684edf9eece1cf126437498cf2545940ca3e816633923c166534daa1b4f579ff08250c124c681d12cc98b89116ada57d827d77b839310f868d46528be8ae7508b1c5d6d7d650817a1cbe2ca8180beb60d1d51b435e0142a2130876356d8542241239631d514a21dc859b861ee99854c7139064f5f464a2febbeee202a84aaf355bfd87157ff13809011747a0be7b0f6e5d28ac859eb64f0d552779d1af85690e7242afc8e4af51f7a46a4fc3b01965a3444a75d5f438288f357b87d605e3699fec8e3f5375d8c46590e2c2754e7e69c919e3d30177ec658b3a3d916dae251232ec287ee2e826c900468f5c3950a2f3a6a5e0927ae5b9dcb399f52b90d71d1f1cd7c3fe7fe4ed0d8ea651d82656dd8ee1fd545cd6d7523452ed43b90e4dec6e56dd9722b6ab6f50f861f655b7a846422e00ef19640e5066c4e399e0e563b0a0b24e993dd13845104964a76fd925a1266805935ca202367bb9157468a3d0d22c64b3a2b40d14dcd0d4b47442643ee9b68ca343c6370acca1ec0cadd757c37b943fcb4aae3a909ff30b81322a810abfb58f49a8d3745d8d0106c3009b1fff3699963346c8b5b5d3fe8327a2f49e1ae6c6b0d9fe0a0b98ca72e41fb36193bf2b9fc3985b29c90f6b57664a3917369e4ddbe89fea9c96e72dba8d8b5777e10fcb3f0a4c38a78c9b4b2c112d71fb7f060f12a66b4422cc680c2f949cdd243526cfa65abda86e7ecf2d899f7fcd13ea9e325852633adaa5a9339a27c4f89cf693baef04036be97fcc1f8d0ef394f8d2be4e15b86d178fea08067833e76e035440d7eb058c5a944dfc52e70c519dc7b277a0f6dc602e1c8c66884578e693cb504fa753aacced0c63bc510917c7c81da00e9bf47caf6178dd912a5da0372934f6933df7444feaefffb942d6fd611c0c1bbf7b98f6ef7f622d3b02680308ed9b9e442573cb423c1554a99b61e0153e450759bcae9bc73bd9c096643172c9ff39951d168af9757cf3abdb374a9898c830ec936538e172ce50601ade8254d6f5a5ec49444a07af12c849aff5ecbac4438df1bdbc57eea6d6d955e3d97e5cd26b23bb8bbcc3b7d1824bee443b6e960210c3953f5405911a609a6fe6422b8b455dcdd95e7f3f78018f96babc2ab243cd1d8cdf9073aabb1b8a9b649b8843bb8e58f6e9e3f52a8fe0e93e51021c31826e669db381ff56b61cf2e50bdd59dbeb131b645492d6c1b3fda8d42078d8ce9909e675a3de6380be41bd4470cd31d9964d35fc5600833b5d80832adefcf3ecb1e6d8f13e350d6b147aea477d112129fc2451c2463c55878bc345faeb1edc6f1898c58a3d480615f5dc8887e4e9677363ee5689fef89f2542b60e9bd22c4ff0bb39091538f1353b477f8280c39866976e67e71e0396486473b5de4033694d15264ecf39b80b7e265dc670ae56321d84a9088ec7723d3171192a21b9c31c189025be61e46bff4865aaac7df6dcbcce9414c84d55d5b0320328fffd181e92220bb884c44645599ee9dbbf6424e15a55c931923d724f9efb280760f2a2cfdf4f599b766ca40b5f8ce9272dfc2c86914d30f44f689ba37ca9078bf514a346f98f17e811a5f21150d9cfab652e326acf9ab1468cbfd975eebc4ba1a6597b7e1119b87968f690f8470c06f5237c4da7a1aa7bd7508919dcfbb71ed083f7a9c0d672c8acf7c2550f80c73af646ceb7ff0e9646cb59dbde87ec2f10b31cb45e0b737c8737a3840e023c1b4b51645e99da3b0d4518649cb25188eb1da67e1b9f991cb3f10490065b81eb26b293039d165a159f352f9c41f89e1d7b6f43c38fb18a0de24cced36495812cb1f1e231e7940161c9f791f2509238a3cd984d1486928da3d8849026d7ea572b67e60b5d39f68634cd5212c7ac37b37d6aa54de1274af3299d9ba352effa0f691030cd2a7f0f95389e587558e76fd10562d972bb85962cf5976e20e482fab8930ad987fdea7d5a42945a6f83663ea49d3775295de3cc2201b498fae302883cb4b707b062b33e582ac471375a0cf0ce637103c158d4c066a646e59121ed4b769e5e0e324fa553fc1b598712f197e8eb6a7410306e1eb695177d34c58ed25b4bd6140bfe149a67c472953c8b7993d89488734dc7dacb035edc0d48f17047e1b81cfbd71a9959d48c8df0d5e48fb29bbc09f6e123915a442776b9ee328a07fb045b63313dfcc34652c04cee610a39147f460fb6029eec2ae6428a611a71009f15f148a84bb3b43cc49cb3bf44b41fa0b0390dca4cc94d82312c2a39c690a7786ed704df94bc6060b03f1ac634edf3d91c3d3577111918a74af1fb829b93775e7bc24a73a4790bb0ecce9346fef25b60580436e29036890e67f2df722a0750205d10431a9773ed4fc50960b1cc0bf7c59a8c4780a3402d0e006fea48e78c716380ea059b06c583989c90a1fe3b3431fe10e636d10d08503829ca27014012752941878e6cfb13d9d4d811cafee98e838817fe5f024203e9d5fb136aaaa0fda4f28b07c2d141d8195c5461b81942db275c13b1340f71ab7ef35efb297c380e718b3dfa4da4cb5e752c34ea64df0e2818b05d0d233dc1b967a876d6ac296b71ae57e72f3ef16fa32fb970502b20a99a358f88baaca20141d1daf0e1603843b857b32c0e1caff5119625889d585e64d88d035e2ce235a824b351a64e3a58462cc6774b93964d0b9d9bdf7a171bc10960dfdf8244719f8c1ddc8311dc2c9e72d54230053ce1629cce3f812a64ca3f4ffbbc5820e07622572896bbec61e0eaeb15b4010891e9c2ace057e23de00e3ae0abdf0aa423200ae383223f566bcb783f0e9788a99bc4e3f6fc7ecf0addaf91da517a1d0989afa541ee2f8752f6c6a983612bed572310df43b6520da61f6376242f89b717f49489999c7447262220d66e632e9c518f554179329fe10f76ee348e4b793c6a845f6f085fd9c94d3a3aa890d78e634a289653b90e1d79e4850ea71f2d2095150f2c4dac38bf5f101ac63dda6289caf847489f17417d1c6fa5c5f4bd747752e393f143dc38b1d079d5a9d7bdbd18f0f09747105fd53c1322f4340e6278c11f9e391d2caaa637ef0fa0933d8037bf37ceaf8dc3d9f10f34b682d62a24064451cf91007fe848231cee2e54e5fad3a0de19fb9bdc84e465280884bd9f897944ebc5dafff454be290ea75dada5c83e1c5403b1efc091ef9f0bd0ac7ed957495db58eec1dd0441d8a3e476171f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
