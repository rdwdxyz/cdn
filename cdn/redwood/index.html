<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b7279027844ac669ee55958b719bf7153a1d0d3e62f76cda5f60eed018fec72df1f574bbeaeec171e87576fa3646ba7304c72a9495173b095b700fbdef1c39ec61ecfba6a43d9f65f11248fa2e79a1317c3987dce3d0d0a3817aa43cde34f468db8eeafaa66ddf873807ee3a4dee16c5d47cfd782442049c8abfe85ed9447b2655539f069ed15760ba0b849879f11cd67d7c87c2aaeb03815845cae9d8dce6e7a84216ba98bf69a070ecd1badcf805b117b7aff80aa38ea200d60d7ac492a371c68e5e2aa73540dbe6bd41e6eb632147068dbb27a78b32132f8373ebe5d1b6791f89b1e3e92c9ff42ed7049c85f99b0950c16fc7d7f6020b691f23ed8394bfabc53ca825ebd7a6c0a74c07735cc571c2878076aa64e57db945346f6c40236c9c44114153761b7cb237506feb25de3623da3c939e0849c3d0f8e27a69f6f7fd87a958069d874bac72ed79f5dea896a1e5020205f78bedc34d736cbf175cb36b9472ccfbc706d8e641e3ca803606481ffe0490a688420eb7d87d77fad84a7953422848f7b200fa684c206e85eb468dd76f1dd642c8351360da4e6334ce2daccf9667df49db8e28627e83c0d0ab593ee83889161147ae143552af43f12ca2294ee5af66e5947c1c1414daeaa6777239ea41785f3dbd5ab64e909b3e710b1665968d4a96b141ce0b34232846b343301d7f888a459d665a963fc0d011828604594bced32a314eb945f8c51ee3457aadc9bb4758e6cb98bfe8797cc59eaa4b20a14994bffe79b7f11a3abf08584335fd87c879c3b94c983f87c9a0d4f38dd704e7c0ad04821d9d44d5854e63034dc448fc0fef58d7ca1d9613cfd2ac0e803ad461b8eee2ad48dba0825cccdc20d2e2494f65aab0c4661ffb9ea20b0be7b6f9cd8c82c785b329d7b8d6400c8eae67b29cee60e2f706e74c5ce3fd00a0147ae595ff0b69d89c875c9ad41c2be0710a8b532ff140def75d1e7e9c4109fc214332210f962f826b284fc923b65d4afa0e3a6f428c1547aa47e3182c7a87c533b877512224f396b00f409e2ab80565a84ca5bccab341b0c3e3a0fb00edc44dba02c53e841d4cf5afaa96d67a78d04f922dc696185dd4734df185d32ebc03ff504a31af94a75f0ae3510a1c923c90e2693185ade37865871ff91951dd4c4fce93c816aa0bde1364ffedbfadd9a5b8a3d03819f43decaf7ee98b2e1dc4220fbc79273386904b5f54c083868d3aa814cd378461879d4eb5ce932c14403ee4352d49abd580ea788340e92e5c1b64482714d6b347536396f51c53cba9b17d5e78e51f896e3dc0c2cf1ff8cd2eefeae84e0b7b3b992b10bad5cec2c77d9f2f364294a9171b656c7010e7275f3bf5980d4e2017fed6a081cb49607c0ac22ffc554967e45a79ba34a439a69d03fb0b428fee05c572dc0711c9f78d867faff97b9605b6179a8b0fa954150198b1b981ba53a3cb48650512880a2cc48e640fe9a3c9a5172937b2d925a381370a4e39914c73b5094384575291fa4c3a3de729d56b67fa10c47cb4a4464be46ee26c3606a63bde0b62536887016a86129fb9784c2fa6fc10b87b78b4ed4558382e26bf3df4b43fcc49cdbcd16352fd793b78f39abdbab7aa76e6c891aa6ba32d5c87114bc8c4adb8c41c67c227895e3a4012a7b5bad308977e33930911252a86871056e5355ca04c09efdf4cfd84c5d655ce35ecf6772b1d0bba8325213cb76b8f1bdc5c84b614cb28677d803d49581a768b166caaaadcb409a5d37cea1e00ab4f2d6eeb6829cc78ca38cfa625d4447969f0dab0ad793ac531ce1011e78a2efa9f2c9ea286436b22e322e9c439d73475030921fc64c7f4375bd96eb3503cb6620f0ceff7c568dcfd9ddcfbc80d37e3a58cc627ff81432cd5ff535d271d7a90f01366dd46799281621c0b50c0cf437e46f70f0a7dc43952f7b96758bbc4738f722ecf70fcae9a6b35d46dcc46158945ec80653211a4c3043b1a661f3e94a268009e5b56421ac64796fff34598a0ce6820c9bfa922169846ace68bb0f4c4f0739dbd49bb53b87b595a0bc4eaa2118b4d3e56598df880ee46ca1b6aca40140ae8808a6586dd496fc8ec432ee5550ce464d675634da11594883b04b7b8307f591f89bddc0d7543052a731a4bb902c23ddb3c12d32a187ed09d74f36000069b39f0e72928574163e12564483484b488c641e9a096ce6c54f9f5fcb4245304891a80080e40997bc2bc736bc6f2d1255e23cc9bd250217304e07d55f7a53a516019134c60c87e5944b04c4aebd0abb01bd233f237dd5bbadc56a8d807d1f6973ecd4a7a0e2632ed54b2485e36a385cffdc04998e674fab05b31ed710f3bf1c5193be545af785129329b5534c2fe277e0b92cbab2dfda88bb7f0ddb3508e6a72d91a4c30bfcb82a3f94e61ec2aa7e6b50560b905905e5ad07c67ad2e521ff98fa634fbac7dd30bbbaf105583ebec11062ba45d7ccd5807e9608041dbc7641adc4cb7a06b21a355f7815f28da5b24d2b06e8cd2a969d311b80d708fe3648fb3c9e3ea7ab1d0621252e338810bcdb3c72ab4f4c7a7bd2c5314575489837773f6a43b1e8ddc3c0b600661634728816626ccea358aa4dbabe4b48bb24f6dc1fb4b1dadc6d67b8244e1c6b533ebebc086b7eb2e4f39a2a494b45f2a606ce4f6d6c8886eafbb946c6a26981d5cbc3e73ffe8f52a259964ca7775ae8e19a2c862b1a9a56d8b5badbdea9b3ecca2a94898e657871d68e9b7d11c5a9960c54c380efddc898daae77ade127a08028f0188c99cbee0c093bc1b4a6f6b8abf786e26aecc81d239882ee94c916f508e3da0e4abc5295fd23e61d7963c03d7226aaecf094409723b838004d60b9766ae848a8ba3dd85624eb9520b416ada290215f424b8f1a630cf107d8d7ba0f86a63b4466866422c1a4e612fd19604428f2e9293c6a94247fa826ab526cca5add5c197d87228520b976f1c4827a85f6d4feeb0157a08cccc85fb7bf9f5374eebe0ebb6596a1e4c3cd39a4d153205ba488548cde403ddf345363a4cef74a8ee71836d86873cab4fdaf7b275211504bb901667bbbd2cfb1c6b1b7997a7532385f0dc7fc64022832a8fcdef309bf552d7741ee93c7343958cbc088b0181e60fe4841170979f4d6e21f036345430d2517c853dad5d0cc8e4f4822a2181f70c84c563c3ce9643dc7e67a8bb0880fbf6b31b75001e59fb8858db169a148167de7731debce6d4d81ec9b6bd6a3cfb1a57d913084f66d365209f0c0bd964ed843780e4a6a370e37f2a41e7004d33f49354b13a69b261c8972da339e1c8639a4f832411a17b19196664b8f0369708da4f186839320107d7df12c46518f67f32886b68dc641b8400b7e21f714b45ca14d08a8c042eefb86abc2f85bdb83707d72cc50c0d4812fabf2e33632a18bdf373a2bb2052ebd6b336d41770385ed2bf0d07496806f7152f6d33fb754405deace1fa39a4fdc4a621a09fc2ee02b0bb27a37322b59e753b29db29f408a11b97cd7cd8ec00b174c9176125e7d01feca5aff9261a22346a6f387924a40dde56dc82c463dec26ab60bb28e919e4061a10bfbfbb8b0f28f2642833bdd7167c575a33e3f3c9324d2b6dc88bcbc3dd511882cb1796bda06cf2f6bff02678bdee4617d01e089c464c58c9ab6eb7bee7eb55b12dc00ba814d9030290df5a35c8cbe6bfc521895a0b9d66b4bc630bbe820f8ae77790d1dac045368d5b9a9a3f3a882c92d1460c195255039a145d421aee5b7003e2f1ab44a3960c31ff309d64f66b32ec201ff7e88392d2bb0c340aca59eb9f95a36ebd0d4d690991e9b4e1db3db3bb3e6b04be6d796dda203094b7a292a25fe6a91f780ef0305901dcb778b06afad49f8f6f1cc882a0198fba2a8cbda5a6177e717b8cb83f2eb5c54c89cf195e409dcd2a8c1571e97470dc85ddd9d3ba44bffedc5449398e8aaafa031dea3d47d6c76b65f53a6bc7b17f45fd05d403446cf64f02df0e5f9744254ae909942ddc5e2da017719256f5cc44de17f47b9c990cef49b919215113532e3dd9f4e7852c8ad575c29b1af3d76ad9940ac018471652485177076a79c123240c1d0f1d93eb2a8bf084fcddb3ac842697ed52afbb206335df81d54cef8b54cb038e56496ec4928d2ae8a7d6c8a1c7063e251eeb6a38be33099d1146e63082a1955c1d33438ec50832b8451173ea9dbb46019d0137430306549c0f074ed2e25f36d5ee217430512f5add02e22adec6f64fe521cab26dbc95b9552f267af34d2fae7d1435b8070aa399a285dcdad226b748bf73c053b9481fcaec67fc7827ad4a774e96dd0ead326eda9a6ec28f75ef8bc022ced67306681126a978edf18157f696293945c118c24eedf0e7b470b4b63e39e5fba7fa87943b595ef5272186f97a8d0c021f541d6718a6140ee178dfdbebf2b1b0109934e31b8a4f76680b29d782254fe2a222a6b65db105dca34efd131e39817ecbc47ebd53d2aeeb5d1c9da8c42454f87232090ef7c23dd13338c7f9041ca0d0737c3d2f5f6bba2f85b526396cde9698e15d8a268b383b2c1b777c2390fd78c026e020c47cc32ff0cbc62b87427b8edab847a2cdebfff3ee0a86a75a3764af6676bc214831af419f44da8a584e3152972bab8b12638e9185a3451ce5013e1b50e6bf90f0a64ef97b024d6a4712c42ce5fa22155ffd47124cb83a6d241c38f8aa4f9b7439a08187a8452c77d99b548d3ba9a4861bb73ddcdd42436587198aeb19e5c62414f9828416cfeec48651ea7ca4e278339570992247d8f4248afdd5279894c66e00957f5a2abb837d01ad230708612856cb7d6fff7ecb9249054e676e59b0a453b02ceb3b6b71091c90aab599994c0150f18f7da5a909e01ff550435b987c27e41ad8640119b793b52f2de7b4df7beefd709ea8f52eabb30a412c31b9dc59bddbd4209031ef9586b182c5dc4fb1776eff3ac15956cd76c67e5f0446e405ea42598e0d155beea51e9592de37026a344e6b6ce830738d7160292555fa1787b3791f6d521ba12783f1dd29ee79d90e231a3985ad731a6d44c14c8789503f08f6f2f81c73610470d719c8fc9128ba7aa8db7988116c671c6516e055d49e2acec9db013f3a41577c6758a8df3721c6d7b960ffaec4de2327207ff8351e4cce9337f52764d891362ebdac84c96bdeb0ccd93350311542b4ecf5e10e517c9e05832bb9f2731f9daa625737327be656eae977653505c560a503d26ae7286bfb6a09e67068de1bf9689198f9462dc64fe60c71783432f731438d5dad2fb32137f877c93b506acf87f09a9287f9ab9ec394041db5466e38d6d8bc8ccde9ee35a0ee394eb250a375b4175e138a41ed5729dac232ce10b35e8103bddcfaccafb02c181a29358aa46b9d74377911c9fdb7fc8c000b6637ae4e13eca54c89326ad0a7ac1661223f05d76d97475aa10167bd587c0d0fcc02c5bf16e725f4c60188a74106ff43bebaea52c062ec8ddb85b4f7fdd428f68a4f7c8f7e749bb8459cac9bbd57fb67e2be55acf9d1d60ae3c37d424688a8d75d94eaa066f2f46b2fed6098d27739b7086d2fb24f1f8a850f8040dde94f204db314e62c5901332499199e9e6ad1e0c9be712cae60c30ecef56550c1a680a001b95cc88ea7049ab869e27d6de3cef84d5d914810364675e54ff6dc1a7d8d7454e8ea58d52afa556b966216cc236340e3942dc0e6528c13c003858e515c52dd2e81564ed9ae6f10a69197538fef1ad4819fa5fcbe0d079bf370ed6a3bcc6554f95b94abab4a211b6bae6f67feba76fdd3168759a8b7fde0db3713c2b2d6d398c35b44ad8d6faa5f2e1ffa9a2ea9f881fc5084c5c0dc5913ab04fbf01af4f2cf63ce2aa900e2d710f893f7b82d5904f5dfcbb98f303a69ee4851a24bb3faa74f192dd5a44029dd99447935ee0183f7ea48cb71c0128a0465d38bb687efa7dc361a3f5663e491710d30f06fc43090e52884317444225777e61650c622bdbc0cbee6d655d86e6ee32fc31df710d95eb77443ab646df574b6793a0378d3bb88bb2b1b2fb1c5fc039e2d4ad9f61b696506e4d3f39de101abe4a440d4fe96c3c8474faf3134a896a6dcf4162245c42cf21b2042b22cf099304b58886169de64870eb14a31b0fb6424df5d503e7e2a296a8cad5e4110c0df9d627cc9521b2abb715cc106043db957ad27e544f1be768f62d5351d6b02913f20dd7ae1e5cbf8cf487275f6ffe2d0e67b07e4c5ba4d7f426b2de7c9f7f070aca95ff44cb9e0c0063fc1c938262a7a7ab9dbf6737b08d0815b06c68824ac2dc8c3f586e4226775f430c4849286035fa405a88380000bb19b1638832f41459ce305cbaccc4872dd34a955412c0370aace03ef105ac0672cc6717b861ce27940bcf4adaebe95091e8b086fe024892fc9e47c5f5669bca047425178ae65d600cb61ec27f618733013005230caa9a3343a0bc0bc7283e0b3cc0e0975cdae8083dcf6e77b2dc8f84243e95986413f2b52aa962225c587a983ce5eca520f3a31ef2732e3fb9a1bc73c7c63c52ea300d9fe5dbf4aeadc03992e3fdf6758ff5ca47123f1773ab6122cdbc7dfde1f0e8e212bd1a3a26a585eeefdc3b169df24d8c03742eb6566221645cfdf93c12df9908ffbfc0fb3138fc85520e6dd69d163e54ffeb1f790756893c6a2ab9d693c05319b2f946e095d82f6f71dc0d13d6756d829185b6352df692387201de1752027d0e43c30accc639e556331d88b5f7e0c33d5cbede967158ad4709f45ba49dd3931544b10e94674a8a4a51e50752ea4cc0b37da37324f48dc41f28939e838c2c45723b8601cd6d2637cb836b2d31181570e37ad22045c998bab9c41392d783035b4b5d5ed74b9a655c23038b42f9b013da45a283d3bfddc7535db2c0379d835b8a37a06c2d4b8768f5af0db1cf78d44fd639b3caf9b691301157079c7059fff61f0afc2996aa734a20b74df8b51b579be354a0dc658efd98412eb965c9d6e1f9a7ee95d965dcccb9d8ad6e17e102f710dee4403891d7d5ba93f65addc10783fe6427d481c9d4d035413ade588386e8371d942e9faa37b94ab68daa7e6ad8230f69af57199cf09f7722cb0957064bbd13a15e5830ae4fb0b3c0f3e429c45070a3bc0b12417e0e7539eeb2c5e3f429b44cdc80d0a5b298975ec2e42a8e20e776bc91294e1ace328604639bde7d5680ed4f2d627aca5b5aadd72ea7ef150628ba637dc24ebc6492f23e238fe9cb84c5ba419f6503b6955cbf3cf9edccfac6cdd8d6e73583063848af39383aea8e9581ead704509c16f4244c6183be196b9818ebcd64bad09f08fd0ce4fca06871e77d992171615162cca138003660127447a860e85dd7cb13eb2c27d963635f861bd9111291e1f1ee7b132b063b2c3ebcb15cc8d2e7d733fccc3142a52804fcd8676832e4cbed52b461f1b8c8f658e920c32635921305c353904a8b959b97a9e1e4ba3e883ff88e6e204126d3804913d45869f50fcfa6d914ad8e615ff87dd4c595243654e4ac33da957ad30e3e72ca163e80a17c6f83af3e4daa6f035cadc128d8e101fd8359bd1a9d95dbddd69a0d982dd8505502617bfceb566a2f872793fb93cb3280e7300cb923fe5ef7e93fe52a95a0cb6771a165d5b6f4064d1ad81416172e9cbfb907a883b24bed57f00a558b606d28f19e0c1d89bd95f1bb87e09dc9ca617e4e01fa69cda31a67faa8092533d9fa27c033cd81a984cd86434dc0b56152c30d1360bf7e4adeaced93720085ef15f88d715c305fe80f61d1345e32ed8d93b2468900ddaefaf95071a7dc653ee339168af521f02ffff77a6c7e73d511244a897a5b12ebf88ec63f002ebfd1bde72c266c8f1faeef45139d1f280b1a6dc3d28e26961a52def4f9231810021ab18f1e2d455e65c02a3ac4282ce872d08f54fcfd4f3bf569f0b79de1e8881c3e68a58d49f1876c1f26fb0f52ed893c9acc77f70bbafa0c71f2613cad169f83600ce692b283bd597e8d84f5aa36748832dc36ef41b9ed474bcb24d58b7403cb2fed3c54f38bdc7a6bca5689e02b13017337a1dbe757d4353a9a1d172ce3d56ce016f85ff6d500e2de2233007b83465c3d1e8383f7389ff9bf038f3d9c6f218492eafd4ab3921afe09495876e1f7dfbf12bda2607f49c67bb34d08a5d9e19e256e81884f6cc720265dc823bc907348da92bdd7ba06210a56345a8fe3e0fcfbb37191c294c8f41febbcda6d2a3ade6b05e77ea30963961c7388eea0e6cd3bebad21276ba1775651b4eaf5feb9709443cd7731c4fb9df4836ba313812a8bec90a32528d8085af68d42fc4b9e5c7f4889463c5565aaf885f31f1ac00cb9022abb7a62389df97bf5cf17dd58e5ae5e04a453b56ca9f34de3baa34b194bdc1d64e79033da5568bcc3a9ad53b69b935f2f793bec5bcd89971568619a57570eccf07e01987d8810989b6b1ccb204c345ada9400ce0644e5c27c27e025d5b23fc9d965cbded95c863190481fa36ecdd1cc23f584f2f29e4adda9589712c82af611e9ccd603d1e82b20871ff5239b5410d2b41caa2219851651e91a84151227eca15e1970e5f9f342226c7251186e74f5395397ddb4dfe214370fbab81363a52c9986526b1b923796f09a130f45c271659b2d3eeadbb89ba9937458e92ec994d793b6c60f708b31e1088ed36b0c9126b2369d9759b95dd2ff394b3b133cb409b243477c77d5ffdebc16cb8a1514bae7e09b41bee2145ef7537db01b1a8a3e1bc4ada560655240412126d497f58bf0ddfe8bd1eddb81c4855fa418d361ec3b63a09bf953956ce50b0cb82cc5190bc5386422be211ad2b38ef9e680608aa95ba3d90b6e52f82be119812135d549f970b5a77741204e874f00cf949642b056622c72d6ba051a068b48c8645f3c784aca44e9fe6471469ad935a5fadb64a3ff18320134b06481da97b073ddee3701105f8029358942c3acfb77f26dfe8a4e6521f396fd1971f6adc545af83ee5c754a03b00684e1f804b1923ca2f9892d9a834cea1b58d2237274a12454fc4b22b21418c669ec55387019bab890fa613fef3564395f764af311c2aed79b394f727de8e853f1dbcdb77ab37989612a23813267cf7a6cb48ebbec797b197f3cb6a3c6235bc69b47f447be24c600a0662253f07028d28846a917288486ebac511744e4bddf7667bf32a393938d9d1c93886de5ca9a047e7c5f25bf92943c01d5edd55da582781906f4b372ee1b83f1fe3c45700cd8904e9cb7fb76c7cf84599744217aedb04afb6622f1141d0d530272c1a262e7e2adb5dc8e3b2c46e46de02098e1c163c1adb008a3d119cf48d7014c8ee48248914c941a1a303fe88f1cd46bb68341373a75d47f092b1fba6a34ac547b68538fca53026eee0b7a20eea0beda15cd2c4a41eec6334579065ebd4dcd81f7f614fa634022c9d28b67f33fef6e14f9cca70043dd0923cc195856c3d3a72d4d3d46ffeab0c1da4840bf860e71773697ffa4deecee3dbf52c519e2626ad5307ed284cf4503427aaad8b7d8e7cf93a5e529a803e1f2919871cdc4c22cb6c60adb7e414f033ac6d45850a86d83ecf628b4536fc916cc00a47167516d33fb3db370cbb62219ccf441bd5b95a685d54615c6c842a3eaf8abaf8f3f140dba31e5207cf25527fa8085f38046f6fe840bd4e5939d43faad13d50745749c9fa2be07a26402c44e42b89e93c90652e185c651b1a89ea8e46fee3697e516d65ae0f4f675f631e473f1597b95a147a0c420e6cf0160484a7398b0f6025560a219c17fc7df288e4930dcc8903b739a828f12a6b45bb0fc3dbd6b636e474e033b857ed3a393b6d9719c45df7f1936bd6ca2d55c5aa4ba3a5336f12795ccf1a72d4b1b15b103ff6a6b07505b8b6eb2c283ad064ee0e8087546b8afe72f4a1c994646327d7e2b253b611918190ea9bd0ae89b2e70d7c7056775efe625a16a46b80a252d88b763b62b5cb40c3cb520e8ba46140f0cb024ce46363fb602806f444bcc3b913420a7f9e6f8f40e12ed80f63fdfb53de3788bccc93f6264cf7cf221884370801212f9576c1b4950cb064841b3141ca347a51bcf61bbf87d71733605ca6d1daf23e3033fda49e0ac19474e8487d98453190d67718cfffd71a4b0ffdb6dcc644758871d15a156bdb885b2afd1c9c7f9a4dcc4da9e5e65bff7969cffc341b3064e82553b9087e4d85c93aafc76128621358682c3066c17421972f3a0f489f0ccfc84c4dd061c3746d1f60b36ad74e5aaf43613f28263b7b0541aa019b6c1e4857c9cd1a7e2447bdbadefa01a71a929839d54593b54baedda0e1809fb4619d380f79f7e6efe6982d28dc77524aeb0ad988aa8ca9a7efb383d10c384c54429060d6eae3a945667ad4bd83f23302ca5518d9424deb47b2ba740b6c524d038ff847ca7b4b527486cb0272c4076135e5bf64e9c8e452469401a80d610c65915d5b96cca212898bef6819287bb7a68e1c3af47c5067a6dba66597a85520e03a8466d3b4ec2754f94b5d443b306fbdc90f33e2465efc3430bbfe195ef6909f5bced30b3a778802ca53ca70be8c55bac9a7027fad419b6b97dbf548bedfbe4aeae7536bc18a08d04c52d1d504b8a165910ef3ac756b80f5406537b4fdd1cc1f44aa06b26f445934707a52ab1cbcff66b1fe48a86cbc9439830610c1facc4c172c7be588daee088f898b1138249b4e0b925fd78753d983891c2dd9856ac4218e9dc3f554b0617bcb37ce5b32b35163dac7d5ddc832a965dcb8e3ec0194b36448cd63d714b3421162e6741233892db823a74d54fb95359de465562036681828a01a5166794eeaabbd1defbb6687eaad57e0411b7a528244c11bd9d461332d63119518bc8eb6a4114b10994164dbf7d9b4881917243d7efa35ff2ca2679ad00dae518e4f9c733755f6afccab5717746048d76a7fe47b7867f2dfed4b6bd63f280225bf2dd928e7e6b783a36f9a65f140a2a0bf84149b78dd6aaeac3f61a5626f25eaad761fbb863fa4a0bdf46d9a984aaa90d8a39f155c79452d9fcf1e6fc08222d43c12951225c880f983d6b28a53397c1dc70cddcf5764923b6285d6487af421f44f946706413f174f9b14a244c0c0664e216c8189a221f95b94ddf367cb26aeb488ebded8cc64bc6fb54d444a9cffc5bb478194399f35fc62bcd4f2b318ca6fd6f8743798581b48fbbf8e6de4c9f48f309ed6d0a3f131a47520dc96a8e45864f57cee8326dfb727660861e7f29c1c0faa33daf80f7693bfaea191cdc939747e293396ad0f0cc8f7e7496adcd259487a4d284b79d0c4306a7e5d4daf97e7a9c73e867144cf85946ae4646d6e4025c1d3182f7b051172a7902d6ad4d7e4a1bff992aef545fe9aa9eb6b6850091c945c4971fed3fc4f7014f94e95d7665f9bb2a379bdb50666edc0c402643ac1b89a3df28263d8844803097855a64d300f27a9e5209eea5310af38bbe5974a5ef337512213700c3f2244118ae533ff3b806919bb7860b74328e59e83b8179495a8b56e5c42654baa6cd4a23646d78b61a3de6e31a9be70c736ea4a8ce1c2c33744a45b661606bea4d972205e170024fb828da1a6221605bff8c0c4547e9c2e5c2f1d26a34ae8f998f47928dee1ff1817d296b39a846f0d879800dffb9de389f12c6518a427de43bc499c8faeab685b00105bee0059e1db0a44c15b4d227c05feef6ace30f6de1764092001054ef978a4e8f105cc79e8b7c6ffdd4aa5117e63629a00dbfbce7b87e699b0633fd526dfa6bfc3e460b061d0b90401cacfa6865ae433119a95998ac2c7bca4c062001b21c1b2ac3baa76435af47cc43c285ed619cf633ff9b82d74977bd4d7f476a9c71b8759ea813086b58873040f12168d53cf84a5f01ba3ffbf20fcef35fe9f1bfb513a4b12c1c38a8dca939f8aba092ca3bcb6dd9d6d61d0c4ab9867ddbda3432b8fe750347c67a3a2bc353ce8d76ffa2d972db8e4d298431ee3f69c1c4f240558410533a4db9483aa904727cc98507a10eb1b7702f55e4d580befa4e38d0a759a6a3e2f19a813d771bda2abd1e8cba2dff45ac0a96573c58522e6be90ca7e9485bbcc54d16b199729a2f548cfb909820a65f39cd2e70758b5d86b0efbed1df1d485da8df6687df0288673b04c7b1ff75f5949b21911b2ed8b259ef5ff7504d25d9d55519dd44545fcc6f7ee8a23dd1a727a4f1eb2fe7d18d9eeaef5b99bf8eaac414148b5811a39408757dfb0e3f61b7382101ef1c171fe95151d20563883bf38ae3775631a74d98648ebacf9b3e5f3ca21e39560f3b8c46c103fd970679e8d19f2ff10b9b7fdacd44227a5cdba306f72d531d6a292ebfe0940ab1792a4edffe647f52cba939b517310fa1d1ba305077b4e0b7ec1f81e62e626666eba3646a241e0e405f694790ed3d5d3f83dc1d8cd158b95a71c78528cb909659a82b096d6f5c50048ea2cdfee1fcf789dce6be1978f888c121d52359cdbb2d45f25111b00bf470ebae1a16e29f303b07981c3338760d2bba5a2f64433a8a71e6b4e13318a8c8448b4620442764437705cefed71cc9282deac186b505a9b24a92d5c709c027aecc2fbb578ef30a602279fcec4373045fe2af798f8e03c89179e0e5443505d48984e291a7405fc1ab735d625dbc60de0da3b31099bcff7f9ff49b7939c1cf9505a762d87222ea395bb8ae0dce1cbd78fb4faf15b313be262c8cb5554bff34c3795c104f29ceeef1347302253e20508f33a7dd7f5ca75c189d9371da51eb3926b19331d2b67538a65c1328fe1ad192bc518a199fd08029fd82eb2671ed70deeb3d8781eacbbf8e98d7f0f5fb81e02631fcf64553283da882923f3675c377353f855a38ccaecea1364835b47e09bf5735156828bddedf171f267fbde3b17b47d58ed179c1ed21d87c1d8168b3fe2b1abd3a1bc9466db4a7698e0b302c89834ab1217cbd386b6259470327ff67bd892cad9b15fadcd7dab732be194e70f80d7205c6d7f73bbc3f9badcb8c0603e68717a642cd804afbea9ab9ae3b3963db273946f161f40440ac59fba8869d47da297835142f4ca1b22b1c8d28a365b8b97cf52cac771ce85ee8b068169654f83e8f2bb6f5b6f0b5a119638cbebbc0115032bef5b919248b1b0db75f8c83d432c73c55d12ea365a6f2d1ad6fec5030b68465a5d1004ddb425f26290eda808587aa494c58bfe97779cece6b3d23f5dc27b9e19aa2975e5749ba6fea63aaa4a90a265dfcd1257abedbb49cd5c456f019f3c0da8d3bc2356750cd5643810872a245680b2ae7b7abde70e37953f15a5e7296491528c7ecc2cb94f80bfeb507e0e965098e3001e893a7e30cf7496018af4c1a65566d25feab987d6dd5dc8fd3589a232f9903f2c2240b960eb65ca5a751cf6b09b0314ea008df49d47764402b3f4c515e10078c3d3d22fb5d9e62f3c726382eaa39670129e6dd4824204160387719aa0e6f74d2395f6bc41fc70095fa8acf1e3ff22649b492f11bd35832748ffed7e281bdd0db0d01463430e485c79ac2bae5cb06fcbd41e9759df9788f6032adb69d7ee0cb2869be9cd85b84ec4782db87e152fc47401e674183960f3b233365a4e534f808a077174397e59538894c2b3ce5cc4c18f93b843ec481568263695c6b20b80bb96fe4f09a4dc3a80ed4be7ce5caa54afc96a0af49742d7e823b7ec80b68e531da076e5c1d7a03afc051e49952819b7764defb303a1391879d900e1675e5ba80718bf27607326f35de7004d30bdcdba1a95d82b0bc719f3f8bf441708ce38f96f4065d918cd906a98ba2ffdbeddd64021155c4a547dd6f9760ee7c0d5d6cee41857a5403af800c0493531424320b7a603b17c2060b2a16b93501493c24a5e0ffab35991c24941cfc4359d3350fdf31837834cd71d158db93380a321d1c1043d457819bdb559b907bb8ec1c44a33478d2ff6e3f429b298c17800ec6790dc6920d7ac84df87a107d328a81e68eeb396a03203efb821f096d74241374c2a869e8e0bdbc56471fb354809f398b9a83dea9848b4bc242ed40c95207ce382c265c1ebaa64226ee1703bf40cf9bfa5299a6eabad9c84c3d760197c80e1a0f923397bd0f36cf05c39718473265c7cd03717a41efa447e4487115df50be3d747e06fe9a2385b4aa37ce1bdaa31132caad79f0c51f89dc59c8de4ca4f53556db965a96789de0a19bed8ae5631140d7e735066575b5d73d0fa9bf9d58a8b831b621afa3195ef1a1ddb9ff97bcb1742f63ccad9e0130106c88b3f119afe0d151921d571fb889afce12e836b9035e35bc69ccdebf631fd9efcdd470367d2c097a10802d483559354e920b1784448148f6ec77077f87972d9c84237e8a5da4c72fcab7f0fdae611f7c75e04ba744dd773b0098a3d0dce5b51383edc608d9824a04b88d8ce0563ba1618d370d2dd29e7c665d76bce297efcbeb70d936c801d2088eccaa6b29f4ebb92f553449025fa42bd2f5abe2770601324d17f362ff72c59a3f0f03a8e7d416385af61dca6593b2483b56d2c9636c96b28791e0313c9f13e87d47e67481b713e567906134808fdcc1934f019a7811d2ce372e0c9bf7a45c7caf682464ee54b451bc15caa08a4d8633686c52d51ddfd85176eed72dd668a78f73a64fe9bd337172938e24d03b685465f9c782a636b07d767ea68b5386b54d93ca49b018ba00788fa6de4e5ec6d1512c2baf48f3cda9232fc0a4e3e55cde255e6fba85d5f1e22e2b949a9577434c41fe780d9291f2316bbeb9ed6e47ed4b30016644a949b358c5bafe0e806f36790cd4e0c6f312e6cbcefac111fc5f4aa1a86e5ef64e600ea6683dc9e77c970a5a31705939509506713ab23c337a1fd57b1cf30c22a5458caae2ac9c29be217083284701bf5f24f4969635bcdb92829f97f6e4bb467834583dd4f07f59884b7e79c442f3487084c627bddcb93f86a0c25fb1d6f15adec75fd96ca1dda88c66ecefa3240324cb7bf55327592cdb24d21272fd54184342de80985a84d9ecea19b5a3ed11bc1534655d04f9c53919251f2b2e5e2ebb733b4f024d205cd6f572fffb03c28a165622ad4fbc14afe21c375ae8152ffc39fdc57fa9506d91117c6bf16f1e31eb220a31d9ec4e9b882e67c0e1793f21a81d336fe5d37f8f84e959ffcd67022c16125b4ef15b8233546dea571172c98b10fdeff69fcc5a7435f85765e96222c0f8c9ee3518f363fc114ffa972b47877c5774d9ed25a6cdba5ee70c7bc958e3f0f91a142a27e9c385cd64c8a2d932e08d53696493f1d9574c014f2241c50f7ae054b62d7b05b1c44e66bf6e8631f146d4ff1dc65adefb45fe47c4cc9d68c39b2600e8e15af9d8f2a3e25f1db7dc0278bb2ee6cca661c04debc5783f9418237316a579e40cb76466402a2fb8eb0fba304303981bbd8ed27b0df4beb675ba0a0339c4181a9c8d1484777960f51eb13b5993371a1689a6daa50ca74b55c09c0555440ee913b006529935684090ed5a7c30fcf3faccaee10a7befdda2bb59d7b6e4157d5e9232f254e13db7c4cccd7b2e40bd83878b0e9344088920c42de7b982bf7af357dfbcef13d39346837a8fd69b43be55e20e4b65c5207474315ab851613c71808d742531bf1981fb03b20d4c1c59053fe3752062d26c3400f9969d5dd01121b3f65c61ead6426eac495f6eb3c9b862ba20883c55d2b5255e143f077bc2d36c44b8d014d2b08c0690ff2e5eae80650eae2dc3c1d275a48dcc16f6cb4788542a0b46c18de1a296c07b16d280f6f4c73cb690dfde8585c460085846a332686510d02c81110687acdeebe26167b6932cfcb8d432287944ec26b97c38bc6d6572470327faef9c80d6150f3906b75c27edf385190e8d396c6c5fdfc6b1b036061730b171b72002fccbf2fe772d73cad4804dd10a45a066f9605a7de0ffdb5f9b4fbeb174405a2df0b9e6aa613cc2ab9f53ddaa1d2fba71b629e3a74f575af89945a678aa3090682d04380164cc25aa0063583a15210c611f02d1c4014e35147240738e6080095c2dc0ae2e71408ff60168e247d9e0ef27e63e659f1a01d9edf77db19b6b9370c80cb07de9950c1f607484f394fa2103699c37b695f80eb69eb92df87cca48ea808b14a50edca1458e5d2e080428eabdfdbb10e2ca4f1cce5f1f02b59a3a8bca8fb2df1e97f694b4e70bd14025791e72206f622ac5d84aea0dbeed16a495afeda3de027c0f800fd2dcccdabf9c5a708bf3ffa5223d99c2bce97551fc2154276f7a0d6b72939ec25e45484a8b109fe2eca2baadf07b1a412c2f73f1ba4a9c8ff58b91db2e81d1991b5964ce3e37ef2e79d96ca0168cb012fe93d8c91f617203d5b599bf3fc835a30d712959236e16e6d06bb0cba3c7b467c3eceb853ea18e5f672ea781bebe537cb94e786485f2d8eb6a8de92b2bc4bd87ddc934693e0e774c381059557d2d158fbcc14a7a7b72cb21c6523884d8d1997c7deaaf9fedc3ca8d41db5aa5bfc8e16b5dda4f2756acc10a5771def9534f38318bdad6cd3962f5febbefa40669e3548513c102c3c23bf80986b008a688c3215de1470dbafabf7e9320759803dd95bf5d0c272dd80828ceeda3843c4e7fd2f74d155d56643c00159f996fd7e1a4db52791c8dd2019bfb88385285fa8d4535366c8f74c6e3aaf735965551853b1635e33c8a5d560f77e695900324b47e83c787f13413294147d09b8451a1c74bbdf0b5b73954bdd948bd7b40eb8b2f64f4462cd1f5d0aa50a9a256e31970d2eb1c1e6d64f77bcba3744580d0c0dea422974f594e0ad6f4b59da3bfadcf671a28c7bb5f5272b60da48f9e18ccdf3b41546f51e8088c002898228cd7b9e3dd2192e062475c069d3ee215a4912a36d686326e46782d67531f91cce5c993069dbce2a206ea46434296a5e0be1d76914f8079b4b727c2d67ec22b7f43ab437babb03732df3bc8f979ce49a605646db7ed4dcb2c689099cbb2bd936f98985c096a94156d0108768384b9143d5f46a4eb3f0b5bf02b0b4685118e86235a150309b191a532fff7e471c7f24de15e1cb003cad2d8e39bb1c968230440dd05afc0ed5183ca79529eab312c5e1805fcf99a09818c912216f2812550c4e7ce0e301a9aa0e4badd8e6ff6f8fac526cc2d1d5a628f3deee0f9803f9a8e0473353d31cc3edc630d1b1dbf0ae230555a0f8909615a04ef210e47b5648b900d19b8185005d0e5aaf7b4ce9ebc4cd0d6e214f3efa76671f4be6555213522061afb8f9be42253de47c667b3c719b2f034682af81407e1523fefda7bf10012b7816f49faf9e6052b2e238c0b150f04182559476bd2f3cf571c1b4256a28d971c94e5934f8b048ca084af403e75965cd2d04eb1e7e516230ca5950a213cadc11a75157f4fc5d26293ebc876eebf2bfd2269e4cc69a78a14baa0de0e3162e23186e1ef2cb11e7e991a9106cf7c53c1965908e9ba5ac66b0df70bf96c961e967dbae527f9a58abce344782ca940e00c55f9af769d166c7bc543780d32e424ff41119f14daab21e6ba7ec9c84f79f4c82f3adcc7a6174d8db7d8b0e8edcfedbfe54e90411b2193f76f1cb684af804fa75e725d93f2983dfeb2e1ed4b701d0cfb3c77e83bcc8d32c3ca15d0dd87ada6c4c840c7d9136403a8a113c9be72640b12c745d4ab3a1c71dd83965b1f979999a0ff8ae5aceb0e19069dd529fddd8d59ac30753f44a11f5b7ad2ec2a652be874d8e454b0b04e71fb62e507c4f1c849ddce9d123ef8d5937fe3d3999c823095ef6b7263738d28fc987885dfc3e5b87b72c6c06684517d9fb73f12129bd3e23dd2f4229fdaf997bebf9420ef6983a18190f612b0acbf093c3fbaa017319bf3bf4124ea3a5d9e028a252444d6cc5515c2fe650646160b602d7cdd6012ec75d455112873c00ea938c8e8a9b24ab7a8a3a6db67e306654681656ce8dd0221786788a1aade4880a337f08d4fc960e550eeca9059dd539d182ce6e1d1abc957c1c09d1a916ba240da6ddd9b37b4ce33fb07c4e92408a796e7840b6c7abb2df0bf459726326d9a2af3e82a37f7fd3c6d249edf90df3cf3b0ed1894a8191b8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
