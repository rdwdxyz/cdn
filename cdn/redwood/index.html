<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f74577f3f3543dbb8f8d0df19f7acac2c503924466a768f93a72fd767ee6fb04dd9ea4444ed5f104e96e6c26b952126ad43a036c7a76013790bc9232196f458b37be9b2a7cb32dcc0922bc97c8e177e7649b2e0977d2c5dbdcd7caaeb54b84a97d7eb63c1c4dd086f185c181975f7470ef42374b56b19e438a1969eadec474a0930c397e4999002390c6005a487f72490155123f3f6fe4dda750aaf037887b09cf35b7c362e9d3dfae5c0c8ad1bf5dd41125fc739c57206b8c2e4479f571d61a1510a7392115c1818afec4074c2ba43e458624a7310b9bb6d29f73374019109a2b171a4afdf6d45ca01a1340697f0c46264c0cc5c3e3b048d2450509d101a222350664a00b7284501baa856b0f2bfc2186d0d6b1769c1cbcc4d4b85c9f0a1b4d4f58af393d3497a308d0f2a4f9b857afb3e6f05ce439b098b3bd5f51d60f31d09a0846aae0ae2b95cf16eefbff37cf4567ef284e540ba6ae3616ceb0155e620bfe2b224e039b6ac5cb48871e7f1d344541de4337578d5931982b46c23645cb5fc167d26a611d010d116b9ebc3e0c4126249cf7950b2a895f775234098aaaa1f12541383f8fbf1cc1a09f762ca3817c3d428f5c62f8383306f9327ddbd7c9acee92675013ca74480457b60ac685b523f3482dfad7c8169d11839185f77c80249f474db183d66501aa8600535060f46ac475dee3adfbc92633218c9d5455bcd8ca8c4cd7d64e71402ef09d00e00481567a4f6f0e536e83e2d2f592e48ba7c783fbb8d2ade63655bc03750f457d5f12743a21c1d80561d26f9b9b96edcec8d90a3e228bc3970e1845b1dacc5790a5b9c505465d7ae8b039bdf688cc42ba4e1b422b5ad4131cd2e31fbf47f83ade288982dbc927a755c56576300a7d1e49c0e59eaf1f29b3cce6c1d381af9c7bea19ed103e20163158b7723050fc1fb6db1fd7ccc20d1c9fc5548fcbf6eb7c49fb00b32edb4992643d2cb677d68917c8274b3beb5bf7920509bff54a869951b0d454125911e04e0e856a466a88f53c9d8f9082a88fa0f0c507a920ae492fde064bf753db07cba7ecfe1b224e957bd513adde352125293fde33e28d2a5969e5af79013c273558facb776719ae89688f44338cac4dc4f4db20e6b5b51d6a488d8e05cf5d0f5bbe4e7c80cf554750f04d93de9127ecdcb873e2330e979f18410d9e63d58509ce7c2530ee84b9d673df1479cf950c8ec42480f550f20fda8e3d26218c1dab81363424ea1918c984ceaf63b066181e6bffd21b4296ce06e4f9376c48746294eccaf02fc4f10ebf3b67212eddf9c6cb241277376dd521756e6dfe0bcd88322dac250853813f8f92f8b58c452dc57bbe29133bca0330c4f6e73d237d74d2c2cd648b225ca53c92783ff0f894de5264abd091a40a01fe4b2543098bbebf224c2177430edae008744c00d8d25e3d5adb52638c91fd73d50fc98f1e0c05fefbdacf8fad7e43a2de6d43761eb0c2127aada6d6b3160a03c853af9d199b3e16a4ef5a46cfd6c8ef01d05afe8c8196707703262abde909435d5a012e29761ae75f434ac98c270ccbb99687f77cd0280d8952b597bf39860a8bc0caa0f8ce6b9db434fba8a8248e69bdf77d88241fb71b65b06af46b96983d846bb33bf444aeb7d8a91755b18bc4475607bf50124d3c770911d3a49923e0694385dc94f7704ed6227578b7742c5751184a48716cd1ea123dd3f69549f9d7af7f019db67bbf6844420e8d72edb7bd81641ae37c39acd2ae414b8d1951aedb0b95995f526f46c34d098dea2f56e41df1310b9a8a20d1077334d8045b4313223cf031d653b392b57be5519811354e79d015cdfbed01118a8463deb13404d407532788978101621af9529aee27e7b50940136c21cee724982adf6989710cc3eb5267574d98a46f93db1abdaa98a4983859a2d27b1e8a36a1698010a3441e63333cfa2e5823b391c1ca377fe51a9bea38b820d5c7b85b2bb3dbb192bec2552b1d8658dc1592da0271591baf0473dfb7f71bf4c47de64a412059528a970f94bcef74ccc5a9f87beb54fa906ed1c5b66b26509c38aebd85a101cf28da6ac34c52b94aa7b053ac1bd872636efe0c0ee598034106b06bb19270470c3363d302e21a649c07686d568ac2c4666334d427c6472b21a4c028b390b1f61656e2581eacbc4a3a5b80f43771d8bcead2e9e8e6496d5e1cb01c3efec3a7c3bd8c11cabd27cba7ef7a65653016c87525733d16c6d0d64c73605737f8097862088e4c6be00632178fe9fa72a0978d7c173f45ef88aef4d9ec9a98f1518e4b4f267cf895a272cb62d4c436b35bad80c864cd248088deebfb5001c05881fd6864b720215a7c8d00a88fe9d28980277905641b9f40bc9c5b6aaeaab3787cfe16a476c255aefb8bfd3f8597618f1156859cef81dc275ec03cfb0e5296bbd1f1733854766a6a30ee846ea973ba29f20ff5a662e7c00c9650de64295175d2f420e1cdf543c592023d77aad7fddc972a12ea520f7f0f733854e21a32eae9121204d8650bff22f96b893c9efa3f868e2b2a2071697a2216495c56b80ca352ffc70f0104bf799cc12f6ad8d62eb19759cde87bd7688b98c8a0c78ee6fb3309cc0f7a352f340d3669ccaba45253f1fcf7529514e02eeac4592dc3d6f4bb8287e25eebf2274c7ce126b9ff0e6c2a4770a72ee9ca0da4a6f7ee87d3ab5af23a1d4dd05ea67544e3e266ec938c50ef8100c59c3df750ba55288d1f93db219843000027c57969c58dc69db6f526c2752735bc35879d91a576cfb6c269134930c405303edc1fcc7922f31d24445c6e35d34fde775e8401820897d195241b4ad549618df105523eecd83b108b8ec373b8a156c0b5fffc658ba6c92a194b18e5a55bc972e40d7e31bad07fe37da498a1b14dd3ea18fd9c0866e88ef3fd163c54db72c8035d0eab2c1dfa8bbfc9e807aa3f88c58675839da54abf20d9daec216b3636e6cd27e5065848bf9ca6325098849edaff2bd1d2c8e9893533a8fccbad7ff250494e5551ff020c74475b5b3430d733694a0ca7810a35534fc3a25b3cbfca14f0d6f3f59484c1d30cde6903e85b45f6544d9a2d28c980e1916aaba81af1e2bbbcd14cf27fef6b45d01f851afb41ed6e4ccf6a9c7da7b8c24efc00f9f5f91281ea9fcd2c8a41455be970b98770acb16e0407cc9d74ca2c8eea33502c7fb7af7e6bb41e8e617692b2f9c4a6df879710f13b07582a743163e12929f6f9c5cc5a2262456e5943c8a2cf75fc4caacf32b0e8e4dd4c3162f0c84243190dd790786cfd4b6dadbb116c00e2fa6c01c61ff313e8988b65b47c98c1306400dd93249cf285568820701161a5079cccca1bb386d43b8eda97bc7293fd88c9e12118661e854a95f0b620b2f2dfe150c835c96663d89976e623d98f874f7b7580a8d906b05285e96a7e6e1011aaf277a969ab1a18e71ac45a9e882a85e553c08212d396e8fe7e5395c5b177f3d4a09c09f660b1055a86888a17da87ecff3554d160f679938cec579c75bc4474eef304a225f408962bf9127e9d9dd6fcd203b4d9f9cd89c32af1328a4225adaa6664a100ca47bc232ef4e0b48fb2fd0c124b75fd0889acd5092d46a8b866f6b3fdeb07e88a554b3c0dab05bdae150ff55f9e7eba58a70f257e48b76a1066f086dd2f89c2b995fd3c80e22aba68ba2dd135a4633c68ddd1a3316e746da53d16f06f79565e1381cc3944af9d6e88a8e4c57e654504f66a674faf05409b697fb382c8c2498275ec2ab1f4162fbf417b2e755fc5b545641081ac4d9bb6133ea86055559156a096c82bac70c59c9bcafda444f206374d6562e2016663298f428c0d6b96e6ac9c02793a7fcd9958d6f74101073087ecf593308665907210a2ab933f11e38102152c8c662cf333f71251cd24c0d0efefb315a337db77dd405a2db9b47fc25f70f25fb891ec04ead6b4d43dc09a4675b70443bceb52654c014baa963c38e432307d4c85a253a322bc8cc4e8de352da4630f59e0ff4a582ecd50694a5c334855e655df9366f644f117226f471d88394316548b1b480909730fb46285f376328f0e2acbf897865820f01b03179916ee38717ac809d873db93b4e6cbabc77288454d23946dcd4b23f07f85bb5415b2881b45cfcbcf41f8a056b7a46fd277f6c83a98d3aa512e2fd5990f496f5f9a1ed719a3795ed187a97f1cac36c4db780f1a2dbe3c76b26367bac6c867c92e120d977de83c27f914662a313b1bf70958f2100ef5308337675526bf37dfae86dd48015aa497cf15972bc40bb5cdd7045d7853a17dc815382604d676ad7779c642c63305f5dea5b951a478dffb282842e8ff047d1e056f3191940edd6d7b72d64bad99bc9bc0b36ba5cae1bbcda08641ed499a1a51d904a74f206042a2cc65d224ab6cc4aee9386e68ba02c4181bdca165d0a8c91b186053ce54e8ab94b5183ac4a6807a665c2251fb47db7eeab84c9d383c3999a19e2cc572c208653642fbe34596f45fd9bb21cb5bcc0bf84094ef50583034ce2a99fb02f94af3186f0901c30ed34de006918818a796e766de64dc49fd9698a7211f4e0d3b7da8ec196092b4b8638ae240581d083aece7f51498397f57dee5e725eeb8bfc2c131232f5493acffe550ffed23623cdfcf1d2478fd9bd242e2d7725dd81e3117be490b6952f0d7dd2687580cd695e4ea31736f8a4d5d087104a67a279957abb52ae421b80bf4d04a61f2d88b8f3137def19e34e9d1f61e80fbca01de37f240f746392416671a98d7c61abec686d57cb8cd650bcee0905ae80a1b675dd6ad26a98ed7732bbfb9dab27852c760ac2b01ef2413cc6d9e1ffb28881fa9071811f97eabf6af6a4547188d97414e5a17a720b4cd0294b57b9b0ddd68171506d88df54ac0c484d573b29809f7ea0f06c06e0af4593c2e5b37b168fbb8e8f0afa7a05be0e976fc630ece35cc21fb51fa22e7de48b75d4787f67db4f7948dd07ca60033814213a4b4c1a76d760ea1af6f7b8ef696b66543b522d56ab3fe076847861871e6b59ded786247e18ccb816d9bffd9b22c571b441060e632fa1c5c28ac2a4f6e433a72c57144594a9d75efe25e0c940f3b1f862200717483710dca5da9f8ba6f3ef3e1a3d7ec2e3ecc4cd1a8e9d52152636ef4eed1cf99b25e95599d217c658ea5ee7465ac2c977b383ce2d1eef86ba84c3e79727728ed4127b58e30b5ec7f3b3dc7141e2dfb245c31b73b1162493d39d896145a7ea86ceba6259b826fa13b50dc110fb2084e6a1be230d2aec2c99a8eb5f9c2ddd8462ffddfa7f3225e69ff22bc58d47eb771c4a12f5b4e9a28a69624aa3983c78dfe7a4ca4593da273f6078113d0c27c2f02294a739241aae583c6b64c26ddc762dedceedde4c4fc034953b25af24120b0b3c98707f8af5e5467e630cb9b3bbb579f66b8026216ef2ab016fea82002df5ddc9793193c73395b1a7f691fb2173bd6b34c3294836b67b43b29243cc532e46eddac0138c23dccf9dbfbcc5ec66dc130c707fed162a063ce6c9a18c6fd2d80252f0218bae19ae07240ae9223d6e791548c59f4d68904dfb50f66fc9c463ef302526f153f8de4f00fa04d8a7741ee0fc1d72706de498708825b1ff208f55178cb7783219b0858a27853b2620fe5c6e3bda721c760933c8fe5ec1a5be3d7edf17c3ee43f85de7b2e137bd464ba212d9dbc25d70368d67f72f44aa194f85dc870288ec8923c2274d63aebd944888b435f1414a28e310f1f02f8565bb50a9bb26bcfff80399355e2a87a5caae36c56d2a2d94070e87d4c403832ce643f71fe49753396b0885f2b8e178693c1076efa515b47acd95b4c4b57ab8a79ce48c5d93f1a4716838a5453bcb83417e348377e6c9503b4c66a2863f8a75c0d4559574964c6e29754b2c26dd044a00dfab5859869f36b41e01c45fed902ecac4cdcfadb507bf50dc9438a9f6d2b67be2d97e8f285d4c856c27f3ce8ff1b2ab02d42f7ffa10c1a9c5ccb6d262d396d1457189435fac2f4f43c4e9a9eaa7e732497fcffc07ab26825fcfd80f59531ad0a82c1ea4e3c4f18a1b0e99c93ce1b4211cfa22e6b61e64cf033bdcaf781389517c8bfe33a82e221d4682051084828fe8f2fdc33dbab0a561d4709332a3be1fd151926aa161566bd2520104499300a90a57d19d5c267a5b77c04e74565107d5a4dcf099e86f54689834a7bc59b6274dfa9820009ed5577b2920174ff5c40b60ac214439de9c5baacf2a0f651e4018307abfe866037bb886f2bf968266d3fe6ee143462543724869bc273ed5f7d9f8f2bf57ffef6f9851f51952d1ca376a59e0165b9f31acb2c8f589cb4b896f072985de97ca58bd8fdfff2127c315685f204b01082cc61965f5694fa8d1a4dcf1ee5addc99104dcc6364a4c250a06d641b7686931646fc09449226719d2a0a85b696008f6d5f53cc41927a7125ec863736c6a8ceddfa35f8f8f114aca2f0571c594141233cb8e3b45a5f07b3e02095de4cb0ed45ab6826e600a89a766071c26498cfbaa9011c4d912b1a6521f2db236ade402f88c1c5169bd5998add2293f5e7c0b9933fa00507b5213f951a39fe837bffe069fce6cdc2626c4b00048c54ba92dc86eff77bfaf3ff0eb36bb71f421501ac176e3008a99af86606afda20367a2d6fe1b9bbb81027e3d61e143f6ff9f4f289be59f3c356bd3f1fd791c0978375525d8867ddc2ecf607357b40aba8413bcad62a3d6b0d9806571f5b46e0da0f0e0133a5df38221b457a9fb5524b7bfd62492791e43d810a243d790b7bb9b006cba9612df93b87292c64d1ef5ac97483b0b468405534d777ed6a8263b6c3b82087977109f9e18a6de2ecf238bcac7ed9c2a3a9b9aa1c6f1d340f794f1c139653fb172d656c694bc82edd60fc5d3e2bbcc1c37b87b608c0ccc47feb595e63f4db43d4204a124e09992746f6c1ed9a836e6fd089f48fc9757e2c9a7ed5139ff72852479dad57c7d2461972aa9b26d16eab7a692a8ccf986e89189eb2832210d059169bb1d2dfe07d66f6d6410dd04ea681ffbe142a5e6c439e505d799d8d795d50679e36dc2631b5def621e50cd55bc9831270a8a1b32b2b77a573d3cdb74d717eda08e5de278bdd8071598b320cdc4f2de7335fdd18b0ef29ac94c6cc837083ede5f980621eac3530c9fa01ab510fa854d4ebb7adce961ebe8e35182be4474dbba5093e57c4f06cfd6895f00ef0c64618fe92f1dbf146a825d0d6d897bfd45781eb0ec3ab26b4524c65f3d29fd7352885a2a704ee5c6467d9274a3540c81b073c97a3b882598d4c756f3799150d1e82cdf3f820a657dce783ff30fbac80d83e3dceab42f1da5e9f6576944d474fbeec7ddf82e0cd3b047a473302867fb4c0e5f828eae5b7ead30cbaa060b6aceb66ae4193907999cbd278c479297b4af3621461166bcfe10ccc81f222794845c62e6aa4ceebccaae8b7ab8d353850bdb816d1429e1a375699d5c45639d3a2e995009273d2dbf8e43456fd2dc0b072c93d6aa7de77e4f2092c60e393169d6fa020f089b735c07d881ed876000bd4dc9c4a9ebf51567d10a2c0159179bbda39d384cee46b36b873a6683c0f8f2d62e22789bf30a9308f92f13236289bd64c4d4b7ec3279a7d3c60a30d0c844c337e214e66ea13f9b0532b767f38e9f4a54ab83b5d45b0f5e5eba7d30ae414c97abdc7cad4f0c65bc18dc61649f346e442d463cc5b375f5a397c62776a429a7cdf4ff3a8118326be764a5696d4e35f43965554d556e5cc72979c913b8844a9d741043b0433ee7bccde9820156941dd391f0254f3cf1f0c5aee26dfc7bc64fd579fd3108e3d96f188067cd1bf0f9434fae058ce02c685e15fb9e78ee14c7c61f461f3715fb7c8a97585a81ab63094b1627ff2afd0003f4e4f35cd3850ff85648de87796bfa31d47127912b41fbf19be061de88b227467f2b1853bfca84c4a03f0e435e06c7ba007e7326a63d09d3f16e9acde2058a87e1e04370afbbf2e09969228f237bb0a795fbcc62bbfc38616cb676302515602bb363515d230cdf95c37db100a0c7cb7e5be2dc4274437440d7ef10046895fb5edf42048f3b3faced12f8f37511eb1e9bbf21083b87ecaf08c6b6656324c25c5bbefe9629fa48cbaa3a5af5f1d552effb1ea78c2d1e0e5aaf2fd65c5e29cc5d28edbbfee0e96a8266d638fb03e0581c656fb4b8f5b6b82a03edce0ea1f6cffd0466c2807c9d2ebdbecf56071e7eca47bcf343afc75da8a5dc1d71134707e87a633c4a468edb0e62ab93b75229a4c68bfa36945da34995b72b00cf3eec7f58ceba15c2e724eab533ca6fc3aa5b083fd8caa726b4ed8cff48c0eb472b533654338593176cc52c5f90754c93e9031dd808dd16ddd114dfe466ab798bafcc4ac8b537db4068b81b391af86834b24790b72e5bb1c26386f1b68a8e7921457f61717011f8846ee5956d1e4e81fc8b3df81b943656dfced9f7ccbc711d731f8db30afe1e3809665d23f1610cbadd0c6f09937c22221fbb63cef0753ea137cc2418826e02d470d1177051f31bddad68848798c73e2a2cacbefc785f04fc2822a245aa7f6fa5c7ba169b72f7c0b72620c292247fa53d2c79ba96d4931168240829ea91884f727ac0b1f3538d73ac8a3d3aeec8bcd5acd2978c3a4ebfbd6ffcfa10ebdd51a0d13543a9052451ec620fa0fca2eadbd9cf101ced3af1cc01824357f6ee3a4bdd06ea8469e714b69ad8a87b20cd8a17772c1c8d46ed336de00e86a49e1db59e3783800ef02f8cde9a23810cfbcb704f7d1b34cd327d55d04b7f7f25ff883bb23328f29174ea5029639795ad609bca59470e4abd70ee73a05dd0b5400be94a8c3ffd47df13491ad41acac12f0e01ae7c78f18b060d8d03690a2c6d7eb779194b61acc93647324271d2edde5440afaa747e9b4155e94c88abb6ad93d266bf186f5362c3cd461350afd039a9ffcebee107162ac2fe0741e3fa177614ade8e861bf4fef63351402b6530f73c301e48e5af6a67ec75c677f78143020eace186203e08973a3be5639ed1396e0234132beba52f53cd0228e287dfeb73ddc5284cdefcfcf25b83d7e9783145b8ec06bb0d81de03c3b77c62ed46c4a83eeab06d0e55588a2b7b3c91edcc8b18219a2638da89f77208134260e20329c1e212bc753d70ce4ce20580fd97f51343522a30ea2549aed6e6949f80076401fe95a29cbf92b616e52d7a1bcca639e388946ce33ee593cedc38bef8a65152d1f3f06f98be6a769ff4c08bd1dd8b05fe384b8627cf2ac13d5af2845091680b6ec1932a6e88b9487abb128c3a1a18c61d750f7692e44d8cca5501a88ed111c8b5691640486bd806ab9666fc74de4ecc8509c4138522c058f3b66af22a50044863800909924a35545e9965144412e9c99500cdf7d96b68e60870f05d310fe931fef01ccdcf59fd2eab0b86eaec9ec6ff0041b440072a1d4288812e062690fd4637525e49e432fe4cdbc8a272671383ff3a381454f81b014913f44769c87fc4f8c59efb5b74c9d647daa62b647cfb7955f18d19846eae39b7f539be14a69ac24f3b97e6d6d0f41a5dd26489ddf8769605383a8d93f384704d9d753f238cf19ccb48482752965cc71a27c9ffec24a3c00e2686afd0fcdfc7dbb1215458cf08a74d325b91ba1e5ae08e9af5e7d252dea5a62c6a2c18b7f5b3c94c0d982a3ccff974a4a20d341932c2af03019225b062c33291302f34a2e6d81314f3df37633d3683e9b20215729347e69d896d6daccdd40eab0f8ef7ce456589e6c83aa761e44da771869089422a2fd4a352fed9fe0dfa01a0c499ba2fee24ded3dd66184399f79e630ca75ad7e4089cdbac47ce800e6650e5cc336c6bf9215877bf0fea794860b14044a05b38657f104d3702ea1da1f09eaabaa9f587f136dc83371dfec2039e138be888bd20395996def2b863fedb735af5e3ffe9e29902722ef43a0ccd65dcac0f1c8aacee26c6be12a657588bafbe2f57a2cc3efa0e2fdf5dab409276ace02325f2689b9de63944546fed48f111aeb98042150ddb80c32ced1c860edf39ce8d6ed95c9e834d3e5b3f7db40fa0a388891f2c8bac5c9f0e9a59e94117293a18d3bb4aad7bbefc140cce62d234ec77286808b1569bf901117e943e57826f3ebfbb4a921b3cd0cc0084965c9ef690ff13a99aa7e79d93f2e7ee542ad01560c685784205e73fbb8e9bdfa03d81a6873313105a7ed2b10f48641203463adf8f6d36bdf53e083b9334a445fc58bdb83166bf400e6262a4d9e3240f32f64d04eff67452817796ed79cb5500216c2b63e038df78aaaeff22a3af787ae366fe6717d6b18c6de05135f051bf5e39ec1d4caa35b9b6d1ff69fa3e63fb79fa8055d946a07719264e6180dd449f945bf4670b2f0840811e4195f5f610a3cfe6c70679d0e94b8f0c6e50f9e6e0841c6c169605d8151c9bbea66b01248d032d78467df3fee98cf3f480d3966963ea9d5b0b8fe1d421bf288fcf148dce43bfbcad9ce738615a1e4659818a8939fec3d65b48d1e4570dbbceb1315ac43bb41e6141b62e06a2ed75780bd5facd99cee1c34b304d077a9412eeb5ba9d5805bc1b88653dd61e2bda73aaf32cf051a9e57080cbb09911f40f81487ebdc2cdd3a5436aac39b0862185ba20468f476b839986b3956a6372ba053ad26a1f6aa3b97388b5417aa0061709c476c7c9cfaa782289bcf8a371ef7a026ea2bf13302c1d425862323db32eaf60e872c70648c095518240ec69c4f5d2d20962b9e87d4e83d0da6979621805e7ce200ed3cd863689f2631fb41adeb0b5c130e7607f213bc45656ded2bf72648ff820eb48d9d826450957f355b0b0051895af216d8c5ea8518f6afbf90022cc06885485d6444e3d982cec0c96738dff5446ecc600175df368f3a143c5b5551a002ef0180ce35e8e0ded023bdafc0a1a1dfd74228c26addedc2052e78fc4aceda7bf937f46c0e23a0cf702b4d2c2ffe464ef0d57df2c74249be8c8a58fd5f657ec92a2fa49997b4eb5a839f27530677e0996e01a0c714caa8b2e990a70766aec120fbab13b0dd3ef24b684aa03ac4d19a74c64082ee031f8a029cbda56b11a29399fefef0a8860809425876c830531dd3a686f4aeba23968e0eb8f819f4e11e6395c188530808eb4381589204ed570b041223723eb3bafe26318104e64009b9a388d7fa8c105610a4287bbf1a5fd119def6d193c9085c2b8e8ceeeab0aa73a7558a89f29019ae10bbe0eb3f281595c747bf478228cff429936498d99222f63f826c5522d834ff420ea59a214c7c20a8350cba71ee0e26e71cf2c217ba98c8986d10b4b7a34f4d1b98c0f144590d3fdceec47abfd87e206fbb49e55bd19a261e638cadf8041b669d9ea5de604552370be49ddaa986b978ea4061b6e3902ed2c22f24cdd4c271b6924e70d0c883eb60593719e476a771d4318c346f81185e4d43dfdfcf7b9e3a650a5994d06b6a4c01a39ff724864c92ce9fd1c964e18d8211568597a1e41ccb60122b09a7947bfac59e89f29b5aa5e4cc738f374ab76c7f0632ff5d12da65f1f241abc0bdedcec3bbb3caf68195bd2b305d9f491a73afe3f0780019298215bca9f944330b47df846954e12f375ae94d89f59a9d45f05249f8b83ca92a553e9aeab601dfeadff191d6562d80c0456550b0ddb928da25950e6909920edb61cf57f3fbf5c8ad156ef0ac3cec50e6d6d408031a368fcebed70661aea24c20d36c0b69943473f765bc263163bc7c56d9e48e9b66875a4f59228b41847ccc0c0e8544d3e68bbbfcd1ab4535bb55a8777ba21b9c96bc69041764649864530b2c9d1dd872d16b13ca26048b757f0576f37c5b2b8e7e6a1668459e20bfdf2269cc1bb79e0dca5dd635694d50115377b3430ebe509a2aa162887f0cb41d56e9ab70b0ae785b7f1efcf0b074ada96dc9d67f91e8347585bc32664c971044c3438e91adbc64e787573cfb21cda6fa7f85eb4d14097f103e4073173d706eae3fd26e1f355a882b2ef7488d5fa0759212c5e45ea21f56747b649791f34f15162753357f260777ba9479109444b017c1ade7ab8db6ab876983ba48fe4b78120a419c817a376664eb4632a44f4a45d05ffc176f779a06095aedb4011daef1b8bdeb18a3911b523a58453d246116e896bded899f1ccb5a59b98b99ae5539f8502fac88b9eb00354c93b98b0fe7b906d64e8ce809cd567d36dfa2d86c87d1cf9cb1d3b9a146d85bb4b5bab30e9688097399736c0d2d8ed85ece2da3f6c4861e16a97e89912aaeab187ce5e4f893ddc28e8484eacabf10ab2db8a1abf99919f04e63e5e4b0ea658545016b9a8efe8835fa139ca659fc95c501843b0a23ca2877ba690a9a8bcbd84eab1696bb187db6327dc3dfe74483616ab27e9f8121237701cf3102cd6cb7ef4414a386bdaea13097d4ee0e2dbbf1ff148073d91f3f6a3fa019f3dfcfe70287fb2080d6d6eeb5f534198e7fbf9e3977f5bbc2e1c1f8e737f8dd76e6eb9d61dafe0b72f1c6d91d1ac786d578464f32fce1c6566b3265524fa91fc8b70472f3e3d313ce302e503af524afbf6b8393aa6a636485ac236151d0a973278c7c89c6bf4bc26f3cbd5491e77a1689b385eef00b05679c474edbb90db64aff4330f67456ef3b63e75207d1ae14151cef65aeafee876677b0f9c601b68533974e73cef116014f4a6d5f599e0f92213b6291856bf09a04f7f5ec5dbf503d65eef3a6329ab7f99124797f318d9ca9dbc6f87f4c29d98ca440cdb6b4b984444cf4124f350e3d35478fd0cba9ea55735a7366508ab4cafa1b0c574cff40a696250133129635c7e8bd750508e257cb3ae308e7065ee42c859fb4623a979023af13712007858e8953bbf57fcaac408a61e9c0bb99f992b4df04cc59d48c4d504271dd68b397d5779e3840ff9de37140f5bbb619d38e0195a2c04af115c3a075b2d26caa1baca9700acbd53f23120866870d2808835a13403fc026cd0c0a2c52f11184c74c71634d70daa29f17d418b5b6df4505e2c8710503722ec277d819b44944a161c9bfc0757b3b07a4f29a937886c3ef71171dcef54d784fd8a08b8cb7a1c6cfaabdf88291822e046b7d375ea632f0acf0e8cc5233739bf57fb93b26a5aa326e65d29ecf2f03a98ec1c2ae8ec1ea55e7e6a38bbb49d248dda6ca7b42d3de3982de84f6b86928c7208f6dfc0244c9321abf58c424bdf2a38e429ddc3166f24913d8bd177323e0ed2ff6138f67b19d0203fa575f5771e5efd88e30c9f97a1d2a6601bfea9361d785e5f471190808605c7937ecab3b3d30a2160686584d3ce3c3b1496213bdd80e60c060468c8c965a487f2d4bb4c8c8af518896eb3e1633621caf292bea64ed8f3c1c78305c3c30796062a21c07fe7950acd6a5cedad671f125e940719026e51c248bde5b3f1de19aee1e0385f13d816f283052e3504350e0701cbc870d2d40e69a97c26f914580071512a3a13656c0126cc1229b083bbd98dc2144428eba37e5b889cd4fc924c70e36deae97751c2ab6a6faed5275cf652698c473da1fd8f328d4444d407cfe5a31dbd63a56658807a5a19911b795538cc01cbd843e08035fda797f295e71ab734a0a7b4d699919b75abe7e2349002938cc86720eea9c09ecd616c39c5c0091cbe5a0fe7c285f8c4495713ac113138656241134677e14fd8f10c6b3c72feadc046ed372db915a552f366d1cad4fb085e523f46f5cd6e8b341a8c1e77b176b4aef43184d7cda2019b25416a4732d37f743a56e807f359f7e2cbc67e5c84f66cc57ecfedb81412480a110da220b4d2324227860c9bf85737cc5117d88461be80ecf2b89f7daf5f62a9cdf84e1a917830a6448a767ccbccfdb5a75ffcbdcc3fe0be5198194ef1eee7d13fd904b8d8eb0bd2b7301626b8235c96dfe27e5154dd68576d202b46d9952d0d26dc4d28868ce99030c6473ce04252e2638cc12df28a76b76ed720235210dc43f80106077ed269032975254359189935dd1d3e85f9d1f686e1471b94d348d47a84be5ddc50fd546199142a1c8811f650f2196e3be06eaa769c018882acf153ac96fdb30901e0b0742c9c7349d754bb2e172f1048b037b1ac8446ac6ee91e75ea348253e3eb808b9ab3aa33b88d97e0710e4683501c658136f020de85ceaaa45ee9e79be2fd967b070421ba9261197e5eb7f62192e9528f79500cc7222424d0114fc5df36ca6a63e42c3d1cd58cea7efc5ff452bc57781bc720b0c106ac6a3feef46a91c0022ba68aaa41f66e9be9787e6cf046cef6427cfc2de17a8819cb2fa64dbc906cdfabbcb6078438e1d318a1f22141c78aec1f689bce5d86ea57094f4bac17e711daf7b89b61ad0db510ab9d356acfa8607b83c74061255af7ab68bb52659a12bfa938275ef7e8fd996fea74bd47fa96186013e9572870387be040a5995fb11547753a27f68716f04697341030aff2c6499dbbc02104bca968103731955e37991e3391aefc8b8907ada44ea76b45d0b247b2c8574ada5ebdc58391452f14fce6d8e9f63cc40f6fff5ab571bbe14e86f1d8085513eee0adc21ed8c9aaa1cea3ad89922df2b1fc3861a2855727ecfd225cfb2b0655f340ec3faf3566e07fbc8dc571e2095a6eab297988893c7e6937d5c183edb39ee8878642a870ddd4fab2980d03ceb18194751b13860e3c2ff5de7d58690760140a16b618a98b85d6ac867dd81af7edd98e1816b806883dd51e03584262931764cb41c207518182f7fd3a56e9b125cab5dd671f7e2beab8a006406a09bdea5745fe94920a2d8ef8e86492d5e825023c90ca0d0788b14cb76e057556691bbfb2c85a4a7693d994a83d6ba09fd14719d212457b9d775166c160d16655f17c6ada6045406a7bde26f3777c0bfcf00f38a9d3ca004f430a50f41f92dea65705a8028e3849844a7750013837a053a41d60d0a6dc5da388abca9a01b06be296004319936a8f170cbee1e9fc7fe4234bf86e53f0c6cf0442e4ab2165240d86e075daaeddbec50e14de3d6ded75bc65878f883ca11ce4a5c9e90d293910933e17576a20829641955613f26b6fa1a404cfd28ddfc31467f873c70c7d75299846019920752e0fb6eb77fc33c1515438dd21ed6582c77c7f2bc9aece1840d434cdabc17b2d82bf6798827dbd9703b8ec5061c5ff24b385b22d22747bfe38697de4ca84a2bc71a74d98a767b322625651ba24c140d9fa3325602db90cb3eae30187eb01f35c34f68eab18d6bc93a19b0a10cd4aca3aa1788073dc9c1418d42681b89932bef2c3604c7fabf97f97b36b7fb57d3b2cdbbb2155e1adb1005d928040724394b337c8f9bef364e99593e505f4667b4846d315e8ca0ae256ad529175543a5377b0efc76c632192bbf29639c36bb10a3d28e5119c5a2bda21c59877dc56bf3d869eb026e146d3a8562b9c594b86e8d84bcc4b1df8b5560173a6c4b3ad8a8568b1bcadfb0c773ece31de90b9898a53420c3c2c809b763e1996cb918e20525ee4e6297cc63312a8bfb351ec8dce74f4d906dd68ff1d1bdd2007bdbd7ff9bb79917c8495542ea8620e7024f3ea81059060586c9342704c22ff7f866f05fc9fc5f5f480c1d82d6007f3b4e04ae96d08d3488fba780484322be045ad3f6bdcadd22a73e45bba37f6b7b69606fadbe72ca69fa7820db5113ccff51f24ec0204a8d3cdd52566c2544df3c07d40fef65181e0b033b850c432764de8895937582438cf52bf026178844a90f30a07563dcacadbfec42f59335dacc0ed1fd9da1358d3369c45ee342b6ed8f0eb648472b9b727f2f8278e1be12f6f487c5c556f3511d2395c19f8a86c5c9dd911caf0019586f95e72ad68cfd06cb7f89b1b522ecb3c31aad8e4528ff0e1ef71f11ce8ac6f17e2dc4d0d9adf30a1ba78e6a91044153e0dc259272b0c2bb8de62b7b42ac32734e03a625b038b7f16989ee845f35a62d2017c87c221b17f4d2355162db48216c4483d4182d5bf3468f735defc1b44761ace0ad8c1933e660fc04da51efa3b93fef58589f78f3f5aca892f45c8edbceba74f10e22323cb61b54955ed9e36d985ddd21b4b87923da71e83891c8398a1e87793708541d5d2f33f9bcefd211de697a88ef82587115e63794f18548cf6719b9b700fc9a712b222c55f8ace2e09ac5909cf7e86e9ab4d1f54294e9afc337b1a32a96e66f8ac160fe675d19fd11fda0c7c2ed027981bb81a10c37b18ad6c1bb2af41fe07a2536ba88783c0ae03fc7af6e95552543fb0f65d677998d53c30a4e1579b5e4d12805375ceff3d6e52dfbe8808c2f67ad6baa14da660f2f45051896a57943693f5fc9f4a9ae92d2f9d5f831aa82b30b1ad1f77de94d4304cd94a8e1301e311c90526d0300826d26c9cd88d736fb06b94a84840e414181bf3d129bac2d3c4d1d5c8f516b2056c88f3930011391fa0ffdc3eac255fd5016e1e5772be7873af9cfc13cf8166cf9639d4ff57f70bab6467d3f44cebd10cc8230dedbfd0783b28c1548e7c646e5c57f9b729765f0443903ac1e7cc2a23ba9bdfad0bdc5ba516a574c5529b58ba148aa56f71c95a08bfa8d79bab089d86003e47aa36b2341081c72811b15e0d175e1b655c6cd5755e40973434af5bcae48671f89bb4bb69c6ccbfba118445434612d216654f10ec4193898876adbdcd3fe147626837acb630d66bdf5d4ac9e77342aae99642876f4cb3954b6f7371411fb0a7dd2740c885989e58f330fb36bf3b4bd144fcfc1144a98895605a4668dcf3b332d1ce0238a407a7ae23b3b4064c5f2da919ede1309502e8e0f67a621856a45ce85868c44fcc07ccd6d0f8183804e25dba468d5fa856d87dfd1a89e077af739139f5f67d19b9fb99d8733ae4eecfd0e38424225f901fb460a5e96f9c36330869c3917457d8afe21751a3d5fd25e2e7b488395b58f6ce6f501b2bf72757e2cd79e630da5c7dd0ea34b81b71c10bac88eac062579e0efa59a88d44a835e940af666f927457fae1891861b031dc6ced33c90e088f74e4a186f2f1361fc85a10080a84eca821f673b7fbbc2f4c2c06a0e8891e15b7100ae726ea918c04ef98635fd2402613977479cfcd34d1f5ac29817f68fd968c973a33c480dc6c62377e4c64dabd61bb3838c00c8cbcc14ff9dcea6034fadc1afa7d2d61815905b5efe220a2eed8f699599fb690472786b166eb1c16d08a3eda781b22c71d23025588f3d5b09de830cae30e889e36d0855b3f59601cca4b10d9f7479083b26b89de696b0fc51b22424887c1376a053f539831e9d604b2ce6ae2a355160342404c45d7c09f8b0a126b26e9b43181c715e67302aa92f113b6c770d5de2d72196318aa3a578bae31cedd9c578a8b07e2e3e7e0febb9e37ad59a1121f540065abc39159f3d8b21561e061af0acc4bea2c23a3b7e08f39a8abd9759933d55c578498a10296546d5a2d8f1e3a1e8e2f30bf76e1b32ca120249dee8b2343795bb442422b6830096c745089ccfaa869411d9992da6af75ea03f2cc8cb54f926bca17de1fbc1cbf5ddb3e73b8fec78ff2d333cf753bd42707810587b4ee6f8d9032e10cfbcd3419a54e1e413975e859fb991cd615ddfcbf5b644c5a22e26f77cb10b40297d94c4cc8ae9964afe936e2a9bc49e838c4376c69b2f6b05434bbe9d94b02b189991a8b42b47aaf935296a2d8789021efef605f313bf423aae367335f1b569a0ed6c013765d2b14d8bbf83a14c3674b500358d6e264ad791ac801b74af40a3f455074514a72e1d42d91b04d3d0a350e1111963e7f704834952d457e59c7fa76bc18820e536b27fe8dd44d45b51e04625300d207b8553f4b0561e1d3a7ab2680b510d2e8ce61566edfcd2ac0fe14e576bca65ce08c8ff2a4ea49e23b1cb245c330913844788e4a8fcbc905509efdd1e1d45b731e025f4bf826b03b0f0e41480af5e4abc01f4a9738ee4dbd926b10efbf49a516ebce17da9a0b701b43cff2806328c639d6acb285e59d7c961729c5a5c2d9c93ee4403a7578fdd3e985cf12a2ee70071e91a12893f2a96dd80a2cf3bd673c713d9b0657","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
