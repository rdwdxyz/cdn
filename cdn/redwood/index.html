<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4345dbca87997430fa12e7b8525ea088e1c43a14d6a357a690624f02c057538a7e9c133c08298fa172d9730804bee64a21cb54bbe4b8eb5958f6cee15615958f8c1bfc0d68102dbd6ece953a09ce9c027d965caa46fab90fe9bf532de72aab4a317d941135c213d26736365c01a642236b7cbeb8bb1e10c94cbc99d8c0a68c202025857d73568189f58bd0dcc05d2045e9018a3906ef97ea199eb1b88180f5280a3825a2669832ee35b7995f7c6e50c0ec6fe94e6d981117b7f051dca2ac0a25d994878eb4aefcc02f740642b5202a49438adfd5464e996fcbd5f72430486c087d8e81afa9e34b5e9338afcac1b536b5853492d75f82e0215ae33188ea5b435c8cd7f727aa5bc148abd9eb33550a05e9629ca296d5aaad0bccfb618db84c0fc4440978a6e083c6c64fdaed9e0762935b592479910fadab5e3b9d3a647b26439b856acf04dd219e69a4acb10925ce0f928dc4c5ed4bfbf4712cffe76d494e74dd1a26c3bc30da6675593e537f9c5ba81ff69f37fa0d972a12618d65df565489e478aeaac4653961f0869f791cff58b6115a2e130785fc1620bbc4309e1ae457216d4ec7d49c14a646fea76d5872641466ece692092a1a2b7ec2dcd59f915cea5d0ff6a6b93f366469c9bbaddac071390eb4379c0c9b7197681e06734e730b0ea20b1227399abc1acb79ded0219d13ba25e21cde06816723229d536975db72adbde3d66eb44b51aca433bac2898f0b28d4d00f5766858ed9510b24bdad177f621e323a125cc093474a8e2977b890c596ae1252df05759ad8055eb83fdabc7679278a1df36961e796ead952637b946dca8b1afe6291dd8dc524fe5d15cf589d8e19414054f2c6569000c3d57dedfabd88824d0366b8d1c48fd58c4f0d9bf25dde168e5a312ea2b4b4316ec602c795ef67e4226d1bf96ef232398b85bb9237803b3af61543d023479d419fd96e5828e07e78fe0f01956c1991c32efa8b5680f28b414b5b1aa5f7a1654f602f2bd932b4c9d81e96d061e0d8d9056a77653b7005f9755d556a8c696ad66e163abbd60fcb681909bd73acb125dddc15d921035be372252493ebda919eb98919e61022fa3a8bbf438d6b2abadaf7f3239642c86e30749379ee15302708e489e918fec8ed624cf80ab13773f3da8aef9e76a72d570be576c9425e53bdf3e660b802b1455c215f12ef05b29dec2465ddf54e213f2a977c2fca7b44333167fd71f0f3eca8e96ba76efe7e7bc1fc3ecc8a59d74e8381f6879897e90e8937c5954662de0830dcb6df9263c755a34e4e18cdef8c4af72f08af88eaa49135bdd32f1de79ba6efd44d8ebcac40df803766f91a39c9e9abba935f241dd5544dd8561ce8a0c21eb3852a76299caa19260dad2fb634dd2cfdaf028bbd098f229b9c5c8990d49a41998cc742a2fbdf0445ff340d31b3c34ecfdc4b47b5c36fa66e0a9056b66f6060289629da0b32393d9acb744a4906867d4c71c55e61468331b7301e5f6504c4c2f4d7019d05176c1f3b1a37040369e95ada9f9310003368a1a0fc01e43902a7fdd21ed68122ff788a6d3d473bd7cee834f56d27f04ce757990febebe0e4d7474a828e5cb134543833793fb88fade3410692e50473fda83550ddc2fad6a1c51cd5a2e32dd5fe9ac2e5d62a92cb6e8cc62073b600b9061472dda0b3276837bd4c4a0806023a66e758e6285c2ba339b9d6174549505cfc83fe85d6bb6bd137f645a8876aa45cb917d74e245f979efe9f785659f12b6ddec415fe7d9500b624921aaa483f81938abed41233fc6dd3698401f898ea110e61fe36965a063723295ec9c8f5adc0f24d276111556d173fd6d7e6ceb14bb03cc45f231faefa07800a751884b45be8b31cd7e29f776ece62d2fc1f03ece2764e4bbc0cd1a0a06f2a7f3c95e893262bcb215701c538e54ab5f5307abb9741873e5e955fb02024377ee482c4834dd8335ccbd5c47924cd04a204862a83fadae46c0d24a8d4e3d1ba2372c629017b81dc91e52525792f7d677bef4a3ac5b8b8044eb47d7c8889d486dca0f7d7918e1dd4600b64b6f67909428e4433cf7f9209e12ddeadf8e764a6c232ebd35e4c037cb3ebf26c49e477375aa009b17ab2c9a06933587a2336a42611fd8fc36c9f4cc5a8068e105198b0039c80e2395ba1421d0664851aed11a58a96fdaefb1bcdd63e93c07e947dd60ba99bab745ed89663963e7fbf5241bc2c7349cd761040d62e42d1a91adf62a903e2957bd876deeca227a3cdc4c23ab8082d7374d4a7880a3e31bc7437566cf8a85529cf1053b0cfce1301108ae875dc7a6fc9c2c019a8891984e271428700ef51daa49fb28dc7c866c1e90b0f4422070bdac2267fde9e995f07a7795818c512151dcb51ec4ce4bf580f84ef9fa3909ead2829df2662441a701d06eb17ba87c6825a9885a7da440111e2d985b8ac27b5e5dddb533037a384edb97e654301e7ec8cad2ba19dd72972ff9d4790356a95509a0ba6bd2532ec24ec23f3992b2e115b4b176f1120714ee42efe39390b71dbe7eea2f4400169726d0b5da8d60df3407a8e2875a7b01927d3c9d1567e063b41e0749121dc7e053cabdadb1d9dd13039d454040beb9b1e2a4ef640bf1bf9c88c5790cee7f130b7f8fa398a5910c86b8c528a988fdfa1048c801f635bbf429e47846f224effd2ec8e49f9f2dc761c4edb236a567d6577ec84fc04bec5ff32f8214a432ca0acc99f1da47b4bae12410e8d4325e07d998576a3585d67134e3c98bd1b91d42e8a89bf4b16cca2e135e320c2b5b74682207dbdbb4958185d3330923454abddcf0cc90d512de87eda97260f7f0646256d5964b0f32dbdd4c04b3a828fef62e6ce61f15fb1d6b46e540fc04ef5a259c05bb14d96fb845c760b413b545e439b2bf0fd49abfa5ff46be91343366e9c375e97cf51cec4f73bc8921f3142aec2a529f842c0257fc474c646877291958162da3a026ecc5498fd6c9f8174866dd568cdd1164f0c809a4e93d6e3843a17c45daf181cdb0ed499ac5069667f613e4efe6a67ef1cb79a012b5315e1ab3ee0cb7e6b2c13dc8898b5bc4d1fabab4af9473be9ac34202ac3fe5a065e01b01341b2b0f916b72488ac953b59e3826e008b3baed27e3fe64c78cb5d8c22772207abfc783f116307d1b4d56a404f52748c575db43036bc748c3968ec55b428971f23834d088b4430e6a871442f1671df1eff85ec2a93915359f060c0d40fd195bcc78039ada3e7956932d47e2668fdfaa099269463d990bd28adc38f10ffa25b21a3a9ba3073aaee594deab3abd587e70129c3218d700816895b6d73c1bf68895ba93d6961a5419ecfcc1dbc24e7cf806a1d1551eea88ac41ea7a45df793512ddc397617ee89e58a3a342e3cbe40683fe8ae8df268fc35e98672ec5daf6b867f720d8089293b59b7aeb5d31192cd1e14202765386a4227c088c1c096876a032c9ab4b66809a153e964794c0c476ef518359e257bb0ad1161b4d75cd68b4d2052f8d00f0dbe8b008acdd8863741277fc8bae554d6aff88d06fb32098205270816346d01b3c688aa2ce4aec720e6b0073e3134a8baff350aa2fe818405ab29b1160b737fe042fc797174729bda0ed69cf5fc82c50db93a7940b6709a2bf1fd8c3ec98876122c55598c7a2090f4b1f9d1fadfead2cdfc0cb2dc8e5e680f6f49b3286710f1256d1013f1fc33a76c9d2e2eb10cf1259d9c77d5b896931a736b0425922c29920d9eac46842a7931553c0fbe481d86ede812defbdc602a66951fd43d56990e78e5d0d8730db2bd8c4164ebfa572c5fd509316aba7d8102e26ae16127df4f9e869a8ddc54a7022a25703802a01f2106e16df3ea7dc1e356351829f41b9886a0fdb77622d379180b3ab0a503282d280fab082c29ee9fcbfae607c46011595efb941955c1e30abc927e63286c0d4513609971842945243c6f34f4371a40a2dd68c70360d6c3858dfb12a2e04d60d54266d25de95639ec3746d703effac3ff88b3e98f0dbc2f0af37c982c704a1b8260072ed25bed32b51ddd059843f094c20a1674d5676535f3372c3faa91b591b0ffb72a47c6e66ee4e86323808811e268378952bfcc7572478f8191e212f9ef09564153b30d1da44d9dfd57ada039a14cd90286d92878b3db98a0f8d9d15764c3d867e567d84dbaf0085f71801025a903645805b2c8d0c51d26f0db23c716b50b7e1d90a6ca9f2e77a1a24c9118572ad289dcb4a869422b7a298fa815f20fa546b187e42522e86973530a8eb1dcc9a0d88ffd0942e9b05830c82fda16f4e2fd86049234f0adefe8defefadb79135167178fc935fb729c1690645cd6c2cdb91d5f6bec1c35affc2d97536cedce9c68fe5158fe15f160a7610fc464130681b1bb147885f22b9c3ca2a6c7742da6bc6dcb044a66a51f46f799cd999596e542a50eb7d5163f902097d8aea4e317c906bb4a400c7f7eec7fd22fbbe27364acaeb34c97db9278ebd19eefe2214c7077cbfbd43437c40994605b0f2e132b783aa6ef0d09c443fe2b9751f798854c238e498d6bef6f006983e68c64454ec5ce55b6407eb0b783b900cc4686c00d45055244a781e68b5546085ef5ba7e749205c6dfca72f6c6426a810a4850cf5d316e99a4af636b993c49021f6bce0705e7bed0f907d9e0e98e78d95c7906b6727f230dbf1ff368b37c58125e6d17283652476859bb43994afcc76f6dba4b44150ccbcbe8a969735d64ee71e3a94e49f92304df691588085842a5c22f2a28caa5097d4b31e351bb58f410ebf32a5f9d94052fc86c553b6b7ea65427a7d8149c3a72320b1837e7276c633f2363d7d9b2e90ce627da98cdadea4f60ac63373c24d549604e2ac6eb6727ad4aee69729cbc046ff2843645967514daa3c67494ec8b12302b92e7e4aa1d457ba41385a522bc59e4f3b827e2da3fbeb80fc0ed080986328ed12db85b0c1340ba9ca6fa8ac9b3fc2d5719bf017560bf245be8594e97de060bebbb10072ce1fe705dc281bca81ea59e185f534f5a34199debc3c042a6943d2fedcd6519bb23f4b918ccd1612ffd749445b3318857b1c2030726e360119c90f3b621a0cf6f2ce32ca8229ad44992cbb78a2e57e3e3942190efefdc5b36af5774a042fc04f20a20a3d276c9ba3ac2a7bf299b0bd3acd897e1e9de6b7c2dbec7816d1f200fc77e8d6245cdbcb8d9a58265d201da9ba31378e9e3915cc99ae1b536863bdd1934bee301e1c17e2964b972047a34b52db43cfbf6bc57c522c192ba3dd5ee2b12740ac5cd85cf255f94891508509a9b2f6316976fe8138b742541422e04ee01baba9c521a32616f0fc38871814eebb6de1f7005c9e37277290a2d757c35b1fc7e2ddd6e8cd6c230e1741b243dfefaf5055f2eca112ba7fa9fadfcb1000ab3c146ccc6ce922655c9b7975c2480b216507c6e4064cad2dae97d5c4c457f8e7cd47478e99dff23ab2a819774943b78aa7e61631c44f5a5e2e478750d6c8210a562419773b2a6c37e57573c643736f5a0f61ef5528bbd901cef4d746cfdcc4d29c0cd0c773d7059a29bdd5ed4627052a5f4aaca8c1fa20bab41dd0dc7272798ea22c0e06f8e54a9b6c52bfc8a6c5ed9f338918018aba35aa962fc68b4f8169d84bc856e1892dc1780c6df623dd3ac3e59429aae7e54aafbe2aa709211d3d75ee3c87e244547873324e3640703268d2875e82eb9e7d6bc4674eccd2b1f227bd1c8ae5a75912b2e1c19d1213a67e496667f52bc7209ac2d098121eb026fc60955fc7a4dd11448ef4017ddff28674f4200fccd178f1fcb122a95856a344b742b24a47a6efd02e4187edfc569ec74a63b495887260be67b4d6e5eed2f21641a7c272fbe663575afac47b3b3c815a93b06f4b6072d4b647c00a4ae26b80ef71fc05b9e9f0d49b79b686cd6f1a3b85a4e77b1dc637e560f26015c284b515a250973779297203c30cc4d26e3da8913487baf66ac59b00d9cc44adca95ee2c38637217038f97d0906327244bbcd6367bff2f942fded3620b54879bd2a4902ab2c3beca9a1cdd4c25caec44358017eb2365a74b18262c5013377f35f717b0a99738298d340904733d56c3a2bf46aa5e6d22ddea7b044f07cd07fbe5bf6a4933e79afecd73ff11d48d224c82539fc99828b84b35685aeb6db6140b58fcfde58a262f5eef4c293f5c2119027e8768d0c5bbcc71a76baddb48958c8ecab34910e612888cf5b44d1fcba118fcc0b4f543d025bc01003ebdbf8c3196b97f7359c5ca4ad6386c48b443ce9369f8e267087322496424df07e19ec7039bcae5b532de16acb1e9f09945c573c5b7f494d344abb71f49ef6522d95d7b40ecba7459215c57008ace4b5fd156c3501ca402e3e6509737b31e1e185588ebd8f44f61480b61eb4bb7f65f3b41f07de2f1f5438b8512f1333fc13f3ca08ec821ae509f04160e1b178b2b1f591ba072dceee20fc6e7a2d3a76778d3da8d43b4021f99d14ce0b6049b1be95b1ad555822eea785b17cb20ce3c866ead28e3474180098b63d3fec2b6cf3df3bd104760a59d5576be3bea4320b19f2cc8eff409a60ef41d0a092d5051db8a24af3fdf9d389853708549b9bc7cf8a085977bb8e2caae79e6c3937b6be676f222a55ad905554ebcf68fcd58d5e16820b36038bb8f461ae2621769612abf97e0d198fb55bfa7f8ad8fc9a8ed423ecc966fb7ed7339e296f64c6692ff2cea0d186c883dd05a1bcdb81694de556ae7dacfaa8084b85c2aa348ffab18e58b4745814e555c0d40ecccd77e56bc1133c6e3fd6c23e9f23c76c28a2fe9978518db2580f2a2496ab445158906eb29009cefaf18a1b1297b1a8fc3aadc3caee79eabd63397b97ba3c51cc43f2fa8bb85f604f8d9feb6bb7c999bd9dc42f3da4a5f63d10528925a01afeb5697f662930e16cad22649f51014d5d6e69cee8322f5cc6c389d15b575689bcd88dff643b2b721123431297fc2951bfb789eb387717c12641ef6623593a467af2970b1c3e8669055688cae5b73bac40cddd28691a281e86ffa438ced624df0d355695616f4e91614fbf9d5fb9372bad807f9574e1259b4e847c62c2dbb1b6ca751dcb3b1a05a557f5fb1816e741eb6561dcbdac708b96cf191f90079e9933348990d92118ccbc8729c6c615f2cb691e20a37cb03c365685329d198afce0203ee950c9da0dcbee4517591b6dc2389cffdcc645d43766eb684d235f139f775fb50655cb4bd1d9513ef2ef1c92bab979f65d1506ea4a9ed7c9f4cf1ea6b6b44f4081ef80db9fed37cb1461825d2a0d81b92cc18796766ca97995a60654b50dc1a8b3d03964a3d07323218566ab4a9f8a914433f58d7efc735681c2b4a453ad334ffafe9f4411ef9368b9c491f1b4336a469867a7a30ae76bb46ca532c0110dc784db052da72417ee8501082cfa4dee36e6f20e26393b99d349094dee73a2e4a193711e83ed5c5497a23d54705e6f7863fbd8650df1278e29ae4134bf92338ef81a3dcb692841f5ca2b1433f1b6751d1f43da823403fcc8d0a72a7e7b72d125978dab777b9fe74fb1c6e26351b2578070763f23b1d7e5e64cedebb69f8e6706dc638a091d6360b8ba53938af29459f73aa372a6f14d86cb3d981ec8a2c6a7f5decd79a9644f7c3f67be8b590c5737aa68d8056735235b943aa6e389af66e041c1cd928114207adcef6e2e18010444c93fd10a6186208226d94b530ef1f38b9ed9491262295a73dbcf0046c6a9650f4f62c58e52f14c0021f0864414ebd93625a1d0dec75f2dc8e2b3029291b43c5b2974d4f886ba88015712ccd415ad166ab2b11e305dd5e6e2efdcf4c4706a5ecb660c8046bbb3b115f9292628b39aaae8fe37ae90122f5e8e50f1fc17c189912b9ab5062d1b63e7ca5412c31f97a4f86182b792be2424d536e4cd1ec8c59264e676a74bc3f7a2a5f054c1fdbf3e909b1d6014f3f4214a71f8bd1a7bf2ea20bfd8ebcda634ea3558f976376bce6f19a5c1257e19df303b67fb4e0918f6e01b4914c01359ea0ce3d8de3704210fbc675ecdbb486413977bab8e11247ef42932e3cbe360922868b6ddc6a00b8bad6a080ac1cb7eba19e09ff17e3a245a65ab6e24f8e233ed2e61edc3734ebb882b8725d0a646c8c512923e05d1585948b7ff92cc6703f4731cc4a576cdb6bb68b5551f4a6c2ccf9d8f13be0560d64b46f6dd30aee17a0b6e94a52f05af41e867da9f8ac17b2cdc0c1c93390b1f6e0047f0fb5f93e4970f4311ac602775555800c450d5ab430c369d42a9e6a19e11b85c414bd050b31f2d27420fbf97450345c4dd6c255dde0cdde87de5e39ce914e2fd16cfc0e19b53c8f7767ef0eabdb7a8843dc29f6bd11181fbc1d68d0199ca2ea094319ab48b7f6d8df8c3e7042473ad155d921bac73ce4833303561fa25b920a9164f78f029cf3812cc6cb658f0c3c9eb1e48421352655273eb403f4bbeb1950611bb4daff75c289fdf03bd1750f309ff1cf85e6f0f5102e0a25137786933e9a380a5419143535e54a1a1b7dc3efe76fdeab776343af0e63bddd3d0c42c8fe06e300576d64c45c9f3231fc7eb3c4785dbc7ace506c6171455444a0b18bba87c701c2e8e22653af914ad502b58c61ee93dbf6d834fb6279c517aba2531af2faf2b9145d1f92ed68ea09245bc14aa08d3e1c28d4e3faa89f46eeaeb9c6306cdc6e5d3655bc328ad43b8e980d3c46b3a75dc87a66cff59214e0898991d589d1fdabe18e54e30f68a07d9a42a682bafb5f4194de47618f540444f7c2a3399adbf0c2e3f5888992134443bd188cfb6d944fc4c5f05514d3cea457370f6b1c4e05344e19eb90fd66f651ed1e6c109adeede120c7dac65842669d14501f5e6de07fe26096c1b11b65f6c94bbb00182fe0bfa2ca3f095ca65f0e901fbf0ae41fb186b60d709dc572a74eb5651ff279ae7ea386a07924f2c37c3b88e8ed2d76d18019bad537b991ad9a2dcb6ec5f1482e68c63eb8e4cd8a4aa73b2944d479980e0917371986de6e98a2ab06bfea8289b40ccb595cc2af2b6ccec2e28b19c4572e5acce697aac402b6b952031038fcbabb5d9b0912767b0fa19a22179413ba3ef4d46e5ba68934c276ee976d59258ff74100e184654f3242c8612bacfabbfb606adf8b14e7d08c284b7a5350bcc8187161132498e818a6f7241eb866e1d5a8f6b9185a685b86bc09117a48f3c062cde1930fcb76bf7e003827749e4411109a3c01bb6c6312aeb6fc8a31bc4ab0555e7c0afafe93d9dd5499275c38e2f5fc26baca116f66aca42a0cb75273efadb82dddfcffd0f03281da6bde9d92a54e50d541039f491f210aeba4de31d62ec8e321ae1c9d64ec33551763dc7d253003d888e53a21abd124305a803ae839909710279707b6f4846b2055ce41857b9bec95f39f0d0538509336ee44e3dc7de8c65f49b24fbd40d427816a480ff6d4db51e822023452cc3bf50760080ac9b697fd35b617716b3b407a2713cd39368ef15962624b03017a7a222a0bbaf59b6bfab201ad61a4daf32270083df16408e5c66b277898cfb981efe012d7fe2725441b58312d8b0926f30b00dafbd5a608e688c5d86752db0734a91bef2d4da25c1852e16e31d661dd29ee47b42b235b0f2246bc78f8c593ff453c1d6f6e1b4510fb77a44e1ff2f33a287d31d0fd6733639302e698d83dd74438adcb0833f2d192ede98afdf93a823b79cc7830c081a5945d938f4e111fae416a163efe3290a75bc0e544e07ed4f8d3401601079fd3bc6ae863ae4269869dea1498306e42a995ca1e255d7aa7a08bba6d40e59d08328f141622b0b23c375924be859f607abdee6c0e3c9122b83d8b45e69377969bfff23e20d5a463c7d034a5ee0fa808bd5300c8706db8fc70b739cff13293a029779905e62c42301ca9747fb4d72f2a813c55dfdf00c61cb6377dc93eb96e98142e6f4836a0505d7dded666e8dfe9eb520247a7a57b3137b9bd1b949e259fcb8edfd354bff70439eeacd24d3f097db6cbcbcf0ba051847aac7f313b67b848f311d7dfed9085752159baeca3094e49b5957bf8a51d5b1205ede3ee6efdbb42e2480f73ba7a45225b9c2d27f4d9dc5c93818d706a4d68d7d3b7e4af92abd0bdf0dc233eee536453a70260c87ce5687ab9394c931e338cfb63838e0cfac9e9ffe0d3ac7d27d3b2525fc58a1b67911f07f73eb36f27e0ddf77b25b068eb70872c78ddac7c675976d60d97d4a24d6be7ba21eecc5330f2a6f729b58c267854da0969068f3742091a67db291c75ab253f6370358d96b029114b40596588442d50427c298ff6f271eda736724b2b5e2f6076a063ad9fa0fc6fca0e236800745728eb4117f2951df077f557c9b88f4b6aa9a0e16aa46e70c860c993b21eee5cbf81d5f4e78628b6409c46ea67b40eae54692b406c386c390e175174bdbea186b4a00b7f88024acde86667249455b6e2f09bef5ec4fb29436d8af7ad58a29581d1832bbba2945c9a84f8b4b3aed7899b99aa35562398cae4d7643e13e256ecf1856199041be4c6029716288d124febc4ca4c4258ccd3589d5b4966657aaadd92230157544691247dc235729ba2011616f7b5e22851ff61c12268f0b6d00c0b22a963a40204be26e240d87a06ae3b98bcc97ef72ea1bf22288687bd2951f98544d5df73dfe3c2ddd1dbf894db5b0304b3a8584811846fab3146bae9a6e33695421e4e2991fc606d149f3502fbb94575a0ddf7d610f22aadcde3abdf3e631dc1d50a2a3f6a58c372be344046bd4179000437395d757eab1edfe2df14f70eb959a02d7de4daabc9a6cb41d73dab13b5df12084f42b8588ec6fc4e69f19ba55790370871cff2c031014056e024d37cb188178f8c5a7ade35118445779cd571ae25077644e09c6961f3a61d81c0fbf1291c53093861ded9b589864a9a8d113bfdbad0c3ac584deec0a92f9c4b4c172df0e4d744fccefa0a9772427383cd70957de23e18aac518acb6d85bd02d2c6fe653e0bd51ac3ee84609bc231f3066436964006eb4b68e6851dea82779951296edc96d155f63f44d6c0e983d25386eb9bbc094c7c21dbb23d4ec21a2aeb7f8b6f863318524157d68d0cc59b609c1f8a0a105f11dd1e4575fd03e1068939304a1bcfaa23e3bdd0df94ab35637ab70a86afb562c367586aa922e5cd201aa0d9cd843f180492377d73319828bb95033e8f44cd3375ed2e4ae82636734505668009e4c1a2b2bb60c9ca5f7d62de46bae7641f29a76fbcd2bb9e2adc3a907a60818e5f5d850e9a9f7ff78f91e3bb7ee56b1783a80642bfaf2e0192f68d69828c5710515da16636a645cf70a02638bece703cb68ec95c20c74b047d49a0f1b30af8cccf5e9a3faa90556ae780039bd6bb4e2ddf3027bb266a882a0a9b7c7b2085005c2bb6dfbf9532f32d7a614eab2d18aa4f3606cc05bf7c5ef3bf09323f000eb65626096e9b1f6428fbf91ce7df7d44ad614c398c539be4df0f6e60552b1126c57929162e158275eeb41a2f7e4d7e05eee40d3711a427eca2b62b44a1be5fbcb9aee557edeeaef8baa69903778e5b191b1fa8fa2f4367abf289ff23915011804883dd3757b2617809e429c2ce20212c51b09e1a60111d95d3fa010bbb7a4f1ac8c314bfc5df401645154e9cb912f9d2e913befcfa8307d2ac7e6354471ca64730e8cc0b3dea53b89903563bdba42d499a330a1c50f8ba4e831cd7d1251daa74c7809f531b1f278838f1990c6222f9b22973022a331ccf4d5e31f1bcf8710616dd739f537d1422cc555c934553e0727999203b46d9d125ce2c81ecd3e26fe26637fae53129b9d7fb72f1f597b53883c2393e4c4fb48244d355a71cb35326a968329af57249ee1b97dd6fbe4db6d456abed9749b4d73ccfc54dc91a9f1a3370886e3648128bf1cd36e60be9937e309b9dd78aa9a1043f8e372bf747c93261ff357efcbd182ad6ee4fa6798cdc590ecd75a5033ab5f7c1afb9db9cc42eb534cadd57dda3e7f0e577643827d49355de66112998981430bf8c1702f71e8c80107f84553019b227b9529ffe4943c61352cc088b2086f0692b6efe8f60635a11ef77b063a7d2adf8d89af26d65f7e4035987dd189fe49f4598824b558a14aaa77f946d0de66cf3cf73a2f5207e6d3f8ce9e9bd452bfc5b1defbbe9e939f9e78021a059d21ea49125e5b01491ebf9494e524deb2222274c76586395343366219cd10fc369fac903c090de03115dce5f0cfeea6c25f14afd06138c827f47d27199a988a99afa972b56243a6d26fdc87cfd992a8ed0cda05be53f95b113f1af4917a5b89e88b6c61f2e88e2f09968a4917370481c9345e3834f36b2782f0de1f7442c84fa301ba843d47680fa6a6aef99a94c8f4bda9b8c8ed13de821844e8c949127542125ffe197251420a97b5756a637050a73f7ba1b4994065b0fba46b93899cc2717e58de915eb5de831f9d2244d6147184101ae22bc7ce1a4c123e6d36b2492b89eb913e3268770958081e0bf84de6489b559170c700527fb38ee949276e1167a8f51a0b3110984f1da48757348883124f4ccd358ad3d08158875a5b6b48f54c61d3315d53e87a69b5f26d0d867e93b3913d2cf23bd4a5feed1c53c035c33bfec3b2c1ddfb3361defbfa51899323e5c73590f2b491e6fc75edd00eb611e7b14cefd1bac1f50c78a1ccefaf2adeebb39284ba2e67e809271f6e80cbfd1496c5e049bdea2c95c64bade4e1727833ce2819abcdfa83cf87eba00ad3051e562c114560caea5a1053ff26b2fb4acde053657c94ffb2fa4b66831ad710a8c624c6b1dd768a526288952167d3076dfd576e29e7f4595dc4384855c6bcb36e0f5bf48cfd85879b8edf63d353a1139d2f1687d6ea9c5aed63939f61a471606dbb096c6db79d6799ef8628e9b4b55ccf97a01427323dd24a99036354f6477f6379ed2a6e4b56bd00ac2be55a1a4a5d83b4559b908c664e7ad84fb063f8b4910ca6d533bc9c80e13a72e258d3aaf93484b89dd64e3a529cc72e53cce9ea7d2beaeda547d5d42ffa860b7f0be2e42fc3433d271f82218bdbe16795f8c56a2e5027efad38524cfc754e693275cd16892e3fd462193ba87d9d706e89e10af0946dca9f04c8fa7f147dcfb89738d588d7f83f65aacba134fa73784a2cdb1ec38c3b681f643f0f60e35631791bf3abfffee1fda59d3f2c7f27fb31eaaaad706b611f7b96081ca89a584d3f2202ba9b18ec6b9f3a070f504f8dc563babc42d04402d89998b586b9e0707c5d2c8e63ee6ff389b07d26931f35454eda9c5fa6f5992e65ee4cfa6441830d6cf9b981058087972a043f6b0e266606aaad44b932b7a3bf19b01baa69ec3d27375932f078d3a57be0ae725fbe1383e4ce0b5614fee29edc1e1600ba2cf594ad545ea34df7f23ca8e31b0be8ecd59c9386e7e7a0175b4b851b91e12437662cffcc12a5f564d3e1fdd8faab3175b97f6e758321eabbc5f4e9327dd93055ba4e7528ebb2e7ee70acdf058a9a87977b09ee9957d9d9be902dc69940b3dfc62d3aadac3476d5a9108b1e91668468fed5d497a83aa5aacf18d8cd5d9778a20a775b244f19022dab58d532d34fbb7e9420b1538b84a663b6bc79563d0525f67b2d954c1ca098f5f4f7fabf5ff7860191e13adb635def851082e580dde08fdfe7a84fb7ae5f17303ef3211c479f3752f6271ef4db5c47d3b42ec0f946d22c011f2ecc96f23f5f4a6d51714a696dcde8171bc13a1d339bf33309edda85f8770cc01f0ac863ec202a1273a52b0528b090366a3433198ff672c5bdb674f62804417bcbb794e3a26f8646e505b58442c3d211d73f8565564f9d096867434752d819248542d29fbd7da3f8186e4e39d3b9770cdfb5c59fd6bb0fa12d8b76161203c25b448bc9200db79afc92cee99d74d8b841d3a16d4c0cbc98be5bbd13e3ed676aec090225a412ec63fd34aeb3969d04176b32a6a0d9efdf435c4312beb450706d6ecea91acd77d31570f84e29d12cd0ed8a0b178829ab14024e7e6395c6d2d92771c5443cff42ec5f605880e5dbb85035c04c6cd4023ad9d7af4e6f12859063f411f7d651119d51ca7a2d0a8008efef07372fb2028d526b192500f960b6bc68d8a7e6780e359a3099c3528bd2dec80ddd7a3e6e6cfd64f3d13637c94cedda68967b1a995c4161bd38cb30def18e341d56f3d6daa3cc3cc037ae120d58dfa1f3124aab6a125c9462d329a87254f86dca767029e77dc1181cdffe20615bc126c622bb9315fe0697060012a78e4902be7311c58946d9043893741d9497701f8c061e297f45a80d57e2c8b1821417ac2c68ee8704e863b8ec692be8795f7cda59a093ad5dd2000857b7a08410861373432e5c12994704a7b1515b0936fcafc5486d4916b26e06652a25393caa4908d40ae7c10137abb41fac5f343e35163c99401a2217513b001723123e5d9a4035bfadf240cae9142253acad4b93029d262e191f6b632f2023d6beece1c9d92a6cbda3676ac6737151e73a3d87a7fbdaa97784d236863e615bc00a4123c7a693a13b3aa3f912a99ffffaf931984acf3478d197737c2d16cef9fedbf6d47dea1e5e9c4d7a1620fefd2d958efe937e1ae4d5e6f9413e1b251d2940f1b7c0406b91fe9c73d697c364797725388858de1ff61fab86256cf8e8ccfcc9d6e0bdfa4f0fa87d8b16370308d013a5c6ebff88ce4dcc574084cc8ff1bb12b24b8db73dd801719543e67085befac7754918bdbdd26d7e5bbc538166bbac553aae605d55e5f97febcc7885d452496daa596495b45a0981f96f65ee578df0b0d46b7ca6224032ec4b287269cc065d3ee96a1c296356778309aae97e3aca1f0b26404e9442c29e0e2553bc9af39665ee57546171d3130cb56b3aff51805074b138de131238deec350a7df85215766c0a82758ffbffd90073d3db096fca48503070a7977aee284b6abdb4dc8b5aca1328a73202031235a0af833bce21087ad2ee4e9557393eebdb6ff7d719788dc1388f37f3fece6e00645bd15b2d6a2d2a29e0d15beb998c168aec0fb2f33782b9bf18310dc18098dbc25056db112f8bde4717bb9f6e7687bb4013dcc244b58d9a79269b2984546306773fa8fc602bbc1bc18d6e56423a536596d44a860f2dbed2a04473dd61530e5169f6da52f790ad81a4001714591641884f2d0dfcc755015af4ee670ccaae1e3a4465aa19efe24833958a471f4591255d4dd14929a0174efee3476bc059b211539a736009510b5af185b453cc34b4c00125d770797ce9550146c17788f781995a04e4f9e3cf17b430397077f53c5888183307879ff12c946c75eb6f4d128ad0d8a5218557198f28ffe2444e2d9cec72f79681556ef0424c672e5a3db937fbd04097f73881585c407382861150f7198963260de053a69614b576f875474d3f4e6c0200ffae24bbb2d666db6b08b096d15d29edd1874e57587be94c7e38b634625f3d67fc20f27c9deacb2bbad33c918a5b5e4e90796e8d95f71ccd1f2df7ca448820878fa0c6add25adc636ea407ad9f09718d11473c094c919f876d231b816b72c4aa8387c8db477fc0bbc9807398a7a08daf05d2ff499897419e6bf8739bd698a0ca811b02d0ccd8102c9bfdd8e438dfd8a4f0b571d916da3edd8975d6b6d0a6446940d881047904deeea14382d06c20b9cec5672cc22c9b6f8c21f3ab53e1a6a5fdcef7ddb5cb1f58cef595d1a9921b1316ef66c997fc3f8539ff9fc836160e7cd0c74cbcf45375ba0b829dc6847fa89e3797857c6325b2c196773797de8a4f7295adad119cbb5e01f2acea5e0072ec2109a0da409c4e184c50ffcab0b06dd7b51ee9ff7c545f3685f3d85399c3d9766dedffe3889e4622d3c777282acfb9bc02ebbb071fcc3066df96c18aebc66ec229228ac143b03d7fbc018f289c0359813fcf123f901afe54c81cde68084d6b506a1d59ed4ae35e88f4b2ee6fb3bccc57cc3515532ee2b04bcb618b1aaa8e6d598f1aa6f5995daef499a5b9575d55a748792625efc67dab14cc96d704f67c18f8c5747e3c142a1eee7d408c2e8000cbe0f9e26d2aa0f6fbc66b2e81bad7cf92e13802823dd428b690fc61cee58d10fd09bedbb784a1d8f70c49fdc1568668368af24b192fb5948f16e3dcafc1b38dbf639db88687c56d4097db99be449aaaedc98a012d38d81aeedbeec000e887506676c547f4a9e273b68d72d21070b903a7232ab4c3289d05b04d404c728578fdb1f8fa16c9f959cda3e73e797219f0b3b00e2589830bc35e75f8de66c656b16579bd00ea4de7d31f06e44ed7879e0eb64c57e84822fc4cafbd744baf990694b5351646fb65813fa5f6d511add10f5a0d77fa19730925909a92c63350345231b3ed851227574af81cebd65047c427ede66310f312f50522c591fc2a164f1d2bb0290f44f2bb8637f3d5d668077ad7d2f301870ca9f2f95eae4be228ebb1f38bcba5e21453810f675c3ecd75ac9bba14bd85971dbd8bfe73a55a560f9adc2ca84c214def87e2a6aa0ba2aaef88645d89e0c91dbe83afd4aa2f59d329606a0d464e2cb6c6b9612d1c59145bd2b4f706795be9211d944828a03056b480916523fd399eef26d80bb6a491298b916984a7e15edbf1dc599c66112eec3a8b8f0f47c31cb347df2d3de2f839e4d08538226f9edb339543b4b42da35faa4cbdff296b8cd9797adb86e886345e4c486192383d0de8bd8df0b19b2a82b72b1d933387dda28ade3dafc079b77463c6b872c181afd3cef9331b6bb098feb07150ec8a63d337f51fdd7c85a73fb891d75a490fa8a04ae2a2e9923f07ec404c50878cf4972f714aeb33102f99384e2763a6fbe26d574c95511a8a9521fe380ff30b3e976dd78ebd7d9e07b43f1b903a407d60dd350c26ae8b54246c3f7bb2d6f3ca712363be99976a85bec86d6fe16319a08e22ce8ff6ffb069487b7d36f420da90e63da190450625c9d8d7b4c1f4b4e92d92be212ea287d78de091d77029fb409b765b84cf1069309711e8293d796063089605592ceee58f11d5c559c688a1178d8eaffd02dda206aa146e8e5028319805b81273749d525f7f1528a5ff9254004f486e0e27e02a6dea456b175a245d84a1a1b2da6ad6cf419f22bdb66845822c97fcf57c5aea41679ae9a447d0aaff82bb5ae61e56ca274a426189979420882c25e07e7be2ff64c77e4e13a2bb93ffcbfa154bf714fa56e71e06631b02fd8b3d708a3c65f7d81699f99dae89fa9a4b58dc3705c7266ab1fd934b0dd8af5475e2fa5410364deafc7aa73bf030293ed081f11459765c9eb2617f4c76f9232a4a73b1e6b339890745664e9a55663c4d3f2e1537abd84b387498cc28d07817887a474fa45fdca4d6b9fba7f82243203e57a972dcbdff083c4066b6a096356665598363641e4331df84eed4db02a0b7a88d8b393b2abfdab3f10a04066bc26298ba44fb81ef0345460933d27ab88f348563a7b4ad73c36dd0a821ee42df03404bff763b6e7655f3be9f625660deabc6b3fa21ac08b73ce4175f5d6e5961be7a263df9ef7f52e5807a9a89ac876b81ee2817180c5c9876cca12e9890db3f4dd087a7c16b3b330ffc691a2e521845434473135a2bfa0d2729f74a1fbc6944bda91814f6331d1ced9f1d0555a8f0113ad3f81f801f4194378b1104ec7b6715fa72fcdc3166be53fb8afa8c256c8b1d6ae2030bb0c897aa73bbc770c1922572dc498259ce9bbf3a44dc528359555e6d46f966ead7417b3264dc71dc675aaaee297f6bd3e46abc0893f49be55789e0d8be34001b27a4271ed3623417f51c3dadc17d5e63cdb9baae5ebfd0d331bc0cc60110472504b01b8bd20f8efc72cbc5bf6918608ec60fc0a4eebec303c1efeb071f384336bcdb6371ef6b736ae85e2b825dcca6deaafdcb03fdc7cfe693ff510763d9bf9b2f29dc6d8ecf461078ef37fb9e2c90511535967a6f5c802d3a89d3ebe82261b04e7ab022ca3a6c6c5da0337796d1ff1fee5abb1fcfdef077790064bcd4f20db2fbd32e312491a7aa870d972b6acc8f52f32bc1d89f199f2e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
