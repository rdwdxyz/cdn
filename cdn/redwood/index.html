<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a21308eb8f4b16f2fdacb4d6c544dbb5b1f64b3f569cd652eb1b0890f55d593b142fa7db5e6847d39c03b6a4d1ed54db472f1ffc877f96e5373137ac705a768ea89c878275ef231f0fec067ec0cc7b1ccc8ac1838dfce11e9614a895d65f2480ddd16027753ad35101ed5726be3325282f713d85920b81bbf1ea7d40c49a9b874d5bb9bb2342eee1670d748dbcd43145f00f09fab09f39f8913752bd4ebecbb9f0bf0e59b93cd2dfaac7e1a906b8de4d4aaacb62fdcda81b044792ca52f17d3b3a4ca051496ba7b745bc07e4ceb69a8d1bcbc46c0d27316a587969fa7d58f38cf960b250f869d9c30f1ee6321ef0b63ac3bc6b9bb5989e6fa7977748d3a4acc186f6ae2a5ea7c5b523ab7f5e4108234bd787193d19b0288929ffe39b332510c8d4c8905d9c717af02f14748f35f921bd0fc9f8e504cecbaed5b30bbedfbb5d5b0ca1cebe2d7dfc86903591ba614436ce922aefa65b003d62a244e1a83f97c46fa1bf482cf60f774cd675b3801029b50b20a760b02e2f5da44fc422f154707354d53c8f45c4b63629c34319be010c81423b14b84b95883fc39ede72c91fbae7033e92a7b21fe4679e0bf2b38f83d78dcea89a016d487b06e1aabbb21822d5db0a4c6fa1612781ecbf7b1dc38d3a07274c3280f93da5b06109c05deba037bc20549600ad6ab3f04dc3f18a017c376ec44606b35c2031fb54109ba15b48723737a403cccf29c0c1d3dba42d7f99e82db28e33cd8845461173e6f7d5b6abe071499fbf3440b9091719b1fe6cfc61665ab4ad93fe99f1d14a9495f3c3162f506e0d97e2108c56a0f24a2c05435576416701ad1846e541512d49fba2b8ff8f94cd47c159385c3e49d79018bcc40e0758471462cec9043a096965f969c735df38d6925b070b7f19a695b32c4c77f2c4e1915f9187b6c3d43bf85045313729653fd7be3f76f5ae18eafab5532ee4c0dc7f99ebc09a3a04a70f630f413c9670014f81860b9ba2e5b8c1619335d124d0c32934c4bed459ba5ae06aedb01b9d4c7ebcae0a73ec84b11be217e26b41209937e0620e1114583fd707c152b5f680566b0fb6f159942a5e1617279948c15f237b4fc83baebc1992f3ec0b3d20b6297f4e169e0c4852b7f3ff3b097783891bdd6d78a4f6e5f2989f07161bffa5d265cb740847b6272b84b8adb0a649b9807d3a02f5b40f53dac537cf19a340fce2a424f361e3b2abf6edc4b3dbbd8f5ff7274d11d76e58a7a806d622b88aa3fba2811a3667a4259c1e55d1aa0441121c29ab3082566f010a84767f8864d6a2b92f088a50d9611f408a63c0dffc3b5496a8028df667114eb66411bc8383769815d27f920028bd133db1adc07912ea6e1de80ea9b32598098b597ec4b8e483d5d313d1c617f5909e5c27528432b6a3d10e6e31dddfd6574eaa8c60636e504f4c65add82ea47f6a1027ad460e569e23cb279ca33526d0c5d60fb25da53e3615e232d08b2d89350c26fd1742967796d098d431ac8289d5e19a4b61ce5e238ef15f947d83d580e90f63030adbfc96b259ed2d50a061aa78ffc58a2c03f9ac721c2c0d395aaf1c2514717028d7bebb70442d3b90767ecd43d20f6dc9a0e7418e5589c6ab59d2251b1e5c444a7be9d03919455c1e0cca2d9d42fc91b609da840f472b4141313c3dc91ba3c45551408e99cbbaa2cb81eda0072ebc01f89edfc9bb098066ea74560691c182efffdbce52c2e51459d60a8ff19ce005fe804aa3ddb9740c5c191701dcb9842dded92493a3a8c16e458b4cd684044861ea10ef9633724383779a858aea008a78c9e573f7d6011261807f35b44032ba6472f88b3b97fa2d2acc338dc2e3fce38b92e16cff575059bdd8c8539f89051c0ff1db9039014054816226e14a493bb57e2cf1325b678aab0b43cd2131b40b7f8049554c0ed541f7b7eb1dd14378e29c1e49157961a483cdb12f08f871a925ddc1ef451e3bb2d34549d5c792a6fb84fb623018d4d7529a3ddb5c19c518bbbe8d8689bfd2b6f5d0ab98ad8789ac53bfe596aea02682b45166cbdb21f1eabb332f4cbb2ebe202109b5f6a12e42a60d864cab2017e83cc0cb980378dbaefbf7a982d60fabb37572aabf91645cbd9f60bdaf2cda2a3e9babdfc70bc9117a0fef505282498bd978ada4cc6ab347107468abdd623e1d60afa6ae4c39a3c90f9b5bf2d537f123ced5f7327dae6aff6764070c25302cd20fac368059d66301483083f8777fb5f84cdcbe2f4c7a537024d2633f56865304e7cc28b391a99c6d7268aeda0d6b4f0ceebe13da1e8d1285de4f555f0dd3a713fc9811b55791ea484aea7ed959d813f929b46c12ec0824191d97b4d9d872f32b5bcd0d3b716e6cfed20ac4ad8e3161839c54435041ade8160e69134e682722a99c17950dbf8dff96f872f8c0947ce02d12f565542632f4d451f137d7496e2300e6c989296d30391bed89f241671da22c87063a897d9ebd0dca2532f494cdf8cc356af4523646db460e197f45aecd832f8ac3492577ae9f23318c2840cebdb65e898d116dc6e259a79c1e002c78f86414e35ed5afceae3975c85d824d6b09beaf612705f2a85101373026395ffab4525e4ef5cc535f530ba169f376a6b8e01b059c8116fa879b98e20bd008c3edb1581d15fc1e80074444f829fa0f9dc7aa5064d16fe84b0ec607d880c40bc2a81b6cf3c68a5fbfde38596aff35ff8a1da055395aeda0339327ab52996a098b8a242e51257bef1d281851a8e25019945addec3b082fdc91cd71d0afc2041364d7f71d1b808377ac68da4e87551715cd67814b03e8775d327657e92781b4daf83332ac3a6fa50ade16883f29d0df96d1ce41dfc511413983df48e5b31bf3e07e46787e75d4c8b4e3089c424a57c6cec12bdf92c913ea13acadc8819250a3cf453c0948b7e108bd342052b77f04e83ce499777f1ff7775b0ef211ddc9ea9eb40824fa300d39544a3795841c697d9a2108e649b8aa0688f2880254f70eb12a7b30f5fbed160a65e8efcd2b1fb2ae984cbf7fdeea6f57c294d9bcf522b516b192d8cbb184b71669f94d808d936c923a850441a20bbbaebd8c63603d75c54be1d47e85d75d059c202ef9027b4ba31eb19c249386dd5a79d67490555c8bc2c3249771e5625dec959cdca4f90050d098eecc586cb48704d6847780108eb57490f8f326ec263da4608b8be0649bcef9118f75c908bb0338ed8bc8044c89cf954ad608a9eeaf7a7c35badd2e07621de7ef5dce16209c4022b1e128c2e6dee8d207bebf35d4c76ffaec1e3af9e9b805fa036478822a2aa8bba6ab80676cffae83bb3f58e3681b0fe8d8284a594cad594bd14f4d54994dd8b658b3ec754b1958476ea9e8a8d98acf6d0a8324c5747382dc3564349fd349c41e2b098f47185812c8a94b3284fcd623eb2fcb985015edf16b5dfbed64d22aaae6b29c7a4c84a8b2d19c96df981418e99453a884077277b5578f1fb6db1e9599c55793290cc6b35cea2de4a968457cf4e635e4395c5502d8f695a63c0577563d9506ab03faba83e50337ae7f16c0677be9adbac7109794a7c9bb557614bae5023cb647197a7828b0596b978dafed5db42bc56faf060c7c49b3556c45b8dd69aa4f285f7b32891ae8bb4d99f67303e940b74d34f183c2994d4cedf0b8e30c722d24d66de11fada49c7afaca1f3688c57d99dc6e1888bd756cdc3fbcbbff372eb5973f4a7f9c0aecf245eff0a14ac22c775f631b1ed64169ed9f063e00c8e786676dbeb1b9241e46ae14d4fa0d97692f833a501bfb2168f2ca1a01e7d757a1446455f6567e7b17b038289f6df198478b5ad466b0f9805dca1f8d48eb1ebeec8f7ffd8a3d99e28d7c74ee6a597bd022b1ecfe41663ec2618f147713005ce9af69e3d52d970bc7d06541d9b8eae86d5db3461d8770980b3bca7c750d0f72d1913afd236a10b6744b0252d8553557f4870b3d2f261c504be67ff5b884e94f38df8eadd000338d9fb5a867447cb36ba301b53f6530c2d22e86ef2b29ef8b46078d6a36879ad928a4840ac6d2a5dfde06cf8229167ae45a0a62c0cc404aff8b8c9aec8dd7c04ef203980590ce881a309888a5cace523e194e42e254e2fabaab3b1f0dc5b460491fc7b78d981f155e3def9340673f1273a77b4f8b21d2969d166687bdb7b4c3423bdb5c1cf1508ceb9664cb410439c015b3ea4b662ab5928718bc64f499351d761b3ba42e538a0c0d39e82fd74d298981dd28d255b092d2c9e35f44a3b5c576c51af0d09942c06dc97c2c1674bd2dfe35dbc733303b7fe0cd9f86e380d0fe7d8901368ff1d1cbe9e26ccb9b5ab32a6ddb69b6822c62c5cb4ec26bddbc6982c5fe9c99c885bb0c948ec711aa6e19362c58c4be2f5bb46e95ede6b0183aa3b37cf939d460a8f201a40d9b02106469775068813d515821c854f387126bb4f465d80ddad6705298813f105e86891a575eb284b1d0dce001bbec3e2b5f173da65d677cdc3651453dde767150d1bcbe0f7ced5ff106c32b8eca290320415365be3a28322a7225d3a4cdad0e1787f023fc5564b815215d2be3f873cb04b89b826fd3949347a9ecd79db8629074d045adb3ad876b9f4c91a66b39c4a1b281eb46d90ec4b263a93e47f8d598880198717928f48f3e11fbf21e864342641f766e3a45368e0255a9bf0046ae49a6de2001279895d981cc58b7ecdaa187470bc6a65613623a66c05066ee8306904236f8d13924198dbe30558ebece52e843f5da27fc790fadac74e32cb58988a7495f3197ed3183d04274281af2d0ba62baa5a724485fdf301d1499ebd567b943100629db39f596ddaec2746bad608e1309ff0c50de599c21c8a3d22c3fb4561cb6fe57600e8345d3d4f481a6ed7691b0ed3d7f648288359b468611c564ad4961841529c2aaa73756c074e8fbfbe8af607fc38ab1f58c30af1f34e62be738de59a7b52030ca009cd535b48b3d3b0174007f34d622eacce629542452cbf0eb42d2f3bd2ffc14b9f54b24708762d3653067082a731ed7780bc1472846b48706b2afe20ade30c9223e420aaea69f9502c576d613223414d312cc59e4d71e3cdf23f952d689cd5460a9baf54f9aaeaa019198ffa7eed424c1851e884a08efc68da354558b5a75a31938fb5806be4be2a42dabe3214959446c8d7292ff9bca462648f97bba741dd5b536639cdcc55c8d713db7ebe1ac8ed858db50c25d586ddefd4017cf2b017c8c8dc12b385bc1cb12d27a08f5485a133df7b930dbad57174d81435542f8d11a240aff090127aa862c8f2b6349c377cbfae32ded80883732cc361c8382b189119cf13e6bb3fbd136cd401f5922d13b2f20ab533b62272f09d36558ff17840f4d31c6db039d3b62eb6465875b8dfde134e1e77516321c1cbb2e9ad6c20327e49e95f2003039ffa7f1a70b4ed30b4a7d31bdfac20703ad83d25d1321e4c8213b989b0be60d03946fdc856ef2043a4fe2c48cc83ea27e3b4c2ee39694edc3a2ff04b4d1bbabe9e0e576768fdeaad6af0549e8e33994df32811e4a20d216dc40e7750f00993d5b302f8b0578743f57355d2f912d84a71ae407e244d6067cd0a52d965443b1b49a5855452e567a973be1ef78ee8241da3ed7311106750ad8178a2a9109435101c9f9d6507c810818f1aa7619796458f1dc528b35daa0fcef5138dc3f0e0eef072e244fc6f0acd8d935abe493da79b6e12e35807aa80b7f0e45b10fd28a7eb309b690d5e2237d1bf652d8db0cd881e669083e6ca0dc775a188b75a81b298c87abc0348e17225ff6e2aa6a79b8cfafe2991e5d4e683a158c6309b14544d97d536ebeda6d75331a206e6ac333c3aa6afb75d2c723ac1ba482221f2f586f3b63711aa182e66994a9a39241b1b9772e1b3c277352d4e6963ba486f8a97bf129f848745ed80673efc75d93403b1646d80a2c4c9cb40b7f6d4871e5692ffc735543a690dfbbd41aabb991feb41f150605890c520cede37ea2afe60754517d91b2f9916ec983cbdbd5793eb535b92608750655c2c010f0a06660e181703772b58270f496c9b96324047c6ec31540fd842b03f05c6a6b5b18e511e53b8dff84cab179cf76ca113a6b964d9f02a2865fec8749ac1a3ed3b3155875c9dab7e2332517babab71e50008c7ce78cddb8ae38848614e01166d2c691582da99d16e3145943f513ba18e6b6052761cebfcca8c08294a5b1027ad2c11fdcdee7ceec6c2f351c7229c033d067d78345fecd741f3e4cd3404888ecbd2e88956bbf7756ffa9432b18d010a7cd416e459dcb4a6f5a336d22ca8088103efdc6aa6648f13480112acb22d45e0f5a416afcddad6f3bff4d0d0d878fd2ae4353bfca56b47dbfc7d4644a1ce4d6c22ba7ba9ae646b7bdaab2f72ccfd50cab3aa846900c055a9ec07e150df5a56dd12a42811a32a4add68ace75c7538df4b0b4916310a3495cdfb3181b3616e91c68b53d2b3c8f2fcdb4a799a5c7b0eca9d6a6d7f2a28f273ed6798582019c7b68582dc403992de2d1b9e0c76e8c5291c10a7633b07148497bf49bf7a949244fc22ec158e29cb37efc415ef36d608994a673b20746501f62feb73c01f39fde645fecdae879f88b2f545a1209f1ff6324142f0eb25348d96530293c9874e9359d4b8e59057cffe21d78818fb202bbbbf2b7a88694a036f5caa4b982aed4e3c39e6af170b80614d633b24c4953dc96786b1e5c545105126751e88ec0f4320910020bc2f978ca7f35d6a2b31c399a2ba7d0afb9b3108bbf0097e1191ba3c17555e4bb936d139d8ea1116409600ce3664f14524bc36a791809a9ec8940b867cbbcade1f9aaa5cfa0ba03fe140dcf10f33e3f950e8a791da072ebc860775c277c35a55999af3c54eb0af2c4c5da9e098c245c60b5a68115980e89dab8e7ef422ea8dc97369463e9554c6e22f7c1cd3c2386f980e96333c7af213509915669949007f52997d7d857a2ffdb8609b883fb9b400029c940645f723a3ac3314bc0f8cacfb5c90496d0268f038c5faf929fe077db9d61df766e0049a1abe665bbc7b68b00c5fab3c621df00105c218763b66bbc0aac8099c2823377f1d73827db4f76f4352ff2f508b2035926f170f03e272774b6022e7e91a97ecf9159e8baebbeb98c68cd20c15d72dbfbda9459edab1b6af662d51f8685f0275318e4a49f48396edb5f96d7874adadb1065ce10a86ce1c03fc3371c430c7411782ac9ade04eb3ce18cf490b5f76c58c5b58245c8d3b545978a8f6b82e890991a3b4e941c9d2895eac8aa11ed39a04b1a76b0ea526c0d39c22a4459d7a91eb43bba7286c7adee16cd13890ca8c05cddbe45b6ca1106e473194ed380acea4aaeee0455a8e7c33570a6c6c9d5ddc435b2d2ecd346a90faf2e9ed4100b7c1028b88d10e79cda3a61b925631f21abbab49f7881a83c2f17edd6d245ade77eae064f1509712ca5b0a77348eba5cbd230a95d9f0d9459965e3215b78e5c1b31f0f35c2c678489019f57a6c1ba1f34a832072dc5d20f470165d0130e58b7ac3a0bb15ed6be9e50f84f40780b53380140459698dddf60726ec4ce8432c610326523dbb6f40e3dd37a5a6801891e3c938441392f0162db6cc86a98de7bc2a72b807a2b9b9a17076170387e7db452c2234d1c78e0cc24099a6ca5c5150b1511e9a57eae7beee3ee634c8b30c14cf276d19f76f81adc449ffee54cb9ceb93d22e6fd7c58a3f29362968a8cc39c50f03875813a1866f6e3c21d180da011b0316aade9d748a063e33f0252cb0a8f1679335b4d6da704b9c036d4de08a6e272808b182184484d33a1e6a45acaf496ee9ce35635dff8cca37aa9af72eef5b180787ec99b86e6728d1cb18526263813ce79c7f3fad64646203838741892fc74149a95f40cf766bc32eceec96adb437a2f842a50b88bd022b1a3891b9c4db8b2635c4e437c262227a10e0b0d6bab3d897c731d622af68e0c55e86316750e83e9644afd47a72dbee1ca69d9a2e92b74668bbbf409c5d93f6cf6c1bacc3c149d99aab27747c7a2885a3e54359585a5b5087356137362a408bcb07d1a0ca31892276b64d64cd3246f4badddf885c87f01bd3451f61776e7d959ae7ec3bbb4e14e35e0510aef56f8ef27faa019e33a83982b2acfbfadbb57d0d6b366b31e7ddb1680e936e0253df7da1b9a47faba03ff0ebc0085125a8841814469eba4e73baf0f235a1f6c95258cd0d7a89601bf271fd977886fdf01d769d0f71cd82e8d1a263a5738f11e5c4b2830f06aa363eb02a1d1b3fe2eede84a55e04d53cb9d95a40f131c6394de3c71d94a565c774a0c6145006cb6338e8b91a4711ce20787dbecc3cc210a101ef69c9afb833d5299759a2d1778f931ee0b04351d17a5391cfaa2e2473f2c4cb1cb988ee8b511e88e66caf5949e33f10db9d4d61c876a500f9b002a1f413e4d910229e9cb2cacf00e447ad4e17af5c7656de4a6b33ecaafd2fcbce52a992c923ac1475300129d2e6b385559137e72df925177f76224034f4cff7693fca73c02310443512d5ab5ac223ec78d6690743e24f269545d16b588878d82a99920e0f731da9b795a012adf0d1228fd7178d586edd0041dad4ce7f9d67ebc03b9778fc0672201117ea85b8fdde61640cd408e3df733412c38762fb3d0baa03e67eaf9ab7128419b6dbefac3fa1d4621000e7025525ff1911fad4bfbaeb62b48d25de43a966e2f9ec390ffb08d1090957e16e2ba752f35cffaf2e7638cc099f147053874a37548177f4633eedaf5106ea834e3e707db722eb3f911913c383eb6449d7548ebea266d14638f1ca671c1d015e36f686a64dea5eb7aca396f66d0fb378081f576ffd47d6c70e442a0396a48563ded0dc4212b2d0ce4ee87101b77f0826f6267b2900fcbd03a8f935d46b5b54f654a82e80a7d06d421f5f177c08a802e51b023b5b8ad33b5dcd533e402733086402c0d022c68f996aa296c27d31030440c235a6a74cfedb328674d1f245dacf20fe818079b54e8989b10a3eb124a45ade7c4bc22a9b533ced2eb80667e3af6755a7be173e1dc51d61ac02cf8b8440319821b9bc1bd1eb3fba5d66d6d84b4ea256677f606e53e60a05cd7ba54f9ed3f82b1e630950467f932ad975af861057ada4705f9e9992f70ff42da8f081a6065862278c8dbbc80dbd91839ddc9fea7b62ce676e0cf82210160b50deab0035288f3e27404d446b296c1ca3e2d9b7623c73092855e889dc630b9c8be67a47725cfbc8cd2bb1da1d3573db175846fce926c7e098f6cadb4c9b4ede75418d39850b0fa00cb32289e06eea73d807a82496eac3f8e9234968279fdce866f9194a218963538c988f426e4b8efd357c98a97bc2d19aa09c8965c2ecf557ad8f60a9f02dc1095018253af536f322b0b3d8f018cfea762786c29ab84016f9872405d1d76b061493457cd2c046b6c5f67af1f0f034fc1bbfe2fad03470c62f07f0539f760b92261b981f665081ee5a2b8a07cab95c3c26b3623ada40f5097e502ee29784f7423abadd21974fd03d9bdf065000f0f79a1c3734ac97d39bec0248a5c9f4c2390c7361156b924a96e839a7ca563676955a3f41451858d9a9dfaa55304be82cd02016abd5c8c5a17b7f298c8dd3553004bcd4bec2d51ac6b2e5bb4e423e56b6a38ff445d2b3c1122cbc6dc6877ba50f6e67112e18af5e25ac90ef2bbd4051b3ae06361e06eea74947fdbbb9f6348563e8e8851e08fa417c2da7a585b2fff3eea078df0e129b695197b700ca1b7a21771a1cd334ff986be7ad6999563824594c11115f13486d5a9a4e8534c09ccf4f95f84c59ede7091c776d5905121c45fa2d76134852a0630e64e53a12e01469fc014a712cffc87bb3405a464b63120082dd9df0574a47105ab5c8476c484783d6112c18b609562d95d57a00d5cce03aef63152f97f18308651488004881d42d8b1b9966254d159b4a0bf11a81e7ab6f09e303a6457194a42d3aedeb83b0967111e8c054e8fc3bd3e646c04240dc71299373f935bb1b2892fcb8784ef585523577b3557b10bb54945c06b89ce8d65899f033bb067baaf37cbfa0644976071a40b1dd89c8a7bde60957b6b1c2d2864b7f0ebb1a494e54f8c779f5f18b8aaa3cc8abb6ca46110a8f0c516f7caaca19a1d7f58b0e47df094f82afd372a646161a110b67e53641ffc41e89c09bd905b2319dd41a69da0d948fac268f5200dc426f886c681c9fc06bbb07bc2b5b9f85c888c554032c1580162e7e88124c192d0d1257c2f68841d5ddb0602b0e870b14821ae0ad61f91753535c917a87cae774a2206efed5769ba1f858d7cc050df40a4de69286fc51619fee0ddb42ce16e69669267fa96add0c6a23872f104e042bde780feb9472413347e343355c299846910c4e372585f812084ca558b35490d83b75abd13ab2e99dcdc0b5d997e9483cf326ac3c73aa737f99540429f623d7d70e62175f57cd195d21966cee45f16bb493c633fb50374f7d2f2411553551f7e8e7c5ceaf7312df0b862420d048ff9ed8a21a64e7614d43e2090f15fbb8db55a615fc63a0da1cf5e6483df36577a8ca92a4db03f4dacc360c5a0b33a5694bf09fab51a0efa5839613586830a030d3e8853a7cf211fd7c72bc2ea6be61d9d476108acff5aef8da099daaf60545accc8d0cb86d0d4834b0d5b2d0e22b1803313e9fff52950cc20d218cc4dce783418c7d9c1d1b363cb7d865e1919d047d1d84409f55ec68e6521691f9f7307d58ee6ab48ca93a7e0dfb0b82e508575c2c12b2e3a8479e0aa96ba0a7c4da8a989110021bd1709b67c606a947f6f64f57faabdecc9fb00fcf48bb6166caa6a001281ea95ecba974f9aa8cbc1639da46568a48a559bd05095aebbd6aea8c76dc6bc0b71014e9c15e30859c630c9694c209b08ede732a367fef2e60592450642c0e5acbe476839ea759b9af90d5bd653998c07ff3cae4f500c5118ba6993ef9a3e91bf99a3d98bc8d49f8a92b91dd2114234810177e512beefa6f9c87192922b2127f75b85bfbedeea3e86e8348d2ce5d7e957731fb5518fcf20823a595c874d882ca8af99fdb4200e83a4dd326a717dfe135bcd9afae9dc354d0bbfe64f7c458990f93b2ce82b684f3fcfd4318305ab181c114e42bdf96bc532f396fab0431f23cf6225df645041f76ca8fb2d33c1bd6fb67ad3c2e8caac022d79095e8c972b7d15d6731d73d63f45fcdf7b3dc6ed4a1a0d2395bd259a993f39b4cec4aea10570bb2ae70afb1d36c586e3ff0c3e3584d7bd87288bbe313af915bb394f33dfb07313e711e0f94805573ee192f667c78c9c929d33246a70b80db37421cdcf6d857c9278f0e88628459e1c852aa758fecd69dbfbcb2c11f05ea2e24320212b6c43c5972be84aa5a7b13ae519ea9965e3fc1c34f21df5df0e433caccb4532abe9406be4a3fa18728ad346298eee89032c53fd6e201ae3b81f7b68adce36ddc3d0b0bb909285072d8c0f342e5f4ac54d74a29cce8b199d8a5b992801b7d1c816aba7c517cef83d22afbc530343079ae8ed6e41ab5ed14abadb6b1ba158a0538c7b98ef819003e8bbebcb0afb350941b8aa90694c44d930672eada4ec9f7a7a020cc6c3c5f4369b3bc40a224fadc35e8ea87a617862d8fc8d03485dc0dbedf3fc9e5515aa8a55c6ec3a40f185442c3e7a1adb5f7f05df502991c4dacde9454393771a12a99c4753f4e5883d66231485c5b4a635d1beb30aca9697c13b11da2e31e5c03744d2e76220e730bb94c0b8816dea8ebad3c9aeb03a0e723023caa22cd1cb4d855fef179ad75b78402f092f39b848dc1346f7aae7656aff2508c5e88f5be26d57f8b3f0615597c5ee0b041d9ce51627a13fc9f30602e8502d4b840fe460f1bc35c311680287fbbd35909dffa2628607ed41bc9f56ed49694226492da83300c42c672d456453d37e3a78befc500c488ac32402da530c877c5a63f5aa8672984e814f3febd8eb5cca2dd23604513520731707258dc17215804a7fed1713d27db3f9f714aa8a411c4eb03550c08d467e4a7f7ac62e9b9f658116a20f15cd42dd6773fff88ef4830a469a40eeca32df3e0f023989d8a3e6b5a70318baeeaa750a62e01471bcb0dcb68175dc7df893480b6bfd8653689bed8ade880cba15824d87cadf6d56e4028c3664ed580b54058547ba33d4ca48d6f8f4fedc90aabcb8cdb52e495223fa7543d31629774e3349f4eb28338b53bdee21badd11a97c8f0a7c4cecd9939e91c0edd188b5045e076424fdd7d187aed53643ebab539c1fdb90dfcf6f62c2d34f4f4856c7f937f7dcdeccfdac6013de9dfb6b8ca3853807a3f9bd66927f21be48754e02f32d6b4defa5b7e026e43e2278ed13f127ed771508e42367d12c0a06d7f05fa7ed47e3028a26771e5985db02e440fff563fa03635b0950f5ad3688c770c3fc75df9577707bc1c878db4d67ed40a2b968b5f57bd7b2ea6799a2ac102a4e7478f2280b1cc8c115933e79ba9bf459c623c015c8c08abcbe9906567bd7eb2b9e6f96e5db907ff71db82531ff87932cf8c3639706f609d370453a426141f5c37c91f62033c421731de6513dc15cedaba1960a017d1649985cffe65501dbed497c348b498af266a67ea7471447698a10be3d5579dc1ca56dd7fb061097fe66cb8b05fd4cc218dcf5fedcd53bc24ab15fc82c42fdb0e5ba795aae43eb7298d04a94cd5fde2df72fb00fd82fba0e2c7e0de74530508bf7c5a38088e2e92d342fdc7bfeb41a20019a0d4a617fb120fa556f03c5fae3a08fad7e34676d5e970f9e6911bda8845b513058545dc91e9f6cd91a61b2688ccaa649f55bc406f7d1f8ecd3df8d1707033aa356fc5f07b4d07705de5fd0b89ec1512a838470bbe995244b844946f2e41996847ef987be8f4b470e480e662ae16957f6ad51e31a7d1298bd49a7df8f3f155ea2722001152d0e61d90212cfeeb7fdb2948db9b40bf926e6f96793f49e9ba0ad08e71fd1408c9fa87b446e4c7b1f915f96e2f38a252f88a16f9b1e87a52e2395c652349972423d9c7d827d23ec00ce6bcd490132eb4e83de14096756453ca3e377abaec487b2a96be0283295cedf5b33f532ff9b27a72a78631a5a8bb06a6c92d3d9b16bf5a7859296bb9fd3d12db0bf1520c3429602c14ef016d00cdd7bb180bb27794c3c7d9f135447f80dbcb39dd30e3462c2a88b0791dc854a4b018f54800bb9e8813d82cb2e68ad81e43efd2bb444cd52aeca911b4ed09badbfaaa0528308b0ff552321e6822b0bcefb7846bd8267d1bb88d552322ab34a758dd9d551b9dfd5eae44fb5bc3ce14bbc1b3193b9c196864332f30aebd8e3e5dddaf80d2c89fa3e23c0ae41c4003691d9f87822aeecf148e191e470ecd55cd01bd015578b40779736a0d622ed57f2ce2cb55f8719454e2d0773d4714b1f99e43f7884ccbc25068f259641fb8fcc6302397e4438aa30bdfc0dd5c39fac176c37bfb973b9eccd88891ece9fb231fb1446ea840a9f856a77325c0c9df8e8efcd5623c448231a30ecdd7d38cd8c6c1a6b539338caa1481a2f228b9657fb294428f14f5f479f76744cef29f72512edb864d10adae0b0b5c910f6d03bba475cc9201afd0fc21d3a80e259171cb5e1e84e1f9a58ce3648a3f30a9437323e3224860fc1788eb3be946e53e8a7a7a29be36b1e1fbb89ba1d637e0fd2f258c5866994bda35b8c499d913282da1a3fa1e7c55bb1b6ab779aa27101f7e0a773a242facfd815f58a99256f8ea7af3dfb09457ad13bf759661da407d8f8e5e690cfadf884bc1f5bb682ecc4acf17eac35813591ed23d8b0cdccfd802f1a548e75550a52f7f96b936abdc2f449a1f7511c1d17f62a03d320cf0da4314bf38740b056cd9057180bb54c670d688af191b97289ab6c03683f86bfd2c8cf54a5173224ccc6ced60acb23e90babd67f92ef52fceaead33109f9e3cc1e16303c93bc5b27370124262c15b637e5a306b41158da00d55c1faff64b66610ea1999f129159e02de704d39031ef0704a2708cc8fdf44c9b501d545ee21556388247aea7de22b6c0d501f2c2312bec916784bcec204bdd14dd8d6bd19b35c2fdda0c64869aeca2b0f113ca312fd05fe053908be48512e64d23d80f070ec94d36ff73d34dce14d6e22296181fba6f457ffb3018065982107f6519af6b4b5eb739460ec4aef86ae623493b51ef5e21ac48c5649f8a9a115e9b97380fbdda15a9c62a5afdc8aa578e760a4b0fc6d9c4760050d97a0d59627dcefc18efc3ff540461e1390f12955d874d54be143da338853da9e19afb39cf6a1d25dadc091f8a8a25d9256890117f205265ef9ffa72a6d144f1faef4da49fecc6816a1961d605d653665458778ce022a38db62e0873e426483aaa30b91f45cd4e3172c769a49623c28fa61cb19473162d559819c90a8f18689da0e704d7e1172d89368bfbc36f7d821ce7debe698efc44c2198013f83aaf86eba5ac5718b362b6d6c3c7b727f9f12753dcb5375536755feb4c28f6c89a32dcbb2b9945caf99d2a44dcd4f74aeb3cd9a6eb7fc14f72335259e100106335c1a1dfab0d46f85cf22a3e9044d6047e8cd04dbe57759c156ee7cd49548b31040133adfd238c6533e0eb3de574c721806675f460d7847454236d1fd1b1e201b573e553d90f4b407015070a420e1e2a372dc94c2fe45e06d8eb89acf037980ee1396893cc2c698a696ba90050e6fd60e1135f322fca6608467ae379e22305562b8a34011ccee48bbee5a1ba5ef5c7fff9fcec79cfb8a327aaa57d62d2b19db350bb311abe7cca05ab3dc70242316d4e92f26dacef302a4ee0167f28620b85469ed78cca456889cacbcd460253cd58b25bb3b81b9493a08b5e01d41eceaeda4a3d7aeda9e4c073ddad7a9cdb349eb5481ba779975e3045fba9c93d9a8f52098a19519db7aa2059943defdec7c1478f1a4ab4df0453c45da26bb9502e4db3ab7f1b37c5c872b05169df48e6343637f7f8efc5b344fbde2bdbc50474f39784801949d3baf4495c38fed499e6267c123a43ef174d8cd6b58e72a59b5d63cef57c59e056886362b4743c610129e1b9a3b7c179d1c48e303912808a93fb5111045df5e94e48573ba42fa483f38d5266d70dca7ad3a23c797ec4ec9207ceb073fedd63cb5a60f0320bef8003243bcea7d184c43bd464e35c47ee50faec390fe5d3b0dc1df2e75e15dba862c7f145a38d6983010c0552d20106435c632cfdb6f55084cbea9a7b9649d55dbb7042a85ececa8e05c803374202ab8dc4510fd247149d6863a34526d9379b2adcac7e46b56c8f83a2ab288d5112d8c905b1d1a539bd39f6d2105c7b9c389e35ca6388a22110375b36c4c4b7f271cc137452a301eadb0e8235ebd0d0d7a35085de6d868371cd4e304c07a77dcdba89d9524616433b04692ca71e5bc6c34a0d408d6b1c406c9baa42c3b359043f1a189c235df61b3c4bb5920a769d39cd33695c7e88098da4c9f5a8e6be81d8b5afa901dadcfc708931018833ec0b84ee671491e376ac6b80ce7d495b566f8e8852fce75849401a57cd93a29daea16900676f09f9213eefa316142974eaeddb475289f6f963c4062171011f65fb4701cc4bf35ae5ddedf3a964e809c50fc99ff0534bf524462a3aaa112c4e7729a58a69d5bf0da4de5c7e8bb99b80036182d0217c52839ad97c9741ddd6be7a2885621c36d79ee1c347bf382e3d5ea24f87d1edda883c5c5f7b610c2bddd1bfd4c4540dce03839a0a2ea60286e5711def179bd179bd29913707e8019a6c8d2154c292f85a5586db34b0c6de28a14ffed92e2682db2be46882ef68fe8f3d7913d4069a8890f0c2defc1fd62da4c135c030e22dcdf1140832bb4aad4e1bdc0aafd35fd9b211f4bd7484ca97f5c37698f0f6e761680582f15ed3f15b8bc85488987b8c10331e0467d6f09f4ce6da2ac8666a5c009b172577f5558b88ca00803b7cf7aeb638362865f4337e3ec6540d78d2aa0436016bdcbe49d47e04a41e2b9f41c3e76cf138a4c2a7104d7138a8b40131f1d612f7618d8005fc395bb6b8d7103e1f80d3a2dc59a8ff8aa30a3de9f2c9faf04f9ea8e5f3a211615126b29aa57b165cfe3b901df34bf4513ef753d657794271aea40ae1f9ffa0d6ff27766c65d7746571152a98f7f56eef273d0aa2e320c6f5a425c07ea75763c6fb0ae904ade853712cbd6b80bdcfe629806e95274b69e0964ddc1af826fa4387237888f99ad014c57ff733360bb66b6a16f417d0cb51479e096c3cf4c33b7a1b28c572cc6007caada422b1811ac02d3626731919864e4e866d48397c4c8bb663efb248c97df71765931f487d3e2675ce32fcb2c3689c0ff5e6159780949b4e5f4c1de0ce3a8baedfb3cfb251f13dd7ef288bd27ac4738ac6e159d0d72629a03d4035686360d7ae5c799cd80856720049408f8ebe362a39dc6ed3441d10e28e694ab0f21a2b69df5628bc3f90ce3e1c168c1d4027739e84e49ec54f9336b90dca7aa5c0b000b700fb63c29322676dfb20b7f44a4b5438751198aeca22dc0750985f023275c61052823a7c541710a6e18655d18f4a19b001691a5534e4451467b4385b3c61dbf893dc3cad58f85ee964df4c37e2cfd6cd4930ce44936a402810cd2aced1eb19393ecab2f10ef2337a3bfb130e0629367044c1aa8545bf935f853bcc0f98b692f0dde5fb89712d385ae46f24f816ef7f5db8a83f13fe19f9a949ec990576e2ad7dd42ca788744131de547def1ee097b4e7633144b0aba75665f07e06ddad63271dce104fc1c604a71f4bef0b578224e56d793d4b0978fedff61a9b8750bb0f0aee428b8e81400940cc721a2e9d1423be21196a2c977191a242627bf0154a0e9bd03e34647e3acf4537c49816902b991f09a1fff06d7593f95772c5095dcde3373626424f58a103f282e8fafcfd436e5f3d029c820c4c95e94653bf35e67dff5c9e99dd13d9a246811c61a05dd8f505a1bc349fc4fd3ac3d07777e37d24ba5a2645a4c34d1bbdbb744c34927f514e5e775cc6561cdf9cd260b13b1ee00f309b63f91ace99cc624cc6c722ec7256a214b99e7d19f8f625b5ae35667f24d44d1f45591ad220cafa75f156948123cd7ae0716bce80aa887fe591e6860805446a2e279ab797009dd87c66cb6794911d2774ea0d610514a38872a218acb4d6b5a85545d8cde1a2ceaa00044249854a83135037bedfc291fc5477bfb409b491563e355465a49e9bf3aba7aa8f7f1832a1d7705b13bd841a8d46b8856bedbfd13f4e91730ffdbf4054203c846cb294fa137b33d3cac9403de1e598a5a1fed331f2ca9dea50587031d9200d6b307a90741cf71de0da9df95e9d391026a421be4425efa692a379402cc33c6dfa0bd10f679107b12bd3305d0519ce0fe0e084046ea209901bdce0c55987ee34b11367fe0b48fd62b6bdbc82004d5144f3b4d6e88aab79baa55c4b908fbf568bad4b74e008bd00e2f8b65d518f9f5e80b82ee2888b55aa917d57fdcda7d52619c77ce8ad7bbf8b50dab9e99dc50f0e37dfbbae1e8583c9d68c9edf4109f4f9731c2837c6b44086d49a00590d67127d0bcf7a2687ea17131427e833d4e1e9a0ef759d8cb0e076aa4c56508c3d045e25edc3b5290b3cd61c90c81e34090805d6238f40394442782d1f2df236a3cf666a33290cdfff1b7d58bbcd14100e357ec95be7399e235b5c0e07c21126256abd882f222202daf9c68985357b4f1a2e9bec0e85d6f0c7a65944ad2edcf721458317b51585e05535d2f9553871deec4469fe8dc262385cf42fb143024e011bbfbe2bb027806614bc96b47dab4d51a879018cd165cec23ced71bc741be53a74f4251dc90a7a4736356357c985ef9ddaab3771298c0547ae3281156103ffef3a0eab8654670313443ced010da40b6996879a5fe698312e5ab436623c313ca3dc311edc326f4f682c3a51eba04c46128d4da2ebd47b9cfb0c14001a9e0416dd76fe8a5e383b85be147f06c82eafd86cbc18a144afa998b958746e0ff387b7a06dbbd416532509ea874614915cba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
