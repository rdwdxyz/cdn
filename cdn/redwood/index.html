<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f07fd0ac2c5ddece623c05bfc244b4d3b0238687b0129479f93c5624c75fc7e33982f6f2415057fc40ea48f36890e6ef773945eda902ed34826469508c8efb072821be4b1f2b12ab7520fba84f82191e63baaeed78678d5b55e44df02e776c6e61c20886608b4a5373bab3cb245f1f437fcdc53b0193275a9aa4e24b851b24c0050196f00c638852a00dd996ef4deef44292161487d1fac85edd1256a7f7358aafd55e75b8a75b956cbc8e84307a10ef2e4ad3f9cdfbb81b923148bff9df22e78aac8f257986976d3070a6276c4e9e208fd70f7dc5ca62f88bc10661320bde3534e4eb0b0cd1fb8d32a7db44dfc8d872ed40b0ad6a4f3095be808f3f11674fb3bc0cbd62a9bd249085c0f34a23b620cd7c20548af0f8a077844918b9068349e2e27b851278b210aa8b9abd0698b7406dc6dc8158bfef33a8c0fc15d43a5afc1743a8fdf4e0a8f075b822dd78524a92b6f6bfffb3a200b5279fe24805612fc34f69a82562d2d06aede2453a9638f60d6fa691c50ebdb271740987c470e3dfc22f5e41fdd2fa0beac21f3beacdce31dee8727dcc7bd78a7f8bc27a77c3714d59dadd5d225491f18555821894564a4fafe006dc17fbfde112912404e5e46f360bd2cee8a96be992bb17ec11bd3f94d710bff04e363d7c4aee85b8baa593a5a7b4be41116cb4d930100cb8b12345d3e50ca64db9b49e932b32e47cdec5cc817c9808b7cb8209e35fea7fef07a37fbb620eb4730d6889c1c6776f21b6907fb30ac9e707b718f11f89d6825c165477acec12cf60ea646d8d58d01b8376d2cc8196c2e77fd5653d01a556632d45f57a34186726a85664d2c3016ad43638e8ef25167be8dedc632d665ac3941aa15bf70df9902755d5f836f05fa1b4ad3668632a6093e567174e8eb405e2cada51dfbe40c4d173f12a6f36b53f4b7dcb21a762653ccf5d0047607d8a64c160d07a208b7d0731cf79e95b7edc99c703f62991ed36c70a4201f1bae64f7e7de09ecd59635faca62d6522d47d715ea00fee4404baea3ae73d59395fb615f454c46cb48896f0731848d66c9490df6ad6c01636185c126472d35eec6a4a38afcc4145c644e5c8b057048c52b74d072af4400536f2c3ddb56169aab9ec68b4c3a43a457692da803dab8aa1a4feadaa70f7969d90b836cf013cc904bf37b557e712f397a4b2478fb14debaf9145b3615f09dc94760fcc2f871c22c2f1ee2bc4f5fc26183b132df1e4dc5f8685bd1e79236cf2733c2c04794df8f72bb17ad171e86f1df00771932cef9f83585b9290537e9218f32dcfac50897ed99eb78c64b67d3d6e199acc2b1a5dd56783180422b4c6b5c93f10bf0f349afff57671d7b4b716503f86598e00baff224ab25ddc045de7351b7f0e2fb519fa4d0d172b0a5bb75868e228239a813c7952d2f2e2a7751b8d6d7eee275c46860721ebba228348285c84f120f5923d69be8476d9dfbc2fc7a411a8a647a1a406df9b4a71edd1063ccd0ce221809e7815f1c543487a8d8e319ce7371c9c5a152d20b4d4314914a6d93f163440e283c478922a39b2b6d8ce87178d0a78588590bbb0131d19b0b389c5a410c36a3d5208541243787d25e233be622b6f34da28b74188eec70d274c6a3cd11d28bb90153714634a19bda64a7cef6514f86b69ce1530f79e27505a70df9dfdc889e9de7d6158b172a1b77f07349f079bf25767e8ac6f2a49d3c44d525d875772985f324a70a9f9d37a04223295b4af2395214b4b3007c9d68033d56a88a97f76daeef01dc34485e2ffcce1f2958244894b7591ca8ac1e3dbb178e27290ccf1c4bf1ef05f95d5d6ffa5319ce476b68a2a43720c0c844d3bfab4b6160201c74e63ae40f4b790d83b0b07642130476535a05ea59b1e506d68d9a141c6f76d19541102d06b5790bbbf97ff72093d97a34459082c9dccb66ec81686119955c6758adf49aeb39f82f03c2f7bbe9b169e5fc05d6e11b8315858f5bf41a07a9ad4f7288852d49445736307b7c013b3068bb67afcf3b9b14adbe9dfbda2766e5938c639fe160e4e76f70956c5952b2f5225e474a09ff00d9943d5555e5195f4a48f4b0d57b1de7da5cedbe53cdd53b34bcc9932610f381fdb724f9f25d13ce17cb0edd678576e39ab981f3dd75d354aad3ab92e49772c4a44a56e81d23ace256fa0f7172c7cbc85337739a4cbbfdd2c208b28863d98e0fbd3d9aac3f353535a636a7b122aa4eed4e82ad7f5855e34f5d9257edd599e5c49b87c067dd0a363f8b93a54c2ed0ec7f9d5b0911d952f76985dc9f8f247086ff15eed4d4c94a90ccb8af9bf36050f181d967e463dfc3d7af5e4c0737984f88bb77d6e6c030de9a1633f2dbd0f6ac835a780b30d414e3b49442eb59cd63aac0c91639db34f53e3fc09ed4ed947dbb4a0f985ed7d4354aa1b1928673574e69da0cabba9ee667eb3d0c32a921563ce88cb5f8a01271b49b6aaf4f2612915188e5f29652b084036e41bfb634204481a54ae1df4c203c83ec0c02f678cf2af329b1d57e69d7d3cc190714664d34722645177718a2ad89578b9484b87878803330109191442b1023eab52386c44a348e73ef027082611146eb7ca8536bb7e277cab654af1d6c591b1f2006a6973916516280b7a89e7e481359b26e480f8cd59785bec843f9d05e0643c698b43a30c3fe6fab136ad1390ae0805658052211b85ef745d79c8d0c513fdd44e1fc5ffd6f84065eaf89520081c3424a7e17c76a2a841d622bd54fa2ceeb5813d8d8ccd7cf669c836000030056459d8438b47b0d10b7c96a9df10232373ed20e5ae24c541aadcf5771fecbe87d0946e78bc9201a6fbde3267620122a91e947874efdbe66ccec4c410fe0a85c2c305e97436e6f1cb38ae45233a4b729d26685c2c4629dd3a59ad9b8c8503c474159a28ca0a2a1fc83469d395c408e7a62191c262afa08ce63b77145ab6e876638270888123398d560c79e9794db52bc2617287e022727115567f1f6ca84a20a75bc7557babb0276d9bc7ceaf84b25cbdb27cfe43d9931e69c3234c23c4365a7281bc7352dedcf5d71741f8a1d8bb05375ab08963066635c3595a31539680a7f637319ec9f5e03fa6734652127288c0c37a955537b60def570b35b1d47fa1b0f993b345f96c61a399c25b40d3b9fca10ce79323f0c36df63d65b8d7f43712100b8a355813d1dddd8a4dbfeb331c252671b141f13177fbac663183ff3de797b1f92a37ac420b09a5a3480f15b4be60c4fccaf344beeaef2055d017456592f2f9621f476d20a9d4142d2067144f0687cf953781695747edc06c5090fe23fdd4794cde8212250b16ce6d6767b5a63fa12c915be62a260039206bf145f4e49445d88a01251dd87fadff1206a7e4dcc5ab3c8f9273744c20a8890e999d388b19d483a64c4949deb8214aa9fb26c19393051aa4b49e9b1ec023295d268fb1e634fae8f104daf281baf3cde5d7142a204bde85b18d8389179eb6cf3bdc24b1f131781c222e544e314a926b8961614e9409ee756b05dede15eb40bec20463a1608251ef98f551d977acd2610aa8727dd5cbfad2b58b969d5b6842408614c18d3706a61c2b374a4b8b67242a6627d1b196fc775917ffd95251432af59642c0647f7b623cab66e90350f205bb04967e0aa5c93d1392edabbe66accbda0055dbc35171806d7da2b1ea17d706e360399cc2732c7edbae0529b073ae0c04d69165f8055ac11425ac6222e110511f251e829d13356643c5f5033c34fca8304ace42959862790f96035445feeeeac260808349ebd5eb919a4a0e422aecf68a021f1955ac2a161dddfee79f2e180ef9fae303e9b2622ed55eb7c571fb28ae617de4fb86f225ab2e57c1f657cdacecd6c8ecbe72dcf068de9e9c6b0026291bb60b264a3610225895429200c40c9a824e05d0e390659a2614088e28c59dc59657671b61aee81c3cb665a1a0538edb0f542e1cdc29a85738c333c0f75ef5990be2b747321d28ea57ead794dcfa0e8ad0e8ef66c8d12e3eb9e546cc7d97bdc720e328546ef25b200dc104ba7542a157e0279adc06a78269ecdeba12fcd68e0469baff54848e85816e0994439dda468d8a874d846f91a514fff739f419fb8b3a77edc115704b5af62df86c04b287a93e908f42e46ea8d08df8f05c71a134339ff2c3c79253951089bed1a04116d809f08e2335238f89e38a886be12a919fb380a639918d6c11407945ee217e62fdb0b938a759aeaf79e79a19c2e724413443f2d329ad0fbfcf306d559cc8d723dc2feb64a3bb3ae3f87020efa46c47f8e85532ba37234411382c4535349b7207c53d46f353e211ad8bd4e333bfb1341625d2fe4218c51e498544b44092c47492fd68e50c5e7b76a9fe26b33d3b22c5e23fa538a31c0658bb0332ee949f45888c187ddd83b38186bf08c065a065a3e732a22607d436e7c4f735acf80715d05efcd45e3841ea4e673ba490c63bda166706d12febbf2457d85921fbb8a5e45cb56525a436734cdbc84ee495a51f18dff9adb08c800c6e99aa5d745149e2b417642773c90150990b6caf6056b9cea62f7353a92f1d1aeaefdfbd6b24412f5a5abba1e9e123101616a400b2aa534b6cda62bd0756429c2a37e21681df4ffb84246d552a534ee554bf9536c2506b1c95dd51658869853ea3060aa86936747d618606e77c168f659323d92736cf33f6b2ea99b22bcb32d5b30865d514a88954dbcb7cbae588dfc88df9aa2832b91edc469c9528a303fa6933ea2aa93ffb5bf1b05da739d7c015d48b334d6c3386ea792976335d59d81b88c7f2cc3caee6eccc860c365cce5d9ae83c1ecdb97698ec79b12f8b9c138e39f8b1715841f0bc9183c59285a562ec53d2d019c7530ea1d0e9838b2878608c8e59af81c0f5ba4a1b183479008ca04c4b4521920d57e4df471c15acac3402d7171c423e93c369db654e9774b61436fbd082e1b061454e37f0c394659d57ef0a6e97a9c16ab0d56393b2d0bc2168cfb568b83bd6156e98abd9348367faec18b91f40e342a189f642fe3ab82cf54dd8b029363cbcb46052e59250b25d39884ec9d4f747b5af991a59d46d2a6beab29f8ee23c63f09a408c823a9d6017a2deb957292f6d9a3ce12cee811f12d7365933347d4553c0762be798b2912215ae8ed39c1103998f45e6c8ce45586f1562411802f776bd8fecaaeefea7beeb971026b009388591f6040270a83217da7b445cfcee25d99a9f18a58621b21494facbebc80c824804ff80aa4e140a10dff46c4099a549e6432efc533747b52cbb58b3d6a46e16c8acc3b8c4d8eac81555fc10b50c44621c677bec42af370e976630247b4307b3c93016dd83b26fb2d209366196dd25985c55748856db66b5e0cc7bdaee61219cad0713efaeb69bb3d280e67860fd2ef6b57eb0eeec8f0935e90314b6b932b55f08bc0bc1c1031937acc1c05dc2ae0beed840c3eaaed69f30d864800382075bcdc4177e76d6f09b8cafb2672c5298847718f1ac2fd0239bb2d815eaf37c0d98fbd7b24843a92f8b369fb5ae87e5e8dda4a4e8502c4d086159a09d5319005abb198a2f6e901da68c9fc43370dfd3e7cef5ae3f82a2de64d27787c452944094e116dc2716a38f1086633d1aca8226a20b8140001e98b0d9ace85725507ee06319ce01d0245ef61bb9e406821f3b6355d703722b47b8775a2e5472b73289b28e267e6c1eff7f210459569432b8cb29e65e488f9ad22a3b987dc176274707011321b93588dbff82ec4f1d278ecf016ce8c95010b3625a7146de910fae750158910db2ed57d52320c65cc68f09028d7278a46d92b3255de8beddeacb665fd4e440ebca7d99d4122f98c110cddda46bacdbd8fab74181d9472d2f192d587909522179e08cebb71fcfbf39008bb58ece431b636f8d50652eb92a1588aecae8559f8bf5881c9f95de270758877a51ab3cc6c66206d0b008ca5880fbe340ef8c7e48fac5aeb02e7ba5823cbb451ec9ece54726dfdb190bf863508845eaf14e435cd402828fbf1a7ba67a17793c6ae49deb92181aa87cc80764a7796e817cb6312ef2c88d5cc9cfd9de079267eda70ae605a22a3ca739890bdda58f749bf14064cc508aeb6ea8ea6cbd65602078e6f36bfe532c2f77e27ffb3e9647fbf860029f0ed68ef10029ab01816b7d0927150ccefdf11f7335671defb5139af572e5bc96969e38498a0cdfee55a8bea2ca4d405ef5de449ad541dc033de285393cd23c057368c39e41dff254b70ed44198f25096fe0a0932b6d1d188641fb95e17bcee42c7b207edb1cd50b09d061820e3e06ff17f2c6ebb72492d96a38a00ff0e61d53bfb7eca9b6f78f8bb8302e4d8fd38b072421e6e517804a43c30504faa6994b9e3730fa6a897e7f3441a877d31ea90f623521c8072f3c79167ac5b8d614992eb075934de011df2393110c7bd4ee58891abc9216ecb6e899fe6b04db8d6e38a9e98cd15210153ef2c8206bcba7829a2a0dd415fe1fad2cf2ca6a0a90b294fa09a82079f19105bf2fab8a7626997e091d90593b8d95340f5e7af828cceb94f4641edadf9443be07cfb74a31e67b0d4769050e5eed4a365b200f41814b13eab228bf101202b68d2a65e7f3a0fb3106263401e636622db01be8b3153a1b2353ad17f62f1f8fad9b1174553c98e9516f3e80325eb94cacf3809913a546f477851d317409e4601c5b7e7693e8368d571e9945ed724a920c740e6a107a1431685296cf7a8b133427e9576faf266254c6b193b9ab6353b780115766b23e7906d1d00551fb7a75cbda1cea66586a0f888fab9ce42f67709d17aa293775ed6ceac317ede53d94ffbbbe1ea7f1b49746c3e369390529a26d0118f71102fe042a00974571bed6f26271fcda0446ea0d08e3a986136160e749ec4e0d156a46e4f77b53df05b9dae6f70602135fc90748b17f946f24ec9cd95573af1a2002b0c19fb59e421e2569037ec225ba75be5d55a78ed6b0b16323979e2487a41e56c3c279dd0ebe796a33ec9c125afec045cb413ca18f13234abc54bbcc4d588001d8fb242e763ce4b75b14befd6e18b50490de243cf2c9f286df11ab9f691981baf9e5a802aad2f20968e326d945b26acdde8e5d8f588975a9cf0b764f64a1418d382b056fd383fb0d688e73ba26da117381468ff467fa668afe61a73abc69d5856ca53ea3f90e93922d161e22013f62e9a6f9c2217ebd3a72bae35e7a01ca2fbb3f427b53beb33f0ac307ce5e9df5bc596cde714899705f0fa8bb84c29f4149149c6d2ae3847ef72b74ccdeee1650dce65f275404a30836cd06d52ae8f4996f6a59d542d3099d0801db7e23f585ab1839ffe9e1f955b9f5e188bafab684a2f4e51991e6cf4c6d3bdc3d66558312e205d492a0199f97d445ff79a40b7e48b53c662cf6b8335fe360df0edd70c303b7a4bee9ab8640215241f17bcb3d62c450834eda3f7173ef8f2ceb921fa00cb65b595306c160fb08102816c9c1281a2f2f9b3ef71361db7c2d51d2ee15ac5c9cca25126a4691cffe367ce9b896d86ff83ad8911400b724f36714c652255c5ec8b5186aff7c921336ed9745d4b434a890b2a68dd12d0a2e443ef3d6c66311be257d2987fe151c1344fb23941f1e674712e72e2d25de47da77fd39389765fcef9fddee5c3dfb40ccff58ec147dcf16c0bae29ff01e2c8221146cbd8e1439d3be2bfcf7ce239c3fba5410659e6af4b50a430f85929a82d953b986c647ab680f7e0a1a750b90e0301b707805b1dfb18fb1274459000dc8da8be37c66d195e25f5922aa1a7d080df1e8467e52e8aad2db1d70b56925534ba9b73e3924af9d8908003f78b2a5408bf0d432533823ed4fbe08471ab433697b2c13122a98118987768090a1b7c79342c3454ec6e9263a38f6409cc77849802135bdf39ec8b005c08385075863b2da31503d17e57636ee59f222beeec8ea5080108936a8da1869315587ea49abb0568cc15f873213a4f5b9c83e4cddc770759273631406cb9288129bc51101ff279229f8aa2cb0620f1f4f67f1ee4604d1a26464e59630354e5244782cc879076e181cc0f0fa3891a47238e82a2760830903358c974e71317befe7e4d5839887e4674587c79d5cd0bb9e4a3cf3d57851c8adbfa8ac9060c2852d8299a63c2d6bf9f5afb9ba090abc873238377ed1cd32b5debaa69e5088d38b68b8616e2e741605ab28ae146a82c8aa283c7d0a62606378aebff0339f483dfc7c4b3059aea3653cc5266246dd4931300d5dfad198bc36c6c24565f4daa0f321036942628663c5272b6a813e59261e088dfae40e63046495f7d22403e886b5587343a7ae4790cf4cf7709b2064bd3745baca7e4e52eadc53bfb7372e9f2964958e4daa0cffe3aeb27fe0703f9e1e79627cad5c58e8df0ac56be5d873dcadbbe32a3efc622f6242941673b8e243231536e4a564a34fc7aaec645d1fe4ddcadcd1e4f515ecfea4d4f61b337fb2dbe28f0d4dad236c24a225fb09e857a34748a2c79bbe5629feb4c8a6390306b4182712a0fc603fef580034b283ab8be2f861c424191d9eb58d6bfa05c3d11135633448339cccc311c63af55a8151011498cc3ae6918902ca18a54c2c56d1ebe85bc6178c3158d75fdab2a4d48f30d3f358df6714918d2495a105751867405949d36c734625997f13258936b18c625705cda94f1d22626c719b91e5525a6af960aefeb66ab494dc58a894f8dab344ebcbafe80696a683cf336ce76d19acdc90ae537e2af885b8dc1806d11de7815dd74855b0e76b72ce1b9850a7d1fe3c8fc878def00fbc5eff00b1e9cea9148c9297f1bd793ed21e821cad07065f9b81f3429157bd17182da37ad9191be42be5c6057c63013f03ee1ab8430af52dce1cb27664e9cb9995e5543f9569d28a1b5f2dd4f2828ef0449d1615381ffd59e9215e9f192478fe7ea116b3dabcec0e27c9456e6d28a86f172ec5011bb8c28c7574d13defb214cc68f43237f9102c67ef1f44df8430beed88e37646129708a3de70df3f4a4530cd9131c33ce8d7f366ab2756a81043967477cca4d3e4a43f1a0ea1d220ea10c65c5e17a01ca1a0f1bd8f57389cd7dab96f4c95d115b6732266b9e790845992f5c72732cf4619539537ba361d7c103c2e4eb75cc2ad667f9628ffc4acfd213610f4e290757dc2ec99ff2456f009da8288f2301fa6b5357ae3cd1c9ac51fe5a19f1b9230ddb5733d154cd6dd2d1088f2cf1d606f214ca001987b0869a91016ec3e24701ff53af6bccaa107f50086d6b6416a911d62e3ad595eff21550a5d8027fb3a94f072ef7a336c254b46d58f9a1ca1c8d6e79808900605c82b9132302fc75c87cede8db0818d69c5e60690d409b81e8786ab97b878062e4ef76d209caa68a2f7321851a58acf26bbd2177e7d7a59c905e8d27b4a009930541cb43f704c61ff51d4bbd547c180768591b85114ccb6811cc761b7bf073f12eb6c7501828021a9bbe4ca69210a049e0cdff0e56cdcf1e8772559b0dfae557a600978150c8b0f9297f61821823bda7b5cae4f015d13fe5b9e51230adfb6322dccf74e0cacc595610483fa5cb831c03cac25f1baa26daa3608032c44b684a86b34cb7c44160cc6f0bdcfbe655c7ed73ace887397916374e4ffec9326f6ba83c732069c8b38d6e6faf04420d1671ab96904b0f9bc098e1d68ebd9b80a426b0aac8a0323e08a751c59726ebaaff4275aea09746735dc1fd19ef2ae38689cc2a3c6a134e3b19274bd3e13641cfd94089056ae059e64ef348752ef9b036356e9a89168ff7b5ebb9a56942853f94c2f68477cdfcc6e348c318d9e2acb14f82f0e6067ab5c71101e756407dad2ca3a6f901b350e178c25cec923b2831cf2b5c9c85c47eeb307c636b1f3d427223cdf5a8fadc881437752ca5d9673800d08b6c1313578237064970c50f628299e4c7ef7d9fcf2e50296b2381a24f95e9487819c2b314ea4c788bfdddc9c140c255a36fd1c76f756c609d6edbbc805ebf1d553840c3732405202c3d444276fa58a26c947d9df86103d939e6e045502c00e468d261c3de2b34c58fcb4e4fbd8922499599414c8aca59fe66a04295309c8449da105ebce35dbb7b946c68030a2c3cebe8c23b215733156b9a733a84807d20bd91fd29cd04c1b3f23cf9fe49fae9bfa31a90084bb53767296916ce16d121bdbfa77b8d1f5d0b115ec9434023957b11d579c2c15cd7c58eaa2ebf7010bd97e75541f0f39abbd7e96f91d592022f2b454992ce8ac22252ab30c18b95e8f6de911b3211a2508407c4b9d3e15ba4b1b3ad36c61ca9ff16676135080391d2ae52bb0f24a38dadf97618eed3a49fd25af1a96120dd1df251808dfc0ad1bc783f2308ddd923899fa00747b12afd3d7fd0e9d8fe23981a19c28e457550521d6c766942c78db0fcb49bd132a42355d61e755d791b51e30c71993c4665c5c3a0886925c01f717699a50f3e3ea259efe60b47f75acbb87ea68e9df93bb3be7b20dedad2e06a4f20b65aaecc2353daf5060defd4a01ae01a4200116b1ed2da4275ae7763e62d4aeba88a3131de504ceae20164e8af49f09091bc4973f7d65b54e083418ee1d6104c3003f790d8f333fd8ea1781e8761dd3c98af23c9b6673cda3cd2b5550c83ddad47671386eb524ae8ce81fe03db9b9ec7242db26e9e07294fa243cdd5b180e2d7fa97e9da79eaef2988d994a2ab6151a44a74fbb0042395676e0a49d800453281838b852dae5e679050c3f4da495e44b77503efd433d77bd7d094c77f141bc6bbca6010c5372fe8d6f68c11944b560dbe63cc7b7b39ba38568f398ef4169c8e10fe0c3fc5d8e6f266e1f0e09a96a268d3ac1beccbe74ee03891664e54f66f4e9ddce3ed067665b61202e92b9943ca0206996a822f49ae88e1bd7f84f8f67089dbc98ec15d545e3b729902fd8a9243b7f5b4fedf06f87636bd86966db4c193811ed05aff77c2446ead2926f2c0af404176de9b5879417f841913c47341d1cec462a9282c3aecc2576533a212d5f0b35540f25af0736b54b237ca0523dbbd56adb2e354837e70149f75bfc04f2b445f66864a28e2df61fd36550232fa0f16886a53dcb43802686b041a1a6c6b21c64c00d4b2437857be865729247bb53d008ee9c6fa74fac78cb07ddd511108dbcbbd1588e5b49a232440da7ba271875a2b1ee920d2bdee0abae66a75b3e1595313eb94cdbb0bc644a70f33cb9c120f1a1f630aa7b7a76b02a8db679ef2b4b809feca45d5a87f8a1b9aa88f183682da1eb4c2d9e1d5b99ca8533644ae702c44c3971cab14bed779b5394b866c4f01986e20e6148990ac0269fbc443ea2dd107b4f3df6e4a733141a4e5441b4fbed9da7dcaec6c1856e5738ca4e7e4dd5add9f55402c4cc628afe9a8028cd8edcb828a448027fcddd13ee5f44a385de98a473eb33838ec9eff3b1258dfd49d888b78027f6707fefcc8429b6a63b0998f9cb65d25d681bf0ae548c1d9ff7d6a370a45b73955d1e2b277d695d3ce60d9409d7591dab715ed89222d485e922560455e7863679ffefbbf7156a86bd519866240c6ddee15b28af138015584077d5b3418f8265a70474690d5cd1f9c18c3c069e86454a92fd8d30447285c2f564bccf4881da994d865177c5fadbd63b1b03c9cf707689c8037e06808cc681768d08db9b8cfd3811398e4da5d8d1dc0196800be806e8883208c0093a6dc14e9ae701598f709ddfe73fee4b5dbeef0d1fbc6e41493b23c8c1dbeea3d782d32fb416cc4e90e2f3818d024bfdcf67c8cec43eca51a0b430c055f9c92ce41e34dcfd2afcccff40df35ee37667ec4395d5036a0c57be9ef348af81efa32c91e94965eaa49f7fa1fe6746a92f1938de5e477a7378fe81535f9b6f86acdc7ae6bfc1b95f57664b9f38b87b8a881e7cc5f79d98998080acdf7a07553aca15f1ff34c7cb63a4c7db24543e7ac301200da31306a1309d155e5f1c09fc9330b59529e6ac73c97f5bf3687f382b3a9d5694787b6700d1e0945dc2de0c172dde8e00965c43c8da87ad29e78f531648a3137ea419ee3513764e53c85ce488c4dc8a2b399e6e244a3a0f8683c8ef087869b1616fe495ce37e1b85b18e31177476dacf867da7857fc1e43e2b15b050adf9c8bdf6d55d9d9f76a203a525132663aa76d21c81863e20e4ad984d02d59722df9661a197975dfc6d43cb72cc32f1285e63968f59ba81d4bd79e88d928d6f598650ab77f6262a63431e9545fd31cacb3db9ffd52d9f04807be0266a197c902c419204e77eeba26c473121544976dfff51787f9dfa2c4fc9d5652d9e70fe16dab6242355f395338ad40b6711b0a234976321522ed8f7f4db133dec33632426d08172124c906cfdb4c38108cf8e57a2111870673857d6713fb1c8085ad02d20239b266f16cf74b60f0b43880d8e7b2f1475f31443117cd9b8eabf5c7ba7420b05dc8d7e2fad85392b44b673c880c6f2faa4b2669a84dd38621c5177ebfc3744b6b45d3bb0dbad50054b0204f23d417c78dc897de1ef175b022bc4a4d83b7a237a8fe5c424fdcf6388bed075e7937b1e9ddca42ff0a0b2206fb421d8a80e62f0c5d0dc2acb112748c2b778c9c29c54433521a1fabc5c07445a5cd4fa5dfdf102cb7dc0e8a663a5d86e3eea757630aa502f907064a29bda0b422f6d039f1eef12d5d13c93c04b8407b62a29b5e54ad93c82b136f51813683d1327fe6cd65be57a8a6127140f0d7d91541f3f88f1b2f81670a6cc19e6c13620d9b9ce6d77d101124d6964d77d0b311525491734a1363749e65fc0019263604e032681a1af72a58ac68299061103e3c94360bc583c193e8776246a38ebe7de370b2c230f9d5279e526224bf34ec07fd9abba798ef797afa45e29565931f0e12833ef2e222909348e6b6fcc447aa8971d02a2e25e223d2396f61bd8b7921b6ae0136c211aba0f4651938dc42f237d16fa1775821bae1c7ab65d6b13068e2578514d58f0dbffb52bd715cab357c135255007185f30ea55de4b147a9576242a72ddb8d91c1de65814e28621643f2b53e20f23ef130141bc46fd29ff01c5bb79644fcff05e774092d5a645256d0974b0cf5ed92fe26dd901e1144e885516bf10081f99ad28c0dcd319850a3bb0ac735c99ae317e44790e03531cb6807c517a49b43b1d7a406b8074c62b9a3519fc28f186db5e28ce5f0512cd0ddef9117a112a0cb44bfd98984f8b91489a52b19de2a3aa3082662d163b590f8389eba1753b4cc4cc48880d1a13781e3eb21aabf5d06a754079029bbb33d48259367010bb623913e170d9d4126376394892d21b30e6969e8314bb8a0d1283372c6db52b1088ad9d3089a17bcf6bf11facb184fb7f3e200c8755fc6b46c1c12c2788e3ff9d3149960d22ad8fdbee84557c5fc0af8315f3d41fc9895204ca947289443ad760c8365a04f6d1a79f4504b8ce6d2854049b792d458ef319b0374566fb5763052cb46495d4300b3984871b56f28e9d087c01585cda74b23dfa67bf833633ec2c1115f799564a28d8d52453d97eba3001fb4b66586606bd818383da0dd548a32ded2e028ecd4c67641aa43c02fdcb05e2926aa3ac70250e05e5a64445cd0f7a4f1874d3f35569d9838af381f77a2c219599547bcbb5fd06aa901d092afd4b64b6d57a5c8cd7e2aecd9b1d3fe0966726fbed68f50515b0791115282660960550b884dd5e7631424dcec4082413632bef16c71d62a5aba1b618de8e4c5f6e9d23ae7b4055815f6d6b46f4840e45e4eddf15ea91912e046f03725573df1f9913e83d36a5e6cd2f65efff71862a2a80f4208f7166d302e44376f7b2b9b6c4161a6d81f297bac323ba6ef8aeb5a89042bf1c92334476a4df66c6e14a9eb03f96c170d96d1f825de2a83d8b3a7b704b72819092da433b3462d667ac3849f8ff5ff0a16b4914cdcabce957255213efa61e578bdf31efbd52882372b5aacf25262051b1a8e2881ba62fee2b6544bf42b5c6bdcbb84e55c20460a4c786b4e3f1bbabd371d46743b2a509e778ec95cb460bc5ec2862c255648daae2f50619e91294aeba81ff141b21ce6b157c36feda0c13e30f91308e6d028420a2692858aad03cb2606b9b11e44b49de63d6743e3a3312dbf8228f6e41dec9f3e2879a1c28cf0c22e525931fcf0672fc34b8b86aa269ab3429fa6abf0a59bed01d7ec185684738245fe1a549845e23381326b388963a3ac293ecc0ec68592033661635c5f4cfb48e0baa7513b6f1f58eba96a5de66f1962f12b1ede7d9b3cdb71a502141697ca31ef712cc662adc0856e312c959b4fabf814d325cea3f3883ffc9d20be4993404d2a234e40b4eb5d2d78ee3762d86597dd630519cc00b1c489a491d22e08f3025be9c3d82cb7cd406c2f822f2cb5714e5a437c3d193970dee9f67296bf6c1e18adc89320aec1d81abbfbc21f395651b15c78e76d15e928a7dcbe49d4cf3a4c084440f73d87ebeddfa86793220150a22642ca6ffae290bf8206674ab5b41b695dd0653f584a1c51066fd753d9a3554bda5c8f6b9ff6dfa9dfde66cdf19b3d0862010bfc4f60914ccbd3986fa7e257a817a75c53509f81cd1e69aee2e70d758362397145c759ab30ee4d97fc51987ae716acf5a028058f820ee9d5e0caf8b4d4fe22b96bd1eec57225018048fa70b29d4c582167d1bbe443d67affb5c36dcd0653d7fecfd68f462b8aad159966d868920cf085804ecc9f5b907b2d696782997c3326186d6380db981b5b51d788552af989870ff167ad5497d14b9472bb85d34886d01ace3fe2ed1c2e259f3aaad72d919adb1717211bc9c6de06d76feb61573ca144feea8b147448337edcb162375a36b092c92747b0833a2d9079fd2bd40d43a8d6c67687750ab53ac91d0de71cda7f820fa923b2be2d5bd126444b02edb9f7705bfcec89d2b7b4f8fdf0fceffa9e7756416aeae8b6eccc57027c8f161e250054789a8e0fabb729695bc091ddd678259cafe48765d5b07fb5c2edb6ff82301038eb14e81c4d9dca2f6649704b54c1351851962b8210b33b0cb5b660aa0ff7441ba1c1f64acf397b6fc4bf3bd47f916bcbce1e40a901c77e8248b06af5d426a71ccb3f29170c15cb218d32ac9b7132b32e241f959894a5f6e12947e807cfc794111d06a44bf7437d3316be10c8b0f66794ce74f0f0f07873a539178ddad23d8824f8a7ffbba01c60982b11cfdda62a69e834f429fe51f2d8e813344f1b8ff4e142d3bce604e379a8e1f7322167003c8cb3c79cb1b0182797ed5ae1b9f173507c2ee753a5bb6b90ef903b6b12ea2e0677ad8b2a249475de86a5538f1bc6932e529f6deabcc7f8a9d09ce05e05e339b5e79ad9d9d3633edaa18e91f82097ba1b414ca6d3b3099f44f5e3e4d86d23c87688a523f531deb3a2af9b85b0fa9eeac38715c303792f13951f87eabc8bf76da51fbbe6c3dfad930a5d64ab6963dcec527815389289f98de9af50cae110d4b517481c91e320135cd08b61fafcd8e2db1d6e27f0cdd074ca55760c1c4b1493dbeb676299155a52b161c023a38b934312079de093c72a46fa1be6ce45f8ae40b029dd3a6b3f679de39be54f65b97f76dd8e8a3e2a8fa60e67e065f9dc229775ef5d2975c2ed7542683e06b52c6deb79359dba207a1b41f776eda5455ae3df1a7864b0dac376e757e772f852645ac70a3b19d03d222f5c5b974768a51647a50a0c21a6f2b26893f04c745449d980556a649bdd7fd7e73fe7e4bfe3c0404bfe5234d90d7ee58637ad17eeea3d9f64508bf5df32f72e473d78c3fb5a63d1fd452aea0253d63077ae0123cbef1fcec4a4c55c907adbe4e556c2df38a3a0c38de20b63e8b724834ecfdeb33638deef065e57fc08cd797c42d5b382de8b6380f4b2c304da50718eeb71b68bccb6b1d6e5d3157e538b81de431747cc9bf1fe0676b8970dd0adc72d5be80a59e3fab0ffd6ff7423d575a95758ac4ad75b14b9a6ab20d217d4e39d5a17699f082d2ae2f299e51b9b3972db2dcdfad969d842cdda3518f717578a5e96c80f4def63b445d43b460db6389a60512b44ff91f6cb31c945e5c21fb47083dfc295d92d7298546583591b66a8231ec751b3d2cbc5aa46dd95f1cf48ecc73f60dad35761ac86620ae8df0c3648234411bdb8e05430381235cdd5f81f8113e4067d0cb7c6b1a29a07b146633bc4d423557529d36a69f101edafb9428548b888d231c84c6804bddc01aa12fda200c2b9818e8607f718dfe5b6ce061d89c029dc8609b93b23f5a85ad9523e269b20b0f6da70aba27425acd9036c3af31e23a3f0c7ff30b660ba2c1e26c75ea86764a196b1c3392c0d3b8f1f31b2583df0c36917dfdf582345546bbfd93c001aaf19799b829415a0e4df062d2c3c2fb3e62a2d68648c9bd208eaa9e51cbc37c6eb07d5a5473963d9d1e6fbe6f7dddb8ef9d9b6bcbaeb0d6c22a1834650d6e91589bef2dc703ef48001f1b40e7742e2c7f2de46727e8aa236219c7b557edaa5e17dffeb3a7e3a1eae935b7ce6509fa589b2d3c51a06d569db8c79d3fc84ce9be518f80af9b1cde361fa5007341650e49daa564444cfd39f16dd3dd6473bf74855d77601d81ad1dbcc2c2ec34f7159c47b014c41bf57687aabacfde4ae037851f8d87a044e8fbc0c8103416867fb07fa888c08b1873785618270d3f75b87b82f6502d59297c8d9c63f997d802e0de2911de03c9382b4e04f8c615b0bf67332d9384ba8f9fe3da8d62556133b1dd17321a5c890d07ebac5ca55eda1936295b1bcb973bcb0dadc7e498aff109a9ae3ef2e7df3020a35daa4f04e2d6aff31d3bd67745fbdfdae2911d952330583f7d3f5723f46d76a4f62e8f1f20e28cb99ea73a03912987cae1b813acde5a5aba1316655e6e337add59a6d94bfab4a13a97486e3606a7250e6dd225ecb2dad833734e145430d2605b3cf5863b907da16c5ddd62b8a57502b3e52e495203a33241cd1bdf62930e99924c0721034aa76f7a50ab6cb2d3d055ca4f7c29cd1dcb16c8f4ca706be5cbee1bba58eba3678b7d6bb36c5da3eb61f807654b88774f0c38f5589cc88536629a293c06debc9f593e78023e8f7fbe74e40e4892f3dad0b93787d1a381db0f8eb9be42140a409a0126cc78826e43120f499084e9e23ae563ecfe5f1caa88ade1c212c48eafd06c8ad6c7073e8d05e0c320d66c91385bacf21d7a39c12bdf74ec3f0531635f5c022c65da65eff9ad7049d72e4a32b8e14395cffd46c4b5966cf765aaabf0f3923690e5508b18150d18d8f38656fedcd5568dfe6a59c458ba25cc0813ee77c3dc6d818e5abd2477d5b02f1e2e3c58eddc69310667f9ae40b140895cc7c2a5efd7900125c496e7e9a8a819151c5443e648e4f1c709da051e6a8583d9ff67910cf32c87960e3a16805fbd57c2224f5f995b430c71abdd74fbecaa5aaac6921faf8a26829418a995ca21af1e7a567acaf3ce3a5e12b93ca1823a43d0a7ab6349edbe40f8b36984d5e8495a5124ba316ed68f5efb9f1a522a0e948dd25a51e470798c8b5caa55a4d802cdc8b061e92d3aa44bba0cce4efa7ff73226c66041f0cdff7afb6decec7b88142b8bcc1e66c622f9ece6409298097b0baefa0ddf301303b7b150ff424862ba24ea3e1a171e100a52f1b4644b274a2677bd69c562e19ef011d663a748c56aa239f3bb70a95b173da09010fb5182dbc5b5870f1e676244ff3382eb28c3c4137340117c283ed838df2721841fd6c1b838dc6ee8003e024474b312cf6e7aaa6840d26839ff83afaf91920d30dd7f43d6d47d0c67b1143d9a02ccfddc82f740910488cea3b8b1111b5913c1a45c1291066fd8a626e5a0bf052fd1fed93ec019eba16a44e75b8be4d664f1d16cadc90a7bde112062208791718619d879304b9377a1d59b5441595dc32d13b3b54e42ae0664dc32f5a95c7b62229cf7c81ebdcffbb1dcbcc5789f2b5f6314f337466a166c82f1eeeeb2806ca10eac5a2bbaa2a76c581b32f772bacf75dad9bfb209157431100cb51ccf70b3c626de31a6d0bdd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
