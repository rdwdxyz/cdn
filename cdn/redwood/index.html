<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a52f8ca318b80046d95a3962af91dd949c2b2fdaaa0a0486673abf071033110c068aa28f45c458d220c53d969e326da47f3d8d200fef2a736482e7af6275a4b703d589aaf40a116612b16ef829c0adf532038067f66ee199b8b5bbf47bd328b9dc309d6df2fd102e08a561e8ad01734d1390c3eed0c86472c40da28aa247e0bd85b0fd5ef5b4909e029fe4eb5511573ef0390656fa22739ae13ea814c0cc298b1d3c46d66d6181abc88303c35b22c8d1aec937af0d6c6c5a0f0bbe1f484e60d00d5cdc22c4b3cf30083315bdb57aec12ca4e45c89e84b02375b791b8387e95eed5202d2e7065964c21fe8ad72b6ca0823fb76c227c811bf50182f1ac8ef3aa33b59e4e7f3278e59bbcd68c690bdbfd6fc6b808712b9d94a787c5d3225030101e93ed8b04a78208d5560b4d71112a3420e459ac26e59402eaf3971415ae075d1a2afffb14d4a624bbea61123326bdef15104af1f73da131e0560d821d853ac4926ff15fedffa00befe54688dff96bf92df62641dbc69c3f38d15e28efc8ad2dc145f734da6303e7e2d46680b69d854d299a9c2113c9fcaa731bf19fa9fc788ca277a78ab3cbb56e373d3613cd36d64eab2d8ac44ea89b5037b36c25b9cc8ed6a9abddd5aec6283ed91182fa7ef88d0ab36e032e4888c6cf79146e8b8f491de48674c4de1b9cf1de78af74c9aab15c1da6cb8de9a93c962a78c69391ee82279f1d031f22cadd479327288c618c6fe872076c653a220fd4686700d600bee4ed2bc0167800a18b210f1f3dadd13009850c032e993ca5e56675e970b9932c949c98b5e1ddfb0723ba284aaa0ecee524a62c4a50e15c996f03e79aba4dba4623c5f8bdb51379145346a1cc5fcfd929fa7a3bf2be55d03a7620f7981086e13ffb2b757857d2964392ca82e0ed4cb18b619047d8f4c05f13c4a58da7d375136a7fa57625dd62bde68552f908d7951bb7341f03b76dcab4fe5acdfff5553abd6cc47691172b5d7f0ff2411369f376867270da5fe1af6293784801dae42f9929cfdb4c0888d4579d14c7b5907744099a2552bde202fa653b51743d4353015b985a3720a6cfe9fb93d1044f260101a595e3dff51511637b4845f9641d6c19b384e53dad4cc26439381791198920634b74a81f8a27a4f631a8ca63612d07a7120e711ed6b37948e5bd940b3823afd83bfa43c07206df8c1045be008f65c35d572535de4984567ba631970edf9971343921ca2ab8231f3b26e531e7da8b699ab1b9e2176f480f9a20ac5deb8c81fe31a8da7452bf367cc19aec0e3012b8c578a0320712c402c1a2073113951bab08942ded1d5f7b3142285fa49f12a0fc924f797121e362093e9323e9ba3b32b25d354b33fb16115ec419c4e42ece9e030e58be6957f88db95a76925ad4a7bb4030f7b1d14e2ce372656a5ead187a8bb246dfbee4a6e73a6c7c9fab5a4609da2cd13c282661a3f4b1aff05e2ce1152146462c4fcd68bf22db4d7f9fa8e8d4e8f68d5dfc7ef1402fbf5357bbe26d2fb4113fd5b43542ae935e7fd91f320fc8a31111a2fb65eb2027cf6e7efd661369af32ce63240c4f9acf048aa6f8bb345094511a637f085be2ae71acfb80089b4b9c4df9a6d6066f11c057e045d1dbfccfcd8c019280acb57893d04335b3af9034da6b7cea491495f821b949897ce685ac69e30ec3b15341aa79c437a67d0ceaeae10c3732392b4bc71f69dd63d5c0e985c1f01d3c43ed4f237692a7dfe3c4ca6342c10c22c1e0653c5ba1a14142fcb0680597b31247aa9067f27040e3dba55592079360b8bb80068340c1ab06a06d670a61c319242d9bb2f778ce00e6094beb588755c5ab381b425777269e25e058d5c4f37083a66307e6a4f170be32800ad6a60cfe65d6b9946b54dada8c9cba6546bf80ce9492ecb5372a3a5072e171891c1ec71ec6fb817680ab6c484b927bf8400f6c896c5e7141556718867d24ded4a98050125fa43982f0560e2118226bb6c31577246fa2f6970585e2b8e4dda1a34ad638c7833b82d72999036f20233a75d66a5dcca877324db22ceda74a1edc95a0615eae92116fe77952af0273bb4029591c52d846ca2f62c473fe2908b2114d6195f29ceb1857812e1cdaa61f50d0cef6f26900aa7240ada7ded8e8ee3f2cb2c9b8a9bae78e191adaa67f07af05d6937f02d300cd35ec262be0ce91ea35d9866756c8d83733851c17c3068892e72db51d6487f454632e4ba8d6a8141a97af3ace8c7b75f776c910cac0e6f98e8cf2f9d3770352232ea2065fc66ef77cf40fdb7009a1c263d3f57d3d385416f19462258fcddeb48386589509bd8d5f5d4c4dc1074e2c48994fcba6341e4cb0549d7c40081d8c013f8977f86ae2d03f237eee92551b57972302c946762b1ceeccb2e848b360d25f9f9735579a517de9a8b5b61d27f6de620a4464eef58dafdb7ce885fd93571365cac3d2e5910212b7ad9f3928c45861f851257c93b04b2429a6ca889862f02a917abf7e6bcf489a6e71d40f7b7cc91d71c2625f2d99e075b0ce131cc6dc675a3066ae94b71abbfb29169f1be1015881a1637d8f7535732ff6528110a832cbd74562dabb479d7b76c3526eaa8dd382966082a9f09d58a4804081dddde265ae872dbb929a3e827d8a75a64d8afcdc3a1ba750e756d672ac1b46cf8d258948bafc16efde24db50d00544c5477b491627adb5aad76786f1179e06d665c2be193aec75e0cc7b3ef64e72d64a8bc7966e69117e3c49f045c23789453db54641d9d881958a25883c70181927a9d52bb508ba02d210d80191c72f2e8bfa23f9d2f7b97931e57cbbc2294964203d1a3f90a16008fd3db754b0df20e61d595b9c5e0d6a165be40d00fcdf0d9490f427f602e2105cb73ec1ad70abd7c96ba4f4ea12f24b519c214e837ae92bc94ce9b56c92f11f4f6cb03bf38887a56b08683388ce9e4bf291764666f064f5292a1f9e8f2db748e68db94eb87ba80d84c8fb2772d23fa52c3ccf165a5de4488bf38a8fd8e2de2b6e239958c37997bbe413e3c3d744a447d88c9fd3791dafac128902a42179dfe1bf42d9c7accb5a3e900076b548734d9111de211f9cc25df5c5d61a1a88b75fe28e9b852d8ebbbea75daed462e7ee6035a41299db077ea1c01a04daeaf640c04fda2a53ec6cbe0ea3cb594ae8bc7646f4a1762a683528efe1dddf21a9ab90aa5ec6952f2243ff643b79129f621672ccbef446497bc366dfae912cb0d0cae2152b07747eff9b4e65e4aed5fdf6162bb092430ed1748c9d2a8d0bedfa2a497a04bfd7b6114e1d4db9509d0f6ba74023e1640364bc3d2eb26c3457ee2f2cf2dfbcc8dc716efe69dc51f1027fceaf3609933c8f3668f7ca7f8beea7de44a93651313b150ed7a18ef65c781e90133500231d3e16189c5d5d08d8d739a1c5e9f93502785687f145f6e63914502dd6e9383d3f2e41e8eaac549933a53ff27991e732edbb9d884e87c6d39667af7f7826b0c7732e45c116e92c251ab65bbefc28dc365428b7cc726642b3d84ac4da05195c687c401c42139389a7b7ee0fd3d2b5f15889d2c8982b3dfd213b6e3bbae24c98c7529a9cac190b3a783d2ebf3894b54f4a2a3990092436c45c246370ab765da8612b854d21b9ed83cf85efa62caf592a38a213aa6896788533faab27680593ae030d2a8ff85bd375a46b63c4c8ce4afd53d6511ca70c7fd500f30cd4a2ac07dca3953b1c49c80d6a3f4ff5650d37389caa92e0b84be681695125ab1df1e38579bd3f5a685a8599a999fe3dcd0d0201612083ef571fe61a67ff97d3ee5b08b5dda968674fcba78c7ec3d7464a79e2df9fa8afcf8c7f37fa9a9215ad2bb80f0db5c5ea9c1ae2aae2142e2215d5004a313c71550f3a9bf399b203ffae4e7072bca748730810575cc24193b34629da6d7cd5b212a2ed79b6851317b9ffc72974a01d99f3de2be5578432161809d08b87dbefe3bfe80aebe7a7fe099029985e42d3e38d951e4e1f134951550341aa2d6921e430311d719b6831036e970e0b0734c3f95442ec4b6d11c423338042e76bab7341851e1a9e2ffc7293d7e6cca5ee5c1739bdf9767bd02e884226e236d8257708ca24af3e6635ea762bef20f9be5a3f0f8dd6f33877351e772493c2d35b95ed3c6b76f83cd8c42efb0d95c83dc8b8f91fe6f0841f1fa21f0d7cd014d4a34a8cd6ea4d721a778828de78780b7b52af790591cf7ba53b818ac4a602a80f38e602c468267f76227566f4251d650417ffd371dc45a56d0d36e076f3c270f9b2448fcbbfc37b7781d3d44cdc17f83456392bf001447c54ba4538f1b58004391bef49bc6da73a2e73a1f2358fa4ad323d5f7a1100afed210bb3857bd9c07acadb0da8990b44d87ac6305760bd974ee8fb83ff600700bf3d46d1b8cbee2c1aa84372dc9def5624cc59885adbfdd83208262d32c154ea73be3ff161786ab11da0d3e15119779758ea5ecc963d2610fe3940fa402d680bb1d147edd621c541e4061d7f7c568845c2527e6672b517a49633d9ceefaaa79d5f99460209ecc63eb395cd4a24f4017179ce48ef2d3b2d9f32153ea9de388c476fc327ce49e8b5cf2c2c56f8b98de156e32c83702d0dc85ec85ea8fee40c6038f07a7315bff319dbe3fa407d4a024185163e35ba3b5141824092b5f81f6da99c959efe2cc53be02c2a7892d59193f5612673b068a390934c2e761f4baff381582aad328ab9e9e563ad68831d5e5bbcaed98fdccf60fbd5d3df1ec07c8f947f884df7a101431517c0ead8849a01516daf01c73c4babc56e0aadd9db8d08f4e3c99088f225504bae4c7782b9d2b7625db771a7c5f1fd5636f1f9b64e3943f0108cbd2f0169d4e93c783dc3a31a16badc836553e845c997302f811f21f2678ff147e2f86e51b160843ab7a0e382170dab6f758ff7f88b612318ce1c52900aa3ff40f26ebeeeb7138c41fcd987ea15233a5b39b0aa944c9891a9f5b010f1b9de6799ce54da2cb1b97d645422a2e46ee75650fe2b7f65fe072924457c277b579be83b9b8d54e3973e83582bcb1587d2fbf035f49abe31a15621e6f185aaf8cfb39d2d00bcd7c5e3f364314cf03ce909d33915ec3ac052c32d6c947d94a783933d38025b43e74f50209ec07e8e371b2bebeadd3082c9481334b9a28893fa618645fe4daf8e10924ce10e7a48940f1b8b9570c4478454d1efbac3e9c74fe92886b498be6d5f7ba94fea5ebb45363e1c74682dfc27f4171cb4ba7c2c86d32530aa1c394db8d4cb173e16dde4573fd167bf90ca4ec50b4428cdb868e88e01192599e2f5118f4aaa5c5381845c98b5087b2caa3c9ef2eafe1b5e0c6a1e656c2a5c4074b9b73eeb468c4f4882c69786047c74019f26b244c3066caef86d4cce40154362910ca7dba8eaef0209ae55510d08af6a5d4982b28c73aec0aef3e0cfe849260f6aeca6761af08611a1fd0019f4a5010a66bdbf4d4fefc9888d661b89c7f17c11a8b1ea0742239b21e6ff6aa3a1b19c6090b1db0e78234562e0f7d38bae95d4d227bab9f87629f91940e29c1364f5ebdc98275c36b28b2e3506b6bab193990c068097c83737ccf17e7ac5b3d842510cd07f542a74069bd1594a2357c2c7c2b2dc7ca5ddd5686ad53d1e4769597d03b5fb6220c822251b5c331baf07babe6e49b71f46b1149c49ae3bb8769c1c63971f5ad6752d7fd81408ab0d272760723396afbad63ea1b6f7460ed8ed86c4a69b4871526cf9b9fc73a245f815c3f5ac26e3fcaf6ae3679842807304b3ec1ace1b0f178b8e9875e01822a6993522e705512775749a01c88b68529bd6b08763f3ad83696493c2994d7ffd2f8f7d06e19ba58dec59b61cb5127210824a3795857c2fbe91cdfae60e83e0ea8d613a483397e949864a339fdfc9f16e1d1a1e108458281979ce447fb77a4f154dc9cc656982bea6584a14ef36fea3c815249b1bea9a72eec630124169d188bde50dd6e5a6453c76d594aafe6c33af77eaca87f54011b2a0533da1b48c3b09f1d9571bd5efafeb99ea41ee1fee903a6e72eac4dac6eec963fcd6f80fcc480fddaf8dbe637e1b47b6fd183bd5dbc4595ddc421f0e336193b5ba50d8597f0da9ac8e953776a17e4b1146c6b4e67148902bf495ad1ff3c496a6985f2f8c18547b5b2368964f2ce8a03a9d9809bf1a90e7d583044cf25c227299b126054e39d596e9dd8daec4a0cdda94abed81ea0e3c1b0d67dde561b24035cafc3d57b77102bb0b0947594c4f6da47f3dbc63ae0f5735b1c1ed9e0455461ad53386025e15c23c0294a78c16852a30421a09d6ceb703afcc2c0e1eacd06d9ea05710259aff8d6b55fbaae06d689ba468967c3877ebfc32fbf6c5e2859429ed4c0e08d6bde967cd3dc82ca317239a3e589d6ec39127df3a28fd13c7735bab557341adfeb7d55afbb4e940b3d46004b72a2c2c1b1b309168039ecba47cef39879fec309dc86423cfde723c339464baed2f45eadfdab0770aaaf0475e5c61a233dafccbe12afe82260b55083a91c50a9a7f70e3b29862c4aa5a712be1bd9183085ea6119bfafb3f47b9523e973f15ff3ed24366ee6fe153830dd556c6afb8a6183d6b1bc81d709675f4e4a554a15fd9456b3a564025cf94ca458cc48df32c5ce4f58cc93f7ab69a71a81fc9b7dff3b868f1f8c193548f300b0a047723ba12361b9098327184aeb44279d0f89d492a99d2fd0fd3ff7ff8a33cec12bcd634e78d4a9c78f08653bb97fcf4dda60d9bb46a0ff19654ead97e87d3a78f29f07534c93c835855787da9aa7e3fa7dfc27ba3e321c48182d39721f330ee8f5c914aa4aa8724dd1f95d2b6998fc196e7b0a3d7d1e3ad66f34864673ee3740aa3ecc5388749ba17ef98b19e4ccb1105fb1e3b72c59613abcee3f5e61165fb660a68e1345b9604c22f5bc301864ca57ce4cdf995db81519b979c2a94089ff8817f79d2b1361c58433c9f6668016ac23f95bdbbb322ad4e01ebe96d509e94d78dc413a65486fd0ecdb846614d5248f28189076b1b3467dc9edfafdfc43aa332610859d2cd7acc0f19576d1f2aaf1966dc664c8a74b95866e852a60cf25a4745b3fcd773f69743047e68b6b59680d3d2f8984ab0d03d00879aaace1bee130d512fba8be9488c8109480eb16cdea52e15fac5150ee427985000c0fcff506aa69d2136d7236b54cac3e90a0413970401bb053f20bd35021042bd0ca86d89821daadc167682176d84c06eccdefcf5a2fde142c357992946a58d012dd82f9761791a53d9a33bc6c5425f778281aa9a86d1312f50cee9fb137e9b76800f6be4a6a32c4cbe7245e6ca08ebbbb6925f39f667f0699cc3d241692c0f450424b43f806b97fd7be47c92a1bc5e6269ecb6bb17b3688f51bc44384f0f1c1e89764f86d56de09ddf716e548ea00ec6674291666bcd5f976386de3094a9713e25cc81e5e2bb065882fe847c3d274b254dd345c2e70c6797559ad52fb2cee7f89c4cc03313476d1e182c3a55449b76844f2216588f820ea15379afa230d64a53179b346bc28735c6355010d8af7f85c05a2af15bb4827ed3c9e1369e8eb629752805f76b95938952bf4177bdf4b33d4d726d6e6c6129e52efdf9e1d6c1255f046f8b99a7e04bc50d8c09428cea7016a1d7abfc3a92267b3753b934fc3914b08f41f8f2026bf3c852b92af6f0b2114af247b04af17d4e418a35e725b8a666ad8d6e013a7e70ac38864fccdfb9d623ba5890cebc030205c894c175407f4f32adb0b1f0ed177ef66d663482b057b6e775bfd747454c13899cc1585579059c838b40fa3ea69617a180940f9c9a90f64017b162837ac6dd29df8542668e4d8f83030867b5ff5a94a3d60c61e8eb4861d73af241d6bb9481e82473278a9061fd48cf45662ed1c1182006fb62b273b0aa7d81af456e342987c0a4e9d2a574cde4c319d8c778f2f94bc722d3dcc337622114362ad9bae682dc63cdfbb077dbaa86be510406872388d052d535cff5f31cc38ad62d39d48b6a3944243e260cda1cead4eb4138f6817341d3e47e9c033b9fd5d57d82c914721721da0de714ef2341a9ea0926a6f15a2c1a135ab48d511dc3da506604846c6fae17e9ea15de50186a547813b5a998fec1bbc6fd5bab0b9dd5410cc7bf3917662d8c748f39cdbcbf27fb0b9673e90e1b9fb4645702f2da9544792df7e6530bc26e82d3aef627e6ffcce3534f0b7cada21120b36b30cfc4a5a13718dbcd6eaa598a9c5a0f1fae84b33d43338481948990319003ca75c859658f4115849e581ae5f25d87c7ffa8f9fd5c2901b99c35fb71eccfcc993af1837c0857568070a98e752891562d95722f1148dd772637e7b8b7a8d0acdbcb179bf9a47b4c47c64abb5404cb86aa9017cb4fd2ccb366456011027738518eb7623c49d6e935775ea8fcf4ee6f27d931394e0dfdc2b4d157f61f9d2036e9c1e32442ae244b724a86f526b25520897c19a254f3d80dcbe25206a002428a9d33ec16ba120bb6cc7f01859071137bff6fab86e29156f06f58f3f466dee3c199224e472784d5f8d8ac7f699a79eaa3602e69024c09cdee32617fe041c8333d9aad9c3163e297f0a0163ebb26ca28b8c37001444c755335f00a070ffc6c3694f7447ca9284f2fb60385857874a90a39625c320a892a149d544eff588df64a5703a38f2fa27ba65eb918a3f9ec780998af6d3f7f1718aabe6ff2b702b16941bd028edecdda0f7ddcd2f2d1b6c84b2002973058d9126e6f195d6d8ce949ebb50240440a5f071482001108601916deebad2a9d14e8804ae8f4e682ae3f0c1dcb3d4c271f37e2ed045721eefcb3b5cf9748dfa2f8fffb668b4e2685845582ef3e44dc69a7a727ef88b3d9995e92677509820b539e9d521eaca97373d8c12194f5baca4884e515d7a3bb9732cd6f48dfeab7b1ed71c6094929d9815556178ad9e153f37bd1b377dc4f43ed9bf211da55d3690dcc184b90fcbfba6acc63d713dc57b6a220cecc4b25aa55c777e2b64d6101464a97a45122331ce65f0599c3f3f62d0e6671f99c355596fc83353b5bf6d3d377b5d45f76b10064edb77a7f0c27d2afd405cfa165840a30bbd8999010521a559106a5c1d8943f2561f534bbe4668be2a6dc108948503b4a41b86cbec4859995f74ddb88e311c335eb9a2c7a6e93bb50177ecd9e5e021e40de8a510aac618b4cdf2cd3caba8bb5fff6e4d21049235fe0ac933810fcfabbfa760af9eafbd4ef273d402de0778f940cf5a559cecbcdf8bbc40bd49f5ace1cea35a89713d5ae76198ca28b3e51bc75abbf2463d4453fd78723597fd82f213570766900acd8d46a546c16a7e5fe647269ca1cf14f168b0b97caabfa8b001d0948add6a62483cfcc7020dc76d5fa832ac8e3ed4d110e2c6447e955a31f4c6f1ab77627af16a421aac5d98a29db76438650afaf4c73e263c91ec343e6b572cf55f954ccc2de807b4a63eb07a9705f8ff11c9053c99fa928c39abc0acf175b4f702312211b820dbe1c97eb558adbf764529b0abc6eb4b9eb981115d397ea8fdf0cab24af8bdfd266e07e617ae5fe64668c226324c2ded10a706c3f5fc9e53baedde1a452ceeacb2a0ba6007cc56f9909f4e36c9b5cf6d517da43f08c199f8d6b7439711e17f6ccc6f0d096c5db0bb9e32ef7d8dd823b02d76777c5386c50b164365bb95daf7b51c663f1b7df964811d365d372a3e4edc0ead44f51166cfdedc437f485dd27d4c877cd0d75528694cee1f677dfe1a55ee647710817a99cf9eafb6b615c01625024dba7cc285b8b485fd4675e03f60627f1a919d499726e900c9880df688706013b5e2b7f8a8c8d41059ab7cfed9a61b720997281e17ad19de88a30984ddccf29bfef529ace777fa786c8eb2ab7c939644d64279135fe5c58dbb009e9407ba42b45532f11bbc29649d2eaa2e9642abad805500548a909b982d943bb2c7ec1634452284948d539acf18eb82edb2da4fda2d458c8fd6177d0d224d806d87426912476cd2d17835bcfe80ab503c1a81d8c654c2984acce81b3e9653d7f8bca242cc6e1fc57c938e0a49cabe6d38841736b7f711361fab3366c14295d34ccb8a7366b8672a3c4d18ff877359785c6941c87543bff933c4f7cad0a411881bbb4d4d01a48a4772f64d4e25579aab7fc5ba528f1aaa5b203f307f973509286fee36129726c6b223bcf53632da7df7857e19dd02ee5ce2ed81c0100ec2cacc244d92b91526e55367b268e6afef1952ea24a24f04c3f9de8672a0381886dbe48f5eb83c4a89a3a3438066a78e25c3400b7d517b7fadacbb4bc1e6f7413b8415d5bf60addb77e8caede4e5b57ce70170654c26b767426bf4fa2228ee3a4a68ddbc474486fc94bc67222a9efbf0f8aaa540f925667a9fc24c12e3bc09357d6da50da83599be96757dd91f64759e8a86cec043eaebc64a6a3e87419e0b38b193090a9d296c74fa49942b136930d34e86c476957f1eed38e29ea53a58c60bb75483cfd6b6bb41dd1405cb22f2d1172508a23a3fa54d152917f2baebbc602792faf8d1891925dad03777b887173a9e70f639760247eecaf84b6cd3b718c099a48d9a42c6861c890487c375fdfc2871bb3cb655a9738a77ccde80a62a54e75fba4298384111db3398fdf3d649a97413666bbedd83464bdeec94de34c8a6e8636e90bd29a7167eb21224d0acdf061ff5535394314dc34751ee4f5c5ebccdada2b99005075768a55cc75e3f3ca40b771c302d3dcdd464276906791ead79fcc01be3f894e9735ad6529b3094f96975b72cff09c277d6e5b6633a2c69de4d62d28976466f4a730a89477cabe494b4b921143ef38b4cdf1865806b5b01aa468f96047e099630e6c8efad7670f10495500a57639d22dec12744380ca3212e0b2db0d58d1e21482282cd548654683e3edbafd7a4ffd1b3262befa3917ff5824ad44120fcf931769fb304526f1d55103b3d5cc81eb42dc88521b341534ef8f10086a8bd3b09bf08db396e97b90d90a1fb1ec5c49948ad3821c0aa6584536e3de0ec5a4078e170a653c3fb6ce3670f056cdb1cc4a59a0151e3ebbb00f224d2b98c68f52c97fbb3c2bb9d197ad81e3e04e117d5068643fbaf93c22a32d299efd09d9449340911efc56052cb765a59ae45236be45cc3f36544324486e35b9a2b66b12f348be599ee778d729480ab59a55464a87500f5d8ab4aaf78b89bac4fa797929351c65bbbc89f9c035c11e11c9849c2a965d54ba966cc7ffed6e16e7d9a8b6672087de5f8754089e1ab739845ea6950e13bf7c82bf2d88023e42d430f06fe1c6dbf39493e0120c82d24d85b914c550145ab8cc900f4143673d36c8b47f5f62c442b24a8052849b03e275b1ded96b53a8c79a8511e9dded71e8a7b383413494d3c81a0bdf83210b73b9781e2512044a54a95ca456bb6c0c29f24c4987f18c4035201abd1592ec3c765789ebd27983efb587d3cfdfd1fbf82ef2a68838788e82f0d3ed1bba3a7492c2d92c8f87ad33b029a97948dc54c59794f208cf5c61e8afd6794a6e7529f6cde3e699f98496652c3271c078625bbed3c119169c7a268c3ed99d708399996f0198eef7d3bc329bcebafb2ae0717cd506511bc29748ce640fca70a511f3b949c6e78d51568830370fc356918d1fc7dd6084ef29b07d2a5d15ac4af60c49cbc6f3c7bea9f7869e04cce3493795afcba21358bedc547d27a66b0b46eed8526ccdad4a08895551d16c9252afa6e1e3d747aa4a5d2446407e0d80ffc5210ecc9d536a7768c6658a8cefed665e75b9d48a8a2c9e461a560a859c100819119bc7baf7e4b8608a95fec49b4806335cf14ce0c8c888a42ab79647747fcb3a4d6af6c095590489790a027b68d082d5b2105d81e04452f8eec250075dccffd9712d025ab2c8a975305e1ab09cbd0242cfe2983baa3cb72379491703d50ae52637890d9bfc01c343670393e41534a5a331f75603d593a88d49a9b20addcd666e52f592860e5fcd39d9f2859ab4b9c2bb22570860b5cc0cdb17efc0fa6b58c3fd97849ad7cb3e216ee5b420e50ba2dc96f85ef534407c947e25d157cdc17cf13ca0548dec7f7bb531fd44ea6a64245ae83369d6e312ef6d89c5a4ac7c53f2941525e66a3fcc515ccfd52af2b91a33578922336ba09a387152d45b7549c0a60bd0a5ce73556e9ae842f672a436d024283313fd51def7c71f46c0d3279306b60b8c8ac68a945c40c80e48aae10b505a7131317bd092e0afc4819ff7e7d2a3dd437ca8e3e8efde03f907cc1b46edafade4c7ff3a7fc39e23e9d8b36165fd86df3c446391a0dbf672d09b33891c60e6a02bff02476f951f9ef1d50ed3a080d62f9f865a59bd387b6b8745e2efeffe8a23e1f13135b710dbe8cc0624f29bdf8a636742d9d77692f8d5a24cbac439a64c84cc27132eecc907687b69160528ddda69714b64f98dd8a67dad868b711bcda728311053654a89510ce4e01be79733a14a19005b7e92d9eed499ca268ec5caea4618c0fdf3d4c2dbf38b94c6a560c248edf311d9d813c7a9a996c31b39bcf419af7a70aac6758a191ab1ad5c86023c300f92cf43a3e066f5a07fd0ebe2a4775118ab68851e1b999f0069ca4696aac2cece279a42424cdedefc7a995dbdc0f5cedcf82cee778dbe5f967663c72acead95e6bf448e50c48e22cbb59891d9924c804f63b6d3f4fae3fac6196ab450bb8240cc7748401e615b8cb8f2cbe10eb48742650dc2e69f5db7ffaf98e4dc7be6a27e4879f2e0257991eda644e291cc17e4af1dcd3599157e6426fbf6b5a072f1b77c0b85c2f64356e1f3d706e20c3e5f0d49a2054dc9fbc11d21b5c55ed8e7ff138a9c611b73f0bbe27a286063b18b2330bc9787528fbad586fb015ae2a9b07192364534357f68c9252133d5ed084fa9d1db4c1d9b69f9723559a03682e6419ba0aabf9d84810cc64c68102e999e218dcde6eb00aa5f0763858e041fd68d6e4047baab84e98e10ad7f78beeda4bcf0f49bfadf3ca45f4c216ca93a6f3ad2eabf89eb2c7af681096092a5d0d412bb6c180c905820de35f93a70085637e900a66d7c99d95bef8e2ff54c4461e003d4d14cc65cb82f20613f33675904aaad0b7a77c8f22b4c5b63d94b6f1908e70f371c5f844225606afc91e4a6e3b92785e45acbcf013b692d180374d699875dd08dd40888d0d41605cfcbc34ad5ec60a8269b6c296427b364c0e4cbc3388c1a091763a32463b97a9b2650ecc3278f6a1f74908177478fb6e24ac33c1aa72a2ffdf0ae0ac9c9f9450895a4da774bbe9d4c7f9a4c6b1bb5a54bfda0f663a7de9ce0b67a3fd37e26675ca6904fe2503f0043b9f5e5cf8deff38f4e615ff1a2cd244b357259e6de83a8cce4e1b21d338b69823001a00a4dc3ae64a882a9de615bdb91db165a147a7a7c78e53efe7c7d0bd402f1e0a296e3bbd6a8f9981c0e98e6e1c16992a2523e6b6aec4c909e595e9d2dcfce3d11d9019bd48aaf044f99841c3617420ded058806cbf7876416aa376944e229fe3c8056d3a24930f38c4433c586b3e3489a462b25ec70e1c229e8b95d95599b2a2f1bb739ee2d758959df9f0836068e040f54c5fbbf395df06653ef015a5bda52d159d142b5b99d2c64f52c010f0924fab25ad34502153caa0659b1ec2ac3e475e964a543d2ae5b73b201d9c3a3af7fbc46c846a70e90f0c330ee7c3a37133b3cc67d01acfcf78b806d1d46c6af53c6be01de76055e9f567c9fad6dcca75d92149523c3d4186086701255158e4dccf075f711b75d3b693303ddd807ddcc0b087845191d65ff8e8dd3e63cdfc69bca0c8576a2ef2afb621e3f6c2ef05ddefda48422ff4b754ec636193eb67ce03db7f7da373ba6b353ebdd235e446f672e25eddfae28d7fa8dee198597bf1cb253bd9194ec161163a730082f7e08372d35364d725fb38e925bceda71874a58d6f8e4395823b4ff5547c9b3f284b52cdb7901c409a9c70c9ccfc7abec211d51645e07a9ed71698173701e86c917917b6cb38e5f31fe9a8afd5f1cef3ddfc30c4ee026e15e14d4a23c0c466c707362c017edcc3b35fa2ad32ef462d28ff4b3e08d6f039e77b3b38226e1555849d97945968ca4c29cda136232ccf454af467afcd683b64adf49dd92ec402d20406c8ca9e6f88bdf7135a97fbe1c995574e7916a1ba7c30fee4964ebe96237e10cf57ca14d2c8d5dd9e71b3a2f4b1c1bc8e505f019046736b23a28b41f1ae624765d462b944fec958df462249fe5e1198b33c760c2cbc850a5a01b27fb2fe5bab361d8d2afe972e1884887c14549ca75f4bee01b6f7bf7cc790e795ece41862d25e4edb6495389757ca5bb29cf98e3df662b48974eb67fd3ae61c0a84942ac6ba66acdfa0c47f5060ca793bb82fefc590b7ed38b7ab84e3392f3e922af919bc2a73c3dd8bbaab1ff4489945709e3237329452519455ace4a034bfcc9f8630b352b9c0649d3eef2bd48e357bc555a633aa8440a0ab8c7239e67a690eef4ef6f8fc8a4542c9295814336f9dc96f38341bbeff2feeb66dd051e9f69ce95a5cdb2a4f315b0db5174a83a5cc773b45654d1cee919079753697fa9663edd1fdcbcd2256c5eb25eb459fbc4c26233e9c12977c640b61f020e277e9c7612ec4e174a3d862e715b92995722678ba1c25e1979d3ce64473aedb03d93fcea8743b1d45f2b02d99bf38c499647ea83132b85606f596ccfc02eee2d1c4ff355d5f520bdf8115f318d21c97301d76445319227a1630f3569089f9da2f8f1de3e3ce3935d2e2bd20da351da57c883d82bee85e236ebd7d776f7bfc21bbd28e67129135259b7f98e7518a29f94203e618ec16ae6e61af4cd2d48a28724ca9499436f260be77ca0afe4d12b0a386438c6becd99a39f49f7b218f6d126cd4661021016446b1648f5d7d7635ea42c24517fa40b2f381dbb82c65c678114a55668884ae0b3f7650a0e6dbc04c6a6f7aa16582e849511098f77c7b345de4b94c89f973468a08a6f818bf1dba0535a21792c395332c5cdf1420669f9abfc5322351ad2877dc20a43202c598d5393135f91f5783b7b36531394ae49010f0ac5190c1f99af3ce73e278fd8cc101317585a61b9a9427d3a868b57df80307a04e15a325f99d054cc59c9e1ef79329d015c75c755b733512734d9aaa24e8db4bfa6f3c89b00f1803b7172fa42614230e72ff8457cb68eca9b119684405bd4455d535e171e303f7166cacfd14c16b4a3d1612fbaa4eeb555b4ad0a5e68ef6e8488e02aa3f17400e0c96401b87a6a7eba855cae000a0615726063ee09212bd6644ad55dcee54e5a3e4824052a18a1905c7f12c96535129e72f7bbe4ba9cde7f145c6baffef42e9d0147dca4507b9f992b9ee1168f6e41641dbb65788f40f48f2099a601c8780e9d0d2bcba448abe096a9e08bead26eb545220e6cbb88a8e08f2c6a19e3be962300bbd63aca1978a6adc6f52753800fe19b869b0373d994a7db415ad090a1744cfc0e346514d38ba90f46d474061d546edddff089477e9caebe67d5730643398ff9188152002daa22bb53fc4e205b91a8b79a36af94c4be86f7dfdfbe0d0e73da8659562188c7503a164452d675e73515cda00db2999083093e543c97e4896343fdfd4c9f06618d18f1cf8a8a7ba696fb59f1c8ec2b4bfafb4bdc341fd7797b94a3041f5dbf1a27b0ca806bfedb374cd18e75e6e00965bbb89dbd33308190f7d3e8556e91d3d08b4e523a3872fb3b4de69fb6c96f4476ec12ca160c04ad851a8daef9002880b27688866d87eb0a8f3b3759f48ae8a7213f141269a0fbe73a1bdd118e0cd96d06a255b575b7bf7474223d128dbabd8646293943200583b5260dfd0cf4b9584b5da4e78addfa56ead778ed23b9cf22a167beecdf58c21b352edcfa059780645e2f5e2f2fa06aa9347f1dfffa1e779a93eee5d45b148c9d97d0cd7f53b3e87114f1cbf7c3ee508042d2b91b627aeb7461f414de3e2d0323a719370f598f7c4828c805b6c5a00f87a8b9a5b86e2b53b904dc8c98ab5808c91ba1d9c3186bf8565310ab16e72c84e4bfb38105b7b42fcf8955abe2638dd9068d939a525958b1d5083f0f68f6c1e2055ca1e82cf8378310e8e2714a03d483673014600c4073d5cb337ca9fbb1b63ff244415460d491f5509eeb289b14c1e903a2801a1bb2c37220899f4c18bd568fb43994d2a2e6feb3816bde4113978d4a4d8b20b285e446e223d9ae548bf3a8fc6beaf1e5b75e5316334b55d2322cc71ff8302f612ad40f2afc007a7ee57bb38e434b7daf88a5e374a9b62f918055b8119c58a8ec4dc1044691ef0d8ad50363cdff23c49ad7abf3496cf97166079a8015e77423a2e63b53a2b639cd3b494a64147546bf0e280fa479ad09ba53dcebe94d8df2f14998d2060f8222b9dea30da450ce900bcf6bcf3ac0609a922a1090f9e65fb169f0dcaa8e7dee32852df3c6c8628cf0afb9f528e5e5da0b5c5531f7e5dcd20cb0cc31d9df8877914c0bf9f4a2a7d61013a6f4647830e70dda8702d8c91b68fe3e79dd59f2ccb3836ea5a59750b2f7b4d39d64f33a1d8c272ea533a9dfd1e71076bd0731b10b5fff2747fd6ebddc266003b4b76a44f602576e1368bc558c442c2bef227ce4361984ee595fcd10e284f374e16d9d8c30a25109f9ac39d1c116715250b989ed1ca32eccd063c5513e427b64bac0fc527e252368af91edb38a7c122c5c5a0d8fbe7c7172cd5a26452b1b26eb269959b01093491c22f20b3c474b353555e6aaf2e372cacdffdb5908bea5aa37ecb1b431ec59b715a5f58619d7a6d08f0f1292d35d6b5b868b5f2c728b3c4b93c994d816770b682ed080df7d47cb7ceac5b0823086425486704e64b58e3834c93aeadbcc9a34c28d57758eea75abcbf662f9d4fb93a8f6acb35a4e15e46e8b1043f542316a1f5d5686db21a0534c023e6fef40428edc764d1b41a3c33fb569a66cdbfd382b98e6fa65a33f3eed3ee41a47d711cf840e4cc1fd08e0a58932f2d57ab345d091884701f322c5d9a1ddadcc672c4229a33a0133a1f989e7e77995d0bdaf338ec3f51db3f9f8d10f50c2a63d1d01320750c2342aaf8890c0db5f901d9b59c0b3ea681c589b13d5b65678bd2e30065690399cd2ff4916d4aa7bf3b6294a8f8af13417c118522c276c66881d812ca2657547394aa1b8dbb9c23a4f602f80f893e09a56e28b0ea67f5586bcb75f5e96012bdf69d8b0dbd69bfdc4bfbf2d22451eb015355da89d8afb75ef36f36dff8fa9b8a4a1826011f36238e11a65f370f255863b60db59273c69bbbbcbfef37cfca435c846e9dfe255eb1ce206b9abfc2b2fc8740b210cfdf05a0334ddb467c105728d18010f52fd336994c1b629a064c4617fae54885f8b89c1a00dd8d4646655296bfe140e1dd6caec9469c08e521a4065c119f129ea3620dafd686ac2cb7c0169501d9e5229ed7de6ffc7b263fc317df13913ec219442923eb97835062ac577065dd5534b28aa3d4b3c567a698530fcc32ae505d09e2fcfdcba84fdcf1209e24d5273d56e8dd38fb7297328101d08a280e7f29b508dda799e4329800c3a257e85bb9a36af8371d8076fd0d2a58c467468653daf3fe0702f928b9b31869ae403c6fac8a9fd72fee68db650b51da2d76570a8d96851fc10e20d71cde3a561b8e56de8a63a22eeae507ed58e852c8b3026f1f58b3f3e028f47cc70a1668a8ec012e81a72c0996945ce0f2f93249cf14296189e45c971e3105a184d13ae3772f0265ec7b1288afccb893536723a98a8a22be097f56d4684d34994cf89960d001b20a0c221ccbcfb9bff5e2ee7949a0412807f10013b70ab0a47b0d50f12b0393cca3b6458d5a5ae0f487e41f0fe6892dcb7f21c7b4a15dcbc3f0b9394c22ae1ff9eb679a7578844f2507e98c57676d6b4306ad7c45203f78519a693b04f187140b61cbc60c20733cc669e1566c73db42ae28588cb4355d7874b805b95f8ee29b11a7c2dbea058344a42569c38670c824e2e7cc359046b691b5403888e96ab6b2f451827586bec4c5fe5becc12afd57e9b85","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
