<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb28423b8a9423d0121c5affc6053789c38381a52b77b8d1213b69687851739bdf4c92cf5a260eeca2f9ed1b6e09e0148cc152b8d592b9902cd2818d5b192b919c5d16fc42b6e21777c72063c80f1445fd8cd6443c247218b17c94cf7e341218932d31b0728587a2a162b7120ea2924422af8f156191222ea2f06409a19e8e0d881bc7fab24a03f753ec61f36c70f7519b7234353d96e5f6cba127bda076d787db489d9fb7c9a7a7245715915938710a00c52ab167eb75a7eaee20f3b8745bc27a45a43e38b065057ad7e298434d379f4fdf4393f1cba9eb63803d124a16e2c0abd21dca3505746faea192907f11c84c781c23443fff7d201be7c6a4b9c0d98aaac247b3d88a366605f9714f3c16f449c4475616c99a70a847dcfe428584c35a812ddf7107b3cee2092799135dd3faeae67e4789ef7c8a85ddcc61f7a1ea9755532e33a837d409f7d656b61e335d8e8eca29c0d88273d3870df9967283087c1e17e9c5da93338a584e90de34de2f4f1ccf90ca07c45b460fc0b10641c80a9a6071d22739fdf86f1faf5b6ac6fab54ab227d7907ec2ff180d89e5d8bc072f4e622cfee725dc604a5458b737d320d591aec7d512f9c109ee33c7089d8f7c06372a1861ca7751baed3ca31a3897bd061b7b20c2f1c99b0c1b939a680e744776ccd86c8099a026d0a0ed13c954ea727c06a1922d1967f4b8ad83396ea264762076a4d448a6591b04d6d05b7db84134d67813914d906d7fa0fe4debb379866b5220b48fc7fe20921f4dd4170ecbdf17334372621b26b35235645fcbcac83cc9f4b1d3a7885324fe659540a213711525ada43bf96eeef87d907c10d0c6c584b958ca68ebd593582f67675c14680f6ca435271fb8e7a454cc078a7826f747bf364aef9f3b85eeba1f6cdf6d2365084153cbb5c358891ab118bf5ed7ead7bd51b4fd300c37a3c2de34f6f907775db057bfad2d28d372c67be0009eb65a1c810370433626577c80a21916769e9de83908577dcbd1017b784d1dc1c22a8f2172ac37c10cdb5db7f13dabf8d9d83385c488ff96b8c317dc05bd1280030823f27c0de2cedfd1165d2097e016b9eac8f8ceb639a3f0c35967c42ca07b053a3a76b0d48dda3f4201a312a1d04c63d4f07420be620d4d1ea0a31be4c493fe922e7be3a9525f93d61b224e5619ca989f1c770dec70a3c011ccd1d224054f1d9c5088c1573ba7e380a4ec945d77b5f03f40e517bc7075bba8a43647bb12b2321830d44b873163a8e92d3b089225c76461f0bcdd65b518e34c43030bda61456497fe0bf2432fae0e5709bb689d583b4b8d98ac38fe9f77772b796d1644a9138ac10b4ca72747357b935ac355ccde538c8485f32f587722baba0e9ca49125283f9d5f9bbf1a47b979dd186a72b8cf655a58e8941cbc2e7b7199e5330bd42064bb555a8094c3ffb988bf6b3b72b59c90d030d86ff8fb94ddb4d54a15a5bd823c0f25d4522a0bf4815a5131391ff654018182cd82214543d1528c9e8555915df4e45392fd35b3211c3af40608ab81bcfba39acac5b8ffc2bd5c90392758ef061bf7f713ae74be81e589afbee15fe5efeaae21d8f7abef3fcf7a22dfabdc77bb34f5eb4a3541ab8c11c132b5c0662a754e6436610d5b859dfdaae192ded6cab9bc81e354d0852e7115d6e833d9f4392067eba3f01ee1c21f7a4728c841ee590d17e990d6c32147525d3dfe55f1029050e1e37febf7fc38930b8169fa16f564c9da1bc546aaa18f74b543cde2fa8b85cabc2a8ce802d64adf6dd7a0facee9cdb928b828f50969992b485d749b0d508bd9303d82864f92c087dd5ae420ccfc4b8e26a07a72e914895e4eebea04ab682ceb61db32e411b4920a5a45a0d284872a50541ee9d3eff2510935955e7524fb106ef246542f7f5bad0dd1e65bfb8812a03fe5c147e05f25a0ce7adb0897d24f2fbd12b9901655b272024f347f9a54ce85ea4f5eba2d95ffc3f1f4756edab9c2e02276edae093c1808e8342541d7cb3c91243fc5ab010f2e2aece4a2bfc8a37b0129acf2483fc16f4fff7cf141854df0217497db7cc6e9ba72481b00aace3a4651f0fe9b61cb61f72472e122f000f72d56eaf8808fd8d4fa8920e5f267f075294de7f7ec4a6f7af38e22374dbc759c1cd5f9b68342b262e26c28b4d2e0a3ee97741f81c93d5099b965e8600e1421cc7ba2aa9e270c468e41f37115c00dc2df12291174cf1670993f8ac61c69f94f3da18feceae9f89f484957cc058212157e85765b6ff20de5ec83fa695a8b033518e526c8fe503054f4971925fab12d43713c751b38f84e46ef013ff6357ced4e167b970bb25ca8964dbee97826cfede0fd8c67be79fc51a74129dab4cea40f8830ab3bfbec16e65171d8e6ef01b50eb5f3abaffafac83c2336ca095e0f9f9ed7f07e1221f0e3da0a0bd0e8d16d0643ab90c2183c9c7f3d0bca86c85af18058ad294ab76c7c73377ffc573b2c3dcdc2c3e9d0d98de5735ad05a3d4cbc7adc3e147ab8164d6877a97c3325af9fb3416d062d8ba3580b67dc3ecda6f9c939dfc419c03b922dca23432ee1588d669dfc7a1797972ca892ff1873987dfa43b287dd3f5a20a342eafe51625da37fd68dd157ef0581c233b050d10ec1252c3ae1a26d36085ff15d7426fae75deb40be2c75f1000f1ab57597b1f0febc4291254a62e2a838c90e0e70de21a42902f1efda3b1eee59fbaf8e685b743977b35af1ffa5bd363a642e5de3610e899f972405dee51347bab2d751d3b5238b0ee9f255200f6ad4781d866203342c4166a39dd6725486d6fa09a95fabe571ea35e3060d58f57eea435d00054972c5a8595053922075e935cb31c3b5107497da69d8b3574575f5967d4f553f1c153dbe2f76ab0db45204e684cca2e1a04401e2d3d1060d2d6444ea8c0d7f5d68dd8b19b7c52374bb54a2f614dfdd192b1ce352085c7452723165303032eb54a31321bf7ed39307dbb69a29509aeed97bd0db2a83a01afee9adde2e933ea4940cfebc20a059fde6ec5e34de2b61afe34141f7232b243fde7c303442ff970ad6d56e7fb68e0ab56d95f8fb4cf3e7d2281edfe3b435562345c20d16e2d64f86e9b2fe69e7056715103cf4def0c155e02586b91170a75752ab0adafbb8ebc0ddf3fb2d45fdc8030987bf11e96551a8dc1fa41c6d4a8472b64d57180df02a14558e6bc44322bb48494452ba15f1a9789664a45d94648e9dc7839713082fb11d1e5571ae9917b45a53803f67b4988f302c12b5bd04d2a2a59e6c6527b251c0d1534cbcd61318a36c49f8f9336635a650cdc261089db01d3b95c7a4d93f9a5de869837bb8be48955b938f15916d19b25ba2b397ae1abe0012ecff048a90f5915595a248afcb306bd3d4649de4379530a24322c63efb694046b7cabe45728f89ec254cd50d82bb8f4310b605cb0430d1fa2f75a3be66e89542f566f02e722be908a0ad61f36fae32f59d4dd0ae2cef99b5accc0710f0f97f858e8beb40abab2b1744fde5ff7ab60ecaf1ee3a211f2ee3ba3891cfcbfe7ab69955953d49702a413d8beaa64db9fa49b6f6f9a6c0c14a11f7c16dfc4b8bcbe33a25e7aef8a359a9a50a66915d449865aa232a054113ac4df200203b9bf2a3f2357042de4b525a32cf1a94d74e709e88e621db23303c7e4756cd70747e5c471b9bbc7e9e18522a9e9001c7cf8c930a172de7cd0f89af136680702e89b584249e44d77086442fb77591f75a0f61326d9ecc6ce66eacfd38297726cf6cd481009b86892d6230fc6a280a0804224bf051e7145b2d4cbe892f169d2edcffc79e308ed0307e1c3ef81438c8bec63f2fcd0e67cde869a3f98da5ff4426f24bc14b87673e2deac3ac49442f880a3108209e7af925648481c5c9b28d9a1ae1224f4e3eeb4dfed812369b0eb643904c5ae1e917be504baebdf8dba5629ef9ba400eb0db10dcf560fb6124b060a3441151defd99954da2327836d0c6f79ef09c97dbf331ea16045181dd2ce566afdc523de6c79e680af2f0a5575e8472d83734c92771e5fab441603908dece78ec0dedb92d1329786db858f884c4f942a59917d34356a705525fef58a3c0bfc7af9ba3eb7c4625751520027e033b26ae9984674f9799e12d535641f89db00be7d7191c5aee935b670f83b3f03d26d68752693f676b22be80655b062bb9e1ce2fd36b51ec8b93aa2f8414ea2c0d48529c6af8e49478fbc93cba2649fa32534b83c9d91942ee01dc07d2073f09a01285726fe1bb5a21346240d5179b76714bc2d23b13767c2ffe5af19a18fe8a147dbf43ddd105eb06cdcd9e019dbcbb31f29b40b4f06a3564c525a304cc361d05e51c2e3eec9b25ad4af17d3f8909920fe58cd2d99a23032b3fa221f51630586075902a96036610d76e0da946e2b26e5b9b2439f2dab237caae0e50c64badf45566daf439e87003fbbb1bdf2e9ff681e36f025d030e98ae2dbfd9d7158f8b48eed87547d67dcbafcd06f562de214c1cb2271c299c80f34d4297f23c54475878a09de8de31de5b383991f177e35287e3b29ad252eece9bb2e9542bec6c4bfb92271a51cd6c05f3698143209b859a43a55914a06899682c2fd59c8cb197f1bbcf762bc5d30e1dde8331d121dc7963fec04e3e2656f3bcec6c1f67e64441e44f53a69d3b71a0d2cee3b07cc610c2394611f8eafa0100bedb38b2aa1434e906cbed9e01fb537a4b5f45339dd222d886bdd4cb9f1fb79f9f041ad36a17583503e6ba271b9b505851523954ad107f0fb118de85502ae7871a9ba7fbceb2e86c8e65bdd3eaec87928e484f91be995d55b2ff61900dca00820ae501d39a694eab1b44e3172f8593e672fe6ad829ba5dd8ad6f8d4066910b27fedfb49a0aa668afb948c54c1fb5895e0ef57568d76f17002bc768f81fbd8b4108f19c27d4490664e4668d3afd96e128b43c8ed150b5db557e251bf997de7144f00fee2b01591c92c43c81078ec877f866614d4337ac12047cdd537188fc9171d8bfbf441298961b2562c744e43ff2372eeedb21aa5487defbc800af3b322701982f238734970e3b577312aa9487faf10212a37d2c880a07b22ae2b6e3bf6553e53061a7035aff8d388f1255258743fb48abb53daf9d5e731f9e2b004fd0b8e6be6f1acaf049715a858957497d97e559559ae3993cea5030bd70406463fcfb90d4d7fe3378063bff78cb9990de0f2c0678af44cdf109f369a4230fe60df50944905462ea8b6cf4e49e7293f5b4f6743873dfd73ee328a3c7da02f0189f5146d95bf8517adac1329d9ebc98dbae0136809c3d2245fbb2199ad5d87a0d0c4ec2a1a2a664515736b4b4af4c18611690c9b69f395a563a62f425fc9d5e1b4f7e5ce687826c7f1f66959b3afca7357d8f927de78bd6b2bda44319f7f27853a96cb395b33d6772a3964872a9649b8c068603048f4129c7d90bebdef06de342b7a2ca6b0f25b1b3c0eedb40797a3cfb2905ccacd4d668e451a9ce8059e71c93fd403588abbe03dd993e2d7fbb79e4258cb61abfc4d3b2bc46ac41bdf86cd16100cefc267ad7a3163ca251ea837bb1001b74cff09708a976337110f93d8f3c5f8b4bd31e30ff860f348c352d3f94148febe5f1579fbec41144da1ede13bb4f6dd7dade54250f952b1dc00e3b05554ed3f480d94022eb1ab974fcf820de4357e77f4d48f5f422cee5880c79a0bc4d58fd386153ca083b7273f31b73295c06b63a9d0d1b0ad4f69f602d875b6c2279c28a2ab32cd4e8885944c82530cf3267df6a7c4118b7a14a1d638d40b28955c82dd3be753046c8ce1c255beb13a0d321f0211d11d9a81524109a5768c97f9fb0d23371a4e93d29ec506d1fd2e467b89ab18d02ba1294c53b05ac25099c3074dad6c79ee239eb558369090949941a957b189483eb9ae1aa897a732ac22243a4544e317ed32ff7570e31abbd465fcb4ffb30210eeead424f6f052540603581182e25f7b1c640336e0a02ba38cb6b7e91dcc956a57ff01bb2d3d0e3a003347e21c8aa852754e4fcc4d524495d23ab751a42d1d93ff4cccb8f4471e213a8ba1a305ad705bf0ee20893cf0cf55564218686e7e9650b952eb29d66eaf268949f2ea3b97fa808b6d2b90f0d288066867ca398133a7b7ba60257f84d87077d00bc9932d0104a8fdd9d9a7c968890e1b5264c0574b11a23ef84a350eee24fe1ad6ed9bf46468f903f06e804394166aadf6ccd042c268cf4a770516d95456ab9a9ba250614adedc1805cd75bb319266203ce84d6ada1d92af678567a67320270b261e8012d26f6f8a8859abd42e7af7ae580c0526bc66bcb8b6df0e85a10f48ee055f5c76881d5f364de44aa9cc230bf79e7ba2961403044be6cf51502f33700d18172f6169089dff30b7532c303b7a74eb6acc97a3f075a01bb84c2dade68c2fc92fb7af91547f449c6cc2cb5634699fd4f708137343a8ba85f13792a248c9f02cef842efa80369da1dd8a4afc3a81fcb5228b725c8c173ddb6f1947c4fed46cfd4271be526db7fbd5f4f3bcbe6216cfcc180f926c9549b94ce0f8f9ac11fa4fc5ed6a92fdf1908f813414c9294de84ef9b0dccd71e4a5c0eeab4d942398fe340ad91ee232c888fe9024311c029ae88669ecb58ae0e16d4c113ee6864fc81ec8d4d7dfb0bb87f8286d044a116f27db96c39ae09bdbd1c41e4a108feb6f5ed344646ef5b7acf11c9778cd265d7a5cb7b72a4062b4429381d8b5a0e2a3deba7007f557ffcb1a38ed6021af49356a1137ec242d4dbd585d1a37c4f50efdd3e56fc6e03220da613f3b18dc3d384c24877706f1a28efbf94982511359974515209f3b7f57a5e93870cede634cbedd3e1c1f14a3cbad59b9c2d956104882789cabab4ae24664d954e75f06e3b8ab9aa967fa60d517306559b6a58aa19ff637f5d682737c5230a704eb5fd182a048f1d575df1bf81ba0918e6b341f0b0d17f8fc269e60aa8643dccd4391119f40d7e763f356a1e12ebb20040e576a4ac93366e9d4ef3a264882c9308a2c31c61608ff62c208d3a9941318acb047ee7fffcaa063ccf3fa4d3813ca87ca92d4c0fea129c87d23d1fde8b2ac589d7521bc76f32ec497e870329f5b0c87a135e377ea671e6c4e8d97dc7b669abdfc2b16bc0a0fd671d4b7ea4829ecccc8cbdb653d0b481a97d1ce0ce330828b008669d116e0e4d0dfa76220aa343335f4660f1c690ec535d9548c53c3d5a53cdff918abe59454d7a5a2f497d8220650c2bfa8df06b64152edbe6b1bfa48cf2c31a101bbf762d1220d70df5be69824a1988091ec4187df11a382ad5402586c2fd95b38b921a2bf90b132a6c4906f7791b396ac164e865ce635b2759c94c0e0388fae79632034c80131182c860da8b2ff34fba5e9d933b2ab457b16b78867509b9e9c29e9c1391c35be305662554fbcf24b0391e5c442f211f189859da9f9e5c73cffe93184ffbf4d23dac1c444a556ff5ca6287886495bbc7fd7d48f360c87c3dd98fda82bdda669783e1f0fc24ff4b21a96a95e1db40cf188e2ada8b6185f8e4cb962a7a8ea0bfe14666c86de011ca8c573780de2cd9ae2c55ef1f854b6aff05ad12641fbd38f40cf6bcdcd572f389011731792571ce4b0de923214d77e26f1b3516a28932be2f0d902952c4a7d3c509f71c6ac6b3414c30aaaff3deef739b564148c135d3d28eb7ecdc6646520326e6000505b752b0243a89ca0542b40a39ca0e027e5b0b13f0e559bb9ae3e5e2e711e4f714e596bfac66a8f95c0883a321b547c96b3539e26fdc8704cb3c901316a01c2ff15c4879d10a340ed48d95c2331d079744a5ced7a9f2e6213575e7e91a06e4611c5c660c7ccef890117ad7bf41eb35f76dddb37138d8bd1a2a41c8ad06ca29b6331d81b1b8910e877a9faed09d5dc17cf3fd23252ca8c812aa1cbae34b4fdc2a959bada0567b4633489bdde3a359fe80fe440bdbcd4d740896a7cdd34d64008ab0592007b08dfcc0ca7dbeb3372d7cfd0a77b93b30329ac9a6291ad373652cd5b398b9047320c02ceef984aa7fc881823172d3001c90d01b8cdd0be9e31d07909cbade1c9410016a67711bb887efae76dfe12520bb8af8365cf2f69ac6dcecae06f68d7817d7669293fd0fd1afad8636d27a8e1fd4005ed2e4a979a01da34f1278ee89942ad79028ce4b80199685627868aca561f874d375004ccabcc8565b76687cd125fb8cc73aac840536b1dc54470c1a19f2170cfe448ef33f1244624e6a5db4af2880f2d25eb32623d437b71dc74b0275d8db8b09b8f1984a4a8a60763512b066ba391ad0c6adf9300cd8be042b9066f658265753eb5c5cd1aa6c8bd3163f2d68231fcb4be5e8c46082915c8758c3b1382272cd381c55f7be497b72740ff9348edd9a95f5298aa83767b3f07b3576cb846e0540a5b875ddc8b47c5d0dc2b35d7b395bb946e0de3a6929a1503a2b70678c5ad446820e50732ddb04e51cb70ed9b0766ebc30c4e0cfb4f29756af89ae71f91a7b90c488dd9db4f5dd7959e83afb5eecab913da201d0cfa9d8371e403e3342fd044ae5ae07858906aef26c3a8296a15eec0e4ca8e9b8f82274ae2d3fffd4c810502ae45fc00ee3ccf3cc95199cf3899c9d391eba970098d44cc8fe47db150dfc4894c96c94def51a8a53154d7f2dfe3cf7a95010b14c974152099c26a94e34f905d49e1409932bacee09424f3359c6f58a95ad5415de66a8d52f76c85f06a71d58da9b3b8c6b33f6aee1146a11ae7439a58a3941e98a09bc346bb94623c9cffacfc354875c1b4d348f8d8ae301415620e312bd9d46e66ae9ab63351884e04b551ae931abffd8b0215d07c289cac266eabd529cfa20e0251a1444ee0b0060b6d2ee06b44c61341eef3f5769b707816d0674eec7f6c3e809d2e9949e06e95bae0f17a143836899625693295280fe6d6882b645773ee676424ccf35425168dcd0718bb30cb08f6a69e5a7c0ccd4ac6b3f72f1471283fc261d2a8ab92c3fb06118b2639b25cca116c6a4d859997d1dc2b9dc811241a73fb02782c3195b1710875aa9c4f50475ff638e2728feaee74f79be6a138e900e158b2a5a038745a2c5a7c0fc39472eb1f33a618189519754221d010bd06b077a7c0f0a0b8f15036d7c958282428bd82b454e78f86dbacba4965668db2e463280b2a3edd9d4912abdf35f5c9d4c5db5a52d291ae10a75f4a34fadc206c84cfa9fdfbb9e20ce1324c2d6c046df32ed6bac8dc2c6d9de6aa1dcae67f5928ef0aab693f824bdf61099e371419f211888c10a14fcec81853424402de1b46260160c0cdf855a88823bd1ff487ac557a3d9ba257fd11ec73389edf32f966054e035cfa7976d7a5f0cf1487b2261c9173d35b2056b5a9aafbc7c28f7a057d85a952568213a292c060b8638fa2e61665dabe4bb60dc8a4e87d19219bb69276c08dca3f2e8ad50d329c5a70ac4b3deb4c0dbb10892dd15461cc3abb29b5d42f50c358c3f0bbcb3f5c27616fc91ad5e40ef829d5bd6b4ff73b7cf9da44d5006105df6c94b1f19f864ad32d86135c192f67b7f484957dff92021ed00d213d590927277f2fad37f66e11233ebd72397811d9bd62861ec27a3619727963a2c7a4a83a26b27f675e773fd28cd8b617d8f12ae838b154c56243277adc01eb582d01a79b42a05d2d31292ff9df689a9a1a64a540c3954022856ad1f7ea97a084cae4b19566d582a3caaa957ebdb8ccf13848a57843f6e9f049b9aca927bfe83a2dc3b3802082cd1afb691fb2314e6d714ef237b672369a7626c3ae932686c20f28e40a808938aec4ebf19858a8e7a4949bbd5eb34b95396e2c23347bf0e9326d917c91549adecbc428da7419a55839fd9b2a72bb4d03bf77588ba076ac1b11acff1959633b1bbd51ddfc1801da6dca9eb80cf64f0bb8dac3faccf46e176c2714fb5630043c85d793902a154d57d7ea4a9b84c20ed980268b1104e0ab0d22d41a9df685842670ff0f67b29bb2790b13bfde0c3a21a6b3a95a8fb7a433debcd7cb4031e4b4ee0013ba6626efcb810a026136200b633705cf3306efc2f0ead8c2adc53597c127b0d5bea0d6430c926d06cd191c01a34fc2a7134defc9d2dd055fa6892c228374f50199fbf4cbe3f2f3a1d82f11ae81945d2539201992feac8926c9d1f9cedbcc71f76069c17f515b02b8a07af7a4fcdfb07f13ef9a50bf72857eb6d5dda06ffbaf697828d115389f1a979e83d28bce785e2736aa7cdb1a6cdcf8a244dd3c15fc92404f5de50c9f38dceafcf8b9649c4af8cc69fedfcc27fb64f47e259921413491a9f861b8adee80bd909240a0e123bbadd86d6c81feb35997f5727374a8b2ccc8765bbe37836173213de711932de29c6899707949e2a3b14ecbd24a2959c62e05fae44cb9c9d796f5103dfb253b90a758895e4c18c1b68796fd1673199ec013746ae5d6a1d852b1e5db86ef7dfd8444e0e759978c66a1cef3a6a551465ae172d5f08ee37d11883f2339657549ec855fc841d829e535febc419f5713a41c0a3d36a61132892cd35c18e4f11567ce1c0cbc9f07991973f6c73a64a4c1922c1e91db6b88162d4c1972134de196ae7e02bf6a50078205533b1e50f451d7869bae933c99493ceb9d187c3d3278d6926614527e34c7171235f8063200cb24e98f907c61d3a43d869071d2344276a2bccef06fec5dee803fb5152cf8ad488828979ab49bce637fb95c205fb821e9cb291e019f2f10d82424bb99581dc71a451ba8539197a4d9962a7b2400f7465d41ba5b4924d375e237ad6bf5785668455719b97f078938f38c6b7c0fd124745a3766548edc5c62af4dec8a01db5041ca9d4e0f96d0ff970cf3bcf600a6a6d555ecb504f54aedbfcc1dd973788fbf6c62bb630a0c44a14e828b8e2b7dd057fd7f9b8a74d1dc2e9f2ede7cc75ad936e070db9621adb26ec3001da10a8f2246d71d69895fe9f0f0eafb5cf96225e8f0b318931c3d37e9faf2407b11250fbb4bc1f20c0e8c615aaea83fa0286e8697ab1cdce4d84b5be24c1bae8d9f0a7d2d47cda76621d46272cbf7a9b422f0a000d8f0b997712bdafcad88138aef27b8bc6d9ddd44b7d8ec3b601badf8ee47ff9344410991cec925d5ff1d938b44ea24910943b093969d0750c4b7cb20f976e6fb22614b32973ee977c98e7d93b595db653a5d9f0225a134a38390aaa6dfad13ecf89abc09b3641f7a4c7faf97da91b1a3ed597aa5c9ef9314ce954095ee0712b72f168bb42ee2dbac032dd8f1332c46a3007c7300cd5d6b72c8f4d7f6c4a1d0fb778e3a774bc016e78d9dfbe0f94ce513cc7e85ad293c94ca19d8d8a608db2e7a8ee3d559768efb327ce262d0076ea400abdd6adc806637f92348c1c8eb15a284b26b635bcc7aa9160e999484fb7aea71800e52bc892fb4cfa55e354ce82cdf25b77ff4f86f3e6b7d71e0ee5bc7ca9f06d6cea62b25adc629128ce2b658c499adf6420f9f795c9b71561c2b7a9452cf6c807e908c5ec8f0720332b550a682e8a653430c607983ed091b06e1a3253a49844e1401b52c4c441efc5e2cfacd244706771faf7beb715feb25c7516ae43f69dc2c2fd8dd1c61c9f32d85ef00cc7dbb208b8897f154f041c826bacbd928f218e854e9f8ee3d986a979a42dc2a2bf41c52ac00a9d991705e7eaab52a8dbaded199356b1beb048fa1edececf9a5e558124e0609a9f2cb4cb40a67e6e9e23fc74a123d75d7e12517d165168b0bd45767e3300cfedd893917f2634f96316c6be7ca48a05847f65767eda0596140f3ec54d6f6e6281e9276a262a97c07847d94bc6a9e9e51f363443d28ef4abcf2926c5117240b346dd5ab291f5e465bb48320b9d7a6b4f485dd7571c34ae0932691f91610f7d11a079c4bb0e0ff13d26df729b2e2a607b1a47850bd034358bfd01a4583c4a17c30bac3601472e99769f289294d22b6f606428b46ee3904c04343eb854b76606fb3d6bacc195ac5e35360dd5986bbf95ef54c073591c61b4af8d040cadebe1059c321face4181c01c3495939f8ba1d598e02c787a82d9f45c4905c243f55b7fd23c15cadf253a7b611a02691000075d7eaf430870e00f3b08a5e4f1b2230fa18fe611be0a56152d487cb183fc26f92508adae6df31d2ef81c7edd712e14deb567f7b11102642e18b908e016a7e17920dbd7c82d043458c66ebf643c389512d7264e806dc6742866a54ed754d19c5714a0e6abf3b8696b4ea5f2fbc690df5200eade3cd10c27c147f017812aeb3c472126ccf7302aed41c20cf46bd93f84dc5e3b7261ab4b384372fa6cf666d771812eaf56d6fb328557d1ee5fc2d4fa384c8761fd48f110028b9517fe472f111771f1a5fbaa27977a987ab6d755506c5b6b67171d38f6773020068440d4f2af3e73f5887720ac2db774a83abb2add87bea4618bb5e4c4785b02fca4e7e8cf87c1ea91144bd8ca8789fbe77154df5d165142c23f7f79c63e6fda5ecb82f8dfc55980953c02d7aba3ee7dfd7582a2b74256f6097ea2f328aa669f7ee3cf5ba66bdd8c66c103a8961da8e2784be58fb4a995e5e5d67ec92bdbcb2214b522dc6f95e0ca820ed2f3df617ce86fee0d448ec2ba76e1577b21aaaee55f5602da288d0f50a7a86ff6f76bce8eca2b10467e5770ee246dec00ef50768be6b7f5419dbc977118bb82a315b6991e3e942e19edd6fc14fdb589353fdb26e8d97587c99db5d07175dfc9320f0e0aa421520866c78f34ecdf68061a717dbe60c53066b96f17aacf72219d655168a79615ba2f8d8e2192693ec7d73a90ec7e02a39a2f0a9448164307d6072cc31a038c07b4a47abebab8204c62a26bcdef6bb1536755ef6e5b502db7362b1c14be5a4c3394dfaa5422548569be64ea3690722333284f70dbf455c70b6f042d42cb9e20f9540b58ec0723822c81eb03f744bbcf87ef1a42f070e33f14e21aede2c4dd7c4ef68b387f55e90e4757e63382f85149aed188359c2cca5306b322e7307f04bca8e0bbeb1e018c4cc367516b9567079137a47a498ffbd2ed0c7ace1066abccb3b0f5f3966c7a1ddd2f49f0e3f2ba11223882dbb2016911779a357a17ebec43eafb4f75e62be0893ef290f1b3254c761e79ad26cab0b1db4df034fbb88b542b5adb43ea3b012937d83c6cb6cd3b5fbeab723bee685301a30f96a0abb3c1e713a58039ace0977f8c9e51accaa8be29394a66981ec9aa629fefd7ca3346c1fcdf5e13b95ab972224356963487107464ec0a9654c89fb2b7065bc3d04e13655366fa7d7f5df1cb03287276667d88e5277fe8eb05b3811602d2436c57b34b4382c1e3eb4fa7d3d4bead0db41b47daec7760008219742cd8293b7ed5ca75da177eea13920a20355eefdd5510ba24848259b2226a9a95a23b365560fbdeff62fd488033cb1c7841ffdb04bf7b6855840879e72bd4cb7b3c072847a4b229101c1224b4359d5c250bf47f1725ad1c8e630b0325ce5d02080829211271369d425383cb5d6f632fa8dd5572385c2b322317c195de04aef5a62447dbfb154b61d03fb4b7dd7398ddc21023065fd7a85373f7a289474a084b0d39a6068be01a2abe7bd07ee99532f3da7a9d0b317165ee8dcd251baed8ff5f6094400e99dfe3a99b87b2c7d1d97f5e683ef12ef1a27a6344572e0fa7a557c7de0af84b598473b5b4f6e5783feb67fda44b50f102d6851cfb40f018d980f3e3617046967033237de873fbccea72bffd3e18ac564124c61ff5b03e7977d3f83782dd996ef2283d566b1f73f78bdd22fc26cddb6114a6dcb50d7cb9c4709f3ecfb185323dcfbab5f00f0ccee8dab831c6ebad95dee5bd22f1c820b34dc3f8e778cdbb7063570e0868d104aad5cec812c83e182f8a1871439c8456b88b698d6a11449d869a4be6f28a9f2c33f69e0758d982be6f00638b193566d0eaaea4c2bed0e7fb86534a8383ad9602e8a76a75b5d5477b57d0f0931eb2cff50e5609b2304584f756d93820c398040ac3d315d66b5ebf5a057ca687b73b6cd36d071af1b7c4d02dc44ef24640e47c3c6098a98cd7d5f5c68229081f9d93db1449fc3fd333e99e1e3c6d36513f6f9b24d7fb0ea185e2400bf73a72f84b6649af235853d85b0c77f73501cf7d8e47b3227b9fa319e5aaf4532191a2e0b8b14b0ea45a07bd2f3fd5005caf370838cea8d3e3f4cde74bc4c20cf0f1fee292a684420e83ddd9afd6d6fb3af081e0812470933290c87f66a48ca1839b21108afa954e48590cbad13b14e334e3122a3113d6b69df64126791f58634c6cf0a1b512503de5088d766142997cca7e596eeb33136f9861f107051fae9fa6ab5bc5a753123ec1ef5d4719687a56fc38d99c241e0ae96d22dc8b191237698c9b2b79b414b9ce0089a97ac6bb3e9b692118a7d1b52e6dbb68cd828badef94b3906175855184ecf0bd140a6a0276cc507671ffa093f2509f1851742fcb6fd523d2f68b4628a9eb11acc3f4816cd4887ae76bce7a0b9af79691503083f509212c0cb600b37ee89f15b81bcdcca39c5f3aab3840aa283ed68a7b9f3da9210fde87f9765f31faa7927580f271c6255e6d2a57b2ec2978c40fab0e2d50cb9397c82ced05b2ae6a6cc15bb1390dbcd8bf43f8e4ea4a6533281f347153562be064fd6eaf13287a7d9b57e31a44af5b8f1aadf5d11b66bfd5b04640e7e5762069f0aa9b6faac1de7b99c18dfdcccca956b51c976a63b95ecca7be727f2bf3de82f57d42ab33946b483e142ccfbc9cad20c2cb8036409d09515fcaac996b22c019e9daadfef6e6bbecd1f96f8116ece26d2649c236575cd3126d569c5d30c6f31773cf43f39b4036b7dabdfcf8a6f68974aa0ea27e63cad56755273c3a56bbe79b1d554bf0630c8fbb9cb7a9e5be4435ef3e7bbaafaae474db257cd98c4e1f121c60b4b5e27a37520413901d6e707478360910c418d9ceef1d35fabe5ec5d4e4fb948d70e2400aef58f84ae209a0488d9228378bd4ccf083482a22069558f2172bf3c9ac98b52e43add71a787da70cdd702ae9c3ebb32dd54f506114250f7e506cedbc83a41dd4914d2efb899515fc9bd9b43830f946cb58f2a35efb0da80e986eb7bc6d4544d4858c88e6dafa4c4aea862845dd89d6b952e3f638ac4b21bf36814184f33f3fb19e13aa0002cc0e1c1b07ab568b347526bbe41c6ff279ee8c5634b2f28fcea0c9c52bd0ca51ff1dfa7bd3eeb0c03650259452aec3a4df09c9861d2efe6bf0578e99546960d557d62b7e6618858667fab37bd3aa99a05f40a81e637b81ed040dc8975b049de8448ec2e072ed07d9633bf4c927bd58c9771fe5e93c8be87047c3bdd60c71d92cfe773d78ae6b2271bbd65953785fa72d0055ddbe309e150ca8ce37e7ebf0466190840a4080b5b69eb66236c0afe3b0b85a33ba5e7e00b83aa3065caca723c1d4e83b41949eb644c46eec03ecef7df41e827e214d8cbf5883367556ec9ccf589ae6b38ab14b4842e143c850bf986c12a1c0a8a4c9e218edd1c5744ebba2a0453ecdea2e1d3b8e38db1f787c9933890e1dea53bc51253370b7f61f7731c3e9062002ac95ca1a16a91580bd5a30ff0efbdcb1a8553b01cd055ec63000cf0b5cfe7f6fca8c1c85c0fef0393cda008f83fe571038ad57cd4c641ed4adcc4eef8fb0c36b198b754ae519bd5fa51ca96328cc2b4189c3787627a3b852f6dadb116430a1564f9128c5744c74486ca2e77773d8467ded79ac2259c020e9fb6adf77fbf97560961cdb0d60dbf4cc82dcc9695fd752f1d188fc6448d100f436ae61aae199c9f5ea419b095005bbbb454998a277b8d8d9e3683dcc54a3048d1c2c6e7a63c6f8152a01ea47190f8984f3b3fe55c4543a33c849e70ed7dc2468cd4f4fb2dbbdc3ec003271a6816c1890bcc999296cc70d232b9911eb255b4e3c75166bfc461e561b697e325ea1f948e9a07b5b7c7ee73e139694e5f928afa636ba78d29fe6a6585eddbc861e5898dfe35a90314efe73a16f6a4586b747b19f9808569c32d0202a7d526d1aebe97a3beed38ab48395a393574f6753816664166dd49384ebef144e3ecbf11efcbe3731056ba87dd0beb95c3dd71285852ea7d6623029d706a335abeb3fff2a127d60c978080608755077caed328c3a72602816050c8d175b28f1a305c29813bae9d0f4c38fc6a3ce92653df3927b730416d79c6b02c1a99f5c0c2b46fbccde62a6bdbeb5a3d82731354aa0dbf44106ee500a962eef40a6a8745cdb2ae2747b7ac53906772c98bdb51b9e9defc9ef9a2e330741248a9835f378f0f29133e0932cf77a15d055e00164825f7357d4933ac88f453e2a6e1ac52c39b53c3fbbea88b81e60d50d43b51479f08016750792bb278b2d1e8b6c7dfffe236d8d4483ea96e28053966c43a0c76f72225adafa06ce9f69fb6a8af4663540f0511ddbea0bbcfc2630fceaf9109a18c29dd3f6b67df19b1b4a0836cb8c936b47ed8e8155e2affbbff2b06b35aea6bc9fce6438208ffb0ef55c461b50582f4b40292abadf944b8c2346d4263f5488c0e9a146fd67395104456d37ec3e4f5d4024d2376f815ffd8f60e9caf46d1605d4a4121f3706159a67ac94b30ccfeeab5e86d54928c499e4e83cdc1ea007be63ee064c9abc0242dc7a6999c14708fa85eca1bd318be2d94dd41bb9922bd79f0ff72993d49c6f1550789ebe153401999f7e0a9cfc40fffbf86d5a9b0286400ea134c891fee5c132e77da5847da87b46b196c39dd1e06cd3f81cfd9570184f7bc79ff47706063c4867c30af30ad77609e08a1f85fab22c285cc66c6e6ade61c9db4295f1ad80a110e23fc3d63fae64358d948b022b4323972b303ce6f6fdc021b6aed3828fc22501853b4bf6c7d1d3a9a9197d1ed9383a750dc402641be4fc546da4429c2dfb952799da2c694abe95749498b270c44c24884d4454be797c7dbeb572783400c8f6c6dfc07e27a887e53da70632c4e9df376178bcbe5d9c7f2c5048bc29c4505c03d9d34dbac0dc15ef8f41d978bedf624e00f2ec619fe66e37c21e1ae976983da2d9ffafd265253371eccf9ddbdb1269b8ce86f6d08cc9b85f7a183dc4cde3a21dd77a31f4a982ba4223a042db54a50072c162dfb952144f8d086779ef8b2aa70bc3e9a072d1444e33a6e6f7ecfe94c0102ef004316a46ef7e70c828843094d7addf2c1008c6cc3acf3cf4fec3b96d22bee18fed66e9d87181b8dc99da07a0f93a9b26d8f1a9bf69671527fe06e1670bd27329d67c32541c1a7e2e72af899d932b5b230dbff8f6dff184120ebd18cf4f0350e86e50ff4a47cd2531240c9dabe3a239111ab624448343c48dedd3ca479ad72ce8ef8f8897187aab17726d9d070e2c3cf91066046874b4d39874f2cc86586bf58fb9f8e041161e98c121e657468bdc995bb61d3c6b4bf08dc6dc01d0f32b71c89a91d7f6b664cf4bcf86251bae3ce09ea1c4e9660a77bf3f01bb88c7b1cede29849f9d32baa5bf160fb30452dec61c9864587c397e7b059be1d442e5828fc37df7b148cee7876b65d899ee0b8922344affcc183bb8dbe3f6f1e618887f745345fa97fd3b4778027604f6b4bda4ed3aa8a31763dee5d36f92e465151ac1427a5a083dbbe2f20e55b655a665acd1b36101de4c2420054e60484bb2c42b02d7ac030496e3a662f36389d424ac1763b8ce851a79637e38cafad303797afc4dc989ae4d54ac52b4c99be1cf85fc1569595e948081864e2f2f9c077c26bc42e5669c4fd178b53611165e8b967b9b3ce3d7c47312f4221e87b4ab7e49126ba1f8b5925a64a811d03e7b7ef43eb2e2cb22fa0383d94d46f5368d1e0aa6722e05c67424e0bd89aeeddb8191ae2d3d9fc55547d457b38340b20023351462e17d4389e67f620d5de3e51280b35ce29c53ac86454776fed7ea5582254eddbd36088ef3479b01962c423373a9412842a97695eb7eefcf732b6b87585f37e49b87b31e28b49e47d0ff8729e282a781f613fae39f0dd10153b900b57329a72a983e07c3ee36bc05b8fab917d733b105614d8306ff1e4358e9fdf826830d129d7d31b9852a7c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
