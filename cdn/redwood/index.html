<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"512cf9581ddcf5ebc16367a2d081e3989f1e6ab63bd78e819a90d340244485777495883b3da482798bcabfe17bf5dcd02a7f4743da1c17f08adad9b23c3f71a392bf7e98943247e8649dd0651367ae04fe8ac649e8757f2976e84ddad75c7437b456cdaea5a4290b6f1a87c2c8c8a3b693bc8970bd907956002a96baca587c212901d67ad68646277584a4fe0b8587be98ef1d99c10c25de4ff59a8bd0382f67f1c9cd131deac90d8bfa0f7c672271659c15c3e074217e45454f76b62c7020ab56786aea10451bd940cedf8041a1ee4daef60b5d1413029d9a5568557668139a4d6b0a29d2f9152df68a2b64ce01c494e8b5633fd674bdc9c8fe57e7693be2be409cd75337b7748f3bd3e270dc288987e9265c0e62425c6c75c4ce6a3316e2f096e782d23460e5c84ed5488e85b8aaf60fe9d7df18e97a609c85b43ece357feb46a68ff37279c88d9cb50474c7ebc39a060a846306985137fb5ec9204d0bc80b69c763dcc203bdccc678268f29bcd1aedee5bda9adc23f5dd487ca5b3576a65767982653f6983ed510332ce8eea61eb4ed53e6a6b9ed6e04b1612dc540f3aa2dcb74ff86b9a1b1f69a18b0416a446846320b10becdc027b2d6cf7d1c29e7b335865f6bae3c35d67170ca8bdace6fb58cda6ef606a48310329af7c9f19bb04de8cf6633f991a8e4fa342d05ed70cd7a3172d4aaa46503373dc38932a2fd9e92250f7391c8a48e708caabc46f19257b9f14e89f591ce0b99a9a83cd20a7b8b8351c9c19d59a154157e8d273dfbc8e994fa08bc85c10ce0bf4337dd3dd83a0a493faaa085aa6dc789813306392c742c1639b9a6511e26d4b93fe28eb3e9fd62c92a92d7801ece1e44ff8e413e42ca5a12c1e66e27cc3298005d380eb1bdacb37edda1a888ef3e49126a48cac16452ea3f45ceb40074ecd07e58647c7876a8771e0e65a017fc83eb7f3df2f41eec7160a5d28686d03d90cab7e382d1d791b17d1c0adba2e5c1f89ffd0a839795851a1720b5cdab533ffeac26fbf27955683a91642d20a2ea4b83088adee480f1e22eb059abd6f0f78d9523652b51a1f1276112fae92092153ec6a2fec9c01c58de643bcb7cd7d9b90d2bf648ad33863482c668fe82fc74ffa877df382f21e18b2276680f814ee4044cd347f49bf0897d6c8829156cf7b25a12a8f48a48f7db5a941cd25ec350ba54e5d18b16711c63879a7c9d41a6980be208a00a73e7415bb03c7d7a4fe895c215c8ca751aefebaeb69740c3b0eb668948f8fbc1cab0b6d0d275a3803ffc32929eb5adc247d272ae67167e2751a8d2040bd5a527f0910b56b1f63a090f936a9d109281769f549bfaa0aea6cf32a190e488d3a23ba008afa46d9a15a9f6bef7b0445692892df26b85d27c257cfe8c9c722b88f0e24c882e6196af9fb8db98ef60d5f7c39f72504d767a92950d591edd71bb5a3f5e172efaed3b466e671834bca7632cee1328f80225de6f8123943ef1a05529fcd66282683b2bdcdbbe886638d2022cc2b11a943d85cdbcbff550e072c98224075b8089b8d65b364d0b3f3e2880c63415536348fd87c7d4bd2f7d95b366a8c1ed633c53b2c7bd9cc98170efb91b3de00bf7dfb860a3c6e2c48148a93008bbf8b3c0ce3565677e43c2ca38f7e65193e4ce9c6c787a6e1b8f2fcb996ffed9c96a108f95a540594bd9db407e71554262d8e9bb664184c0daaa4425d7d70c0ccc206a02408369c70bd640c42468a575f037c2d6c13f7e5f79f282befeb3d5a7d8fa501a9d98f3d9a255c0aa170cb850a37b83baa0b786222be34e848286d0ae1493df458ea2ca709230c39a7cc1190c8de5a5f56a0b5a218a7828038cbaa64b74d857d83f462da65806678e21a81c712d9451f411f991f34dd45d78d727c04be55301b6550fd8458b6cc5c3671abe56ae50f2ee995430fa601139d61f6edb6673d3196baa040c69e955ef482c7c7da0648768be73193292721d2dc996cea07076de313223283a29065e9f0c7a0341193d387e5f12b2534f10824c02f22892bbd85b29224563d10f609de59038126ea02ed8fde452871d0e0ea078583e3d8d8bf4f2710b36333c33bcb22a8be0084ab2753a19380f285aaec381bafd0158a56f25b8a9c7545d897f93ead51c546842328b7d06f1e10156fb893cf6fd8483c86f316c3b1e651fa5215f5b80a3a0b2e731eb77aab7753611bbdec19ae798d9e0b5c97dd84047b75b70a7fa9e3c3cc71e90a1e8de1f54965cb666bd2895e27ab17a275a3ee860689412c2514a785666365e7f01e9142248907ba8186eb4ab00f3e0b1b0bb05798c1ee80cbf3c152952eb382fba9cf35e6a3ac38e21e66a19c46abb878bf663b560e6da7f1fdcb73c315a5f2535eae306c5db896c8e66bf4e173d18c70ea6bc1f28e4df3bb74f2695978412f0a2be2081cf62d9a194df1e2c3e8d82a8a4c7d74ba3b6e6e2df000d0c806b61dc87c87e274bfcdcb9cc8a7adef5bbc5292a3e61f38bedd5ae7055cd20d21e4614e64df357838c1c7582693a1da4f09e8959b068525a5f6ba341a6cad00ec05d6a943837e8140193a821228505e31063f975423adf8b46ff828827cd273f9a875d1b64bd4a97f9032872ddf2864caa54d8c15d454de978d0d1e8c6789e1b20665165574389453bb6b7c84f503a45c5ad2a5d047536dc50c5aba08e0b750304f9755ec650ebcec87e69b7a62014469b72be23d5b7ddd28c94bf1e567fee1e4f0210eb292066bd940e6f8c7bc49d1c37872a6bdcfc9230450924449215ea0745bae275397ecc498ada58abd652c829a0b9f281b20469d80b5501f42297999b22d358fcab69e2b231d18f4c15bb5b95005c8cf95d31ead94664cfd8d293ea4a6680322e8675fb360cfee4739b7e312d975cac3a0bc1f0cd373a50412c9f224e7ee9468121dd4482d70cc994a0f097b5b4f303749cf3effde8db84cc61e8e0e1fbd1d2db7cd37544a3714842d96a3158a51ac77650d71b977dddf12d010abe0f6373a8741f56c124a03fa13847e19beddc3a49e625e1654c0ab413eec9091dd2f414ac6b32c0b0be45e7c0393d19b43c9c65c264e99257d47f4e87d8b36be03a7d548eb5edacafb511e06375fcbd001977096685f180b5893b7ef74a742f885ba419708e5d5d00027e8ac5310a689079768dda8576bf592ec3bde8489ac6c7932c654607f0017e07570e6fd4e771a4109a4a3b83bc3b994cf516d09cd5712223f6eb6d80cf3c170fa47b110af60198eaf44bd023a0b5ee7c6562ed5fd8be8fd908786ca2fa97f1617c78e0a1aaf8685317540c0e0d808426bbcb9ccbf77db21723b70b97e82f69e41afae40bd2701b148d3c9ed2d5f998e2e0383e89f47cdd143cde5ff33b5167eb0f9ac9b5c0da3c49ef66daac12890c954d5e3f736295efe552badf6b6f164ef2b2c589af32c17cda733006b13f20f95c1fedc64817317cd41d17fcb8c23a13819075d186e5b4a4849c3a1de151f11fafcb31ff9850a133ffe5773336422203020bd233dd43442ed923bc16d17c497f2ac45411ceb28bdf270bd7584d45d90bb395733f707032c7c465feba13bb5280eb741bca830bf61a7c668fb306f0c771889d732006456102c6e1886022ba63a5108c46255302932502a8cc26c0265f4275376e8babcdc7a06c3e113b18efd84f9b5be1e563b2d72e177d5ac6137fd2762d297d34b2c6ce70961eea00d6ea3ae7c462ad488df74bd4f5d69f474c0118b2214b43263ab8332d798538b1e9be0b29de04117d60a0a197ec126e95abdc8834f6e32637549893a500c94c664b897dec7e7b775eaed045d22381c1f65a2e3766cefc5230bb91f4f3345cc332a0cd7c9e76687e97a52907dcf6228b43a0a8b10d84c8ca1abaf2997956aad2ea1c6ec9a2a311cdcd3f3fb190fcedc8997cdc9a8ec6a2923553801f908296f13976896cdd0976cfa10c05f0b21c172822e0fbd126b1a25ebcabb978efb375f9ede4fea762878dda335455b47c0dc5f9ed8defcb77f03a032b39934d453d0302c62a73d7ba81390f907031bc95c13cb4fd3d194e194553d4c540bdc5fc89a1db55a5ad7644453a6283205279b85638df657b584b7b86a2d5d62a4d23925157a591d7681ab783aea15949c78db6e8bee80bf61f65cdf748bd96626d10383f267cc5c6f80114fc1c65200242308a75f28a593dc8d1b0117e029d4d73d9a142dcece56042c54510c052243dded9b3e99c971eec69745fe11543fff8a41651a3d59f6876d7e256ba8af927cfa8d9eaad2d138fa91549312459e7518c8e923ee7f2ed3e4336cf0aeaccc68f376d03949c3504a756fd7c42109b83bdda49efed01714850411b89204f961a19be833eaaabf8c69c1631344c344bbe638bd044335cead357a095a255aeda2a4588382d91e1ebc39ef4bb3697b17e3383773ec0a8b0417edd79782db3e8a09ccff76979c9fd39b3166f0130fdf1e9a19cf6c240245752ca529b444622969e0eaf7e94caa2751835a9319184dc1f2aff5a9a680f9c14a3188d8413e4c86e6def9a421c2db42c7bd95f0a63031e0a6daccaebb6b34935f9df11810f8fdb5560fa28720971b6eb233e5f8cc2d4aff3dbf16a31b02179a5ce0b0aba283f9e334950672b70dc7aa93f812b240f922b3369d08c25a35c1b60f79973e429c053d00660bb0c0731caacbe660b45412f49a0991a87939c731779b25caaca40b6c806b8c57f66de801615a143efb575d4f3f9f63fa653838523951d6ef52eb039b081e8291bc0706d91b7fa217657b10243bc987eb16eb82a85053da817ef3a707aac4f82247021fe8a42b0e9a8e3a118e9c10de48cad33dc084e909d1df49ad2dfd8c0a32858e384f60958b47ef5a9579213568b69b85cbc63a6010a3998221adc753623fea5e6d16de233a519a40d255d185bbbc0070eed4bd0e3af3e6eb53b50c6a3cb30f37869355220bce82dab1f1e6fdfb394d7c9d43242499da6da5ebc55f8d59b8ebb5bea7b4605bae9e26b308c38549d97810a4f5b24c987757ac9644e47cd4f93c7d00c022b9e5f83e6c076e105208b3e29cadc0e4ba98c606eb9ecd509395c9cfa8793704b967a1b422adcc8d614fbeb6e45d6ac14ba966f75084c88e672914942359a819f48b2820064c0ce89d2a2d8815020b24b58c20b3ef825dcd1f4ee51cb4b01fe7390babb2ff44a2a6b622f3174e3391f4da6e2927b9600c1a2e60519de6874bf246454ba25469fff7eaefe0355e7ceb0f10bb6ee2fb1a07588ad22e1e3ad68ef1020d0be31f54def8b61868c17ed5e45684b56783cdaeaa5e16fb97153dd3b3470606ea3e506e179e853d623b13ac6f45ad96fd84525b765fdaa235e49e1974386fec8942f4a4e1ca96537ca303aa754c8bff8295ba68763d7e7931e00d7f65d12ccba143561164def3c090887ffaa44885a3cdaaa0f7e4dbd19c11a21f363ccbcaff776ccc673200acca632c6d092bfb91932cc160dfdaa04d1d990b5a34b38f4b06e5153e6c2890ae33b0deb8937c40afdf809d3cc85d56804bbbee11ff98518281487fc98e0ade1a14d08e211607c9a8ae4393c6ffa9f5be8c3f2e1c958d34b8e73ca5b16010daf05afe4c9b155ec3793e437b27f2bda83bcb9d910fd66d996a55e46831a66b4823438c83100cb144e2caf785c1630558089e35057fd70cd6d9bf89f6cf97c1694658641c54a21ccd2612b0ffbd4e3e7debc50d94996913d6bb492baf4943edf4485eaecda15902a8b0ce66a4205b55654bcc50e6d75f4a2589dd76249303ac3dd2bef6641685aadb1649a26ae2fba961af835e7937647bd1c9905e4c8e498e8e1ffb67fd23e11967a729eda708e22b38af6a8df52cb8d3c18ec9258cc31f3e13a5bcacc9a0fb38fdbda11a67c50e0bdb5569b676afb224df15840efbcae54c0f00bb40afa039396e3d0ce84408eff3ce4e85fcaa28c8f1c491e11075221c218b85082ae60fbb8b97f9c25107f7d02374fc89ea742674489d18714860c6aeff6eae1110f6e2ae6fb6854ed94deb385e54df4b39c824494c4f581d7821043a5477223076bee49a1c2b1aa640978bb081b09302772793d3eafae2d6a2ab431cf048ac6d0507eaa92ffe280a6a9a38e8bd3a3e4927a5dedd0154a13c3079216d967e176642438538674ad401fb44cc9e71f4c1283d975380c9f4348ac5f3803abc4ec5e6d9c3ecfe37a7d75db229872a094f923569b16bab2b27904cd5fe51c428e59acf4b32d017118e6e941bb4cdc4be417f1987c569bb30d5ab5cc097f23e9848e3b20e5be51554cb8cdf222862d27832386d6480917f131354a60039a440537d62b42e633e3d5d5f7fca45c62b67857232921c3ddd8c8a24830e33eee746828dfb802ba985dc61d72b6ba133933fa232c47b5ad7884686b1157dae8a3a9018194b16a9a828b5e930255278931eff486d6dbc6b3400a3bb7a45d701249c19c193b469dfccc0a5810e8eb33642b43e264fd20f8d6d3a93c7736e9cfd33b34cddfe7fd04d44d9aa743c8116b0662918f6d4370fd1a0254252bcfc75552bc01cdcdc186ef528be9d6d9097901362f516661fdee703d42d4842cb2ecfe8236bf34452b9e371ee36b645a0ad343e43ea33909ea9e3f6a47ebdc55b3077ce5f94ae09a6fe2732f61f1a1f0a42c6448a4ef8f20a7b3485aaf55759f6af6c2d9d44c9df009be9351e6eeeba8f3265579fa12e19f91afb43158eb9cf98cee040197ba3ac6ca60b77247dc491f9fa0fea1101640795cd5f9271c17a3cc9c0c9ed1f8c651d93a01c02691cc40b54008fa4b62deb1e8138c1024ea94fae1fba8da87a6e6a30a9e584c693a71f9c76d5a93d83a7583e3500e013ba0a60d809f4b55439f74f0fa45b755f5e2e73a47f964f3072e31671eb0ff15014f78b172de2ca0109080983eec35c84f6942536bd0b0aba9b834e2eabe448a58d9e6aa6fb28be71acdb05dd8873d28a01c21548e0ae6240de0a3504fd651ddd1283070d6eae91fe0c99c333986bda0a34e97f4c5fe2a9e744c59fe4a4017409623bb41e0f93b6f7775f01b5564b4b57a754aa235634095527a86d6497a5ec96cc7e7590a754671db4e93d22f5c9bfa5ba88ba87fdbc463746e5a03680c56982b3972530d8c3c39178e80423c7b24cd4de2251f8b98ca7366486b43fdf7d614605cd13efcb205290cbf00adff39e9619933b8cafc5148e81b941e3216f3c44a657e842b6117c5ecdc785de40425b9eec401da103c81e084e330bbc3a8d219397c2d54290270602eb4a404dc57fa1d53b91def86ab7d4d25761c5e24ba2dd1a642f2c06ddfb577364305f9d7dec588cb04fe84a69223f029129f3699be6baebc53ddb1ed780131c46ac07db9e67a800299bbcf9523355f8d8429bf75dab2446429a066f4a8ba6050df13bbba845d98845a107b0c5fb499f519681a377d0133dad46da5b7c79bbcc4204cd83a015f06b3ddc5c66ad65c7ef960424a2e12cf44df21a67983d5903efbc7211c5b2c89fa2a7ba2a1a2c8edaa15b1046cf954df7bbde08d59bd998213b93738e07d288303073247db3c0dfb2a833579f1c8f7905dcc56700f497559cfcb72e0c5f6f2ac462c2b09f06af026a3b14f10ab85cb8e99cd9d86031c2a9bfc01cd157483f410f5c1ff88b6772a6bacc1822751f9c00d7d24a23283b1539b59e980aa3440452735d0478d55b1530a358826ff9b2f798505e52358d1d3d51abafbe53f7bc03f537ece5f6ab3eaee2463f54230e1daa44f36bd8acb2f78a7d1df64778e46f953247c9d437c868913338429ebd8f49e1d570a59c506311b1745fc0a99edda0fa913e6526041dbd6936f6fb1d008f93d75bc0ca85b024e40caf2d75b512f5ead2e28d10bc96a30c3ef4038d5301033d76f147d6371dbae979ab9c4c4f7e7e34cbf80883bc44536b860f10081acc92f307a2ddd1e35de46351181aea34a4e3f79132ad202b3c9dcf5cea4f525d6b3d7ba74d3a0f587aa9c14af00ec6d5292643a512636e4e9973b93b7ec6028e82ad4caa8c29ca6f06e2fbf03489a9812fab7fcf8b69fb72f9a42788a8aae8d452f8d1274bfb49d2d3d37314ebef426cb7e1300bd273c0714e79099d9a675f31977cb41d02ab4bb2bc5b3ca2f2bef5ea4f13e4b0ceece177a731b7cb1af83438576355e9425660d8066a895c24a80b961b4ae9327baf570efeaaea1c43626ba0115f65ca24a749c383d132677620af6aa26a6939f8b3320cafb33933ed93866bbadd109e0312257902973eb1fa581c9ee7cd77cd65feef740e1d53ebc52789186824f6caaeb81e63c4f327a37d1da3b580a60bf79db5e326a09e0b7de27d46a92d124446e8de5f795518b3dee6f6637c3928fb25bef71767f50add32d65e9f4090570cd933806c19a916c7a3e54c27d22bdcd3ae2220a58c67abb53cd30d80eac217dd81c6fd26893f5fefd9c7b0a87259c5847611336eba134483d8083d6ac16de6f3b9e7f27338fe4f813b459aacd44818f834c96fce087be06f4b4766f004553cd9b95390814b75f0b97037cde6af896072ee2acc9a1d214a4a88c7113b6bcaf392336207a0b4e3d2730e538734b3615083813a58929fd082c6b5881edd9ca8edc936a0a090ab0a1d21d3efa6ee02919ac5726302dcd138af020de8443923819680fe8a777a12cafa5169d1ada9c5fdb9848d44f9801fb7387f20f104a41b791c70011af3415b57a1d144640bc96dd6f52ad68c38f639c43c4ef2a310bf336b65b654c9f086543ee54d4ba90aa86f5250c67998456e217475c84c7ad55c1772bbe2900c3a9b6dfec9eb08f9bdb14eacc84c62dc7783140af4e9d731fba95d3f691ad59fc29532c71913f61a16aaaf4978515f8b2f4b5a3bedab388b2f1e9f380fc6e366e68cc633cef0d379f13906373eedd4cdff81bacd73fc3f646c6047d2cc98bfe2f136388bf7e362a7feeb4c2b7029ddb0eeec7264dce3836f446c6fa06b6700c36b249cb65967146146578812e7fd080993848b39108f308bcdf60e971d6cfb288b8599a5367cf7a71a606cbc416d83a4bce7f75d864922136091614df49e3d9484aae8b882b96130079e55e99c51369fa3c55e877be4fde352f8d8dbe49ef10401a64c2a25b332de01a2a402363afe4d5485f57041d794f133b6cbd12b21ab3c09c16f74c664616e782d81848fe58f4d3447fe5bbf4ea0d7e31406b2dbe37b77afc51d26d7f7516919f6f4e60dbe91fb725c10c9066cc143b77fe74faa03ada41da04f9f54b4d1f7f08990fcd18a4e7c12f5f29a57aa12f423bd0f88f56c32a4a96cccff6a9a762a79c153d52cb218954ebf9b528187ab616e8557700a9dd45d1077835bb4d5ef96897657f3baf66cf00861f5d77100ccb6065b9b66dc50a43a02ced45bd1bf3d350a27eb2d1cc1b28f319b351a08fd58acfe4b629fc74ff8fef9e647d10e1968875c11bcf89547752ad79362dc68e21b239dcf2169c97c4cfee20e151698a75e13f62d41b48d487114f77c0a30e20b0b804d5c197001d33803613d88ee87d1ec0b4bf054c9ee75642e9b53120456fb510ba277f5ff140c3382a67e23b12e1f8d4c7edbf57fc4757adacc1bec2f34b11098581c7311a8805b4103a5a7679f80245fac742eaa4fad9ed5ca76090fb2fa2254222ade27a3daf5fea7bd69457e1f90cb6896ce7548b4324143907d66ba737066c907d358311650c8272cede0e4bc8adbc145cfc4e1abc363b8a4352f25e3bc0c6e9f547b475dd8525b21da25f37e941711e2e1fc674e8c9dbdbeb6d92c4531d96874a2a89f16f30eb9cca695379cf35fda137adc0b87c1adbcab7eb1a711572a72ab2e7aad56ddd376715d7f5786838fb0abf428dbeaf80e00a4facdbd5c52a8dde14d42502152db6e15215272aff3c5fe7d9c61861db70341b824e005dfbdfabfd8e78104d0d775a54df73fae223d3009809ece32b85db6e2185f72e7e8249d0fa78ccd37744b51dd0fe480e5b3a90bc5b2c18950844042f8d6578b8ba96dec95360292687cbf5c9ee3fdb1578e226c5c1b343facbd98535dc22b5b69a28303099e04ad1b9281dfb82751a26066a37ec0599cd321c48874aef4f96ef54c5e7c09cf461f80b7a2392f2b1bcba7ad5b08f79fe7a56f1366cdb10b32908067e9c94670e244dc16accaa8d461d004aa47fdc48e6bb3061c0ea8eb93004d55e69e9c03f7f43863ee92b3797c196f7c2f604981738829b7bc8fd754670c2ce2dc99f4394c0a8e121a5fac61ee269bd76e2239a7d11262f3863bb94435ddc2e85fe1e82de201b9b85536e3b12b3c7b1190d9049978cda419567fbd8f8eb7009d1c199db449c56453052fa7672dbf7b3940cb765999cee8d941689006bff55a45433fc470708c4ec8266bd49f98025b86cb9c35758f278e8936f3e1d8f7528fffe3b4b26c04634577b412176f2079ec4b3fe11e0bd7860aaacd47b1b599b85ac51b69c10dfe11160cb857bff58865e8ab532400bfb97fd9ee1695afd1cc8c38570d0c93d29487ddf6d7c10d172b1193ccf5d9c3b984e6e509d7bd94d02e3e20a6d338eead9b2ff72db21b3b883418b36c92918de2e53993146ff778eea1dbb30d501a389bba8d8cd38db981efc7db516fe0f6baaecb3d6af746bec635d822b909494663f55179efeddab7daf880d2bf21b723092094a63d5b680e061c9cf940477da0578dfee497e07419efb0a8c1b57628cf8644632ed882e352f388cd16d97b8f3f72fa1a3b24ccbaef4c43201db49f98fe90a92cd915d3a192d221c2d5a5a0f37b15176df0f107761b4b062bee47e492f9f613f3eb2c27b9e52f9f87cae3ad0c695f57b08a8c0cb0e2a963719f39a1baa790944f013a82f460f059882b50c3d3b8f06966faf36d65f6c9e8e7515f5ba45428827c64e9135052f2ed29d5c3f9d858d7c2c4c51f98864a1509afdb5b718c42bcd49b4d077921cb911489746708a03359c2a0e8358c21b1618a453883f79a69e5580aed313011d7bbcbd56f114d52124cae2886995a797aa5f135f8074dd77760454e7419542008f4429f99b3fee6fb4155222bbaef0bf6e531b7183059905d89b5a9bf3610e78392d8c9383a773baf803e0d726f7aa31232ff3239020bc6f33e63630ce7a6c29ff425d9c07cbf541ff0859b195dfa6372b1862ae8976948126fa045156bf35c855a0fe8fe320cc37375c9795466d18d10b719bcd154e6023a7670a57230b08bffb4b739caa74c5a2e77e7060a0d6b1d69de9e6d019d91198a5b98e3931c6e22bd548aebd6c80ff4068b274a2839dd7c50c767568c5378b7b1c388f4a1176cff715def4c65885492c2ad2461e54a6642a97c5ec6109840d3fae145059eb43279bdad6d65dfd9dc7cf8b02ebfa5d39acff0d7dac40cd376d5043c35ee68a3c6cc7cef8be141f25db3f38166d37639fd8c8f40349c6a80e3189ca5a38d039385387bb259197ef20221b21521751b1b4dce4a6f4fad85c4fe12aced4d3ea042659743ec9d37655ae0d33dcdf9591d3d014c6d560d83a993be9d7a5483909743a91a9962900477e02e0dce78dc290d04b2bb0c9fccfd617087fe6f4382e8a9665a9208105612fb222a1ae3e4f0c646aefadf0399ac4e74d8f637a697a506fd14ec016f4aeee98902ef4123d10443989785b6cc2397e655304593111514969d1fcffa343310eadccccea75a42a0c21308db06078e9e02dc908323fee41399c7db90c4d5d1b3f045913fd5a52ab1403b90a61ba69d86b4f2640a084cc4fcf7703d05e0418c5fd73cfefbf7ce3fc9252116c89e3f05a1d87ea0b39425323b2e2d08899cf600772cdd2a8c3623acc77e0c54862870817a7c4c0d26168cf63a15d732732386aecc6823d33f9303fd401f7bd2f1c75f2f9569d252ac38c86ef607887f0c34fb25dada4f8fe50084917129bc1082db1a97f7ae5a97b872f34f91713a76bf6371e4820a455698c1b3c596f868bcd5f0376e82e73054486936237b21f79a1bde3233cab7e7a12f141e3c954141ee95f9c7c4635e8bedb55449d34f70be3fed5f51ef8ea3d2da8440f5c9cf40e90e09b15475d7a81ce15db0cb84bf2ae846d5598a2a42671db3522b9a4a664c9a2aee80f888ade7bbc644accc0d4cc8d3e9ed82a532ad1e2a968a3e7770f7476dd9a59f29335a62a5ed61431607ece236046d6153dcf77380796aa5eb35ef00ee0df92835c88db96a78c5381aeb49398117ec7b3c78eda9ddc3340295a34826c0690a68b730fe8ea524920af6c8c5e7c9054417f8583dd4abbb9d22287f673aca38e04a0182bdcfbd8b59d290edb68e51404c7509fef2dc0f6c628ebba946c0167f1765aae5097e8b5575a1c28f7c3f4ad18ef0e3a2dc224b8df3da1bb434fb621a1e8e00925d440c54d7b0f7ef19ed394e3b495b6a7c0313f71f3d85c39e7dfc50837869e249f0c1817c2ed0d3bd9d8da6c6f30b71d79d10408600587a5b12dacce9c45aeaaa552d29e6f52c3e379efbf6b868ac8be23c65ffb4e36251fec0c32c48250edfaab20f0f8ad93bf723b97d4f29708d78576c4b48b527d9b759625b3da565587bb7cd96a2262f5eb66f36ee55e7cf61f53aa52e5f2e6f36494f00df58a00990b9187bff38250bc06ace9ae3e30ec83b4730cfb907affb40610b609f53103adf9ad195347c4ffc0182051ebda615b6ee49fa7a751145a5d8f59ecf1723cce009137fc53fd611ba456aedde7e4b4341c3662bc45353b2735680f6ad99a79136b46d6607e2eda25273d451761d04aaa7bee468010d68ec4af3ec36941a439ea667019cd83bfb66bcb9035295a72cbeb3fc7c30bd62607cdade0e5ba56e1971ec5010112f81dfaf535bc5f6fc31ec66ceccca6b5b39b1ea14c7fcb2e531f3d1df6bf7279fe4246a956521b18c925c8c4313941d4b103142ff2d32ed8bd84b70dbda8df7d55f8d3df820482eed731617a44be5b8a23b652541eecb3b799d658567f29bf6fc8d9710073f959bd26cfe18002176c7cc1624e1033011d2ebca0b29a870b139774995a97fda2dcbea3f9fdfafe009e00c562eec265ebfe8fa774993a5628ef9520386c5101472f991c1f1ce58520c7df6c29308ccd16379e137acdb1c01faddacb3f0c72572f6ee3e4686032254b06226136dab5dc43390ac79b0e0c914607a9cfd6c8dac94c169dd2bdcbb47b268ada5ca20d963780712b530339b5dac805abe872d2407751460998fa327bd1ce3e8c254dac7e2b1e49b5d16b539ce3a8007c84f7de83ab3195d77bfc1f5b68cfb934d8ef5a4249a183b7d429452849899f880e7f2ea780595abb6abead3cdca3e09c1d405a0c3dd92f4ccb7e67509418898dd0ba13723d67bbfa00151e5afb633d2cc6de319f2a0d8f8c32e6468653592a497d89dceb221925f1bc9543a64b6afd3c315b2421e9a152f187a0fe3c0a0b6b1f1a5febc5600e354848f291ef8f9365463418962458c8ed7801391834b2134b940498f667c69e388536b334ee1427e19ff7f6c4468a542c43f1c038e6d28ad6c4fa2fed36f1219ba1135e5e6cd0ffad6f340d52a7abecf38dc664788cded4945af661cba7bb30f4d61b1d32c0a94864fbca68dc7ac73b3dced4904654be1c0084b1e186d52a12ca0dd9014890448767d4f478aca1b6edd25f57f5f81bcd6b2e15b422cab2ca6d3746e0cf20f58562b21e6f6405c79e773b4446d88d890a0ae50a19506b1100b832006b3bea9fa4b2526af48f497dee8af8faf3475b216b03132e8c42b5058bb36d662d88a2b19426663cac7a492a31a16a3042411812490ec348b751598f3b446b59820bfa18bccef10d0c2633d9de3803c7d936f97940501d898b8d8fbcfd98c578e7da915028eed9e613dce52b45838fc16b6010f8229948e6964ef6d7fb6c903d4fc2e73d14256fe62655fd4201b858625d73638537c14fd29a8623e8b4179ea2fca961bce17092fb7b7f01c6cea8b40f61fb5826b323f54549b7eeb91f070b54568fc5da94a6f2ceeb4b92b6d0910ed751b9674db51c836eea06eefc8eba0e00828887f17f5eff8a685dbbfc4838c8f5df8b57149a5063b05dde42ba54b6028f28db065c65b2781089a0b0c23fc93576a9be2ca9d139e7a276a5892d76477d8ac80761e3c79b0e479a997347250c7e0d913f5f6d4b024f3548027419a78bb63248916a6f35768334c0b3b36581f427616469b0bac0da89a8840194598321a9ea89d2931a610d6f3e5408c079e5e1efaae8e3407496fb44fdb7f59451c66fb5604e438b9310054aaad5010b880c5723e4349a06dc2353446a026c62c79d82fe404500a957540e0f4e4f8532e71c10d1005348066ff63e62251c3510868793dfe9cbae928c9d577c264e7391b26b10d167065f4c93228fcf20d29499f4a522ab4ca7dee8ebcffa324577585ad2e71460df8ce62cb97e075167d32a360e1ed0add3ad9e5c82641b4bb72502b0c88d403c7e60de27caaf59b4568fc03b7b0e8fb055e61d20032b8cf200975d8fcbd150fd225ea6459f72083d3b0ab86815235a7f91f872fd32c47657c32a2e7c104fd1c2ea81fdb0ea3fe57babf98dc3faf289a18d59a47201d164770c7361d620ca9e26e22261a13e49e1cdb8e5bcc7c71ead1fd20a4cd028c400c3e714252f38d244f0f6edbf443dd95c5c7bcf4ea029e445f76edf67b8fabf4a550a4bb5afbbf6f90171f566ee42c2adce410212840cf5a978990bff311c139ea8169d425a7b56252c6c333738e5a21033bfd3e9685c8fd79e02ae18b343c70151ccc36e5a16d1b078b937584b1dbac0e4329a6f269f69f1835f4b862de193a2fa4585c67bb43f6c101e7db01262848edebc938ebc4673d531b73bd03469b40a58f01112ade5c96ac32a35a4734709cc1db2d7361a0da03e7e5d27c5be08503debcdaf25a34cf089a6b34aed7602ebb250bb2d6de8842788efcae4d25b6210c42536efcd5a42846145ef9d281af6d5d7d5af062ef629428a7aec86e74c85cdb8e770eaacf3ce30c6d9468cc22d42540fbb6affe6214fb20fcefd74db74d8eb51b08795952a8ddb3695e82f7684ca6628986f46ebb911bd6592cd761809851be443535fd72f84b966a1b2d76ce37b4d46d1f67039576d7f7da2826ee4d4ea5e968db962ab84d7c3eceb377da74fc7679c49d48ec6a0ba3f67c4335f043fc002937691024eeacc1b86f518813ca8e845d28bf0b4dd7656c56d18b65d19f16f2a502c15b4a0a9cf1e6f0f9fef467b20b99b79a44db51ed3743ccad58b2ea28ad380cf90e3f39b6139adc0492f240af7556b3afc4dc71bb3d8bf4213baaa620a328825d169b89b6aceebd0c8fc98f01a2706eab0e88309463dcba6d133cd9be3c2de115c10f4c27c599a5c1868f36689e8e7abc50ffa647ba53c5d08c7cec3bc33fb8b6e074a71c8d8aa97166e5dec340c147d6bce07cb5f2c2e6ae497054d920aaf2c1137f1c9d08ad56a82436c7efcd486316c4b2ab554c19244e8d771a971d84d7b2418ec760d617c0c338a80e82ab996c9e0fd9e19c4ab279a7582e303d50f11d15bb36d9faac3f07aba9431ccde38e4119f3225638f20fb7aabd83424f390db364dc4e090f5bce9113c6b39d4179845e6cf3149daaee0aa912a3caf05c91707aac50c83a89480a602b548d899adabb75f796b84ad62e5e27a2e33e22496c5d250d34c3aacad68cb97ae8ffe29fc3251d8d81ecb656ff0454f61d8cc59505270104a5dcfe6616b4eed25526781b4b4c54a577db7a4a1fd1d537e7e0cb9e9705f2e41cfba53e0392cf31d1e8d5b60f42a68f36f6627c24e99a9ba33ca23cdf0ad51a240c4a2cc629868a51cc7bf05ea17c493b2c9d639e6658a8e870eea731825a76b5f6746dade6304a3ea4bd1adb7e30e6c1bf163263f544a36a112f70fa8c591d5f01660bc0368fea84588515b331c63ff54c50848d22d4189a72ac07d7d6f38093055051c1462574cc164af60f77eecbf1775ca9b907cb98d34d65d40df9b5e5297373b966efc7de764de97f6f41baac97f321bb9adb6ee7cf1e7ba648c649810cd2d32e851298bbef120eeb26f31ad17e567e51b1d4c8cc74860913534c543ccb5c5a5d0cac668535105b37fff5bf199e393323109b70b69396ea57fc887a5a0be680f0d3b5625acfb4be1485f03593d2746ea9b06a78fe9bbb6e27761253f9111ac2dc010fcf8635951a44a51d9b1bc4a051241530ac0271a865eba050d25b459b13e7cf22524f33c88623529a663309b1cbdd9781a61357e8441ad4f4c8cb54ddd4b6790e1815c61b04a5fd74c5e21d9f8549a5cd7bde57f166528f938149a7590fb8a7fbcf1853eac1c8887446641ad92f21dda76707caefa7068b821d06a29947ab709c5316a4c0c377b123ece43e668cfe44b5058c97b0565eaa666a2e093c951c34530dd02bffa42124dca2949d6af09633c03b2ab95f407c155eb313d70c7d6117a8947a6b9c5628150dfda40c9f5cfe3313cb2791612e86e0ee57eac567ff6c2fb146ee29468739fb3909faffc231f38baa785178ace3793fc6fccfeb89a9f8bc4dc6abaf64a89a2aa1b9089e36374ef73cf3d1657d83b2550f161bbe8dbda93742273419428691a5bbcd3d4ffd18be74ab31c2b3ec042f2c127d1659d91151d7d779a90aa6541e90bedc2b8c0fbc054d539ba45d00a9441b710a1903bf29382dccdca56a33db957dcc3b3b1cef3a221c1641750546604867aa0ec7e908cc113ab8553278283a95440a7976e9aef192b14008154784593b9f1cf069ba662c75cba852b4a20a9936437e3f812c4d418cd6d652dbd8b38d1a83d0fd88aca50a4c5ac29fd3fcd86f549b15d486a752875b166095ab97fcb13566084dc0ff6d44e581f0d88c96c8b5a966d1d5c4edff69d1ca046f756c49ac6460c38903b131cf95689cd03d9591e0d5960f91adb03ade6d12055edda9e9561c49979488e02f41c071c3ae8513541055aa104e2af1e326973fb6dab5dd4cf71ac8d0c6c83e1a34bac8ad1693d5c0a115783c90645ea12e55c633958250c2f055249ce24dad6f922ca38f4836716effa3b5f0b37230ea245c3f9d2ce72d144b52f400697f4f46534ae20acb47bf9a1121e61a1fef64ad6d9fd1431a4a5777731b3dea46f14cc0f14ecbc85fe547d036f13f397bc825dfd3a2e4370047354b501320617c780b3ced86f43ae390ad899e5d344f04a3323f6f49b7facf3db7c412c9e29ea867a61d851dc65f48ac756f0cf336bb74e8860a4d5bfc6a114ddf411ef421b4966fdf72f8a2f14afa8335f5fb9b392540187a203dda4d461b23f33afbca524d5cd506053c9048cf85aa48d8788e45bd2900ddd679340a7ca1da799f5f59d18d3507e89c320eff9ae7cce79c740a20660020961170de65ec8f9701c5673e4a16797c43d82c2f1159b1ea8d5ae13340c017150da6a1fad621204e6de0c37e7e2d871ebf7d52a2e605b4a1f2304d6eca514948918c64900ef2ef9d9300ac96145d28972f267d04ec0e3d0401253466f4a52748d28b789ec0999dc5a62b71364d0a7d0b9f1149efc2693a43b1eb038592974929d371371f819ddd47fdee8a9b1198ff9b95c46efd87154e970ffcffbef8e89e610315e81dad767e5a2c0c8acf4088447ea98f8ac867dd5b960b3dba1b8e4ba09ea2e07ae20bf3247ad93ff8d50fc8de1b35649217762ead794198a140d78e21d31ca5bc268edf0b6a67fd1d5a233fc121855a6a2a4782c8c63c06dc843dc742e8e2cca90dc7ee9c95695b87b32f131460b1f746865887ad5e12e81bf03dbcac64d1f23d43cee1d9910756d36ff94bb10afc8b967601c8ee3540c129baf8748debd9260ef9e3c72582576d1b7e084280be7dd72913b4a32bc3adcaddffaa03e1238d5d0dc9dd760aa10f77374bea706fed78b4b707a8925c2a7cfeba55fc968f314c8ca9a896a0a6b4e1a9032753f2ab19aa6ee8cfdee0de1e8d75379ade007caf159622e472dbaa544dba244c27bf314a2f4e032e891c4b0eb76898d009245e4d042908fec2071bb591252e51bc2d5d8cad9d40e6f96397c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
