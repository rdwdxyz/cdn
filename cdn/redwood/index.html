<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"baa2e0cdc291ccda0aed9c9304942cd80f19cf3d46e1fb9be9c01c42e367e77f7316dde705c70d0f751d95763f0f7447879fb0a40d152675e61adb2b786e29692f419fc540cf260115a532d2fdbd663d0fbaf924fe37302ba173705ad011014f06457bbcdce3a92db35dcd41b07c6a1a6855bbb262e792d1289a1ac1cace92eed5177130338bc938a1e349900eb917d074b6aa91990ae80483bf29e08c0b1b2c310babb87f000c44a83e335fdf7138daa7bfe860926d9adb115393fe16021504ac270fa0b7be5b9c65c6e5d2c43f2fd98ee6f394139e0e3f97b7dd9627cce36f47150fd8783cd3284583c71ab77bfd7b1d0113605f062a5ecabc32411b1d6891532782169c48f065909e5b40eecfeb72f9c0b0537b3ded4d373c22e597b14ba35c94fc86fd1b9b28b4504dcd231eb4b44120a40674a6601382b65f06dbb0938811c5bf69c0f0a867e35dbb3e2f2fb034fb6531067872bf759aa235387eaf698633d99a78f1d32f7232f3b8e9a9bcb0c600110eabda97ee6d5cd189c71224218f1750168567a8809b19dacfbe46d0faa8ff4d650c741efa3f9f61bad26f4280052bd2398702d4a4066571223ba1f769b0a55985c4de50d954209841633712c022cc3acf3efa0259fe3f5740560319c01f5b3ded12a6678028c28eeb0b018ae0d290150908025cf87760aa8f71aa0055c7d25ca93d732d84ffc4dc908761eb081f1bb92a8e5173d90ed54f3c5110f0c2e724d215ee5b11e0b9204fde5af29aad28efa2694b8f7fc602a093da6d64db7509f3d333ec66a6015c8f2bbf3ec2f7e679edccdc3f16a824f0cd9509e2a7fe2fcee94aa1b02926dafda26f7f0dcdcf4cce898388d48bab7df3da2e7dcfa68a94daf9b4b230aca06a274528faafb1c6b0284a1e5e6f73e501ecfaceeff12d28f752da97b79d45214be21986b0f1ebbe33b87e2212f07edf8e311ceecc1f66a07a8c8dfe257f7ded72533c9af965ea80a2b0276428700023a958d55ba1203a73e110c858b3683bcb5f8626029df409f53b55dc8f89c3ae07766f00f6bf30aa40510106d8c30620f40e8673c8dab573da2c356a8ba46ca50eb39d1f96781276596f956463ccc43e2de41d2fb936dba0ccfdcc2bf5a3ac36fa469b667c408bce8e76d73a77e440c05b92ebdbcbbfd5afe1b7f7ac01ab28fef89b81599978c3b946e88308942a5d223e8959a6b09b14eb5cd63e21a16fb1026e3bec96273683361d334aa4f26a6b17eafb8c2087c99925a8f58ece0ba778efd0750e1197c91251dd595284172b1f0e8cdb885a275a9289b73202b35657b8bb7a9cb8e26031b23b677521c36af2389cc63d793e59b866c9fa4dd2d4c21f0dc3563b06be093aefcb5c74ff094e90b758034eddbd99674624f0f7b98ee37862138b6d6658fb829ab7e32e33d284920b59f05da664d4c0ec8784553de6222b0abd0d1818653ccf1191f1c2ca80fbc3cb1237b44bf51b8a796de9cdcc9e021a5a92ff50e61dcba1509614e84512d26326158aed21cbb55a47a4e94c030db9bd0ba65f01b2bcfd744fa12cfc98dce0cb3d66909aa244acbddd85c294fdfe12fbe6cdddf878c304223aa90c0ffb98c347f28455ee3dbd2f679557adfeab0d055034ba90001bbff8a11fcaa9afa699bd606cf16ec2e89745dfec521b465901da4fb344d9735d3482d5f80f89179266c20ac9ae0c0e92ae21f17c4ebebd906b005dc0897c643d0d16f7a163ceb5ba03bb476e7243a54b57c8588da111bbfe0ddb4b1f04e360e396697a42f82c7a29bc057a218a8180aedf7281cd03f1260131f9c8ba0165cd52b2f1bdc9ad3db2ee204f74df3b88f5ece1859d366df9e197ef9238e4cd0ed8bc3c5ab4c51dcdd03523272854ddbbc92c1cfa36d7d124b8df637d88de5d286b99091705c1b4ba1552b212783c5b9a956584e2b552b9d06b2f4a44b4c91938d44bdba0f293e05cd1bab230c0f417fff9d44017f3fc39764f09281def5e1a74eb627c3fde90555d77d8ae8b13a4d412065c5615eddf277de3926e5f056396eaaaad80038ccd9a9315536a0ad77f5ad18c1c22fa30f48a2b5b882e70293113c88bc3a5ddac56f8675022656ee4629a16d773370cbd648fd1d3daceda621e8a817609aba929c1a40681f2dfeb470b6fc04d34d1dc78f87804a8a952dd183ad7e6c3c3013c859d329aee1c8ce1debcb3027fbb121d14f658a69c1ff6dfc6f44b5ce53d56700260cfecf05bc6e92759f830ec3adb989a92c9bae38aa2f3fbdbe2f9ad45493b7c229d89883a0662cb222f9e734451230372d9550ab003619845a901c2fb020df4f301f1fadb4c995f0ae829058cc2473da82ba75453518a6ad92e2230617255aeaa6efc94311557f5a3f667e6f24236183dc1720841a9bd5de16a06c56fe012cc288d6e057d3ee8d9c4ab9aeba564600926d09a9bd02a7f79f660c3f152cefd40b5b34d39f158bf5a3a04929d2dbad6c0fdb3a34f8daff6510a548d5b02499b20a00ac7c17f550c6a9046e6fb092496dccbb55ecf4d7b3dc88f8afa66b5eb57b596a1ba1f2a5a24a949a2fa4545c6b233065f063b625fdf598c212956129378a4775429db60b58b2887caebc68781f41a2d311731e38a1ebabdb33a3e5d737ad29c0dfdfbf9e6324e5f4ca3898def7842f582bd046567173b5a90848b992358bce800a89fbbe60605b7ce2225a89b3813fd806646813b1ac7be10525ad062d444b8d350a9e813349301b5e8928af0311064c69ac0c18082b7d71dffefc213e511b9ba8ee59fa2fe0705a1e9e423de7e935ca5d2140d558397792e8799ac92aa6719cbf9e2d16ac701c8e0504b0d524113df8d0e9c00580d0659758233a3d83f401da05cfc48798bbb4c94abe1c93f639d9aa7696cc992090872b70a6bb674c8c3ff5bbc5b77949e558658e4692a26379809ba28c1e18dc8afb222af463a23e4af53c4135bd221b79f68182d46e943ac3d388309fb337c4d782ba21d49758fa5422bb0096160ad866f9b64aa2d4bd18c453a35c74f92cc06e4f06e539ddb2397aac41f9896f279c10b831122b00f74cd2f9c3ea2590d4f46e346bdce5c1ef689ce5f6d264240a013eff73230493552dcc738b3ec9bdc0d961bc6c154e0034fbf4cf7ad9524331867dc353ecadf0766b10ed3ee8134f8cf534b35e1c42baa5c59288f8460fbed5b62d16437798cf2578cea5d8196d743077e891284fa993d28f3ab712cb5063cb47e23f955ad669c56d2078b0e0e4b8caf08f7998bae2e52a15fc0ce081358bfb0e3b49c41fb9aa430b0164897c27813630ccac1f1a83b9a2c16c5be232d3ac5d07691551af10f4294219428dfcdc395e16c828f3d5fb1728db37757e87824faa3e1a883ca3a91d7a831b5d8c859cb52249b4ff69d1933014cc6eb0cf8d91cfd8495afe967524acfcc91985ec0253b20bcdd51e078ec98e02a43ebeeac553ecd7e299ed0826d6fa87cd42b2ef9cbb98f89defaa8602d84596b6f289c5dfebff4d11925f263a7fa7ea62aa528efb087d662d3e13b41c5f0e47210d85acbdfa435719d4c8085353c3d9f4c74fedbb21cbc2c0aa4fd6a0da5647d13dc9a4a70efca7575a3091a32100b33c75be3b8a28cd002c46053a10c852322355b0f6a7b728606be487de6ccfea46872b55cb4a366970e27feab8b2702a8c90e376d8da3612862fdb85ed2a7afbf3f189a42f40d517fbe01891ca068279de13403c9bf1015839ecd476023a32e73e8e9b775f65a1e531badff2d5ffa4149d53be577d9b5335bbcc6c81acc40cf03722b4f74e3803efc567dbe188080a986d73a32f6d110057159273a492554a31e86a736f1818c4b97b33e75a224d2a5364f0e87bb5d4ad20248b8e8ff17ab6425bdb95ff419b4d24d6873f6fca9e6e6401df5262a11b9ca7ed1b8bf13d10d54662ebd1a180e72d9b3fd9401e58f99a4a3dc5dd7686b99466f6bc9ade84efd7c0a24e72d71a507fbbb1310f24fe5b895a216e9b4d1feadf49101a26d9c732c5cbde94f5eaaf6025031b064c161ff6df089ffa019e5a1a3ca55957e3d61ee018751b6f8ca6bad00e24996670b2590dadea3135661406859da78830c0ba9cf7371b5ef48b2be455d202e412e81e648b16a7ab4a244a630eb8728bf12608374f81a9ca80a470a231b18849155b51ae66517a971672fa0e6924d7d9f85ef9f3977e0b0f1a064430eb5a495b4d3e3e2ad4c14cc5c5a7a60539e6c5a0afe4641896427729d74385a5394f59001229e7ee355765a08b05d9cb2e5d6d6884195831508eea23a02c3f7ad7b10d92d2ddc25e6509da2af0ddd2af513cd56a2201b7e99adc55af40d3163486d6cc06c195131c2884c45ef85cb3a743a39ac3862efb0967cb491abc1fb32b499def342c9c56ef72b191f48e1d9af2269b305cb1beda9723514b7febb16df1b1ae047d6c4ddd250060c6a8edbb1a95a894ac2aad111589013bb51f618c554c2b4dc1929614b02fb48b1360b45f3fe6ed69de36feab3836e9517f72abc87c67ae6624c3c2f2a2c2bc7ac23e0445cb2681a961f1cc0fe87d595dcb2203e11c4a0a733d0256d78b0f08fa6905de0093ad7c3adcfb36b32a0469d18cfa49124f8a54041d7f93b3d7c7597362a0bb21f8b01f459b7c68c75786eb7ae1606e47e6d4c45250a58dd2ce3577879773906a70bc74f6c501a2040c648e5da7652c6dc7808a34c7a154762f6bdc1f140fa742fc988c55dd227792c16626f574d3c84121dffeb7139b40e5d9b27e99fbd050cd2061101a3ff88c2c99bf0e859bf75982f1bf8ce8e346deb800634147473dd3ad1775427cecb2f751a781926aac509e4f0653bdc9336e2b452301965354bc1153ad59dbecf8f76882b5f9718b43dfc6f6490310cad8abd23762101e7b9432988b27a9960f4db3cfdf10c53fa8dd1e4a3e3878a2692ead12098523b6c619a6e31094ec5b85c06a711b1149c48b930d1a3e1eafd4f12356f073dcd9fc8ad63e1538f0cbd073f304ae1d82d0a32972e4e199644db3ba371a323ac74528b36cdef3f12cf7550688cdd605745d741a37eb8d6c66e86c6f897943357f9fc5fe052995422a38c4f1f23fd1d72811b5d361db7f6b723b31c07adbd94ccc6accc7e5992b564bc0b95db0981301bbc0b9fc0223896e4898e57950c7e9e4dbf6d3866395cfb18bea18265e873ba87d2165567a88f68fe66446f8df7d8b8d8c23c26861fc575e88808bb7872a97fc06d015d76dd7d2cb64e221adb3cf9f674914214482af8506228661026d6bfdaf293bd8a9885b1d28eb8a14b5960d98392f2c93d708146c9ae3e3c83fa23f9cc8c5f756ff7d3a8d8558165846e873472fadb99f4d7a111a408a9a7553b1aeaf1dda62a5d446197231f50b710aae8f55ba256773a5ddbc8e3eb64915fec8cc905a0cc55dd48933b40b6cb321941308709115f14a8c342ebf55eedac6d226391b1766b0f4053d910f795595324c1f10553604dc48fd7c8a0f740c0771d6756bfe6b59fb89547a51d83a94f091db10df6086e9b4baf286de095675853ff89669b2cdef324bcb938a3d4fa89dfc7750f70b9731f562a39cb0cd94c0da3ed9207e78d4f4588015f997b45d3026ee6fc20ab06becc1338a0d55416396e14da6b66641cfacac2bf681b9c92ee17cc0ac200df89f77346db0f3b6675b35016e2a30da5fec658cfc16215a8a04a8406b525c74b29c3880f63356adc2f64d9055dbafa722796f90966ee2420543ebd0ded514a1c2caa1ef5df344f8ba727b4b9b3985ffd7851ebea8e9d8c0cf5dee7025c64be8f03cab63179f531771e5cc4ca5d8e425040619b841b1b5efcabba68e6045f977bc8a1dff7b4cf003d1dbc6c14b64702ffbfd2fd568a9322bfbda971a12547b51798a20570340804279d2ad4557c9b356a0cede65bc2485bb7567e235be7daa4189f5ef5ef3622953a533ca06fe2344535d51f155679aa823cbf54c3d0202303e8a306f4f5a4ebbda210a6b44df547ed917f8827e7236341a140137755b328bddf579cf339edae63b7e39c6d90b0aa7fbcef4192d63a43e11b64972740965c19f4222b37e3afc527af20a607b17a16f51e0fc68b13841e827b0b38bf3d4b384d2aa42f5628fedc552ac2ebf55aa790cfb88a74fa826e9d2f293b04255845697af8659d09e86eb99afe7b7a5d03e02cd609df1719647875bfe7ed7d9e4cab55a12886180aa3ca54c1414bab8425e7ca62ff3b544d20734f559934d5dfffacfe7bf9dcc97bb28f2ca576b2f35a304d6d5bf1260d44b8c1a14356e59e4eccbeef3d50fb6fad4d4c903c98e8e6f313611a2087d2aa24855c619ed84debbd9d5c6abd13683c672301b9fe3b88821622dd4b759400ddcb972a24d5ed334d8dea69f5a6662388863aa14be045f9ccd6a8a860ff8010709a40ecaacc4d83f9fd1acf086cc4e7c5a75c30038f12acf3720ef7c60cb24c0a824046809a3c96752c97130eb35c44227d8326928d28edc34a4b024c958fcba8be8d71026223e461bdbfb1aafa0bb72ae2e8823957d6e11a861c75afd2ca9dcaa349262a26bf37df71ad1eef2bc027307c8c40ac4cb05fe146c9b47f9c95407b46974d66075c3b2b1f3b7360af731315a4288a3135606a881f991f0b8d2754cbb7e576035d0ce9207c7b83013aa632ef39feb1f067c7538124fe824a9c62de155996a5eb209bd953c74ae95849a79508a1d9c331e4662ad093e4192a3d11d4f26d7467b7cf8b75efc93bb6e43920e4a4b43852f4dbe3361ab5f18802f01345837367cdf88d2fbad203a71e35bef7b12405c43cea10c2622bec9c8a2e0e2c80017567e52173417d3f953a6cc0df2c314f9ced3280a316fcae84a343486f1b4c674d3635b3570fb65ebbf43d7e26423a60fab5a6434b5d1bddac23083154734ec0b2a7de8c1998277352e2bb89d3dc97b33c405e965794c681229810044d053bf444f1e7fb9356bfe10c3ef1acae99680926f1b982365f1f6e5457435ab32d687943e64872085d8e55e0f891733c4856d0df095f6d4a9700ec385d0abf06bf6d967d9cdf05c45f7b43223673f2c352e183435fb7bc8e9488d60a430883cd5ceed5a5c0d771db309c338b8b72e9bd8313ada79221c1d832706d5f3a5f6b16752c5a1fac053a11ee9f7db93516f065dbb92a83e92f32afdadc2c90db5fd60cb383f6b91cd0494b5b91237f002e13ce328401d04542ca2fc2eb7abcff51a462e0c21c1ba2be63032963127a7b648a65fc7f0bac55433e7f32772fa66061b04f48bbd4e61c41abca6ec6278f4fa7ff86f06bcaabbc74d19d4cf103022d3001f5a28fc035ea6553f62921b857de9737297be992f8f1f2dcfa288bba5f81fa7f352feeb8ae309031a0d893b1cf754a4dad87222bbcf0fd8768813a2f23f8baaccf5fd3a6250f67d1abf1e9db46fef3d684b37108b1ae4fa8e6125c84f3ed78da8045533319d8432a3734d82183372f0e4decc2a2cd61c10f68c5c5a07b84c03d201404544f335268fc74786be5bac290cb1cbb19d896f627cd9bf065d261ae4c91777a2fb4be8840295b927130741c03c44e63aa318faf4434b0205adb88e2f8783ad2fc759866ba605a0c8cc1e672817ecf64782bffd22cb9947b2f39a07bc7c188bfd7300ae468b309aaaac410e7e9992809e22236dadcbf5f026d6007e03e816c783187bc6283db6d216c65a528f08de4ef7dfea6c3927e2ad213b64d61f394a9b0628d779236e67a6ffdb09bf53a24ee05dc5955a147c41ac57b6edcdd49db93b6fe6ba807235020f4830013863e0e253624223ffa3601484ed3265dbfc8435e55fd25dd1049983c4c92731f20469eb5ffa9d4be5c237cdce298212a304d48838c74568ea062c6f9fc96c73666ebbc526ace0d1d7a801af47477d37627589d777e1bba5b18170c1276c710e318ffbe7c2d16351572b13de890eba2b7198367fb596191cd53f5443e9c30d2c2f5bc8e04aa88fc10f3fba3aa861f5f60c672c3486a1fb50dffbb123c845faf19cb2d41311d6ded3a4f7425b14aa04b34f2f2587563a453ffdbcb08479393785cde6ffce86a9407bd5a194bcb293e7a2faf6503a75c0bd042762e4d0ae5f51d14ab8825ec5e6631ea7b444bc6e892ce46baabff2d2ec8f4d1bb044461e075e0704a077d1d513c3ecb6d3f7a2c458076e7a1b3f47b4d5a385d120ee108007685d1d71280f028d015b6256b935b6fc0ecfa37122c292fa9f07226b75ab572863df7388cb44b8273e93ad35f2b7642a97194b5ffee1dfbf114e509c3394ef625f0d4b3f67e65e40476d17bdf72fd55368b6492e4b366c41b3146dfcead0943b64ce09e3672907e539d89cf9c7d425d29bb4ac88f4872e2c4cfced1d0606f7e0ffdd9a7b2536fc63cdd999a384942dffaeb58e5b8920340bbbe6d7d2d01b7bfbf2206cb87a292bdc9cb48d62d7283eb1d65bdf34510e98082e1abbce355ab916c40e9c3d410938955731faba01bfa72c97adab8914cec0efc93deae1766abec8e5a78f4a9eb2e2659eebfb1eb92a4d2f1370d0825bb3249157e88e90e2182cf81e81d13dbec0614e548049a8158e9b906fbf90c559cb2bace4c987eb86a645d0024e5d9ba9bb3a02f214dfdb4b84896903dba8a9f787c2654fcf4cb0f308693f731eafb5f9261293a5a37c34c41f76692f7e9d2d3b811b07fafd47a575d52a0b76dc4e62c426978ab1d55dbd5f4f353701f8875dde76808a5de77d9f15869b2eabca7e3d04d7b6edf56853a3ac4a7fc217507fa6bcec73915b1585641ddfc87bc26535e42adbf5f02d80e738d8f1dde7d152117a0afe7ff5483f65ab642638f5186cec886b672d96a5e5d135609a93ba42574232e7de60734ca2c21ed8429a6fbcaf9431d7604f76b651073bad380786579802f57347bcaddc048c4bb690b9d7a7b3c5116d64e881adfb30c81e47a87c68f1167489056d813d02410c1fd5fc87f9a7827607896123f696900fe9b886568ebd0de59b6c19eeaca8b1b52b2f64d1c8ea4f9815ad33b442964dab6d08685665e97c68fd55046c28bbaa74c8b17f0d88f81834f5d5a8625bdb68fa768bd17421c9eae9a9dfd56da92cdd9f9b02db1b404a63c14724ee98d32f3c5a4a1f8fb916c5b321f69a9e5cc11ac7ec3f543a9b8748117c08f8af2bd4f6d079b2d3a7e6dde325798248ab2ad3569692eeb9497ad5f0b327add695f9ab14e87ef17a697972a437fb83b25a4ee5afb53e53bc057aef470557858a6a719d1f64ae3c19803e8a95f0f067c33667bd48e8b4fa5b862db75dfb0ebefda6fdf0f95bd2901b0208e32a0a708c2e3c8e5ee498d92fed6700a3e169898f1812d31f7593e96a03775818c812f7f45d972635e68116bf99156f234e3bc4cae7f1d7db19c379a810cd0077c90e335fdffb2bd9ab0aed6e72fe2d289bc4c5710fda3440879ae4ede0f3273287f9a17d28a6ea8aed2db94832d44df721496d2c9dc6d76a070861a11bd4fa4e4aec4e50fd7639ec5c930562f77bf22a53885ec3cdc8e42f304e1dade8d2e423ff88d86857b32658bce4df8e60ad0f5d9339e80a35ab2a509848f9e9b52eb30e19887c2a278846e18869564ba123ce4053e6af99486dc91e88e7a495f9187b1b70f3681d8deb67eeb7c87799745966f9f4ee89574033bcc2f701b462eac0d57f2ef3cae147eafd3cde7ec4d97fcdfccc25b40dddd74bb1d233a4771f2b9a52d96dd7a0ddc87f236b02b80786da31c64b8d5807f1e36b1ea4f714300acad46e0c3fb4ab864105e83dd11234ee94701147550cfc9e51db4a547069aa1b54c017b0604244a70e5c56bd9257a8b4282e1445c1df063ca88b5b2cda5e67b2a7de8b4774981639e5f27844ed0ed8e4ec7bdc05d7b97189c15e0144be967730d5ee811ece56d2c5463f46b8cdb6b6b76042b04dcbd54cf1bd9fbd35f9c07fd7f799133fc357094691c3a480718c24660b238a758f278ce8cb2a9be3c015a127a3ec893a1a49443d42745304b1d8a5cac486c5f1004d1345e03c4e05c83909bffa860cc165e5e1ef43d2a5954f88ffb3ccdcb76607ee923f19d7556e9d3b0f876a5f83878185042e4e0df37c8165b4134cf4d4fa772303eb26150e3f8ac4e88ac4888861d249a222f0bac2ffea2a5aef6f5da211385e1c2474b99531d1e5d93f80cba43a74871bd2066c7822d449039904333e0efbdf52ea1d8d61be8a3dc767b265a8d2e75271dfaff50a71356256e2ccb043a61207b6620fce3c96efa9748f4bf8c237d2e32520cfffefe34b8d737dadc195b6721dd30e3e4fa175f2a247f9f003c262dec61a3837e4024c8cafaa5765c29f0cade2ff025647bc375cc00f9b030b3c449c5f48a728222c0463135579bdd79a277bce21824b3118d1d130a9bb826ecb7837b2a9383452d1bd99f0afb09518a9b7e21a6d48b4f30bfa6f1923900daac7b28d473288d737decaab36151b657bc669bcf28a6cb6ca8edf78c70640dc0cfc5a00c4a6740acb5084c151a99af0469ff6bbc2f0bbaa0c024726f7ee09cf048fee9386da08b56c79aab7f25007f90665935b57864137482f210c3f3284b0e0026269b2c27ee99eddbf53549b6c1027f4347ebea401bd419d03bd6494d6234cf122117cdb1cd13dd58a407dbd3687301fd632f2ca98025ab2bfc96873a080b509a4145369f77d17f8800092707807060ec0be79ba899a32f983b30cdc89aa32468242751485649fac53fea18b07d39bc5ba6b3985ad5683150c5654440ea6dc5e7599de2dc0b581f8459b24c2ae3956090edc0423a1ea2d3f1856b977961833609022350573bcc4e7020ea601331a0cef7ff66c2a80e680c59a8bca8247028d03af3c281a762422fa848e77767a42c4f101820c1add953c692616fc7e240f5403664c782eefb5d14c2775680b71643a2169e888bd8ca702ca7d170aea4e89b422d2bce2d8412866594e5f9a1eb1832e476396e1e6b27c47fe83d177927c7b1f607ff7beb5bfd147809b01ac348a9c52033010e54df758efa12bbd9728c81f1c105316ba8345e5de294b2f9511a5c9daca785156c41eb2db20495993a86c82732ccfd10d474aca239383e79bd865461f7897671d5b2687a4f703734584e8f6352fa3afc199d6acbb99483911559c3a10bd6ef0ae2da95ed192a1ff7a7da6f083cf6e684b083693c7d25f7185f19c1da56a61a2a6b5cbce03206f3bb6f43a30944741a26d3a4a03a0699506fcf44f630d36faf11e45ee320d111fe33a04a7c554ab92e2cc80ff5fd7069a5f6285dd2293cb2c05bad6fa52cd847bce67afc89e739300aa2c062b4583914a94b356dff9bb7c8e8d5cfcbc6dc796ae4470737efd87ab325bc12dd03667e1f851c821e79664ea529d1d3b8fbe05502c2dd6a1fdf35d8d82ef9413f22fdd78a31eae4a2e389a4be7bf4f38211a9059a3c2287e3df9358fb33b527a59f46f0ed011145be117caa460a73c9c4da8cd2c48979936b251054db571783294780a1199586e129e44641062e98127d68bcd1d5d222ca41185623e4605d44bd0b008fbc4d512619d2e92131a2e5e7dbb379505d1003ffa6a4fb7828913ff56a581c1baa6e060e316a882269b68db83f5622f132a1722c0d7363e30c0f6a0b9e410a719e23b61fd2ca1708a622b792e227d527ed468fbc9928159d9b69e996c6afdc6f61c30dc96d24af5c27f968d59b05adb5a5708d926825c3f53b883caa32111091995c3c324e774e20c9ad1f666614efa20c00d46be5006eebd3e4c4b967b743f16506ba691b437e4b78c8e17b24025acefa7a0ce40bdfbfca9ee3476f741bb63175292680fdb61bcd49a7e314d60c9bf466a59971e4bab97ee5d4896e2c970d0106e3f5dd045dc0c7445d6363a8e7e8a911a852ba3248a09754d61c7c7ac5a6c80ed988d448f3aca3e61b8ac105f34b8b6b767c111264e0cafc79361c9e19214cf64c72c1245da265a84f9a294c3ae782bf88d16c419debf9a6398167be92564203b0b6e2655726a0efc2211e2f9b17437e59052ae6efcef2233ed966e0003c7e6ec2a6e2b3724f381340b8fd495b39c320de892cd72631401dcb30b222869ddc0c52b16c00c0aec98e0988fdb82b49f23537f415f656b42dd769fec373a8cdab14c6317e7207b9d05ad4c18d1f876f0abec30ab4ae2c062cc53df9ff8c8fe4caf6e6186efafd4b426b2b2bd291f0b3ee0c772f2bae4115463eef0dd2cdeb961ac9a8a99b9f546ed39114b5a534ef81eae3173d9c746d2698b0a90fb90548e5c9a576547200b47161e6b67707020d484d3ba20b29001a3de2f147bf0b7cf80b5f97089e468156557645a25240e98f07e72ffc0e1cf1b032146dc5c243d5e2f5e2f7d15a82d8f83575a6ecf5c6e0f99e5b38f0acca243a0205fb718e5f437c4991a06031249f9ce693fe66034524516aa7d42b104f4e86786241519ae7282680c6323441afc8558b7a4c8132036193900618775d7da8ffabf6c55a4085912c9903e99a0e1776e47abb3a4ff48ac74112e5bde52d9d9df951e33316ad5b3af0e7fa1acb6d5737fa31b8e3bb4b0fc32ffa3dfff1e3f6e5dd2215477e747fb1295948ff480ed81eadf79d992e1147421fa0d9c042bb8f18bad26b7422dc349751fe21a8a9f4f25c59d88acbb68aed6a9e8c62a105cb98cd43d3e8fb78395b0fd2a65e8c9f3661709d0325e98f4e272b874e5d3495b260e60a6784327e38cec3fe974dba0b62940d6fdf1dda52ed06d29b44905a1f607aac32d0477d0c7b76c858bf23a83b529422731e1885d561ef734f9385c1eee1d9169415e1b9d585f970aebc513e631c571c76b1f4a747ef7713354d3b1b2553a8cf0516ab330039201e7e74dedf8eb4e44d68b50536827cedd47005a2f2d7b48eac798d16871f206844bce41f8b10618cc2f15ff89831eec37cacaf24783a41045e25baafa7299b906d42ce27a7be66d8a79fe16e8e81c3b122cc6ce0511b9ef3ba3c96f7be170a913e91248bdb2a5c9e15f52a42c573f21d99073fa518e19fb9920789282272ed1764062b81f75b89d451e30f363d8e70dada696a576ed0a22fd2cccecd03fcbdf2cb3403a9c22e136ec3d66e4dca480b76fb075f1745ccbd4300167978f505939a08c3513e4be0caef8c7f2bffaa2ed116c6e5403b4cc6ac785955f1f5687915ff25716448045d724d1c0ebe0ff4f12caae0071a595ab9e30c8f1f3da39ff239b41560f8229460329e5a2a47a5f09a1b56aba6f13b8739e4bbd77f8e417672d6b1ef9cc24f0785822b922d693dcbaec0cdf448a8418aff88b57f7a115ca9bb96fd99dedd0d0756b92f23473c9daf2241d9c21ef8f3affd5be60fce95e3bbaf2fff7e695ef35936b75f818aace6c9af4a24d77303551217002e275714c600597db727c5f80744506d64b5b25aff352282ad9a1881ade2a8001738974a466c914bf32d1d70cbe54b63817d21490e7f99c6287814ad6e6d311a0bfea1cb6c4ed7350ac53ac1c84aac00cfa1ff70ade3a7cb4fd3cc824178b868bb262bd0638b6583aea2e6a17b5243b0883a3e6c89ff18011c23d40cc68cf9bcf773b5d7d277ff1c6dbdeb7090234a09fe7415f37f1b08a589d00bd32176e4636909d3f264bcf7220d141b6d470e717ad3d8d5f12c86f304e46022a94c8c36240630a6cea0abb514c6a21aace88b60e55790d4dd6f9ceb1b2ccb8d816afc30c032ea680f5d3bf8008143df67a4f2fff281d132cde3f065ce0bd53dced8d76d2b076a44e959455279a6f372e409abf129d7e242a093ff7a382b938ba5a01d4d249e8f1688f604e94929430b119a83dab1b5ce356b88a4e3c0873f5aea6ead6bb50f7d0a8a49057dbec06b9c1efd90a498199f2c3a80f8ac728bd185a7a139dfcaacdc505a91d2981fe568d5e6794cdb9566441bdd29c4617af7c357bb454a2eee1676849ee6aac2045c45da06a528f8ea617d2b037bf353dd6af86486d486cf7f198170d79b08b2e1f2db9f2bf99593f69727490d316a4f0b3bd77c92f587ec4a69b999574bc4695f8523f5a4df305572c0481f360c885acc12b462f26c6a786a42e22f31454137f43808e760cc9ace1ce63daea7c9add9d37e8a062d0741d2395a355be8c28dfcdc27aae77aa459633583801a6d6b9bb80e17221600201c4873c9c5894beaa8c14aa037a55a324eee9dd642374237ae7bf62e0eac0625a13754175042a973c7b4fbc3785014099d531292215b50ea1c4ca4c027ec3488a77a68f5cef3e8cd79fcf5d27b5073ec3ee9d8752750f20daecf00732cb29a45c426adebec40be027617360424d3cb2ea740d1a00dccae62fbd534ed3ff6fced4a3cb27e6dbaecb77032f4d1b4423e1ac06317783cfacf5047e7bb063c2390f8a96ea79a45933b2626429fa924d33e7f30afdcbcb31b60ea35a6f2a55d7aeee3fe87e7b66c3c7773ea2b72c1b59e5a305429c515c3c572aae1ead0c76f870439dd08271d4f3ac59bb6da2c9c840d410ad955c4e3fb00ffe1693fbe01eca64c49378c77ae4e8ba59843c7dd1dc5b7d1b01527bf832b2640b3c22d65299ecaa691dfb48db87acea60cbfa47dd84291aa1f842d8b090dea8073ecaa686358ce8fd15a1f0d9da8e1f1bbfe7a7f5fd90ef18ee510864284f608728ca6a746bebd40ebc16c6cca3b8aff8b765d828a5885b3d467480e474dea14e6c1afba1dbbc9c767db3544c9521ada87e8f20862cb87e951442ac2823f8730ffd09392e8c382ee974f29eb39b563828d89c13cb3ff15b5d57a9e4dd5446d1bd675e3500cf23aba0f3436ff83b98184976bdd4dba57009ffe5562da3bddf586bee5037107d81b0d5b825c6b831a9ea296de5ceddca72e804f45a007973f412591ce1e67faf4bb8adafc033e1ecabb4ad955c03604bb3d3df2410dc6ae4bae98caf2176bb2fe731a32bc51ea65a14e73e6a832ff0003b0bb85ae2256616d18dcdc63961d516a96c013c3488d34fa5f7bd8961f9366fa4fe91cd8c683f276acbcbd7177a8f59c7ed10188a70b0e5d87ba73ee1a703b12005ff6ec0dfd171696fcd3cb5d4386ad5bf6116419d8e541f42ba9f64037c69431e600402354775914f41f8b7d3cdd68026b2d57ac9afa5c2e99f46e06b3acddc6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
