<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29e8e8241212274d157ec08388111c06e66225e10ce03e4a8c060e5ce0795a555b01954eb0e15d6fd08d7b23cbfe51b4a6b8aae4ad8005cb3e4326a0e7837f596dde031ceeb2fe68df37d7f3c10743c68a7601ea5c3095c5525928d22df4f7b77f82238f949160c20bd37108d8cc9a31a6978c244b14602113a18c8eb871c76abab7993741d714d4e6b150f0bb75a258a4f8c4d136b937947b43c698f43fb468cba44b836456d49ff751937b54fb4666c5aef9f652d930d2e6638295348fb4782dd7ed4b1d44a019e3979c0aeb6e7695cbd9290d116dba9993d5e74d1b7ae245c2713efaa3feed5fd3afef8e14b667f6505700691e230e377f44f7142a8c3360b9b8d849372fe432d18e64f3e49aa132702074fecd1542029e52583bb201685d724540d52df630bfc680999065036a28f7b74f14364cb627c7d6d65a0c727080f8f29d0251a5d6c8039a6e780d9ddec93d08c35d397276bdb5bf4ca0ff1c76d91dc5e841aebc708fbd6866726642fe8ae7bf28c09a6c5fe1354dd1f6c897da48a35bfa8bf1edc9e759d5042635b08a56484576688c97a9bd392044cc8654607e003ef468d3217ea6a800365c3393a8e8d2da6f9cc773c855bd60ecf80ed0282e349ecf254eb8f77c117db5ccf8002359461ced3d68519e694203703272ad3c5052c403a86b53e7965c8325f2cd3e5d27e2b8e17551824f74bfce8176cb44adf13abe9d99b1c1035a0958fa9977e5f1e28fa3bfa63989146cb2082df39d3b276710884a93788c791cb6b3e0fb3b6b68a8fcb658597d5444338e30268bc10961c9f3c6538f6375d557dff5b037e69f495b81f15e272b321371580d2108938c53c4313152c7c3ed7198027be8bd578cbf782c65f71f17640587828fe640caeefa929d366d0ee1bef7ba2876e73bd69896f998f32d2cd3584cd65ad111252b1f6cea71c9a7a04022cb10316ddb429784a349fbd18c16e1fbde8ec0cd1da41ecfe1899b18fd318717fb67a0668e6991a92c0e9c42ae1e4a8606a889244b4b74a3bcb50453ee076e286c16fbd89b0b6b72f331f25dc582ab6cb975b9deacee7721adda460eb4aa2441096937cb2d44fcc68f25a7aba32a8d7e4651b861e302e89dcd6a69d4ab921b107580df375f6182d8adb257e32541b390d5d70ba5e5e8b670bbc6e9f25da85b59bb244b1aebe26003b99b1559061151ba83bbc64ccf26fcbc34e9937f8b964b100d3941eee8e4d80ea379a36af22e4979517bdcea1629d8aaafc4748cc6f4b91a212ff29bf27e21b27046f84b04bdf29cfb3b6e1e1ccdc9bc775d1d2c4dcc964984564ac69b73783bf65a5b4875ba64eb87088326b2f84505406beef9a91827d95ab41c0e2ac278db43fc4da819ba18ec5a1fadacc5fc9dc661169ead35ae74e760ae9e731baa025d76768500291ec8cb2a0f05cbc2e221f3e854aa64ac648d68d4201cc747883f780cd2f9855c58584a333b7f9dc674a2aa7b0d41dd97381cf7d9d070d28289d7215092c525bd19b771552a5c70bb49264f20b95b3b491675bffe7c0eb5308bf554da7486a55a1aafb4c9a61c3d11671db626b212b96f5fa1674e42a799aff96d84243d03a870d00441b651a1b14062c71f7e64f9962290d82e9ae2c834bdd5e218b80005cca3964c01f1adb5cff169696a1d7019bb0302869827435288d2399fc909d4de28dfc653443bfb06258c79e35a8dc91a7679f68388c07556b916f3467826c87610e6b844b576c261db9ced145f9a66bc610de0909b64af71f578fc435c517d71c5c7030de75f1786e697b1c5a33cac80f4bb8e63150b950e8b6d43ab5e93395c5f2df31a1d987273f2c34438a8ca0cf91273c246dd38f1e32e8949db673cd2a3a239e627bf104c831475ee67adba144cb0ffb4ebe52143fbedc2c47feb737781bb139bb68de2ba2664f7dc21675243ceb45aefcc2308f722219fc3343d58496525c651c97bd26ec5b354773215f1039e903ecfbac7bd9a379c8949fadce1ffd8c6b7090405a34bb952ac100b3fd91ab503a375e61bbe8e8fbcc020fa5b9168f37f08b1ea48b4d43b641a2281af45b09e35b3003625eade86f7445574ead2f0a3b01ab3384daa8aeb37848e2ee3c30a2a15a863fb7bc209a699b0df78c43b417553e9e5cacaf65c78833d6604012fa855d51c9566d16beed9630f3ed099ff33a2aa3a9951cee65e378deb5af214eb03a384bf73d3c00db876d19f10694ac9a398cb5e6ac5fff9de5d8c12785e7130a470d4d4c707e8eb77372bedb6d9680b0173faee225e13fa5ed7de59bb7e90ebe6ff9fee93a1d4e4f071a6238556d1eda7002641173d346502d1ba4f117df05f35c94787f83170c46591b796a94da5c39646662873661a41af4d36b0d999bf02da10393f76b6afbdd31aa84631c693bab7cac0e3e64fab9eb209efa7f7ef085fc6337e0b1b30065b665488f7c5a5c97dfb5b6a0daa4f89bd0088a7dd75f3652c95c8e6482971686eb49d56628c18320a1458eccde6e7c36127edf36916124e156e1bfec8e0ce519ef95acf1e6fbabe19d4027e289a38de20e0955e4d924aded3d61385707ae15689a3ecec8fdecc7c4208f54b13146f5b86fe75421e94dbb1eb99c19b13174437a0f243b870ea76046246e2cb192a0f61e52a38b4a2afe4e14106648796588bb16f8a7fe57b7fc1dd2f8c4f9fa7a00295cc57a026a91342434155d11ceab59ea68628a61a42e40a656f12125ac6badc26669a033ade7497ccd7555dc0c0e9e42776f1207737c6195c6e0f458922488703b4b9c0a53e15fed4af50121d437bf87c15a18de7d7d696863ddf9f5afe92b4e4d744af73cfc7601ea643aa494a0c81e6cc354a26d1118cd2eee19562cef51cfb1032b3443bc0cce344fea7fda033221f938fe88c8a1d21b9ff34884be62d8b955385ba4037f772c122f14af83408aa94db92d9685b79044805b1a5c6a27a9953f719dfd3f81e9314e5b7a8b722dc49a518821c6a901e3f12a12e733e3589a640f8066931741f9b0a2ef9a3640c8f74b8ec399feb27944e9d86fb0197bf7e1c66a7fd57f8a2f776e807b337c6a1d36a5be77e443d746dc3f0b9fd57714fe1502661bc6bf7b37063401470c69ddac0bcb2cfb7a22314bf0354ace93919c250036504f813edad6bd8cb17bcf17e581650ea1ee714290f11ee936dcbdefc715b8895e301529f4de8163f14ca4578103a020a46a7601ea24f71a0c9b6b79e08d01380a1d6209c3639aa8c21813ae8e62a50d74cfcb491d5f120c8be4ead615e5d21f3a74e6363bc5fc544aa4ef72aedb05e31b5e41be620d2a22f460cb14397b941f8770bd4b74a3a29ea37d220661f165b30cd6dd093afdd51e84fd1cae144324c9c47c46782ef204fc3987e44e346b01e5f6fd2bdf7c6cb92ac483b7fac054b4b648398b7df93786ec98eee23fb77d842f0bc6486e9736c9fecc1188b98f182ed4253f1c2ae732a5bfb0b30c700f245f31767e1f6ca9744ee87969752c24e73240e9418f6b386821d83e7e5731be0bd10cd5bbd1d41e2e26f18ad41474cae890fb148fd29d0c496d65e5d8cde2ebb289600fbd2f3f79da6f751477b19c43588a06e2a7b2aa1d61d0d44f61015bb20ec8fc2e32e5fff442697fe6eda665c5d045edf05f40670b7265db7cc6efc676ef59d222ca1af5007b5c2f050cc9160c0b107e7f96b7988efb559661896f099622491b34b637aebd95faec87d081cbe33d79323391632446fd6b80650e3bb882ef2107dcbcd7c8b2e0a45ccb9904d5e45b5c21a2a18eb7969b5775c3d2488d3926ae5e83081dc8cb73fc832298e89c1a2c475d4eddebea7f591013578e707f57697b47fc6583017830f21c426eb7ce6e052b4f94242b1bb0e3f306697cc6c7fd9f76abdf08eeb5be9044ebd579c474184455acc608a2076669fcc87e13f02ffab06a5b8c30eebcabf5bf2ec13b371416932c725c817956fef094323e4f63fdf69c7730e811f6f30a362b034be25d4dbde35d30f43a8235821d48bb522dde9e9af67d28556ee304eda759b5f61e3fbb2f479f5cb07b6ca06bfe068bd00eed563ff94e1ecead8b2f0cf41c9c9e619ad9b29564cf955d24639385adf6264ae6bf53c76f4fd6129eca55dbc7aeef25b7bf3eb66de0389c38ebcf351baabdb3d55c8e2007005aae191700093c596e7efafbe9d8b5a69f181558cf95736e0f2b872f940e3cdbba06f27e97e3390f5174fa2ac328d7df66fb394229f24ece9d4fbe534294b5bafe648c520c00ba0ee37c2dae2398087ff435f24c2e7fb3c562041fb4b99c7335d3f127e7b9315910e92ad5731bf6786ecce2b5d4c846735ac13698bc848d8fe08d5cf53b55789250acd5baab1aef1dee48172aeb3fc7bd27027609a92ec16ec9cd47407d2582e5fb048d57525298cdb9f37f2fa4e70e002ffc240ffb1b942b890ee71e5c8f36b217a9acf2f63ff22772930964623558ec67a5e7e5e9f7ed49821ea059f370b41ba70e01a75ad87b2c909d26c91be30686b23edffcb6859371843c3f0a3d919ab2c10eef1d2f9887316302cd07c85115891a2ed77ec608fbbe46515512b274161c72256c1b88bd9fae9402d4c658873d34d477ad430a28b815a5a8f69d6c563a10b479c169a3f54153e1599e861fb5b4af7c37611fcf62ffebb477a11db224475d0eda4968831fafdd73923e6397e6c0ae13ada865e0ce720e3287d01fe14cdb94b6a969679e6aa73f98a5f6b2d796feb6916ff7db1f082ab24573206a2c058f025f41b7afddb51c39b80ca49819e1228457cb3e7dff46af1186aa4192748c1c3e68ddd9e702bad65834cbd5492469de7c022f6bdd0f03793fee2babb0224923b4f5bece50a5816b6b578fd7c1eebdfbbde0401a55b81bc3cc50e79fc272726e8df2b9037cf1878a6448c6bb9ad00bff4e63259692646e4e3ba7930bbd86a1b73725c990085dccdedca66ae70811ff7d8e10f1c0a36e147fb14a00a00975c55fb7127984bb51fe993f6a773c5f01b2d097146bc2d30564d4fc661e799641fe0a3d073f7130740b7f97c4382f310f00a3976f27979dac2fe4972ed05e1a96630fd124d1ff9c6d171770aa236e200e58589449e9669d3a1372ae7ad22dcc36ab5b15871e9450e5db126901cf5c4be90ee0b8261104243be738eebb7230c288622ac4ec44db9166282aaddce16bd66e224989bf735cd00b611df9992472cee99d239b27fd863c5616054c436081f10fa5c6a0cce14b4ca2d8e4c9fa599461c889e397835045d63fa9066909e0f692fce90f763c74cb34631db8482d4a0f38d8a7e5fe62bfed5f3c243016a843b590f68abee1b37dd93362ade8007577a5f796687cacdf89dfef32589ce86231be94b7aeeb01e9c3bb71759a62d675f11e52d1e46b030aefac6b883ccd58ad6cb625a7552bc81799b93e9d7c182bec7cb364c3fec99e9144642906abe031e3b77165a81fa0a80aefe5b8af3eec399b1e401f6ea90a6ec152cf8418af745d0f24657bf68649da7079ee532c1cc2d7012bd85b69cad138abf629516e63e0944fdc2acbcd174cf3dbba499d571a5530ddf8959f738d5a96967dbdf8575a75a01af63911424847c3f460edfb0ab26b6b213bddb899495bde484a2f6d5941b353637c1a537acbc9be227452b26782639753282f62bb41369886e5e8ba56ed44de2309aefd4dc6e7a02fdc897ed59bc77587481fa9a28a24a88051d9bf7f6157ce2e7021b521edfdd51f526b889b5ab455ae3be40b358ec48b104300e04650af12a1559ed777ca355e73e88a14989b0f8efedee0418773e1c112d346997985d05c2f57a7baeda0d3f59dd8e86a08d3502f4f683bbe1bcd3fe8db51ea2e46572f71cd18bbb67cad040fd0310c04f906aacccc7a41232e308771f040a98843513d29606d7ac397e6ec12cedc38430d5f063c84326fc5ed8e2cf222bb578aac85ad68e4a0212ac9cd122e4b2468c96a4e9d5d9a273ff0c9a9ca193c47c10fbea67f31d77a6caadbe8ae8382544a6aa2eee9ad4633ff1b683b4ba18f2ee88513117980b11296dd0248fdb744efc883651c4ddfa77d8a307145292c2378d3bbb5b547dbb567fedfa18b06b9b5a324b9a67d8a41944a8455ada4c78fe7c7a4d4cdd1531d7eb21dff256ea2740b40be700d2afcf1489ea07de9b581cccf9068658114ec21eae5e0e028a7f7b329ad0b5f0835fe56ba740ab6593da8e291ae49721656bfaffc1e1e577cd65cbf5aae6615b80118a9f7a3813fd333b1b46ffa7d58253741ef815ca119aaa1ce70d5bd1a487be9809e05d790f9950f850a28ebadb7d04c453af586fcb2feb5f67b7eec26e6c2a2e129f62a7f0806272f02d44d815f66126ced18d8fe511ca6db50630557053cf83f41222b7bed5e2dcfd852592ad742b1f0e7e41ca2eddcd873e46ab8685d12d1615526b0109da2cfc66d110dba5ea13e339f15b018d1cd5c8cd8b33be0fb450a95d5c4a8cd4911646e6ac5f6b300309c779b8a962844d3928ccc50a0abb91530fac7ecd96adf0ef386ee4b764ecbb5996be71a559e0d860c2660f962ee26658105b2953a7c7f508848871d753862fab21a274f6b74c33bfb15f5999c63ed94c2496cdb89fbe2280e94c5757cee63acb2ef3218442071b168cba32a9a5884b74fd0cced8ff70e1909ed34e4f8d453af69f32f823a283775b17aafaef6d15fef7ae8a61ff17d93699baf2bfd19990e5030bbb53437237ddbb99a9a5e28a032f517ca53f98a46d57e97be7f03571e168f64276034cf8a40e264f88ddf3bee421cd4b47f58cbd185221364eb532d6a3642adf48ba308615377f766bd963a8f650ef192b9c3f36c507c083959e13fafeee8db9c3f6260014aee0b9cb55e41f04d3a8599b0b92ae8d92d23d8fd14dc81d1a135bbc629db44054742c45be2c872d10669755a0e9219242f01244a016f7dc8a63a7ac23131c04b29873a24193c95ec0e0a02dbdaa8c1600f1e0d3244e421934ed62d39e8d7a523845ff5231adeabbf09570c1bff6caaa97aa5d9abfc7a67d3ae557147d470c1ebe7e9c1ae934857875bca2841cf693979ab3b0c56419ff4b574429f817d2e7ba48d252fae7e2dc83d9e821d0a46fce368fc87be85b931410200c09a4301505320b698fc207365cea1f62604386428dc5ea4b77efbb6eb5583cb0c83743a5b8abdb6d3ee0c88f53e3e0c0d32bfa131ce7bba1854e44209d8ce3aa253962729e1581ea2f6a1432781c9f16ebf0152e3afa5ca3cd93278aa872e479d865282729f457c5dc221f25e8c12eb756201532e10846478ddf816ba31e9ec339e1c95be47b323ac29ee8c0294942dfe18bb53f2aebbd6056bf6b5f6d777522902e116cbcf2ec0f44f0295d5ba1db2d9f2208c2032486bfd1a1ed87b574951ffcefb073313001f2532dd6080e84f8dc31c629509c1a558fa93f4981d140489d1ac7831ca421493ebdefd2fe688ddde3348e429d2b00331310c6cb57ca8015d60a8426684a626f7f8aad3d31811fbec1fdbbad5e7fde7d8622ca97354787b9e2286b2f343d8d4534596eed514bb742a3bbd2d45a1aedf763991656437d460bd77c70d44ecf924c510e6d9c425a1e248d44afc72ff6096b3773400e8960912fcb70b537d0790040818105fa4f1af6c33cd763c0ff938608d6c0140e8b3505fc1bd44b349c05fa2ed63c003df287bed1ac64d041b9ac50a46343d88b6480f179d9cbb37a6cc64d259c99e73fdf47ad77ab82c76c9e2b2333a98c11c3e8eae122049f92c90d280796d3a045cafaf2b293e93efa939b9dff8b8e71b7df2f38908caecfdd7d6db13b78c80cf32e0ea5c8a1f1ab6682b537c936bd878785d189316bce1df3415fac31cb0e6c3609b50ba3c19a6adc692271decc09ee1f276b92b85a90e8b283441e7385d2759d03192f5701d4a20ecf58e2a48ea008021d14c9aefca9078033e78a75c33bf2c5b1988e3b2c357edb2de1085f9a7ffcd85f34949e689f82aa59b00995527f074d5c368856f09a3f43b23f7edd05caef7efeeea15355badfb5deee3ee4b64bd4851484ed0f14ff5aa723e0e5129434e0a6ac88e71f58e65f1cea7618c60df05ac446f15746567d28fc643ff9b4890c3da9fed507e8c52fc35109741544ffcf2e8beda9a846d8a63d9b854c1750e01ef59c65ac0a13d190ea3c6768d7d582a01910757b79ee942dda83f458207c1b3a8a9c8c407213f91c35468973afe1b00f72d731221f618cf317827b8521938dca9b04a0791e011bb805d48d9483df7e3df76eb361a045a65c5f25f922c0125089b9b652e2f326c47363205cea7e5d1906e9413be273dc73dfde637b2201ced0382b77440af8f46b00f6ca368a390d2d98be9d055d4d0137d3180e4ee18d7b6387a3990a9dc844da61319513bc6f81bc5528c04c3c5e69b39be439b5047c134c5ffc7db45b0c1909620ff7259b81c20298c68a068b0447c08b3563da53e38a381cf2dd42510675bb7e105b9b9abb948951a46e136eda020d0fc391e13134127c6262c25e45c6603192689a71abf969d2535c6c6bbfbc78a0a9c814d4294d0fcd3849b13e354261877a1f975912b0ee90ed2a4e2136242e879118a8f12a1585d338cc76a28af79546076963c56ee396d1d6837e3bcfd01a53636c729af97c7addf4ae2a5711364dc354d9da6197b6f47c920446d6fb7d8a92c5b13e51ddd8a314804dab158f410d7deb9dc618904160ea2f517877e73fd5e85102e6dd7b5c67fa0088fa81ae60c31c16f06c57d82e8533e1c2bd527fce85b13c6c40d4c2234287937bf5efbbcae9967bd0f6c524219d95847d88fd9dfe9f987776f684a468390d344d273b6fb3e4084fa6280560a495e19a5007fe9131ced4da146e9ccc4dbd6aac5fed08cc05ce170337b319ae3e8dab526fa43405beb059613d49cbd168bf3d7a8ec71a048468709bbad125b6264b35efdf46ef4676c3e47374e3b9572eef95f1dc9bac9443aa217736a5f29d88cc8b94958c9ca4f6c3481e8fdf9b91bf8ae71cfa6d572fd3427ada010dfa563025050da21fa01fa1b3acccfe5c5f5b0819eac23adcff15e42ec8826fed3e9d9fc849f13a14e43da391fd2b7d377f5fd92ab7cdc0364a6538816d40e793c0aa4f804475571386bc6ea92eb45b8629db61841167d991bcb4410a2aee7884989909540f34b3bd63be8d8a82cc849e3377278d229874900658ae550c0085f0c6fa958281ec8ff307e833bf63cbbd8de21e3d569e7fcf5d169382d44d9cf20067409e8a3d4d4c2c0279f4b64cd64d34dac95d237d9c589b2a8bdfa86ba27ffd33266c68d634c95a79712056c9029049bec5b6c5e661a5e29abc7798f836057baa99d87fea85b316edc6a7319364ebc98e3b219ce008b487799aafa216914359aa560b820bcb4f7f12342155824f53e0f3b5b6e5341a57eaa3a7ca6ec2c77f2f2970c1f047a7cbe599f92e6f424cde55f3319fb86f1752000f57f2586f9004807aada1fc689b9ed454aa7dacd0a2657e27d9131cd0c7a7a62554db511cf25167c379c42f24e10b3fe9ca40a24897a3031896645204340bfadb5ed7a6f188848731a99b7bc0ae73a4a4cb9058d4a7c94867fb85f5d0e806fa0b1e0805ba9dd4472f1c2f58e0a1cf5b8f92a7dcb70b7b7801f2c1d59964f9f8ed116636b75ec01c80e779d8afbba4eb370fca3a9a1ca0bc4f926853ac8b98458318e4fe882269eaa75f977b60781259ed862e4833e7131584dfa9b143929d833dffc3ddf60dd8d08a6375e6cdd1aee70bbe2016c0180266f1f5e6fdf2bd870133f3d6447d3ce8e0c9abf8ce2fda6d15def7de1a1f268126df87fc84bf7110e7b22df52c3d632ae904a3316c5e0a49f6a6e8d90c227b1e93870b282b03bdec1d9b00a7d722012244d9d630f72f09f82efb1fc40b9c0ac155c5fae17ae5c975c1b2de53c3bd8ab9fcd7eb5e8576c2bb4c8acf24e35867c5cb387f61ccb6e23c9ac5cd3f10a1ef8ad517b2823ab0e09a747e145efaf2845712098d6892f0caf26397eeff39d2f19a73c5beecd1df3fda027cb724de80b458f2d5b0dbee7eb69bc106b011ef8f158f92dd53e692d9f3ccf9772233400913eac41c02706ea807105f6d054d9f5260ac3fe7f568a57d05477974c04b71848b6f77d22fd184d553a8ba5b900a436e51828b3ed6aaf93ffbbe6bbeb426bb9e813929d0ad099d279474861da3afa7d7adfaea0057e9c214fc9183649b5fdf28c6b41a0f0c8178e27e883b52c747ec3c51c34aa0f78a4f3c0b7841e57dada9cabc85ed94fcf429d28504a4f2d30709e63af227536ff67eb673ef70b15d36341ef754b942ae1bda6967008af73eb4bb86655239167ea9cb4cc406cbb6b5103f541a65a494e8095f87d80fcfd9fb9560daeed3e98273d09585c10d5ea6ef1df9c9117af928322f15260c6a1e85379f28f8ec669f0aea09752a626495be7d7e49f9a9c2537a086fa8a1dad0e5d2e0ca2934ef539d2768c609c297cca52a8e740e4864eb714f1b16c428e62062ad22ec563a6450e8e57e9a9e6781ed2b980d70a4b0dfe076af4b5f1ff98d8e53f3458c4760483b0c349b49b9c0174214dec3603d02d0e8a43b13a186d74ef7c3adedf5e6d2ac725ca241767a89797da0877f2df26cf825b3eb94db0a2cf7a2bcdc9cdb5d59aaf270f78acf3a975081515576bd995076643f6613c08c1d167a40d20bd6e22b52ec7840ec1fc3647304f92bc123ece141671f2a541f2b92ffe10e799e95ce94b5b500274389ef2ade31dd850b362dda4319cef3f39e459f9e89e1bb2299ca63df4e28099baae94737aad52b23d63dd8e1541f117515e76013546af00cad1d6d58e5a703ffd96e9054c516807227574e8cf9de2b906de1d2d53e9452fff5ef30154b57e649e7f1dbacc20f0dd4512e6b235c1458bc4caa48c0341030299e6a7b93d2dc2a63141fea437702439edc2cbed9ac591c57e5d5fa01679eaf3b0a95ab4ec798df3267fd4335daed373724d5ee44c24f2b676fc306ff57b89c9925a70c9261534c3a02a8ac2bf78eb98500431282512341b11acf1d19ff39508d036c7bfdcef926bf84c2a1382c4cc802d679eb73a696786ad5b07beeee529e3bdb871522f6d507a28c1433e4815be7690d0e30376938cc4aa03147f461401881afa480901a5cfe187209089616889373391b0159ebe11f24596fd894e83a4a1e07f11698464817e5f46dd7b441f85844a23e0ee723d93c658b8d36bf28c6ac29bb9183a470c4282724f4dd6fd113537876141a4bab1b8e5ece5bcb703c3bb82468442ddbd77043f765f1be8034b840581a3b134a5f7f51f004aa0a64de5b1a501298edc61400f8b8a8040cfb869991c7a19dbd28ce5a5e7e7a7a05f3194b008a8a3a135740f956ca0cbd6d6c676b08dec5b51d451eeb9f345aa252d4e6b8586aebc6eb1b648977d2374e1119318d83be55b4776fb45b731d471f8574958127694e91287e06f58902fafa77bcbcad63afadd82383fee9bf2bf7be9691258bacd8321d0161855d653e72c42db07483818ed5df941a61c9d9127c3f0c3b6c9e578d4e3b0318427e32928fcdda575bb8fec16921448a20da4b1a408904b8814f2d0d1264bce3c736eef608847178278b94e0396349bece442e7d5b96f21c68484ba6c93d0efbd9a33ce911706c8ecb567c50e1172f85d9767456cc8e1803e6101e8927599e6c67f3dba84306a7986568505c0d99cedf861e0ee67a7b6699e30ff74ac6e39ab4ef32dd25cb33ee411f61726f10603a2799ad65343849a4d4ea7f1676172c85b3b46edf3654dcc82b14b5ae125e20aff7385811f642088812a949d46121bb5070f9a05f2221116d5d03aa616036eb531cb3fb072c9374186056dab9a26ced23a634f445a5c014d4b5f5212c1bb3855b687b8005e24932460e313b516ab31909a55bac687f9e8fa8dc4201031662b64331343fd8acec3ee35dc31229a0aa74ed664dfb1b41e5a707d706cb1f155e562221e5ca17bf12cc6a76b5305a1e77f8f54736c09cd25448cabf78a02f6951ec4417e59ea421582d6dfc535f030663955031c6d6645929a92bcf62da21bf4ffe257bab8751294fca1316bcc35fa9886137efe14b6d493d41a53d3f8846da371ca89991636bb137b3ab2896371195486f49851053d8c34315da266448fd74a9cef6d3e6f6b5475cd28dc3d05d06b1a35fc389be79173648c68f86f2569611c85b433daa3148c64f8bccf503b323af8f06d3d4a9c0f4e5b5babec15c3e53ec65c920decf32d01a30869fe3c3f0c94a3cc7d6bdee4f86a6e10401ba4db66015b9916f3051738bcafa3a7a7a49758585aea9f05c8e7c0f2c9f7587aa8f73dec61e16a36bcb75bf545dfab713febdcc752e017f47e72ab172ec3a23e405064962d1cbcdf076bf2cc4986053eaa7355e14cf4a0126cb4343c66edf4424c8407ac064c9debbf465aba37d5b381574747166b5b51a01f2ace59b1c84176b6658ed71673157a3f7b627ffeb284cba232c008c82265d09003073ce142a3e2d97e5d64d823a79c8e7d8ab6ec8eeeb7e12573bfa0ca737c48f9a319d5f6f20b19dc466ddd98bf8ad17e9ff5bc5282f597ef2f3619b72b55230f501abbee9d88775bb229fc49789830fa4c8bdebda534384ebc6a14c3cb0e637cb25b9ee0d8e5c24f77ab15971420c5bc77839071189b3b2ec074473d95735097c8e19cc7c2fc98e96ac7c10195ed36fdf2c465fe6f629cfe177e3dcc55056388ed47db01b7bc9fbcf7082792da455d7a7aceb23667871b5107bc7f6b9c4c7a1c289e3d0ef48b24b8f80fe766bf960c2a42f963d5f810bd664b08ce8f488b6390699b7317213f13f64370a6643cb624e275b8ff3018881fddd6b7e8bffbbee631a1c2b22ec17f6778bae809d2e287cf3c3948cbe39a88e8e32b66c426bd9b904e868db410915ae10bcadec20361e5ab0f0ad6d6164fa0b6c92efbedb0fa3274a0d0be3283bd150818597e80fc826927266b003a3eb5ea54c3171b8e311fb1d37ad632dda3ec0ab4f7bed93a31f1ef022ea35b415cdbbbcee7a56211be4c79237b62512574de9689dd06712aa601d1995f6aec8d677b8c423c479ac651a68c78d3930adfbb711f8c8de0e79a5a7366af03c5fb7291b8e78b33c27fade7d6e64a3bed76a2dafadb87ae1c19d56df36d14351b4270f2970824be9ba5d58b2fda91c0afd547097a09261b851f6234004bb37e292ad29b7adef1c118178b31ff6952534d7d76d5da27310f33244dd926e1707f4bd1b6406c2b6bded8e9276353e99d9a89b0216f3a121011712f9263872d70cf4d45b0eb15bffd41bce64a3320e7d6c1958d8d7cca871c5e2706369eccb73e171dfd192d4658de7c177b9e11adf1fdbf5d7b0496a3e55a4dcc6d52bbf725a66f567599bf37f5e106db3445c04bfd40bd8ac24e7ac832a4e95105a1a247e839af0906c3696c352878ae8d54e2cab321af79ba9e86000b164f814c7f08294dc63b2020be424559d3a069495086d8d5bc1d85f4587b3ec36d49a4d82b2ec9e256173c09abb90ec2ddceffa827b08162113c49ac2faa4f3f8da9be628376a839139f001cf1e88c94dd1d8ec2d8942e0e97e8755e86cd2fcf2713a51c3f2dad606a09e44dec46b4a4d79ba61a9d74445b4864a6ac91f12f480c8c44605bbf47e47cba52111837f1cee1238ea26bca6d765d55df06a1704222b11d17209e8adfd1bae71335db41de060826614126f465c8d3e305e6a11c2bacda3cfff989488d6aa881ea94e309726d9d336c06c4ecaf5a1f9fbc0085be8e9587b8d45ff9c538819601fe69021074f68f4ac0b9a60246a2aa75b7cd407c7cbeb0227b97d8aa787abda02e01bb25adbd04d36c23d50e9dfd5d1054b2c0381cc61c07e8f808301de40566ff5b3ed6eddd49ac1541ac8feae17cbc88089c391f967ae04ff30c92091d6171cc8415d08c607b71e03a922f2605b25e24c141c08812399282e7e1611477b14a994a672b2fc66317a04e0b70b2fa361e51a29dc465e0bfce7036385acbe0455e082bb50c0edc70e4fe395ec72496dc3d7f63f7a0aa208d0afed5bcdbb0e9e462dfda0c26ecc87c0ede0fe872132344e8996b19d83fe65e28103723025b46dd70dae847ee3e4f6fdf1de412828b9174b619cb7142c2a9aba9b02b243b5b339dfacead7f5210d90b2554e96af43f46b0cce708ca52eef926047021a7f743429026dde24cf0ef510f7667654ffb47859872fb4203a7c3e20e7c0e9e37dc0f3b1a4f647fe5a115281bb1cf2755d9686b2aba2a5b621d082103cdc7c1a41e041fbadffb793dce60f226ce458888c0f4a5fba92cf7f47d32ff93b84c8fdad655e880c502d36a55fcef920a294f82f8272cafe1c24df004e7c97467ce0288c949adb2c1e64bdb648e056c169adcbda84c835aebdcef547dbab5c9238ee6867b67c7b667fda2225bd8129d90a8d53453e460d8dcc73f27e59f10234588e029c4ced79fb01af1b3f1c77894429bd68c972558194195dad7a36b214efe05995a2ee98c39b6593caae58fe822d11cc2c6b543ea0eadfafc0116ba44634ebf55540ae62547050ae87d0cc90c5f120928e8dea3ff483691006d3603a92df4e2873e00f8ca014d5bd1324128a0958f3a5694c12c63053b50840af7bebf63aac145757243d58036e9bd8e8ccafdfe0897885da5b55c98d0b86720c1881699ab398d79f648c6d1ae11fcdb5617384f5e7c379221738310850b0a1304102c96c2300e7e67a85c4389606628e37a16337f671eb259b6a4874c1f8bc1eef168d6f83042601d6ed30937861d132465aabbed6567734ed8d1c8d8913975f285505c4d5aee4f9418ebaa9b3fd7ccd58842bc4656535bcf97304399cfeb2fe96855c292420c682b66190401025ef6b26593a2d8228847877f144fb17f90136fa2c9b226d217f7b7c9eb16dd6c92c06b013b1ef64a22f473bbcd560b7c650d704e1e55adb2cbef9d750a0be55d06aad841395bf9c56bae7b80b292090ab38eace58c2f06426081d859bb839a272c975fda90feca54ac3b19bfcf41ce2012d0a66d5ae9de94fec957929436c43a3dd3eaa6c9668d47669aac6ea21d544518d58a3991782c9ab64f2622087cef6687e4fd6f5b94d70fe02dc7a90f8a27b05d8a5325b7ab57cd10a291b4dbb43d75fa9da05c9aa72252750150672a0c8f84d28331ea7555107267c33a554d7945cb912e59814be7fc8b335dcba2c21324dce54989e102204cfc42b2a1df662abc1f1b6738966de373f08ddbfbf446ac76d660ce59f43f2b402e4d501fe41fd6a9161ba9aa2c602b5aa6e7ab46caa5c44b6d7027606e79707136394b446d1cdeb540cbe9b3e2837a68ee1519b3e2550fb0ac6122d9d74eaeb97d684ee5fcb421bb55e5acc985b46f609f1135af64f3270509f05b1622a7b84cc7c2b7000ed3b120372f10c28f0792dbab8e8d2824d9c56981f94fd60fc4b1bd21d8a0b3733524a697c31b7bb9fc55f913bac6bef80b9ba675f7e7dc67660a7ad52cff686714fc012a371dc36e6ff23cf8805d9470f3573ed782b60503c3e1c5fd51df7f93b7d4bd79db3d587bb699aa11034d3e92e057a697b227b87e91ef8ef08fdb5d1f2ffc9ab877a8d9ca6389de6767e63e5a967decb1e355c296b85962c2ba2ec5d3123a6518c85a40d8c6d064b2d8390403f072ea8fcbabe1cf935408368751297fd7d907794fecc6a42ea017ec6e24d1baa63dddfc3d803bbe80d494881cc4e8a7c291ddcea3caaf04016742698e3cfda01a0778ee646d0d5a002dcb23ffaa8c7d2694992d3922eac54b36aec2703c3bab25de260b42397495b68b5ee55190751d60913994f276312b6ab038fed331748890b114f87e43466743381b78f2b8264785bbbd3462b5a2edb042949fc75b13c8daf6dec0c6136d68d8458533bcdaf73eaa560c2da103d63f90990cf743203e20ce7c0ddc9f6a9cdf56acd5a6a39433858351b8a68213c2972ae93bdd091ae7d247a0a896a2c655fa558f292552b0c42a6936556a02215a8478c5891de512357f9589a1edbf982d7021c1df4a44d68a538d91b76f42c78db5e3b94d491ac2748dc6533a4e2dd1fef05efdba2eba716b2ee04433344727749d8d15dc6ae89dd1f184456a85e113d16d6929ce3f57158b5c3c9f201333e6e5134ee9f95dda2393084adc27764b0b60645e1154819ca539f5b1c7cabbdcc16cf8b0fa3094bfd21333c5794dabd4c68595641c9b701426869fcb02cf069633baa0ae08d92a70fa862f7b4cafeb5cd0097b0eb7afa314e2e50b27244ffdba5cf6c06d6f6bc5d8f850e9d36ae3b281790e2384e9c89f8a84e45eee9364b0224d96572aaa28caa01efbb95bf310dbfbf1d5ed34e61ca32bebdc2fc8ba9ef41b16ee3970a2045b9be1946bce9fa6303d107b5dcfac26dbc3bed51d5faf06cef31c866592d42d242c85f8e17f3fc626e1890e7cd9334920d743e985f45765d1d7ce6c95597e09f11f84b3e61d50563550d2a83b54c7660b9f823c4b6ac34981367706167036e36824b708bbdaee047a380e0c041962fce0f0727752063fa1790c9131fc334c753c8bbf5b08410c90b22bb763de6c45dcde680764a5aa9fdcdd5cc56c7121a34165598ec94fcfa3151ffc7685d896bf2659c10725b2a1b2ed6a5788ebe8892e33858fd9cb71b1be522ff6b720bcd66653eb25621114e1e561a1175990cd85fbad503488842e0aab347a3fc25e0ac7bc4da92a36568799bd250cd5af889ebfc19096aafdcc3e52f407f1524d89cd216851850b9220d0d20d1b1674db21ca17b7565844722062398d6ce5ab166301b00a40db33a017be0e847c3b9fe77e66b0b2d98016c92390e1bbb20ceb8bf3f6bb5596f03952dd614e1a4380ae7389d2199959e40ead07f8e2d0c410086b4b1cc0735020b7ae465676baa52d7a26902eadb32004f7ca1a6f8e5bdb62b9c3f7a39b09ac74a850df3b756c258a347ebfbe4a16be9f984faed663609411206a413a1f0d0178d81c69033b5f7b0a93d0e605fe2f6aa5d88b982bddfb9068bdc0964d4cf4eb71457c0491c042b9d8913cc0684453f9dbc3060dd8a083213fd57112aa6d7d0995b8435ceb373ba5d431326e0fca547b8ec65354d46fdd14b329c7cf89cd6c61bb56f6107953d79543542067c8da022ebe98bfaae3366f7865b9636544c45bbc7ba733039eeda2bf2c447b1cd6d88bd90eef11fc5314662c9d6ad57e479b5a6ff15788465e077baf2f053a301358ebd0f6316052420f2681a2b22186120cd20d0929c1d8a489811e59f99d9cbea6535cef6ed6c4e435385ba5acfc36e86ee66e5290a8cef1b262b73de9446be9717ffbb44c4ed1be8c9714ef268d5b5e16715261b771969348bf28cef64e5db21ead43455db34feb920252d6e5b18b87d4fc5de12ce54541e485b73e631dc713fc2440f94999745805044df64ffb7ad2745d9390a79189ff4b0efb1efc0ded1d61920ce55d02ab5102b58677a9c7ecd99f0a737152f12c3c573379f3390c4b2de6517c00256e18778d023252c113781ec7a2f8c2998a8526a662f1637cc3b633a36bd90404124307df51e9ba0a1c1cd2f875f701e2ff5b5ad7673613cdcdfd4fba2b056a0b07e9f4ded1b24b9579947938dde7fee86653196c1578c70768a3987e4dc7d7d1c7b2780ef84f8d3be0cec115dd33e2c4c3e72149375ac29134bd26d1a689ccb93febf92975be20c386d68fff7f296de63eb3ba3abaac2f06de8edce8eb0f17b54a609fe10e823cf9d12e4822d52972aa615da82da880fdbd2289e9b7e1b873002093730e72c492b5aad934e0739f8515614875af98271d87758e26ad7b0e6c2d2f3b9398f6bd88afc0591c7e3fc1ef584e7b87ef8318e9895e084ecce902cc66a3cac88dbb8aa6cd7cf0d6613be7a24b4e99f8e0a2cc6d29429853bbfd3e4b5695f82cab951aa1f6d6aebdb20421eaeff5c490de7ad2e42c7e4a2dbeaa2592cd0c792e019598d696a377dcc81174638586dde","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
