<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7751d5c2accae4151b9fb110c5a054023ffb022510c4851b967c38f359cd17846c8aa600a0287002532c5a2f8498595296c39e73578cc026c1a643d21252e5217f7dc4dc613b2da49afd5ee41c06783de10733fcb7271e09e11770c7c7bdfa831b267a61344ab2721825bc1fc21a6b51228b46d44e3ab8434356ecf7ee1b13d722bf78b761ce31fcacda390b756ca28d247b17cafc355b6a01e1dba821dd6e174b7bce6dcea56dfd2e98fc6efddd1432e2a0136127c8c1a7dfcba0068491a0c6db6f4ef0236b1de515e9ed9b371bfc0e8d35451c354cbe5fe1b398d5c259bcda6004234c4ad8de707c368d185989a24aa44da53317e894c67474c0f595d2b766d0c456562bc69ec6a2f854a36ac86c9d696acf1b1194c4732bdf308539392d381bc5d8bae1cad312a10a6972ee2ed3c9392f8bc5df2c021ddd869b7b588275adefb1838a5257baef7cfe43606623762fc920f7429c3ab2a86cc99d2bb38c2206f861147565b560a02404400a469d62902f8c488c13d82388c8d9fdeb042827eb863c28a3f0018adb72430317df557f77e798604130b9420e7b068aed245a1fd712bed699ce47f9cd0b793de00c67882e0f2fe37daf407354ca629298528e998054708ec13e2bff81a66ad7cbba9b53db7f36676db45ef3e3507411c7428564e62f9a670c28031bbaea0e0b4e6d49d154e27ffc526edf29cf03bccc5b6d84779ddb485822d947d7353dbe962d02d8276e3e1700e9448455c5cccaa62dc8f65695405b02d98f228c0493e8cecffd23063c73efe44dcf2ffc8e56771a21f6dadc4c34b3a9813db390d2ee6b523e7a4ad6728c932e314195f829d46d897611c9cba598d24837424ae236de2ea3587e98348206157c53684493deb1151022ddae009ce0116892f7b745eaf0293088271f28ab569a4855812906d349292835ec0eec32d256cff18604166ab62b070a79cfb2fbf5e4344d313b7fd066b424a68395b0ef9f99858dcba04c19ed8d5879dbe3ab827d6858eabe0520d1da0032c0f0eb241e6e855a9de245132991d844478b213d79d665655de15b5b2f4a4e108cd23a00e9f82f26b23f6f039287ed9e7f2fa5ecbc04ca8543c3b2a4e53bb4666368a1f40be7490123179a0c01415f99542d17f8179a318e6ad2886356823484e9fae84d9dda0e89e4b282277378f493c996be202f4286b89d869b149c2ccb61d620c9afa3c722992b73a6fb61ccf80d7e797922205c431cb1c6308d06c90af6e496675ba5f6a4902042bf78e21ecf7765089f5846dde9ac197b5ab7947b88581387d1322b423f8a0171c8b0389443c1af31d0b3bd9f12f18f68884685b52d96e9f5538214e3e71305291e647cbf7632bf0dc57904bf9891aa2e8fa4913b49896b5aa326c00851deac87a597179f4e15dfa8308ca341c97a68a1664569352fec88a0d0b5c4495d13d05ca64a0a3a6d93611add67e28009b23f49ebb741943594d998c732e55991226f07cc90258b565e588583b7365f6bdfe6ee83029ecfacc173aab0727e7d678911a4b56e435c64944887a7c75a689c9bc4edcac0adc019c32d64e21865e51bed9a750f6c21239245b6656275c2cf9fa56c7d57424bede53ffa24d6fd37776f2d1211102059b0c755c4028b12411b0fc7367d77a5428b43765796b59814a845d4c0e8b8bc928ca4f3bb3ea82f7abfffd538e9a352737c680ae0c183e15897b3bcc9acc1f7ea5e2d93bc5ca16a262977dc7e67a1aa677bb42c90f83787ef69363afe21736e13604573d5d2b9b5972bf38a35fa54bffb884e690ebbae5a54d2ef597be1daa035df6fff7e44c835a88042e0b7d7f04b6168013e5c3e2114bd612ec63357cc60e70477c32350a4696beef32952577291306e53d3240a246d1ba1987733eb2d679dd6a1aa3aa30424c34e2d52aa780421fab98619a0328600123c06d50a8ebee083d563de9aa8aca93daeffc59b5419582f23fcca9ec4529ce5c16df728d312086677e986ad8bb675e7da1ba6ec9188e898fd2017874e48b1b83268044aa6ebdf7db086b68cc8f9f8a8363230787991d70cae6edc8df11e7118bcc3373a559d83cf46d6ed1e4cb78def6429003b9457dcd88ec65cd4462d6d5db2d5275a574669308673a8fbb2eda8ce80ba084dd841742a0dd54f7f9617ecfdeec00d750aac9d98fe2796f6ef62bb814f4e972730fa2b08d49b145d0498e257a77d21bedd1fa5978c93e0bdb9d74ce6caa666402f675d42168307b5c57327a883bab1922e883d768b8cf8ffba25d7ca1d1aeaf316c321cb5dd2cb4a8359f6ed2b70c4070cc44533b45f843e802e20d72e2e2a24d495ab936b0ba3598eec377c66d88938d89ff4f1b23bb77bb78d896f25408474ea3f7a9d83f2333045166be14e464824323f019d32e717878cba3cfa0ea4db9522ff59bab95c2519f7488eb31d2a9c64b4106019ccdd7152d30c546621d8c0d7263683ba943016cf7c40d53284d5d69a201034ea6781f192a9b5992ba6580298d48928c7ed86162823b831767bfcd26bb50b53b30057a22e0a8a700bfb3e0d627b58fa513387c662a7b772c66e171b0eeb5ea287bf35e266aa5d7c0c10786177955c22f061ccc8b42e5233a2090abed1f8fb6c8fa75d5ec486b67b5faf60295a02eb71fbda929e7db1ccec3a1d9af7616c0e40bb5d0be3106a24931f8c981c3e99a55a92e3a44341793e13f37bd2e7769ba82bb3f89f18be7077dfe1efd52352d76dcf48d177619b7e61d92f11f545d8854ede5059d811ee224d530921a0e65fc8a23e0b36ec4bfd47940a41e168eeb5b696dd287714ccb44e6a54aac9bba2ad307c68fb5bb25130fbdacb7ccaeee31156b641f88fd1fa919a46ecd95ed3aadb6f8f105c01cb1410e4f0b3b8c4a18e49492e8a381778c432f8e940416030efedda2f33fe40a2c0684d3de6f23f8df394e1b70d59e02fa3e866bfa8ca1a6f532384c75ce2ec1bc8e2a842dd8284bbe84a8dfb06365fc0ad59a33b91e0db3fede5745fcfe35a29e7619563df46268ea4da7b7db8ffa4f35f185d0a1a20eedb555278d5953673a2026f84b966c2132fddb46dad567181a0c76b488dce5871e1b0bd57b9994b1ee2eb21f14584874fea2dc499fee394ea150e987af671606c345f9acae463d443e9760d230f33dd1684f4bdb90dcd481b5773922d7c5c61251a6857bbe6dff1045a22ce45df602130d45067fad91d4d743ba2ce2ec3b7378f0b82e2ee9c01a29c82c5a0af7d226b47d412f7eab93baf33d6db5cdb65523d15197c454d76bd05b695ecaf87a10120ad9af4c4e19ae027960046d7a66ad2115e31e8dc9f995273022dae6ecb3b81660e4a3a1487ac4504b86d55dd0cb9ac9ef02b07caffa321bff99cafc4ce85189711e5a509aeb830ec19dd468974520b02be466e1af9b63655c5d50f4f5bbd55aed9f992c53a26b634eefb859fda06d1ee66163993e7ea4540927ac053b07c567a5bb5cb5f8a6781b20b0d46c12842d99bdfca784edac6e1c1e9f3cd9f1cd082b1dd01debdeb9866a059a8783b5951285c8433afbf81fcb15f4000092616981b2496632851003949cc430c72c83f7659d83521a423eefcb85d7ae69232c9e15742a82e12dfeb64dda3ed54c3ebdba9abaacda6714895bff5610d16fcbc844a866295a1d5a6144b929c86626c58b790822a2e9bffaf674f28237649ab20103de388a62e825af0e64f13a2f9bdd412dce89aa63c3596334f4ab91f86254f56e4075479db1ae447720867335b68bf97748e96ae901fb56b00847c988e05270f6f70bcb8fbfc083c562bac6301861527cb5a6c1f03b01ea1f1db98ab0c4f69900e46bd177412843931d2080b8e076dc12319a14a67df268445d5c78cdccca5df50c1e32430b43ccd2677cc7da58affb5c00ba56eac6e666e397c71f51d45035222bebec11a23736bdd36f4649019199b328f58d64eaad25180f2a3cc29a68e96b5a1325ddb10722785ed32c48d2175b538075b84ffa8b7c4d000f8de2ef7af79fe59bed8ee003f096415ddbdec6dd5b64b417b38e3d12762ad9c2015bd228bf5813e8e0041cc8a2a962882fd03a2979ec2a0411918b848a7bd7a44b87b7cda89ae693183c35df2fa0c568b0dc3dd139dcd0c9614714b9d260994527469a70d994badb5609c200c56cf4f32eaeb1c4ba0018ab47f38d3df383cb628e8d0bda573683969cd176f7c0534415388f43640996c049695aef14e8cfc2181e6b4dabaeb7633afee72faae47a08970975b874fcd0cd1d6b5a17d1f292b22f09bd44890f96e21f000596debab1c600f31e2276c20470e293213ffd859a5811d8781b7db459e5af94b342c33c3e7822413feb637042e113eb36b0140a5fb4248d154e53afc176e8f94e7c42b2a3625df7aae110ccb2ced5bc72e1607563633066433616cb7f46f7535ed5db297141d4551da8e169f41799ae018f428bcb0828afdc48d31c0c018ef039054472734a55cd18d0db3d4a05ec5a474ce0a8eeaf4426b33655407adbad4de0f9866799af7fb6a738329615cfb2e608bd21be7518a257ea9ac7bdf145e328c2f4a46782bff75848ef4a552269a35aa75c5236128110a8270155889f5746be87c8008835eb6628fc961f6acd5c6a5793eb056546770bb7c50bac8992eaec9f7b4e3b79955586428f1300bcc1ed3fc73b88bd7099d9b3ba045d37f645f1263e4938830d2195c4a3a86eac7182cd887a48354352e2236a140aebb14dbf34184e0cc6df2384d39b3304057c3b4d8d94750409cbd47a648ba3cd520747ecdff1b93bd839a7c7d8c71b2c7359c5e165c5c7b4549ed5c25e57d9f05ef9a361f44fbbabe67316ef07900838ff3e27d080df7f6c3c97d322b4520ff900abf5c05a9d2e48fe95b600a425b8b20640c396bcc3a6c75fb32ac050598cb1483b8d9da0585d6f3e4d5d6310954ac5e69390287e2591166e949f737b30ee6e212850feb4e0344b7a3f66ef5e480708bc3f266840ff6f19187cde11afd7d426ad6b5cbca25acad7558d93ce3568bdfef5a787851d41f4fd92ab500cfa3ef326cf2d311eb51bf2e2664875e2e1dc040a549871722e12c81ba2832171ae31a431435a0546d700aaaae741ecb023f653bb548da8c6d72d580d6d91dd64e4100d44113af1f197703fdb350d9024f35f6b0b8744e382a196cb58d0c9faaf1d37c64fb54668f604aed7916d08df63b415e76928c05b56b0887183a142a97aaaed16e8d26f6b4201de3ac6dac4ed756ece8972c1ee6a68596028b4b7da11b4641b7ac6df30646e67d625975fe953198e86ca1b2a30ff6acea509115a700d0f84bf3555e91fa669b286f805cb68edda02b3db025786a9df78e3c5dbc7f210cac1ef450a03f12512fe4e68974ab2a8897c6b526d2fd5ca6cd739c64aa581992a77f54a458396bca193e8a27ced829e6c505abbe0ed636e2f0f762a2fe2bf605345537416c988ad939116019c88c5e292b7dd1b2599a13e46c6216eb03d883d37bf6bf1910db29159806a07e4db13aa5043d009597144ff4a64b4610db0401b43363107f312c75715939203abc84f58fe5f5564b4efc11af69154fa84abecba29c02dcf37cf3a78bfb67009ad782db07c94e73d630d74a78da64ff9b3c0848f2630ac3f35be01dadd325f24d88cb626ae004764c01bb4a6c2f1dd027acde018da49350981750d427f2a0ed17729fe1c571d5d9a2ea71370fb50a7b3239da83ef2a7d303c44e9d5c84fe00b852699b3c8806d3aef66c71b7d57ad797b8c890b56df02ec22f60212da71202b39e0a34819d3fbb38e1e9f82d45a6ea876512122c71e5139a9a342f84abd717848f2adbd9ef4b1b0bebc0b78094037381627d7edda15be4fe22b0724757d4b4ccf51eb4aa54d2682f9c3c8fc9090c9d051d94f9c64917f412d20dfaf1cbc0d45482b4e99d5414d9332182b6399fb8f5bbe78f0f9ca8f01c38b9099de5d7688a917a63dd5eb587b9de5cd3b2436ce495cc6c31a7d9bc52dd38418c68840ec126202baf024d43fe7dd8e9907dc03c0f5ff77f053d1e2b9eb632b03dd49e441cd3e3d7d98e09413145b93e971a81b136b0a809ad9c3515afa57fac771ccb3679e9e9304baf30e4522519f34449d66bbc9b680a59c228b9bfa3fbbbee2e62b58d14cf55e8f5dc266060337048582aea087bf3ee4d8140e1eb180cc0faf30b8909c99c077978935a46e05b99344619b0653ced6e078c793aff49c9ad7c8add18b3d3e90e90664b2a419c3ac3c6cf7147eabfe1baf9d7e03374b486feda5a015f3c01bd21696a1019ed8748fd9f1aef2da04bba760fa11a5d23f15ff4cc2b1aea4ef1976e6c8140c4b9dfec0a812b54be95c99d742fd8f1df9c50add8907ecc0bea3efeffce06b38edbd6c0f7ef25623c4b9cae81e0cf7f1c5a12db469f78fd849c10e381792c9bfc8bf84f5557b524a0c9f1fb9f15e0e3b3654c6424941da516cfe262c108a6f15306791a1c112ebdfce97dc252aa7221bc8b257c8d7c176e61c84ee0fc559d398b12ff095e7c9fb98913844b9866b655ef88bfec20426ff5650d8a3f558daed8c878dd6476cbb8c001dda6ba4630fa5ac31fd3bcab22e153934109a7e0a8c2bd72c06730668369f3b2a1c52e683a309cba3fbd330b868da8d14166f89ec19178ce3e7e6d5e93a487bde5453ad4076361c5f04b7e0e1837f8c92145d1677f7a1b25a3e1b89296507db6e75121f0cd92d2dc0672844d5efb5ea2eb36958660c92ea2e03e4693c3fcb33ab34075e6936cda23079d8bb310bf8f417dd2a3fc6226f9111d279a9e002fc78e49fa0f5070b62982269296c70411d0d410037dfa8a7f2a54919e3ff964a2e5ef8a7891ded7bd021adb7e82ccb91a48499b24f981cfac5a0063cfa4ef24229d8eda2d68422157c5e8570a2544bd7c97ad1a6a2b0927e5e04bcf641b0057f444f343d8acd329c1cccd218e21599e9b57b1ce916e7b4f7487c2a1db25267dfb71666aa13780696c628d5f8d6c340cff1b66186e4205a19c599b09071d32054fb39a6345b60fd451f2935ac0c0a26f1fa53d4b28864c312d46c50a0e35e62c0e0af6cfa551594329ebf8dd6abaf83c1f1f46fc2fc37476b1c4219310dd1de536a90a73da198a5ab63ae12fa7a4adfd458e15454fb43a09b73928b0344f5e46cd308ad0553836f4fee7277a31846eafd923ada03510f07cff4a81f667bfa537afb6f16f2fcd1ba72285c9182d8cc3d8c0a74eecae2f693512e889906248ea6cdddd7280bc688b61626ba27c507162c8009cfcddb02533217ec4bb04a311193e75c92b11104524e4816c82386e78e549ff0c084a2653449b8a73d1c795f216d86705964e8f323698cdf76c12ce03a2abbfb21fa1a4b3271eca47922da5166ccf736697f1e54b22f2c3d5134679b21463bd095b79c77d65aad99b370352a6b927897c5cdd9ab9c0ef55f14cc2a7e106828484507193ac5ef9896674e2ca60a50e8b510f26ddcc6ee1c05858afa38665d7c715769ab2cdfc9490ff5f41926e1252242f685063e6b0aa0f217de6ff83d2d4dbce3263d4629b9216134acb8f2afc35937485fa5eb31e65832c4ab4ac9dbb3c090281d7cc43db387632255e1391208aa46da62283bcfd426475e6a85aa20eca62629dae615f5f53c9ad67f928bb16e4afa1db57b6e665fd6fdddf05ad0ebed6e1da0631e3526b0424e86368588a73c6fdbf0b232264007353b6a42123eb1c9357abe0acd7763250cd570cf5ce91da2b9cafdf5944258241684535b3e485abdb7327592f8aff6e3d635bd0446ac5d89e0ad5ec437817facb02ccc7dc7f5c0d91ec60db860f34a2e9b1d7eaffb29167c4474644cd8f2b8fe4c444c14c648e1f79d346aaab759fa0ad8a5942ad49026f4864896434d9c94b4e2330226456b9947a6ab77bebee6b64659de19ffcc7685144bf44a28634285958436a37740cb80184682977c684409238c745484187ace3a6c400531a938e75448ac7826ca56b6e0715d1ce7e3a0ec050d787ff2e20b7ee8cddeeb82d066290db2cb83d3c4786525ada29daf31c867efc8d3521e7c334f82788566d0b7af78d0f9a0b08d795cc17f02cf7337635a5a8338f6ab05098f86f642ed678f065cef2b2d3cef9732fa81c5385690d37fec314d12277e7579031756ef6475e51903f458e4be09e910c41f6366dd61a5f776fa412c2c079f1af88c84c8b422658efa0ee33682e0e9cb90db7737626a60f6cb50d0d367b5d515945883632e6e690f88bcca5a78b213e72cc3ffc1f47e17438af65a7138c9d5ee0bb44bb9b3021c8d23b164fe3c0bb2467aa0b7f2bf5ca66159cbe5dc66d68c344d9cb5d04b326ec1093a7b62d877631bf203c1d23a1552c4c2eabd402271cba91fe03ca260e49aebaa571d93a47bb1c3b928a7c0a4db1e44b5fff846232a9deaacc1a53235e45fc941f16d528454558c9694ee49f0a6d6d637615acf23c2a78b3d821f2e04c2bf53c58d3011239c56656ba16c7dcaca0231ab12440c199dc8d2bd9dc193c758ef75e3b8b8ad173a5b2ea531ab33de4e7a76c5bf53093273713f4cd1cbca53518541eb3754a4ee01c7f62bc2b0abd39cf5780a1566b91be4be5df568baf0b4469175ee7c04f2e5246aa7835054b559aa2e1fe04dd49124b1c633a6dc8a9d7b615413d4157ec5f1cd7e1df5fc301aa74528127314fc67381ac8343e47ae97651277ffccd610de7384e513fb9a31db494afa8389c8f4947b1984f6d5fa051296924ef12e23e5575254c70886f79a86fcd7b461df97c9cc69e9638675267670443e8432757b3e3f762bafb2f125b92fca8162a5674a1da3ceaccaa0a03781a840f0e2f5d97f4e387b0e0918f20625d85db980000721099a4c3f4cc71c364ff31bca54717203624ef01f935e272ad3afe64197824c3a161f7146a7bcfe3214ac51486d3df2ff5b5239154f8c9274505add707a07fc5c8c21fcdfca897c040a4a20a94770c8fb4cfd9e7ab6c584589d5f2bee5c203465278408d053eafa3a7a220ffeec22f7790e9dde46315989b815d8646ec0ae67b67eeb61e8eaf922de037f40791fa350490bee106317b9b3c21fffcc28a77a701e4cab292abe2f1ccc0aa9864d203c3ee11be2a607f39e77600e606ffeee87bd9f58c723a293aa9af5c466179c25e783afe2b26e7ffe64c34851a850b8fcd8b032dd8c8d78ff40769f7d1c1705139d594e58c6e09a5b282c5c8e9eff541ac358f2f091f2eda8f377eab7c84810a71686d30240bb1f148d8e450ebb150e53657291c1d81f33a35c1ffbd868814ad0d9a0829626f786ab4d09c29aacc85cf5dc5ede6de13e8cb0e1949108f1f5d2d007a0bed7a646345f21e43c09ca339fd7ce9efdab088f20cccf2c018e70199f45488f7f725d49b82f2ed1e1167ec6f4e9fa6531fe67af04d57c408991dea8f1edb814c6de1c0c2e853bf5b5b6d22f2500084dd234f360b9be7fd6a1150ce68484bd5c11f312722b833a9b94a02c26f82c96ba744f0b29ce53e1cb8703d95e1b70041d971477feec5fb61d7d5c31c5db5dd7e152713c0e65c931eb22a26af67dfdec760a5fdb6983b4f15031dae52a9945623b0551b03d006dc0fc71628ec407a234faea8e0483b9c8dca0bab6ebef93b09d5e7aad29401cb586f092c84bf58615a30923458a6f923a659a52ace38d5e6bfe9b735fed8d29303ae259e843b9d6ba61ecef2955945d2471e508bb1ccb6be2457306a9b5b0d77056851d6e9872e3af204c75392570ebd89c80c734ecf24d86a66f31cf2e03793141c471933fbcb0516745e47baf94ddc9d7e3c33d9b1f41ae23f5dba0052c6a8cf3cb49aea18fdc2b8d6a621eb1d791886da8136c01bfd94be6b43663de322f5d1ae564bcbdfd259842060e3039a93ba8b87a49f053ace802da9cd1934c6dbec77227ca0844aee9f439e73fde842c621264482256790b0d7a436fccebda7b9e57425a2a6c4224be5b0af8f8a0df8193f0fddae9b7f71a3d9e41928dd31f7438bd4b7cfbe75bb8f66c5caa1a4a3a291b50d00b978e9b85ceb97e35bdf9b1ad5416a6c1e7af7628d68c6bc4f5ede621d8befe603b03490abd02d745dd0b1a41e3d2d04d44e633d1fef6b8e3e7ef32ab32967f99f667fcb7578bc164410b5061d4d872773625d29aec7564d2310244574cb44d9039f2d7e8f7c719e4165951e58b76a95c673ab92abfa00f0634543144e6c75c2cede2af0d22e0f003e42ebc096449343d320b32f54d493e475ccfb88868f0aa48a67c42f5b21d9ea7e8afb33dcae6b1e572905fe19ec3bd0815d33563bc7fc787053307d0c7bb40a24663180df60ed25ac1920502be27f7cf95cb7dbf4fc08e0fac0287e56b9235c385d8b0b7db73d54a79136236977a474f9bb448799d9fe8f40f12407667494bed6a17f6f9998f19cd1e32c73fedcf84b428330d9e8281467b546fe1e632412f9408a4bba6eb162017940f6e3aadf3a531a0d458d2b0f9efce03daa2247a80d845ec78fa5f8b5c6cbe2d4559c29782ff019e86fa02adb5a344508a24d85fe97a31d8abeedb0a3c03eae70a13fe362a7fc36621d567f30f3e247d3ed36511606c57e2e4943e6e168d8ce82ba3c988107edecab56ba52807c34439fd6e84f8bcaa432d1762c84fee3bc0b7a8b08189086eec620b8b406f73219017f490fb821fe430c4d582c0373c11a7c370871bbe0f27f3e6d72cb7446058d7ce44417cd44ab72cf3b64453c7d7bb569c33bc77e59402692847694ae8dfae8f5511bcd0ab2ee810df7a5f6db041a189eab2744ccab249305bebf03147679ef9441562d2a6dbdf5396d5897a04cc486590d473c543f5dee9c6a212550946e2abaf2f23d10d8c1bb92cce033428d35a6a8b750fd80eeb0cc79ce5991cf8d296bc241b5589e9b2fb2e7454e1a34ee48a7a73f25ea6f91714cdb513eceb05a21ddfe55cd70ad32a196b48ffd3df316d92f4f10173255371bd36178c6938d981727ebfab978d376ea086c3965e5451414f2b8fa789bcf92844b3f552c8e3047a7782e078b3f1f53ae5f3ddc68bd9110415179fe5ed29635175e9b1326533941431bcd5c4d683cf1f634be64a4168d52d8e2be64e6d69dde37f176f42e89eb91e7b0189e4b8667cb75c9c51b536e580073c12719f66f9cb5955029cecb58716ee53ce7e055531a6986a9b7e4fd5aa9c0dc9c93d1ff6c11dbef869d82f12d4db53f2e1a478288dcba6c3287edf5e71d8f56b92dd06d4f2b4ac0cfe862937ad1da5fcd03cc302416704ec011d56a9fda233cdd68c13b4f899d6c1095843a75d1658e873e342eed79d2f8e86b0bd62f07f62f2eefb1c53e141b0fd1e142e52fce7f52c2a289f5c37a7605b61ea06c477ec6ba683a71d085004536aa0163fb340a3b76738f0c5ce0d074d7bd7495ef96d5eaed6bb0ee5f439d93af4436497131320fe07019ee6ebf96cd3a80d96d927d5b0eb1d2688359645cbcf20a5e860f2a62be13a977d4215157a51a44e12630c988d79d4123ec052571be972ffec679a9347b0337ee57defb3f7f783900575e7f69e2b304bc25d164a8f7a2789b5d5f05ccf7f74ad4ad31ef9db09b0d8f41202b6efffe2b12e6e90acc57aaf0cc990cdeb06ef6984779c482968988c4d92813cfb7d0561c85922ec57343b0d2eea08b37266077896bca8d030af491b7e8147f91048fdd0032255acf9e30333baa8977f09f788d84c99da40fc6ea61e0fb84310044d4b1950d7a77822aa6d5b9566a1bdadea82ee14c8f1b093ac643a91e75baa4f640d2a2a81a527b2e10f7c39f17e983ed939716fbca172ab0893fa357abf070f218887b29749bca8ce5df77f6718bdd21b53e29b6233c1afb8f9a27e03c63b31aed0d378aacf89151bb7127208e152c1e3963d5cb8bd68d910494e3d0b29b4297223804806b78060e095c485ce4385694d6a0de37997fec6aadad2bca91036a3e68f0dd46c4f6a7384702a58f8480a9e1a900cc77ed11a91f2bb501d88a806565656d2a18c63c0f8bb05a90be4af5d8626c8771ad6a88d468c600b1b8cca15d050cffd9d64e2f9771ff5ae1b5db94bfdd3f5b73114be2cc44fbd1868d6f5cd6914cb576d0ef7ca3143b249e972120a7aa56114ccee79a64a0393e3cd401937c569a8bec6f245b994a5a8b2b874d1c9cb223c1197c549ec69d505fb65a92e7d9906bc7f2f30ee9b9e28c466b18d829abacb93a08befa21f4a52517ece8686fee5ec3c73f8c3b4b345fbca501547982c00534400208f875b040e14d4b4d9ce34318f0534d64ec7c3bb022f9f24667c9e6e99e635aee173e08d58caf930b1c323321493ef82b02f612e63adad4d6ed3b88365815b50d86167e4b50c60283f9fa5fecb39fd11527875fac39f501caf5a08ffc6a9f2e81760cf9db0efd3b6ef7931eff0fa09e675db0d4be75cad4114d24f95d2d52074fcab9e59544afe7d725a24bccc267c1ca42aa3923add24618672a89e129ab014239a14fbb2463513ab538b64e782915635fe940d768e7d6da1ebe8054b5c538053a9b84a119362cabf97f27f38cfe0edeb3f11d88a0ef0befcd637fd352a64c16afde1ff33456d5e5d624cfb9cf251cc96055bc68ebce349e54edea5dd7cfff7129081c9776bc0ee50ff6fa2af8bff0b40d9f4abf66824aaf339caedcc4760206da412beffe3708c9bbd04ac0df1eaa11756d56fdc331e1eff689ae8ea7afb776719caa17beac5350834413fc920c58b6317765db5f104f8507f8db7fe305daf25569ac83a3e49eac0da6277dff0671b105c0b154b7d552e9ed7948a2aedaec7682e2ab95a24e52f126f63d928c552f3d865b860455436070f75ead2765ed92021f926e966c6cbbc5e19145bf04b3ff8efcbf508f779f7af418f8be1b635b39b007fcfc0ff027944d72ba1ba2d4a0f9c868413efc9ca8454f53987d705560487f7aaec82f64e87c51291c094e1d16402c3cc5a85e7e7b1e0ff771540563b02a4f1d89bd25d92d68e2912187fb4954af5b8a596ab14bc67e1e7170ec1357069bc4e9885087560608052bc31643f1e4fdc16c2b2dd1e47ad3b83fe4ab5be36c4f95817c48df1945b7af9e42d2cfd39bb44a0846d2ac262f17bec9c7f2fa9025c6fe4a8e73079a83940d955c8dccec4e8c2f0e6b3e7975c719ddb953500f5c4d28e476e72ea70ccc02b045d2524eaeb2408c69d70021f7bed8c5534240988b8dc704be41b95545b197e5989551b413727c743f414bd83754f4ac2e379aa679d338939449cf33c7fd4854b28be21eacb201a58da9b1ba40f8d90a2b1df0e214605f9eeaa92b692d230188dc1dfaf242860d8470db5dd5b49356fa6e777fb47953eb6d8d4b2ee120b9745af304a9f327b99060889bed06724c7f7f3f7fa7ec4157c8b48efc26bb5a82955c3dfd6cf271cd1586c2f0a21ae35700f928a9ce92cbee311d447a84238078686de29fca58044fdf1343e3334b3c72cc285f8e74b8b56f384364ef484a2c1ff204b52d06655d54cbf93656da084752796fb53e1385af9fb64238e0dab1a09b143315a33cb71e74b3171a45217fb13ddc2c0de3311989d0704cf8d4cc685078d2e360b73c555172db8a65ff57fd4d38000e421a7be8cd1fd2b420ab2dea62384280583f8a4ce561af08ed713307153991ed4a0d93d49e6416e773db05fe7cf017f2d5e5ce486e4d0642db241a6cacdea62d7d2142c189ce9aa0e261f32c67c4e64774bfbb397bec44d239f13184155f36dccd3f35d99f996d4d8f61ae9a97df640efbad8e950f537ba54eecdf437f6227b92aa9ef52a26eb6cd9361bbbefaf484f85058682397315db949fd173ccc89ab2ede7d7133aaee1af3dc13895a5033e08cba4bd9c8d4d457976d02417d8bddac88eb97777963dd4d06a40a1ac669e208173f2471f02d22262ef284b2e125f1fb955d6ddc1d9919208b7e3edcb9fa514e762d78dd91703146a785600ef2334c6527152a1f1451c11da2708cfa2a0f5d2ea358f8bf2af565d5ef62c883593e062b57efecc05fea0eea6adb00a72df9af4705e15cbd695f683fb6a7b17bf63c466e294abb8131183aa860c99edd4aa55b967c1c570d338062716940a2e790c3ea257b0b81d3754b2f20b32871ca99202b1560352bfef935cfdb30ab6868e704e7c53f6c606519e221e7154b7634a8bcd2bb4da46051580b9736e629b4c125535c62648216a0d580112810256b7b96bdf1e0f341c9a809b9172c65116ce533693209e2f7b1b0bcf2f28b547627ef92b1201e11392b892666ab523dfc0d78090dd67cb425ebc54cf9370f9dd9d78d773f5db9cf8ad72c96ba5c8494c454ff9cc33b931c0ad2b14ae6e717ec2a7a31fc4552e00a7f8a92351c77954d37a4b57fcccf1ae572581929f21d5403c7e73a897fedc750ff03e4b16929e4ee266a78c175c2ef347a5ca9ae9ff3c7345fda244678373642101b8aa374e82694bae82df761fa3a3217f40e4adda526e1f984a4810ae88c9881971e0da5b3a2ff57a05775d9278522f81f574e1a9d2e48fb188c1537ce23aa55d60ec493da98b9dce138a71d81bea24faa22be79cff6f9e2fb672feedbdc05388d1dd6893558dbd15003fa0fcd5ac31aed3adeba2a464295bf523f098fd21a47163602270340753fbd88dfc24611de98819b8e8e127d30b41922f14b26f3748408b173e8350c9313bf17bd2616d0433465036a19b25473ff781955664750e781ba8dfff7c405e40e0118ffba3d449bd33f6303e5d2edfbb25eb18e0682de660559152b4ca967bbac816234eb8ab862534a936b95cf46bad81460fb2358e6c1b6322a101daaf863a86b1b997ccb3e39eee1199cd4adb3d306d101e3e6c78e581f84677d4b9d547b080518bdb6415f166f5a38b320e9979c0b07973b9a50941be0fbcdcf9c0ed045d7b55395eb6feeebea30b1a30d54a0e2b87ed673dc26f513e5d5251b047ea2a13e962636c449b653fff687db66960c96a0d1ffa8b5c43800aa03c973cc0ee2625bb83bd72a7df67bd0db68f7f3232e274f473625e6fa42ddd4f110ea51f99e8658e75115b3842fc8888510d8db63570368110323f3aa640c02e568f52ab1c3d08ca693f44d19703a6be44801e12ecce2277af1a886b5f80c01c1e5be89a142a01888a7563f8b608848ebf8b9874ed4663142e84598692e4e4961f54d7b0335d43bbaecff747a210a2fa2b5dae8256093c5a4197d717e5d91c6c10328b8f97b24f94650f006ffb8cbb808fb77f05e034d39f19161b97145df2529513e83c11a8f6a696c1aa8ad3cfc17f89d6f30f3ae463c70647d18106e8ed18f9a5c11fabb2066db3f46b802d78f42ae2a4bca0d5bf7c03f4c024921dac8081cbad904b1f1765a4c841d92e233eb28f88ff843973aece4bc778e414c31dd176019d90386c0d7536431baed84c37664b4256acfe32344eb0559aae30c99177bddf77f7c5a8615f5bfe16ebe6ce27728a0cedcbd3607b38eaf0b4418358eee5303f59247bb1be394995bbc30f65529c6f138c28ed8f0186ae6abd0d6eff49458f78c829721790aa0dad15e2cb0f76d041fca9a996c56daa64aa9ab71a010be66701cddab5fcfd028b13d90168cbf79be792a3d5860cb2816fb09fffb0a539ab8fcc45be2acec614ee4048a3138fe427dccee142ac6c416fdc72e6af4dd0eab1bbc271d57feb14557e58a2b09a0b82389a5ae8a9f842a1660d8b3a2b54ad1fdbc6b5933ac776e51859b43e251f97bbc574cfb7862d222c9f2e9c6c311c9a755f001637d9040afb2da4c3b6586f5df4acf3c5c48a34c42962bd77515bf722bbd5bd0390a1129867d8e79c252f07ea640258b713d2f2251df7dd6216c06c07650bd6981b20688e107321abf9a137100612681d4961102adf9e217df2d650c9d0fff2ab2a04f2be87dae1a8dc82e7d2b25e8fb63c6cda19aa56540ae4c10097c650a956417d15337238549e57cf84ee3314b3875b1bf1dd08253503c7d1c23efc4aefa84a5f327890ae8cc453533034425e9dbe8e13534915f527dc2c9d44c6e10f6d04b54516c92c1a7a570c90395e3b512dff4994d3889a7408d15873c8b2535b3172ba0900c253266d446b76cce29da49b57287ab40d37bc261842e1f7d5bc9bba3bb62afb807b019aa4afbdc721ef43d62cadf2484eed9074379e453a68b6af793fe138a8b914608f4d4d688749466dc71465e28d103135338facd29d3d2da3691ee2f2103e9aab044b981749e2a08dfe55b07e23487c539896f1f12e285d9f7027d6e01b5b464d9872a7567b3222a7284fb6dc34fda9f88f6aa52d341e58fc26ac0b0ef87b587357331459f6081d449a1723a0fbdd6e2207879eb6d19978030371676ce860b3465961d8043184d70d923cd14f4eb76e17de54550c5ed5c02d3ea88ac0dc064b3406c08b501a643c1b7daf3885849af508c0407c6ea5ae9e8aeccd91ed2fe2baba04fd76c1a0625bce7eb81d2d6552f0979f4ce9622f065ca6759ef11cf5f9bbe9b7adaea6c795c6421612c79292c16bad87c365d0f9d3b72a3a421a4ba58a715c5229fe59bec421c5b19436bad652997aeed0b3815d7f36666af6ebe566ebe4bcf60029047d08101670cdb673fcc0b1f86fa8f5d8f681239df0cc65bec31b09130eff8a13ada1d6aacd98313c6e5bfdf68226795dfa67b44a0fc7ec679c90564fea2f4a0580b00b97566fcf1523a9f46cfcb96c73babc01233ec6ad2b0365e5e5c761a54632e59190881be442600ffc0488246b136be0b9b85eca8de895b90168ff402074d22454774eafb46e5159fb188dd4d91cfeee38bacf9755efe32e22ed613cca63199398ab557acd95d53c6545f4cae87b1bb424458e3836dc841287e29751eb151efb1201777eb248e3f1c1b9f80aaf097664edf459fea7269a0b50d4120f8b680b3def64b260d05885307f0dd77b4325e50f74a31212339a58303f2fa26fce841b011e8f070a308a7d0efd03bdc834fb4683c6d69a3284c2f067b62e80e9b0d6b68a3bcd2f0bedd25ef45b4f693e6c30aaab604aba350fabdeb7691857c1a5a64e1e9b130d795966e3db24a65b00026f2ea746ccb3f80543833c576d3806a722e320ee57508d9b93cd85f5a4ec7f1253bf7d77a52ae556b1f9a98fbb7f869cec8caa0b483510d5cfc1c271c9b98a329494a948fe55bcf0e6493facef28e3f1cd2507a4af4ec8202b34066af29ba110706bc9d01335459a6809f6b3189930b916279bdfd74d8a4a0fa8ef5b8444a885f1ee6195ae8eb987fd9803218ba171acc55bbea34980d88a00a6f2933a857f4ea4533a7e3aee411e63f93c76372a9ec51c940b99de62b5d85ccc768fce65ab838d1d2fc7e3d0bc776334f5fd86bb4b21951bbbfec1936981ce579b583cbba9e7219ddaf8aebba2cc283e4aea767b69c14f046e7d49a3797738d4ff0bda4dab5d3975c676eae9f6284f94fd601c8165fc8e97280329ea1e64fe4f74ca79dc0ec2b989eeea2afac82bfd32713333b4c06f63550e55e925231b9ce71ceb96a74c522e4d0c1a274433f00c9854fc76b2a3a2cceee4e90dae7a5333ba1d0b6579bb1161a27f8683b9bfd634e04ddbeb061f5854c419ab2b5c69b1634c0df7c74e8e3a3cf60d52c73219d599f373bdfc854e241bdd47af7e2b33ecdc48f0b5713ec155aeac798f17fb874888d495f77834ae9221a8667c6fa3819b88a90ee890b690f2056805f6823f0fc8239e3e862e9b59a107e794e2f2510b9d1845407d95d6a68d6cc343a12d825fe7e4a532a9fff098eade133851f20be71a2c8ebf7399078f995daea6b70fc8f2b998a1abebe8b469e851c440993bb2d77b47f1477fc44466c4e071a93e1a583b1e906d10a000b559514acc185dc93da3c799a9a3f55d2e8087f709ad2a1b4a38b1feecd5341842547242e4ae975d03dacbcda69925c35d3b7b6d19d5fa76a6d6dc6a77b02f3b6292c377cbf125aa78c5f00eef35a8e7797b4d83237db5422b361b83af08ed2beec99cba455ca1ba4e0f9e80d405ac140ac03299a3cce7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
