<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"09527a3702e6b8ca4a02d626dc17b7dc337745a0f7f9a0bf8cdbc0f2cd56f6940dd7be5204cb5cf45bd66d631635c97238b80e36851ff8d281ba06c58e0814ddd71da3c390f81e188b364de3f29cc70f170ba94720ed498462052ae647516fc46b47543cf9f39be96b7a213f607b1a5010dd90b771bc61e2cda3d0eabc33bffd7a8678d4892b259fb138e3b14d4bac28a5c875637a32fa9489e43bee19707b8fd5553132828536a8380567f43261bf7e746a4e71f8f417375f64ed79348e106c4ac4b4bb07f995f127cd11a5bae4f0fe4f11dcf58a9983be7d1eb0195e0af8c72374668f683bfa35e7798a7b1c66b58b0d0f44e030c263e608df51da1609420bc7260265b4b86fb726c28676dcef720c952bae2345e53598c997d77dd10213bdad9961c725f70551e405ed20788f276cefc99daf3e28ea79319938368643fdc040cf0a751dd7babd2627d314fff62eabc2922ddffcfe1c77f18c13d8bed59cd21b4e69dc4b9e932aac380495463b2daed672e00fb5e45d2335253d83bed0c9b6d190335bf662ab2ab64bf1e72f416d7b8496d92bc77ed9a9415c3f99188413bcb86760f955284e8fb6fd7a09904f9b8ca2a220a45564a7abb622dc06b24c771d4e8171de26d23e7b684c101b05ec4419916e7848b0c6ae126cbfabeccc49b5abd5e4a43ea52263584efca7201f7352ccb91e65357eae5bef6aabb47374f948be9fc90d743c2cbbfc90840de7e853faba6dc9cf6106c725dfc4d0bdf1b564b79001926689b3b70ab594d54d1d4c1ebc977ed6d68360ce9963f7c25bf5769ab10b54d40b2fb33110e5d460c40e67ad3d2120eb692baab50dfcd45b8806beda4c37fb2d02b74f53babd464b4efe69b4703a81c9b631e8b5dfcd652bce00dc7212e5e020c79aff7581ec4c4ac071bc0ac0dfb1c5a934dda0000b12ffe2b413ad4effb2aaee13eb80db0b5cf54771e859c7cad235ecab31640f6822b4f3084f06c03d4b1cbb32ceb46398a49c660c2c8b6450738858c2ade19e5cf01726ff6a11e7b7297701b59b224b4ceaf29a2ca9b242d7734b164e4690d69cc9edcad2dc1ba40772a3976dd8f39f02d98047fe314e7cddd86b7d516e09b71ffbd5a0c9934817911ff59c5b541b8223fa345c1b058fb693d74ec7d03bfbd1fff735ff31688d2c8e347ea927cfe2bb9122ac6ffe4dda6db198b4fe349ce280da30f92df3a96d9ec89fced1afffef2120d43dcd87f06378df13d5a31203f6219f91009c67ff54d97dd9ee12bcbf7230cd514303b9227b68e144bf6573e53c071a604a470bbc12cad2aaf52a53c4d8e57987dfc0a87706d2455cf88cb6c21743d1a18e7ce7905e5b666585eb15460379b3dc89e29ecd557e3845d7c66bfd986991856766bf30a2135301f17032541611d26792cc03af2bff9d9856118812034e7071dcb41647aec78773bda264e92e34a7128812bc977b4c27f49697a9a39a0f2da2977f5b5057fbb44996992df7114c3d841e5f43f6af64d409e3790634ae15f7ce619c0ea68caa7a218b5252756401cb39fb5e2276ecc55fbb5241ce3aa04719f052764f0e183f3bcf744b28b1cee7284faa4aff40c79814ddb83b98e9b2aa763f1cac6b1a84a10458160951d3d9e96124d649be83afe29b074e62538dfd7fe145cec3babc6fd1e698946601798d00d8f82a5c1de58c89f1e7e5bdca43014c6c4c01fb8ceaea27628e6ee920801882e4d315eb986a075176f4d48f4191df4c9cee0c5be6d574f82fc9c2c0b5c5c2ad26e42ab4677b373926286897dc1b7bacce66d493999c1b8cdd7b78b921b08262e324f4a849008b97e079882f1c3814108b7eeb88ebb9c29656064d1620f5d7cf5d342ef6fef8956a4adbc46129871cd980479150c4124dc8b40d76ed93dea7d7ed33b3f0c25a73cfa7abaaa56a396556df5f6d203ef20133dee068cc4d46a9bb5bc488b2e5719c03e464de7e9002dc5c73d1b904a2cda310d07b6973ee83faadc6f0ac6bcf3e0d8f631d994f5987ca8ef6e071d181df50e45403f45763a082f943017e52fe8a73a5699f3a9922e6f8fa1ab3ea56a98eb9cbc3c33f6677638090084a039cb9d8bf03259defa8a93ad042669819f6b680b2ea33fcc442fa20d34c726d5e0838c7dfe84dd974e3fb9bf75a003ee8a2df2abedd3e75d955cf6f31df353fba60a77242170f7c5fc878126728ae1fba0bcc175af3aff15d6509919fee2e16ec3cc71b4a14f671658ecaa3ea209eb19a05a4ee9b0107874a69e43b404fdfcec43becdabba333528ace9bdcabaca5d34c45204efe0fdd7cc41c532cf26bb3c0d518b8ace9ed19095f5bd289d1c748f940c11358d60f250b09dab66227e16049222a2ad6a9eeb07832fd1b24a423bffd24698f51b36ef8c15435fea41515184cf553390ae0e46563ed02f49ab17dd81cbefc53457a71a6bd3290538029eeeab378a91737c0986a4cfafc94b7a0ccaab6cc1a6e8c71fc36aa7094cddbcac6558cc6c440dc6dc717a1194b2111e179237dc859f37fb434b8e21267ecd8cff4f5b06dded981f5e3fe1a7fa68e54c247d71e834fb2dbf9469b01769f529166db52f17a8eb4d5fd129dd3f2ed74e9b78bbc2ba9dab80b232d068fcfb7d59455054cabd23bb9325d5706cda55111ff5e1de02cee040b1f38c18c4969ac0fbaa57b68aa5715b4562edde8c256f0cb05b811d70b5ef3895295d2997038ef0d6525c8ce1fb23a44f20867bc996daae9932d707731db1d260f9a3a4cdd1db33d1f2a0b3ff2bcf97269d6508313f453333be19dbda2d0020d58e56e7cab7a777745e2df61f41d32e5f50fe08644b7ef0c98c5d9615ced6e4b65cfd670a3c9a33c18fa33df6efa016a54173ef090430ca2ae7f221832635c0a9cbcf428bf061d272dee01f870b296c607182991dd49c54309704a7ad9cd016280a80394548002aab96d87b237d4bc667e9e341e85d1f13f2c86cd021bfc8b1ea746b6938a19379c2f5ded66dd3a41b59f36cb755ca3daf3fab35beacb388f3dae52a6e53b601f5923c0d804d97cf6546617c8c5a7cdaf1a855bb3763ffa4ec6991ee8ee122ac42d8f5842d41181680be48aaca38e13cd634a9aab8ac9838ddae20fce3bea45f2ad6d0ca1ac276677fa648ce53e27e0ae47d8b1d9137ac2096c4d8cefb6236b57cba6563eab32a1c9ae210f69917404d9fe5e0dd75db84dee82db6a37d76ba8a063296cdc88daf1fcda5bccb10d8f20e421e9519f661198858bb229a7efa831fadbbd24ad5ddf70f13532755fdbfdedcd8e9646fd790f14d56eb921c7c1ff14c4b4bf0368bd5de184439023fb44539ec5f6e74d353b19b181675f708250e0b37b75296a1e0108aed48e82883697439ec5bb89eb95bc3da0f8bacb1b7e50166c36ebc880dac2640a501d8455f407d49a3c80c5ab444c88c3b6785b7e9c494d74cbfb5956c6ff5e7d20bf827f00d36f9404b10b0b0e044f2c018a8480242974d7178d3f375d30fbb1e13aef64cd12009759e549b8d1c8c7784fc4e6794b28808ce71245a85a988c2f559456172cdd2395bf9305e6486ff05805ad3f8996af9d3549fec817b6d4348f4516f30b56c7b3ffbaf67321a206ac8c6a5dc8fb06276c0e4cb4b21f3551c1fd850d3e4fd6d8dbaa262fba3365efafc40dfecb8c3cf2ff9beab4d016a950f1773aeca872d319e86ebbea9306b94e2f17f1b0eff9949bc6018f4ebbe80fd1777bd990547b021f0ed4dd9788b19b506b917d26ca49cb51753a65eac0d4cd153ae845224f26be969b9ca301d9c5962197f94c89d3a0358cb92c8d37cdf156063e88d0256be15a4801443e93bd9884cfdd8ffb014bb17c966475efcc794d265a4c636479df3ece86dbcd0c48fec39b1b64bc33e986c5c28cd4aa095d3dcdd40634975b1bc3025cbc912513ec6081c59618a687c41711e320bcf1d8e4aaf06c409a5c0014ed667756eea08cde1fd1950cc35ee56f380ef93123bc001decfea09f790a7fc75a22fcd869c35af97a53814bb2205acee491db3d24a4393a90270984bc2a7841c861f59544e470049bed3c3b897351b64596695d2d78360ef4c476e8d339a50fcf14ada9f92f07a47248899933d23caea1d561a7e2487fdbd5aa928f9964e64869b0b9d49106e4acce99bff9def2e72fad43f726a4da3c3468d1daa6895ef5da1b18d50d9a6b5c9ab21305a24b93f591701ad59aa7a1a0073d80248820ecc5eaa0c33bcd7e130f863523a412a1f5c486a7d08c9683c6812e33e57627993e137a38282979fae26e494f497ed1497a9249f3e712f4e61de574cd63a39d723cd22141caaf1cd8a2efa9b9c683b927022ac1ddae55364c19aebd8633123ac048971ee22126bcde534b0385eb6450ad4a435178a9c2cdaa73b4d59a93eef51e1e94a22eeba427ff65abe8afdeb5f8420b5b3b7cda1cb1d822bc9c3f16e316a5bd6996f7a79cd71581896898290de3dadf0f1db3fbc2673e1a3c723701e7490dac20a868a03b5e1ccb971a5c0936c694966554077935605715c6e56c542f8159eb58f5b80cf8d373a6cf269547e81bf0f5b1759a02e39739cd63fd63370a3935287a62c8941f315d3b8ed54a748ea4336d0679c60d069c5d43fc3a48921e9da217ca5ba924b37133b5a233d0617d5f15aa24b0a7289b2debef5c24b177cdbb4fdc04345ee0ca8f72103daaf2319a93213c807721cad0f63ff8d8d802b7afc7e371e99bdfc32c7bf5f2bec6d071d1848f12cbf0e143104061f292e4036706cdc9b841a3004e0d8e7cb8ddedc048d70f4bda516c5730493214deae334192228e07bcaaf997c5cb0c623ab3b776d95c96e8b63eb1f411c06aa3c2ca7da5515d734eb0adf3b22fa3831ee06b42ff00c528f0fe916944427848eba5159904fc552d8d1a5ae6ce18737738a52e65e2734e7dcdd7f0ccc3ccfedd79e90d5567f0c549b6b5a6cf10b805f4f4fb9c8b16b0b3c07aba954bdad5b313c867b7872f6856dfec44e131b9f26f7a8fdbcc3dde5484392ab739682a0406aa85cac81067f86b4bf12d76543c72a05076de9369752d9957bc79b16705580618fb73f89165e9182b5f3a5038ae21bbd5d5f59a68f76122f5b867fb6ebc494a6b478451101e220b8fdcc74e6e9e02d56436de39bdc063ed31b6ce9e86d587526af64642e7550e5c4e19e74e046478447d04f98bb97c569d237a811a3d5cc114b5ba58f130a517cf0468e7319f4683aec6341f1ee7902a056e1aa09d93c3a9c4cdc91ed43247dc8d3fc981fe2a5a2ee63288e5a5d06c668e7e1a2137160c80bdec3c0136dc7bd544cd8f58fab690de47fa3984d35b0fc5fd9d1a6828cc654d826f27d14cfc80664fe64e548c84e6b88bfed188a571044306c777a201795950a3d008d35ac6593808ece712136ca36b64e0ceebee5a7edad0745d813e47cf009a14975c61e2930a99ccc5db291c856999c1a4f39b157bad4c4cb3c307ac06ad5981d58f5d4c154118174b0fc5c4277bf4e5e51e72ed5d18858e85a84cadced2f28abfcaea393bceaf6ffe98e263d23838b7e38d24b4801708c193c2fb678dfd76eeced2a677f96d6cac9a321a4fde7d1408f85bb886a770d6e67b64af2df6bd90eeacb753aba4e08d704dc201f5992ac39e87cf5288aff78ba74f37e1c0e411d19edc1bcd88ab08abf5135fbd7372756e3cc6da2acf77fab9a88dc95128670546979c0491654f1cbe1549e11b0408f7518ffc43bc1341832cb26852f417ead92c4461b9b2023b13ea300300d11d68780508be62fc1b494e8e41492a7197b29d8083c5b73bcb86b64dfd13c740c1bc712ff5b974654b51b25d282db46a73294601fc4a793d8799b8eb71de4c89f2848755c7574cc36d1508fc1f2c5a8ad339ace8884cc4c2065b05934e8cac4d58ac2ed7650216a133ff1fc64143abc1dea4bafeec4da2adcb6900f9f1276e01037983d82e211bfeb6f77a8fc261fa0ff41e58e5d721e2ffd3565e41c56a280695f7e0eb3b70bb578c5ce660792de4cc934e26867a2e66dab7878d657caec72e7ed9022b152905b0299976a4a9eac5e32ad2aec3d26f65d42b5b484c4133705005e6caeffed40032f1d62501f47c808ceb113fff3bd1ef0be10f91ae1c31305ae388cc382100a45355afeefc094d4e7df4e06d11fafc1be3881a296bc0fb417e441facb1f7d42bd36d4c4b5720b9f7c8cba34f8b2adf8381189c634ee6bdaa0d57b0239aec49e483209da58ad4ede4360b859e9851ad1366a699ec0fbff584e9bf1b99c37064abc47dc05628b78356f4043ba0ae0f8a390f556d9d41ece2f1c89e0fa4571a151a03c82ba4c99b062c666f96dac5d391eb5a67c0ebb5f9dc497b1c5fd7d78f819ce8a02a9c1ca9f99446a08e75220e64cf3206fe661048fabe3aaace0f70d1c7e7e0d49a6971af9eec2355de5e176f1fb2121e53840f5647c1cf6c03c8661b1a69d0c7eec814e5af3a5aba08b3082784f4ac00a9d709c0272def300510524f6cb1e3270974fdbc7670cb80c3f3a04a8440d7e52b4a0c0aaec9a4df08f2a1d8839e1e6ccc3c9ced52c1a12e019797d10893e838584972693700a715a38d41c89bb09a38fa9656056a41544f9f5f929186858de0f0eefac5bc87858f88956d5c3ac4afc1798b4650f3135601016061f05692c4554d13c5df5b6297fd367453e4e46e3c314c586a3a1765c3861edbc739c5b9f3ca373aeffa701fee2a1ea3ade2c562065beda1cd4909380dec07fcdebe2a737937b2170ffd3a336d9037901ccdcfef66a99ca0e482691f465150d76ca088f050810c6207fd54d1519a99684bc5883f6d0ce936ffb2209d68b9ee30239e947fe599bb1359e4a1b8c83390007435359ab2dda28daa7dbc44c34879c52b46551ffa4dad6971aff9d38e44e3252221a7fe8b28a9f11a3bff5f2839901792fc8e910a13bab8c50e626a4e762f2deca401ae42a25a247a00d3131110e17d67254ced9d883fc2823a174a936ec97aa8a651a7e6d43cfbc8b297efe427ce00a02576096ce55e3aa3482d6189b7a68498cdf0ecde458b4695ae338803dc34b51df991796f5b08e61fa30c4b6c08e467b83e396cebee17cc3b4a94a876080ccb04c4a7bd03b580bddafc3260417d3551f1e09eefb4c9d91ceeed29c6778c9f04b2bfd03ead7117d4b89eab5f8693c174b0eacffd1f409e6db2ccc21363794efdbe2092ef7700881da5e0e740ddb4deff4ce482db9721ae2b59ad41bdcc3c0bb2423271d30a018bfac6f0b759dcbd90b5e8cd1088cd88b56eb3eb2e4df6f173eb55fef16511ced6b2d881f9fb4c8cb57f05048e0c94a34829358058b74aaf91bd75eb3395950f4c38916eb5fd9990c1ca8b69f185e230672337fb931b5c76e685aa258228d569df5edd0f48ec9e7de5233e16d556fd6bdc86db208f699a2613e2c7ccc6a3ec3397aeb56dbd84c37f14e0b624529823ab23a1d3fffb465449776a40ec8b127c5fa653a427ebb9d9a679803bb7ee55193fbab1667124cfb98a419cff982f5796f632cf49f17bd9e2c39ab411c0a1a0da762dc5b5841e55d295314b765bdbc0ac5681db2290bbf60fea90aeec60b3e84f14d4baee1c5d2c08e3dc7f2176e562a00f069cd1c046b38b2006d22fc0a9303c38aec448084a8be110a58c46dacf80f4515232b1ed95043a80316c892bab4b67c673edf035511857f4911bbd9f613aead033adbdff4a9b7a5e7f651750901b552f464f3ee1acd537554c4596896d10811d5e7062c1ff4f022ca9d60fca89317d553c476a156bbad049a6c1c167250a9adb1848f448dda35bb6c2d15f562add25bd43ce66baca2b47aee4c50d0cac4e72f0091217f14403a186f46b3c9adb19eb70aebee59f1c3ed5cb4aececd791073dcc349c1432de345cd972f3cc4645a6bed1cbf4845b2f90f2eb4de65065d5148f90aef3a83111c791e8dc88f4019e9e47788a07442b214b796692de2bf8a4b4f591697a4e467871d69d117ef92f54dbc3950bdc46e38d1cb9a7cd44efc73f332163d4f5111afd145be0ff94b24d8638416266a69b379d82cf1f4e494a7ecc78bb0fe7f3bd9a3238a8d622b824ad6cf2e293dbf540e5db68c9e92c15eee64c937848323106f69321376d10896207bed99ca890925ab29427305d4bcf60e01ca275c596d7b2da7b1eb96d46680c3908b0c2ca2d2bfb404ad7e49cfde229825ccb85ef3f31f1ba557106d9a6cdd8e408c91336a11d81edf0b9dfd27fd499a4c812b93b9f3c0e1c54de712f680f390af85f75dec26a95160e6b215bafc82ac03d84375465353342d6c3a42c1a59c052d9c44408ce5bc0247933da2a13669f6a430430a74facacbc7780c537ee22dbf60e5b15695af186c268e8e4c14388cada20d0b36921861076f3a422bc49bc6c5964e48abc6d88a7943c6ecffec025a47071c12354160ac2e9d2944eec4c9fd1438c3986c4c3d9de56f2cba3ef6758e19245317e2451ddf3280b3a57763213788d32a143504c3945e086e57446f1e29b79dc5f84ce2f372f13d5fb56ef61301bd71955acf0ef990c9340497a8ef766cf9c603631114e6aff190bf7b45bbb412375244987d6d87940a5c92f2eb4c2463c7c03f116d662fd67458adf6be5616e35e2914451759badb782be029bb8b115204ec8fe697685226df554a784c251b46b5d3239fed98b3d1fdb89729c879fa79c6b26e972b01579722b5b8c3e78f9f73e216a0f755f309bd13b2c47ab350dc76ce3e0513678cc294ef4dff8098aaaa953cfa31baff244dd8e593b3f682d015cb670cc3b271bf76fce91730e1afed1971c3b71d2f87283761249032b413e3e2eecc58c1fb7f4373a32fc91d977e2d012974378a08582ce5591879b36477c6336b64a7cabb5514b10d4e4d75f8460c98602a1e620402b7e972877d529bf6a0995f47df1f0d9211862ebb660e530b72ae839b9fd91526316cea42455366702308afed897b550eb7ae0205a955bf34f49277ae1558a498365ecf91246c39dc2ec4d708f6b28a2697cf92ef540a10541b41bb7ac3db5754f2aecb5100dedda5afa07e324a9ffd1afa45fe47c0b1b9626c18fa3d5fa5937058bdf050178e437a6a14ec1ef1e50a280cc5be08b543d2c2f0f8e09b90bb09620a02f6d04cba6b72511aabb4a5a46707690a68a638369cc694f6e6057351d699d05b3383030a1a6f5800f2a2e350f2aff16bd1c5105dc0592f8bc05cfa74454e420138944a11a361e732e7bc21e77f53699dc220b6d8307ab3eda03811016fe0e9a60fc89806a25e7908e76f515db2264e02b3bceb66ccda5516008be1d2e3619baeb3fd5bd3842f7f57d395783ca596225494f7001ec657807a35eb4307333f8a749fd039cb10183ec7eacdc85a4c344207efdae6dfe751c88e09019f34eeff64b9bd915705bd9f72033497fc72c653d9e4060eed1d8d05c663599e73bb33370268024de7ff0525be4f8e4e5507d92fc49d4abe55d94a9672f9c786d3f453e5471602aa8b64a372122dbba6a03d191e82435ce282c2ba7fafd667eb1fa48b6e81d9bdc68a7598f695333ff4034255e60b69db19f5dfdd14c5b0cefa53ad2473381f842ac7826f3ffbfc246dee341b522a3507009890fab5622e1ca15fbb59761ecdf2dce5dc4e2ef545ca6f01d8182252afca49cf4339a6015db5a3cf3175d8f7ca17dece9167cfc4911d437f88487ae65ad73961ff22b368fcabce6da42a9f6602307d78cd762bab37631bf5f376456ed3650eddc9f602046e7b495a5a2489074648ae319d32035f1b97d00dbd367063ebd1755f86fd6dcb4d15d521e5cacd7a34e11f6c0e5af7188f00661419ebde0d0dbeef5dde783c4088792c0521473f97c30a1b3fb39389ae6b3da6bee8b95514345683b1087f4d5b8732a99983a4f160278ee42df667644d7accc34eab8aa5632892c44a7561669a93ebf8b5d12756a0f2d8f57ff2c8e3a3b4dc0710f47b18589d25cba21dcf319ef8b690b27a5a6a0c34da9e07e82d5e2dbdc8226c0f2be4339eebd49bdc48fd9e513f68f75b6c519ddca57271b2259803a292dbcb694c2f572b32e7d402ae016494d50d17ca7423bea69e633d452f505ac67ae708eebef4b8c44b8b381fd14714adc795a9aff0ecff18e9d0da790821efc9a46525ac5f6192240edf0b3ed72ab519fddab9cb2b933b68c2352cb724011ad727bc02efc0f35c0bbf1539753c09bf3fa419ac73452f41dec517a0de4482df1e35093f009052ba119c23a20b8ea3aa4b3a33e32fef773a9344a3f2f60ddcc09650cca2acb30ca16f2c3efba44e44475eb4c62ec0154844dee0f33c51bc3a941022631bec45b9a6852f0dae9affdd50287a1195cbd6655739f38e02489660c85284b14acbb6e7b34f38f614dd6b77e51cc6a90f3886cb3de993b2c49e770403dfb5fda42b8b859d7fc45b45bf729f4d192d1dfc3e9b199d05b1ea6c68fb6bb5866098ab385eaa9352bc0164dd6523144141a5e9dced3099c7ddfa21697a124dfd95e95215f37d6be46d1edc3804ef4520fd938c66d2cb764ff7c3c592e37850b920c1a54a827102a6a2e44a266f111fadb64ee3f7b945995012469bfa46e407b49ed967e52178aa59d7d55577c4f4035d335806235d76ea254014e98aaf0f45d33d4ef34598a7a81393926b08fb0ad5a5ca725ab53db17d1a58a697cd00849a2906536f82ad324279e7f78b2c975fb461721771f410923536920b4324d3260189168f71edb21eb2a38b69d0f0a5ce8d48cd619e193cdf371fb3944014404422aa86356d4dd174c40bd882b4bee7483fb9b17f16185a4138859f0622ac3b9bc9dbf24bf8a444cc42593a1e3b3ef070eaa19896abe6709a15323901b2387410f89ade868ee8b9ba2fcb4bbb33bd041fd9d6928d351d2c2c9db5063bda55abd90613a995a1a9239c33796bb49444419d02950a502c1071a098449a9dbbb14b2495346c579e52e7ceae0ee380f40a052fdb3e63bc639663b3ebb1d3404f1b0aaf030e01c9c4fd77dc14b4eae05439d93425fe0c1154f0ce23d705c044ecab539a528e9378760b9a229250733c39bbf4055dc2f94844b88537c844af43be6e1d776d30ba614aebb4872cc061ad3f0ad5bc8a6a2acb3f88fe45de8e185d76d60adcd16488bb620b8af3e1502e3178c0bd74dccbe26a452a047b3d155bb6a330d985a8d5e5ee6d102e8794ce53963229bed42a6760c2b94a47ef7088157a6a25085ee44f91914c0c222706cb64926435c30d59fbe5d84871f74f44af3a9ecbcd738d4e950113f0aa9b1506723e549abf302151a64413d412154d05c6b14deff2fc36a9fcbc899fa0edf90b0ac246fca86000f3964bbb05c2b5e46ae0e4a0951d4a0c7cef5180aedfce919be5dd877a7e65c096531130c85bbfc273a22bf421985ba2a7cb4e72f44abe893ec1d3de957726c533132160ad420bc272770c4252b1a41afc9c339feda3a1f6cc271d8dc71a3a345f10184b31ffa4bfd88ff1748110855adb60da9af7fde5c2e2e3762cc0e2ce1aa93e1778d07af34e26b72c8f0d8c457ee79bfa165fa58532823c5304b0122e6b06158255a74bedb7493c3f93655c9cf6d67ce4178cf91416ec806bbcbddef26aee2c2d54af1d21e43096a8df7c77b6dc0543e7eb1ca9d9ef330725a50634e94d4006faf4c01abd6279e876e6c58cddf5ee1099f6d8553f0dad4c746c59af0dc93aa6b73d3a9842b888001e214b42b365cacfdd51cf184a254cf2161cab19a45db39bf30085cb0054aa5d339a840b80c99ddc5012ebb9ddf4d54a0226b595d21d99b704b5a37b7acd3c322d2e9c982d28bb16ef72bfe92476fe9cfd15de2adfa72f796c2d289f231e8e1dc227709d6587dc0a8a447eeb812621622ff337776e2ce823e65fea6c7e33bf477dd14ddbb6fd77364b0190e61978dd6bbcbb92201e7260bf45b56064d38c535a050fc0774bfa5ec66195f7e8905e977363e03562619ca773798b3f66b62585bc378e2ab0041ead7616cc35b2add0969716cd3a5d1f785b3379ed6972f57c58a3cd27380cb5ec91da1e812f9d9b887cae3fec0068c9947ac2bb8be2d8e10cee6b9c8365d23492c8c856163c8486b4cc7b63cc1cd601b367afe4134eeac414716ba68a99b63f317d6f0365b0f2313e0dcf84221bcb81eccadbb22c810941e895b0cf429df1907a5405e7e0dfc5f254a6f155e8245ec81a78db63254d745ba1a37a5f410377749c8485837743ff4ae1c5eb921a7013a4222ae535e1736c2b49e05727c6f09f1cb60c751cae5c7d331e187950d93c7cd52dd63a69b1239ca1f84bdfb5f622927f8e127e1f7f4a907df4d09d90bedd401e6edec47a6ff1df269703fe22ff3465d0fd3c03877869f1402972a95d022f0de9ef094ae00d5a369c3a4f025c4e85172c126de60b38014225163002ca717a9a9bb6ad54054348b7716ed7ffbe028e83e34e7eb32bf2e7bf728bba6b2fa521f15d3b0035fe7ad9be6eba782586ba68c8b66bb4e571ffcf1a346e7164a881aa02faa28f0f65e890067626760656d039fa048213dc2d64e87f24e1aba778332bd3da3d8b28f5e5b4e9d0a7a36dd7eca0c1f8e1ddcfd101974a94bda6612c3b50d4fae09b0973410eb7f271488f062b3f1d1b2d79690fc5b2e41a0a20362298d04294a54358659e9f1b6e3bf6ade29370755018c112f4579b5db2b2bbeab8b6ba2702d7a8226325a690668e3f80710fbbfad5f0f950db84776206752c53b8a08d5f0bd06606b7ebeebf99896a46c6014dbfec0f51ae08417451e2d9fa3b716ac725a06bb812e8d48890b0d1dc72ad156c93f98993924bc4cbb67d6d5ef9f2b6a8897d17c792d714e8c54bc667c97d15b4730212ea5c740124bed4ef2955310ab3dc79fb8b998b61e552f5060c78aeff205920bb6705b1449b4113567c919fd3251a23d548b7015f33d98bd0b8f319aae401c1ae6e2fbe0b84aa7658822d7bf0ae584b859e8af6315769ae6763dbcbc17bba6d146858dc730914d898ce8d67823195b613a75c2ed23236a7b721fa0643202dbea98962ea55dcf4b2d87b01044417e763a28cd3494b9841719c84942e4bd9d38840ab889a847552fe0c80fae9fb3c0b20e3e02fe2c47e29fcf91cea410564b83cffe114e291f457a6db56d6ed38178547535067b55872d11e86e1f5dd9b9104f60f4eaa8a2c3c24d7a2f4ee0925833f2b60ded4d27a5c7da7c6c700e077fee4057782b0a5ed232e280ed1de0994fab5e6d30da26d6ea4bac7373ef8f7e5821497830eb6df9e2c139149dd6bdc141e10e0cd8522f137a93be7e5148b57046d3a109d423d89345818115816a8d4598d7fea676c1e54770c2bef4eba90c6630fff49615655b8e940053c56e784d3bbabe84b2c1f0a276b334d66e54d00730c89df7feaef5b22d218c826aecc4a83389896a90b36f0bdfe857bcd62fc7f4b8b6075e529610d099f567f4f57a02ec4fe5f379c11d375c8a01cffd22b7b5cfbde56e5e792c5a5f1bc0f3940c238d3fce2196dae987a32a7289df7c040bfcf5fb43d6d6f57ab8fee56cb79103260918d9b3a1f9e8fff829a9a9b6fdf344a07f42a78173a056501d864d56f18c9d6e6a33cb891814020989aaea7c69c6137f322d03362f0659f290e6b87002916b0a49057ab9be5b804d727c361810e205482814b02126c429d4c4d33bc96777b5d5b8750a0be95c6c382185bd3d85f93478f93f88e329338a7e905a454050a6de2ce938183e3f0b7ec4ed84a8265c0a8a6a6aefb733a94e189f4990eaec7ecd58ce9391bc271433fcb965f86230559f6a0d6dc81ccf9242294d7a08f8b7fd0be7e849ce1c511d723cb04bcd031275ada44bd3a72c8b53322f3da7c37c520aaf7f674270b82738afaed35880edaf041983a1f1cbb037137421ae23edca05ec338f58249f8fddcacb463aa0cd41fd51375c2bf6a9bea00a6fd5db4f7996e1187095a4a85095cb738d9fd8934c9b9654880440a12c4e62db8bc8eaa2eca9741d8153c69133d29604ba14cb36954549f77cd4a549186c59d31457553e3ba0cad34ce27061353fa3c291decbd8ddf20adc896023efc1194435d71b4c32aec60501c4cd6a2da8200fe1d0bfd27b10a41d3ea1ba3d870b99da6be2c0d01f9a1603aeaac205d553060b0bbd9f75ff36ab655fd969bf7b6442e972886b0e37d627f21375bf3815e32a0e7f5e9e5f7b4706416062e599ceaa39f10ac4dba568784fae1f667c0bbdede6b04f900184dbe28408916a8665b5061a3e3eab9c6ce537d1ff663d98577efc4c6cbe9a5b873d829a7b595509c3bfadae8898b455b0539b32f559a1024af947df6bbe4c81b0e607a20c128803c1ba1e68876bce43b4e719cce03c230c093fca76a467dbb6f4635a21f516c086a912608770024fff4b609f1acb290a9b410b03fe224cba54483739688b0e0f9a76e70e0cf93f7bcd5fdbc1e323a534d32f841113e9684997a0f0c167cb6e618826868bc79bc71803a15f82dbf7b74a35548dbfc52160de152c32ee414453a191a1d27b8939ba2e53a86a54921b5a48cbe1e4b3f5feb721b3b0c3a6bb134c2cdc8069e0c29fe27296c7926b2a0c2690f6051539d068e905b12e78c7c85e979c738d9f2021d11ed9e514682431d82ae539ffd49d51cd3bd79facb912c0d54db2f1a6f5fe667ad883886badf78a0a24496fe4bdcc148954b2a7e9bdda188411d097e8d2a1a0a8a91d69b8afdd77176b1df68c654a5016f4f917132b13caf5764c5b96c9132e091ed31a72a5791c12a7d8f1b6bb13471ff296ef48390410e5fc06d5ba4f9ab11cacb5e32a3698f3e469df688b0d85a86291907f1a267b2890e090292b5bc6293bead88858a8ed8db2a8ba23e39fdd68829caeae10996f7674ebf8e2a1c6e3681954bf3d70da0b99db151cc4e7e37512daebc904f04c666fbd5935e03ee654c6c283fc7d0bf1702366f3f26705a496eb091f003c7834e012d24b0e5998982f9088e7d493416624259970ca7ebb1a03779e8d17d049ecd57318035f4495c62c34ce5b04d68cef2b795f470f34b13d7c0c60f8694d4806414a2b724934610d088916e99454c778acdced0f698c7d55d7dbed09438f076494af9addbd95827f8fd3f1e40c047509a629","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
