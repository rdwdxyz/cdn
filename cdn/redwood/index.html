<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8e43e2fc19f450b35bbe740197b4704263a5f491130a60bccef8bc2afb3c344b41cf163227605bda3b3fa07e3c2d9f029220403a3b91fdf67d12b1e9c81078c7b3cf43e150cf6b81074ec0569647d015419f9fa4f1e457473ec5de6349b659b4ffb03d9d031651e00a815f7ae899d796196bbcc8259e795d98a6f9b8ea7ab285f03cf47f1e2682229181746ce363ba4a6e054f2f0eb5b6260fab2802724a7bd42a17edcc4cefd8fc060a6f539dca73c55ac460b8aa20889d74ba061a26ee5773bdb5eb27c6b668964afc0e3551a5674059c973c5e7bb3407bb201b645113246f5727730bc784c07de6c82f2b08fcd8d8a193f4c78bf4ff7e5c2b496bc5c8e5f476b0cd6dcf17241073f0ccffa0ce642c5474b9f687dd38b9856544294bb1e0c7e0c05bf179c85af3b0b6a333e75e14790fd7e33fbb0a985bf09cb98743525495502b3f8fc05758c82a30f026fbea7e4aa9c04327ad460c260c2fc852e43822a9b9961ccf406b3a9a9fe0206fb4b4eecffd8ba51b58175898d2776e3f68395f5dc1fbc2b8275c1f2cf77bbec516ed94b3cf791525fb79e36fd99554bf54e87008d074b860b24164e784dd4cc1957975af5e559b6a6a287e4060029483919593299eec072d3607c5c250d0cfaa2d142081dc293fe9d6e23981ef109fb4f8b45c84c4abb8ad3ac84ba84490bd6bedcc40a26dccc13492408d088fb8f59e35d69b15c3b190e8fc9e99ca500491723e00ab07f44b6536a20bf97d12f7ab3751c9c8e6241deb022bf1f8edcc5b2fe9202b2f80a6ff8a18a3672a4aaf4fe772ddede359c008f5ed27f7a7ea630fed80171238c241524080e99b45bfa6a7b22a493a531d080986b71a255cbb83d47bc87700f1280186f29c7f7ea20492ac00a2cb35836b1f824b9c4e362e658a37a6e2837d1602fe7d29f5ace53d606ce9fadeede657472bb817c5f4e9e146fec682064183e3cd80941fe3eb01581b9a4ec06a6fdb1146d16c68723886724ccec4cd6a2efb19b310111d8ebbe7396c96edfdd05b52b90ad46241be8010f78fc805e01872c69236dbc98dba53114fa76e0d473cd1a7a9ad1b21296ad0f07cfe6e7cc1ed8fa256e231dab74a3b8ff0c5e5e20b98de8867482d37dabf366040ba7cb621ca8ead282ca37a72371ed3eb5868b439dc618c6312d25b68f930de8c7eac3c1aba60e56ec1a27ba6837ab11e148e7a3a4dd6f4cfd9898e26ca924db47666b3b7fcbf49a0eeec80260fa06a2fe37df5be5c474832a31952192e1155d100d0bf90d6cfe466a9d3fe70609f2d89efa7ff50d834a8342260a96cd0246c19324fe837e91fbbf591ee8797b6b6d9a35f24703eb335067f78221c0e4fa09d6b58d955de638c1d5259b4e9f62bc52ab3d6e2103192eb047eade2a87d830caacfb81fc732ae5db412f24350f8ae528242a5c7f19e717d1b9cf1a928bdb0be28a571a40dafcb4e43372ed8c09565becfc8551a6a6e5c744c23e941363ce17d8838c5637ac1f0ecf7586603f0f95f1da25ee522cd3ac036a6084fa34e060e70097241cd9b2a4ec26a7d4c6e9b5a4b0a2d728608bc75f7361acf10f35dcd059cf9e306086d7e303fdb0c80c4b60eedb9f2a122f03c7c6f5215e1c8502631d41db51f93dd14145720c196e872321ed022c58bd92281cf19fea0bf9e85acb644b42594bb50bd05e25430202553c9019de18536740754b7d5f76a026577c84c201a817f08047328555510abaf5482b74fca5fd782e824ec5fa794467693c31bda7043d72781d786db0ac13be9f7ecc798b480e505c4ad72420a0bcedefd6b5b259e003550f896b9e2c9fcd3cbad87960b146ef0c4847f76b143c776aa78f253c400882860562a09aa47d90f5596bf063826708625f3d77999ce46b77c4d783ac07f31a7571323d6ef29bfede2919e6ac31cd14f8e27cfceb3205602666e28b420e0d3ab1e8455174cbb2bddf6bc9b368f6d529ce9aefd031be513b7c04dd71d65583e0a0b67d216e7a30fe54cc737da2b6ac9095cd31b409cbd96b90d5c1ec90e4937c66c24999dd40107908df84cf8cc2e46b3b4831cca6aa6e15d785dcd1d238f23a5aa3d5fced19d657e86c281c01c440aba6670cecc20900da05c667f2dbc070fefb1a2d950df80fa65bd4f194b550be50c1aa56eb0094e4905c29649940df2f14af8656d59b9effcd10936b6b1edd1d6ba229d699bb103c903bb3863d8aa8e8ebf4538414369d5d4ccc5a62026989e0969d0ff47efa1a58b27e5e00f3891efc39721aa762137bd00205efd32c928855b94ade2f47c12a4cd069097386aebac957ef776fc25774c546c76bf3c52fa96763d10187af24d6c4ad1d420cbaaa683799d9e0c319138a996afc914a02e9e68ddf5c8bf5d2040564899f28ff1f8fe6011459ba8b3e9754fd51c4ff0300b7e0bf126fb337e5450ceb25ac6ff04806189b4e62bb9ecc108886c7e7f7512c9b5ea99b6e84c2000f8b564b747c8a8138abea43905dbe674e2aa64d712a8d505ab1a2cb746a65b6b07cee5938158e9c87ce1bbd43cd276179cc722d938320f1d25ccbf7918167e777fa0af8d2b7253c0046e05e62805b0440f460765bfdfe8db9d4a5a5403a6ccbaa45101a156a8b3423fc062e63bca5a229b6376207a18593c6438b4346d4790bfe6363ed31db16fd56eeaa010496e4aab40cabf7442c0b682e2be2f2bf4413d39e74d29d3f11d220dec11a4bad9d107afbccaf81345b356c8de01121001015712e60ba26b0ce648157f46e9fb0745570b84f90e15f641cd0f5e472ae08cbe02654df6f7a29ff7b8ad657484d3458d083db3070b0cfe8392e1da84e67745e62371747c05b2666ada31e59d5e943966a631cb18b6c94ecfc39d512e645ca791db3d9b0941bf2a05b33e5207a96da5e87285472f954b14d8cf658bc4430ae4734f117c0de66d957e20e8a01782e7b4caa9ea35bab7e541122d20cb8f70738ea8130ec12be369d9c55bde33ed8219d5ff84019b53a0255c52ae9b6354522929ccddd7ea8e8c9e55ce83ab653a079e2f4e55a791b83f180da7858fa6282978e244e0e3931bd756c34e149c101d29a3ed38eae7b228df8550cb824b9013697ee1d33ebd6e44448f81522b738f845313ae19664fd4414023fd9b2c20947be1d9b6a423e65fd641cb241a70344394823474a29eb2f2b5a2e29ecfddbc5009e66d6d02d9318f4ff76e2fa3eed06b9a10ece76d9bf91f93642ad73906f675fc22329e68dea1aa25ed1a1ce781c956fc1df59afad6c28a53b96310d71a26f60bcecc9f7a5f896013b01537524e7c7810c76253fd7354b3b8337d4eda0d3bd7d2f08a6a4dd67c3c88877b48a7fb05bccf797b281c40e7631f7555f525a12e5aa0eaeeebaad0b3cd1c3237ae9d9fab2cb47da3ca4563e9b8152c2a6a85fb60feb9de3601c6b699e277155f2147bff023c022bbbd8e0921bc959a9bf2c6e9f81056c8c7b5b39020d308a448a21cbb69f0603e532e29204ffc8a808b467033d07d8159681844e189663f099ec8459200a75653daf809c347dfb8d59787314eda5f060cf26167497da5a32acef4afefcee0462ad25b8f080c5d7686d7e4dc9bac7e748d7826dcd986e04f0307a0df46271953321a2487243625bcf9c0b2c8224f30f07e4af24b30b6cea426d5897f6001f897c60a878553cc00bc4379d9d14d8826d43a7d92f034e56748afdacdf07f82a8816f0b4f0873b4edc2d60ac710896652338f196c5fbb5c2d8b97f7a7b71461a91ca62ed7f2cd54f5b92747303520ab24fbad591b9ff99a0b87682a3addfab18707e39ca11baecbd5dd053f5db2a16d664e25dbd4dc2a8985c848867c2f218757d93124a65debdd00b7ab0af35030fc6028d1ca75d7061f19855915b4964a1de69c7a2ae201e6fb91ddd7c27745efbc33bf097db433a863d48170f358fb87bf14e50c1aa0ce273b8f7fb3295c518dc5f709572c456596866da4d610bb47ce8d137596e7a5c0a649b83991f73ccf792fa36af9d0d59417ee452d88285846d6091fc0b9aca3e733c734bf40a0f934a83368a3ce77f65dbfa1959d7c37fbd59723cca5452de335be8007defbea81d11100b0ec828bd2abfb397cde258eb3bf6b9da913f5159534a3b4818ea036b743e00b30f0182fb1fae522ad5ee43b96e5ad25f1ec7aa277d8656809d45685195a7f891e53b9cf91e809b7762fa38cc7aa47bca9782a2648a27eadf55116ce8e20c85dedd23a5b9cb1fb50a63e0a430704c8e5ff130cf581ec3d5b50fa70438e719e8f2071aa639ab61e5f6afa9bc8f0d8ad9c3a7716b333faa24315032706f07d0d520b60035358ae0899eeb29ba5b0b268ae7f05bb5306bdb6682f2ecff014fb3fd695113a2a3c40bfc69a01c1db87261e5e3822a9cbd45e9b9393ed0b1fba4a945d2ec63850d597b7979902f95ca68b3f5020144f6eb9fb44b4c32ec24bf673b3eacc971d0dabb3d0f5340f7291608da5319209e31f0f833ee756114b6a49fde6abebace35fb733bbd73fc50c2470a3e75b025e91ba5d3e2ba603a1313486bacbf95d5350e0f95d6d574779638189643ca6eb2b4699a674d6cd2b7df9e25583e11e30e16f1f991b392eb1dce7b56b26dcd8198b46cb749fa5ffc10041b4820954202825321f4a494a935f682a4f071f9520ac27bbda65f4f46002aa168a6404fb7853908aa885c0c93d2758379101a562d3c86fcf8d25e6dd6762ffbaebffb60a1731c51c29fb3707aa72142ae175964d0817a25954b6570a4abf12a730ab64d42021da9f73d248fc3c6789349ff27c8f1caff024cec40da802766a193ec8dda5a6d49482bbdd3bda231baca9f67ba056d1bc936b47611052d3f11622b5862ff5446f2a955db9903f67cf99fc70ff0a1c97b0cc7cff653788de39073f1eebee21e6f0218dec7a813ba62f4c8a5e62949a9cb49f748f3508120d5eb8de309b63fa44a6bda94d477f794e0de7f0abcfbfe2bce337030aa7bce6e4730ddd9d6947f1f400fbd3cbff31944ba2edb600ade0a9f0b2fde503e6cd9d3287e42468b9eaa11460bfef8ee2fd98e4a1171a1ce743fb6621b5bef727925d97f6c959a17b8914e7d7d69e1b488c2b3912ba71f5cc10dda92c4d545a1206b5e5275443b237edc979c012ea6e60c08957f94ed262bb0d03c7c83b09ab7e2cb96bd6d7ff0d85a88090776e358c393197370c8f8766417707e0b02536b0d83dd42d929220ef42672e2e109432a1c69a9eed13c1e7cbbadcc46f7426e5bbd70e8682785230f2ddfa46469205fbc1352db4b9044f3ae328e7528341dfc1a7225f7fc54fa531aad303e3e5f4d6afd0b0eeac9d9935b13a2764209e99294bca73177d8513f6f6e676d51953b304017a6b0f38fe9553d4cbee35627befb02e47c78cf566149ae7191d3d42896d44bd97a467b6541693d3b416cd7b4283f2a431532023c155f9d080137c86846a43dbd5e23236a64088df3301eb01354a842c7ab494de76f5c7d45405be3b6703981c8b0ebc11bbd365f8da36cb7eef5d6540855b75d1216ced55f46bdca07242322902717ce7fe4702cf775ee129d2f1f3f33556d1c428f337af199c311b978d4bdaba2dfa1f05f8189cc82e4b89b86be4ed0a8d1bb44e6b002d5d94cfd18b23e65670fb479ef901eb12fa55ec502e7b8a889b282dbbceb32e0762c788a835b8330a46a505271eb477f250840f5c95214b742ac12de8d73cf143d71856342969a71746a4ca782604122a5f615fe264541cf18a9ca68ceb1709b2be8080230790d44f87fb7c9e700d61021a5e0033a4f8c7ec8990156a580b0267d3009f18ee2732d6458a837a8d31031b512c3170df5be1537b976d6403262caccbf564533a79cc2047db075e877f9c0fd3f1052795aefcd877fa4066114b6e280837df17662aa77483c1c756b87e785057c424e2873401099b1692985c7b9c0761771307f9d984cbdad0c78c0a01f5c238b2a426ad3d46dde76a917fc3f3cd95bf7c48b47a328c6f5849c6afb4dc811d7c71fdf6ee012c76f53e9cac173896beba34de5221e11076d80148a5be1e37c3c5509b6e5fb6e21830760bdefab7d712a9c6478db46f816228814eca4a2890b58b42f82530057c4da1e4a26f23ae315d27ed8e594bdff3e58e1f924e5f9e35af24f3f57e87e946206d979fd06bbcee1e25faf155503d184301f361e0f8c700719a24bf69650596ce5a5c96674414a1bfd186ceba8044b6f6f747b4bb587c04e87dc22306775701c145e572ea3a91b6c3aef769075e0eb1e1c8445815936f0f9cfa1ddcceb7ae6d8d6c4f427950d3796cb8973035020f77cc90742551b425cfff78ae3298f1a24253fd61fdd7dc990449d9f44d31e7b9633886f7d7582fd321b25aa58ae0f2a3d7b19c3daa45f2a893887d6a23809f3d363c94eea62246e7f55e174aab00f32a4ab42f5f23e69cd955ed660275584831c3598adcd468da20bffa5fde1f513fcdb170a39ef36ed4e662047ad341e75814733c3378b974c49158e9498283b446776e5ae8904910f6bfdba904d8521f601c0e74b94b724e0c5739ee9c61694c7865c3375586e68be9073998e7768af5b1395ae494bb48caebd572ad35163c10195e206c4ffca5f5d662025ec66a7196f250d7f69c469170d39abbbf7a86b9f077d72c66172524bccec1e41572460992aabc6b37685997f80f7e97cc32dc371f8957df3e4de267ceaf6868f4589a769bb8eb8aed358cf26eca6fd2b8e19a8644fed9f02a1bf8ada7dd4c7261661e0866d17be760ed62564b596b902346d25200547ce20af340be7d8daeb101e1f73252eabdea67cb2319216863e60e966c5a568ed85a77f2f5a028c04ddda0f5b49c341219f9def2033fb287e53c5ca21607953039eb32b3e5548096207a0406f4fac2fa9e28da84d6b4208f107cfb4b128cd8474499b07a21e3b0b962d99bbcb6dd95691282015d362511ea47abfda29f0a2d513d3d910988d28362ebee97cce9484650fb52cceb6b6fd7f316082e2f7e166e76c0f7e35bcd583988faceaca6556fbdb8265544215d4c1586c35b8f419f092c0db9893cb1283904909c359dcb394534f89085f1721492af131fb6ba59b3e1f771aae0d9644e304619cae6a95e614495bd6977c258c8c357ccf16e0424b0c2571e85266a7a87a8498eff8f17c4f26f6cc1ac7de5c648ade227049783439240dc5d9e19cad155d28d2a81c000ff77b3bbbf36f14600631bae6640a255e154adc99c48224cdd9a78939eefb72cb591d6d6e22388789b39924045907c596da636611cd52d8a2aed1ffe5a68df9afa53074cd689ff9b5eaa3c89df9b9a353bc7cc657a0214e9a21680ff78b0ed40202f48436365d38f2f440f7728c88492faa29a2d7185c7ddad8a8c760b4b213490f49c9785d66968abb287d05f2026c4c2c1ada61968af4d75867d03ba344ece814fad2e224cbd7566ef6ae4062fa036bf5818658200d293703a52dd719e7e3fbebadccbaad0a56869f806a11e0e9e092f20116bdf4822de2a4eb0e9cdf1080cc4aafb5ae44c90c36b85432a5aa751bbff5726c4aaca1a6a0e57d2d5022956bc02dd50a1564db289997ec45595d6a2dff18c34e9aa459781aa7591cb1bb99f851a7a9dd81c29d167dbfc68bea17683b92dd8b7a14127daafd379e90b2e4b1ab6442903012132e027efabcc638adb8f1e0d390c5a98000e73937030b8b2678d25fe52271caeb9fa8b22e32254bb9a75cd05f0e4fd4baf536655a76cfefa392e0f8c18f17dd7a3712d8162731f770156b3e2f9b4b872ee6a1052620d9d0f049e2696e320f312121b0deb0036888a2f322f61a831fc441d7369650332196c5a7670f878e3f09e7211ced640f4c69cd853924c6241a3a6ee542319bea6ef51c0b1fd88f8343462b88ec2cb180a0003d4a35450ced20048f6b0c5f19d5da5cda9d2d37674f8ab7f0cf4aab84aca42c3080ccaa99b0afa03372e0655308f13a0913e2efcd1da252e0b1fbb5f608ae838303d34f1fb7914077e514c9ccdb5a4b6bcae521f0a2d0a8ca597547824e4b04a69ff1d82a58b79a92d5d3624bc0a3be7074366722dc33e7e2e3f0b51664081c6dc69a78f870038b416e35e6c38a05ac9990ae022ad03b1e1d94292c56d331ed0a916c82079eb1b359bda1a3745359becdb7b4fc8993ec69510280f3cc2061a2879b354dc8e1cf2fdd2d453c86e0297cbf3c2ed82cdd74ad52f7c1efa7c36ee16c8d0c88f699f31ecc6052f431681421d08fa37b14df838aea6f4c25b952989db99e24b75ab85398d8c48e37e0ae42fc8f9bdb42d109c705a7f4f143e9df1334b624be91959eccd97eaba18db19632e78aa71c71f0244e760bda4428c5a4ec5954d9302199e10006a1ae705181296626f75c453f8a39e26db8680a8ff737d929315ca3ee381937f7cfd43bd623e523b8473f51d67f04adba195215590ef014c509f96836132185748094a1c33393c0cf0c40b24fbd59095f0c118d8eed8d1fb1fc278d8d093acc601054863a983dca64588627310bc633aa813680709b0638ecbfdfbade055e603fe08e52f83779ecbb71425dafdb9a1770037a02d8c023f17b8364149485f3af12f93000a26979f3a9445ddf34274e42a83e6a44242a81f4af3a52c34f08a69e2ae4367470b76df1c119130f84adae03fff73d33365532d9afb2ffcb6562ccc8968aaede38d195220a66fdc6aafa0370ad6c34231e0118d54b1ddcd89f01c049bbeb1725666cc8b6a692de4260860b3a8cd5f462589823c6f8bdbe8bf665c51ae50f9333f2b85e1f2cea790e979377afac90c4af7100240bd0076aea000064e888e0bed201d7282d025263435bff2e28df11d8eeea51e3001818d75bd7025f2aaf136d428239e6f4960e642706be61a24388bcc78e09e82563ae2598f36934a9c4a4c4d74d14038cbe449e697bec9d479157097c0112220055d954260090aa3fe006b10eabb7e252ad170b9f05e578027ced1fe2ccd5ac54f0f5d008145ee913a5a3f1893623692668e58b26f2ff6b06e2c77ca431f8229600a99f214784ed20e380a8286d101dd6a052f96d950b8d723a04e3f1b0c83c40e613505dbd1a3dda9fb58e33dcc0ae1b77f63fa82969eaf1a964e4502d223ec929351153ba16fa47acf4a2caed57b9ca433f48f6f8d019dc96b864c412a86da978a2c3094d570427ee085ba35ceed3cfdb432b3cdbbc6c0f48f114f925b33fac5c995833cc9eb94115e39e8b78f3ab4696865a59a945d2f2c09f174bf9d80e079ad0d4f83043dbcf5cd83e58b40b5bc7c55aebb8a1b36b929129fa599c3aa2d0a82f274257730fd60511dba0fcc0da3a0895474c1008ceabdf779e93b3738993828790e942724236fb839a636b91c10215d9236a815112bedb3dca07d67c1d9298e546eafadf9d64c24b26d7fd275d180e8c5d87c5bc22800dddf72becec5415b558a122ca1344646fc00bc664a2b145fe545c30fc2ef9f29c3ff800184c9c47664c082467ac5cc59361a9ffec1b4bacb79d62812b73a11276ec23fe094a70ab757043b2cf5e6dfc4442696c90c84281d88a80b5b03e7135661be60ae044aa2ce6b02c3e3b77b03ad6ee1d2edbe01d492f5dc8eb7567160a618ec824898ef2ea86f29c097091c92a5f6dfa9b972441960b3645e6ac97140ee5091d20d4ca3aa42baef6fb4c6d70630887663da47fc819264e46e4747981aa5cdee01ac8574d360e67e75a97d6180828a3a154a8a3609d1ca2d0c6ad7e8b96fd8f255ca187b5dead21133807f4569bbe37312b82617ba849d0c3bdb6b4184faffe638789e7dae09a3867ed0ab836fbf2308a6d52b108a2d2fba1eff1ae4fda2dbeec36b8c734283a3ab5eecf7a54f52ef04c810966a4985280af6e47c5557a4f3e2062e03743511a96dfa86a8fcb5d3845a0ee3c34d95ca85da78669c338e1268912ee5b4d5ba2cf6b921f0c3ab12dd4e3567680ca93a2a8406747a5812de4422f656426231fddc49e56efa90c491b27bd4b2288558031e9c34265dfa48d71eec319e78ffe3d2130dd69c3eb90897f7197c09a729c0d5d238cf3b579cb2287bc888bb2277083534898b419f0c524becb7119df12a0caef6ce0b0dcbcf9f0ab793087782ae8aedc996079ea963dcda6a49139c7c5918e27ecadc552af0e768685d4e1d835af6f996008645db90cd18a53567762c76be01cd542c6d2992ce3d10975847c474671eea49c9d81f40b7c1e618a639017a5671e236bf8167cd2b4c725da9bc43162e94c8ec335fa81d5753222a4e976269107dc8c390a4ca3f2933928ade39c1571b1dec818a3c04dfcbbb1feab884f61e4efec6bee34d1328164a96a35bbb6abaedc0618eb56225e50cb002d23901bb3dae1f7c24bc2511eb7156c7db45646146ffe3e237ce3a924d9aeeb4b0bab309fa3664f1cf1b3ba43859ba7cf7c385ed05b6e963ffa44062cc2fdbc68acf00db0aa6b5a26775fb497eeed6944fa9c889b143b44224cce3c92a4f671c74c4a17d3dff7ac3d66e1c4f617c71211e30858a577773f48bf2bb5a60de460942dc68c8c172b07376eb5543b26f9364631876fd13ab5bf4b205a6b3b1e8590094dedfd6e90d3d2edad6fab452597eee48a67097adef81d587e067a6515138f26ffe117f3d6d213d27bfd16c293a1f2b5ebdec22437f540ae8e919f6a659e5d901d7812e77f29969c3eec50650861cc29714ae6b76c7041a36bf4b8e6a3f2d22cdb08ecae3932474116d5664c3a8e821500aef54a506e05a0f34e94694f79d329f786454db519eea0530ba28898000d75a51e3fed1fe96560fb8051c58df5a2399feffecdddd32c505f93185861590a696e0bec4a908a3691dfaa6031d6c939c1da37a14c22afe567eb11f6f63dad37c713e124fb478a6e6182233dee27bfdd8f64f5f3a3e431753d03885904bd9ef93fb49ea889ed4b0655876e7528fccb32c5308b401e0cf5d4f35cf98c19140a8fcd19d626e3956be95f2fdd8e697e728c0be63256d84befec94bfb947a772845fc9499eb80e74c4f9e3ff943c7621fd470ffc137219a4f97591077403a760afb33f0ab27d93da3f54490c8fe66c4bd8249c242808a5442c3c9170ca8d24b791dbb6252ada2024a205161af9fa3006f62bc27c8be849131ef9093a6d2ba6051b5db31ac16e1614e03d7bbefb73e7710916360042a66a83b41ecbfd4b42bbb3cf3f2985776bd94d3c909b5efa5c4e282b6ae72cc8947a4f964d5d82ccccf0f701e44f1875152435e0c6c23f741fcf59281e28e3ddc32cea5fc24a5fa879ed328abc50ec98a2d818336c24ed74aafc729f7e8957854bb8a5119ab96fa7f7a801df5243a6f1a18d6844d45670e2e95325cba6511be4e6072db1da5e9e2be9907879d0ab1d5f2b17191181eb29245e6dbf76337339b3b6a6c47bea96d9406cb6e3719babb43992af361a40d52060b556190bfa3a990da40b21996ffc6794543fc259c96721c3688ab329afb16152a6e9383334bca20b5a7c498fded253ed2fa75e596c16f00327fce815f6b871bf753d308cc1b4dce3b05d0ae592096033a965d5735eccd83525340e4ad53398440b16a10371229e9fbe973aefb5ab116edeff4d9066ae208d473d522cf45c1ec3d71bfdb5c842459579b4919c5e8d28c273d5e78322a2b49a48332cdc3d94153f83cf6415754e20a11a872e61d3fbc539b7b1d05f82db1250b1394043b7e048898cd3c08ef50c9c44173f4818528e0073c1290bdf123f962056af04b4dbfa6d782e970ed2877f01fabfbe162139c30979a60ecc20dc2851691fce81e2a889ce7d3aabc5a60c91e7c2207d8aa1b9930f272aa2e5982643549285d6c7f923160ff0241273361b3a1a532610cc785189259869b50ef111a1fc4a605abd50ee838e69dfff43efa6bc279b658761b6820f31395783d2f5b1c909785305bee877c7712ac6e2bcc9bc783a2e42e58c7e0a9a7392b89f8a60e60d6e9bfe9c6e8e964640a426f2cc313286abf9b9b896cc7f602427c2ab523bd3f1ae3a8118e262e879a11896930965d6ce1293955fbf8a3a77bfb019e8b4670021132ef173a311d4c51bc30ddc638c42d6cfb7f8fff41450ce478f9fb5ebb6e105eeb614af3f4032a4efb4ff5488143a2746bc9bfd2b6adedda7207380083518b239e41e78b2920ff63f889425b6cc912069f01b2ad75951fff221ff1c3efd90bfc4543d8295994004bf4fc625bd6cf776fea057980ceb7cad9babd62c2f6f8bdc3ff305b2da226d374fd32a8e26050edcc6cb33c69dca132238ac76d67168b258223546995fb2a7d3851d106aede60de86bf2dfd2047bfd15297041f68ea5526e1b0eed0e00d49078d27099812187a1ecaab8161276cd7112a6c0a6cd88650683537f716976a8dbb25c8b61d9397e093941cb0b3a420d0eaf4823ea52dc71decc82b29cae18d43181d4055e5c1ef95266ba1b09c6b07e29dbade9651d497be8e71774b9384715612a5a80eea555e306772448f319a70cea8b2d98462480a90e9829f4a82474128f9eb692dbaffbff0886b23d74f1b6af7205319b06d2d854c8800240a18875bcabd74412e9dc7dc4f85425d755bfbc7414cc420cd9faab7cb74ef3482c44227a5f7debdb20e3ff8a73c17e220195b171d9940f300600f67c2e4d525fd4eeebf1a767800cdffc937eb54cb2fba84ebe34fb5883bb8e939109375cc7dd3ccecb539ec935ff0d93545c7514c53267827bb5a0bd311f9e984bb74543d9cc565fa953d64880c0971e25c4060d54a5479e3ba784c02b1f58e7493711cb6f7f70d821c95f8b6566959391e0691ffe5d22425f1680adc45cde521db1f455f5799787fe2f2fb022f52bda11cd599295ba8a9b0717089111f25a22e1d5d51a50605829a209bdfd9b5da060cf1961b732c97d098081609f002b3c9264ac70bbd398a92ba5cf9af54146234f6a42870e5211bc8ddda4880a5932efccafbc955f2236cd068576bd7be26a11708d9c24996551c9bba91c3bd6ad5baefcb9b3b4a342fdfed118c92ccd849c3ca13e40b24a18c2401df8d2ae7100c1d054991e40b69c12ae77981c337fe098706a0a1bea4f2fa372780096ee3a8922bbd6f9ea92d04322c04c566d0b0a1bfe93763e98f4660c3e79605ef68b0e4bd3363509a7920378e9560f8aba0ec8ea8a832ad399a7e7593ac1ed74153227b9e44364dd954963cd669fcc3a59a9184b6f745eece22dc2bded517361d11780b52f670c96b19775b9da3c02a4181118888bc395f98113a2c995a6236356b0cf75f88ab6be10f691491b133114009c017e53d17f5a845eeb8eadeb47bb3b18fe0fe5caa57b6e663cfc22c05b528df8adfd4cea5b4a47016d3388ac7f2d0a66601a4ecc9080d6ffb9f5a4536ff114e7fe05a3db6bd9a36fa0f26e1d6725511ef02b8a212ebfe611beb6702d584806880697eb22230e23dd52ea57e2ceabb4e33e533efc323b934b5e539958d0aee86a633de01524643f853198ab8405eb5354f2ce145ef449ba9072e4340dd45152f87e419e9a650e6792a5e7eeed301f3d73003e266009f3b8579d0c95c47d4e2aa1ce390813dfaaa2245280739728de0f8d31dea0fd9a84ddcc2119ba68e595f0364acb93b494c8d54be13449bb5fa7524b29db4a3be07dacc992a2f3172b84786d84c3a363160e22cec0cd916a6decf280803120b768c3c3011e620e09425be759a327ddf5ff9d31b1b356424321fe2c03d66be8499bd4826877ad14907f6feab0a39771290f9d603da15c99460b3f64c92a646cdc03a06b0864b0cf6fd6ad511bbb4ddd35bd274ff4cdcaa319710447c5a4343c9ac81438df0464c10a0d87a920d7343503b0353dcf80ffb285d547dda3d724ecd96c8734b6aba35e9d62decef5934470a5b3586355867ac0a691c5a1fa0a3ac2c70aaba2701e56e60b059d0413a88e5364a0bade8e95656066734cd98d66008871adb53f57fac242bd3500d643c36764cbd1efcd34a944f5246b6b5796d25315c57a6b253d47f293996bf50daad42bd3ab68ac51fc443ee2e9aab2185c4c1a22695035e366476b99153c9003331297cf7b6588688516bf572e7835cafb8a04ebb929289d171d596326b7982251637d1b6b8129df1f4e97860eede0a9000a9f62dec169e0f54f59469fb667d04e599bda37dc20fd38f5584981fd21e4a4a5f89144d6ee4e0310cad1f48c78714f7c2481f561a3c9886e9c6677d34b2dad3fa43ff567552e1dd1ea24d93f039614bd2f24445c009ae98491975d8f3f1c661426e060b2bd5190193535a1932f33beb3ed2ea37c08da0d13d7928ae1e2600079803353f41732522c816dca2ad9311fc3343031ff18c71f4af17e6be8580a167801a7c5471a92a41fc223b01461bd6107077ef4a7b36be2646e8fe2445fc7fd4f922a5f7b241cc282fb214b16a5ea486e61772855fba6860a5aaa72465177372aecb280e53e9f0eb4f152949bb0c00c00dd9ae7a63eb1e7f1f2a27111b0bb2a9d962cb1b6715061fc277f4b0f4b33d524e9d73632148d1e10cf3a972bddca15f2f0548255dd9d13255e3d3e018bf0cba21cb507fa7859557bdd1c81c0ef6be78fd30ac8dc51fda7258517b06fac6b20626f949d03157d23b16762ce29e7ccd9308e8b06c8e95ab577ceea3c8c1bf08b3075e0271f1b922d97ddf098c96df677b08bad3344bda42b21a58fd4003c46ffcb2a477a9f066a9322cbb6303900b4af6d4f409f13d21235bcddb5145754ed14598952e797abe8576bdff549ce90dbe4381ac02f2e6ab1c70290ea54115bead15af22e0c91c769cf196d61a981c5f3a66177af374a4b985599790bbebf05ec39ddb8bc72b8112af5f7003d1fdd47e3ba2d31e78c67728014a2bddd954b357141d9deb6cc205844af6f1e9fd78bde0619a30bd74d9a2d0ec15b7575c8e72d43dc00709dd56180a340ea52763ef171e646035cf18f184e810437fe068f2f018e0fe1b9a40ef7f1e104400bcb881a685ac8c6fcecc7471ebeceb05595b48de6a869aee877970915bde5e77d0d9092936e3e16c3b7aa01bac71df81d73d3055d73e1e2d1e58297cc10598c48a6f4fa70225196ebf1769b7c7e6ca18d6a4f27598e9f2d2561acdb4a10f4ada0808b73042a86645f76b4bea2601a6cb5cc5c58e82cb434193bb847c6d949e01acf14c679aa277212f24892c1c943a51424875849785a4084e524445da7d3d40bdbaafbe6c8e642af393d6bc465c2e55c47ea47ae94bece5ab236d28a5bba73800dc400190bded84f3750f18d341efdb9b22ee20d2d0189a639568b19f1e47a0602e771997f60ce8b3b972b634d52b9bdec3254233a9b9ff058ff6c855dc2915b9745a76b076334d03eacbbc00afbdb8c9d3cc90e66e89133b993d4eaac27133f9d92a3b830fd88763381c666557c2058c2465287c681fd6bee4b624ebf81c228a949ebe099008bcf933e6a1284cef26a11cf01f62a86830b6d7efe9fe952ed2173e2ed8bd27f96b4c2f24ebec464c1f9ffc55c7a2e259b1800e55c89cafc62bd98bc596a2bd176e5f8972cf1a1abda8011db84db5a011f928edea85bfbe0032d45ce90114cd42e3ea3bb52f9cad2f6dcad6fa57314fcbf0706b65c2eb173ae6fe5070c73b7c89c18f4b6f988bad57b995faf0c2ce226d468e01b73f2e9c277790b1a089291ebbebc8c9bd703fada01540f63486b80d010ed084dd5fe18a4155e045f47ba69782841674605169d7b36ce134105cf4364ea6544f77dc6d0ff5ca540c7a8a7d989ecf0be556596db8957db2384aff09c434a4ef6c00f2afc5e36007e1669b624edc0717adaf80d0e176c83c76922a2792028a31e6d86f88f1c699b8833c84c9990d950d970db8e89ded7d8206aa3f95be8cc94c94c8cc21f2221c9d1a71ed5d11eabfe7100dfcecd8e33c17e67879438efd97b5f6ebae13774a8b0f95d10835d7387e57d87b1bd0fcb618926ba3f3b74ed579e193e0b096ccb17a54894121ca09a1b2459ce8156e6f30e6a990a87e24fc9b11440f1373d267766262770715bccca18fc3fcb6dfe2b20d3ed70f7134f2bb1b782a69ec5398a408510200a95f4e10bb21ca48dae6d5e1d9d4f4c80ac4307aba556ad74414a0bba03b551c30068f5adbc978a7f31fa333435088ee01686c3c41bc501bce987de24eb1af5b67a9f65163dc0229bd502b08ad64ac6d1a7c3e0f38710692925e44582b4d48f9993b6c86464ea3738b519033e958d8419f4ae53c7a517ffa16016e52c2cc101b1c215bfe20fbcbacb5de2421d359e4ca88393cf34dc2097e507d33b291c107cbd886fddb8652848d7e3ffefbbb591c8d001821f73f72b1506129894190cc0ca4468cb3cd74ca43e5a77071ce72c8f3fda616a1c8f5087ba7800984680bdf31e136f2f6e9efff2d37c342f2b9d730fb42421a4f967010a8c58222bfc1c6b97953074bfce2bddf6e18c8af1510361504eb52f072060e8f80a523e6c51b21bfe414bca2a18eaed776ba503de7047cde71c569395267dcfcf0237b3144c7b3eff8fdef6302202cb25d6f27d46e1d16926e2c0a8a7d704097f80a5b04990f93f54149daacfaaaa9f09c3873e38c02df1c435989e2cdd193727942c3ca3ac1496f82eeb30eeae8229dca0e0e98e877565898fb1a4d1b4561e2f11a7293b80fdd17e4849ffb3ab5dae64ae9293edc06d6de64764ec1afed3ae670246f14c628794dd7f8618bd888cd8d91fbfdc65d3e68d88d7e954cc621aca58098bcc8753ac4a7a55ba75b6d62aa70f37307803ff5aca9026270c694706e175793ecdd5f9ec3b6867ea515b9cd43762ac78cceba384c32ffde9cdd864ac265bd5acab331da4a28523dd6aa01b05b4e83da7295ac5f895291d6057d4594401f3024ffcc91c978d1af887b4551545f55245e1fd0302bef9945f368fb6249f42cfde242417d6dc75b6df67449430c8040f641a2a9c8215679a833cf28725c5fbce69a71b4efedeadf1764cf495718ed5095dda446445c784287963265a30e33f090f2903b1143349069bd3692a79606ee02e32fee7c05d29b534dc4e517ec9e686b87dcee02c44a82bff3c4750d15d3ce808580178bc84ce5595f32dcd869dcba3fc685fd4fc88beed75739261f52127ee286e69da4e6ca8d90bccd8cba551a9425dada749234956c81c0194bd8151e1319d2f53fe6506eb2f5bfd75374e6cdf99e01d3d1c59114bf9febeb5730f5eb11009c0af0d81bbc54538168f78c24b7b25229620212cbc23f24a503441f19872c582f8c833871e26ced8c209fcefdebdff3c632c2cc83395f8691effc9549c98cbde7bf36a690d40682ac9ed1355c27678932a42c3de61806bd148cba654fedf03b6dad3814dc409684ece2452ff544d9c08b466effe70a488aa1116c0d4a2a4e7d4268d899eb806a104c59b6b6f2c4ac327388b8a323b549fe4c56bbe1a13b682fd72b23763973c4ac812237559cbb136f0f43f303aa38aff527802beb752a9b65a9e20e02af9d2cdfd29654bf5169c83c575fa144411fc12d8574cd5465c1cb6086412fa9afdd5a8f17130c2305232cac3d64998b5a54cf3a60c0d8c99a168379c966ff907fe08ae2ec42faed129e839476765fe663b89c708768a62ff16b071583ef84f5c73cc99fe1a4e11635ec761cd0411eb25f1b6010ea956a935c78367a7e5fda0ac2e5522e82cd2b4319a81c2ae905d5ed9b2f259fe93e6e63d40b5ccfb31ddb23e9f178fccb51d13e72ef20cb4b6f05ffcb4d77d4368a451059c0d24ee6e08986b4bf347cd1e1bdeb7b1e4b13e1105875d3b76cebaa29f398288e4c8ed5043f185b57a396928151da67c0b86d1d1f66d0670908bb82a5a9ae956fc6ba65b4b5baf2e980f6fb8766070fda25361942fc158758fcba81f842f7db2ca7aa1b44516bd0a443e09a50817f99514898018dd6898e37a05596c211389e755bdb18892f0372fb34ce81e7beb8f76d9ac8dd286230a1ddda5e2fcc233c1d84465d215ec14ed7626191c381e2cf3b43c6baa9518a4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
