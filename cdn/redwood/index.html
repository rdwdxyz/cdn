<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"323f3f2b25c8bd387007b41529a7fe83b49c684e4bc705c4e4721970d9207d7d9b2eae3e88aecf2898b289ec0eaf52dbad79a3c278211be863eaeb4b07701f0edcb5dbc9125d95cefda8d29bfb5ca459ec58885d48caef2605888c0c99f40e6b94af6c403dbf7dc5d19100b1f336fb80b271f4c46afa69ed09994d02c7550fe33bc0cc3009d316b4bd1435244183356080fa77ac054b5a934244b702b28a86f2d03fa1d4317b6a9976b97bf02d3890b000ad4a1f95e0590e7772b990a20b00f9f28612945dc694e3d1fedbe6c415458c5fa83cffaa1ff9c7ad3f6ec255512af815370549de21cc750bda43d1c82f848715d655e7640f80f7d75bddb474a8bcf09cfb39bba57ef9765674a2a4c2d6eb1449ce04c95c98435a4ec38d914a979a94b819a1710e192f08fc31ffc262d09f3615669267601c9b4fcd58cec838d653169c009323134e87ad107772e506637e5ab18d9ed1be77fda0cdcf331e9646d027a718bb975f7ab8fdea9c4da637037fb9e1ebb75200f8089f9456eb97367b16052b2ba38b501566d9e75a4c210a591731135f5d65005288d1284a2185942fb08ce34eb019bd21780e54f048da8e6742f7b0c9d1e67cb3850e25d2970f59380771abc76197972f2bfddd7c8199399750395e8d5586ca5930b80d568ef2773fa4287976e7f0b5cdfd2b41063981c4fbf0853ed6107fda064780f95b6b862fcaf7a4cb178f5cdf12365a42410320dee98757ccaed370e74080d220f6e1eb45251ee5f0c8b8a6460656824f1d7ac7219d91d7e69a7d0caf3862e8faccb00b340976135516912572d2d911354e719d0616784463e00f8d49b7571b8c8311cea57ed8c0573ad3423da6adfa77f82ae9a5ebb42d07fd82dccf1137a8ac0b062f230d48cfe0d7e247efa71bd8ea5bcdc261bfee210164b0e8575ff06137cb06b4741131c566baa39972fcf4450d1229a85c1eb731ba9ab37b7babc8bee54c690024250ef738427f390a566f45bd20fce8cf2cbdff889251c763281d0bcfbcd495845d0c28f3282d01e62107a8fdf82b9a8ab6a39d070526b22d070f07c6183f4852e8a487ffcd25f6dd7c0e66821d92198509d97dc5751bd9385944ec39a849b3131d9cc7e70168fd477ea424b24c7c5164242ffdde12fe7f1d5ef29e0e6cedc12149cbf7bb4a35fc51576af10c24854959d8df00dbf9b8830955f0973b99742c468c88e9c5e35ee67b2645292bcf78751e9d4d00e718183396759fc0dfff6478568747e7ff68a283f90b337f4732ad1357ae3ce7caa4eb47454f7b79e7e91bfc1ef56da16e9762312c9bad43e225f6835621039f04916db501ae8e1006fc5b5c52c72413107b196e3aa10f3bc0f32e82dcecb4839ac81f85424fa7298ad2f44d150e9125538ac8fe60d04716688ea7233f24c009b0c5b1b7def1aa5f95e58eee19942bc36562181b3cf04ea69d0f7c87858119af488ca8db4ba34816f055a7aa5cf90af087d293cd6b9e976904e8c80fcc3cbab9bfec84e63df95979d23c900f8f20ace47a1fe8604d0a7009860dc7e322685f4e46eae7df3f8ded9aef8ce4f4b2c63c9a0df43cd96a73d1eee8212cd03e9ba42bd171864dd52b95513d18c515eaf96a42ea44cd1493837f9a14f100e7cf7281293a52865a18967144680c06624fa38f25015108d0e6d19507da3ab58e5c99ad571d0d7cc05494fbaf03b2632ec309914c67c09d832736091a9cbea3419b499cb888335d197565bb041a0e7832d2a53b83a47be99702eb0d4184270d1c3495cf7394637863e100f9016505c2c2ca30a4271975620e5bf244836bfb593eae939424235e5d050b118cc9d830191bccd813e5075f3eca6591f5db0438584c5f234f901ad244413ad2bf3a3ea08ef3228202ee00ff37031f2e3e46bd2dce22daec40a1b24e19f2c53277692417822332458d650c444c08c36fa3f16a9cda331e44bae1ac24699d8de55ce27fa81a9173d14584b16ad2164a7850c6bb716e7de912678d033954764565cade4fd512a9baa512a12221bbce515061f137d1fcc58b00d7ec153a7f2d67d270d788a27612c56b44cf748a5968bfe16443e087611691d89fc7029fc0b0a4125be49b89e0017677472c6a0ce5581a659c694185f6062775d7e863d71d3dd0864bc4d7c6c4a93709ffa3f99b8c029dc6e93820397756ab9dc395e45fbbb252ebccc12848a7f2d03cbb1134d43a8b1e98384e6dd8eb80ca4d948e5eaf3fa06e088a949f2d204e9ac164e6ac7d777376aca131ea2b1fb38a82cb7bc1fa2e29e3d20d1b3727af2e3955f5b918da95b4e4abed286eb7a0b20428b1a78f310a7335da82f5b8bd618b42ad85e5ee2d5ca73937dec77f2b87fd92d06b8002f97fd3bb78a757a8e539958a4538dab17b71ec8b83a21360bdf4f06c5447ef89909da6921872fe68c332bb24429d58aeee53f0a82516ba0e6cd85c038abd826d669e17c5f02090871e2655e741c441e5ad716bc08930a0bbd1fba993de3098025631c42c76a142d780c01477e5025d331719171555705a22c205fb445bfca4126c22ad12f71fd77c69df221a269c1f01b597b6b70d62342ae317375352c0d7ef1df3fb0955494d5948909d42568867726de27cb8e928e33ee251b5ff97b81ff49274f70c793271afc7a37422a1e945f074341e47ec521c61b366e65d741718a3f9a9ade0915ba10894435dede743b5c98a5d3cfba756ecc40ded855b5d6d321b5f5d816c033baa5e21dc1bfe558694f20a397b107efb2a967fbdf54ce4e22bcba4bcbe755c36d7af4fd012a23bfa1cca26825064f94eaca0694a374b927a674e0a7f5dfdcfcedc01b6353a5c97af7922012182a018c2218c6b3f698acaf1a6f4761d3e422f66030f0db0958d072922be6cc677cbbee5f3b38be50a404a300337dceaaf974e49cc7b2c024eca38575f782dd5fc560893ce691adab241f5d29ba8fbaf99eee7a65a267b8ee79e36c712d73c82b79394486c9ff15dc842f19d03bf2dfb719da1fb72d13a5345c0fe948c299aa1e6d259f47dfa394f4f04275e1fb6ced88806ae5646ecb7747176f5b273def8ef3854db6b055f18dfd3049c4dc0105a29e1a3e27dca46313d27f1db08a5bec799728075bc8d5c85bd8b38cc5f3f6a2bfa5687a3f7dd74a3ccf63a9cdd9d09f076441a69ee7b3e5bbfa286c81368ab29d45bda4311b7d588915f4091add128693bae4ca6987bd9b9daf5bd37aec7ef3eb9a1f79443ee7b108de2a191dade8ff037cadc7e06ef6f3c0d4e7532530ffefb5e5dce20d5ec7aa2af8ddf5bff327bf13d5230c567d244a1b7afbbefc247ae576358100564c80d14991f09407bd29cc37953576b983c3bd02a2336ef1f8a210aa79ae4f23c9f435ecb398d51b48591723b6e500c03791c20d64f28f7964c0ea25e2c2fd41a9e1029e6ff649aade4111aaf8cf0b441183986295fb215448bb23c31c1cc51fead4de0f396ef45f39fbbb908df97db815d89767c1c18965ec4a24669b4081c32085417e45b249b44e49e78be6b1902714d89edf53bcb01df52a1083785dc1cc44ab970e31f6da4fcf3a54e8f087d07df1afc1c3af99b2f66c29d4b1fc7d2b07abaec274340c72b247b97f5342287bfad914bf94595d3e5d61aeecdb408b367939179a23060db67b32a461f1c067c9c6bfbbd7619630235726c35fb13b72c40251b3b5a757475ef8629092df4cf2c78191bf640560d767a6572b858daad02c555f1a7f0a2ff7072afad6a609ae56d5c7e105ade44c828493038d55be8e5f204d453ade44ef8352d35bedcebd86915b1f009d401fe89e652ce39957f84ed24b3dec2d0a72e7236658bdc897c18cb087aa71ba02a13351c2d701fd5dbb071167691de5a9e22f9e7f7f063d43e06d6da51cd3a4456bb1d40e83eb5e1c0cd566db63146b3ac72d9b1ed7d6adf0a85dc11e0e285a2447fae47910c13456f99899de6f763f9abd336ae0fe6ac7adfe4da5cbc3fb7ddc5813dbab193b86567509d274b50b409e058bcb7f371a08aae0043b790fdee57c005940d027275f49b6973f8685efe5ff2b083e72742a32aa18e6d8d4c603d51648f9d45323b948be285009cf79f9cde7e8d28ff61a6adb654fe5000af04d44b98bf2876d96dcc786e436aab98cbe3708671233ab2d6d7321c14c4e51d3faf8f4e45311f4c20ca1c60c24e3bceb31006ed151f593a4a7f69d72ee21fd021f495308c4088b828e265b1accd47297a0720178cb4acf96fb0a0512f02f846fa75dcbe2762f035a8a17fb1453bd4f2223bbded38dc63411ae0821891ed99de83b7a5d32dada373809bcec9879dad44da680ba827357bae1b665b67ccbd4a5d6f288c7415ab09538ed80fcb1fa986f99d281e1566d60248de53b3b9e2b24c6c6918102b8c834d91ffa6088a2a5e160f177396f48afd78206e697a4e6b91a836d25b96ffa50ff7f2249511c4d65241bb09def286218b1f847114c79991527edeb3bc52851c69604a7101660163ac0c26afae125ccb201a0a17a65aa8bd2a08ce19ff8b77e1ca39b6dab266565e7004fbb3c1dc998779df1fcaeb88db78b65c0b26694775ca59c5dcc58a60f21fac0a3c47181e40725473ddec9c15b660a9fcc6a269049033371a2c6e4f2d97521fcf27466458aee9cc300205bdf5df5d6c19382d21783b797aad4fbff148678a826a8e8916e6395e7edb1542ee3926c95f9fa9c6bd0c7306f376eb6140c172b5e474684c45f7986421a6e65ad6bfe12f272af41ca5b7c43a78b100b5e4d338ba673c256e6ae622b4d7687d583a3c27bbc6bdd7b88f782053b8265488ade41da9c7bb8d289445ce03072650a74d38d77d5fcba784afa333055fc6a7c5e45ac06bba50af2fbd7575bac4b512223161a0e83955083a167db127156c2a5e4ea74bb952c56aa1cbbeb124fc2bcf9de9ea2e13859df7989cc22ff61b4638717d0adf6380bdcca6c0365da07fb86445c7df669f98e99abb19bdefdf2e7967897d1990400097fc094825d4b54f8d89a49d3e7f29bb1f4ac5acc13313c19ce38aff15a8397c53dc409f7b3aa11d691581112bb5469dc6f09a37d6d0ae6e1b764991dbc13cec0b14e690a708b39d13be15835b670eea8195f057c05ec51cd7862e9212989edd48c06d9ee3f3be85aead168fbc2cdda0bd49e5d42366ff0db8620bd0528a4691d5419a620a5a5e10931e36880bb3156e9251bae370cee3f75f0163df9834cceff903fb7f245b8d323cf282f916f797865bfcebb53ece77e9640137a33d0d17d0b523c3a5ff9a6cac1a2e0f89e6f2eafcef4960849139f1a52e3915c926c5c1c81b7cbbcf3e929044e7dd5564434d2f32b558c8b129ff7eafa3c0882b025b4113a9d3f5fe8fa313a28c26900da4f07d5bf8b226fce5b5b0d65f5f25790b90459e097ae3a8bd6a5a19197cf30252e14c2e16237c595da5dcaf8b184a32e0486876d8ffc36aa642459bebb5ec4f14ec38b9cf103ce1d8e723cff71cbbea050929d4df86f4c702805b0eab22054cce4968aeb037dfba1e1baf5da3338cd9309f9f363df60bb905324a542188e6666bc57de0eae3ac29b46acdce5f0083a649a1daf4b2a5ff78338dbd126f06ac73dd14ef428071ad38472dfebb97d92fcc71bbd68a1f35db0a39eba3eaf76e6bc5b8e9c176f6baa925e57cf72e05b9c8e8e353092762ca80d98ef1258cdcc4250418fde159f08cab3f039fd58553f5f356887cf9aca696b14f6036527e719d2fc7eccf2f3b1eb4785875fa52af640197b96397db2c5d3043da8c7030c6f82c6e3038587a1fc64c6829d16a72e977b7da6cb630c9ea273d373b9f0ae56a524945dec2ee942725ed3a7da4990132ecd9bea0977ba625ab798d46514b2a4c4a3be70f47cb6aa6e6cd1ae79889508d9b0a3c0cdeda510eb800fd1abb2d89b0502659e7dcb1a846619cb3fdc43a417d473e02592d0d351fee8adfcd3ed3baf6e771401c75431370fdf3ef0130831ed6e2ff5cac86b0a3469b1b5e2c65ad9a21476938cb1bf4557e45b5a498c610d1eb3b8a913b52c758e4304ee28fb3ee039bd43ef7ceec027fffe2b17a6fba25b51f2ca511ea191cdd815245e96aa00f6c74da454de463279e589604d18e88a0707ecd459cecd282523179761f3ae8caee0a92d0b4c81c5c84f0386b7662d2d15d2db36cb2448dd7fa42af217999c35d63aaf2e64e1461b2b20fd1d203a3a3ad87f30e2714589c9748f6d5929d4d33e33b9cc0abbbee0914f0ef3269cf486ea38945f6a3d016f3cbc21cd02c44bc1f36364bf6f777a11834d42204ffa549fb92649138fa6aa61a4aa8324315af179ce38c689068ed5cb52b572981771511376763e3130e7638f23defce7473ff42a9ea7e9a73f1400eeafdd8bcc70a9d96ee7dec2996d0e2a95e691f04e946ba2487ca8fabbef160d91521e63018dfae4e9ad6f571c1948f1febcb4c71737aebb9def7e99de55734f242b73a5531059028f4744d026ec9557d936ff8645bde1b96e7959b031216019113e179bae7c8a6c1bed6c49cf746589e521d48a99487d68589741df039593b4719602cde6cc6dc7015c5d9234e98f6fd8def86ac34d8b17b4cc7529a6ec25843e83850d5601449989048ad510c8cd06bec300b039c240b96a70b2670574be01bebdc014cd14e4a4492234c15a3498864726af69c5cc4069467010aefb88be398433f09598edfab08480e9b891ad21bb0802c27f4807970e971302774f3d5d2e5ebc7a26ea439b2f730e5e69b7b575399856b32a951ec406bd8dbd5c112430ebcb209fb2a1b18dab6e3c791f85ca36771d40a8a42678d9d19daea0a491ce52a4e2697d6cd9f8cbdef66a9a45ce2a53ab40e0be678d3ce1843046b01124d08f3db15e54a55b617f4c0ac30d210d84d17720ce8c8f4ea60025bc766c350353c5e9b0dcbec2cf1f1a88ff70861cd597d973eb42d936b3053088ff247b05d17e8fb9a26e18734cd8a5d3add8d4ec12e9a5c1c169dac5289bfb1e50cd30dbd0d2bd53854d53a3cc2790ad332e792ec3eb327b6aa1c4f33901a2083a7c015e9c22ac63951e2bdb17ec6a3582d01f540053e984d5587f1723e00367c9a8ed7387d4cda6cfa5d2b5085bd4ca6bf1232063427010b3663780881f152d4bfa8bf253dd4b54a949a1a0fb56018e23f3e419c5629ee5197fcc3b0bab1edda986c7ef057c9e47b519e97a5186ee1ebc334c56b312dd1e40a08a751a5cd5c6cf23de7928ca64fac068fa00511ca1ece3996346e74f3876638679da02dbb96f915754b4b5dcb45bd041af9b70b55ad8b388c715816b42f4e55219ab94aa3af538eaeb0f017bc058b961ab26a767e0cfa7e62e6c62f09ebfcdf531e3a9911f5a8e56468289e8ffee6a3aceee0293a1ac5cf962bfa30a3eb53d46993c9a868944ae746fb32145773aabafc114cba4e41a0ec417cec3cf1836fe52585416eb95e0073d41f35096ae7335cc0e402ba0010f691f8773b2ef1db084c3416dc9a8de2870f9d4186469b680e68c27727b70d44329711b4b3ba7f8a5f629ea8bb95c5a2fac992ba20ec69a0e0926825b2198c99c7da953c085139980b1a01c09de3f5cb5956287842ac7c433885ed20f8066a9bac06a481c37f801934468f8f1dadef1ffbaccba8e7dcdd142b7b292d7a5891c045d41d95a299983771b67b9c4a1b1db2cd393a6e98fc1ae0ab9e7208553256703775bf406395a1e5cd9f7284dae5b362327161083105d89e365693e1e149401d365b8e88b78025d0128a4c7c42de897ec71bded821b07beec12f32a643971ff760b08aa7b616dd9d2d7eda51a838cf689e584cfe661bfe61faaa02530394b09cbea392725a7975f355910b1c468c025ef8de7ce039edd95e3f12cf5c8dc7a8b97e0a007ad1fe9ee433245ba11a0ce5657ad890d6e79ba0c35b4bad24dd1827c302d5c6cdf12ffb4d1388a2fcef52479c899c4ee68f0f37d0cb59e6006051f95a10466123af107d5d9f387af1c0044fbcd54b40beeab53fe96994d94fde961654397069a1250cc104a2942cce256e21a2f8835e4d7737fe913173621df43c96b2bcad44bf326ff6934f9cf1a9f48d4c92e9c625ee110e56f0a90fe073d2979d5ead30f321b437816562ebfda59b79ee308a46caa0088274455af93feeb0af1c64145bd970d921261738a4acd4a88adcb3f80d9b13d00618e263d536e1665cbcc0ea3253e45a78fc5d12cdc892d841290e13ddb5bd2c41dd90b2fe92ff8920d6d13a1f917c85a46540ae4ef2c3293cd4ee2e22f8b59b49ad5b9d3d0b62112fc040278046cdd3d58e3c79b9713c17063e355f2cba07978c7d25aebe6c32bf35e0737e8b29ba966be5fa18e19e87b34a13874883dd03a4c31387c7e40f4b3bcb08e73c68c04f60fd3de64b3bdfc492a10944baceebabfcc7c0b6113ba082112b7da9dd278885d8be0b82af065b4e71641c6e319e26942e0fe92eb2af844a96fed9aa34eaa5141be44ea6b831e009352ac77cf5376f70843872968263076a7f177dedbcf4650a37ec0835e8d8a525a1a8c340589916c34442152bf1e724e5c2ca9ad187b3ef19b3c7d86cdbca2ab0104c275f66bd49e2d0ea534e45a110f59a552a2739bff37cf96f7b8f1c16d3c86b21c2440ce22c632e12b7bf5d2c0cfaccb3bcfbf891ca2267a7c5256fe67b68590be8713a969ff3385bacd35872266ec2a56ddee50d8952078c700cad2691f6d93c991dcc58b252ad3a37bd751bb38b264c299e674df3f23a53c4e1070f28fb484150428d69cb7f6b90e859b54286a2b43fd36ca82a58cd7e10c798c20f15d4f06511b53a206d1346cb4aa122769275dab9dc436a705c80652d31f0f6dfe1a683296bd1a630126b21a2aa2eda5e989682b697b333bacf222688319e92843f0f033fa8145101d1ca4d1516ae6c4b62f3d7ba064cdc152aa50f9952e03d6c0285e437967ee3636b959755519db947ed0dc66ea2a93b5ea63b492b3151ab7ff181a1f64efe843a2d3eb45e4349cad6670722005b3451e6ecd5f6d05a215ed7bedb0bd9b2a4ca18ae3e8db8021905eec111aaed7cffe4c933c2d784558d16c804772dc7605b9e05508b3140887268b557260cd96bdd5c78927164de6b67fe2ca4eb248095d0b3e51f5f51ae3862389e4703bd985d04b0271d022d37191749140be4e84f2dc52ea8183cf95893805d86770d2cd8147582f4206ab81ea30346d684181ebcf780320be7535394bd5c1eaefa01201de3f08749604912e8356492e6fabb8df1d56e0fca63e0e453a10b7d22164d47c30d234e284bf08702b50c30dfbdff275a0e97d5701051e5e9c903bc974301e479cdf21c314fd7ffa215f70d3a78efe0d110da947beb1cc8b91248936144628057a7d34abb6a420c052baac5370bffc5ee8644311d69cfa1672524545e62b0607602c0e5b19db844b2af5e6295df5f948958295e63c814a1876ddda82a29db83957c392564091a96660d3c2a96fee474c4942da24d732f3658641d7f3490d408bd8765856e0fadeec960897e97365d8ae0036c00e8cb0a9467e8f237d348810406c74e3a53d048bcfdbd0826f0c8abe7e05fb0ec8901e2279226eb113540dfbfb0b8daad15464cc4849989f3ac094a2d2594789573117ff989b3f73741b72b09d7e5a0d3a0edcccc2f0a8075f8332f41781e020a687116d523e10c1c816b3392657adb0b96214b888ae4f7f519258df6968c9543869c1d2f5d976acf7945c92f126f0fcd9b464763624af94de6550b078438fb1f1bb71f8d346b7bfb4ff821a28a8895393a251260b16053cd84cbb2153bb7ee7e73cc7a4ef0903e627792ad433744a09bee7a4dd42821929e0996b918a172e32e43c29d30e1c2183f1df391ea05118207366677556ae0d4daa792b065a6fee76128417efa8216a2469c4deec6c631bcac567651986c4b996f7243f5671649e2e851b7b4b40796b0d421067511bba85143c2fe4095241336b6770b7bfbdbc710b90eec1a9b9f095782f20e08307613a5c666cca7e468c7f2730ce7892bc2c2581e709ee68c4abcf6125db4a410917c6e11100a4d0af5be0d2da7809a1777e28181ea57081997d8c9c9ea41d4861878b50e969499d0c9ea653d914c2697b5bce2c2b3f1e20970be091562295aa1e5c15673981fa507f6393056c6d31c7084871d72e2438dfaa402ec610672357dd9e4d4d06c607d5cceba79b1de2ee34af0c9ebaf4acb05942fa4c4347799e96b2a77aefb3e93ed2beea0045add5e9a3c8b5e9c4c03412848384c44fcbd2623de2f0536adb2ccea2abb810bd34bf8b977043e7f3190c380ce83439945338ab28dced54ce3c0d33044ce4232bd59334fb73b3a64713edab6718055419bc9b033d637427ae543c29673859579280769acbe76c2a30a950f62384628a14c9e2c9ef45b54d4c512e2ac2a770b77121fbfa3742a1754c0799bff3e9ed2a4a44749d3a0d157dd63ce2901476d685fae3270606c26fe45e5952f59bfec04db23dd51e276b243de57c2880d67e714a9d6d6366f2d68fe1524f50f9a15bf7f9bb1db97636c0905d2cf54f478c17f1cf83ab36b4b7f8bf3b599a5dd311fba3906183edff00fa68c8e22027a3933ba3b7caca7f61cd7804b722f6dd94dc9f44486417579ef664e9238e124db47bc79e663471cd6eb5c1bec32b2fbc2e4350d1078c1f3cb9d0c745500292b61a3e3e7f1bb61af7ac75ec0fc5f73280a7eec69c49c63934662580545a811974166339f3c95f42b0e73eba38cdf84e11fdde00fb6b58efa3a52ec97c82810eb5a53bee409b1390644efd4ef949d7d6467082fe0857001222f02f270daba2ac705331cf6b22b98bffd31d64551ab497f7466f031fad4bf6b954f60b7706584f94221347816a0fb0c57a50db9fc5ed38d0c894033409bd6d8bce61b424bd626ade140f0d3aca79b09cd044fc630ddad968362fb71512216ec53795f68f87819ddaf0e5c56a83bb312bece2e1fb82395b49b64b406313c9d170c9fec1420730e1cf20a14cd9ecb38fdc8ead332038ede29976443c96f8d0c97ce8c62f58533b9454e9f12d9d539755a356f1a642f72b436e92d8731319da864bd867148234b8084159b99c53f4f5b55f7b84368558dd8b6de0931d4fab7edf34ea3d633dedd5865d4ba749a7395e9bd105078871346ecd5cdb9901c724b2a070920cdb22047c6b470719a5d7d2118aab2e87fcd9eb06c4d17a0097f4e9fe1de732a5ff1a0b7d243cb83dcdd9521193b519b33aa30452339e84d55ef07208a7666b4b0ff8de33e13cb1ff08538dfcc023aecdfea947bf05ca45aad5eb2a04ce8c6fee5beb1f9704cdef66d94d7a0b33621d8a1830e280b18b68c81b96d62d9312d439ee42340ebc2d278632459165247ed18602dcd13c463df4368b817527006a9a5d0d1cf2c5301f1b6595a3c6e9b8aa0626be76c4202867994235bd65edf445b266f3d55b2c75954453415e6392f1f38c5f89e01f686e81ecc7f9c0ed013fd0311b4ab2a8b1fad86d9fa673299c805d0037baa41d27a65b24f66bbaf3160cbbc94f258390f3750be86b1de891d6712862b52cd13b174d32af95813261b5cd1761eff2993d09dac3117b34081248e17091b84aeda8763695a6ba90130815ef7efb82561d7aa6b3d8ae8ce06fa5febf3f22d0f3d870f8b6f245375e4c24d02559db7ad6d981997c2c9e4493d44e04ed8a782201e74311df2204a477b72601fb3b23b7d831113ef480aec4879bdd16dfb35a276ca99ad13eebc1f710b0ea6c5454fca618d303a31f43b5da069fcb5bac51c2f40d189d8986b1f1e65518963dedfc32b501db04bcab82f2c396ac04ab4ae6485033d5b6dbd4c66a0e5081ac5a2dc6a01d03f8bdd46a15693a1ab6d3cd04208eca767751eb208b31b555276a2d5484eae9558076356f6aa05d3190a16b0060263dbf744404c5b2010e69ccb52a53e4572b7661332cb501caf7abb56ecab149fef83d8fbb07d555b69368ce624c610f4fe1cee54d31adedcc038f2ba34a632087adecf4a55ea79d71ec50b06bde45d95cdff403c82ec2986a07f1f6f35f9a3ae86327eae380f05e8a1d1c4ecf6f382df0af37b31b6a834dd52f7b781475f238fc8af83778fe861fd1d2edb1f2ee64387fd19e76f32854aae28fdee82d864a0bab527cb949293e884fd4f55ff37e64005608672d4018173297595ac1b57736585283d90293a4de359f2935cbaea2272c54a0a2db2f33a89c22e246412895ccec4be1162cc53d80764c3042e2fe683a140ded50036dc05c127bf59d510d56990de0c75f0f514e79f0b73359d7b50e209820e616ae4eb96be7f17fc4a491308af39315231d229f3f9f21ae7becb95a28eba1d0914bef35f2fbbdb3c6971633f5b2dea3269f1d7bd4b10fef71039a8fc296f185c1e30cc8bb84f107544cdccb5b997681d93eb9f4513fca53d5672ef3f87611bebb49b94cebc42dbbb9007bdccb53d2f7ff6b8bab7e09fd89854c546394cb0ad72666c45d06859787a96bf659726f01ce7378b0b2c88826807ea1ca24f6f14cf9f463cc9ddb1cad13b6f7b9cb1c58e6d5e2bac57094ba0244b0dd00880a2df4c39cc22a4248f1650bbfbb7b831fbee59393befe0b6093400e7277d0055b55d32dbe04833d1565250bfa9f5281a5f1eb0ca050ae31ce73b7074c0c850771dcc8325ae8b527bfd2aca7b60c815d50a05d194cbfc59ff7f5af4a08ff68295a9e8d0af6e4aaecb077fc7af4b1a02087c35fe9fab1d84543340803927bd56085e421f293d29a3293c16045fdd3774691a282c41419fb1770bf1688eb42c0ec7dfe23f7b1b67a47b03067da80d65fe38d60a97478575863c59d9fc4e6f93bf67b8c3173f9aa955fd5d3e985fa690997a2c27081e3fac2539b42a02b3845532ed34d0de04f96e7987f217a70b22d84aa79210f2f65af60fad10446c8ec39802bac49bfca2b7145aea412a61b6d168b95f54d5bfcb9d4ef056d0ea936a4522430c31c20d2a999ddb4bedc04dbfdb872ef9fa356ae3566925eaf5974ddaeecfdd9715464af40357995aad3a8b0cecc7dc1ba6647d19c4fb508ac3f299f7c56100bbc2ca5ea7eff7a8298b84431e8b28ef55d73aeab8e4ab1d78b80cae242c37c8a39ff81fad919a9e387949b7ad6d3bcd6cf102125a3d098ed0df4bb089b0da70beaf660ce1db2ba3f70b6922460718a5352de0f2239e7db9489fac53055a4fe89c0332356ca7fc9650e58addab7007afe18b76e0933685da098ded0b72851eb1c11ef7231fff6c6135e3cda0bd68acfcd82abe4795f2a5ff3d6542308917d56bac180d5982f6682555414b44d86dbf2866492c574456e24f2857d1b1592961a1e7b34af055385807d9882ce11acbc64770e59729edbc150533b7154215a90791d4951c30a7b4d1b3e327e85bcbaed543cd3e7acf3613d054a562ba121d9b31edc8976cdb74eec688b99ca984558b1cf14e24f3bd8b9876351ec240493b09ad6be7856668f9752fe5c2daf93a4127d1c998bb59fe0192e7608d200f1ba23c589fd1f959a98feb93b3e5f96febc7ef3f1d61294f3322858855880857dbaf74fb05847a535d1ec77062b8f804330d094ee745c964c9c0ecf751a4cc330ecdada5908bcaddfac1c63db9399f4e971f639d9edff38dc07efa69275c1e33992ecad163f27064887fef448201c96ff7dffc0fe7a60f009b4a44de8c5a4dff1b184c76bab058919d9db91de73d8cb25953d24b8ebc6621b125049ec66f45abe9728d46f5fe0a14a69112b4594e9df6ab6e1ed96d35ca6388c2469ddd138ba1f474bdd2ca6d11f5cec16a0cdbe4199602090df6a8b57a20338506ab923ed8f724e585961bc36efb1d464bc68ee656e914cccac9963e4c45c144407a51871cedba51dc6425af7170f5f28079c0375d1909cb19a93384bfc17c97f79e4bc6c18b6bd5c5331f3204e62934bf7c80fb616aea2f6a5c6c4f549235e027a26e896d9c20a5864d97d29765f65c37617a31948f3c86b31edac486e7efd15e2f1b94056463240694c43695f4e27aba24a42f037c485786e81f530386965888468c56f6bd493f976d6c26ebad15b2505db4742ffb1ed5bbd351f571bc538e5326efcec27be8512699ddc36eefb954274fd0b4e99f932f94d6b3f6ef55a67a94fe19c686b840d8b658a641ef94cf5699d53e23ca6743c4ce99aec171f3632ddad402bb817763c86e721262638911e7a52876d1d666559ae57a5ef2c394a419bee4402ee0d3cfb1042d51af525cf0b38898120e0f67ea60196ca06ce9a2e2be5eccc17754b8641ea51468bb7176cc219d15561adc5764dbba8e01541f4bfc8fa34f821da1e01d67e4bb07af3e85fec028bc0c0d4c7bf8b2b4442fe8c998e171eb59aaeb73d1e68a4b52e80d85e16c4b5f16bff066db7bd6ea7bebc8ee8b2d1d1808109d0e71a42dff8e5c7a93839a4291b695588a603d0075e89cd5cbb1ea75d53c3886477be8640646d42851c69bd7dde2dc1719ae31ddb3ce3a35d92d3bcbdf3f22003a383cb35034b2d870ed01642b859a940b18c6b08b6f5b7b714f4e408ea68470a2f637f013db706a3d46ee05cd9766c505b10906f424c093b0dd7365688a851038d546b185d2b45576e0cf6cbdad8e42811f72c48ea8186c2d74391c93df9e1d23cbc45b4b00cd24edc225021822fd0edb1c55e07b3fbcd33164b31e885533be8a364a77a4303102a5b10168e7a13b49e4a69457b43621d1779581acec28bfb0a58fb07cc65a059665878d11ad3bb49c89f5b76646226d0418f6a050fb989c9930edec414fe1c1b620080e0ebd567bb9d2671cc636dd510a10cde96326934394dff4df3293556e63beba4fd83affb082791bdd608f7144e6e97ba8294990ee4645aa6c04117a19fa309729a1dd670d55cae640e20c4932ca33b89e56bcef282725e5e562c3c31696841d353a5796728d16c83fc61e61c1f81f7fcd4341f8ee303d2b7410c8e46aa1a502eb07d82cdcdfea1bbf6fc6c1a83a47a6a4f7fcd0676925e19406dd1667f0adbe8c3416518f96c29cc4d0e8692f2e85b0b4f28aea085a01a4fd1b3fd7e9e466da3725f8dc4fb15ff2acad4f0efa0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
