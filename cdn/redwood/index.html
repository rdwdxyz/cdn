<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"026d13ad65ec5f89fc7c8fdde36386f451d3df7b6052e4eef2fba565c8286422e30c630f7bdc59e78d0436d8d84182c9722d9a340017d0439f4f64161223a841fe298ad8b1f8aa106bdfa9bd4f7bf885f852901001ec7672097b5e41c4ee78f3b3e0dd1f74614283cdd3eeb688c546e7f5c2f7bb9d7ea9e57c4038a7d5b59bc5e30e80faf64bcd4110d1194a303b73c6a70ed60045e8ad4b55cc03faf3535fd3e0cf4b1bb31f1fa1a888da2b4801baa9667ce75343e5e5a533be4071a89067e9945c92aab454ca6223849146bede2ca4bc8087870fcd54f6786d0c7abcc7faa056b1c27ca41b23e45b0e64591e61baeef044206e5e32e0bdc465e48a778d79294ddbcc1c7e2958f99fa375e497f8a1d287236b1312148e5b9e438de61e8ebc66453cc149170be10c971d3d9750fe7a12a450ff21196bb424069415f18390a85190098de06ee09720fd0127a17d449cf882a9c0cd11a9cd8e6714a2152034d593fc30a8bd4a8aee4eb133e1d01dbcc6da8fafca089eb9deae1b4692401c3e90f3ffb54cc70827ef0e75156142aef3c02c6780e0e19c6e24dee122360fc1a8256f221c5a1077866707091e11de777f1c19a1809f4c263c10fcb201e4f640f27ae0fcdddae7b0adb8a989d2914a94db5c7addf47147c7dccce9d847cc249637f496c31b71e872c5943cd9966198ab4ef0ffb0cd1d3b3eb4336b837f70917075a6546336a1480cd984a669c43724ba8ec8d4933b00314ec59a7496c75c316991e6ee12f7da4c3e3b6fdf1e39adce8f459d64329a402e4ca3fa0d9ef7132a792dee5b8fc69e066fa5a27b64218c9a42cf4198bc640be2d2da2cc16c09b6e602b107c1a628cc05384bbbb078255b42beb254febe9064adf638f28c25b5d40a54d61690a9eef57d0a5240904be0f948d3c92efabf0700e813544e9d580b8b0c620fd8480327437071acdf50b8902321743b028b86dc6cf7d9ac232af5fec72b636a01edf8deb2969bbf00560032d827b7f41823d65665794d6cbc5b0200bd5e024200a42c38a85a26f1ffff50a5aef2d166da114583c42fa39c43b7996b419762723fa824b4550be6ca234cc75c45f3f2ae618964cbc4c3be5610271bf79d181231201eefd047c259b3bf599693300072fdc7c65c4b7fea4a9541a35befef00526288448950d52a9d201d58b3b8df4e31692d8fb0f3281ea56396f44f2131bad5391a411d548bf907c5e34b443add25efa39ab0a64595e06f5b3e0cff1df86e87162fbf274b309777e78212e2a349f70ecbff3757853121dbd9dd2cba6e882e4bcde40f9196132ae96e92e27b6b397363bea8410f69d4a026464a8704f9170d020480b79452c6cf261bbd9755079c153c8f8a3231cf0e6edc1bcba3dcf04cb58a0d4365931375a3c5f3b7ada3057811edc970d53ec4e504094865d2dcf039feb70d3e055e3952182f911e499bb8a2284c4592ee31909ac1583a3db7a1a1a442c62bc06de4ac598f0240bd8109354b33ae5936bc4ea64499fef72823afce5b9a71347c837bdf5a05048d058651b52ecc670b05d0447333c3fbb21ef7b76d8f2ba86335ddd67bbe13bfcd8f54fd63e02bef0202601f58770905a95314f50e349eea5045be5564180902b60d05c008b163c25af2caeeb6c36d754c50f43b39d48a06f8d7ac4ffdb84cb686bd10cc6c92902af988ed261f4cb2f11a175179a828cfbd7cc31e802b9746923f2b81c9dc04bd8b8a783a1825d65d0ac1eb277f56b487f26fa7a1a213cb6282b725f065bf593eb4575d224496db3a36def61390efa355e44c2b6bdf410171aaab2444b6a8b932fbb873e4518ac0cae8f187503301e78273d1e5ee05b934be200a686a153f7be9b375df9593031e0c3949cc9faf57c20f2c107bcdc74a56cb8a24ee1fbf85e9881a6fc7d1ac4a62427ebc70b81650dbae85fba675673677c754676df1a18348a0b2ea21ad73f8a1772a7ce9e28cf351a24c568f69f8a4c9de416031ad58446080dbe851f20ab88195b37dfe613d8877c9d80d747cbc72e452e53cd49c21d2cbfa796cf3d30fe75e14cbef375fda46f4af2836e6eb6e98c449ee9ea3be56fdc02c6cabc8e71bb96dd098410b99f89b56743e425ce9669858102e4c9bb7725e96da8ec2ce5e195bada5c05aba44bb0820fc5f6d0423dec77ccac4afdbad05a212fcbfdd144180ef6f144445abcf345c751a2bd933473d26811a3b32539192bf5cb06a72af28f7c7c275d30565c16d946a3240c22ea72ca218316ea6b1b7230a11a4c072a687d96f32a8884a4e2477b2d3287a91bcee90250afefce8ca64bbb5e16f711061c33d6a33306262a2bb7178b66f5d3fc7489a833b54fec6bf4f9fe917a0aa8dc53c03c6ff004e58823b4007233e1ea84c3b36ceefa134e11fea522a5d09bc708cc465110ca660a73049a60bdeca4c0b5a42c73fffdd82982926a2ac16a72ea1ebd4645f070ee6e4431b2e91beca817181a0b2bab7d8ec762ef8dd6d8afd8ddc6b59cfbd3d3e96342a240b7ae021aeb9dba6eb5bc4f5225e512431f5e4c8cc6f7b4468618dcf4ccd466b3ae84091cf4ca92a33c7cacf3965404852bdbfc4cecc4a4f94cc1f4dcdce0b4164e545d8771598536b646bd727a400118b48c2e776f912c48e74bd2ea8b0bf071eebb2598be72c9079650ec0281c2a6e4e92df19213605a7c2693b7f08e41b48452d8f0522cdeb1b694f9fda606fa41cc2ab0916bd9a824f1f3e50f2436e8ad8c57a2fb1ba0461bd53ccd2c849cf6bcb5e0956a5140bad2d4ebe7a2463be70d89bb2203e280342ede75a175c5b9971395fefcefdca5c85c8ba0dd3a304d28510c40a5792335edac51cc2da355f45dbedd833ceedbf29f1fa2b1aa1041c7ccc3e4539514181920688f96df2c064adece58c613586f934a55fec0d29a46a5d0255a441fa0c5d70f7b659411837be0e9023d7447b55de71663b9cb23aea71bddd209548ea8cea32bc224bc90d40ec522830112c89c1c7807c272f381e5c3be3cfc49b9c495a7eb4a15108834534e3ffc4e06778a8a14ddd52ac46312bc434058f1649bcafb9fe7f1e7dc702c221128e67c2532fba418b8f0c420ea2bbdc26b7f2d3bb05862be9e519e108a7b2369d4d6392556b59ab20b5ba308fdae1ab9665fd3c54f06785fcd21374ba079842ad52aab1b46a4b9cafc8f8f6ef5193756a60d15fb17c52a6017323c1654889ec0ecd76b9fce0e90d1f4e3c1d7021d070fa2de965b60caf27a262f0e7ce56457506a4dc4eaee78c15f6c2b150e2ecb1f5c39c006269bae9bfa321a07584fb3fb95b0060b5a59f44cf40f3019f40ede68f8f05aa78fa158edc787c76b53f467b563f927089a43b50c53766eadb65601fb14379e016fd9d86598310e45fc099b74a9b2c777d4f82ed0cab979b3ad95bd1bc81a40c3327efcde30d799463bf765114ea3977fef8a3165e4d56050ff6e89b4617108821258b5633739212bf9a9301c6e28fa0b432256bb29c29a73d6b2bbb1d1121910bfe97e96129b3832b619cab8d1479807d1fa904b1b20e1e3978c12ccfb9c63fa65d5f2995df584cf819d89a3278322e079ae519889daa1c1aa302b5e3674de31f56728f571cf65ed7c35c50faa8ffabe6b41e7a9b2a8edc293af3ecc91700886abc9b65f4ed51f04b396ff33f716e35e47ad4477573b76f2599b6c7235c59d53b458da0452ee2e6d3d10ab2269135a25b05c775f56f3443b454c0a82649fbc470debd746698e25e258397435e205ecc0a0446da8ca18a71042e3d7ae8905434dc7ed6e62bbb8dbe596b80729cc1f91e46000f34e8887b0f5b3d0ef8e18e44407207bbcfc5c8bcc7ada8fca467445d979db05f6026df6d12f8703cec4ccbbc62def8df9ecf5bafe267e985e005cd999bc1819dbc3e9f9bad6c96c1bd47e30fb8cc12af9c8324ea7596def23f48bbfc1551c207dfee68f7c16bdf1305d5276dda9fd0307c824caa062624718f7ee3918aee09805a2268252f755b08381e3d92391f558c771722ea7589939264b5ca5c6eb97a16cdc6093cbda3a86dcc2a0efb78aff43711d859a1b7b557f05802ef6e9daf344ca4e48d09078fc7d6e936e1027cfc76261e44ac02c81e8cb42fd3a3615d1a8a3a201bcf2090d8345d43542b091471201dc12de72ac6612121f3d7722fac9e036e1713471d46c7899415bd668438d845ff5b8246684f5b2fa7fef06b1cbbc760cbd089db4fc8d9db79c0df38cc8ff4ebd000aadc84dccffa197d6e412953f8406a11f229419f8d82d0c84b7e8fcaf09009dd06d46c51f96b860d3aa4e4416c818b4984c0f52807a34d8d6d5723135ff775fff75588f62eeaab5d387c437a92b810ac0bfefddfa29dffdf1aad6ad9a6ad51fbe771d768d68a7aff59b7e3b6c03c251d9d2a31b84f3402864fd030857432396bd338acc3d34da3eba539854d1fa166b9b9b5a8900d0988bf0c2b5fbd7994b76502558f26de37580617295f8ce69ef3fd30058ba2befb694564ff0a425bcd89fded6e79cad94d6080bf93d1a1807df836712e5d2a10e65c5277fdb34083ecb3cf1564c40a0488d33365809e3d3b20e78a636e7286f2a44e63963c30775d453a5c3f1028c6bd997906d69580ad967a92865ec0c7b74093bede1e10371759e1c22d6d08c14ede0779eacc691491fc4842254a59bef786c5e469b45790bf400c56912d26168d428c007f9b2f2750b2a676fab2b0cae7732b5818f92c71612b8a590f09cb574a153921936d86454572ba8c958109a67dc9b047ee0d4021088060298d4c2e387d42007815076ddb9355c93b2c9c55161e3855572f107d1c9ea9e3f86bac2f56963c1357c209668157608c375cee5af11f53e1ff27ecb5db026976c8a61cd1d00371f43b5af7493a9a4bfa6a9698a24b57899cc9b83126734e06634c2ce89a7a9ed63f4184cecbfcce07569a4b60e23824cbf6a0f419bad8ff39a34d66a07e806d259ff8384a0e056baba7dd36bf9ec4734a50f5a7d81bd132b545fac7c1dc6d8e9ed91aaf286ed86d42473ea8eebc4f0a2c590b7311bcf70b25e957f157a7b998c4f1cb252808ccdb37dcdf76046f777795389c8f6e13dea82fc34f6d02c61cc55968f1d607620d060191cb7e95675a7ed7b48cf356d02d38d3c612760ee4bf4534ca484b23e651d79d778ac05bda9768a48c74ab0b7bf2847b23f75bf40ed355965b7e4976d27a506376a90681b321eac5d945aaab99fb85a31fed1525042170f146e2f97effdfa99a604f6a35c70aa9304f1751999ef0c8e0cb3e81dd2670551e27601e1a44005262fa7b1f43adf799faced5a64dc0cdb1ccb3d3026cfdba7053387f80da62afc56faad6d77f9d67e2e7f3b0cd61b366d5fbbd7a216f1b53235d845986fd17e723fa38654b6cc96d4223bdbe08439b6f029f3e9ec11dc8e23752b22e982949280f4ec53ea8feeef34f7c4297bcc07eadad456e5bb9d0f9fa05e22a82aa5e7fb1cafada7d0ffddaab9caed3f57dc278f9a0032142f78c019689b746b2f49cd1b84bd30e7ca8bb607a22f052c67b3b2de99731cd5d809d0946ccdcc57baeeb62a5838515596bbc17c139318de7d8ef09803218499525bf0aab53806bd6cb3797a09cd263774654e5046fda83f030d51935d368309806014b92ff3b1bbd780c5ed2d419bc40c7f5c3294c47432c156f40b59877a0496e3b5ea5ecf8ca246a2dd30d157191adf7c9cd9ad15d9353caa1ab802d6847aff9f9fcc1a5d775a9a1e335b13c4d56cd34891b44a9873429e99acdb932c51e3c1446db58170027234c2c31de4e476cfec7ff885cc33c5add4be9a601389437c30db7747f2566469253ce81a367e2f862b4b3316a4c9e49a70b846d55b54fe47bc4280ab513a558f48d2f988c79963c6fd7606a90db7d402cccebf5e5adb52437bce4f734bf07bf85c843a4eb661d117804c9f1af4cde034309d867629272d8643646ed95a7a4dcf5f702d5b03115b822b9fbcc4086b56710f7696fbf115003642a03ea68b13b8f83780a36249deb20cf950b7e2d7f1628a19b11fe17379b2a1af897a68155ff9722b1fad0179759992cfbe299e09d2352675fffc0ba1a99ebe3d61e7ce43b62e380ff0427bdce46f7e6d157e112075fc435873f287ac6a7da39cb598ecec819045ef11fbb419d02b6fa8e59019aea8d923cc54ad7bac4196995a5829db0fed28efd345b3e6871ac82a867f175ec8811f9213c39bf0a871886980afc2d716f5968a9114e209c45190e3fed249dc4724e86aa342370bcbdf2fc7696e2b03acb1dc46102f504e74f548531e69e1fb5854d8b2c3bd2d20820a76971fe2b281681b3e4c70aad9b300ab63c993449d88ffb714cdf5903375b9268df1bb45536427c7794e12fbf41eb9a97708c75d66ae73e044bcd8f65cf82ae1fd18f9aa7c2cb2eb28c6d3dc4b358e3599f16ebb51c4b7eda5f7c4992abc03ce176e0c1a49be23b9a933afd2f44c4b5df15aa75390688b1f416764d0dba8c24d059a96c61479c2607d41321ab0a0059001f23a6df6f5ffb74fa555008c0887b7701f72951dd5c14dec856d16dca91f86886639d6731e8ebbca1fc2548affa55d2b3eb82b3259d20f3bb11b3ca07cee36909b1ba51f486aab87337f3ba7cc8f108eb7f1e804b5f0304a999de86d177018904d846b5d8e673c8f775e7682fe2e6ec4404efdd03da1c7befc2fb16489d7ca8ac6cf41e24582edf21267b8ccac1b1f2ad5c6f1c42bb0eceacc68fa5dbcf0c46c7264a5b0cad5ec030ee47f808377dfb3e8d1e20c81616b64aa0d196ff35bdd714ff264ceb750a177da3015df141c63fd218d9e942eb102400f3b8aa077dcc15ea69ca49708451da33b70690a765890f43749f8b60b689a309181c69306ddfe7752e3b47371162c9a36ba234eb52d58af0d6d037aee357f837419e239575c7c0b907150ac8539c112f9acc693e006835806415d7f4df26992df5a41fb23163631b323890d0102938775059766e3a51dd2eeae224f2834da566b092ff5fdd2dec8ab956b8dbb8b3e666443351f46995e632cca455981a3dc428e51813765f05803cec4e3531555dc66cc0f2fbcca22806c0e952a45078cb7dfd1ceed8f044567e2f634e912ad60b43a88fb103f112d986088923e5c38915533a16bfd378f9353d42775ae4b5aba8c1f05b41c294455ac6fbe12d93d83dce1c7777d088112d3b7fb6328f0b95fea5e503f0edf35d7ffafcfa12f07b1f7fd9b7ed0ff942d97913163e1c0493e7018062cd9b94feb1747f72d36664cd54302597dd815b44368393236748cff30296e6922676eb02d7c4c3552fc5be95e2b3ac1ea1180eb58e7834340a3c08509efa3596d2b37a3ab40ca91f30937fed2d47c68ceca377d6c50319bdc357bd3529594a88e1efd5568fa790ccddc7492af17a97f10d12670d2b88d14e8ed468cf2a81c50c376fea49d4e3c1e40662eed8c272fe3618a3dba0eebb3cc031d97c5d87fc9cc7542412fc8adcf9a55bad5253389fe03d2922be89a6ac308faa792eacd3c1a740dfd4cf2601df9b51a7a38c6a79b8f9c72ed6ea35e5d4691aba4e094011ebeb0bc85129655521e56b4a0970269e675b6424f209ba930a1d885404607340f69d65febc6055b9caf5580d79dd93e4626b6bf7a0e646ebb2b86f74664b2ff2609996512fb83579b68f7e57f8fffe49af8e21518bc0a42607241895139eecb155364d53b23ffa1922cc8da0fc51f55f8add804c6fbf4b7aeb001a2e145b34dbf4c2ad53a379df73d08824533f5bfbbfa453e6c5ac9e47eb5874fc38d3ff68b7ae1f3b9c0e58080c00a5c2c2279b2ae83e343ed1b50782cd7b98b021faf970e5cb02538af76e7c1fc0644ca62c1c72983b1c47d13613c71b5e62185d247487c077688993f2b54fc4469c681c85aa740177dbef500882dda9b71f5d50fb2b4031f01bb2ebef0f6b5cde2c888fe4feaffa9c7e60bd454ce57f3ea9e023db2a4d9b50192ca0389a9324236e4e9bf9acb3a162e9b32987ace965a9ca4888a8f556b53e3284a73127160a25dbbe3d013e1bc590885defc1242bff56b8a0c247b119e6c33f044ceff19139cfd4900a300bda51088ff963b216c60a4d0894535e0c64a2bd0316e355275a90bad71a628675fed6dffe7b355fe1d46716b6ae2987ec2b451fadba56cf3b08f52b2a58c3ab0251a21ceb4c909ca4277763275389350d387122831d8c1c46b06159643174a952995a4cc7e426ed6da20408e798c00da83671876ba7eb3807718f262e4c3f9da11c42bc7f8d0a4b13bd27b965a3d2b6b17268b708ef6d0ebd73215f5585bc9043a4fcc285229980fa8eb70f2c828c95949f608f4b692052582810bcdc2c5c53613b0dad50f3fee7cc93a5ea7e3f0c99c37f0ddcfc6785e1ddbdca2853e9022bb994e4e6307a3362005d07d7de93d13253b4bc683edb9fdb952c46ef867c537f9c7cc60d92ee278008eea31aae19ccc4281a5f10d8032d172ced249f3733276c1dbf8eb1b9ae84aab4a6dd38401ca0b24bf5197a0c1319fd3cae644a066e1d54a44cc127f0e81379c95cb85aab188570c81b7c0b0fc4e8206ca183cac2fdccf7b63a546fe9d29db0b5322e0077a4ae01a85f9e4f5f1c111fc2a6b99341c4abbb9ee3f5363726e81489b06282e85ec819c6fdd85793d29d1120a7617a3d1826451d8eb71b9b3be49666a8724fbb530f78372f7ddf176e2c2185d5f41dd427b36125fb52677cf4ddcfa4fc740a20c898dcefc033ebaca67946cde4f632908df7e115137643c3ca1c7eb864acb67b07bd8a188c04e492a186ba9f193127ced3509e391b93f82d6288ee3777b4994d953555ce76770cdaf6b5fbbaef35209feafee04c9002b04d99b1bb0e5170e1107ad196f92c803ae3d15bcec4485ca04c79ab196314c8c91835eb36a6bb88c00973d82d7e1653ff898a2d96e64e7a860af9340a541baf89aff2620ab36a22b792ffea9a88c91a77ba9917abaebf41293ce6b361cdd5b9663aa1d5462c7e5079c4e48bdbe05529d3fbd30605f3f6dcaffda6a6ada978f49a15b01bda65f9970138e803d30568b7ea0d585e86616bbbf2d7d0ea8d4b79ccd511eff6209996ce9cd6f9a731e04a122bce2f4300c4bbf8d42269ad23712880963f0b2676b09379858580265737f7271707f874b65b33d5f98a02ccbd520cca739152a0964c2680fa52146921881e216a8cc42f1625b09406e2b2f05282ce950f19e2421c08069816a280375f0deae605abbb89255360c7510fa3d98bfa9bf670b1e8e1bd8923d3985ebaae6fce34818e22b279ddfd710db1ed7d225e05b3bbcda1608bd2c60ed13253d1d1e98cc5d43df49a492534f6b2a31531f1d2c33685e78910cda26c9d3ab0b71d68cd86ca1cd687a690e3e2a1e591f259a848882168294374bc5fb18f2a25fd14f035d9d2671bd367ea42bc8175564b820d2e808004eb70ced5d8600c8c38938e2c2423adda2740e5e66445f1a66a34cbd172e1c4cccab8a2ffad11cd3b10ce9151a5ab156ba1cd1c5556e549dd14949c17f3871472188aa7316b175285ae08dcf8a00db54c48d0ee7fb501cb9d494968a1c4cf88bf3443973ea4fd0e0860b3f6773039cd1a4fadc1138522f7a3c53eae66bfaf5a6d0a92b69bb537396cb009caa56046ab3ff8d7cb9c0ac60ca3f4bf33f2e6d40433eb003f262f077e236b3c50cef1cba4891eb7c59678fe58b1406d289bda84099d70708bee1a7ec2fd0f459df54c66197931ed61143a42d92df08f1de14a56b3cd58ee2c0f0baa26fb0625d38001ba3bd36cb136658d170a1bda21ba17937b4535db4ab7553c3391eb33a6402e70a7df4a86785d74983457d33b0fe902c1fd70d2703ecb7dd826fa5523a596f91e580aa01cd3f25cb2b84e8cc5c22e64070d1c357f59dd43440def86ef301b9940ac4f46d6eeca7543a4fc5b9483642d9f250829b2ca30f081e24cacab088a8d2d542eb9aec31e9ddc0fa4fe622777687cd8454f728d3015762343726a18ecc0ded28a8456de3f50781208aa4d245b7151d8cc8390ccd5f57ff8aa365c67685c657c3b0847b7fcb3d78d4a527684ac156377ac71df5f203917b97de3df19d7100192a2e083e42df28bac6d226b3551cb0b11fb3c438e075205662dee33aa1a0e8d8d5f8b562f71ca5c96e22d1a59356084899b99cc88fc773511e470ee4ec53c6ae14c9fcaedba321bfddfb079a64968a0031fc162e1c58834559fa469851d3f819ba334b1bbb5d6cb7ca8b166e4bc18b7c77c445cbcb1892e7223a37b769eb13336c80d289ef22420634bc2e89aa7a283e8618c46c677020159417837e7316378460236606de9bfeba7279671bfa2de693d059929dd9c9a56b43eccccd862eef211439cedacc92cc7323a5b7c95242233045f07850e009b8fad38e378408404dbefca0411f22cbf653b006a5ec26c4a937b4273cd259c493e8ad51b8552117ae06979e4597ce30984fd345a84be67122732775f342cc0cf2d124c79ec6e669d6f406fb7b746f873e2f2ee6a2ef2385ea37ebc50e25de3f91e6f5c2aed1a62b56ddc71b6984728ddadc81f0779391a02240e82c05193b1f2cb8d0800b014c2cc652c1fbc4809b9eb8ce7f79d10ed71438f4398501602af4b56ba6cede5dffa11def3d7cac8d7a2419bb103d43b2f4509ce230022236f00b1a22d8226e352fbfbae0a28686cbe0dc06fc4df12e03606949bd11ac55a947f9ea3d12b95bd52ba2bfea590dda4f1e17b6b75d668d93b3fdb6bda54c3d1c697b70bd1aa4c7c004ca0cba73b6797d248d4b79a2070ee310c352d77da7928a31db28f2dd1ae79b7fefcb51e2a9048a8b71405e867255e90540546d9ac07e7cd53ac3e9bdd1f80aa54ae029349873393e73b0a91c3306b0df1c1ddf9bb1dcff9208ff4e82c9212d34b96eb1c08a28648af022cf7c651f918351323bed8dad7f1e455bc477f6439566200a224c45d135be11c22ff494247af4ef5f6414ca7bbb03a4eef0159bcf325cce69f9d5cf05d5a33257e38acf1d866191d300d54a23e51f625e763b2458502615b650a386c4df9a5fc3123cc5c16bcc86de971262b547926bff7db430212954a8eb9275c73a7dda1ea91d0122c40874db06191df8aad0fd74aeff8c1d812241caa365fb04614bd1980c0af7e3d17705ab958d7c0b5bbb6cedc66ee8722d9d7ddc39529fac5a1b38262d43430ca4d47cfd60c806ec742c8ad651cac8593da575241850618b200ee1d83b390035c4ced8ebe15d59c7152d3a734cda5c9f777c44795bd17e1586de59c1aa5a82aa9608d76402740d75c5865d1c953de5931c110346cd46ac34cd3240e26bf572748d3aa2ce6527529c58659bea494d11bdff7b1d07ee51cd460f6ec6a3cc3170d57fc5a94e04fa597b43a7efc7cbbf7ca4e1ab1c30610ae33094444b2ed0b8e3c5c8df1ab30efd149c745168b33fd138e556f11edf36d9696bad7974dc46184a067100581e48e499f7116f1a7a458c6f97c20573fa14e21a3834155668783965e0fae5f044e13a3946937d564f3cd9a4ad955dd77056f065c9463bb778daac52bd5b020f7c88ab4df42e536581220ec96d7b453d271e1f06f3895809b49bdac7063d1772408e164adcf5c694a9f5eec2b81a83c9cc0b30f79d4f3dfb2cbb83e1a68757d62dd64a9e562c4ec9813851de995c3d425a75b2387eea60182b4f7bd18ac2f8aeb9a202d3db3ed4c4c353b8cfba9f6ea5c45808dee4bbd7377c9f0cde822d3caac3db823aa667c5db93628eebbe107ba7a58c2a08a17a1e87e88c3f7c4824c88c7a624b7e93730e4100d91eebd757fc4d08c0661e2b5b7e264d5777a390872b11e45ad70f017c3430704fe49b09824b6b311eac78daa51c4aa0bc24dab35cf8ee82463dea0cdb20e5091fd494b0ce919aae2cb97b6d01a9768d9bc70cd17a476f110bb95bf34428a0740127d71d8b8484321619a1524232d59a2374494e8e954b28aba2337397885279b0f20b8f88a2a1eb25a842b4864a7f968805d2ff240dc7c2ccf1f272785aeeb17abc7968cf906e131d44a68dda00d45ada9944184b85a9a0f4cef95bad891b106bb18dc5239fa9c37f35879fa906b035330839080326a0268a742eeedadfe23801d200d0ab94647784c77894a9a1dcac2cffc296ee8799c34845f7046fb0748995ef1ffdd530801a8f266e6117b3ba5b366c2c2517c83e5cf9dab358b30d8f83e14dc4f624e49988bc10aa92f467eab9c3e09aa192731aa9935032686c86247001a3715d3b66573cfc13198a17a0c949b13f93367c0fc2850ddf74ec8694e5eaec6fb63742667a63879a0dec1672fdbb3ab5434c12312d051bc80216c169e32254c02877bb4008fe4c63a9ac8d76abb793826e9ad4e9c285c660c3c9336413fcb03882bb482de13d16264a0c40bde59704a3d31a36a0b4174f81788198ec58f7c560a039885ae743ef3d059b8c66c6d8cb353b8cdbc9cc52b57e3cdb6946490fa98bb3fcff34872c1df7f84e313bb1fdadf614b16f6f398a66ede8ebfdf33bf9c9a002d73c0b0ae74a9aa17ca713bfb7d655f27e1e05c7d2b3f7cd66a839bceba9f6f9709cc89ad22d359cabf9702b7fc58263b31f00b7229900834b6c5b34e9c69cbcf73009b228a235f518c42f8d8f8b51375fae8944e9cc03e155214576a3b64a1f4e946685ff0c2c7a00b6aa809c0893c53aebc44b7db0a5657e8b625c11ec9a82a7a6fbda443f02d0c6c2aed2956cdc1704265eb6f55936006e38be65a300069006f6193402d1c16d0f74d543faa837b87e19411b69c01cf799dc2139c6e06e9426c66e8722c8eb7bf3a9d54a8c15a02b6cfb76e6c5d507abce92cb541e6f1c947e317eeee8314019613f347229d8c61b3ea82cd3c2c5ed016e08512ab56a9f4ab8a0e77b5d9c089b3ce0e594fe7b3c064022e6c96960988bd13a60a420b97fab179e46b0499e8145f7674c00671f025732f5f547d00d5a8cdcc5dcc459842ee2a15b7614259fb68205bc45ec1df6492174ba0ac896ea88047cf029f6f6d604c5761be206e086c966a65ed2462b26c2db7a0a3c7162872796e470bfe28f938bc71e15f38a56bfb4bbddda23c7299cece755731af82494e428350ff7e49afff0ce9c609e250b69ed54b32ab3b8eeeac2a4c8c35f58034516dbfd85ea14086cde524e2bc375845074fcbbc81d18b70b21e53c90e25d27ac9cb8906f6afea541b6bdc92c4048712e70182d9adde4c617eb690e7286272622cd1f14713a652cdce46234bc33ece09bf6c09d11ee46a309f6e530c6946fa85e23e34edabe0fb3b250e2c2b48bae811843d974f8d6353262af212fdf46c2a48a3a32741a7f835c6e2038a18c415070e4a50619ae0fa03c4dc32432ecf63dff697e09d99470f6b20eea41f4bf4d8e6756a434504fbe095d1800dad4b0a8f15eb848433c7993932352e64ba93a81fc201854bb032f83f1d488d57e70c15b221c56890dc064820929e7c3851860d8b8f32d9097638a2cde82be47bca704d80fc5d19e2110289185994c8d185eaf4ed2ca5cd0c6db473aea77ca6dd51ce65763a3535ab24d8253402506cac3c18ea6e1c16fb99c3fd5d355d7f4d183dba297334e048ac25e18968d2c340d5a3fd7d66a75fe18d0c4752bf7491a805b4f755282cb5f82308c98915a6fbe9a553b2dea705979268b4b9c5b5066d73ad38a41e275f8db4926f29fbcd2903082d65def9f28990fa8ddcba501dee97f684e51fb6163a4d0d17154c639a0b99589fc428d8b3f17327ceb32f97c35ef3b41aff6bdb59aba5e049c3ef257d1890954ec227185f426418ebd7737f11d5438378f2bbac5e06232b5beedac48cb6d3a638a2d22f0ab7c54e27ab025462ee6fabfd42401b2538e418ebd531c10bf27bae077141d634a5455bae41b8855cff5816759435310348427b1cf4e45c18221487a0cf691a38e79729469e4d910305e8eace5a2d5fd7b3901e4cd1e42a101cbc1a4e35e79cb2d983a8c509befe276608f0872c7bd6c6bdbf41c5866f75c376b58bc391bb993fff36f86dfe81a921313bef714339a42758276b9452275214d6057527ff0ae10b97600cf329df528057a96b02a9837185e3256bcc938696ebaaf20f34c13cbbe7f3870f1bcba4d89b8677ff82aa5d93f0e0da3ced4f01fb6b205b5c05496161d0b4afa26acb3eec8698dc3b0918d838b1ecf413069d21e1b56fe5afa812d3ae90fb51e4bfd3f23f74488e1f90ff9bd365df888c85ffe7839c4d676cf8309a8ffd209b792d787d9029e3c7705ff137c6fbe63bf3110f6591d0f5abd2f7e6d812cc601e1b8e287afcd80bce6aff6cee49947184a15fc89267ec8433b5aaedd0eeb28086f82a3529c19132b2fdb95177b644582ff0c7b232d71dd71073fed1f7b8b82230db6b04190919e44de799557fafc26ae563aec2f64ba012fb77f7bcaa7638e588f201e77516334f25de93d9ef424d464d6d3d3e8b45baf53422900a1f223fd5bf1dc2357ed2158ef60bc7fcf804b2db7db597a65b3cbffa7e0732437eba59f31da15feb3bbefa18547d452a10e322d7d9935a81fa5d178660d22886065ebd4d6786ce1b63047b22b64dca0b5546df63d91ace8a0aa6dd0ff90cd5885675455e8f68b8980ad42271212d215939147a5addba2fc01dd1dc94a26610d933f933a163992c3ef75267006c7063a554fb38c2720ca2718d49da4db0a3703e63199f33125a16b733795c9e38e15daabf8a95823e88890f82690db43d57be1baba7e71604a29b8e26291f8684904769a148a847f1858b19388b966292fbe3946866b9336faf0639433e1f2cdfcdc9991398c1d732127030930213065f06c02279e1bdd9e92e37e01970cd1f38d73f4a59e925e26a206793f7c37f2fae37ae90dd014e1f5af47bcca102911d861864ae3347c829af27a47e66ad60e6a1fc938d9e80d38f4c45401da314f62ac9cc0a342c4adfa4d556bc48046f9a03d7b0ae67167066891da9a9fcf773cc1210640e8f1c961d172d4cfeb2daebd23dc116a0b90841fede0c85c991193118ada775b0741d635ad64891e5747ce4c24c230f55b7afdbf7017dba3c24239daaf507943d8f29475576f1a18188492802b2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
