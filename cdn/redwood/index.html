<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b631fec42e80ed1fe9ff0b1c30a6f5c846106ece54cfc045a9617ced1d09613b6d9ff93d100bdbec879f2b8e0bd419a4210968b085ff3c91089cc9a951fba38262b8d69e57662c1242a5fc60a89b9b693d9ba03ab3916fac28feb4497139b76d9a6e41729f6653bf0376480a4ba6803dd33d1dda4d9af2ad08ad74c173b4e0baef3071f9cbc289db0d208a88e02679713370c09d403a749cbc8cc9d4a162aaf3d5fa94c4cbb58854d7428c2932d4663ea1352b4acde7a8ff6398477439a56dd4c6217a6b6e431538cae57c1a9844aa0559b3b7cf8dc5220ac965653dc07e61c9083533ce64ae3567ffdca553d792e48b43326f2cac3dc9806c6c4709e43a573590d79529c454da1eeb64c6cfec718b7f48faddd3e5ff19c292b9208ef4fb5beeda4f6a1df21a7334b7e25e76a1ef512e6f735c30d68154e6198a5e464762d1375dd5b2ec97ba8e35606b6bb209a18e528d55b0702c9edbc6508fbce1c063b0850d8baa661d107f0468caa28dcf8d703f1145428dd78deec90ae666cc9ad1f7b06288af7fa0ecf27d05fba8c7e734ba3e922711f226632017b0388b80e2c88f1e8f4f630e3721b0a78ffee36f62a3afcc8ea42ce332fc246f056c33b6388794be1b66c986829cb126617b5569e249e20eab8af5dfcba39a2b08f6e9a92f94a7b19bdb646d0575abb33d21f40996c6c24f8bb034cd7247c73be628c15f3d4e248d69925aabf26321fa0d410f1531e9b8a4fb679ee1fbbc8d3f83d31e149c7410210e9a8c0b63a9cb3821eb3cae22137b62da89195a3d191a15e3a1d5b31f984a784e206ab064e0a7ca01fa06225900fff4e0f9456e3a7080d3085878becd2f2cc9bc5948d77b234b12326b03a24f509af72c035d007e1f1949efdc3f012680e6f4095208ba3e97afdd9e9edf0a6fd20f823e2d49c70bc6afdf688ab7a980b762e83605c623084acaf2d81d2469ce4bb6c6232cc155623f2be1be97c5798b563b03ad55b1b538b3b67fafd51877e17ad5e656b098a616a55e530dc66282dc4b34e9cfe8cc42ed058ac00cf33b46054af9e92b2a3ddabd9b2bf4dd3c43c27af1047147e5cf345e77ec218bc127b2a711b22ca243e9faabb744924b7251c15aeb6a7f989f99204f8d2cbdf711317e14b216273d34f71f6014440f660f794ac671b94aeae2eea8ee7f43ffd3f8dfdcb75225e85e2c883f319d1fbaf8cbdfc74527314c88908774e9a353722b22b87c1957273330da6c4b605221f60860635ea9cc0d7fc62b401f602b552334ce72a1d162024c6758ebb3b69759491c03b011c34ee44eb04d93b31b7610148f6507a3e0b479340cbad139ccb16091dd33d6f402fc4747ab5707236492cdac6bc7292ade1a88eab5e9966a245e15dc7fb0f4b6eec7bbb322e97c8175a86a4f4b63ba85d6d67c33a3691c4dce3a0ba6ce7ecb38b9ebad1973bf8ab586cd6a9659fddb0949b1599070128a616feda5bd7602a1090e8a1438803ee5e3b70f3bc68a7787053f0a9827f1ca27026345493b3217c4fbde118ce921085b88fc02fb8979a8ea6d1e8a206cf76ea81fa09584098ddc8c3f78d511728b23f8e4f6949f71cd2f9fa18dfc451ede03ba056fca7c70fb43f88246ee79ddec17113eb178d865f2f3de3e198138e39f0cc9d1b24f03b3fabf0045e2fb83aefdc00a27f8a2db37bb3b9d154230780b018c8b734bff621586e37ca3727e5aed56a8902900a032b6b55340320cf27d1e2b2da862660a96713e12ffbeac240a80f83915b981bb25aa5d5570de403c4f11a96732ba1d5f9a51cf4f4b41f151c7ce7a2aefc49eb6433ff698d51b4a1718e34edaf1ea4196b278ce597af9e9d9007bb425bb76a400be8153e5a5afa965e74c30e6010a0cf1c1691d003e07cfcbcc8f4decf5c4d7db78a313f10910a8c0520bcf872aeddd455abc31d27c2ba50b5fab64df364c397414e05b4b29792992d5849114dc6cd9cab095c1b7677bf287938b1cdc3f892f948b633b4c4dd06b024f6c40c0fff5ad1d0785a025ef8a124e9a2162c1d08c1f57d10e38c428c4fcb98d6d6e26fff19a84d81070334136c62fa29697ad624485ae2bfe9eabb177a85da25b7cbad10005e00b35642f66056b0f751104266b8d8ecf35146d946752ae5c0f72d19485656a215c10016acaeefc96255263ec31403f00be3eb1dc4fc424dff2b5185596e3770424439572c840435d50535f9e880382fbd3bbb81ebb1e26089ace1f34e00e437e28659c9431ceaad4dbbbe7186a9c46464b375848da01079b291402670ca72e86b264942fe4caa780a8ca0cac9e3cf03ced9479e427a42fca46dc7c3c46a454dac0a25181e0130af5ef001d7be79995e3a9593715c0f64d20c3d8b5bd3dad6d75e9c191e1e9fbcbab44324080eb09724f4a9f9ac8fc3822cb7fe59df7837f0e39b5a3af813852fd38a9de650ee3706fb062a9e5d3051064a813588c3c4d08dc1e94b3295ce25c90be45068b1b7986f9fa8caa662a737a64d733168d238a6347f72c0d8ca653f468dbf7d131740dcf3d184bb7c5961c80f73d74f15933c03873380eefe6f796d7e002e565aec66d77e16d9323079cd516be399c6a95834c303c649b92f06828377fd4c28300c242a4ef2469c46af8022c9bd394e49e677b1b16787fed06a64d6593bca2f4a6d5d2b6cec98aec6c58e4ae72df69e3e6210e3210414883ed57e7ecb20634932bf1059f86e529fe162dba349f71c0efe178014235fe0a0d09b68c78e90f4997259ce8c6e22af3add21e7df339d41f1ed1ce6202b31c63c9721376b5e8f9a720f4a63852e5304500189486c8afda84e17d21c78d5ca5a39b8e91c23ddd47a2f213b4c106564970f46a81635aa4dce7359fca05de5ed607b201f39f34f642a6d77d453236d6056866f8306426de383a60b22771b5e0562873bf7a9d2e354a3fe0a3325bc44e9b2f84bc04293d220c98c967560134a264c759e6230e6a2eb21148cd5ac348c083563e400166a2b17a9cd1bd612fb6209582f3d90c64c9a068dbaf9fdbf444be7f30c5f4c0af164fafcf0ef20da07b89a23da33e35097119960651f46de9e3c9df0ce6800d10e394ba746922e99b4bd2db911897998ccbde4d3617c044460d87c703dba5659c75c37a6c862dc57c90519716c434afff3078c84a3584a398d6b6eb22dfb1f53fdf0462815cca742db7619609c2765f8b58cf3c3c493c66e49a487f665eea67131a73ac9bf720bae0de3b3f905652fb47f6f758f81e538db49963ac1f3274c7d38054e868b03665b968dff338cddd4f8cb52e3b1f056a90924b0f2a4c9dda6cec93e58faafc94db91c55ffde3de8441ce549465f34979d9dc41cadb39eb725d08bfed7dc0ae489b7e4c4ede0bed3447f9c906d5b6fa8419adeafac06b658a1cda0ada37be7310cb0462332e514a08d6747fec88b03e0f8218cce00075f2635248f91bcb2b8a0a54639b40f149d3699330b865f2108d7bd541e44cba83eee31a3ae019fadc52f89af85719b858116284e17dfa3b4da2a3d15499369ea1f17da05718f7486a2ba660fe1e10bc7fe042b3f3d7f269e7f27179d98758a452c55aa54693e78c5ef4ea8eb3b3d3db9933d84f257525e6dbd71e935f48d690443469bfa02a8c232ebba66143a287ff402199e4f87afe5f6e4607baa4e8c66d7bf6b94dcec21b2968f35fb985e0988739b525fc24a82e72edc680032de17575c04f583e6042d844dfba465e43f40d2845b0e812e5063dd236f74337f0444f346e6f0a577a9f5db8d0a128a586588a74e9640383b785af7c8a980969ac10bb5d4c68025ccb0349f6a77e027f0351bd41853029c910fc1d1ee66c79e7387cb2343ce21092e604832b93744e798fe9930480e4424fc00bbc789d9caa358d2ba4a56d451f616e089f00992d628dd6cd416763efcbe05c45e65155635d83836627dfdeeedc79842f42999e57381f2bd22b94afbcf75e29366dd4e7212752eb4f275e6c25cdc2f1d8e1296b34264ee24e9e25c9bfc393870673404c82e66019385dcf607887fac2373bd43251030d08dd87511f6e8d1d95fa12ad89ddea0ca871bb6178e27864dbbff24e8d776a69a52cadba84d45a93ed0d97fead91d68d2f72785c399b4cdf834c68dd02013ddaa4f6968d2ff7a9640cfbd97930a65e1351dbf7de437bfcd53ec433505af3666514627a574ea1ff9bdd1b81a7d3e2593a212eb13e394b963dcd2c94981242e31c2936244652b5563bff085d46caf772e485b42eaaaa94935efa780bd71d19cfca310f76f1992d990cd5b38bbacdc9ec25f90e99f2b3f3af498a73e1a6cca6003d38580c098eae2eebdc7a3c4c23f1bca40f61f42a7ffad0c7caf61da37dfb00934a2de25c0a6772fad90ea4f6a65909b0848b8ad02a3ed605bdc0377b2517373e23d711893a86dba17bbdb66fd553e57245e6822389fa11c675d0a77e847e43d957b8b5e0c6e3965a59fd06b8bf7eed96ee24af22dbd96d6ffba4fa23f2596a9d6d75b9dbbaac79f0e6c76b96d9b7b3c108c6236c1c3475017217d573e3f857683531f89ab138bb694e27d1fcca755548120d71298e89eeeb24066da7f1c08b50dfb133485f3bc9c5697a58347261b8fe031e94ec1e78f800564409097904ebed948886bf286e9e7564e0ff259aa1c590ab184a0a0790493f90f4e6a464bd7cb197158f737844bfbb99c1c2fa1081e749ec0d0043e63464017ad2e681a5c1f49e92ae49093d8dde4089ce6245b6a969472d257178a06bf8a59531e8086d6c0b0c8329b3530f126ef21dd9cf27f7512ec04d9dc1a22bd1111ceab3cb9e9b095fc7b5b6eb607a474088a85f0bf7e4b185ee2af245dcc7d1c32bb9ce6d3f3c7babd4cfc50b714c02c274f4cc1489d85c05aacbb14a8f8ad6d76c74a7630f69b4409e9db9df900fe1e9759e71397110640a591f156878220b97dc6f10871381788fb2c452898bce857207ae99f3fb1877c4c4673be2f4e0a164dc34cf2cce88714112857227bb5a9acdc0df7a0842d0aa4e72c1f2280156efc2ffee5ba5ee2e4c8f805a183878287b3057850a92e0d5e42b2d7c35428cbf1bb2bc7bdb257a58b2d1a471367cf2d545508ce389a3a4759cf3a30b1d86f5737e73dae605021eb2d8b1976fee946a4f26671181d7ab3c2f2ca6d6ea4c8a3d50136c564e0c55daf97267e97f5a2af32f0390bff34bc237b56656b34edcb0f838bb133ef17d843b05c949ddd3ef11b62714d1537016285038a14e7ac9434d3e0611f151678dff7d6082cd8b1144ffba576cc2a87036d99ff96e295e43821e7eee647e7288707bf74aad6639fdaa77e3d0a657d5ffb60484320b614cd8096e1214b2ec5cd118d47b8d1cfccc2f4c418ecd4aa7d75ae66b4b9d3d6d32f401be2d16c5198315bdc0890b64d10895f373d399f0981f1bcdf45f15cc9216003baaf8753d74070429bc4c5a9077827138a2f80b12dc08e81829f42f685184378ad8325ef3a8cfff6605ef55a1fffbef9953d51f8dc5690b3908d91a0ad9a6b3713aff4b9d9f4e73fc911016b530c4fc8e4dd70e0704ecc269474ea9731e836a598428115980c87fc49dd8f267694665040f67ca7dcb96fe14ec164a9846404317cf4ad8f39d0a7e182cc91d364373b7b0faedcede95b1945b11890c1471a75ead14e8bece29a65576ee32b2c46e490e3883973247b9ad807ed5fd1319059b5d79beaaf4732e58657f62b30a0d19389f65d01218e1cc251a4e22e81b89d98135c621ffcbf594f71019e77e8689e991c988662d99e9a8c183201a5e38dce569cc46c4c0ad9335f9f2d5b39373d8226f17c93003d3010ab27703d81526c8049f1c7aa53f9e8fb56788f79670324a40656ac922d309297b6f7a84fb8e0d939e8b6804e3e51e8fe659c0e7ca5c260d8380d87b3276f8ab2e98c4fcceff1f43854c4814636bc315deba74b6804645c0c8d0f3cbbc8f4802a7a2ca12f31b945764ea352ca430a13bab7a4bf55883b3b7c8cbf4627f1787877a65c3ab868ff08bfe1aaf1910cb9dd9e1e339ab5fc27beabde4ad85c98b45df2b34c9c42163289bb12bcb8236bcc8153f5f297afaffa408cd3b44a2ce4457c3f9b5395e9bce17bbe4720a8575523ec6be4e0f9468ce1fc23ffefa7e349373f90dc67dc72eb60db98df01d618851cbf3e82e2eaf8aa9f5e7259d1582f1c186db4aa75d7c3f52e9467e6ce3754de7984fd51945cece1dedccba44afd58d1c45cf2124737aeba629d73c4d14dcf78413b70dd2b10510ac9d4a1ae78c095df489df353ef1ae67b8864069858f243379dbdb9b4a22f76770da75c1408d7a73235a0c8cdd3ace01486a85b4539bb38eee5d0e967c51028e2ffe48715ba54ce9f69d9a490160003824fa4c09a23615636788c48f5f3909e253805320adf376435c85a50a253847312353364dc5c3c29ef173af596cfe5b479251ff9295bb310c4297f5fb129986d3c7c4a5e01666beb210f8d3eddfdbc852ed4dd91d1696e92f6d84fc6872419496003e31a536b7f848680c90f78ee1e16d1628e621db5e2e74d490d0015f7d9cfe41a5cb38d7cff255e62e0a360055cca1e70b44af660251ba1ba479c795b3ac6466203ddceb8d20faaebf13897c7199fbc7d9e4305d1ad90ba572f07491f6376d608ad5ac7e56a6bfccc91c3ccb39dda3fb913c28aecb405d652811931db307f70ecad92009800014fb4135f31d6cfbbf3dd86e7df52114a0ecc11af81540699adfd47892f5149a76c54082f5cf5573636b33f286acea303cacc0f6395f654c7ab3c09daa99d2e8247063fd56bac16bd7c70db198d6615e570e966fa943c59c6eab153adae9b598a2c50719a5fb2e9560b56546c6267465f05b59bbd215a08eb68335554bbf4a3b20e62eba0617ccb94d6acedbe2d44d13e8f239fd085a7683ede2d487a0b27d2827782a8fc8bc3ab634a09a9ad977afdc9ecf59d3ec0440d0afd57eb572d160d11915ff189463788977b757651532de49a885721a680506d63275a7f279db54fd74eacfb82582df34422b5fb758a8e9d896dd19a0a6127e37fe0de86b9d637ab9d3b06419b4e1c7c5e0a07025f3b3aa0f8dd13d62c58b80e5f5cb478daa27d6b67255c40530ba2959bc34841c5b3fbb0be861d3f562d367ada0520a850ca0370c40a0041dcefbc37c524040f0cdd433c33cfbf1892c4ddc0c9fdcb64fbb2b092ab2b4a7cae3412837a6695184c798b2447a23fb68f4599506a3cd96a79ac85447a56a3ec3496a2aee855f6cb39e2aa91184c97ed9304fefd8bd25c92e46f7bfad52a173e94ecd3ab46d1f51a8e30daf223c74ac83dbd0e4ad055b6320202a964dba6a4a3b46da4c253df3689fefc06d95b077dfd5b7221bea29947ac227effe02599ee3bb253d89c3a6602e0d1f9ac43829e55ced109e506f894ce5adc73f06b9eb6d4f3ae877ec8aafd37fe6c86cfa464f675fea90c9314278a9ddf4922eb939a2b79ba99662cfe28353b40b501f859cc3951195c8d3cf223d534d81b475e1116ca3ef804e8b0f57944ceb51d50fb5df559a76532fec0551699b48a40aa61ad63c232be20247d38a5c9435a02b622980148b0a29aa4e29e5ec37f6784e1f62eca871da10fea0ddf1b3ec388df122e1881a9fd20e33f264fe90e897d8e4200316d72270223f4eeda1811b34d54b6ab3c4331fcb80b8ae6a1a2132ea70d5c0bc670c4f334fb4982ced4d678b5e949630f31d88a6d09b5aa9ab2206f22319d98b2f97542817bee18052ed8690d6bace8c9251ed50899d6677576764825b3dc75192b53018f3ac40c745a255acc70ca1297743ac6d24a733c367c63f841f05ef49fd8d7bcabb52712d2772ce51e07c75eab78a7977c8dc0d13e4150e1725387eff4ff479318e7a607737f76802b16ec24a72b4405ef8033d34ac5b90f35638cd6be41b4da7b8db784a6833db98fcd94ef62e86dd57b3b7c6df22a77fc7528353c7a0d2e7370e67f8210e3b5299f915f3727724b646c428d8742a2cff658e998e2f8f74ced5bde3910407dfbfb6159122412e0f087ee55f6214d3ca49e8c2d858e0f563808427da5fd2ecce51401f95ec1576e42ff25eccf3aeea4249bd70d732bc199ddbfe885f4b1a6b8a86121f5e567a7019be452762c90be777da58ab121db2e8d3f385b73eb6cf46c56a477c983803cb0c0d30b522186a2a6a37e3c9d5fa8f05009fa40eb68a8577767871b83682d5d22af1a7943859dc4e42eafb28ce30dfd006d620052d0523773362542f938c4ca5df19168fb3d2c7ff969f3f786f7238047a10b3b71265fbe6282e1f11226794ac27c8c59c1ca49dce4d5402407ccec7fd6dc4ee8bf3e5c7ad024ba591a75abe37bebb930b7dd861d07437d00dcc4c5b87de394395717dad6f6f6fd94f7e38580593b235bad435dbca3491636b1588f7c8efe4923ff1beb880ec7be2fd5405ab8a6142d46acc0ab08d8b8d810b200a3e72c8b7dd4348e9f66eb1f738bd673e309c51c04216edaec1e51d7d48758e2128f5dc42708a3284c90f325c2d9c1820d310dcdabfa3481b5b2bb73aef332c3f9b5fa77fa7dde1dfa31408786e46da002e04d9c712a61a9d170eb1bf970034876d9e0905e01ca5455cd25e69b0fc322ba013da7d3916c79969b610db0e1cb2ef7cf8bcdfb3486193fd8830316637b595b00452aa56a1f486ce156672caed90cfe7fe06a17bb6e47b30817a394830e6324db651f7e5cf4c6ea159d018c1b212fba3d09577d57511a98a9d3efc8b7f6f5f128a0966a9c63e3d139804c9125f70517dadf93a094840fb98cb379077fabee19f9618e9bed79d1b818aaecf7a98579729daad04cd446674370fb6a86a58dc00891b5d25f33f0b604174972b70f5d236c7a8fd3fd4dea6985817c98e687ea442066676203ababb56d2b0fc6ab007f35bbf5c7cc250174ed9a8cde65f744d17464b318c66c7d70034a1e24407c280e72235f98abfc5365ee5c301246c322679dd710ba4fc60ac302fba9ec11570dbfeec66fe86d425ea26ef4c64920cb24e3a5131cfa204112c5b76b3f0f83f395a408dcde786ffef6105699cfd6b1be94124f383a754b0ede6e4505fb8c8df1c6f4233d424bf61515e005dd4432b85d4e41873298acfc15e999eb4bfd8a870d9281f5dae974576414001ac47cbf6efa7b2483a1acca872dd20042f7f84732b03bd90638017627d30d30a471111cd285cf2cb8d34827e8f08ddb3a4bbd5ac8d9ef00199df1f7d1f55418e7278a84b499f433f700b3f7a9f86a138062725f577cb39d8c461dcb54b133544447b14de953ef010bf3960ea1d4dfd63142b0dafac4bc2c208c8ec1254fecb6b6607edd3573ee2fdc756a8a13bb5c6a9f67d037d9364a52b845f002790b4196d731266c3ec12615fbd294dd7023ef6d0358f04b3ddc3c4d6317ba44a8938a2d8d052cb29208f70f6cc88a8a34894a493d6fe99b7e72e787a201549bc10a0e8d0160d16cfb22b2da6596c6870fed526a9f543b6bf97c73f8d828ed6e02f1c5a18f7b8c0a8343d3c44511fb3266c9a8484f9589b674aa1aad2749e51ca4324e04f1eee91182077534b03909d5cbbc3edd94d4a37e7f7cada12447351ddaa87067b2b9052ad782c7cd9917a7ba91d93be1c091759024858ad582485f77bf4f7c06fbddd773b26731717d8e32245ad621b5c9fc8e95f3ac68be78b0e60918c42c93529fbf4cbdfb2125a5c9f661e3d4a4ed7c150ac44d283f8d07ef2e466edac18dac674c99bbd0d47bc6918560bb3d06847b56a25de74af52318102f249f559af34b306108b3070013801c91f4740470c5d80d299936002d9e499877dec2cc33289fddb7b0a33c74562edbb65da59ad40045001fa1cabd38b13bd63656bea256329f30b82bc6116e02b96b69ba9ce049f12ae11ca02c9170a6083039ad29ffd05e1315555e8205763d049e2dd22378c2f6895432378ce53eafd0506a697395e87af42b2b676b418d7af547024acde81058e07fa4b3f0e7fb72ba0fc1747c58f62515789b4d37cbc42226cef40ae37808bf83a67c9f8facb94ff3d2fd4f90b80511b2e91a28824d4f0c50b941012e46b2d5dea9cda6ca5218eacdfb7ba06a93310b114e49d6f5a958f4679f6209bfe874430eef21c884d89e902cb162cf5310ebed977658208bc4565cc92e9589130c8f8bc48a8171382d79414093bd3783a2118f43ab9e60debbcb411c56f4772038a5b5a526e5ed03fa72db6fdd380329b01edc6cbf5a496d3a08745c3735105c38578dbcac625c16e0a7663a1276bd51a7a910b1c216fbd5826bb3d74b5568f890e9384270a273d38eaa1dc885aa9c464b4b2d50437ca47b611236542b0ae7f6736369336474ffa5ca76d5fbe01f6c3cbbef3a3a41e430c4f0b2b44ff958952e8201424a0092a78ba711c914379446294353a25ea5ba79579ad7c72f4ffc39087fefb8616c31e6a73299b5a38a76b2fdeaabd9bd463f7d9e36867a839e98ee6dab917ae50b827c4ffbebf0f99aa3b0f235e3c2a7f75c0257420eb7a5e6928189f11e27af28f5b700186bb467c8488d28bde3b284ab58f94323771949487be40973cea56c1334b63e0f89432bb9bcb25f96d1e98d2ea735dec2cc32220d36db74ee7874bb88cdefbe1f27915601a5923bad0dcea8111550c6482afde599d548dbd410daf743a54d9e68a7bf798693487129e6f45dd0ddc274132af8913bd7907987052ccd392ffc064ce0c89abf32cc7b118f25ffbc04dda51dbf01427c460fd972c3c6a8b2e31c8716ccf93901ac9e8854629265e89b8a273d4e95b7ee0802eb2c78675102a58f13d926ae538d4c2eb23c43b12bac0adae2d6b3ccfbc3e544c3e33efa40241ec57f43dc57e6984f28370552be8a9c9c02391451d2d4df823467fd52653d08ee7248416bb2b32a3952e36f29c90fb496c3e52baa5ec25fa1fe8902813016c506b504880f2edb8284a695fd22020fbe6e16ab46cf653d8faebab862fff10197dbfbec97da136ff57671b76e8521151736424c4cb05bbba0bf0c1be0f622f9bcff24821612a8a1a0cf26fb0d8632ccdbf2cb125bae57fc256a7656834bc53d47e783a9640ffd3a212e81d0e6a0a3b13121ccb90e90544af80b8267a457e573b9f06e4812335f467f55969c60ee4bf4673055e457bd2ba4be19aa203d0a4713b0b09a11738bea8ac8f29904c47a2d7c761041b02938098d749544f4d493cfd7236ae763cf467eb0efef58bd70320b3a672f2014bf1336501f7b48c67232ec73514a0b25117cdc6fb81304a907b1b745634f0ecaf0edecd61ccdf3814b12a3bdaf30430359e40755e82b9875f9ec229ea7aca4ffd01e8dfb5fb4b32db84a68d1b392efaf8ae71c0dd544d1a0bf1c7f4c0ccf4d229738af7fef024fb68f927fd1b223d50047f171feb136ca2f95ab6f36b7efc0059cfb01d59db1e5d0aad5f88cf425417e557bbb287fbdf9c5db9346cf425470b076d47b68dd8152f39d3700117f85e702a81dfdc5e061c807060f79cc43b6fec0b7837e8debb2fdf429dbf5a1d18638d2d8a99c9b318c6629d1322f8abe7260c9135ffb834980c4a8e10e652a45939acf6dbd814ae599210a07ce1bb228df73c06dfd556bc2a014eb91b760b9082c260eed3c8f0cf3f11132b32e95135d31c377a967ec9a841a86273bfecc7d3af48b28a60b5667b72c499bf8bf0469711ef2a33f3b6a144a28f56ec020f564de21f2d6340cd6f6106160f9a075ffebe4689f3184ccec5cb0c7eeeb2a2c0aafd92e53fd4108783b3c5e0015257ec9d2197b7189b94cac63d31e53527cb7669320a7257705f982ba2c2c6b058b0093e4a2465c110078f4242147f95761bff5f3041dc8e7c73f60ed2191014e71e222233cfeb406c07c1f3e6a3c40a422478b21441aeb689c5ef29239306aa454342933a437785d41ff22152a4734e6f456ff7b1b870b9bd6378a373933b66f1241df69a4d8f719f2c2c3ec597eff4b8032c8deb11e487de733bf61da468406904cdf030a8e29210fd89c274474d39994881b6b9b7578d3109e35b3ab781c84ff5b14c6fd8a97dcfa985027db4c695d8e76e2ff4adcfa376ea1f06fad0de554e512d6824ed105258c8ec7b7ee070b68f676b66579cfe22976c6379b6b7d1a1bacdc2f2ce37609b94ed6e49dc4df5e1fb8eb130f5daf9cbdd6fe2658c166083b1c959663ded1c008b0f8ccb1f2c3a56f34f3aaf8122f1957341196cd4501cf0372f942ba5f6139ed3e174aa57bacf69e40baa57fd56254614e3cebd5778137117a10d72f87062ebaf3a2d4ffb0f09e34c4ba8d4da04fc9d29e3b45206e68c9ceb251b101d850c153cc6a736b526cd71600b464cbce596c0d6be3fda8b2db864057a68fa9855a8fa7db1ff58e40e9cd69ca21e7fe524e6d844ce5b828d313d25f1447c259c99b69ee7254fc945f0e6b9eaa45953a80255f3e92f7c894fa67cffa67c8caebf77edddc2658ab9fb775247ad66c67c44e11e7fd7ab1b2ab9a04598ac9e6c3adda0bd05438d2f69ce09df08ff87f57cc6c5cead117659c65a71bb21adf246cd66ca867ce358fbdbc901c01140bcbb80644e5d83019f92c406f2a6ac1bc4a36ecc1c20ebece7d89db6962643cc30de0aae510bb9cdf501ff1f4921693de0d5c072fe5217e237897e7cf9ffdf5e9d50c815aa47f42669a683378a441563c576ee698649a33163be6e7453bcaa420c62be0342bf403f8a92d58fb802996ac1848937a77af0fecb7001c01a1c7124bbecc1808a26481a502805cf3901dc79a5e58605992909185599577f1a681f979abd8c1e181cad2e6eefd5dfe4716c4860cd16477d834bcf21b09194046c602c7f9642f0c5e614fb1b9309076d9f2da129e53abc04a89a4133d5d0ff5de83b6e7923dba750370ab975212344c81a99d53376eab9bb681d79316059d9153049cc7f7661b2be49a0523accfbb04357e13b1afbe478d712e8daa3c43c8adde2e01b5028fbcf588195b68cdf1903bd1a1e404b1b352eb59f54352ca5ce312583a18f212a49d888e2ec207f4d2c1df79db21f314442764985da7f51550680cda0243e693bf2b59786ef9d1a941866048ffdafa11c5e19b2fe07dcec313a1fdab64125e547ab9f65cb9716df34b33d6bf4d9cb7c2658d627040dbce25c3e56f3b2e5af54936cf661661b7e95514aaef0cff77553ff07281d6822159999410e0857ecd68f65313d069a83fd62dd32a932a8d8c472b93b59805b685b9606fbf0a18bf496d45c4671f268a1f1e445dee3a08e2cd28dab6748c6caef4a4e4cc201a8c4fc678ebc7c041108cf07dd6124c2708a7853d2742713952f939591b7cd8ae82c3604f64c16ab66d034f81b7f6fe7ea625909734079582f1d29891bbf4000336e5bea9119c005641b5e139ca7b3239f5e615d9fef68901c4feeba9a914be75828ec556bc45bf341ce9f88e535e591cae0979f83591bef65df985fd57084a3ed709ebc7e448bf138b5f7fe94c293c7d13bf334bd7dbc6afcd4e721a5d210f35380ab49fb7d47402053fafb229fb2c06a0562bbb8da1dcdf4c88c3dd358045409739aecf7a6a60dc363134a3aa8b9a848858dacbe8200c68117ea3e4f64b9a14fc7684a042af9212cd6961f9354556d59105254022f669cc3aa8c7bab930b90f2884b513dee4af6f9835cfb1832214716e8b8e08376b8bb208ae1c90064ffea53c87a30758c67c54a66df8d3ad7120c2a31ee1bdb4f6fe57a9acf36817d9a9b21f17c4ff7f10cdc7ceb0e1c9afd174b6ee92fdf26c5bceffae39a5b8fc9ef7c3e5b5568115b3a388a96b8235164fcc563fab4fd5f74384ecf5ccb8e5fa58ebd43bb65f8d0f9ab4106ed805fcfa40ca3096bf8f53102550e38efe30387f58d29da6e2977860b3f3546be3cd962ecd5773d8272f2acc773c31fcab31b2852cdf65978dcbf6cfabd7dd0bce0f50728bb4b09eb543e655a1b22b2bd15bc49df0c0f6f135febc9cca0dde337f9e0be39df466936fcb5f76047dd36bf47ffa632c9f998acb6ea3cad59c806a224604c18122d9bd98180865ce87c9d50a4dd9e3409900221e98739d237fea5b12494d0485efc681166fd910ff4a2afa51c002f00facc8222d7f82a9110afebba8d21533bee100b853ad5bf6ba5ec6038218f75d3e7bd5b7366aa2823f638393326efe8869a6d8e3238ffa95e2fbedfb223ff130364499e1d57c9d7f765f93767641cc235c92a31a6f4ca7a3f9abad56c8cec49fb7ac3ffb61b5c3716f157101a8d1aa1aa60f71595d80c2861d7d2d0dca3dcae56eed52a0a2647a247e7ce12a5bae48435ca642dd1526edb40ba06484c4407a291d2e37a9cae3ddfa356bf7eaa932d719b8dac4e48f0d8171d9931a7c6fabd199b750c62156eae0e9700dcca60e917eee40df8a8b325a04ed6f911dc7396ae58fca076af78a4e9aa6d83055da76df98cba8c13a14404d2d1dcee1b0ce2960c86721b77f4b96abee0312a242dff050b18e96da51d88e37aec1d47dc8eb4815e6cb735e3c1c13ad2e9e53b722c98d065f79625ae716d4764efd7b08f49b8b5a3e6de0f1e8222955b197aad163c86ecae57f8d318b5d5e4f483ebbafe2668292607060a44593e133481fed0b7914d3a8ef3011ba8b108bc217214b343804f11806a4baf3dc86630b50f8a3afe65325a03fced11ad3dfa27bbea2b001d40b37d2bef59ded8c24fcffce34ee3c28074f1358d9bd3b3b690461e40a0a14e7530c6c38356fd9384e28e87ff520f2be97c83b094ea44120c461eccdfd17885bf01330fbbb10679f98384be779a0fd0d804fd7102ca17dc7e5b08901a90292819df8295d37eb1c1031261da684f4ac1f98206c9ec80f0ed85757e878748cc79447e83b5921586bd9242cad92d8ef5136fcdc8655fb3209db6180bdaf2f887f09bb7abf15ef0e3d9f3e8077a73109c4a891dbfcd8fc141f9a08395777b537f9db7d808563a6494ca969aeecd586b0e5eb5d2ef591131b1fdc64231a55cc415a249e7d22118211339fa33974d809d52f0357cf755d816deb69486b8594b51c9ea614dc1015caa802045e40406853b39889d2102b50ffed16187137499b803dec22e97186d3b3ad2dab970665f199303cf9e4f5d4f01f7e2a692db7b53010c7bae8c935f862a0f13d25b8bb7f264094e41a76f78ba0d6e647a869bd212393a15c553c6840ff6bed27fa269ae37a2283dadee30098fd0639b8acc8ffb6d9473eac35da68d42c652c120025b970377018c0b64e4584559db403c7e34a5475cce008d15bf2165e6dbadc52584b91a7c6c8001f6c2ca7d21e3993f3428456d610873e886b98eb196d3fb5f04bdf0316ee9743d9d612a874c2e315ac57827b4f50efa96e29c16965b3220cd83362eada3f445a224f2ee2cada44df30c5dd9d81f1ff07dc0dedab85841da5577dc77939852111ba6518cb0035806ce0ab8c8e209a8862f2edf9d5b88ad1a76034ff137e30ee8dcd70b255fd8147610f56604e0d9713e15696acbf2a7586d7a866c3979573a7f4b024e434fc9c8554a4f70f75743fe56f4aee91f70b0a287eb07ef010ef560516301fb3d95e609bd774e7d03e3dfcc15d2be5cd722bc3a98aa03930664d14993dbf7a4abfb27cb7b048e9eb7636768d6ee746114d124075d82cc80015ac9405a3307ce47da77e8c6da80bbbb48bde3ae42cb90a4825c5993ac5b323e0bc98cf97f23ced073d6061b76eb8b9402a747340d876a2baad11cb389c8c1c1b099893a8e0cf2c8ee3670d65ad6267d2ae0d430a832f22f6804939197dc74522d2e3d59bee41d52bf2e54e2d070f99528db0589f0ebfded1dcba5c37d4885ae69258d47c4326e949045bb54cb6710c4565087ed127bac2262ea2c57fa2fee197fe72ff4c37d0c0962206ce879771af8f50bfe39f0cde3775ebdb8779bb57daecd712d09b85af5ef6edaecebca6ef5b17f7031683ef6a4b3f8970a80cc1a145e1518bb0924a9bd09aeb3d857eabe243ada4226381b2e68d5a6ef2c769235faa2739bf0ef68389b09d16458b36e2a99a3ca055e6e8d5e99979db7f4b70670d585517282ecaab05b5dffee897f58688f302551a3bd34b567129d1496cd47207947776474dd4d890cf539694bd0134b5cb40a779dfc072ecd5325bb798a9344407845e8d5ff70833e391be269ae38ca48a8721a59194844a4b4691d310ed686e8ebc3f9317f078a1e241d3a852f89e30f2a0d74f47a07eec05b3d7b63a88c6ba655447606819efd98b64c795b3c430d770dfa61863ce22a43710c222b695e06b816a80b8ec50e2d6f6e9d8e0f00f8ee637ae695e145499b79c20b8ae8edd29884f740cae62267e8fd08a39dbec2475dd4764702e326c1d8e41a6b18723d3a50a809378868c2354cf8fbadeb6a6a46f5736cafba7ae7bc9105be290c693901acb15d77e8ee52e9ea69cc3f8840eb9437459810498c9c3551fd65a7b5585b12fee86c87160eb6b73f4d3aecff4869404449e6d1017c9444bea94eaff7f9111f34252234d819482ad81ffe1d8791ec6e502831cc032a9f016c92be432ad7d9908384f58da8213faddbf42dfc19b67948cd818f4216d1ae58ad381d61ed79ec47cfada378615388425613d55e1a1cc011894f564b3fd8816def3d326db3bb014e0189fbfe368505cbc85fa59195f7544bc306758e4be5484ee1e29e317d5daf4eff38925b0c1fe601ed890c4cff5ff560f20be0e134f5c7651e752974b0facb3a8a5091875278d21acc969f5c9e787a0bec4abacd43dc7c843a63492b3fe7d340cd3a0e284b50247fc5b9e7c4518af535fe91e3778632978db97148be5edf52a7c5e39289cd32e3410b8a8af90ad91c4065a26c8a8a9125bd27058d607e701f6e34e659030c1f1fa952bc3d4eb71c69aac35acc0558ddb1baa97e693c7d4fc8ba43ae522772441a73cdbe4498ea068edb0f4527709bb62e9e138c2c565329739509aa54f8a51bfa8dbe1caa0d5101586d761dbcc84c70d43080de3cf4f64e3c2ff47e59fb67283af5a05cfaae00ed2f2d26241a0b975a7600de7bfcae056a1e0de4f457bfcaa87d2ba216313addb803cc97379bc13316fb36eaac7b4a8baffab71e167cb5c3f08f5f2e01322556c9b777235e617ede79101da7707dc4e845e449d7b75b0b046fa6eccc1534da5c3db587b48ec55ca3198b0574218685470ed99a531cc57879a70fd8946abe90a4887e4514f2579fbc0adb7e90af63459b9c7ff6f0f2a89b607014f715eeaa31cfc2749aa9ac0f7eb0129750a25409bc9c691338ff2996b0ad9559d2d65dd42d6b3166bb3c795bf9aee3e6e93029e3a9582a71dfbe3531a9c95a32954744429e4236471fbc3f2459d1472e86070d847d9be3efb3c2a8d4ebf4ca70a8eb3b880ad7060e62eea928bd13f67efd7ff1eed74367dc044654f3517af6cd7062550762332ee19985c0500b3e4d6a9e1c6672796b82175b393719f6039352f491773862e756baee384aca4fd4b3c806182e9085751932f8d7ee99f0857565a33069087e9374cbe4df1b54d5d1e85360d49834fd1b2f5e1bda790d0ded9bf8f2974504dbe191b41747e60439e8c74d611ffdc6d0b8d79c4dd14d502793843413fc11eb936aba8b9286e988604d2be9b6b1ba7483e17c038282cfa243fc7a4947f54f21348c88fae4186eebef57b9b3bc8f13d26399483e8a8a19fb6668fef5695cf6c2e232baf322400a1a2b0d9bec9839d42316e881c4d6c71124e15d459d7d98a2c9bcb4757a07b427e4b802a2c62509b4c10ee09b29eaa5d0a7e58bc0611dd80ffdc1abae14da96ebc07da5035d0174107be9a0d4e801fea85a3f2f9ecb7217560ef0a347fb46dac0a0635b035af230f5baefd38b3e1c5a8ca254658cf8b56ddb798a3cf5f47f6a5141af877bf80d668b419b465c02ab91e055fe0db70945df44533b3b47bb35651e6f13c6143ae69a8b0ea4518232f97e0454beb66e518b47181d9d69f8382d01082ee960b09ad20767e039f868080c8a29a6fee386316af127cba85f3e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
