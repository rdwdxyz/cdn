<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28184148cec7592c4841a6d58b0bc3b8ebfb3b851edc6ecaf4ab23e59e8ea5f47569a04fed9bf5662d46497fd9806584d196b12f636c591a5050ad5eabf8d700407190451dbb74e828ead579ae7829f78db80d492b2495a5d7f0796918061e85a5a429769dc8f2ba518ecbf2020a78f3d8769f321bd95f775135c37ee96f66fde235ef52310e86075ec4df9e3f4bb2fec629447518310b0232e213ef121da57619ce8cf1ca4ae8a1c2eb08acdcdfda88fbc7b31a2a703ec80bab994a386abe65b93b3d053343ae002a5be3919933024b28884a08cc6c3c8bc17e42bbcdd73023c64b092c2c7d1fa0b5bc61044477b7bc064862f880eacf456471b48a4570b69fcbc77ba24e3e31a55c7a0cb83419b8fbadf64e5975a767b130b92936d8f57ba56332c67ad89a3ca3850f067943fc3c413b03b5fadac49fa956777c6244b63b65a5b952671287ffc9f5f6f16b012cbce0839edbe82026901ec46d56d3e632313c4c360e8e10cd2a55cd508e06920a8794f6e2820164f67f48836fd8ff05e033e6a5b891a25ac9d01bd5995492cd67113c8359c9cabbe9657f1623449b58ecb47d421e4e235ca7a028540a9d5e26ad84d57c72d2e28bc98934358c5169485ac792073a321e947ed32d007580bcfebecb545a879f2b76ec096cba2d2576be7e706c9903aa1d25753ad4793202b3ea3f99c0b4b74a7fa0b3db37e0197c5a28199cf9ab2de6824d8b7d4e2139e71ecd3bb01d59256f1953d5a879d5913d8826a64a981860a248321fb278194b345b35e3993e61fd56a556d6e4180d9277591000feb965f1762a209a4a66e8fa208892c67828ae2259aa78a7286a958adf73471a87d7aa0c119df7004c82cebf3f77c489ca6a8945ab4336b45639df95c0d086bdd90b53b06bc2f6206e6f623a4762f3ab51928d1f55dc2dd69b2075381aaa215f03597596e3701c59969ca000ea4eb61de69f7202cae6f2ccf2877ae7c82d705d290f791fd143d606caac7fe863420f11f2751a0bd9fcef3726e07c269fa72333c59b3864f9f34be39540dbfec398ae6d01ff90106a13f58a8b6d2cacab3eb40b421d65c65ee163b60d4627fd10c9e957341849acad371a9a77818377b10d255d0cd44e4ebfed56b09d9c04ea3ffa2e08cd0b72d11a008c70fe437eca72225c3b11f44ac044906c10032803fab5f8ec3ad19773823122812aa1020c18939cfe17ada89252641fc9d717638bd890994f0af40727773446dc326be44001e22aa09665cfe9bf4196bd6693725bd29c09ce39844d9cf552ce53540ed9a6d97d0df6bc0dda3b52b6e9ad7bb8f17abb846b6df2d1d3b7cec0c25fcdb046710eb88952c65fb0b399bb788e4b76388e11134cfc08388f78ce19b0b22fe2be26c7241a6ea2ae1b432bc1a2b1273cd838b4c95d8f47f5c9fa45086400c355ec864f7f1cf3abf44ea8e0aeb84c583a483421dd8bcff3481037ede91e16ad09b682aa3f96a2129d9d873d796f92bccaac610fe9bb94fb2f1e29909c301407e60b1bbb9bb9f55025be9002c1dc1eaa6a966d95deb264236bf31b02d7773161efc15ce4722c1b245bbacdee6afdc4c796e7fd96c6453f216c0718572e810b97204ca1825c8602084092ad1ac85509018f192810d5d09c9baef2a034c8abdaf963514475ff25a55a291ecbd12c914001149894439d5ea6ec85b019dc4e726e83a3704271aedc0a6a58ca9673b29349911d1a2af08ea0beb619c2ef6ce038bfda7a6806477ca40edec3580318e890bdd557892f6c99bef1119a1526d894f79fee69a0ab637629028a3f232441314af92638dc32fc13b89771e2ea93c4f07c1f7f17e45fa1f49cf5541ff5cfe88b01433833e3700a7fab2721f9047052a2fec80530c638dd1b3e2a92b6b5c2380ef5d6f8c79d0f24fb9026c08f1944231307a5e23345775db2c70c9226d01db671b2d59ee06f85709df6aadc49783c67cbcc0545cffc4e2c6250a6f571c0ff9aff4a9ecb6a66bf89f64147a6e6e9b30f6f5d4a6bd860720f909e1ea81ed029566236d180049687162c1b6300a976f2595eecb41215160ac8308feb7d6f85e9de4c49b0e9a837bbb15bb6ce14fe44b493b6dd77c7c117f84aacf06cc50c81da4eaf476acd340eb871ea73bbf9a95bb3572a76b900fea3414102339bbd3163749093d92a3032fecbfa380734b1582a27c0e2f9b45cb0136bf7d69d8b27d35a6d3f844078279fd84b511c103b4e0bff70df889ca10dd752ab60f1b896db396238efae263ae505d5d1e0deacb0e1b5c0af9832a82dff2c6f02e37717010bbf1af0d8740fb44ee049d20de65f84e29f4788cf10252a39a35340f594e9be4584ddbcb57990432148a57de8864e5011662226eb79348350365ee0c7474bddce72bf623a4deaf41c46d444a70e5a38e8a74f842ada888bfbd20a69639051025fd358c1823ba07d893a261cbc1835e20b2cdf4483823c7470bd2502a07d016eedd4e576d97ca01e5d5e2ada587e3e9afc7cb32f7917b159446241b4aa6de072f1a42128e5744e054099a76202ec05027710a780fa8f5ab76c093158ca27c57c04baa09bdf4d3f07954a364bdfd8254e44485ff6e2dc1b9b04bd205235275fc778af598d3ef1d979ae622309d52c0b070f57fc9cf6141523261b156f2548294790e65cf38f22e341da5968c233a6c614d800e5133e8a83bac365e6b6470a13f921b81b7d55076378ced274a17b8e1d618a86ca895a9bcb504d4c6318eb8f9b7d4aa50277abb86ca76fc03e809fdee4f388bc05a8e83c22ded2f457fc297c93387713e150b54da0aaad1375316003edca2180a9e0d4117afe55e8aa79ff10b37a21c56b83d8ce4b694dd68039d04a0d62de3c82551bf9fb4072d84f05709de6e8f8aa8fcb25f33f9018dcc294d52522181106794f3dee04a3a79c285820f67b81ac3a3efa330a32fce67f26ef328fd680c7dd9b0e05271ed592b8b6635d2401d53b47c6c6e67e463b7480dacba13de8999dfa69b6a32e798231419db9ba2bb9c2f69655edbff202afc532d8aa71ce1aa24f7b7d5b21f920b139474d7b3341115b2d787943dadad54317e71c8ca6664713750102b5252362865a8d77720ddf8b3a6924cb51e34c57be7afc440615f3db2969b767a2f177dc0c11e29544b068ede67ab8871bfb9c702fbe361e1ab610888fb72bf7d813e5d450b83f8bcc0aac0ea98a42242398438b13b80c357406539a74ffe47186a2bb930255972d9654b0976ae3c6ad01b926d896a1c20e19b600530167d21c679e92f517781fdf8400864b4e38731b8cd04e67c78bc97edaf2f489a84fd488e5946a90e07a6d5ec6bb88072bdd8718d997611c6049f966d9afd8dddb3a1fc7b77bcbf7ee3cc585caddea6bc7b457c294244ec2efaf2ded2e230499ebd8ae075fe0641e9474dbe2ce637a5407973ce2b242736187c1c5a3655bfa8ae5f64fae1b87cfdc802dfb7c1d6e696c26a878038dfd744bf6856f50b5be12fb01af34c48cb0eeaa87e04a48e0ee75b2ffd55deb9674fce3444bd4c414004a9252b586c0cd313a61388494b8cbfc9a245b2328c143c727efdc6a36483dfd0341af4e8c83a491781332b575ce5de28971efe0e0b554f4d988785f3974ed8cd0135b1133d82a2257a12192f1bffbbc940f3a68cc0be7b923e65cfc8457e2bfe3500155e0a1efcc82c54a5e2a3bcc60552f08f6ed277ab9e3373c877888fc90e4054f9bb629a48a5a0ef2ead4a0327f0bc6ad60c33c9bfce07319504b5e565f9037fad241b5b1c986d9b748bb509cfd8b62d88382edbbaf838fddf944b98480d83f95f51b88af7acd27f37e44b9e49b134afb31520a9322e7ad2ce14b0798c6d8c6cf2e659772e023a130f41496fd00f220547848cb556aecc80e2ce25a67ae9d5150b03d0a7e312177fd10cc7d9933e572ad47b715edae84a7cd7d670be74cc1425ca40762514d8bebccf77220dfe56b53f57db11d8da94b6bc4b4cf31432057b41695e0c12180148b66a190636868ec177617148299ab0cf6e879776ca61e44ad5d6aef7e0c442e0bf8bd84b0f4be25279eadabcf05b4c1c6b612136df03dfbb1ea631dbed9edebca044fa8f1dbf3fbca781b12985766665ec097e2554800ed9adadaa78240bd659e7932c98c385df34b02822f94f9f219b27961dbd9fb8770530bc06269fc7b0db18919be2f6ed5a18d42a367b87c08eafa8e67c294589276b052a7f9a71c6a92746d002dd994b5f9f59c810e1c885e80a62f3bd053681d93a52dfbd777c63a6746dea6119640e04071a5317693de8dbb822acc5c00e7c9f601450e99debab03d812b80cd78bcd30d269d2bb409b6d550034e754084c1886efcbd305bc0d82720719d12df1d953cd8ca48c9e1c188e18f41e46c4c99a645f09dc9c36218c8982bbae8e539635f977e180401498bd6e16615419d27f7aa3575f2be524cb10deb9d20f6c9681f2272dc347176c68e6023949cd6e537c40f70f7556767a530562529c56e2b747253d84f9066112ea23de1ffe40b30492f85821162da14e26114ebce297486124c474f0f80beda253112af427542f80e7d2e6fd7328dedb04f78e8804c2152b762730bf14d1376dd59e4f06c920ac9b2d81d9b8e7aaec3535c76fec693ec9dd8e8278ba8737dbcf453e01b785986d3a2e02e3bc92fabb4ee97a71ed8425dd83a911a268703e149fe3feb0987a586da6a2b17ec609064091bb16e6926a74a885d5b4838e5db6399cbba5d0460249f5c3ad019772235233c3f4cebae8a5401d4bd360eca60995cbff911b2580cd2ae4bd6a31f5f76b788f88cf3b00342eb3d116c7be7d1c9725deef146c83096afa889cc37dc4b1b0695828cfad5bacd4b24731c02387d78031d40ceea4db8b511f7cad9d443bc0d9dfde62cd340667f715d1f72fb90f768c5a0d621f85eb09e568a7cba59c51b338ed083c18c2ac5f4494e9bea2dabc8a9009a6fcd937fe1c2586f961557e65daa5cf368f64dd1dd573f7b614551ca3479019793e349954da70dada26eb29a587ecae791c1ad78b61af8ce1522ea36f42657b79a33e442d172cb811301cc30342e776ed278a7731440cb4674bfd37174f501a9c0591c953fccb821c9b9a515ca639727f30d225565357ccbc6a84a9810ad35a6b6c7efea237db7a3519c4be222297cdee91d246065d3d2957b6d930ef31366fc5ec8340b8918cbbbb34dbbd5b633c3c35a31940e055cbf17c1f974f8485720675fdb6c3047d14c44a5ee03ac544a4c30a845902d8368aa8660fdde0972b33b6806e0f210a4ffb608fe0813417ece92b6a9a6b9f22f2d5847b58ae16efc0df656e783204c143a6869fd871853f9733380671c421d1bb34a6b4757d98331f02a8a64cacb81ba701640c7c666958ea59977da3398bca7dee7637484962241fc201b2e85a49913972a3c87ab78ed73678f4c1b2317f5f598ce84e6ce29c37d9c38dc6abf9e4bd3573c9d972999cc056d52aa8d5d979825cb6a4b6e2264991ebe981a154474f5aac77d33c1ab14cf9c5937027c08f98ba805a7f8352c290b7c0392beffd7fae9b10d66cc0bc25efa7bce1f5ad8ee777f4c5ed2143fa596ee0c834d5aca183fb3f37ef15700f59236ed6f5c6d052878886bcbad50c366001d6fd40aec35000b2c8ea126a159900f982086aa0fce1682716d350ce7ef4208c5e2dde47da200a6e42ce0e2ed6bcfd46e4aa56e372aafd28dedcdc1180f915fd1b83de3c9661c28e1b682464029e992282183dc657cb94f7187603f08688aa638d14b45720c4b77e4c881dce1aa169ef69572cdbad8eb4174e80d8c60236edab3cd08aebfbbcc4441f6fd4863b5d4ab4ac04975396ea9dbb511f8ed12632158917e0f1fa97df8e47c7335fdf5d7e84d9ee148c9091bbfc91fb26a194562cf7ec34e76437a722de6a6d9e920fa146358aa5ff874d8ad14343a7ec4dfbc008ecc8d7961c2583cde1b631e2601c119afbb3b49f3f4bb2770e08116d4180f89f083f5dfc8b01a783e6806669845b19abfebae556910c437ebd5329ba6a754ddf593ceb0ccf50196e93f7a7c2e9fb30f5e78dc72fabceae20a9c485aeace4e5e50f022042d724b31ec57c076131a35d074228407319d219e1ad35299482d25f5e93897cc57d28c0d73288565a74939fed24fa23403efc7afc003eba0900f24160bb057c9c950b5fe9fe1ad69e1693364f0b5207b215bb2534767c852d371c5b222b07f0748ed1511b635dbeddd6d1684724f81a58572b7a4c5158c4190e531cffb2505bf393ee403ee0f54cfdb1a6b317651ffc940e6dcc6873d280f1a717eaf2434742e8a6e26281c5e8aedf6a3cdc77cb38e87946949a5a247a623f8dd950869c4c653110a5ab362eff3117c9a9c30c2651dcb1549f052957bdc2af3254f51c984d063338c0b0a46bfa8b74136010ea7017b55eb531edf78d28c2506d96fa6c2620162d494d5946c0e154abcf9c628ca477ca61ed2266beaf7910d20ec9b58c0ce1be6ca74bd645a737c01d7f57bd7db9554a29b70c1c6e4638379136dcb347301ed4676ee568a1c8e0b2b7120f1abec480d36ab4c3768eb4c352d521ed8d5d1e3ba2eb1e988544cfaac1e8f45856a0c04bc698d98298d3963297241be2c42bfca117eff76906c5dcbb7b52601fcc416ddf052143448135ec0d278f95e957d4165c39034a0e30c77813b5e9eb4e0105ed9a7102c0e9f9b5d282ce9a08efc096dc0d53695e1a1947aeb6048a9759a8a2c2fd583a008b1f469cabefd5adebd6668d7fcedfb1582c4967514c58ecae39a4b8ce13b17ad80f8db95127c46035652279476768ac2ebbbe1557c260a2c5f7e15405e192ba141a0ae7577c76abbe90270cbe0925f54f83bb5240d6c66d241098e7d69e4ff856d4d1110eee9a03032ffc5e7c8c182c81371b332b37c2302459fde8061c2d4fc5e148ec74e803cc57c7ae0b00cf4a730bcedd4501e7698e96871ea16348bff9a31ea913e6b0489eb5445b0b6f7a1c9910790a2769e6ce2d497c20176c182ece378636b9e6f62372605f26ef8555d79f30c07f0fbc5b31b16a474a1b5b064fa9b657e0b07c423bb6cc5ba5ed97ba4cda1f9cd76c5e93cd21921faf1be9e2a38867030ca030d659a9996fd152a25cf9a7d7b57452898ad69157b247d026b21f38869fe70b7451fb9323fafedb2dfab41b03246ffe93e1282025e77006ead68062ca8ae877dede873fe39682a447f3a2aad1f2774a78101d42d3475d8ec0f9a541261546107ad817ade2e265c4f4d40214b289b2159daf57d6f902c0c0ed73e87a339e2437c8b5d4e8d7b738151daedd1d10801aa0f1765769ecefe67e6d1fdcf65cc7d48499df25115bd7c392a42580de69e5a5488780fb68352e12be8da306acffb1d95b280deaee815b18232e9cf88a408c4184819135c0833f644953d108bfa5cc845776a1ffd6b0e02ac2bb028531e63c5876e82084da61a4f0c0569707f86c16935299f1fa39cf01b9ee35c16eb4bf737408891eb460d4e4172263ef3c7f16b8d91d7ed9db50c79b61cf7ca7abc49ce84b7f557183d230b891ddd6bf589c0601dededf4c245d01e4eee48ce9d3a713678ca13ccacf8234c0cd25d054603eb8dfd633cd87bfbc204cea690b3c382a07f49b743e7cf960011bb5dd3575abea1c3a96def213396f998ab2695b09e4e99ad3083d4688da33b541c19fb3c58d07c5cf6a9e326a9250f6d261f7cc9427d6cca5939264c0afdbd36cc93ee99944c87147e4080408bcd8e1ba637a13fe525558f814bf3586d9e39604368f7c13facf2250f939bce0af06c5985bf92f0c03927cec7512530b8b8af38e2d20b9db8fde50e9218479cb51777ca169d069039f8c25683516264051d996e530c35090c750a06b938a01618aa7857cd741da41c373f99056f5d2a7009fdf37d2917aea544d258636a6cbd0aae52ba145409f51c486ccee4c35e34cc88705c7043d878f33bed8e46f334ab0a919ff0806f7932458092af49e8bd44a1f67752ab8c4cda1aea86b8d01e9023f92d6c04e6b37a410de6e205e8e8d7dcc90a4b0d75c396d9f2cca0a53e2947e06876a4d41820638b4cb8947666f923066f666709c201618b314778753dcfc19b70fee06cd8ef66ed0226762ef06a3cc17a55ff6bfd107b37b704cd918a0d68b4966bdeb28ae0d1308e9997952229047b58e47227d8d76574832a300af9c724845d0d9d61356d1b596971a34063ba8a0c6e61b49c9ac37da370c7f39091ae3b24994b192600753670b1eb2819d7efa22957324e8b99188c18c5003a3a7123659ceadf33a1913cc5623f2a1151eb09c8a95bd9b40dedf2306b66009d73c4c404d652d8c19b2f8a9728220c6d9db5e681d79e327eab7d8d627dfa33516178d81df0bfe061cf825531a5237bd312a45054755b152400c1f42f463d30bbc3e39d831961eb2d50b7b652f2047bcc175aa4fa9def1b98c2fed3023751321f7cb76a229538fc61f44a668aa6ab8dbd2d916ce63fcef7d4a55d9659cb0d0449b3e60774021c82dceb49ba65d3787f978cf5516a4ab247388d63d1e810513eb1f9ac306e7ba1361f2314eb885bd4f4f54509322f1608a0109a81a2f9503a29df6a9094dd5b7a2eac6de4455f8b715f03f4283be84677fcf2ad9ae10e521500954340a11895259cae5d4078a3aa526405f2a69d326758e009cbddc5f7656b433acb8efc63289faf52183c9a9c1a91cc53ac3adc5b05d68c34a1929eca6ca0736330feedd0e1975b807553509862f01cd9acf602cfcc2400b401509ab4dcbf917465e95f27e897efb6c83e5ea1970a78fffc31eaf1bf16b09b5b1cfc95044bd8bde7a1b560517262d8e737e4f923090bb99473ddea105f197367586c752f0a94b539a106234655dd7828783a367300a96ac310b99fa719a752f46c60bb0e45e2f3873bd988adf662c51ac1a2d7ea24745e9556243b0762d3cb9c8c0afdde1e3d5876a396600019423cab7e569df926c1138dd569fbfde44a8a9ed610dcdd2d0b5f9e20f73afa3edbe39b53f06260171fa14dbccb5211b518084f4d4a0ce945e75f80500f3a7f42a98364b034e7a7ee1ef375695931b7d704025837920f19daca0b4f63a5a14cca68db1256bdea871d692fb658a765303aee8f223c2f743807bfe21d9c6f757b5cc65b1d5d26141c91592a7702cf3d93b98b567b92669b302f61217afa68379e09fb526481ea6f1fc5315bf1c3de273588c49825b6aaf552958a16b316c05941447dc3add294037999afa0b9a924a91e665b21b05abccc1799a2ee86a6ea4102573674a424d7dc8a987fe1b3189b5230432094890a2fc5d2a27128fdec8a34f4becd6949d7bb0513e2ce0f8b9dcf45f62e030ace78306711fd61920e6cd05caa5c5d576529f62b428aea66d49c4589cad057e17a8556c143690b3dfe40e520e7a82e9dcc322e690fbf5579dc62e1c5bef353ad49323723c196e2282f8eebcd480d4bd531602f298c977ae8788b5cbff1d91bc9b107bf11f87b41f1919d02db60871fc7369f7c662b2c8e958cfda27111acb635dfcd12f5fd5b30cd23dfd26680ee1227e6366359327453567653b1ff8f9f5b9127d188f2a6eedc8d7bcccc0c9748d56e54d6ec70306100602583c5b100b2c49f1ce4f7f7209b8fef163b10eef7f5b153f2af0a3c290868c467d781e5d96cb5ebb8df14be120c9c9265bf6607a0d6d8b52ab05a43fded36a40e7e1e95369021792cd588d1057ddabf22c594fb6995fcb0f91d12692c5c18db01f175c7f34d42b9d8195fcb56c3bfbda1d7b33f038cbffa3954052a1d0bf466f8cd417a5d66bfcca708fb73661eedb4d8b4edab5af33d7f7e0b697ee669f2ef83f00e0a066e59a8974e6e80503f4fde95f92a8465abe9113791593731ae68f06347dcc8f7648c232b4a2ca2743cf05b9daf49c0e3c62ab4be7535b9af98f244aef2379d5b4106e78e11a390ec7465cb6d9a683e01cfd58ca80ae71acda9fb4f4c4a8e3af9f1462f637d5e970b8cf5d3880ece319976a09a00468406b8dec6319f9d29bd395492548bd12d4b5be6812db924e16ae0202c633f8fab4232a5f05587e96b34bcfe95306284f33ab35ebfbee19d81dd0237ee5a609faddc16db018cd1e0fff9690377f0f60fc41cc3f1810caf7ff03c53ee22baa562f445748a810e927b6059c5e990ad82fc17cb0b8910b4e0064131a2a542168bf256535796ad876f86ee72a3919e9b35d07cf840880ada61608350736b48f6fd4bd78e5563a7da1fc0b40db28a425044d6ff87af6601edd37d1753bc973b768c35abb3de3921324cbe842f0cff25dab42350925f7d52ee9e8e9332e4415ff892f4c457fb83b5536f5499463307e1af77bbcc87adf98377a0aee25a772d56b33154d674576c14982d8a2adaf9a462ada9dfab7b4477361c9d73b76e4c4d2ab2673a3df7a7ec61108d557bc32000501c0febe2534f1d9d21fedea81fe20c5b7215c5bc9d4fd8b1c4790b8993f0a8cdb079e49b2271b8392820ad1594bb2b52cabaa3e61b802a1722b17f3087da7ec3f1ef74d1c14581c79061d3e8ea4359985c550f2bf48335d2e4c74fc596ad69c36632cbe403cfc819a9370a297a98b01e9c8889cd9a1ed006a0892c6abd32b0bb4b478c106cb0de8c326eea433136b76461fa18ef11a37a33bc27acd86131ffc46487e2074f276ffc60aa5eb4eb933e19af3b27631e4a547b9a9031c08a7963565bc1fb34a640c85dce5ff31f6f9e12b88dd12fd119a45f8b6b07902dc3445690318d1c85448409a0260608771ba9f4724deb83a8d527f41c4018c76faba0ea032351ca65785959482b776c69d421f9f216a4522a55e9397c69a139b3019156f0e0ed74ef32c02efe7dc75cdef827cbef7707574c290b9e61e164aa1cff78179c38f0c01716473ecaabc1aee27c29d5107eadfdb943808954017a12f217ad4312bc7f8130184dec58353271a5d4dea8bef319fbf7b8b5003e271cbe7565d721a351f52b64ae19b6b3b4936b0acba1eadc3ad953586e43f861fe4aa92c40ef8f6940fcbe787d586174289e1577f2684071e331a8ffac85582899cf2a735a718b4d006181ce77d2ba2b66732c67af26fbb70d1567bf229c30a7cb570387a61c7a90002c57873fddec4d2b880a0cf661376a8ea4b0ec548ff5c5002cd1fd41ce1d6acee141ac1b0495ed6ec02c95a99d9ad355ee66103439dae31c5e0cabccd3dbf8379310a61fb3447d7df820b64268decd14b8c627723f302b3f4093f75e53263ccbd876030148bf6ac46958c05429bad3486ad44d2b1c6fc41f41ca18e0ed776f6b54ddcc180af3ec914e6a4962f59549108c3a7d32e21b4f1e87794c2416c84ecf5522170904cdfc367a01d4ddeb1c92f289b56ebc5ea396953522c92338129fcfa2513f2d886d61f18e1c735be65f846f7e076e2dc3ecf6dc4097699186658c3ebba23fa6e53a8fc034016fe4e30c22305e148245dae35aa0fd2af40e554f38902df9336ee61233946b36075d2d5ef7c009e0355def1b11bf9cf28b2ca50747331780eea9adbfff5b611263d9641efb7205976c7707c0d7a935b21a42b48cdbe639b458a37153aa8fb07e0375a0622423b5f3b91cdb89b51c815a8cac543a4bf66c22d77140c20131eb761e881a1c5d75aafef17c40b20206268f6a4be7e15395f912dd92340a3110b9f3ecdfa79495373e24b11863dd1d5647e862b6544fe7af6f27195f29e4fa84f795474ef7150946c904b16097c45b2c115546b7030c317f3f6939faf79afaed81dd0d304e4e45d7a69a8c6f3c0e058bedd726a8559705f707d8dce4fde9185a34f3424a2e3f2428a3691a3ecf3479d6490c65b6caa500f63a2f5847f4f88f20807209bf86799f13b687565914420cc474a465bd147ab7d883314702cfb60974d0c112b6b6391d4f79204c7aa4fca0a3519a5a149f2ed033679a29bdfadd94b347cd6ef09aff25546027bbef00e837b0e95e55141dffe52c265e409bf26a453389f7a07c699a458e8ea2d52f5561eb33c3fc7f5dd549b7b6c5e100be5e2df17650b009df2e43df6ca5ce28a7e9486e4a40706052562f3a191b408ea871b2e9f53b4f7a812c7e282c413a942a632e6b74093160bbe0171b748df3ee6e791cf58ca2a0033541fc4d527696053580844db181d69c6b4ef9ec207c394b7e3423a8ab5d7c27d0220f3d055bf8df2e71b672652a48c95797eb3db0c46c53c6251bafd97fea2367cb1846bf34d1e135e47a69f24e0b4f411a7ed9b07224d3c4cee15bcd2dac6a7f85b48780c6ee40bfb16e57fdeef65935a78a017a494afe0751fcc7bca4b14375f3c80a6e50c7a8db8c578514ea1d1fc815f69714250faad21b590e863c3a27b0271a631f0343b2bc78b1a04a164ad2c569b6598e905d8ddce65ae6c4332bb706b30cb1c208739f67bd6aad973eb963c7c2b04b47fd7bd2f8cff77bd7db64f5fc293912e048a46bc01af80fecca695fa8486258aace9ec1f28f8a7c48db541d8d17c20b970cf13be1755aabdc0e4c74b6baa47ce24faeffe25ef860a45c51d8b73690a3de82f335d6b612f8b4e02b69a6c4712d52edb93a172d9c59b9eb90c7693e55bb6e5c80b56b0444cb9356b42a987b4d88dcb1e47790fc5fc6e3d0eca72650a4f3920f0b73606e621fbccdf00666e6705ce7df16cda33b500aeff899f360ab5144c81049782539eb4989311b76f36b0a2ec7ed650658a502f10c8cfebc54282e556e55794760ecb76e65c8e3f8985fa096f4f2f73e6eafc13d23c26d4a0a1e295104d2da705810cbde138c45667de3158e3929491f4bfb7e051b95f5fce3b5991bd0a2a85fdddae490833575e4ecda1513ae8cdc77b8426e36692b3f7c6fc33ed8330735862a15885936da0d65973366ea06176fd5817e0494c60386e51ddd1a581acb339c348ced065f7231707c45be464741969cc046702f1d32761a58cc85ff7e89b96b60af90784b6b2b4f4db61c9e8e855cc5b94f71dba90132039de4e46dea027171a2e184a9abc59c202b251757878bf11d7525482cf3639978904442154ca293b06d0b6aabc83d41a3d888898f784d585b71ec16cc78034511f7f3c05dd47541b7767fd36c9138898c53d054b029c755a586d95a7d1c158845d46569259ca1ecf3c0167739babf6c0abaa609f03a06fcc8f159a1126e126356317e6767f7567af02d0fd59f3639ae6255bcbf5b4493ecaede405c4caf3410facf0acf340cfab0c549500819eb5a469c80d0d6f1b4332345455e9f5d06ce7558a18036a2d5802e9307102245907619531f5e956a4489c37c6760b1a9c672c98ad5e590ea7e9da7a257b039a12911ce825e5d665f33eb7bbcd4a764394a23f4401f6e561152bc42d59b522788ccc98b094a0f7331a66c609762555b2f6ae1706a16c43891a2ca8770069fe64a8295904ac6158c510023259ba4871771d2aa2880d90d41149d73a757b8c1bee2ad16e11e1395e726f21899a5aac48e91e22083fe63e3d8d9d72cb7ca2f49bf8c2f5f329b63b1f789ccf2e4f062e17195e554ca40d083ebdca877231026f92050db077c7feceab2c631dbb596a90c6c4a19d123a59c77354fc79ee146c14a457b4448a519d77d76daf2d4b8442f0597c87ef8a57a2f563a0b688449e528278c90e62d82a0d3ac812555fdf17ac2383a2d85dae4cea3b2528aeaf357c995b0ee4910c60d13ad33964f5fa9c6543b162e1f4d332cff7fd217f0cb259fb9d7862f664b2b0f15170b9ab80b3b150263712ddedd2b1108ad17f4d6247e19342e073fb0f2f852a8a936b75f7f5a8ca64a3104b89c655bc6efd91a3d007d6c7fe3c8979c04bb86aad3faa4f861e42306df2476074a3642e3e7f94bdcb5e34de3f38a8ed76509fa2af0e0fd4f88a2a85dd588e915e959f36d2621c8ccbf0e10283f92450b4d16f04ad1c709251c2492c964cd13f8e55ded7e79565f137834ab534b57d3013ce26695a4615eac011452ea85a48550b7f52bb2d4188657f326f6091529e3f43bfb853e6183fd7877acfd7e9c5c8315b994ce5687a424887014007522336fdef0fa2d8f6e4640c5a11a3063af6ab0412c0f28a51fcd98f83d1ef7679986cfb3700f25f230035ec6df592b731737f102ace648197c19e42d001115132f181c89bd543478a827315f1f6009656cf99e1a49d860e4320b2ab283a8f37d5df041ed3fac798898037848a2d82176cdc1fca268477b7ca7ee857831c9aae5bfe6ed70a134dd8948710a41957f0b774cd64cab43faa8ce19bcb5e1b25b62c3487858cdaf2d0c88f4831db6c39aa8dd8ad347487d04dc824ff6f0a3e7999559161f878b9d846b6276a2c53e6eb696dd09160dda9de26c61d7c5d2b0978b4ba8e1fe4c95a3c00479ea6c7aabaf373e667bac0397466ad6a3d6d7a2d457c6e2f9a3ad780b2c7020fa90bfbaa4d03166fec0e56baefb041371433c549443f760e3da02b4d83aa249fc94907ab4b1c9e6fbeda30de308043d666bb8cd13458d6c1b33a01632c4fd185d415a07e9965319ad04633a3929926f00795028f7725c28f3becdcb54eb4f7252242e55d55e69d8dbbe425914e559b05713d540a2d7c62db2f8e74752d6971e13bdf990084f345d5f437f2a63240bbfcc95701a830a2a6a733530456766de5751c70f6398c81d4a958ca964ab02cad74a87654cfee810d4b3ddc3f1dd534779fa9a733d179551c02f9ca05b266fa4a28e31505a23d17764a5a28e46c9bc895a26684be551e5692ee561bdd9c54d2ec01b564c62cc68c3838dd3f2ad5a498a204625fce62520962f7a19931ce7a265901f5566acf7be7d9a5d15e6fe83d2a5a28c1a6ae6c3c8440322c04cd905c9394b2b67f7a69ac8cbdaf55c1a6f6008cd87ac0beda840090d509a234c8f6b9c7157dee1f7a4024b4bf2bd3b68deb1b9cfc6ac5d538ceb9e8ed9b3129ab81f32f07eed0ca382bd339fc21f92e25c3d45aac8e08bc6300bf4ed493eaef81250b6bd11142a69264ff400811d19e982ed37df15309e8c3ac26b436cae2a3eccd941eda7f3bc4c95c41875ea207863358c0a2803ff3046a797b3912d94b788d1e948a9dcf50ecd9bea25ef3f975bf4cdcf5f826602334859a0cfb0ca63e4b2584531c44adeae8433d462e4aba5de614953ad4ddc2e275e80c7e87a419dc02298496ba31fbe76889df0dcc7a1d310f439f415f26e9881ee0168746d25724c4af589cd1f227557635847d9c340f569ed9eb7508e4c98642aaa75481604ddfe4752a74b9ca3921d51906fa6f6805339c26c7136713fdaf8e1077ee2f2e0d7c18182527d64104d15f5698ee91f2aa772408420bb0cfea1d189587a8032500eeb49a4ab7d6c4019aff04ffdc9e3ece6783b87c9cec21c98d3815c9c5073d5fd617d1a27ce461970da90a0505087e454f172de88dd33484bc2e4839543f9c6528b1cc897ef3ffd33ea1f65d2bc7cd5e212692682a2561fc304083a3655cc66c3b3c5287882af6c134c34db88757704b811a4d652c26e144c774ea8c8fc45df34f14867d25897df85c1c4f3075687bd78f747dc62a36ae3d74536600133c972e5d55d8ac070470aa7a12af3152556e95f7725ada31364e6c39185a6bd49c1936e841e7762a7dd054cdb4d223ef827b7ab76d208e05f9aee2e84ebf7d82c006484ba9d6bf344bcd11f5ac0c506002a9a87a1e3e84df0e0c1f9b62be033b75da36f6dddc793bfb2284433d561124f5ed1400957a563c73fd9047f0c04a3cefe7efef184481ac9d1e794c64c2cca8d7862de8f2b419c5ad670e2f1e9594a45e71ce93d876199eb949fa0911d6ca83906a32c649483db176ec340351dc3be2f3e72103a200f93b4bf5906c70e7adeb6ece9e23217f0c8ac0a4d3551b04ea1a18e1c095f03898b3c6257f6abcb330e86ca0213a5070686083c15ab5a6924263f0345f1ad5f49ae9a1e37aa8dffe9fa830e7fd68bcfc85ceaf85d57b4f5fccc701293a928eb49a914bfe7defef85189e324091e37bf1490a6d20d67f340e969206e956b9e7fe1b851611eb45740898898765c0b0a90ecbf5cbb5c8095b23010c5470c23c6e2d0ee0b6538691eb0d4461686c38a8cfcc1d77bd859a39e4b7a83b235ea94e656cf2e3ebbe75b30f393118aeb6dc0e6e8bc14ba48f1b33f4b21fa3e72cf948420b40589823362c052c972a42cead84ecb5cff35243b8d809a412b557d74ecc788c38060cc7395019aed205f7c644b07ee30c6f4b67b251b0d5bf707d40112d1b7ef39f2d622501b9a49d5d7e91d9180f714e259f19ac7fb13b489f9e0e30c4f99acab45cf4a53ba517dd28b6ea1d6be7785f503c58f109b0ae31cffe2d21ed1d842514bf538f11533a9905a0bc9d4db33c2205151f841a3468cb386724d95c5364ddeff28a90d4c6a0c3f8b23b61740f1d903483da514f2216b8f7fa1464e30e6c630cc53b2e5a285285545436b242dae0097fe44008196787d21c7997275da198412053bea41b03147ca584b879dbd1fc2de55bf3d746e9e4853d2b1facd9a3d6b3bd0e0ca01bb1a928687c4b26847df846252967a8b6521c26c45a491e2df72a936785142a19b85d5a48c37d4909570e0fa1c8aa021596a66a9b08db0f41e2c83c609cc419bbf2480ca5732fac145375ff761c4754e39d0d1c76ed2d4f88b94ddc471aaf611e40d0fe836b34f115487a641a1ab25874525b7e302b631e7c627aaed530c6b814a5425d5f5ae64c1a9be90981ca860486e275b35e19067e6319086ef964d18693724f9065ec9b10d60876fd569dbbe41044e8f004edf63c8524c93339866e7187233056412e6d05c7ef0d1d110c48d5cc7a50e5d8a3e2ef34418242bf4a0235d5f052b6214fe4cd42a43086768a9078469f079fccd485eaa7ffa9f9e49317fdf8321ddbf71c6a2dc2f70118e3589790b5a56b66489d483c2eec6033c40247d5170b838ad19f2192aaaec305c7f1bccc70a92136384c9dcbb5219af8ce2e0d2abcea122fa45128bed36926c73bfc0f51a83c33b1fc5ea0ce72d38a6b35ef71430893aa09dab6e50d2daa9613921e301c170c76427288dd958f8fec777da27fb468759d55b58ac9330b0fa62602dd51f6f796ab52348354d188903fb565ec15104cb56580ab4473150314a8b6b75f551da6c2215d33bc33dd29c4e5537d88685b2095de3ea03bba66b3e136dad80fbc6aeacd0ccdc331069ad1396e7d540954199bd46d002a3bbda9d9862b5650688c41661b4ca04906df608d31cfad8ce6cdfa419735b82fd95d5cd41eeb9d51a227a3976a860af8d604102459783521a934ed2347e4c0c0ef4078ff51f1e62eff2ac5bc30268c050f516f81d0c9e8ddcc7936f5a0f2d14028ed39aa240287ea7d29240b0c35ea8113f0963cd736658386da60f1db486b3e141b318a2c6ab269395e9a2c7b6ea2f63855b6b0484653f6958e9cb466b6c5a5e46a0288873454f84de3d53b92fee8b85c9d283c60c4397f650fd3877a8dede341bff228d6960b5b485d4bcdece6b9fa38c7e42f5bc6e7df6e37b0a3dbea996aa224811bc2e14de041df3016455223d195a571428a8e6a1820e9a41b8bdf219c893d4fb92b31a475ce54783beeb302873e3b97ba495d2ed45ebdaeecc1a3391a12be39545edb72f7ea8e8c8c6aa9f6a4938be2e8be7e202bf416378a74612520809f9b3b30911ea33dcc3e71d645f1995a2d1d0de50a20dd19ff08e898d3869bf7e16d8ce905ea9861a23f50a15493b5342f3786fc5e2524776e5268b5778ef68b4ab048705d7475b6deb6092297138b05a60b1e2fd6b83ffd342d57d0035469b79d56ab000b3f98321a41443eab9d3cf5fe3c32cecd8686106eb9acddd01357c2c23d11e7f7e8b028e19a95805c7dffa23c02f140b058b1a560b07af00c4a7558658c4e542c0c43da18f535f7c7e803200be44ed080269695832a6fbb5b0819f7aa5fa4f3d0dbeb775fe7f284b5022b7d6aaba11522910fc08473f77842a6e2208f49dfbe2c990506f2ea9a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
