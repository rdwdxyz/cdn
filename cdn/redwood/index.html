<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ceb1dcaff7d04d69059f68bae385386772c52c2c2dc1697598e9c422488725353e1a2b22a98157d56a5bef56f4489a469190b0487a8674179d3af6c8b84b1f7d9ec0af0df71b4bb4c784ebbfda0885862e1bf6e95071cb0562c7c9e9e167534ef5681ff1e45574ab8f936a6cf43480e51c8bd45a03c5a4819b48a89d1e9520c72bc344e845b5b385fac7b3625ad06dd6eefe570b33ab24ce470f4d5ebd3c174327a5072e18686ff62421d8ca15367edebb333cfca9634adcc235a36fc870cf7d1de7941e0b486c1ee32329e5c76207cc63594a59782951edb05afe74da23dd6bb84af8a661b7fe33fd9d652a5e44c0ef66e03bc9520d76106c18d3f5bb61b0e2564cdcae9e016bd701540bc175fb464f5df29e211c7277b950d6153e365b75baa17ac6ee31558697a911a0aac48a6a766db7e941cdeb9fa8999159b0fa5d006e96710aaf5b11ea0246de6a9f96018d4407cb57a382c611df2044b00203a646074abf47812d13fd47f252ef917efff59a70a335c8e223bea870e57eea95f586c12c70e9bc4f03792facbbc42696963bc277c1b1d0ae19d5e1d3b3de94b86f87007ffe2cd4f388646a1fd02d758906beb21225f7a95c4c2d9cb1a8c32bcbf2a3c927f17f20b3a7fc55480ecceae65eef4867f3509d50caa6139b5b66a9cbdcf61b10333653474a2795ecd5d1d0bd2d668f88fe88c510da3be32c3fa0e89b02122af15cfafae4e3d024d64e7f97a230b4e613701afc4d646ec63a2a43a9ccdc2961e89d2073843be697cd2cbf1f23cb5b9e350f751e5df1ad7b428016e20d456d640d57bf2e38740f1634fc6161fd720ff0acb3af5907da7a1ee5555dc57f2f2d6f8245b7d71a413b97f2f14faa2ec62b402308cd11b142857bcdd5e12b0010a427ca9525b84001953e739dd724a3ee823f90373cd4d8dd2768faa572013866b970d6644ab9ce3cfe0d85934c59308d3c5bd4ee6297018e649e1f483ca63e48e19f87f49d158e55ef557a85fc147b6e1c0e209e2ff9fea720fa5683882d8d1bfcda72736d73394e4d8a7f6e35e0e8c6d7f1ecd7444278a84ee8ab405bf7abbea513d95ac74ce626e4e3981d3d8f941868bce65f62bbac4cc8a7a869c2c8460efa6988e2eb9876b76f7efde484890c9b990513964d7ee2202eec060a77d87495684c1f9125bdb3cbca0b28add25ad6ba7ee3769034c7386edc6eba43e7c80816e7a1a3c9e24e6ea52429f5707c7bf5e14d99a56f9ef464d130af9af31eefc37c01a873f9ee2292485cb869381a848f75af60801232e2213e8d80399fbae7a94bef0ecd250ef2d319851726cf6f4c8434c9afe096dcf1c8d680f0f990e801ee3062d0f25028fbb33767d4f33c5117dde93024c3aad25998017c5952b03cf8c1b4766b2532940227db14bc9e97edb62a6a92741d01fcc91cd22d4e5836494a7d1f9fd674b9204c78b25da67b94693a16e8ff26161d37d982acb1f743de00bb1a95cc70aee2615ff02f0f65416d927bae2ea42c990ce6e258024039bf69a3b3078d5194fcb8acaa5b7de02454d3872947b2ef24af67bdd39e6f1c23f77cb1a33271f2a56056c6858dfc8707cfce07eb43deaf4ec9906a79c657ea9f6595140cbde78aa552fb2d6b0a1607d7e13fd4535608cd5d959174572be6b519595450e7187ff5c77f7b9f7e9a4097f2e0d511bc54d1ceee9a42aafa5d369f4e0c6fe26f6bd3c88dc68006e5a3a238f972becae0cb1da746cf045caa2223c46e0329e181c57d1f1cd012b6d34b27594a7ac34838c24b26d6995f9342c86c06d25ea0bf5e1d17705509455b0798631f00eca5100464fc5708e5f68298061e74b6822933d40d89a33dc6cdb1d9d82b0ce642d9edefc1c9bbb4bc044506b414b4f4e056f1bfe488c9059690b35136d9688fc415bf99912a037413e3fb7d65a8c2c64877bffec2aae56d29a486fcd5b67f1e0d6deb9dba645fbe41480c9f7364d03c821914c096ccebc8f46074b432724d9a64024d4e698c1d2dfa50d5341b6f4be3e2b87badc93aee72bcfdbc94f45095273eb11a233351b637921190b729953ca743cb1c5c931e683ce850b53ec94fb73033f9e8a0ae7e0c7b9aad052a78404ac794dcd9d9b5dd7390d1a3c97a60d6d332841d860bb89ab8fba145ff004d3af8bde27d1643a9076beccad32481f35f693243f96215b085becefdd1a5de58670e013da2727768d31fb154cca546086aec1f2c43185d2deccef7dbbf1bd2d980424e2dd60849ef3d8f335cbc013bcd90179dd7466dff412e251a06713bb2e07f284b7c250b5115c9631cd5f8a543329c2d87c350ce709d0df5f17697c49bdd66a97ec08dbb3a036d513a1d2a6bf078e14e52c1e203a833428bf7104648f18d6b9713089e5bf327c294a12ab58e8471a0a2abd02eaaadb6eb1a6ef61ba339f191fbb22d11c8964f5ed434b35e1708f9385c688d96fef47413b95c846ad8e4ba86fb30949a9dee4a6ab0e1c024c9c17c6655ad96f50d3b2e27875dfc53e82d2654ac7784614d2fb9b692a310c0dd5b68074f3d10e58dd89b2bcd1d467c64dd7701db4a571404b14e16140f3eb85882e254b365f8817f830e2ba334f5fde27779cea48103c14405a1993768cd03f4b91fb348829bc7bfa65250b6ba5588795239e85dd030a88616009e3a7781ca186f1b3f47a9745d1e0667e9b4778e31eab276f11f36a028e474260e58c1ad23fbae54087a6ab44ba9aa0a90d0f667ce4ac63c504cd0fde3ba14818203d80c4212292fdde9cab806f06340fe7c0dbf8602166cbc4525b83b3eef47b03e888d718b5180e5281c0ef09524f4f1eb70e03d9174b99e08aad375aa313fd72847859ca64e8942cff2a17707bd88906bdfd29d3409a89922d69059dcf3150083f87e485f442465df99021665b68e03143a2c7b3b9527860c767deff62711be64af7344d19da725bc11d0fa3e44d7f4a4b0f02a970e571d5c89cd41153b2781ea6d6f012d9861b82c6d352709e809da6a6c8efb6cb00517bc60b31b5157c5bd3bf94feda7363627164e3428c47cb73ae94065097179c147f46149d974a69b1596803568f014631fc30a1e6ecb4b52240fe20c285b8169000581c039814a482c9cc96e40d416675d9d15319e18b4be4c16817380a467bdd6739895bcffac49f91e9b3b14aa02b29ec799b34fa5643f308d6c050b13148fe62317050040ab8959747145403ecb42253c1e4ce28d01b2283ca357bea70620ecddc143a591847ccf9c88b9fa02335ff9d5234dccccfe0d9e068d63b2571a15e76256d859960f4b24884a1b7703beaea78393b964720e7e9c687466717d1e9e411cdcce7f92c9fa8d9ff4216d278837e20ec5ea40b7df81fec5da01f29271615bc487140d8354edf745b5517e25ba65cd878fd2ed2f5b669a2eb31ae8e7fbe9ef45763e0380e7c279a9dcf77dc50efea869714c71cd33535754c71ba35b24779a111c8f7ef82d2c45ca959e8f5c4f9f05ccdd44c13c158f88323415983f3bf89f13824da0616846d5d35d14165bf765c5883c762b4c7dda19e30bfd1eda5ffd23241195fac8dd8c7cd0e37294b913ca570a12f5dedaaa5682f39df42208ce48f27fba48b04e4c2e4c5811b11dca9490edae8e7859896bce3c5ed62571b5a8cf1611a9602a6477562495bbce18b011a5482efe46c452b8f9385702791a386e126437a74a083a9c7170c5dc5d24eeaba6b9d0d0ba80e9bb4e1e6d1d8b8451603ecca800b09ad0d2c23960018053e4cb3ba3373dc975069b0e0192368bf3755cc5781c950108c83b6467cd22a51ab49187848d91b85e6d3695c78e4333d7eea0729857a53e54f41202ea64181885c560f081ef8899ea816b9db7dfe88c4a58b29eb05680381dd4a24169d920e5736e55681c171ddbe86880facf356037345fdc005bb7dc943a616486bebe2925fdcc57bb91799d5c3270389e5ef2198d4998f2d0ead12f31100fb4adb0b91acf73d4b7c5fc9ac902e66da559041fe4a4c26adbdd8599358f962968e03d02e787978cc352301e1bd40a132bc93149230b37818728af25355c73dfa75151e079c5319804c1b5aecfe43f748ed65c42a2d9ef78c1d8ffc3bdbddd279f8a74c7c76d20a70bdfca6cd5ecf42ff56f90464465eaad29e0d77ad40c57ad146d045f70a8a00db180089f4a082c3181b7040782b03cb819974da4ab1e8424081fa7d3656542227c4e4557a529094e6c51b8a8227804ca4049566452641992bdda82c53938bf19f7841de4c7659595dca88526bc4dc3af1f1026298cb51e2cb111a78a6dbab5a9165e565dff87b6033425e83affb666b54415d3679012dd9d63bcfa05e28e722a22c2a23f43c4362d1e93cfcf5b5308b010da3f01c65330ef8706716a6a8664acebd92b2858cd52706457f81dabe0f54fc21da7ca2ac34cf829ba11b3644587715ec4444d4e174b4ccae02f16128b93eadbef75177c7bf6b2c7d8ccd9b5a437e3ef736a483acba25fd09dea057b6824d497c83c49f3aa8ad730b67bd617a4764013823099a21303840bda44cd67a3a98524ec69c9124f79a16db53ca869d1c4cd790590ff353ff37d251b117de49d2e91f1cdda3fe31dcbe76c662a44bd117ad87192d82adcb26321881c075fabce98edc3f0c1c314b3e834c71a3d1c733e7f3d8d359e0794cc48ac118b413ba7ccecd4ed85b9d339c1c5bcafce2244058631fa7a3e8d04454ae4df17ce26089313de5733f882b88da85e8584641e5a19c286fc75adcb5357874d893b2b15a4f09da76e8de8254805d8fa28d2a8c9c229865843319c9ef590d4443c8f81085e2490daedd507eb0170253270f2dab4ce1bad1147e54bf57dbfb72e870ad0c2368f16f7cea505a012dbdecbacbb80ae1debd493eee2b319f55f4ee482f0eec15d70c591f6722002268333959295fec0071b4f90442b4cbb8cad15c9ce20ce494d156faa807fcafb156c8d2e2a039f84a7eea3be882c38bb07d1d56c2115a76f4fb5b8983c05c3d27b1dafccef61ee14c07effae6b58a0e51d455e7a72d347f5ed790235cd1059a4ae965dc8fe6d1aeef251622045a4d4c1e5692d1cbc10c20429c79678c79ce23a46c7b29dff610677b490caa36d19b36674f7db188f8b81dd7aa36fd28163c9f22ee29e7608631377356c6ce7e7673a8704115673d7efa54d8919863ff8f6de4acbfe430d6905cffb91d2edcc67823cc7569a45e88cecbf3a0a197be60c6ab0d8ed4ff4eeabcfca9a0d03670494c22ca0a99604524091180a05f7c9ea35dea8a0df35619868ab38418edc0985c7be99978bebff434dd1f441c393a90632a2188ef3919beea8563975a345791b6f6e2280e99bcd30b0ae11ac6caca503af1544ea8f10a2f6b927192cbfb76f5062c0eee6900aa4af283be259d341a2e50852af9ea60e3d6cbe0f857cca14d786cc9e1d98f8a3bfcc502993c22649e856a1f270173a58a0f3c695418669e38a4a14969640d01b15e6726cd0f5a62b06a38ab58510eb296e38748fa4ed5ed735c9e12a9140cc1a5469808ceeee1bb49572a26b72434b13f0294a54b128f3ba1df8ee9f0efae8f31d156884b6be46110d674b3e4ae04495bdf2d85f3885e13741939372f55acae7d124430adda227e66704bd1775e0d9d5bacc62101277f3021401036c67139ebd6161e0e85ec50011578c93797b52f3846be6a9b43b1af9132520c1efc6b060d30895f0c6893e44baa1a8ce9efe44c2be68822963aa54ba84ca0f25c4441db1efe1beba820505b4abe769007461fc42ee4d1035a6cdf2ea38b351f2a069e9b93802299e13d468c29089ac9ae2dbb8feec35a9d7a498993cdd3f52875e09d8306109e7c2948f16248d105ad97ddb0b6bf8f927f722763a27067fe4f70e23e40332930418cdf1db42198879dcf7ad47d8ea6601c8d064ed396930d3af24045d300578e0ce915ff7ef758bcf7f8079f0853fc36a86eac35309873b266e67d7a87619cd156d83749338a9ed112b8fe21086436d773bb67ee3d72970eaa461ea80379793d8fbb8906feeb0d3db64e34b440b38deadc1d480fa8130702c4f089f205be63597ac02d7bbf382bad9d14695f4e59dc8a12f2a7215e53f5724c99bf8fa0f3b1631b1cbadcf65faff412d4632e1614578ab60fd59d3f6fd092655a8f8173fe0185bad920890c555fd201ba9d2315996301d94b42348149cb2281bd603bb911c9efbd52ff3277945f4436a3873dcc7532a84699f47cbcc4bdb1a7557a2e2a5e3517d220e5c85e54cfc02241c9202b7b3f62e1c31ec82f473e2e353498d4a25c6a7e1a69d04055d57e8c239685e9a0674e49c5f8403edb4fcd9922e0cbb728430c225e7881f3ff8b53cf3bbe6f843befdfabfd00af432553d2aa8a228a7abf07f02822b7e4feaf2dc819bc22c8fccf10efb59f00843435a7d3c15a8e4bdde6ab5dc2aac36d448ee7f4d7f1fb493671e42cca17781e02eb5727ece4abfdc25adc4a929e8fdff19f61e1a66a90dcabe6f7919da2b61fe38beeffde4f7a15670786de4b23b906bddc42477f99d3fd445ecabf13a373f48f62d7da95cb8e43c076c7624a7bd79e55dbf01acbee27215d55bd352fa07665ee2a4e20d0011cddf19fd30b0ac1754033aac40848a369f1041278a9f2e871db6fe6738f1c1af95421dfcb2ffbc193b302db18fd7b87ee31bb2a2b83c82fcfdc7793084cae1119d63af1605701606b4cb52b1f504028b5d43a58876fa5bfe690b01b51148312883022b4d3f0d687bee854ccb087dcee28810bf015fc4ea116bc2cfe7f9914c89cdf403954ae73dfb18ebf02631bdcc49ea45646995c109c6174c7c41092ea23dfc6501e412173f9206346838cee1fb114395677aff5b043f1a116e061dea4d05befd76602cd7d0574546b3fe3b16129efa3a9ed5b7a75d06c8ceae3cdfac5585dba04084ac791447cd9ef868e1f375a2770135b2fc63f96e828df784f74d55719ffe89a01a79bc710393a2728683d7d803e91b11362acee5e61705660c394abe086f72f14ec5aaedbc6e579ccfa086fc0a4e0fa59815cdbfd8f3cde1043ef8d2f79455dcc5c5046c9ee51d26ae6767e9073a2cfeec6d721f6883c259a8142b590b892cefcfcef09b2b66314d60a6dbb8f71812f1a99de6aa78a0f807dffd1ddd53b7936ec0fabd0e1edf1301fb8c3175c54355fd5bd4f73f82658942aa5fb00dcceec4614147c57f9c04cf802ba978cf6f7674802aa084537077227c5c5ef03e43e277c181e8e77f95c99be94eb8960830b31ded2fcbd4b800263c6ec01270e179752f18e41e973cce0aa81d2cc98c1eebd2799058a87d6d15bb61026f57e827bdec934f73242bdbea60a2885045677e5b62e1c3fcc4cdd106eb31ea14d2461f28f27cf8f9fb41c727f4dbd8714590075f1970fa8623799904cece09af4acb2df96fca27c275b2d7a4c9662f7c4238d352531736e4e7e72a34d04253b8a4ac55495f717497a3d65940fa38dda37ab8f4a59ac346fffc26e06374a2ec5fdd9eb0437986433bf2d62aa2a44b2d1c06b8602f97296b707999bdd34dd43bf461c61dd5f65ffbb43c9bf2494ad4fd12e3f0344fc93795d1607a851ac630b63ca43cdc621c4fc5352558e55dc5a5b4e1500aa3d45d858f9fac6dfc6f0adeccf2ac0165817624ab2fee4d82d158621b83406f21d5088382ea77210172f4cf5a779a735923b29fde6a76409c45130349126954c2fa1e40ac4a919ac9c3a564820cccac9053112e13ea82da6badc5f46884d7ab82e74f5a9611d472928be44935c43d185f86d14e04e86a36f9c6a7b5b6d95e750e5721a783a827bc5b44066deb1a888aed4d196bf0eab7932fe04a1b23873ee9f1548a21b22e9116ba0641c6f582915f58590f5f4add83e0a6ecfa54a3a1a9c102968321648783d452046472f6a133452fb051be1080c8579bce85e969adea7f8abeb018302b9c6ce263742d477fa97ac707009ac38bf4e1971f7b20517f35e918fb5a9539dec2895e9847a1c8510ec99e2be1e4b9cb2efcf6834d81d3dc64a17d7bdbe3f47536573240631bbbc30f616372c96ff1fafaccd469e6607a7d583249e5a88c862847e61d0f6e8d34f9dae839e98b501e30906cdfa293165b709b2c871cf5a52d65c20f577a17492086d38e538e96f308463c9163bdaf243fb2138f368440725b8432cb4acd5d66fce6acfee39b63b160dcd89a16ddfec5734b21e26cc42c5dcd35e7e0f1a4ec3ddd1072fad35d4a8859b5c9b11da325bc0341c2ac183d65fcdb032be08f76db6f6c10bf97e6e9cf496c5754b25c689a69102e8316da1cc508479cf29b2ce1ad31ef720a92f8eb53fbd31ff7b5ebe7ec0356eca1908aa5bfa7b959a3b31849c1198a20d19352ebe032b06b4182273a0067368d84b405d9425998bb59884ab430e24a167ca5d09c457824f9137c75d11312533f6cb6e4b03a49fc81d40ec54de8771f9bbbca0086eb99cff16fee8eefaf88ca53e81f79e46fe08b2c3b574d493de23113b29854ff48d5509cedb8e2783ae91e64afe3e3c2903181df3342b2e4059c93d48a7ae6a7ab278f4d6513ef65546fd265ac9c1545cf5d113fb8b06b62199f7fcdd7561c1d24845ea01a5918d28c96d4b53d8710d406b5e4edd5a3af31c34667acb11133e1ecfa91a2c03556ac4b2d046b86658770ff43d499e5fb6a54fc89b975c8f6579d727a582f20a2b2af20c4d285f3619815c127bdd34b3af8b4f91d327f55f6b6629d1bd9ffc5305b3e5815c29347022478d1814ea92e423f2d9b9307d63dae2ec680c88f484cccae5193c3ba259ee7a969f3b981a4b3890de7499b0c69bffd789c0e7f93c482f56af5e7815c8804ffd3123fce75329ff512dcc96de4be4580189a81e93f751f7b1d6e953a8f39efa497660b498e496f5e124eae9eee2a81010ba4c3c6282d999121d187942bd37305eca7f4c32da58fe45f1a56d17474e9794c592fc8dab91535b0a6d9068b9caaa234f33615d0de76a0994cc9696c09478874572c13e9b1c3b0f6da5f0874bfecbf6a6a0a89959fb121756488446d116755f9611fd1bf6106356d023886421134e6c0f79a059d2faaf3fb7e32ca396dc0442f1e09792642b96ce97134e37c5968408fa87c929fb257533eb782ab2cd4e234d727d13848b67e5e765d4afe3352050be0118ec62ec12afd508e852742fbf0cac6efc8a9988e3d12f0c17dfc1cb931b29d578869904846692563018d2e628bc5c31065b39c106986d92c2ad6b63e37eb005617c6f8d1dc27464ce919a86df35336134f089c1a5632f60ab487fc8af79e86e7dd437c08d9a6e505fcf8fc60f00ed6888d3225c4acad6c2b8dbffc7bccab22fe370c62b60408bdf91d104057f3bd07ea7703c813f8504a1488fca6d4721dbd0a975f51df11fe0652dbda84afd9aba0259528775d90715065748682904dbb172b524db36a7741254d3abf1d97264c773a40bec6635350d02e6cc6a1f5e49aa783217863ef3f5286d3caf0e81242811d85d16dc3b5cdb421dc036ab9af6cfcfe82d1be0bab7af19cbc3761491a35c17074f27596f7209aae564fe55b74da29041f039a5eddcf9776f7c0fdf392e5ba6df271f1756207228c78aa6153aa1d64bba1b32c4a5eb23c5bf8545ada45b24e2ea4f16058a832924f3ce0f402f6070696178941dd45f474169e9afa6107f033014f7aceb19096b3bad53d7469e123c9e6bb080ea00b7c719c2fc4000c4cc9b2a2bed1616bb719a8e47f806d49bc47649f793644695882f1faedf44d415857c1f85060409b73b9414109ec77b79b1a47a364816597c9787d0d8ef968409e4ad4c0a501fb09fd5e44b4c91627472035fe0f982ed3d362326f3ad6eead0cfd3a5fceb6674406db895e18ce28b4aaa464edec0371c0aae52505d7213ec0234ce834d38cfc54fb5d8ae61d7e4625d56e0b53b09d021fffda407e82e1e40584fc50ff0d4216976278ea92d14f22f368209fea68d8464e6731e46ef65e3c7a6e4594571d3e5edff08c079f3938b6deecba73fa82d488b966ee76bac03860d7c8a3e62bdac136eadf19945c94ea45e59fef53e53e8072ff69e08ff92a1109a890d342613036e36a4993daeb575e3e1a7eea446e92f7d98a3a349b798cdd3cee284fcacc73181599eacef415193fc020c970adf50a0227a1ee8e1e059ee9c178e18db606aeb7477f7bf1f14cc845ca09d4c4ea1e7b5166cc37fcc52ed0008e412f9bbd639cbff5e3c7faf8a99be95bb42c134a58b6f162dc156799ef3a621b18118bd240339ea38250336378940978ad7fa85b8e72773fcc021649c8c1a08a4b08dceee651dc446d9f8d9c43f9fd4ec643ae5e3e9b00e7adae8f1970d31db672f6c58bf7f9b4ae3bb7ef9daf3e377485c088c488ea5c482a2189e5a554d36f442081fe560863560840d255d35f5e9376fac69ba8bb82fea9c40fd1028742aa41882aa6ac79f51db4022caee8ed99331d68153dde81559c18f2f7a0d0246f9fd2ef8162f40cce28a14b9cad8914ede3bd11794b49b217d4bb03f5f6dc015015ebd2161f726a08c1845fa245058c6d10a48f39386f373b53daabebd65d99c2523482caa1299d9429156732eae14f19896b1cc02a3e0ed5bdbf50a859898909bda0dbaa4c1ba87be8835aec30d2aab9921cd879238652456d8187cd540514add7d4452a260c9121f2f1bbfde127315fccef3db794af6ed699e71c0d01cd9f5e827153b230a406cffc405b07d14c6d9a04f822b9b18873639adf937c1402745a16b327fc3d76216a6e7dd019acc5f4ec007f1f62cbc74e7587ceecdce3976a18d302969ce5778dd2cd9f70a079d12478b9a049cea50a5e37c4caf4e9c803a6e7a975bfe14b3bc419cdbb45859b7a4740650925268a6c873da1fc86651735077ba0ca88e0bd917b839fc3dfd2a385e71c5c5711ae53da14c1ea89f3b645f0268cc4d9cc4b3a8b4c7b426907e729548a6e8d607080be510b59ddff86f4ea1ad33873711de6201be526b6c27e614a27e7af607f9a877fa29fa915f0e81461559a1e4078138515c61d5674be5fc44fffddc13fc161db818ae03c833ad71f8daa0b48cc8eb3a71404eac7ee675a7b7170f3dac5a72bbc82c64101dd6abc15f9e3e21173ed8e06e7a818ef1f6b315729935907b64568f0603b31454dd57ac02af0ed788187294c39351247bfca5f7c39854a0d376e22cdceafe15c3e04ade779fd49096d931dc4e6bd6303a28f6b8073d25234d722ded352142c230d40b3a710e995c1923e410aaae2df80fc7731be8f6b5e40831dfeb4c5ff604b01d51ed04e755f6c057c10aa58587ad13f4fec9e916b6d253022a0bbb4bb47098c1debcb22a63ae9097674eeca1925ce5ecddd353e01846353e0b378799b853de545b93ffa29a7f026ebb5c7d41fcc19692430c643dcb7157975d48c882376f7daf21d1ea1593f1ab9511a1dc03bb847d1a3d465403afb1fb369625c6f9ef50a78d81cd4b158c2845eec9c32d19842dedb4d9675ecc2016a8cb72aa237e7ad239126a9f5a36e38cb7e799ab3e2bfa8330224056061b3cbb57d3694496589fceb777386d8acde8df41f6fca534f0ae718d39ff16426b48360ae703ce6f9b1d88a74f0ff76a1f6525db95b7f93e3cc3fba4c610ddfa2ead3d4a04389ce192a7113fdb684cbe84dabc258a35fb260a90aef01abf1411755586dc83ccd868d78158b8ffeab3fc96bcec270e6a400b19f8b88acb5fd2869ebe61d45c888f7d227627a674c1d318cc24b546f6a0cec16c6f9847dfc033327d935771b083911b97346b6d120400fa7c8bc460464884c230a5d00bcc2b06fbe8deba39d4b2140828f1e913e830fdefe65ca86c861067b5c2a68909993c9240567d5db956e48e907dc609645651b9a27c36318e8bc2dec5a71292efe4e9d5bd3b7af68cf1560695d41811bfa8acc94a441fd4578b60ac8ff4c5a39a4442934d309507804ab859701d38eba922a74933685299916e763d3d8cf7f396450630a828495f9e45cc6fefcfa4d4f9cda1e363ef22a33d69907306316bf62ff5ce3a3008b5840e21d0e1194e6fc5c03a0c2006cfa3cf11657150d6c988396ae202bd36bc16ff381eea99f2290229e737b50029e161fc17c875d7d1ad732c1c5c2f83e59b8bec766901ae148454d80bacdc17f51968cad47f048d063a42372dd22d33d64e0df11061c266e4455fb00376a508b0b1999c0b437803b680d32ad3723467fc85f924c7cc175336481d8d31f4063b25f588418ac9ace313d880e50b5beecc02c83ff4a6571141378cae3f271eb3d14ff7e2f052a29d5aa30c3f84cb31a96a1e6e76adf421606df38bca3150bdc16f8d9fa8e49396fd1ae82dc6ceb657acb65a36413e8203a409f231bdf5a9c207d723df508d3ea608555554b2eee8d93adb4242d4e82de786bfbb0fb84a4c4616c95193301e2e15dee83242b7c6760df221339a6aa6dd34dcd4a0fc6b7f9e1aa639bc52d9068baf6abac934531d03f5faf41c7c79b95d65ebcbb60bb207d54c7f946e04d3757542b4bf555c15e1fe986836ef980fced0c5cf21cf10e6a17e71410d62c8d02d7bd11b82d23453879f299b40a3c6b18a63bb612105374c6344d4d225a28287f63ec91aad3866cc0bfe0735326803a4614eaa142437005357d63148289b685773045f313d9f471a9fb0cb4dd0d99cb4e0e3178750954e4fa3c8ece2dd487f9ba88e862820df635e934c61ef6f6fb19c7ca0c2d28b256004e40bdc2d12e6d6e0c537b509c2de11feff999fb742c6c6aed2b983aa0abae78ea64a60928fea3a606acf30cbb134defbec9a05a9a5ea1c3be53a37cdfef5c56b6c66e2cc567bc474e241db254b6f74eb1bf858fd97231c1d73b85485ca7f5a89ccf4e4fd37ebfb414a81760e593fd421e509cfd63e3ba9eb7e537318bc533c17e884049140ab7514e649633f7f2287556407813a63330a9a8d962c4ed5b1c0528f0ae03305384a67a92f4fec0005b5a6d5467a0d87682e586b34dbcab23b2763350a01932a0f0133a065fd1b9c569b481f1a2e73414f5f4fba333da0b7bc96f5784672159da30b17fa42af30be123e47310ba30ed0e4dd625dd37ff48441ef9f7adb390c4100b6f5c1a18ec978525718613768a99f8b6ef05b8c1cd8989abfdf501f65e033d3dbf587ad60ff983f4d5470750d53678d677e97c1a4af05a5e32e37471d0ddeca44d997737b6aa07038309fa10857917cc7d59ff8ce8636b80793d9babfbc4b9f29c2fc88ad30b397739324f23eb165b7e0807134bc27dfd913851ffac5c8dee429722868109e8dbf972cc4458b392bf75a67098fb9c6c899b1e7d113911b576c82ed64bdc64d4b8100697202e2209fa8090563a6cbeb0d1dbd1b5fe4dc3336cfa00e0ab5f373f7bae612bd5d2c8501e0fcd49daf07d14f3a436720d0b6c791f20bde00856f74ae0fae3283e3b20ed1744088d0fc86198faefafb02632d0c2fa6a27c5c78b447aeef67ab7eeef8cde9df48358a66d549769dc0d6d129a58164b98ae5f219c59a17a4f44bc18fa99270d2565841e01e40764d858142cc46e684d948ece082d4a2c8d69423cce362711466214af33318a0c772c9b62793e8faf04fdd02bfd535b41ca5b35b0b057b9a360d3a8938056e826b5cf8d2e35e6ef6138e2ea26cc76a9faff7be41701191160604a1f6c97271e921e9039e89fc0fa88d8fba004372014579b0d0a8ad8763b2a761f08cd524bfa028192c2453ad37a74e8af49f8f6a176ee279c07372de15f1d693fb2e5e004522894bb83019df149d6d49b9ac2c9b15abbb60e5d092a244b27c1a2763757b83aac748d97d8e4311e53a7ea3cebcd69ada851dbf0022d6e6a9dc72918b144127d4fb8cb670976272003a352b0e3267b027d5423087539cb393fe26eaa7b99d4d28678da67227856b39ea6dc3b2f7153a684045ad2de27fd60fc3db1e2af970f3cd0f9afe98d4bd8005c9bbeb497f45f522ec0dc870530d9c49795fa838eec701b774938c3b8e63f784991c3cdb7aed4a2baea33320fae98f07b206818bd307c8879a945506cb48d1012d059bf466490dde415624188ba675ee1585307a193e5dc0571d34c5fd46f6f5d710663a086a10c8cec65b9665ef586b7a8d2fb9c6d0048bf25e01e2d36e1d8849f2ac510ee6068fa557be735f33afc3621f9c304e04c265c533372b0993cc8ed3d0dfdb12619721ff1cd655c8effc30c869d61c6142e0bb545ce2e8ecb9b934685e20a219e758e918efb59c237438f7b0b9bf359aa2be31689cb434dab536d67fcac18539140f1394a11b7fef1619a4c4459728b4bb193a319af8b80c1f681338caf9d2f95d0554fc9b39e4ffe082543ddb62eccb4b9f45b2eff381fbbb0c5fc365f14bc842859c7aa7173d369d47ec1000935460f06b17fae28c192a2b5012b4fbd4e04bb9a5ac2b8745f035ebb69c37a4547021a4d0ac21bc8fccaba31c6c9fcf273660d19cbebeb80e94b03d32246104a7308cb8198cbd3f611689d45a7276748930e8a8ad1f39896002dc2a0d71acc1e3bfbf07a48a6eb8f540aa1590af89e84dabea31a858f9bd57d5e20938d306c254466467b900607953e50179e9464b4063479c6fffa3b7e191ec7b291ed5d56ba083116e3f69655542d3ce189a68af09b0df1cf11d5531737f5854b90c9540ed28de8632dcb25377d0b7775123eef7727a92b64a730b6c37bf6e0ab45321786e915e3e92a135c8a85881c0286191bbb26c123539b9740b879381a3b31c07e00e2cbecdcf1fad2f185154648223ee503a426168d153f75f1bec7842bc214d9d1f223300e9f155299b11301ed7da5cb8eba976fbbf7aa1b72ca44c16d974a09e309469891baa772984fb052b157317ca48cc062ecdd1d16b92186234f853bb3473a2ec488b0e43e026b6c807652802bc5516ee11012554ad9c63df59a8fc4b732b866c0b20d29d27a38cfd0e0b4cb75e17cddd6445eb0bf9210b45651a17d14cc17a274a729a764017b905d3efca2d5a2e60dfbf96a66e29875fc68985fc250be7b6810a65f3075554f6af7b3ab2eaf66f9a6325d900de2744d89b75dce383579439e1e9161bc38b61a2fb7cbbe3d04307e0c664fcab08563941856abe3ea697db9a5d5b2a412e3b04eba096bb1c92033ae34d9ddccc3f8b9c612634031340fab499902dc5a8a2c955a2bf1c827debd5631354c800571129c177f2ec51041509e5315f4b0d75b803a9476880ca889d33cefe3f219210020964b955c62a29743cb587ed2908d3dffb3de759028a70cc803cebe1395147792816f23e5f06433b4b237001b75d924b2cab9d6e8202bda6339d968061ecb75d676c42e45db57f834b31aac21b8c09304cdf765c7fc8c38f0ad45347db1003ae6840161a04b4fb770f264787d1495f800a78e67ed663612cc03122af342dc58cbca13e098cee513c41858c5713ebb593088077e2456ee1666f265d7e27bfbfdce967364da655fbe95c2d3d4ed18ffc0c0616d65fd84c287553fd7bc0d849379ab2187ebdaa942d7dc90a45d59cb2aacde3e63d04f8fdd00145cd536cc3a1113e2484b8f5b0ab83f39c94d801c42d52c6b40b3aecb5c98fd52cabe53cbaccdca81884a6966b80b250417dbaf94bcac06025330d402d1688e64e7d66136298749479754f3b12c48400be51ebc824ce104daf1a7cd9b9da0d534131c1788bc8a13fbbfcd3a168b49545a25d0af5ee623604e362da79b8ee41b2cda2e47a609f371c2a17085b3280374b07c9705ba646f5e564e37e904b70d4c5af80638b47df55bd1e19acf46b22e1755c68ad3bbdf1eceeee7e40d33c19da402302bf03c253987c22a945dc8a4b6e52500098f80b0d1db1f360407c944eac8dd34ee22e394b4cf151aababbaa33835d09a17824dd1beb3aa361bcb1fd35c7f754e20ebdc96506f2bae1a3cf5c43478b8365fb39d7a8fedab33f57a70d0b02da508c00ef8b6fa3d9a90a40801854c431a256c4958f325c533a1d1d2e6fc547ec150f4b13763a1be357bdc832d59bd6a119ab05d8a5c77eff6a77b87509972227429a8b17ec201057ad2f30df406d9b83dbb6e702fb164ac638b2b29f28acf8635a0368cedbe64850fe8bcaa60b7abeb76d7536db3f55cf3f642f850136b4ce2a029043454525966a6032376519dda18061c9ec9d4f691248c3341fa0820cb5dc9684e63b8b976cb008f8f55ab11acefcd196031ad30637ffdc732df4ed0da2235386a1def1efc21566f5538127b9ddea70f5d0a1e2a6cd8ac17d968a8146beb2270bdfc333aca2e21bb28af1549b9e3f455b004cd871b860bc3311954aa2ef1ea5df6d6cdf0362a264662224b62a8fdfe2a401d421d26d26d9ce10646ea9aaee27eca1239a403259984d39fa6ae74d59e6d19c61304b9bf637b63ed2a24b664ff5e9e6f72d58f4653e0a7f492eb9abb24c249db8a224f3c1708c2532edb59a5d7eeb072bc68fa4ea4e79b809fa5e2b50af4fe88287c8fdf6afdf267a798913972ce7ce147ae3163c543c1481e862702efc0f879b33259f6afcefcbf98395e5035f90839fe0ff0a5a4d89cd10b0dc163df2b11e157322efd4dd9f7f7a5d2cc09fababc9343d88b259d52f77c5e98c7557508c3819b7ec784d12a1dab83554f818fb524f386dd1a48232da79c4fcc1d57a27fa3da447a70cb189fe449ac37eaec46779ae9858a5479ee19ef755d68ace7facd222fa080d33a71c7578d991a3281bc5e595a1ce4041e639ae4925d06b687575c991e098b7d7527bccf263262d2835dabbe5a0038f9303d27283541ef7bb0afa154549ae0693dade1dea9f55e1d9b31845ab18b8e9a100dcad28fe55f4cf0285495934b0b58dd0f7dbb107fb4b9faf82fa6cc8a03749e0998ca0376b695354ff40e4ba15f414f635aca16ab5d4167895794bcc5c7137af62b02656fd338a0d3185f63f0706e823359809828c41c6a5c9fa57cab74f6cf20f9ff4f24537b65f1cb39d4d72a0682a0f6111343dd7a33e7a201b01e71c3e38243a0585fa1d06e56f814c77c8841311c584561ce747f414886040679d0b29fd20d41907ee2338cd99c0c3e5aad20f937c06c84c6fc053a77e0883d69208ab90f4a918c40c753a003cf00d0d8623500f4d98cd5872277b52328ccf0e09a6b40e2c04d3bbe5c9e43a2f224d1df5a9b94713b4189ee4fa32e80900e39be7b46f00b0ce589f7a492f8e653266eafb3fa011ddec9ca9f10935bd054769c7a59ffcafaccb186ab079a15d704ae22a8de667a2c557204bba96f06f62acb6e94a9bd5b6cbf34ae521a583d09e5c1c2e350351d5784b8719162fe8a47f74fe462caa464c17588cf6f14dfdf70be9cb4a4482e6ff8f59ea4fdc18a965290619cdf1576752dc7a3e78043f2d08a7f7fecb423a732fae5b5dcd513811a2f8b604d564388d2271428dd7dd86b11cdfea1de52f5e79153f7531b7a0dfbfc530912ec7207451c2fc91a9c659283fba06861e66a472240f85dd9b666d55ab6117c61cf0cba1738d3d6d581eec8b988726dd8ded567249151ec983c5d66d9a6f1d5a82889ae90a0ea65f9e0275fcc8d41abf6c969bc152c170a59b97756761580f051fc1de869841c8ebc11d50c62602b31fc7532b9672604eb39e46ea231b0c6b50bdb50cdbe190373b9a8cb14b1f89ee9cf30abad7ca5acd1add55ce99bf274fc8452e86ab5a490cc325924cdc78d9acf9ef8d70bc2d5e0bbddfb0c6e4dbdc23f43f652729cc177a9ce6e37f69b162e41d9fd9627dc98cf032f9900194afcae606431bedd64b76bcef311b649293701f98a9c95b41f49193d69c83d4a9df3798c9cb34c3e098485c48f3eb78861cdf9446d8e458a39cd16d8ae1b66631a38cb173050a3341dc9a3570ec378c859e756940da0a918f10b0fecae1ab3eb8ed704088ccaeed7ba57e8a8a485f2ab91a9787b533c9bdbc8cc41e32778a3b6bed81cedef761aff2dec2843dfdec47b0c2aa1ed4094ba095cdcec1380651fb51cd1521939ac5363b8e53895","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
