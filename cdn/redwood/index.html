<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de339de440416eba76d6320bb197a762648f3f0830ae1269470e689a7fe5b3888985a765bc13a6c1964ea59551bc68261984cde7aaea0bd1dc2787700cc92e9fbd256bae96658718766e406e261a55ff0198f2c880703d643f5c8e7e38b14ef74ab98e52d780accd2697b03949ee82a420791c1849dc5f594a195acc29e426af9da1303f3be7dd1e319309073c3b8399ee601b5e49915ac1f2ccaf230dceb1cd410405b6568807be1b795fae2caa4fbc7bc67b6e0ef62e220ccf0f5337f5ed00a4d9b1f144586ad2bc60edb8ea051e30217eeec6159a6422b1c61e6719a71608ec59ecabd99f88452719fec14d05d3245feb3d116df58cbfc248f73a13058c6c634ce3c325292563838aac687924972810035fa73fd42dd4e223aca4e9a9ba8280e7a4712ec3562f3a12042a5c3679ee283ec3d02daa9237cc972de1921f67b03f587ca31b5d477bf80765de2129e6806ca290dca12f35ba69806d9e126ab8308de23e1b97ff7aee3e9fee2ad22975f38076268fe13b5ccdce211f41cbe2826d825980f3ae9b47fac245c418592f2cc8efed6349b89b7e8539d3ba6acc67d5e518e27b1561d13a0df69769ad9eddc0f561c6ee1cacb1e488f7eaf11b67fb99373f5c29d66164dedc83f365d747c7051492ceb65cf5254e0f139e7203a1d4e1fb0e8d58075fb250b2074b429ea1b6f2ee9df0f638caa8325d8e8dcd81daf77d1b13c743f13a04e707bde0f9de2a68768de59edeef3703e61e52834902a39a009c5ea32e07b68a88a4ff16af8fdca9a7218b310865e44fb63fb7f529333f20c5a983862bdc8a6438a8a596c8fe4fc3cfa84a511f43b333c3152eb6b02baecea678baa5467b9338e84af7aa5ff055480119782224889280f07797776d7094b8a63a503eabc42a3670ab2e723993b2f978b8487adbda51df255f5fc3fd4f1d88be460b08895f939ab754e430d8d2f6ab278661971ed076976e95f27ce315f51ad8a4d71e248f35f35a74b890be2ad88462e4a2ac35064a661fd89969ad4edf4417116498788e240c51d5c8636518df353f61626fb51c94098ca3f1ed3bf4d212959e4b62dcbd949940bc80e2c74a0ca5c441f7ae03026ff586b86a0f58bf41d18052264a93839f84236597b096620561a5705a5e6181b1d8e6af18dd219275777b00a6d8280f1896c42c8c639511bf05d66505c2f9b832e105c6eecf94a7fad9e017f234d93f1d43029c9e5d6c51f992673b0c09e9cca2c4a1ed453f1e431606af72699167a619c343b43851877d3db5973bb20b474ec5f408c8923858cb03842ba02c8efeb5c57c3c23a5329d426d7d485a0f5310e9cea2708def4fc457a815cb03ae177b2c4cf633252a88e79a8f91c1550ab15812ab560e564a9b5124d9f094e98df0ea7465e4a7d39fc9ab8843475cde6508d57003cdfd1a0ea96e05887169a02a92b8882ae6f79d8bdea14bdfcd16c05ec3bcccbbf1f60cee683668796eeec01f70e9456e71639d3e23eedd5ddb5dda45697755ceb32f4ba651424477a5b5040b75965d609528d4f9e391dbdc08f57227fc9d751b3e3a91b0ab198d6c8b4a75081fb7ca22380baf9bc8c9c3ec6da50adef16c34eddaefaaa6d0b4abcb371921d60b5c839b54f612849925b044d0890d571ec9275d90142d01b79ca509013eb3eb44cf89abd73e2d8d225bd8b892c8ebc537810a1aad5eb992a8a01e3ae3a4b0fa70ea5c33d9e0c26e66bbe14bdd810baaf6a9e7f4416b00220baa98dee8b85c5550cd619bba14db2a28cf0f914700ad5b6cda2b042b6757fa49c9f482f6ee48897fd68adf1952ccb8ce5ef42dc95bc3edfa7515c4d4652463f2eb02260a9261505c0ad0793dd4a8d0a1b8bf9349fb6b50d3cad0d4620fafcec6f1ca3026a335e84f50ef4bea31c8aaffa832742d9456a8ca1bbe8def7472a19fc0bbba9b0e03d0b7771048eca876315b9ae4655d8f0bcf2f19fa5043affd895def412b732ea9f7b1292c01f725f5d724b21ad0132bbb76c7ec7b1fc24d58734675d5daea5914eebb608aee14b0eb8f3a1cf56f2c9368cdcd1db7382aea39880b4e8d4258fef7881f6f257c0bc6ae7ee437b1ea8697e61aec552eec3d33ac93cbab8acdb618cfe642af7e3437b67b91e0cff620848806d390741e82c7508fc49b10b60cd14a2ae1d1179a6eee3dee882d1ed01acc892f4eed6bce2388483f239a7a29268c65e589d80fe47825cb3b94e2cc8d42c8cdb8669254187557c0b1dd7a46d1dc7c41fbc5840f3f47509c031800a925528d064681fb3d4ddd2333ffd9da4acad13d5eddbf1bdf6cbd980b30740c6b50d1953b333c263c37bc8a8c993301549bf301e32180e64b3d7996dc3de8e611267c534a703e69840c8ca9a931ef172a951bd671baebc5492c6d4369b82f0ab7d3be1c8b20187906e58b9c860818ebba11c3d0ec3daddfc81e337a83607cee5c7220ed2532899f5ac70c2d8bbbc076ebd0af4dd3940d237c7192881a64478486bfe59f4f4f021eb46dfbac4de3e92b95578c5a6af6aa38dcc05aa18f04fd37c6922a4949bf1937863a75a3928dcd10ef69e991542c94fdcfed64f1dab743e2dae733f0c594b36559bc8e96cf73744a04989d110076b323945f34234146b6eb45b68dd0f7fb43b899a0d8585ce39e4ebcfb4a27ea61149e9ac2ee9c617995ed81434f779b81d1fbd3583bc85ae493d6a5441c93e1830ed6274f8f979a992996619f8c45cd01b824f0f36e96e2bcd24e354ecdab01ac0a2dfadbc8e0634f019c880575f5ab90d3e4a3c6e4155af714924fa6745ebbb835abd1a775c4ee73d6fcaa5ea9a9f1ea560a96cda399b204e4f57bb5904217b074dc392511cf3f37cff471e7a852e8c85dfd88ddcebc4e75280c6a289fa108ccd5e520378e674e5851bc698e49b78228f52da847ca83fb62f4988c8cac82fd34dd242e4fcdbfba679119ef9249eec31eafbdb44b9ef29203b2837ccc67a2e1d3f0780e767410dff01adad93f741a95ef999d98f2d4ec455a84fe18ce9c41a7b13230dc17e3787adae0d0b298dc3b66e884c7d109a69a9486909253ccd50842737207ae3185af43b8119d33112f0e0a372b0bdd7ae28a98bf44d7fd555b0c1e47ffd2cc2c41efe5602ed01f0bcf2b17533f1adb8a60b791ee582d18105f409d41c5e3769c1d93fcee9af88ed2dc4d8c57a950696b68962374a9251898d411ef5360e381ac960e49e50d192ffc759d9b3561fd009e39b085995461bd66e55137f5fa876c6544d2be4950b2510adc4a32c546c73687f6abe3baf8132dd4db002da54925e6f8816a7021d3895415fe0ca925fca7329f993f5ba4281cc43c31575f25ea7f86da46f3315cca104cf29598ef0b48ed7dcd039815db31419d44a71108bbd06cec1c92c0d5bb3450ff3fd5744127795712138b300fff4a553178b88602ec94718c4868ef1255050bf1e38e7b10e01890eb3f037ded698890a8d47441a6d30d9ea00448935df4dc900683553b2871d4a29dc2cb21c10a5c714aa5d87f4f5f3fe367d52ea847d4820945e26ef4b1b7ca5decab945416042825f45db6bc9a7b0ba19352f081e39f7c180ecc15eccd1adc769d08ce962c4032daa1f2473ac75c58ab1e9d1a13ed8516693368358568a949df714d98c3cb5ad271da84be467ae8542d2efec9c4d0e2b560db0c640875a75192d6db8ee518cefc67b2a1c34057b97111531dec15c4655f2a938eab6b547fcea0cd053bf43ae56b8c896319e04ce5844fa17116bea85340f30c226210d566bff3dea92d1d078d659f9e52b5e364ea64a97cb2a62f52e365f9c3907042566db024f3fbb697f6ad96fa90c4bcd73e51629de8f53d1c51cbe827887994eae4937e4b5a83a6b9b3ee0ca58930c96d3a7def1dbc0403616d6e167b459f407cb82b78784873af1f959c0a5bc83bd744623a8f7ed6206b16a3932ff4400ec54fec1750982d83e9ce92c545333ae03b8b300d7375662b467624cbd971fb46dfd051bc7a9aa1fbd518b20424497fc15237807a8fd4b16e6715a6e052d3549a326f8f6b3077ab3adbafd92b25ebd834897d53fc7f500ed73bb12605bcedb87dd806c5f17299da7f771e0308b7f9de5dbf76efb94867a5760d8ab8cb9b08528669f549559cda43a0e99955a385c8649584eeebe0cc2a002942dbaf3f3a6530ccbf31fd746fa2c7cf3677a5ad015617d3fef74090bb9966bd14e759cc2f94c2f84292d7d1ece44ae549e54bbfbbc33002c9705d6e0c07b2ec91ba5ea36be125a6db5d3eedcffc2e6ef085a4f267e912186a14782f6ff054519773a139ee02aa889c66015b4332cf86f4f82544dc16852a9c53c5ebdd41255f982939b2299d019e176791177890e1608af1818dff685cd74267777329a262b34cfa6c531dfde663a65093e101ca613bfc351314b362d29c818e3ca833dd330208f4d9352c2fc94e82fbd245d62ce29b70b2f59d1cccad871a77039ef70395c4e3aa998a6f01bb046d74a59c5d915b4404ab040e773d13aa9ad1531921b84674ba46912e26eafa2ebfe48894bdcfc728993cdcb73d8aeb84bfbc8d9b00c6fa7e39595850b7c60a398746fda0e0ab6d311af02f58e3f62a069ed65fa0a1e0485a482927048e35a90c25590d8b91e5638868deca3ee96948d5b17eff29e5bafe372af4be1df8d2bfd2d38fccab235631ab478d13f8ce148ad6582be0a4d0059c9afc89cf05191c544e55c8256fb7bfaccf82b9f447661e71bf7ff191da42f7995c3e60c1384d485cad639a7930804f4c3564b417342e0059999f7f1ecaf6a9fee441664b6382c5d29ffb33e588770188e790e4ffc1795be91ab4bc7e5313dfe8cdfb15a145e1a9cdba232bc51f11f8d1a71ef9d1332d8e3f1a796a0b56fb44cd5fa17ccdb1c5fba0013941a7d30756c063f723fa2953438e8053878f02390f3a20bad707b06106c4e10c39ddde51633b8f1524b2ab405c106d026cdf74de17823368b7589a09d7e163015b94f0d991dbc4dd7f63df09552393de8ed030462e722b357d771af889a8aff82241d95343d3bfb9543dbe92176b985c59125bc278435f10d089df43d2a0424a313b19a87513d212d38532a19f7b70f71a7a14b24084af761d4c0ecea11095a77fd6a47907760e24e47f338b2740538f4001ea58d1711e123e8940b4dcf7e0af3e684c3bcba0b35771f9b8b4e8206034efa3c4ca725bc799550f22a603c1fce787cb6f7308c2e867c11d14d4df80cea5f143a85dfb94bebad78de08b29da966149f6a22fc82d6c23e1305c282085ae56f5fbcddea804356325ac58b0d980a08f2156c210fd2333cfa0815b48b1314463a3000845953c73ffb5b43b412695423d67f034b4a769beb7dd7d21d10162ca24be186ea18cd976940d69f08fceab21db25183eda646c83fc9d084d59629f14ddf693dcdee26940846c9ec6bba1956552617e48421390ebc3917439a1a3875cd7e4fa3db57a7bd810d58a3c56df40faade6f5ff631c73577d2c6b04b11db8d832780a2c57a6529a51fe56d2a374bd6a00aa5de3f7e2754501617a712a0a6540fea0b128f673b93b5036f43d9a7b79bf885e85b9b730c69447b24f0dfb0b71414a4ff7ce733df61be46aa34353708662372f09cb6a3ed35263cb3ef1e3044c9e637969342ef115aaa9d113cf585252809af34add0100601050a72f97be9bfe2431d600de2d94081fff235e95bff6bf619a6feb69838fcc4506e10b5e72666c8dc52ba66fbe285263d7518c6c4df727db59d33061f3df16b2b204a413323565545f0566d764baeaa72940626a5bd7047a129227a0b5b6009ae97de6cd9d8eb30d28fa4035ebf4b56d18cfa71f62dad6f705cc5f0b37e35889ad2f850a10767a998ec9d747b0e87cd68637b30fb48fa9216f145a867eaa26429d711194d453734677e1ac983e02644d79490fac5b6be1157e7f1ce4579a753476a407a9223876dc1a5cc082787533728d1c848ffd41b99e9f659811ed5183be87429b0300a5971d4bdc59640bc025adb64e41e6d211168d5f5bf113c52ab6da27e471614a07e8438b843c486d112ef5ec8696473bd91568c60c199288e930d63d70ad881b7fbad953b16165d2c2b6db39d5d002add07116ef8c6ae9343c494da53207e3a6189605cc0e05cf1e17205543413d908fbf03041e56fcdbe0d233a4819e37bb5f207920200285f4265faf266a7df193adf201110ad3467f1e5713b0752579ed4c6268ccdf3d8f82368d97a124271f5d0fa7743ddc0152ebecf6a196aa2f6d8f56a4bf7b5fe22219270239af4c74a237db0e3887951f7e4e27cb2d312e07084682df4ba5251568e4a9f9d96f6494a9635fa7931b655a6430804baeee0488e6c31ada76515887c4a1c378692bac1c7796e0a612f32576ed5f4f07b04223c88d46bf6dcc14e69063ef172b5e45c3b71e1a96b08d6504e4e44979b135fe75ec9d23ceedbb6a6f615f609db60de3cd13fa57276082b71d6e54a4831a7a7f1de0b3a569ae4b978a402435f829373469e815f7c2505877e4a8269568dcc00fe0cfccac40649cbfccb21ebeeb44fc75a3def961f0da08979ea4338b919c34a6a874db681a233d85d796246fd00607729dca21c78fb5fececb2d90f25c941b45c8f1d495e20c9af7dfe71f6759acbe10e63337da83f265e1064503678cf54df8a1219aa922f34d266ba8195ce23c6ad5b8ab46da7b1fad2a1c64ea720702c651452afd3887885c95ee36e8c0b5a6088c0a4085d9dd51fcfb74d51bc9dd47e8fdb862cd3eb41db4edfcea259879e64c6e01011509204546c3947bd4e9271bc8b8fe58297c48794a199a6f888a2aebdef13b92c8ad8592269164c6627f654facce88f9caea18f4aa5b41dd6e18af9d0ac4b3a36876eee0dcde71e7f7749ca7aeb47327fcf0f130deb02f016f35d541b3e79c4ae2696e2b60e8edc6b53e083b25ebc7ff734bd03db0705a4a5846243a87f7ae6332817dd04c3cc82a46b5479d21947fd13c90d0b928fb84561fbdf0e38addeb16c3146bf9d383c70a34766558cfbf443fa114a15b5e41b4bce406065451f7e3a7950599f42962897654659a887d40ffa96f466d28ecbd466edb72c1db892595d0846d1ca7c430e737a8478440e6b62be448d879c65b8af31fd531c4480de682a7667baaf026bbbb658fef0e30aedc0a985efef1013f310f8942bed249784fdf99849b0d6cc3f1894a3cc2f37774ac37117468ff7d9ab611cf39f75334c92ea9022e2b83b78d6ef8727f8388da9498a1acdd937a0bb0f79867a052aab0ae9b37ca6296b86760a63d91df150bcf274974b1b544b10a6a788bbd569223e95c427496bd0b0b5b0df80a382ef67fa72b4b9eb37e4dc134c079cf2aad145e637124c2104489965167b8218ffe5821fadd8eea29aa4cb3598c5253d6b270e4a921fe18fa7fb935f7421eb5a6d54bad8dbe74500c86883dc1be3ed3b50f4fae09326026ed088d14c33e386e11de066cfc8cf3b7c20568a9281f52b9d5e6ba8d0aa28f16b7cf463ecbc206316bf9cd627470348440b687ecb5fb900bd13ef9782543f28142b3db0c7da323ff7d806225cddf73edf417e2975f2bc4ff0ae5f1bfa6133f1adf9ac8380c44e45a2466695b04ef45cd4c5b3ca403d7365628cd616cece26dc039bc7f04eb5eba6c13d3771f6fb12f8bbc0930fb3650f6a5ecb775a1b41c5646c312791a4771076565793cd683a033533da3a022d93bb43d19ddd29141991aa10d7c099f1cbf94b76d7bd7f3645ab9a626fd1f2d5fc30663d36b08862d87dfaef4a41482e2c299b29eeff82daa7425f81d67606c10d26a1d49e33837c2d880a45dcad0c75caf0b860b656b618fcb2883b5d36d692fec204b88d9b5d8dcce15f14918c379bde332eafca2754bcb04483c0408b1559baa2b60ad12a8d633ec9905294eecbadf28eff45d8783dcfa07b87b3c2383db1af31e399908fc22fa6939611e7c0372a04f8d0acb280858d2ef98768bc48f961c78c9d5a5be4cc884640ccdd127205f4247e6224ef899c6d4c8c4016f38b907f15646763ad3c61b2f77f55d177dad5f4fbe60e752e735788323daafca767de3e356da59c517a5e65b2bc7d34c506fda2eb5360e4c0bf32a51fe993bff13c61e9e45885cbd9ff414794584a0361a8ff0b62eda10c8b1b720e58fe5354ee17410b968e370ddeb7d401f0556b5396261f87ef47b0a4759723a983c4d1a67f0eea4d3f6ce019a9a0216c7dafc0f560205c651f82e548a149b0108925081c190ed4e4835a6953d3964280b2b406653b41d9dc7e18246d8c07e46bf326006275679686e072982e3273b0cde6a8d5218662a3686c61b9605ca03e295b3e2335babce555a0b0fd142ab195bc9beb402a5bb2513ed3681c8438c04a5fa4fdc6d31e018c8474a42d7a9d1ad55a77ce30ae00ee6689c6c4a235a90ff2b88e152a0355df144fe074b4787c00d5c3e99b080a6ace2244e2fe3f803455edac3b8eba053d31aa272fb685692884fb7851a5888545ef437a05a61c158e68059e7a2f6c05651a7ddff05f55b1e41560d02ad9bb5cf30bbb3899f559edbeb67b94c99884f2b982b09cf57caed463aae7efe19101d07bab4c9fe7a025dfb58424ef164643bcdb0f8bc704c511a84cb8f58d7728c10990383be6e67e550d2f6ae2c3903c5eced715806584176f053f7c889d912b1981b2814cfee7dad031292b175fcfefce43a004590421e9cf8de0d2a5e08792326bb6ef88b4a05f9af797a939a0466245bc61b8cccd539a2cde77c4e4600ca4dca823539458e76aecd3ace372f09a415a44fea2679fc932644bbf787b5b170df7da130eadb88be83349cf5cb8c215b9c048008fce9b6b41731b0c0f0c503b4ad805489d8f35f0dcb5f3c42c14ca85c6565e8bb200e0e63211cb5d610aa1a7ea1c184153e4bac9bb841645947bf34e11d705b2a2abd5cc7858c377c491ae8b6ed2e4c5d073199575ad52faa5a740eac72b42ea498cf8eb505fd05ec6cebec7f39049eed2e68764babd2f6f5e18a7d4b4d60ad769bd9093a22ae1d92531ea71f71585dd1fdf8779d3f90d17da399d8922475844eab2953314270becc1aad50bad69c77ca5bb6cde0c8c9585629074fc0f7358f30561e7adc43cf2eb62865c14eb8765497fce0e3272ab3afbc5ab2779ab7c658415005a337a89906856e60ddbeae7e227ff599ce8fa225357bc0cb9e59ca1150c57014d225d99f9c3299bc06dc818befb52a99381cac2b7f896b68b7cbd2b01f02ba6412e6400cfd5a4bff653bc0f47afe2224bfae0ede421bc06976ca7cf712a4f66f9a7eae51d189fcf88ab9605914c8824dc58e68f020bfe69735aeeee78af3e7ff8e9857a347bd88369f2f5b88aaf4e680c0e944e3f4eb08feb9203431c16d083863b4acab2def16ef5383d7c0d24348fe98c993392befd33a69bbd1df15cf2c777a4a583455b3060bcc20a53bfd51c789ef8281d8c472fb532fffc778cd4d9dc209588c1352015ad2fb11573f2b38d9b53b0dd23cf4b680ecb25e87fd1c3e82e9c97d4387a3b6d27c13f07c7a9ca67ba0ecf3c0ebcdb021ae315ddb703ad537758abc527fd397b25a000efb75da5575a2e145d6823a9e8b76c7d9afafa3ff27fac6b85cd4112c48ac66f8476c22ad1b96299121226024c4111cf449c0846b2ae3c730fa8440cc830a142bdf5868dca3878d9db4a84e2cbb61ca45fdff5bce5b11d8f107d8ea66b4429b3335f5f709552788924d588cff40f2ab7b588ca56df91d4a06f37d9bcc5ef781f9d3ebdd8754176ebf4970e092eac7765604e057c8cb57d1b5b5b3f8580c7cd1a22b6a579a578369b1a46bcb3ff346ddf1ca178900b42f39d9b524040d969b79446e0a32e1fd1ebbffefe779f63cd549b8f43695e7f4cfbf3b31b2206d3b22728651fddfc394deedb33f3e40ae67c5cace464cb7fa9131c8bd402ea68b8376ecfdb3693554fa07e01c77d80bd566966801040db26f9b23e3b08b32e531a3811f31e03d25cd4e056c2071cbed06baeb679c4a70fc2d13f8568a0fbf1f1ee4b577114db57ee5d03f62b1c5a7f0bdab9c5980fb5f145902687fe9fa1f49c4b7f05ea6769ce60ef7624051e60d590118215961630129622f365cde8a416a8e8b9b3bdd9256b057420006eab56dc7b46b8e4305867f817aa2e600617a2f0d27c54266e829168d95d1e02acd52a462c33989bb5e2c6901de8bb82f8df73626838a86e357e8ea4e323af7c5d88859815478ccac35d6b6dc320312927b2da87d9de270fc64f1b8c41a200148b565ab00ae9bd31d21516c6f95d883b195ea44c6f4c881cbd33f86c761e217875773d4f1eb1e7182bc627e6f6f3393973a97ca4601daceafe34bac1e6ef4a54b200efe5fc8230a580247fbfceb017f15a5b66c3affb22e76f66ec2751fbf4b3b66fcacf4555ce10595a300d8403bd3bc0c7f0e2a400c5bb8cdd11038cd640605c73b36654a58e30dfe60abfbd490792efc326f8ad2c55416e66e29e7ea549b00423d797d8de9d8b3290b0987673d98fbcccb8f8605f9b3ec81460ed0dea927570e6e99133e116e0b898e5128e9b4fe1d13b918f134a4c7ad050b46206f81a6a7459230ca1644dddb01fc33a8b600e39bdb5d8480ca177676f3d42f6d90e86d170a89c86640db669fe3843b11c56ec639b86b80368befb6c0d6b1a017462098331216daef0e9aecd18442dc787ecf5633961cf8f00959253740a438fc5ae3549661759a1f0f1bb5213037a5e7187b8e64a21497def496eddb37cb1c4f50e52e88d688fbf5017fd41ea86eacc7838006dd2fc9b09c97074c2c497456dfe26ca7755daa7a2a59f0725112a13beaa737da47b2b32c97f4fa60e13d3a5b14ee937b814aeefaa3137d37a1096a6caab6af46efc0168a9f9be1c7113c07325d54d8290cde6fef7008cbde5b833a177c226e6fb5032d4848641b317e0c29dcf877a58fa0249aed6f39da648b44a69b2704025cf1823ece6824f1212fd106d2b83139aecf87ff67acbbddb0b14c2c465607f1d9699b541c286570fa9f8d95d91ccc0429d7e3853926f8e8a621b17b5e058491bcfc1c2bc2922234a951b66883b238f736207228dfaeddde313f4dce3820a195573d1108480df5b23a0d75b7cc87f24ccbe6c3eefd530786290b5678afdff37f0b8855792a82059a4bebc06efce8768de74ba9e4d2a87dbb71f5954e014409b9d57bfff41232fd2bc15688c4fffca4a4f1800e24b4b2c4e37fa185f23965eeacc25d18db84329d4498b1e9127bdc1e979f20f75e4a4870bff049683de3e9a725d394aae40ea4bfde8615279a1c6eed60866b6ec7270c8b290de25a4c5ac7b6dcb9f984cf419ac8d7aa1e294b9c45d54a21a7ad98f7e0b0d3cc79d43d491faee348d81c09370eda281627433b78a79c6ffff692ccbd6acbbea101bfc416196491741fc2a003dcb81a80ec2bbb7dba13dc2404242629830cee32add3d88dfb7af31efb31458bfe8d93136cd9ed5da9d9cb8242a73d534bd8fd136b336f11156f06b304dc7cee113ef9afc801871b71dcb8560e61a98303f5bb9cdad7a61b0deefe292dce9a8752dc167eed3352078b241c9ca71f1e6aed7d5da36900c2a164dbf5c1aaed8dbb04d50c16fdc28f1787c611ed42309d98f2a4047fd1e04fc535643252c9e7856753d33e9f66ab757bb5f5ecda2519bf0e033d126633f1effc86d4b61093416ede94ba8b83f13a1b50a33cb7da6049cc17dc70a9fb47fe50b9b5008109ab9b3b8807d52b81b751e43ebbd35b069ff74b47532cd3dc3edfaf89be517ac0ba83fe2942a9a651ba50dd3a8f727031c20a4c71ec99ca80d038aaabed20656dddaf113fd0aa732dd8db0c28990783a99b18a7cd539a371c2b85e87eaa08ede745bbcd6c81a6858dec768f351823feddf3496cad3b631360e0072e87ab9287662c1ded1e5ed28a18a75c20fe5849218d0d6631ea6f21a36abd4177e2e2051a49763c2f3bf0cf76c3f4bdafcc2a3bc097fe1f1d5fa615d1d2a649e7a60ee0973d1faf7ec68a983cf1012f99692ea6256d6be650a9c9bcd5c6c8e776e378e5bdced4f44d5efc758e9fedb3438976e327504f77369146c8357e2288b99fac750166828997e478ebd9748d961632f97f8bfb8301ad2b5cca9e8530b8d60faa56e0e25668e28b57810e2e61d06e63c12d01238457ae5acc173932a8ecae0725e2e7559892d1196d6c266cb8f47c7c8ed6e23b790a736639407b81cc824d8edf052cb601bafcb31ab24d06c84a1ec6ff7bbb96fac879b46304ca9205d369f67ff30624b8660fe847c2a8e4c9f4639aaae4a63755c2337f3434f7a01def6c4be2f9fb2160c305b25bfe873dee89d8f9556ed733baac02af32a8845dddabe765892e747ac7171cb89ea3ec55a532a420da9bdd399533f7834a544589b0c7c41a37e67c26bc7cdc116a2251f2b342e25fe580b83b4113a4d0daef4afce32099f508a06936480f54bb6d7a6d2952f37159dcc056ecbc1ada31b0bd917a7c34c3c532aebde563e49b3ca5f0bf430de79ccbaeedd4ead698b2fefa9411f6c68752c39b952b1372ea3e08023d08eee0be491e3bb79b5ad8f2f8a4bb0a820e6b185310bdd6e2045f04b74d2e37b193a5433fcc1d092e974e4b5a9ab17311f7a8ec8da84766be8606b13ff863a519d26844b28e5d42f0ddecfd1340c99d834ebaf8901a425318363aebf019b6ac3e883e1cfde403c5dd056e60486a39835ada86dcad5634bb08d46b481b6723635b9bdeb2aae0c93751ea30163500328147eba9b2b68104070f237355242a012adcdc74eef97cde9b1271cad727504fe75bb2a64dd8ff386e83578a629aec5e057934817abaa7fa1e705e9e3e73d00f4515924d0702e4e50b59a609dd14fb890e46415b570de6f9e4d4654a778f2d31aac0dcfbd885440299866b3a1c9416ccc225c4bc66c784c1b52099af57f110a3ef7bae96fcfba6aa74cc214f546b8f7590fd569e67eb7182b76fe982253ba7b6b45883b6ebba371f0fafa6106b76ed295e2686c41cbf1a087a707bf0099e13a7a0c6fb2800e8a39eaee6f06636ea145e9f62793754ce7699c01dae89cb53f9947062c47e06210a8d77416c29a3cb0816ea32173858015a798f03cab45aa80ee5cdb3112174af72d7d44b8b08e05a3264e4f1704b576e9bb7351c10aa701029a1a2eab371cfdead5939024fae0104d47eb6f6f8a32f2402109b8c777eef6d674a3549d5e8508cd18d07d7e6531fcff84dc199f8f56eb17b34888da5b1d9de26c0b3ef8833b5c789c01bb2af11d72d12d8e450b4ff5a962490130cc40b077ee659a94bf6a50f40aecfebfdacf274ce39651c0678ba69b0ee9bfcee5695e3ee6d8d23fec0d134f1bce7d827a27ba000aabe3a944788825d90445d7b30eed276b0efc8539077ab917b8db49dec71dfe3800985d6232ab1f13fd5272293786f70a446b95a8bfa2faa2ff3ef57e6bb9315321521b2aa5abf858452c11471438660538066f3745737f2ba9f55649cc3e7dc0056b983f9bf5acafd716a439f19198739b3d492528d4f23c522b20389cd3203f62d7a082d1de24003c1821e5b9cccdd63c6c4adab05b95af5ecb3df3b40e15ec7a6ffbe5b805d9b2cba0af20192a52847d00095686d419f47d265f4ec74d02c6d96d35226cfba9aedc7b259548108365dcab15a4129582ffb631e317b97d9140be5fccac86ad8e497f0c5b7ae9f03cc239a8a7916da91d608e0197f3e9e2d5ece57fc2b2db7034e0d94430e33c89444847605136fa82c080773bcfff5ba1a72808f4dc5f127e30c4bf318fabeb6976c5fa8b901c533f2a3f8b7c8aca0ca8ece187c617cdf22b52552c76043c9f0e0ec48ee63e1179af940ee11f1cfb79592f9beb1859edf269837e2a08bef36401220bd2335ffaad4444a52ce7f1cd07276ef9b7cc71639c075e448ccc0c1c9b2fd1be1fd94b668dbe3d783fb0483c48ed2f4175b192aed808c67700b1c6ec4ecc270fa7f32c261d27169dbc69dbb5fb0836927ebd04698f1757632d21c92fa9bcd7cd93ac01970c532ae1d711f6e26a220ec4eaff1ab6dfc861b04c550f0a80116c69493dd952f306522f537262709819bdb2c023620e6c2e3af95d6fa1c6b96f52e7c29a0c3f2ab7268545baa6d0b0c475ff47dae3d48e7b1ce606ff9b4a3f08e100a4e7623449a4cf2c6ad2964799a114af96850e20ce3d0971e5ed917b0da7db7711dbe53069b8b26c1626843fcd2dce39d0cbf7f179744d42e4548538f1399a85610254068de4ab017901db1154a69490fa2f09c02c8e9fa85e3cd67a87e56ca091d2cacf09898b93d18ddcd5bce6cdabcff4286bd0e247b568f44a04f0bf0134c79daab448a04f1cd367b167e3b0c96f5a164cc15d0f557286468c9d1b1eb835bd8a24419fb4d7a25f6eaace7a78bb24c86db922d9a28d763c5291996ee17779fab6d9fd33bf98936006dda415090b3a74bc2602013b390c5c17b2ffa3c485973d274a471a5d118eb86ee3ea4ca69a2d83ae2f7fe330d47dfc47cce4f63278f4278d09addaa6d6dedf1b2e409ebd9e601a2849fe377d2ba4c85e011a792666928c7eee3f123edebd901943967e78b66dcfeddd4a0ca55d8f21df2c3e7298311d9dd217591409beabfcf5486b61de61cb65ec2c2a44d99131696ef0512194baab7ac9aab7bab44689a43726629d97bd75f35fc3c342f17f16c05877b931b81353c3c521e35c14a3e86e0a6bbb7b0688c8f6b3b39db18f68b8bfba1aaf9c999e2d53f3c0e404a6e566c2940b505ea2e4178e75ea79adf37fe92ce246fbb816771c640e7ab20793e279eedd7db4fd03bb23e0f08aa2d59d4bdc5dfba0874331868432df498ebd655201ad0cfd5b158ffb0b7c9ef2e57a38fa72ee75b393a1ef60dcee8e99995c30f4faf3d073782f6e2b0a5aed959870a89ebb0a8cc530b74b049335a154fcbcfdd447d4d1b69f9d100133dd1204f4d1b7e71efe2cee03ccdcf224ed4e9981557e486771031794addf8d205d7c5105f8724080cfd7d96affa696b1fe1fd96f89d2bc01a1c3f3378849679862473d203a1aabf3e8425bd78c2e03c51b3d75a0e828a922624df561f8518994cecab2b18b7e19094833bcaccab88c2ed3a7a249d759089e328c3a2dc3b9a65d8fef1216c81ac546d5038b9ed9455b97a9de3571546008ab3aff8610174046b6c7b7b2ad362a1e047a4d49516db413631f205039b869540ac22fbe23c8fd3b67433ca0d9614d43eeb66da98dff86002e7b604574093882ada7e91b97a42c15109d177295daef3349dd9e2315abe8e9c0c51095c40c2e3d6ea6c02aae826750f3fc7d837361c4dbecff5bf43ed96ba9f359aa30eaf2383a401ef6804ffb32717c19e0d47a046fed47389297136020ceddabfdc14b3b183a8011e94caa490ae094602ee132f150abcb402167c570c9c192e27364619ef7466a5bea0e8c3696c2029dfebeb938fb7b41c3b5b8dcea203b161f899fc75b66b6fceb5c8c11dff253c914476b1ed99e3f19015129ff6f47a05a211f0d591a0dacfdb362db531a75cada37fa43af98a87ba6f1242f9f7d9682029a4e055777014c2fcd082063001d661f0a040ec138d4175277a5be45f289b9f3f254d8a7b85c36cc4dcb1fa497551a69e66b2c2ab2362891f38b9ca0c823e97a5510836ec1cf40a099db91e361670abd5775cbef9df7c07ff68a3d2bc232aadd28ffdf4980025c1862a33baf8a226ffab8dea53ddf3974f07236fe42b97e6b8d5625c72e78f260fe416e441c806ebdbb939f0918c8b5a28dc4730975b95eb1aceb9d0d379ec51b64988f21d4bc161b9ef2b5eb765c303672b1cb674bca5efb73df2b939ca9542a9665db254b79a435aa89765943b8d46e0cb75bc91d0349fa9dd676e2b8f9049f09138a21533a356c92867bd6b1940ef35df5fbd6359fb015cda56fcdb94f5f09383f9b39a632790ada7981a68dbe2f15be850ac7dbc6ab87e7cbe03e624ecf3502800e8050c6f88e577b755d1235a71f3a5c0d3b842fc9b03192e01decc0c4c639909ae47fd9082fe6c21aaa588c640c29599d092726794dd2c564810c1f948bebbfabfc9ae70977edc789e78a033055955e8eef64a9a48fea8fdeb14d468ad59c4310149cca0e27c25915546e59f647990aedb51efa155f8105246a29ce7c2d397b2a12b67b5e6b2a58575eacf7dae143092804dda7f76f56a6ee67acae32e7c331cf6db6f35aad67746abbc4285925aad77c41f4c8cd8df193b14a52ae583e57874fce8319b47f7f4dc5f6615e2f40b9016ef2ca247b91cc023ef0740cf9be4e6c94243b2237c33027ea62aea9cba9b26d6133e805e976d9e3dbced5f922c80876657da1c6811970d1ba3fadc43c2dbbd7b5f2e4c15b0996873f2efb74197c18f647ce6c196c3ca08f3f80b6bd9cefa74cfbd1b00853088050c7b041e5e3259c4615425d2b4cc7d9a5cd34e24ea9d4e7fe66890e80361961cb608e4e42084221d463532fae649900e19e6c0288b33d230ae3962780d02041ac33cb1f77206a8d0f2edca3806ef8ab868151791dfb847c5241e3133d6aee44af8966a8a6725a4e125c769dbafa4dc04b5bbfc2f0695df3bd52a073cbf5388fe9e8c9021f8674ddd3f6048d73cc81e358699281debe69971285fb123aaa88775aae51e909252262a0d775f8fb6054b405a7b3564d7a2ad9381781e028aa1f18d42a9e3a0d9142ad43dfc6ca1cdba73201e0d5f56e2a56ab955076ecbadb73cceb6e9e0fbe4818b7a103245c57ef585d7e23ad6fd1638fcdda7b9f0f2c6f302728aab5bbb74b411c23e1b10ab67880f89f0faca2545d9e21efd633e775945b34ccb02e974b7b402397c22211d2391630680902be303d3946018d5b701741a7621b136525d977727d3264ae48d0c1d287c735eb1cedb70e47b083ded2c46f25d352d90bacdd76ec764782f818fe9efdffd947d847b38d638758467f830e81ac251ef13dbbe640482858de0c7679afd01574f225e4d375f334f35e2c9eca093ce47217d6db189684dc09d3161eba14caacf3aa5b0e0e32f4fa9f301da2aa9b9d3394f42d9471e36096f8a08a44577aa6febd4cd92935d5fcf0079c62b0fba2f1368d7a39fcfb0e10cec77d2dd463f18a4b526f051e42fad94d39d4119cbcb0c208484a0731dda479aa60715ecd8ec8f011fd4e32cb57678dd58a6d90912572a91ee0343a4bde250af2f56f6d637f134a74e34d811a6db08c310bb3c2eb21ca45bf4ee382707226892ad68bf61b374df9bb5ed37d97d977abd3f5c211574f33ecd2d1228b907244506b6f1ca87ea9347ef28028eb9b3fb2fec7619cbb6cf56811f17de7c75384b8621fc0737e5b4784d68afeb74e64df506f60978833d55db69145a7857ac2e62075d8f35f26726056aa340a294f8a9c3fe78826e970ee9ba840af2975aa4b64bf9f18a26df4dee3a514d3dfad19e3e7b05533faeb120807876c884baf1c0e1cda8d89ef835830331415b94e2e3f68f9cd2c954d7d1beb1c866adfbc4e18ec619a2ada130280d293e3ddf9478ec60e3b6b7e56abf93cf49b9113c099fb28f365804c34b0fd221ad0162f2ff902d7d989100c3cfbcdb703e1c818e30f82bb8d2ccb6f1f108b72b172edf2e66346f01bd2830a792b31287e738105354f4a4970bb017b97ca3d7caebf880bd7391b0070c8463a2180f0aea457391555259bb5fd12c5f51105163254131c75db44349693e2d2cb0fd634fa61b5e189221419ccff2e7b2d8f416395c1db62d3f7b4566d1bcf90608416fc542172d9c6e4948c8320fc1c398038ca5623778e4c38ecd689f7b47b6d59047d7d782888acd0920f51f707b18665bf9ed34ae6948ac78de9a07bd488ea198633a30afdb7bdfc514e14070527df072bd2e863ca3c5e9dff5139b09f757b2e0afc0f21c5eaa09a956eb5eeea2ba73b708cf00d6b0ed97a522b088a2d0f770c9724b9d17bbb327bd0609c74b0c1c4a0bc4d9dff5abc49a91bb5918","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
