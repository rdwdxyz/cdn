<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d4e6575d5f56947a3850eeea695a860c588708880c887e52d53a4f27297bedf7f9865791341e4fc45e8570aab307884c9399a11ddd7bf3e06e6350ef106977d8d70dc6e3b7bd4186f7d683339fbbe6642ed5560ab6df41906ed3e7581442036484338370f661fc3d90e277062c9ee48a75e62d167e72850a17a7539e713a6d120e97d06aea0df1a0ceef6eca9005a5a8513ce397d5cf510dc15eccc8b5732a5555bf0fd82e02a789ab7e3c52c4647365bf9cf25fe9247af84b44b9a3c70171d98db01e5c7b8982f09ab9a1776470c825ef4e598d9dcce9d62ca5c51b5e4feb8c1b41b845c2239a59b70e9f7e9a799ebb55994cf1ca46cc7686d1ad97c2f867f6815026a561b6c99d5c2fd848bf62fb9580d23fbf1699bb708da65017d72e2d59b5c78fc6d6c022f775cbce24a79259766543b354ef0c1ed4bb3ddafe0114946ca577c6de340409e8c9c6b321be4fb5aa6faa54476dff271b586cc185c186fcf9d5938efdf80bb25265ccf1b14f7448d4367ab093444c0d73178cb2e546e9b8ae60fe9d5b7a0753abe48a132ec598f0957359badedac8b458d262e77de95ff12c15060ceec98f406bd945f42671fa560f72a5189dda5de4a7fc1a76a9f3d3a83d1bc79853b5954753051993c6532c8e4bee28bc4d36f45f91d0cbc58c4837bfe1790a659ffbecf470c739a6d46fe1d9bec78c66570de26fefd97a8f27eb8a90616dcdfcfa2d225363e3d0e51fb3129bab4c869339d11afb61a50620843613613b6f60e3aa54a784e3de97453832dd814dfc25299cfb4d557bc33ae186470655fcead726f57879bbcdcac96a0b75fc8db31593fec2350af882c088584cabfdf897b56047531910baf37ff22dffbf03d666355799182da485b1647b7696476d268d7769b791478cad799af846a410e458ab705b93a989d0bf830b93d97dd6c727ca83f82087d76b67f85140c77a20ceb338facf37b2a8a8f3d6e2f149c7389032c460363d900b40436ac689b25279768704ab60476b60a8a245ffc0aaa50253814b4e3452921831cd2e27242349390ba2464c4de073e8b07580b284ae84160e6f5e0fbc06bbcb021ab7f6923c4e7739d5c0cf74d625c9e7c6470364c94c8cdc82be0e572c3cc08a22b03e62b349ef0a14978cf20958bc503f69bd9622f350d3ac1830ffdaeddf628f929e6f4e9ce9be405ae78054ddbb740c11d46f7a83cbbc1b3c1e25ff822af2662f2e7f1679c1d388f7ff5794b2cff854f60c25da1828bacc598023fbedc540404ea6d7132e2ac1f93dc7ac831ede193b4a2e3393ea8fc9df981162b82dbbe0e24633b7b5db79eee25aa849de3b824745c75f63af25b05a5efc540e0c7eb9a56a3dbe7485d5eb8f4d3e3fc4a083e7f068623aee6d950b3dc640042a0a2b88c90d37a27c4c92bef92888c61ad93da844e44eb7a3458fc770a41e072b95760e1aaa764fc9786f79d53a396a503be239d346039ab6578669f7e0da4bc295b69de0f73df8fab48d30fdc29066324eb9524fe7d92f018f1e06d1b01e2fedc0001737e520c9ccb5a41659ad27ce6b7da3b4e38915b263c55e5aa81d9969590749df32dd1a77008c5809b288c4dc76d9dd88c52b1915f3ae189ea8f8dd4e5feac24dfba2ec2f71824f7e867bb07ce5c8f4061f3102527fb9dadeb855ea77e2fc2c09e5361382e24e36c49faee362801779629e46b7af34754946248f5885d718a6a77825fc737ea672f6ea07144a45b9d9f9ace38a3269e04299d0ec4ac370b7a28234a00f91994df2b89194f923d8df604077ba741ce3d8fe303042c47ff30d0f9c829b9d4b697cc0189a0f93eb9f5770683310e7accbfcd2883dc84d01a8c7d3c3124c55d8c86b39dee518a9dca731da64992d7cbb66924a706e3aa56885968aa6ba7fb955669309cabbe941bae3039fe8adcc87d1184f194ca3f7f20af5ba8638ef414dc40042ac07658b1d1ba6f21fb2cf56ea2940e340d45684f35a95d08818e705b344fea7cd4e3cc7212776f1ee535c32d9b5b28c38294e4c133734dda16335ba003792ee1358d37565737fa591b84b8950c99f0c4c52d9c029c6a41e74793f613ac0e4c480caf8a95867ff14423011bd15f14df9c38cef0ce33858e0cea38878c4257e842f5d4fcf36bd5c723fd41a28786746e96262315020d6d3ab93e5998bae3301f69886bb85e223a3e577c0c32e59fc616b89cf5f2ac322d9ee6d021a7653eced65aaa1e93b63f05d26769f769c202752a717423e91768dbaad497292e36a3b4bf1bcc09663143a3b819ea7a5280ba2c988bd5519caf9f1c554f9fe3722e8390f03c555c531034a92353071d61f85cb59ffe9312d864dd4b8c84e3fc991dbc775cb40611a0a5706a59b39ecd990e1a470bda2ece15f9cc8a31f2e47488955ae6ccd21648880dff7674158bd94618e750453a4ea1caba853c4aa9976f26ba583cb05bbc742bacaddaaa8d9b9897e96479b6fe021ff275891ad5f9595e14b8cfd7e79d5ade419a557174172efc4e3987eceb0e9e12c84d88f5b97a0302f21843da4e1d536fcafa6818623c2b6cb79a9f44b58fa833e6f836fb48bac4a594f2fd15366d1a66886bf7424b4564ed3e41f4508a7465e71ca9cdc7d067ac891380476dfdccc1115b2bce6e0e7cac1419572bb492bd1b130a543f532a4d116b7cd2ad503de51e21dd6acdd8af2d613574510d496df2b5e4a88a722f56311b5750d01d2e731b3c11b0f37f9b77f836b3e444aab8decb24ab7129783536805a89412a9b7973d553876e883385a59912b1e3c4ecce64e2a3f28ed06d26104751d097f36d83b82f2e4f9fa7497dc4c25ce59fd9bdc7a7e71fcee19fb55e6bc87871e71ddf08934399502d696ac4deff9252237cb7f4268ee0035ab169a17f41ec483beab860637cfa4731fea345c0508f0ed7a9e7f5b12664c26f19192bf19445109aa67f77b4edadc2df0c601701fe4604a255276bc219126498df4b1a780046aac22b42ee867a2f8d58ec1c5f1fc8ac6d2b041738ae35fc9a17c52946e46690aa15053b2e286689a6593a989c69acc34edee5faea4eba33e9e929527e95f131e1e1c7e707d2fa4857866a074c4aa7af338a9b711133bc85c3668284ba8ec2c6db059b5b59d0969da78a2e7d2c732f4a526accb566ea13aabb20976101d8584792636c95557fbd41437590a269d976958b2fb1fcd55849d13931ab0a93611fc64a3148f789aa276e909f1b97cc155b9671a8c9cd99a6edeb9db3f457bdf1e7ad4275a8e24f8699b21c5eea94b45b402cff163173fdd5ce8df9701ca335d8c10130c5999c73fed0611ce3fc031e9cffd1dd6c2182cbb0c1eed9824f0dae814d5e76ee14041083168cf13245d751f7195446e4dceff94a9f3cc5bbbb2b9a6376c8653a0556dd636bc3d8b0fb7f85b1baf2ad4231f787a811bbe7d4d410296c07605c19154c375a9f5dbe160d4b4420f9bea47539a931f8a0ac7fae227559c362ab76449c67cdddc5d0705d83f2b19ce5bbf83d25809d4a6d6025fbadc9270f9ec38e775d21265440313a84a1aec6595dca7deccdb0a07138ee4f7027e050c2a70ce835a3976fbee1db0ddafc8dad668ed3340a1296b3a581d4581f084cc7b63befd34a2c5446b2efe00aab4fbc50b9c2d7b4b9ab7f871037b92caf7af3f8a4357859e1983fc84dcfa6d75bd57b0644d400c08080dbd761decfad8f7068b8b3f3242df61e4ac487994fe914e4b5065ff30f85dd8d1bb8ed5d9cc3f784734104e6644a13748d8a3f8f8c77b1b01594fabb6e6614b30146e1eb420412fd28a0c7624bc56061478ea9499a40f6a8a896203ef4d77a115c605f8a1ff1dc8ed20c001983f48f99914e91281184260442183cbddc6516d143be5cb67921a4723644f942fe06b8f763e28e7b1add74191cebe254dd42689294a1cb319868203932caa10e74892e890263dc928125d4f090715bee47f5a888712fc3169f62a3e19312543ff2a10337348f0d07350e3fc2af5604d658a66c8c609ecd11d0bc9f7419480f3960422e003f225aab068497af6cb9dbe3d7678da92f80af4c7060cebd63821a1a9b8bd77ef5822c048069a2e5ab6250221ba5b8c5276a5ef2092beb8378bd5b1448fe1bd3618adb95bd51f32bd9b3782cad4a560ee697a4aac13141a7bf4634693873e4c73bba11c3eec8e2eeb51ea3d898e28cfb5c0ef977a78a43cf27a6fd807954372a4c29419c632ae770b41bce79ae7a71357ba6632096425ad83b70e1f47c8cf411564d896335e5e5ab045d952aa5a8ce9689a374e5c758553f84ae7b9b9d73179b717e4bf1dd1b8081a22951798fa700610c26e283e36a11fb3843139bc104cd190de4ea4827689f124dda0812c03e1fb168b774f49e385006f4a60d9e03a0bdd4f299b83d4d01bc4f82967de97623c0f79f8d584d082e2f27b7bef0e2839cc6d8e189d85bd6105ae01ed9db3b11d21cae2037680f2017cd487b66b041e63cea89d917160bda5a73e0861ad23f3a0d81a937ba2e4f6b89beaccd6de9b0bdc42ce26129e38fc65db6a699b6e2945756dda9fc451854d3f6e8e58c9370d9a940345b638409ba57489c9e8579adf85d3bac04aefd3fccba54662a9670b4d82c1912d39a1be9a4cddd1a9df37b06e9e2653b4a121348a84e5aa28d571835903cb5339b94a00d0cda5ca1108490e18b9c7abe45a78aa22b178f7c3e7d7a0c060113082065ba3bc0fe1c064958cfb4c73f1499c7c17fc3efc96ec05ad430fea7d481f07bc86dbe36a16491a880b7fe01f7074976a8ea5779731afca1ef15721c74c2eb08e64eed12b5b42cbcb8b5c6d2be2258bd072ef5652def45a1bf91daa3d5298e00699212df1e7056d751f4cc5da822fba38b5d12a81f6f37c0e69280eaec71d3b0aa1b804fbf3c5e28fceafc5a5726de063d0e60dde7f4b5298ea474c2b4edaa5a61c56dec30ee6c04ffc168519a062b838766487621bb51f61e56f898b7bf7a3309ad650f594dae35604b9d6d6f11cf1a5079b77bc7d71383c044d6907b5e2df1f71c2e29aff59c2bcb7701e68ad09bcc4785703e1930f15d599d45a34055056af9fe8647ceb58bab0768bd87e9f7a4488011e879ba15d6a1791db1aac7e408c90da62c25659f1255769f13334974792bb65ef675d43e025ed67d298fb1551177381ffdd594a49053a93e65631ab3d05a40a4026536b9d97e1eabc75295b248bced6e149a1aa9753cac8945868a4d75b31905a85495f9c2f4c74eff2d3e20dad7fe5d8d5fa18cd3c83e0d05deb908df1dc8e190e82368de5697ce0fdbb57b756bfcbbcbd79b361859b74fb5a1074f0d0448fa921aa278567a7d11e189156528ec19ccdec6f87410196b8ec1fe4473916bf6700a0f55189c1bb26eb821b35d7d7f8d56d082aea378a0441e30593364e2f650dac4765b258d40daf791d453bc662592e846f5b2da07b0f60f27afc62e734405aa1d203238772cac166a5fd8a5c4d5cc0bd9bf10b33dad8646a850ef25c253220d9d3fc1495aed89267ea61ce7b191957ce297226b272e98f94bc4d55786e0907da604b59765384b2415f178da6a392d838220f8882c34a5f0b903e7706e0c9dd5e89059ba35e987fc1fd940abbd816e154653487401309f6ad51c545685f25f37b338a9b24f073eec468847848d8e6b7b1a179b06c2efac1b09e97a76e20ebc91dd5fa1ed25413f83f139f41f00146d00b939cb3b9d352af7ca358debec53b96e8b3c993b314d292ef16dcec6648b46b7f061d23677300f55ec22c5d1b3cc1da380a19923f5c9b201f3a83077913bbd122264d021951b6e28ea9c3010e87bbe80a4e7355a6901b7b45113423e5f4a5ef9ec6c395271f92c84f618d79659e17d05da32815130cc49605c0df9e1f9921026d475b15a44f0946db44f3f11197fa61cefd1817d89110270c7533bba43ca48f0a449065d347d522cab1b03f3ebb683a6b0a6e4d71f6eb4c53c61726bdb2ad37e6bdba2d83c967b9e15844666b27082cbe3f9c8be2b293a7839a3587e51e8538c84191c152d0ccb31d3a779807c5fbc15b4b6f23c15e0949d881bf4254f77563a671c77eb1e73c4d0144776254cc80b441f02461e6f20152124a2ce0b91fd050d2dd92bbb8dbff7460116bd2c595b11afaf08a11af00a545c5182af04de1f8f66347eb774b3edac7148c79a84c71345c02a654b2ed035b3006379e34789f4427b59e86b1a61bb1f81b2992b907d076c17b6ee0273bc56e4c10fa82bf6fccfa127a37f36896ff1fd32355519d2815a7469bce068becac3c4ccc831dfc59e191db26d4c95760faa4cdd509a5386d50d0f90ee9ad25141795e43db301114db78038cec5d4b22e5e34934e9cf3fb01f8c7a2e9f75c17a75a991b88d5ed5c0fb70b18bacf09988ce1dbcee5cd70a04a94fcd715c4c7d7346f2cf536a3a3bc3b36b5148c0a6a9731feeba8ef7e32c50dbc0a418036addc619c08299c22ac98c9424a852df8e861095485a476b3874b4455b1f3c7e88c307eaac6b2896a4fdbaa52f912303dc1caf2ed7b635d1f7fbf89ec5be415259ba69cfc1a7e1cb3882530746d326b0d97360cf88b339d8b9f1a4b38a69493a39aedcc0a7da38ae3b6c6d6a876d98cf1fd02c175cee68515da2d0f0ab61e559bba960d0896ec4f843b71ee6d1a0f2e56a6ca1604d32a7db1db55e90de955409f8d07113dbe058dac1d4738f93f21609d1ee7b6b4bd7c4878df89f1ae3acc76ecfd852d9b4ae39ffb622d1d3aa52629e92520fca4e750eaca39b0bcea083bdc04364ef557675a123e3707b5eab4d9a2745151a89470202a2492b1f50f7e73519b1f002107d62099e71a45be6b41d7227fbc200b634cb9a339f3b9559b6342d2267ee17a706582a3cb74cd9627efcaa41f7599fdbed42e2bc1d86eedef075094e2ff7d5d4ba3cd0a172f0a8b40c3e5fb5dad090f42ab907cb9d7ac0baf52542eef33858d925b5967810bd85a38826042f2bb2911638a41537b748de4aaf7f15d88d7a072d86530e508a2d909bf415937a057702e9c3c222d54ce3890603ddb896f2e562d341794dc83f4c9dbfb8b76bba144c33eb6873f4ee9ef9cb205275dca294ee9d47fe7280792f18b21297eed01a62eebfab8360a31286cd287826569bc31b305e0bbab0436e43a259030a2bf8ccfe92c5f577a05efedcad547571b0dc05990a00ffb4ddc1a7ce10d3e84c9f61a76d283d4782a956a05dd76af4c6a1804c7f8397881a26961aa126a4d7c0f80d187e728e9fd8f7f4a499f9cde6df3bb7a3a0ca625fc2ad2f77023854f8a2173b317df243b9eb29bf7c15969a896ff55ba881c6ca2b04ec09a829b085d1b22f299b016c48eb6adaa6a035a5becb11a849a0ae4ba64a98f246bdbc87a35060b5846add713f87a36c84946491a5b69395833d8c3ef00d02d1ed4207f412931db5cf95c82430d3d1d85251ae005b56bae7a8c0d7dd4c9490a8529f33427b9b84c18d9d32aad9d60c87ccfcc4436dd3e20058f9e0778807cc59aed59cb7dca21c05acecac84fea3d8f1544467bf8d2f793e32638c3e97269cfe931fc85d946470ff134dbbb6b781c768bedfa6370415e25aeae625e3c3ec736b17206443694bb20ab88492fb53e9b98366b7f720b14bab4feba08e9aa2c1054612cf30e36bcf02f70bc4b088d6e09e7b3e548c471184b9fb0dd2b32f93ddb606e29f1436f2029a9d1a11c3ebf8a818f533bc60fe606fee635d438fc5c25510f0b13e92b167596e7ba5be902a7f2fa5ee83fa26d65633a28c62d715fb29c36a4f5837b20b7b9e56283197af2fe057fc8a72fa33a6a5ffcad01c2e7ff40549a8ea17d77f4f7717dd33c45785335eec4fe93eefc2522ebe636e25893ab0b7d084fd75563f870c3d9b827d325a49ee407d73fc47728b33788d0e54ef4018ac5cc3a8acd2c4bc880803d57ff748ae28084443f970bf97363768a7dea9b3b8765747c0a5100397b0fe2af45ec6eb2f7b6f7686dda1976b8886b4eda4b79e77cbee64a8ffabd5d40e44244a2d691430ea476d2338dc41949b3eac064eef651355ccb3ee858a347dc1b135befca29372dd7da7f9e5e4ba2289394b56e18af801bb74b73282a1738dd6e6ec9cc3c2b9090b491f145c5e918896e72b32386745e1af66075a633d1cfdcf72db9371163ac7a5fe0adee0dfcf3cbfb0f4fffe99bf8fa1511f36d7049536643d00d26ac36b770e0297540ee2885d9f3b73f826a3f0f8a0691151d45dd60cef5fea443b8c041aaf8aed0b218cc03aa55b17c1ccc0ef573a75668391d02808a569bad669fae77eb4d1a583610d315e28540d4bb9f49a7ae9d3e2fb4926c6001f1dd6c35f5f5b817d98ac2020289d9422b126b2fdb4962398aefa51842e53b9215e6ee2eb6e43544bc7e8d885a3dc8c85d4037550d6b8f15d4c3adce54235d673dda1dface4ee273e043f2b09da4f58a36db11c5db85738adfb2a94b064a73ef2725291062b7f4f33ce10728ce8b397fed0283dfcf06ae656036a3be334c64b0c6f751ec6deb763373ef970b430d88971501c9cbafe55fc537f47f1e6b0177064329d9cc976ded977a60a8e7246e5172c7412c059315cd11d12d7155131505bfe6217bd22ecc6c02ea67e7380da8cca1fef95c76ddd170c2c1cd26781c5b0099cf4df8633fde3ff789054c09b019b890159ede5147b24aab96fd507a28ea9302f35d7d5d8e80044ac6e2f61b3c35954689f03c708d32fb44017b7922bfc0305c67c2e58ee72c126ce5b2eb43828a372de7e02306c0c9728a8ce7eee0fb369ebfccf650352daea08423b141656235ceb7e80a6f7ad74389538652ea19fa08e4303b2deeb58110691e0d1dbbc2f98eda22b30cbff04692a626bbc67b0f132cf839de39b3648a94ebe8a5d9be9c06d046a853dcdc8a15ede997d7a2dd2923eaa8d9b00c998f9e82e81149d271b1629809a3044222ce282089d06135eefcdaa72b837ac6e1f17a0a98d64a6c9d7e97505c82e01f154620f521d3a1147a1170a73d6253f4edfa00f30b6b76ab934f00be79d1a72585906c2f1fcd289c254027453e0c0481c21ea2532943157a605d491c406c881a5c46e1b4f444337d853806bfc79984d3291e0bcc6436f10c017a8f5639256911aae51ab8d746e3fd6d15a19f1e60b64c60c4bfd4556d5338d51693324e4cfc0a355dd0e2ed02cdbb4c2b5d42d6f489180a1a728038eadb6e687c837f2de2c59cfb45e368f05c08bffd49924ee95b1c41e10d9af5f482b66f8b4986e1f733fd0f4281451ee6f086cd5d70432935f4d308062a546f433aeb6f70d86f3c122c4927be7a89c561f9c024d844d573501fad8bb4942f4ad004f5c74124f592ef3a2c1e984b39832caa6e7a149cd8ded2e4ba1f17d6830ed976900a29bf83c0cba576f2cef78a7265ccec809b105e4b400b3cedc795a7a1b287868346a677b227e85639682b8eb586fb94f2ea7710d410e86d7b722feca5eccf20adec09c76c598c45e0a8db6ed9851af2daedee0661511a7ef6a2d9a1f4695be4cf2f041ec8e7dbf01278c98aea57fb44512ab9e108a284eab25cbd6f7255434bf34ae288307164cfe5b9ace7205f4e7839cf651599f7ce73f9438c95f201c5b10d61211bb850c3ef52aebabb8461bb7e30e493fb96fd5845b9ad1ffcf146cabaada79a68a50ba3634e273d255fd1f25042178e90414cd39e01bff4e957f2160a2c11b2c2f4e58c3865e273ab33339bb68fa6b95debb0dbba42eb902ce1af4aa54f63e5c71642a6cc172211ddf7fab5923459500a37a06d924d7802a3243ed4449adb58faaf59f5acbb63319d04e824485e142cda1450875ff2cfbda54d80f35961839871ca414252d4bb9bd6e329c13d9a76ebb7c96a705870e277b56920c77a473399b6e27c08c29c53f53ab040ff52c828935b7774e15b08345e43471c25796206f313920efd1c8ccb4e27467fd6fb57c887f513cab92381ba7dc53d02b5d7ea573e71b6ac694d7a8e19652c663dc8c1cfeb69afe6f267b2924ca49dcf8de45b6c95169e7c67e1f81dcb6424b3fa2448b2e980c874e14c40277dfa43ca0a85306268a77f65c75eeab27922be0283cf6e8ebcbd6e376f7734f4dc9ab4d18a986131196ce1f2d9e3d2d27e1b961f78be597df054cb5134b6f471ccf5fa4259df6643a47419cb71f4d065f11f0bfab9870be2faa3c5b674b6dbcdd386694bb516be78d7513b79f60a3c3b64f93550361b7e7773546357d2bc7ff40a288156968224d08a4cead26dee8d85bb6af8712ec98cce1219f2b0bcb1fa18236e8d880b2858eb31761ebb872cd3dc274519dd810c60f33da5baac391c38259344d704ea5d3257954c2dcf7cd51c1b56635dc2a030e36194f9266d2bfe575b1de400c131a2cb1a47e7c64f6e7533bf20170b990ecf904c0f4c48a26b6c41bf48503ee7d0b637bafd38c81e1b7ef731a20242378a1f5a2cd516e5560eb47dca87dfb773a97501aa32d6436936424011dc5c4dcd27da5c9cba59a9f66b577c98b4b08e745c9f74bcced25ac73abdcb64335c690366e46d39e2ed74f59f588b655b31b42973c765dfa3d26b5d5816b270d8e07522223a5e494ad71576e9ffc997c80fc455691173fc29b001f0cef251ba7ba7f7cfcbcc6b312ad6ecfc387ee4d682fedc2f94ded7a02d69322e86e659198d912d746e69946f8584b58c3ce5a233d9675db9395d727c15bbc9fe3c9be608eca8ead8006bf85c8a3be729ebe7016e1e418c5c381f9c2857ed5149a68230bb2ced38e6f6de894522b73543166c5ec655119a1486c0a6a3227059bb8d9d8a02c8be9b7e75f7abef425c0d172698d5b15ebcc571ee69e678d74c1f8d53c2d8af47de65bb9153f338a68cb6f5e7f54903e3c6269f53f4ccfa57b81664fdac09ecd30b9b4b4e96424b55c5d951fa1fb4f31699c6a266ecce067bba4a9b9df2461fba8941206c033a01ff3c034d6daab1c0e9219c755a1df46b3ec0b34ee3867e26047c1ae34d85c010fd057b0008d745273691b5d9f36966da76c461dcd3e3ad5a86d5d52bcea8dcc79740ee1edf001af40bcaf2fa72edddd1e7cc9af7f38a448e1b4389ddaece9574065fc44e95ad517e418cdbfeca0965e04a50e0d667117fc0b162f5452cdcfbadd71b3cfd51c278a66c8466815574d673b9e632d4a1e24e2831ce6819bd356a9432d79567195593d60a6d9ae87f1e04b2f96efcf8f86d1ac42752c913a292b4199bc811ed1243c38bd1fe77edbb95e765ade03d3f92d01fe2161669cf398507eb08eb9121132172861c01d0448a95be3256f29228a327e527203860911f2398f6c65f6683c6dfb518b4c2aa6f919e2a78a63e034fd88a49350c2df71af78ccb6315b6870ad58044ea0ced5fd2c3bf890e4d381425a5460fe6ea26e8047da66d545701e995166b73435e24828baa41822226d330f801b6bc7425f2fab564aba16f2cdaf8a63a7af45a3d580dd4018b890fdef50a23ffecfbd2d2f69781a9f3aa980505cc3e2a28b52f1b8696b0c2f6911e4cb1f9e0c8509f8eaa135ebcec412620952086e12ba20e3c9215c0b577557d397c2d11e2b65f9f2d9bb3cfd6962d23b37e016b066f17907b2b88d4095c9ab9d721f4b6bd10652687e2ac5623a9a8d1858a952e9acc15bd463ead3606f1a833bd52271de5ca562fa892ae6b8a49fa64f60920f0fa9c5414790e993c0107b33a22dceb34b7fe76a7882e80e1a342a83f689655b09c3e7ec51626512292b9207de6f04aa0176cef8290b18ab1c5e4e2dfc52dd2e4c444a1bff3ab4bc7dc6eb730914f6c8818046b7f833e053be5f29354f75157a0a5171d04a0b29c01cca8b16e2abaed1ccd11708f284bbaef9fc1dd0bb9c42f5d8fd0d85c3902fba99012c8c75387957b578d2b5fe4c06502fe284f03f1f8db91d3d8d516879751af70cb8849d7afb5dee40fefd0274c9379fed68d2c7c3da4314b0c3cd86c0dfd9343199f90ce34b54b3b874c3d3230665be57283ac732325e582f67bd9dbf023d3afe7900c10f46927a4199a2c9c9f117009cf06e51b114a0ce982d9d33347e14ec0ce469cb6e3b3a6b9d4fab5bf37f518c1f04ee9dae728d30d9d45abe6c45a552cb5ff5cc59714c0ea9ae74095621f2584d9c4bf6649665ed0472c782821d9c417cff604817075c3c7762f6acba9259eaf9cc6208fda5c01c3bd5df251ea394bba7bf84ba247371097304ad6abaaba3e44f5f9bd0c6dad1734cea0ac3f327b68f331c823fd93fd13046d8c59e49b0aeb2cd4592c13b00bb037f6fd73be254701c72d36c16a5183edd0bee4ad974ff8de7cff83cdacfd3278aa1afd23e5042443f83b8b7d88a258914aebdc268f0adc1249279154155f11a9f64c5c6993434e3d36fad47d2c38546f53869b72e78777375f49b0acd8f3c13afa80385f0b234430117427562b94653e33f996022eb20317f7a74a4e2423372d902c5e8a2926125debef1a9dcf00f7bcd880a99a9ced6cd291858d50f0c17d18b4db5a326786271ebe2566253542e0e4cd72fa7ead0f1aee013e7b692b285cd19c42e8a55d20c45877a669951d51e5bbea46ab8f3f1471313bdf9fe9fc9ba7bd8e104f29c6c91b37ce0d1490c6eae24d4dbb2cb7315d41ca3a8027704a3e932dee85e402616ad8a3a639684b35509c6f3bceb294976ba7e42fd9d44340a00f68920fa1b05af0210daa876872aa3a5b8ea745f4d9f514106070f18657af2bbda3fff0282f57bfc67bc2465d987b2cb2bcc91995d18cff40983917c783a13f71e3daecc4d20977ecb5d2920ce8132f2dd7004410e15263270d4e15fdd41bb05a946b3a7997fd72c1956311f758f9a98b1fff00a5e34360caea524af5b5ae0f5a274a3a2fe9798c238d0a2ee385706aa5e52caca9f9d786fb98159aa200f51652fc4033f9057ebbbde92c5d95ae8fcf039d3e71c0f9db4bf5203f37fea4ae50aaad0ee8fed65480ec236e5ad7c1ab17ac47e02b9766530fe7ae45f34e2915637cb3d932c9714f6417838f38534b418a104341969c7087e997db170b84525fe0966f481b6f2e49f5576481f0cc0d9ed5ab9157abf8fecc8171a6251fa53b82ad617aa007b459a57387d0a4679e87fd894a87d35a8dcf9f9b33993b64e8d3680628bbc476647c10667828dbdb4775565e21751579f4cc4aac92f2f9ef4aef94e27370ecb70cf5f4385b0585fd1b147a25b57f564280f940f08131b900e37bb8fd768c61f71ac75d0c530e818d7e6c66cdb95942777b25b88ec03f4179cba49fb9ea890b4001a2abc3fe5e25725071476ade573c175aea0ba2a61678bcd7f29fac5b101450d1b71bb2712527636b5106f994fb17244e9a02db2af7403f7954fb2cf5547124ad9ebbdc5d4db59c9d48a6aa39cb65dfe506c47e78617793c83ead8d097383d9aca04f4a01280046b40844b7fb670d2eb5e52cb14c33ba5adaf1fe52408ed1ebb6c4ba52100ce3432b9879bd2ff2d48f2dd49fb7a6854f41ba739cfda2c942d103f780614360b82d448687cee1b67f966b0176fe128c876fa6ce696a041f2070b5b53aa422956ece264750f855a41e8d63ae712a494b80bbebfecfc35d6b659f645e9984e34fcb17956b66b8a1fdabbf70e4d7c87f330edbcdcd8612af06ce34fb36c44bbf3eb260f8435c9e1bb71e4636311b5a00d7d9ac02954f1a12de6260f49eef176dc7c06384ae34655e726325a27f392b2132f7dcb1ee6339c8cf5054e77541de3ee9f639b0d81e14d0b2a4cc9a037d3bf26cd11d13b5f79544e7c6cc05126f9521bffa162a23eccce91732089086ed232cee4d3259b30e6aaeaa9d57ac08f1046b51cacc81798a8c7f1518ce500cca907f1fc8b309a10ca112a2b19503c1ae3f833a4c5c9b7474fedb3b796230541ddda3769da3a3c1acf625183b764e0e8b08ce2dc094e12506d67d24b4719cf14276635de03b041d67691933d1a79b8fd221ed840c240fc4f6107b6df18f75eea085b7d18a4c172a677eb531b7674b86860702081743735382a3a96ca6c7307b7e2bae27d98fa3d306064cc9ad776152e9a90496ba90f0c572b7b00cc6792224e2913fab07b06914ba007d578a87dc6486832f5135edb2bc52803157e728c8a6ae0da3e0e72a27d5c0b40814ac8d8df11672a6c52198c53bd93ff0acd248a0720c5b46e7e36d63714adb0cb511e562c8870c3c86113c11808b975c25f59be9e2c0472ca7318a50b6ec306816d542bc23d5ed96705a4c45326b2639b06d647e2c1858d20c7b303bda700f62aa020330a7e19af9dd35f9365cbb4d9334b6e7a3ba1501cf26301e506a8bbbd4a0bdb3ba35db48fed52dbbe083f6e45e060f5bebc8c4bb43db47a5fde5c15816e21af14d0c9bcb2fabbf3ece101c51ed86392ca658599c892f1285276ef29e7f1a6289351475ca05050946a2da3edb7ff87e483e5c0a36f57c0a005599c58a0d36884550f5bb4b365496e4054e79afaad11e4c64923731ef4835864aeea0eeb6fdbf20384ea9c4846fc462296cf384dd130b65180b494998d56dd22afa1e172e53dead2108a5d6c1c0b5428d7c92b48931a26a108ebe2625222a4fa7e793293d3a7c933756cbfbe9006b46b90d89235069ecefe012a044f8df3cce8a63aff030c6a78b203c3ae305bea5096fcf612fc81a39f273c7bc5a0442c204ec68312b08b209e66f813e8e370181dad4f264b2af86c792bfbda09fac35b55e33572bd719e5dfd6a811bd43e26b755a95140deb9aa744b9f3828e2e323c04ad36627ef5d66609bbca0a493bd0bf0179a9f754e960989734925511cbe6445900e24560752d7f05695b3b89fb28166b4caeaa44ab2bba6700002fcd62c6427e37cc7e3793ca04f31c82d089583885c4062df89cea8b198f2bdd96bb22066cdf0df84c6e4e9af1c33108757551c4cadaa590a887ec3b2862d24a11451bf22b7dfc783623f79de6773efaf18b9b9c861cbf8f4ce06de37589dfffe361f974f6bcce61b721f13db2305345de3c00f7a3dffcc956c06c8f464638354f1b034cd8d0a1261c3f849f12f14d34feea5aaa95b29ce62c8f341adb449d4f9b152f07f50c6b0b05c6c422134bdc99f5b15325253ddbabccfe2498c6c54a0b544f317cbacebb2c2b571d2f151c0f20c9b4e4534a7f0e48f3f412e7689d7bd34f20dfed3cd70c67ba625b62e6682feba46209dcc8447f03fd7138d076fad99225d10f080afec1e0c47ea3c3ba4a018c883c770d28236c3c3499dccdb2f6f0d442285255d5f701e6cb7a1efa02da7ca38c1759d44a35bc1f18dd7faa56464a5d0f2b3a18988d4e247dfa954ca07fbca2bda096436f54918e825f9323a7808e7d5a2d5da10b808e80dfb62077bbd1ee23d4552716005d420671a539ac6ef1d31afe9e6bf42dcd18531bb7034a09faaa0faf9e94efc346c2ef7ae433b38ead402c6d6cb0672efd3fb43e8f9c2e1f0e9805b7e5d20ddc2e919e3b33f63dbb663acfd15652aa9b9ba60f5743b23f93278c51a4705df504334be96eeab2e3045116df7f7a8a8d943548ce16d0314e84e7479d32c426bb85d61e2afa52ee86367d7a52d48561e0bbd9707df591c4bdcdf027363b885457568344cd0236ba437b065f0d0a98937955303daa524afadab24393035720453869b483de016cb576ec5396c0c91bb1e6e60364c365b08e1d2cf322883534d822cd9c90bf85149c5ad36a39513611ef731f92beb79a3f2b64412eb5c844c7478deeb209d568ab1b40d1d1c4849c95ad6daf19a7cafeddf43022b25fb14529305b9f1b665aa211b8ef1c1571bf724d17003a87da0e96996d38889b68353398845ca05aa5da707b64d7725294958edf7b94c6b509baeb9c2a89ecfbbace081f2bfcf6a097c305442aaed2a211f47237b2dcf06ce8b757860d1301f23d555f83010786bf254356b7697b043bf4d769d4016b04ec2db4efffc1c83ba03518c260124d399fa7cc9ad99f73e82c0a477b513df80b9807447c01a8fc6d614d342253d59d21f37b073a97f0fe56ab68cece6b5b771d8286d419818e11757debb0458aa3d61bd4e7644ecbf3333bd893981b03e7aa8a8069633986308ff511576ec43ae0ada24fc8c7d05d3bd80a910c9fb233fb1f21a7f37b706a2946db8d77200a968ba5b4ec4de5384a22709a2484eacb17fcc2a0dfb83820495dfb3b465017867b85e12e715cbba161838e840831854da49fb5c8dd2b93f0b5c1c42e6985858257845ad5affec20e17fec9e87e0e8ff733d2468681a552b79b6f7da3c0712aa7bbb1b85cfe8c43b9377555535f21a67b2473f5e5e8aa31b8bcbc2af7f4547ccf431f0a8d3a54deee814b6c81ebe732b075ef243cdc6e2be2c895e170c2534323858029ab6950a98cfe936e47797fd58b428640f7be82e60171b07d6b5005c971d927fe79a832d2b53918775b69a611b84b541ed230654fd8b603771fbbe46006874365454e3c5f1b8a6161a31ec68ab7a783911c8fec461715c572264f62864120a2337c644579bf3146781a35ecae1966b447771325c8d956f751b1e20d6f8e2afe5aa38b5384360d2e802fac0890c17322d8757a383be58ad6bc09bd49154d1ea142df28cd3123146544121dd1fefd1c9de94f8040335e9aefbab310980dfafbb2ce2cd4dafff93dbf09aaab0239f759e06430be117f9eb45d5c43c5dd6a28114bbac687a57ed0adc20753f53a8fefa235c4e8bd583daab2a111c13d283ef7bb7c53b6e75169cbd18e3c4580c8151325cc414c4933a7b46260659440150a1a3e4d13eba4180d7e54a1d0554bbad342185ef7d7597f8e714e80f8dc7a888895dc6fa44d354f1b05abc4ca2cbb49b8bec581d851591ee5470048ac4a9123e87e67bb62c3d6cab1a877a0a08f4f1e897974638f350d179416702292b76fbf0b946827b1393f6bd5f3396de0f7e0b11e01d20902a407fe4f57c6267a4030b9b19ead7c494cd3fab1039d596578caa1f0f01bde800946a2b162d8b754393acfa1c0987089a523f2c0da1a7b19dd4c678884b662294787d6e2b7cdeec87458de3030f69e491c828326e18d0f42a893462f6f4e13025d0aaf1f6388594d356c887cf237bbaff6fd10887b91ca2c0669530d9047ff25048d45349cee4f215bc7143f909cce8f1d52992577b90f58db14a43112f3abf8788e1286318011f999e79071bd19e44f002da7174d620dea12cca570ad74f36f13878cdc524f2cae82713ee59ae4b1f491a2a938c61aa35261f93ad890ef6aedb0f9fe0202dada0a29428acf4388ca1b3f54a3354eb527702c9a1f0f80305570af0fc7b996e68f0eec1003cae073fd7d71d7be0a94d0b735e76199660c35eab6598bc9d1af71df078d9a07fd095eccb104272310392411cceac46b19c02355996f40342730f27ad96148f6f0601c00dbc37ba4d8726e1965e5f815b6ddecc4acb0b8221095f383cd2b5eb9b50bb3f26e79cf2570893e9e3f95b6ea2eb845a3bc5f078d2dc938da0ff31fbde1c3485e0bdeb372ea1fd0d70fd4eaffd239b28c9c9a05b41ab48b1d148746f65fc292e4270185b97356055273dff2eddc4a6c37ad56f58130304a64353c1ec9de9da3bee6cbfd55c23c725fa5e17958e63845ddd4be0efee84de4cb0c8ebbb30e6ed1379a3749a78072ed3db904e8b025f8cda51ce7ca9640161663c82708cf6487d7f5c0583f2b7ba41d2bf567d551104687ad2350fece7f76ee04562ab1ab80a11514c8d279bfdc55d1c2a81447807b2cb6d660d4bf1590adad490de785d2dd2c7c76e61dcea333f474229160be68a3d849cf2cca462b9a502a458713c10c83fef2148c014287399acfb5f7c61ea343b7abb5f955c8a66756afd693caf578d4234b09e2aff065260eea09e822bef20f458ab5ed4175efab7446831e82e6ec018ecc5b9ce41c7e7d701120afa5ac5c2ae6381dbdcc249acb37fcee89df9d68af8f10cb7096a7103beb1c16a9dd47e0cecdc38d869f3b59d78d8b2cd1e726257f01f96f53282a4f8b17cb96c836a9a18f64b313b8a1409bb986c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
