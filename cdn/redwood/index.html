<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"633331200d26e9ac4e3650ba8ddc65146d6819e4dc3e4060bbdc5f9f1b3824464a7dc7e3cc99ff1dbb534b302b81b90640f403c414cc50454efa92281b99e88a62db0acf2600159820a3a42f6570400641ca933c6a6effa0b55c6d0e486fb86eb79c0002502ba3e0a468d2e9300c72173acb1c517619b390cf1a7ba845f280953933d74b8b9fac5d84bb95b780f3e983cbd8bbcd6450adcdaa7b06f8f0aa4d45f741293a254faed7a031a10a66e9bbb2bcc9902d317bec0eda438f9f262bc03f7a7e006f74df79141af7f94ec7d53113369b6a68419ce648f96f33ae9d1c12d4465bb0ce79e7651ca0b968683901430867f5fed42bd77160b34273c11a39142f92089f12f7181353e2ac13e5ab2fa55027343ed48ddd24ab3f41a405d216ecfc1c74730e53f8980580f1cc9ad6724055a123aed8f008a4f0c4dcc0fa278b77e7beb74aa217c10126390bf927453117ea8d28766fac4fe608d7e5d523d3ed6d575d7964fbc40dc316ee9cb26ee96d57a4ce4a2430ef6f2f7344f5399804b3f673d96ee569a4784ec1523814877f41f706b65511c25069b8d3e56c3e745fcb845283a1c2f82f06a27bdd3e2e65d085cf04f34339ed2aae064cb2983d039394362a88c722ff6f91637ba3cb008c33dca58e5700f38b1c6b2cbe9b8b61984d70888026374a7f392799ba6ce33c54f10c3df1e6fe6f2dcc9252a709de93f906b05181966a41673cb4f290569b785b4de496ce33dd2a29cf37a2326fe66b7fd4d7da5b467031906b89ed6162c1437b0930fa50f20c3f36f3072dc1080dcbd8c2d23501a8b836d2183b0f864c54fa0db56aa42dc4008ef17a0b87af00d9dbc640df257082bda1a67efbd42f2b9811ebfcca1d4e3d59ad4beda52a65ad9435218971f60533fbb1367e30d1412b74bd187f35c523c77fc8a7dc544f598610f319e9048b05b33a6c8e6cda1f4e07fdad680673a98a380d656cb3bc047de3ec1cf74d66e45296150ab2a4da714ab97154bce6096b59b1e572774d93a1fc9353e6a36c243310d4ba51154b064815bf4585fe663d64571d1411b6be9bd340c947ce48a35cec31c3f0e34a92b4abba00b5906b3a4cc36705aa70cf4efb650086fda4440948851f6f3bd3be53075b5ea3742b4f9af59a6072506e186ce14d730f6f9db92a90df8a5df3c999b1bc0ecf7466d4766652f1a6a114d4d7584691739bd428929b034af18164c6355250e0730c80da88556b3b42bc49cb1832c44776701a6525e4fb281f8f9bd3a57a4b2c0dfb28d1f843722759a4f12d28f1992e543fa83110976b66598d25fdd56c3f3ad14c7d6ac3547eb1d3d2f346fc71721cf7df51e917c4cf1d3ea291491e42d97d2b8e36e9efc3bbebe2ed1465b464fff015ea854d6f51250b20529cec02cba0e7eea94dcae30291b6f2297141de3b820d87b540324916f2ca43ac80c3347a92d75c4bb9e8c6e1037cdd94f448c016b9ecb414b38f74236acfb4a93e40017ef0e389950d3c635a656e159963016b07edac9da44d0bbfc4608f854cc6d3fccaffe2d5dcc24936a9b7e8f69ccf38c21c3f3c8ea9f8ea1973d440c8f34f5d9d2b0cea338982690c30dfe521cd2f3ff7a42651b0ecbe75c0566746ba1a782787ede4882533844695d7fde6ae24b04b36330b77cbeb84d73b8bee5b93fbb01b3657e464571c437d11a649ee3ad9d7ba1e7a460b523f0f550e1915e74306ace3f301a41497c36b25a905afd67a118c246fc3933dd30c16c81b5efcdbad479e57f45e89675a6dd9af02ab83cf943d866a2599533bce9add2853db3f40ecb595386d13730519029c988de1555dc93fabd9e9984d6e8dd78cffeb2920c169d85fdaee67a71dec67a49d74ce1c8e711191b760ce876bd1a9b2791e304bd81ef8791c9f518afdd34464e46c66c9213ab4c09bd8fef13dd984193102f12d4df9b85ea6298ab624cdbb0252dc8d365064eb75986d00a92091a8acb6a23601e675e5ef14d72d6a3c7f38c31d015db0da6f80706d4ba6b90011c7661f6c62ae94f262863c2d9c60dbf767f3950c45711bed306adb83ec72a7f645b047e857bf0cc60698abeeb872e8e5f03ac679abeba332575fbc72b2a46c564c7e527e9e930f1e9079562f19377dd42646d47a8ec66052d92952940f77271db4681a870a0c7bf6af6712cb39378afbea37facdfa6c556f87155a69ddb6e81f4ae5668d959d525e8076413d9f3fbeab170e6562b75a3d366c57317f813801b7be8375a522d4d09f32a65ad375ccaed85ca69604fc827c10fb5adb6f5c13dafba2114a517d9a630faa84f3eb562b8a2a983dd7809c7b5cfe089de7357b6008f0107e43eae068fbdba5bc25b7f521cf9a7eb147c77e7e208cd8cbe3a8f408f33a2f10a91287ffadab0cdd38832cbbf3cc647cf1fe70912771fb4c36151bd5965c5bbddd995678cf9c8095e66c783d9d06950fbd4a6a7bc4d75f9242c9727edd7fc4328fbc787c7498e1919337dce9134eff2e9d882877df3925c709e99d517c21644baf66d86995e1501d23d8e18e8699b7f36cbecf68915b7e16551e72b6f90981abed0db99e9042c508e83ccaa7e44bf890055d7f65c71fcfa64a095bd30affe56de7d3c8f8e40387874c8a96c0d1e1e94290a4503566b6fe40ca899ed68533297259e8c0e832a203de52e3ef162b5acffd642e7a525721b8f26f97a41260562d789251a64da60c52b410ae71f24eab88ea759b54f19f1a1842305341cfac25b055c479bf50c789851f8c4d17f4aa0b2c7cc461953c3c1c83c6750f43982fa3cbea2857a585603e00e8125b4c7b81b7c0e512228d0b0dee40b44bf2fd16164644d8732ec5c8d12bd1365ff415e262dd8e57e9f87169452361c20e62f2bdd3304ea9ab72a173eda70fd8fd4d7b25c3174fc8ac5235498f4e9c0b640422b52d5d45bd125aef0ae83111326369b79a5379996d7948a91c49ef631d9056a5489738aca854f98f874f55c4a92e1a3ac40cedd2f89540f70e69277901b14f3f277e59ce088482cc4f72b6197d5a64536f3b6b106482d67493c2b6a1abcfa59ee0a95ce98348398dc9e260eba82a1f79dfb39bfdab80ea4926c1b639bcd1cf6d71d4c238d76a1e726109c4b3498eb4bbf3b80302c8c2aa3be6d04c581773e69d4f0a44169b2980fd265d009469d5e766cc2d48c83b3bc38c22bbe5d800d62195f1273d7bcdb68102533124067a9c5616ada6867344865348b3524eac444c2f54ff8e3afb0cf737b1cb62d6d05d0e06f24517085c5157263a7fa6b50d54eed03c5d8af6f804eb4b52445a85e8f9d9deb6cd2d829a9d9e7df1c1171abf6e48e69f380b6d99578b3adaa3588c83a6f3c9d00acbf93516a3485c6fdf34bfbcb98c8bb65fae4b22625fe3faa5fdc2428a9e785f4adfc4178249dee17746a7f478bb505a5c9510e9b760dae50f99af7c47f3d52cf9ef732bdce1e496682ae287d525ed979b89324d6f2c5646f5457e9b7177457476eea4def22d5cdf78b4bb4ab1ef5083e6febd262a9f90076f54dbdb8423ab312990c6aa16e8026c61f3b78ac67fb6157143bad0130b6b9381f5735e04f41bafbd58759f855772067b4851daca581c2f1e92c1b74a7c2e71bf559193ff85a480881c5eb43d16632f6cfa31cd0210f08def6e354be2a59690e1cba1da8554499a82aa0699fe5b1ee869b463462ef9e67186343ad96685de7ed06c244ef0d584425a26b03f85a6a5810488343c7293bbdb0e923f74758612b59f41e6cd7a055ebac9ce182d582c40c30c4645f63515dc70726d1ccffd20eb5edfe6640480c003fa7561d542a6d8ed2836a6fe44615d7527fd23b9e68716147adaf5732dc753ce633205c161d9e2d108014270a0c83da67fb5c7c759d88e8cfa78b8c4f33ab5b6f83b95780cf0754ed3147bfb3f71686b58fbffd3b0404082e83ace09af623946594c7a953521ec6a1c7b47fb8cf25656e57b17454aa64368c592c0af464955980fcf833c9ed8a9630be50c719172b763771b682440df38e8fad8b9aace4d3e7c770fd1d066320637da4ff1176c436b2b41ddd9ee22c011f77673e500fc5eee6ccfe6eb21c77190d1a130fa90126a656a4776762349fd49363da8c2e9b6ca306a2d2946d9fc41482f893be3b310062abb4d184aa82757dd5aeb0a5c23dfd6d5cd26d2b88886af4ae3f03708676b8076eabb277b074eac220bb353bb1a57f1e61a0e18bd787b2dffaacef9bef76e1b807e94861e097ac8bb8c61f5cad4dea18301f6456ac176e028212b602f864d26a91accdbc6566ad3e914e323c79c35a9c84177d665c83d2546c4404def6203f2535e136ed7d8c7e147270f8574415b935dfa884d2122b8fd5a75c117b4df552a46ad8a8a494e644e12348633abb93026f904abfea33ccb0c55cc9487b6ac304c73d26743165d407f9336789e25893db7e4f9d33ebc8a90fa1553abb88df107a4dd51189da7932505267d99f623420a000ffba51fb57645d361022c3a0b17b2eeae288d6467cebb486bb75c95f2ada7bcec5946aa3bd96094ed40a309e86ed114a03bef9cca001e6f9fa7a7453c4cd339d2942783742b819c9352a80495e30f6f6b77c265d2149c780ed0a7ee285318442fddec78864c28c60e28e44fffb9df7ea5f62a0dff43172fedf32b5b5920433b74bb011401653d54f0d2e3fbe7e5acd9562c673b4871f93ba6d6e688919622b42bd0b9a3a7ca8f9a5a24a16825fb0f4bc4c5f148d2700e801d4a2ed4b0d052095077ed1139cd9d1a82a6ff75a3dc0cffe13abbec73db54fa59a54cd8dd835037600718ae6e6d40a177e47ff9359949a0002b6a2b3a018d22ac343625eb0bda85f6bab0f8f856f87647aec457709dd1be2cff22b8892bd6d43f1964c52ddbea9128351326b7372600de55ce88ff40c67356dd574668331a8380e23f9815dcdcc6d23b2c0c3bdce71a8e7273012bb238d5c2d983ec80fbb3bbcef50d1721bacfb1c15a23e95922d282eb9bbae44eb44c8d1f97d32e36973fe481e0bcdca28f80d2ffb4dfd9c17f2610816692738b4cf39b7ebdb13b40b437b887b54107692c222bfda7e202b1c208dad62cf64838257ab554248ce19ddddddf9224dc8d7006497ff1619ee1ba9d83a2143e0dbee19db0076ce02550e38de706e979778fdf0e4bc4a73185cfb29ca7c66d0b9ac70cfbbf1a71314fcd3580a411522840f9eb25f4d9036b28ebd5e3ad2c41fe8637330737cc9ffbb1e3f2c3fb54a247a1225e6d9c25034530e5e5f9b91fbb9a4440d488f144031b9c9acb26b90e01e6de3ab002cab02733c36fddd2cd82acbc3e460f9116c586a28e99ac06b560f41732d04e4a6971461fe3b2f8f3916dfc9caa13116314b8e0c2a4bbf70b4e2d4f245dcb870be2321bc3039cfae0f46631ecae8bfa8f8b17afd2159c812336a4194e761d4edfebfa2e3cf3f4b364f57fc914f85767ed592722fd956fdcd56868259bcc2648493db5849f1ee571f88de3e079fd82e90cf65623cc6881d08f6b3af0645f0bf41775390c406ca53c0271935f2358b0c6d51295930241d87292e6e628de63f05aed425be00dc9754872f688f93f0a047539733cb0c33b4accd83a3631e8152d5b778bd84c4e7e007d87188232c90af11d03fd5ad8aafff40c444bd4d38e570616e2f9a41cce688e03b6e9c8b239047c45e829cba9329ad4b4cf672bab2650e8a399d35441c452047c85010068fd3dc015be88e45d24e7bfa32af50696c82953a6bcef7016ab142f59ca2cb43b8dd606fd73b3f125f10dd8ae91c525e258981b9763761ba3b1bcad2183367a5645527565482f114f90ce5b3ea15115c08c289b73fff8fe765e73a363658404cc55026c7fae3e7a45c769c0e9a9b740b43a27b1b9331e61f38fe75ecd0b4e5085292087b97aac47b6baf1a7d40fde06fec03142b2ae75ae5fdfdae52759f200a32ef7fe7cfca4898c6f516a2eb957e3c261afb5af53ca7dcaddea2a966d27d7c066e7f47706ca945cc5c7e8cccdc84419689e99449d08a817fa0f60b0f26684c8571d388d04068b0566242414ecaa667b8d41e40a3dd01f6c4bbbf4801610fd6fb86dab7782c254fba634c0a3397e5015e9178e446c66d54d6cad2e537f260745eb05a874b0f952912a309a8cb164e07f67347068abb5f944f7f7d3a582ec8018e4e5429ccffb0904c395e1dbbe23bf0f928301e4970866c73c1ea1a464b94a3761ba1de0d290d5243e09b51d5ab71b9c6532a7d3a1fa7011c7b3f8531a4cd5bb199a5f6a3db8c81623d2c44338267b1f98f075933711507d9f3d27109f68c1d3bc13e6fe173337d758201f1a085dae5d5250f0420836e3490a0486c7d8a486aa72172f6a083a611494a4f9fbb971c9e3d134669c41c18c949af606c5db379f45e10b78171b7898f93c2f22e11bc36a4a3f8ffad527162f139aecf4b1b7eff71ce6b61992b7eaeef8dbb787483a1c51e0157f82e83a217db0002daf996e1d76aa6ea0de7bab80c3007d99091e5e67313cedcf51f589fed7602e4fe10cd0d85bef7e84a3f67783d1118f8272186414ac0657380147b81193ac4ea0ae060975dbc09ddae3fb15e7f374e44ab2191e4d1b1a8fcf2c2aaaed9893a201183c7322ff1ec3ceb0f583f6af1a910453b676515dde55acfc41a7432d79e8eb46221d38e519732befeed4de9e3357ab32b9789e902e79f3d2cdefec720273e324e9785c5fd35254e55d397f263ebb88c242917974c3fe27fe3f49146806963e656f0ab8b9069fc227090ef64ab280efd21d6e66c4469cac1f400fd8e522bd2d77463056e829de00c8a91b7811fcb8f42d3fc292e31d41567e47caf4546aa5569a85f405be2a2551b01e0194737ab12df57e734e114be5ca02984fb166151d3ae91069f91bcb3bb057ba9ec0dfad31d4b8a719e0383a3a18bbc28fcd9ebd10c6a1e00939263aabe7924c93a15c13dc7818f67c3fdc2cf42542fbe6e983b231c5f61bde411e766cafefc9b39c627ab0291139a79f71335a70f6ddc3a41f33ff5fe025d7accff7c713d18484f974c5af3beb79869dea8602c415dfbb68feabfe720d5b02fe77013b07acc7f6d8469e5394b080ce3c27fb06893eac2fb31f7b49dc0c73b01a91448f06b1da8e06b3873d198e6eaaa6c050585a3bcc2cec3c8d29f027c07bfee976d8d3058586c291dab661f6d11a4869b817bd6fbdf27d83e369745d72124a942cf9046ac0b315804952e9a247192971207cd44619d457ae09e153ca91ad72b1bcfe612f1df02765ea0e3d7611e7b2d110b29ab182ebcc7dff837e4878cec3aa89a786aed1e5c2d3960ec9aea867cad25224c7579c42aa33fc2ad23b167d1308f32c063e9bb31fe4ba944c1448bdff1b5e830e257ddf809852c6b5c68df505c1b13c9549c8bca8b6b9f7f202648f70d95231ac69a98227463975461efff56d1099579f6f88c3cf36a5fede7c5cdd84b7d42162290392503ddf1719899965d40a7943329a51a83198baff844eda65b1de3fb8499788bb4b32f54a9fd19dddfe2841c8282600982cc3622db12b1801a17a916f9759fa233c5e5d9051369e313bd7b70054753db4877496b7bf930fb2371ce99f09ed2b853b046e3c93815d0f3dd2f67bb4c96c359f73610605beb91187d49af9186ae87e641bd350bc38bed93a14d09c6321c3fbb2978f4d5c2a6a735244ec609ba097b707119171cd62679fc8c6a1fd52c88e9c666663a94ce940c352aad2c5e12757efc62f3010eeef0b25f4cfbc0a77ff7b1c4829a1c0c4c8348f16f566c2811eb838156d0e7add77dffca5d951b0f9727c96d847f8598e75f6593d724dfb6fcfc5b5e353761ebc157a4380bb9eca0819c3e9e4c70b3c62faf2db62a0242754e34c9eeb4a1cf68bdcddad63456cf63c01206f3f4463419c25485610daa5d685cf625f9eb4e55c4f1b6ef3f89bb0b8855ded82356b96d003b3bfb43c93ca15861ea51be061559428637c6eef762ba56934d355c0c2c913441c2d2b510e2b2d0b9262ae2e0500b6ec2e79e0ceab3783cc38203ae3a7286f56168b24a332284d47f007bfed641e4fea8b60b35baa5744c9a0b44119a85915ac961bac3849d65bff5d5958f864722bab574996eb65b6aac0c5574ac55039ee801c3d578cead1719de673bcaf50472c4e336f1f2eed0aedcddcb6c9f685cb70ff8edac2ba18555dbe1dee5ebcc1e19106b3c7cac63e8487411e44f576c56e7b3b42e1c6fceb2a00f8afbc421cafc1eee239a57c7a9fc155b194215b6086deeab363580706f29e30441ff8b62c5cddbd15a763e9803762518c4859ef861e9c1647881f81ff3a83eb34b64da4baa3e266e9f41717bb1297f9c41afc08843ef058a6b9de57812e62986cd83e5c1657274b22bc9ffd8c1ad9aa8b8503dd9f8aa478592c7b846dc1310329a817f7fe14551c4c2ff26d916428f13cc00535dff9474a8346e87922836d0ece86ac0c52b688cf64a63a42ac191844b6e5ff7af0711cb5b11cbf7bbe977070941e4f2fe4a80735fc92dac60c816810aa2e75f0432fd8dc8c27af3fe38a08b41ecad0e0133336c11bf857ec5bbe25441484f65fd04b1c68175ee38740a43af3b4108216bba0fac87e65930472bafe482bb2f75e1e75c8b93eeb6d8fe218562715ff258f65c846903324e638c0fddd262406aa86eca0e94dba05a2951d91c3569f97196888d28df7dad3d41df9211c56594aa4d56d04693103403c77a57d7f208df47a45936897cc1d106a24df269cf812d76380bd2d8256ecdf1f520dc4017ddc8fa525cf410ae1c9c563047dd9ab72d0c97d87413048a5f67a66376108bc54ff88071949419fee7202cbc73eaf0d3c4a82630e29b2b782521288f43120f637fd852f961062c1f85a9dd58e3455260f4b4a5e334a39cd08a72b0342cf63d546b4ec25daa9f8c6af1edb0fef0b409b8b5c4b181fb5cb0fb27c9d51539bc79bd0cdb1cc83f96fee1da601d396f357cdbb60ccfb1a89aa1e88d68ce667b90d018c3ae011111adce9ffe661e682b96830f69ad7b8d411ee109e55bc1ce88e8cb30d0afc29687ccce021ccbb2089fad1a982aa36cc0456e761ceeaeacf2bfc395f01cb69d2da7fc447fc43d56e9d93a07171f47c396f21a5f4d0183dc7ade7d13ecc2adc04e4cb0cfd25c5ea64ad5899b5f8c66f7641de308503af84eebecd5650a628eb0ddd1fc565101bfcaae02d5f685fb2b23ea234ac150aebf21a088b38056a13372f956cc50a215f8c3bf07da038950569de11a1ebdfe3d98099a773c803359e238dfdfff8f17cf619c9caeec842889a8f9d608ad7cee902d31c1bb0041516756a490609f88fa8f38005f49640b8b7425288d987e36db119851860f04d8c837294b37d6229119b6e1b8a95894b67376f5803da71d532902d5f0160b9492cb1dca99161a21db738788319102db03b151884bc4ea28596fb6530e9183a58ee67f08b085c49305e07a9bb5f8520e9a6bdfcbe5f6406ce7c759ffbbc173dc88aa098da7c6100e60482ec1f5fc9f7259ef51cbe286bb01236341db4b79be79500d08f07b7e2a62ed2c64109f98b3f812992d01d06f42f6496ba3c0ccc8d119641e31c23cd2b4c7112d520fa81237b667be48346f950b0915097aa0de1222cb357fabd59f03a5bd99443e05429f45cbf3ce7d1cc48c0767dbd3c44b0dd594cb2e944bc8f0672618b1be811405292cb6320c79ba0dff3531e8c6a00205f5b4a74b200eb502e0c47f2ba9194f538cd4b0178ca84b54308cc8a5781bc6734cc32e8b427664d1f0109751d280b845c256c52901a03132ecf796c1e6168652bedfaaa665f31d5815616c02a42f73205c9e9980f4de473be7d1d6177ed312247ac6b98386ea82893d0f2c928f7262911bf33e4cb2f27b84f1821e2eb26b012ecb50bc256dbfe1a823eda2afafe7ce3bf54d6773a4cd55c3aa8ffc3d767d7c9189eb9aea52ffc34e18a9bd77704fbc4e933f52dff9b2f455b132282c35b687935800749002ea092370bee01be9abe66916b3c4289d1513713192b4f475b0d846a4ef6f34600db936e72d4ee4ec2eaaeac8ca3d0039ca7be227851c1fd62993bcce8632750bd7e7bb7197a318d05a55c30449bf53e0d4cf6ef7cf1c00ce24bacf2ff97a89a7392fb3c0798b6bdc9e393c1f906df71f3a751636830ef3342c6d83af01a0adb45e062a69c2e21a6ead4522829bb0f7946df0e85f23f5e623126b61543326137e65c31c8ac6472c721de6bac5ccfcc4c78c83804e2e3b73edaef2b038a138d8c29df74e416e49928dd9f53a749909ff8be5192b4463e5c5e5044af61d6392a2ab2398ddfef2084f0fe7c7b1c233cc999e2abd5b6287ce568294991a4c5177775e1dee890552aedabfec4acac736bea1bfe27bd016f33f20cfff10b143d4fa3d160851408f22757ac1150fbc18ecb504045c98c8e4cb2b91c39d90bde28f3054d2582bd2549ee7b57c3fe01f84cb61815ce714502014411c8dcb8c8145933901760ab20ebe3bb9e2c52c29e4593e4f3c60a3e0e3fe40d4391e4a36b23fba77ad8f89c5d266a7e75f864230a8e60811085cc107a06649edc270f03870728a60e439c7c8dca2eb9ab9f6cf54fae264424d4101f4f14ba7ad47bce4ef95f728c534229e884d4d56c1511cf8271363c1b51317166b2b0131db11208fb6048c9f0316e5c953e0ddea111c0ebca4189bd784eedcf031bcb0651291e9b17b9883c11865b1a6a3cb66a6dc93cfeb902d1bd15a53eef527a863fa0d88ac68b6bf05fa8196290edaf85333d06dff4cffc45e60890bc60f6397d0e684b4249a3ce12390b6b48ca5d8aa796ea52c3da05d392d29e265b662c5f32d9eb608b1a297b7492c5696857f9e9a8c6783e2ab45dddcec0d46358587cb32fe2525ea33e9f8f40d674901736881c152ff7728499ea1bb99a403cd61434b30e0f303063915158984ef608dd531dd4b8910d4dba355e7fcca505958983c4f809cd59ab426a7c1391311f7d4dee0d780193badfcb9b0932f0e416aebf94989ad0d737b5e9064c0e94e3f34b52b01633b76ec3b375d3900d51cd51d37ea052eb8a22ee157b3b43fef53f932c45135f1546fd249cb90cefbc7a35a32afa53356e7e613107368192c9872d20e2b26ae9f4b23ee558cd5a9169bf03c1e41e97fc1e38b5c02311d5e5bc8b82735b649641bb6c926f705dc1c9a8bc9d5b2befa0f20e1f84f94295d8e747455405e9d0160061da81b25530512a44aea72372121365380ffee66cd157c5e46b78a9f7990ee3927cd94aa3991d1b0dc70fb3242936a449a0a6819d00bfb95fd0213606e6b9047a77d5049fa5e01c69d57b9bec7b9613933bef7dc604af55b245dc01c5fe774a9b2313b49363a8e286e8bad91d05a3c6fac04afd10fd7d77d8bbb7d9feae287496d50d95c4e03e5cbd64f1c81605220faccd4ce977aaa16d20214a62071e464b2a60d4757b11ea590d113dcaa96e3323356d2eb1eea3a0539e139f8b139c300254ae35f530603716ad69309dd3cd8331567344c091935f60269bac1faf6b1e077bb49cecf862bb0d5bef670737b1ccf2caa3758165e4e4aa65bc0405499c2851de579a65b43b40e5262b82c1eae491c59cbbc1838c5d0300e044fd4ec1023ee624ee5e46e5898babeef2dc87feae9e210302197b54113cfe4b24551cf393c4a62ab1d4e0e15d129fdbc9b30bd80b9816ad9cfc43bc24f4aab0340bfb3a41d637004b7d4f104dc2ee52a5b840f75421cef87b5c9cbac989821e75e82c3eba73be5a037ae4f91040ff1f05ff4029e5e592fdb269082b6de73b2e7b6f7eae6d279bf9336f388c48c00d75efd22cba5f5b624be6ce62376a7b5459c5bacf069473316fa35b5e304b62d5835f90abf375c21ff9c2e6dde70f3a07309af5ffe71de714315a8ae8c75463ff0a5ee5d2ce63c7babde600a4965a59632a0df7bfa91c8eedcbf8ec7850a677d0671a4b54c33637f95f92c1785ca194a713a1b499c6070f6aef2df5e9277d8fcc9f5a65e1d56445329c22fa6bb7d651476d1b1007867de4d64a8123793aba227807a25c33e5fe969616a58fd6d85f3225f182e4b621072f682ecc71dcf724322228ef5c28cabc377d73fafd32c0e4c667adf9a722d81054477ad9c5e1038261d3ae3d5523ba88d3796c63b632fd7134f4d9abf58e1bb67b6f1be8480a18c8feb9fcb6abdfa276720b75f024c11ee3b707860237829a0f945bf796c53b3bb2a53d70934e38bf81d68944d67b23915409e39c0ef468cc4818eeecea79ef3db2fba06b68611cb03572d849e0fd2faae34b60ce52136d0c54686f7aca0736bffa6431ce4e933ac79034f197f6e1e0ea664838c7bdceb151453d3d9c7cc815f1d4d8eb1a86806bb922a91bd2f38c169bea56ab8df7b3e923a77510d2ead99152edee6c48c9f43ef2c3db988d00d22c16a5391040c9cb30b2de4456e916fe6f99241ef05e4c04f5fb05e7d4e7f708dddf4aec40a6b925deabace7831587f870ecf62f23e0ab556a0c04797cd25028493f08a207eb369bb1b210ecd28ea7cb4eec4ccf6370af5b32b5a11f5b213659d3bf114e1481213d02bae211af9cc836067c44941ea5fa9d7e24fb653bcd98c5c2e7b5743536c423df91b43ba1f24c4a2b8a25ca49d0f202bff5835c51372c09655fa2d28103d18fc3c2a540636d13e6e22e6cc1b86db8ea81bb508dac468601159063faa8531f8dab14414644f6a10c13e46bbc02c56a71bfd7e185cb1f9e914db6ca406ab300be1a73021fb21fc424544f4960cb8a031220d26d6ffe0f726ea055d3087ac9099e5afc907f073364ce44506fb011cfec30a02c664f8b3f7d2290332bcbab2399b6cd66a2bf6a66ab42fae3ef764be585dcb805baa141193e241e1d9754c0a647f3a3d8723656ad608d6c6c2e064b3758a455404866b289a03964075417ff6cbbb1dda06787fdde912e0dfabc3ab7ec609ec802dd9eb0d5095a311f65f85c0fea080486ba121aea3134d81a3a30210792505922b7001fbf4b4ef581f858aaabc6c4d104f747eb31705d9ec3ee8d84ef679cfb44c8567824829071050e933f1d6ea930ff3465ce72f70b08aa34406fceb592e32de676b3b6d1342885b528cf7fad45796a6db8482e0b0a418b305912bc2c20e02faf18e309f20ff7f73d06c0f903d45c1b5fa3ac1296643eb9af748e5229282a727b2dc56c3dd1ce150ec93eb3f91908fb9cca6c2c9d34637632f886ab04d70e994daa9f4ce117df5a56d0890239002b2f15d0505e86eecaca4c6b37d7ed712fc7bac0b2879a2e1d272e5e69fa909558440f6ff12642a9e0deeb7cfc1d1ec6f806470ff244c2b6ba268df587606b50c43e9d2645006f0a8b2b83f0acd93095d9994f760a004b9af765d4b0e30d0c6b30aac5b6a070d3080f98fcf399d381163ad8d578f0a6b9e77d0ab673d2b212d0a1a708fc5a5c8c73a72cdf06f4e9a730412a973664359a15c31eb942ce6775fea57a0264aef20fc3fdb7772a0cf835fa2280043eb61d4e3579826774e3aec4b483cb1181e1bf4d4b2180632d93415d4d96fa933ebedd70c6de7a4ef3ef502c7fc22c12dff293916ed9dc47ed67ea5d215438ea744037ff27bf2b8d3ceb27618bf060dec8957e2459ca1a7d02d37a4a1e80ec3980db7af32d8ec6f51010d694a83e1ec2d8c297cbfe2361f437944ef8d673e36fb7eda5f1ac125ee7d81fb2db8c5b362bf63ed698e75b41505305621370f61340bd947db1e2ace39261cb6409654b1d24a4f163ca4610f2874b39b64075363698733672da8f1971a666d8c39f6566ea7c55c36f5aa5e9d85a6dd37f78b036333e8ead962a33f9b0db3d427be9b05a57f9f8efb7172571f9786b4434313e2ccad98dad2b26043a22e2ae308fc503091ae99f06be30b224a769eee8f73e6ff958bb5fc09e63c2ca289c2fb7de856627bd065952b8a90fbbe93a3e95498744118944d8c467f0bbe0e1729b34b7c0b93a159339ba86b3467089e20b533ccb137c5fd5e2291a710ac2eef05f4a909cb30967f0dc4f71dfc9b47e80cb57c2e1f72ff76ab27c848f04154aee6ad24568b060d616bfa899b2745cd372bee911279ccc9673a167dc16c1986df19335e51a8a37a78ef066f0a6a477bd312c997e8057c3bd944a0b0464250e1c25b25caed8d52cbf6a9ae5cb96b0c9c30cb697d079766fb987a052b56ae69ab1185fb99c8a03f558d6ceaf0876db8fc60ddaf4753b56722110bdd4669632e4046f30e482d0d36888b0b20d2c9edfc203c696b6695d60afbb1c4e7afe9c5cb2cb0037bdb2e49b19a321d330bf72a2fd07e65383fcc788dc0c75e66acd89e2c5e6251003af07945f4d1074d48ee190b57954960066a23403d79ee492a5105a67628a0d651f34a350a31ca6bcf7bc7b01fa89850ce97afca17a04703b2e306599f0c702e5269ccf43bd0c5ae0f5b2d6e49f53e3807270b21cab911a967f76757f2f2c175e8cf7e038fdf18951e4e875aa38fdd4340af29fc7880d93d53dc78ad92ca1c503f373bc823177f974c98b8fb56137cec0fb0413bb42c42ea50bf7974a39c0237bfdb0c28e166624fc1f36b074bd4159a5af74ffa60f469a29e7ab9e02afe970b8c8cd570feee746b32bebac2fecd1e7f0faa31e957014f16017070aee2838dc91a27fe635ec5c036d05154d566436b0470b16d897f769df0e1eab2ae1ec49eec3908323d2d98c8931d29e4dd1b7052870ff026d0c093c6e3e5b923515d835d118f63d9597801431da1e366cb10b2f95e0c2760cd070564e431703ffdd5d5f62f64c57b56e584c6d4d4f3a597fabfc4b80a91c0952f84b809c85281c42435c058b59a3cb8724a150f592106f0fc1c9515c06a3504391814c614a81304c029ba7c0222df365a7f6e1c21ab4affad6d40c3d5e003ed097d7988348c62f1e13df158b08fd841a17f9eedc7facb1164b8e899258615df1cc28f30324ff74b3a1462127d0b86aa428a9b89db3f3e58415c4d3e368f6d719dd664f0f1783969d81ba81ac8f9094191e5854035eecbae77b99685bfba34e29d5c47cac51edb958d55ca6d088690189cf77cd43c8fccf75dd45bcf29a15fa36f3514ee946d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
