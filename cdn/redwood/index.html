<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd5dc799a7d5f53c5f1803b471dad7b43759f551c62dd6397fc4101b7ad179c360743027a7c672de8f1f4fbd6d77b2f3f3cc212fcde4ea0de73b75ba4f43d8b26c8960e3ed0f59045c3391502036eb97e9eceecf2b8a2c115dce4e01c04e891bca3880307b09ada75f653a15ef4b0e11269725557222bbd0f0e02e58ee21bd60a45076cb53aa163acb82591f738a7cebe628b60b409fbf3cfeac3c255449097f5e1087352d9ff2ffa897892cde6f260fa5cae011bd4d864e6af8086d72dd0f6c9896a538cf3f75c00730358018bbb9ae222f34bb4d1893d657c7b5e0f57fbf082a18079a72ce3c776dd144695fc3a30cf05c5d69974e7b4eafedffa6ef4cc4ca9a417d7d1fb24b72714e6bf8e1d27d0b41f0c932e8e35a400b8f2391205d63bfb6a95aa972fc0a7cbb8330e620775f5ceedf0b12c39bad4fa96aa55b68516ffdb74aab0306ca25c4840227838c09ea64fb6f988e31657c673878368434ecabed19d440dbd1b114463d961fe127597f1a3c47b091e741c407de6553a7b47856d3f6ff2ba92b46dc3ca4c49af45bc387fcff616955628374bf8d0d142bd1e64ffaa9dd5697a819db4781e76369016c3603b05492249c4dcc1b718aa722b08c856296da70169894d6bc62de874e8907aacb01b333efac2be3f8a4600b64b0e486829254b42bbbf06f898fbb61ea2c430930ce1a1d7695c648a6d6bacdf96fc7cb3cb584284cf5c52f515d48ccf323df3374f82771bd03570bf732e8730202c1f1f0cd36c16a6ffa73890f684310bfb57e93fee6dfb463c22173d3572ff87b97c4987c6e2f104de26c5fdb8c40e9416c6642877e5a77e926ea331993222692ea7c2bc046aa40168b1348cdc20e22ec9a6b09e649cdc30fc37f5c477d2d918a9c8de3385bcc76eea0c541a0d3e3e5794ea7a80aedfd38dfa95385435633caa59cf8067dd5cf058fcf5601d9eda3855de4b0eae65fb15f4f7bd01d239e91df5ecad4125b6597e2205fea5126e938b3349de7ab91104c1494b770b15e0af22ce877fae45b85ac65bad3f5bde54fa48f62ff4c30c0340bad960bcc985354d0465acc04cbf2fea55d90f11b0d5cd40aec7a0879da88e7701bf92d63dc2bb942edf1144ff2866fbc7bad022748d4d68b56342e9f1efcc3392ab43902a87d340d48fc0430c54bdbd2e3de452356e3e16c2ef7d7f5024b0a5fbc19803cc0f233a1f1e3419a3951f31092dd04e4cd902c81f8127dc31f69588600a17ed4b6cf80ecaaee17023a12e00bc72d3efd4c1171fd09e06ea72b8bc9a82035dec25a932de4db276e3cac10a5fc7bace7b650133330cb9506a900f58fc9cb35603fa1d3355119c6c9593b6fe8d4bf1dc40d486dd79903beeb2168ee3b7070b40c7e8dc113adaff85a14398d910f99512ef97eabbf12be94f485ec45e4243dc919f1492976e466e342ca7b8076eabaed7f32280f7eda87cbdf70d5455e7d81f6968d0079a52d647cea54dd27e2874e30478e0de91e0798d28d23c47b6bcab4130569ea1ff5df35c881bb01cf84f25d19bcd87d8b07218226fd282151436fae97cb19b79d205105ce43c62663f311af851a938e388716dd39e821dbc0540f5cdb10a0f0b37021e2400cd9a23cccbeafe034a3c18f06ed7b14e06688f90cdad9dbc394f2705b156f77e34a34fe9f2215fa22c80069dae9bc595fa2627fcff6d8b7509a10a4967aacbf9cd54d4256533f411f5d9a2747e9733e80fd342b12137dcf8abfaff46302368925758a5d7760a534311881cabb196ac3a1de0d430bea1a7f5f6ccfec8dea79e2f10fff6a073e88cabf1b8e0acd8d4540515941414331891e918b1b35d5164b01c4b2c569f59df61bb659e9ef05d1a6445ec76d2014dae079859007668a52975f009cfcb193b9ee9b7d6b173776a213c1de8669aea4e636b8c14b745d3d658441e02471272845e4ed769cf1971ccb9b47d70adcd8a25aca24851e2264e9c1560ce9766d5d1cda1c267b120582293daef7ecc473ddc309f1a37b25b32356770876ba87496903fad86e18caddb1ed1e39a143d16d0fbd6a64d11b107289daa68db0183f33a461c503b72caa939cce0b03bf2d823f52d4533a36099547df57b4b4b5df6b4feff3ef723d81c59d87e1d628e9de941689829295fc64ffcfe719d054c03f6c0d3afedff6b317b59e20b39ff2dca9a24d4bf86c6921bfcc6f95f404a58e298c5ca16ff115034cda9d31b1313936a93771207968bf37397666fa2b14cd6f87a4a6802c1a0d03b4226c1743a9c09966f04b9a575fbf7b4007c408a27b56fb7533e9b8efbd17823feb67b96ae78bcbe30265f3acc3d1d51ba1d01ef4e6d5ae518c10a205a3f1c3bdb184afe137c89d319e989417ae55ab6c992c20560209d8afddd94a9f1319a5f2cc2744b09fbacd89eecc85df16058fb1c580f3cd0baaa27156740c70893d2f915417fb8ac4fb91f2c9b1b2b16a6953a9bd19a0b36b82bc0644ca6f8c0ae5b1e056a157f93ad1a337a828ef31749bbb4fa47070df9636b703de96c2770898ac2bde5ba71246bb286c3b55ee67d6ff3e88d40bb106118596076d4cba04b4c2c2df0d648f58219f317ef44bb232b35a72cf3e25322858b691b6fa4dfe8953800392f241a8aeb4c2a990bf4da6d8800fc65b4340668581229f66f0bebd6963f9dc17af9ec6eba2d8bc710bcb959dd4b1ee6187567bc296f4a1adfc2a3833136efc0c0102ac5e628899b321d13f5bde725b5c6b18c15c9a1a60e3e4449f96a0dacaf0223a1552c6170e03c3353e40da93cb71465e295a9b989183a6a85d5098b715f2a2d9f5bf28dd995d03ea4ec501d0ca70de241eedf21f4c7d4c53db4359dac763535122af7e4d61947412dfa69dcfa462ed37dd7951f0553ec0e476c57beba294999fbedb33b04c431c4518787a14af692c1a41ef1ccc6f4bf2120e2487ec7f7b17589c04abd0409bf1b3db0cb0c0294e35f678f9323300e4ad37fd8e105568a563c56c96ef198462ed8518d71062d8f608b15f5bc104f08767107aab471152cdcb1ff1aaa80fc7f6d12bb60b46242b20b48f74bc1eb7c9b09df6a42618582c14804a60024892f0c8dfef4c81912cad71db3042a0e405b9c653c06ced522229f65ed6c115b25ca3666ed6b1857cad525b0f2d86d77481c4ded4103ad2a9533fce302aaed29ee5c98495bf5df61dbecaaae43769abf72e3b38a79f84c2ddff2a3a00cfd1feaa5193a36f3a893d1f4568eecae14097411aac6f3504f92dd24744bb03c946011b644bc4d71ff7a3e611d1172a2b75da0e893a28bc49c63617987a42be922dee97ce8dbd759a439b86227a33a60fddfa394bc92785618fcb1e09964b67286c3529e2dafab02e16234a25e2896365fd3f3619f594c3dffba11a346557b5ed6c03d2139e98e2743a2751406a17d1999dec302d6591bb261bba150e4c66cd2e3fa863d4d1c0d5ef1bbdb53128d816effe15219f6c542020a4ee479ed97d7eece11512d3c21ca382e2f90f86469e77a73bf619dd184dd91e459f91df61f80e30c6148fa61ecc9830a595b446673d587f870b10dfbb4ed50932aa549f38456da0a0aafec9b0e2bdae5386ad1e269fced477fff372dd560f39cb7f6ff9c268b5f52dcac7678a3988c030e4cce32e839826889c969b768b9d28ad64aa7e9bb8dcdfa43950cb1014668065ee90bfbc43593f6a7aa168a264a946c752c9418d7ad62dfab122ede6a8172f6bc291937d124f3125cd7e28d65532504d2938d44306db1659852a5ccc505b4b5831431f40671826c16c1c35c7698e0160cfa973d6cc4de1ee4c11cb4b00f8ad5428f9e39b02027860019f50953231514f29c4415936f632a3499e30fbb6e8222210fce1a664c0cc916947e7cc008f3fb7039f31d11a98d62d9bf621b0a735aad47b8d5617e96cf3212b289f817941d7cd403a30471773829f80629d19c38715d6fa6a6390b4682d308bb09d3ef364faad9f4ea074d7dc027550db9c4b70c59e6f5afca82546aec73edffa23a23e8873f2f1d854cb06ad2b3e109923594d95889c9a544b6dcb28d9680c01efebca319fba8eb01fcfaeefc552b958b6d9c97010211cc79eb1c1969b11e484966b2c922cdbd17965d51bd31aedbbffd7eafe4adbb17c0e85119e84afeb9ebf4a81a8e28f1275420369d260e9a6b0dad45d2f0259891467d872c55d170956ae0b5816c18dfd596da247af8961c9c9e4a574cac2981d7396e5e563f4df00dfe0a9b86521b19909c9f051334d89b16eff79c5091960a603eec45a2ad15ba4801420e4d579e04799fbf89458a3dfe98b0852ff63f25f933879582afc837c8078b48458b9d009afcc2f10b11fd700e4dc68d93801842d01bdc8b511beac1503cf281712e0766c6234ab91bc94833f0c961856cd7c96c2467f82298e3d4dca49eb7ca365183cf700f458b0d9218f5904234996bb345f9478ac8e651534196b19aed37de94fcc0525768e83cb1fd70f7a6f9193d5c8ff5d0b3837f408e171a46a9715ff6d18968d632794b32b32610406f00eafc9839c30f9822661e39d87a8b26af8545b1ad0ac6b9e27d6be8c255383a1a9d9cb8776ff16051ab0bf8c6200dcef855804772c2df8d7e707df23d27c3cb01daf13c8a71c232cbe306f7ce04b925f90bdc85896dae5639331e49d7e7b940317a64c554fde98b98476e99e1800c40636bc17e1881c6bd1cf7fbb3505cd59dcc20d93edc5e6bb74c54cbc59ecdb7adce8b2b0e1eb967699723845d1d510bcee2534cf6f2c6834233548519a074818dffa7d053c7beb2210d46d55a2e6dddc9cc11d69cdec49fa81b3009d5046267c35fba58bc65b1b92cbf4f0f8a61434d80ee507951ca94771ebbdba1933edfde0413c7db4c3e5996ef2d9331159ad7808deb740d683deab7061bc5cb3185b4fb7be0ccd01139106fc2b4b19ef6e585b4e07f3eac9c0d00a89000c3a4c98c3c57ec4b10c2de05429fc167c81540f904faa2209301f68c7044d3bc6ccc385172f38e185fc496f460523598710ce3689243c4b92c3f4628c2a4c9f1dba8b5bc3795ab6cb1366dfa5f2a1e5c7cc354643a7bd7f464c461e06138c0f02071f7158bc0f5916a8e95286a07813ceaca99f1b083984952c6da8de5ca9341908a9ed251336adeb2d27be27fdf55180e94592ad18d08e928ec6cfa08540c4365798c5b136b31bcc67c6aaca340e382148eea31eb3599586e8927626b0fd8b37ecd4841d2b627f80a8d1fc7a3028ac41824d7ceb765413aa4d8242605481437ff08087c9364c6bec44e3ddd7d264f91fb118fb6fafb75927c37490b044c7d1848713a0b2d72f073ee0915302319138ab901939968705939d9222ffb11b9d5a2dc05c3ce33ef59421c31cfa3391b5001b92bfbef85c562488314b9c5aa6341f051c9af6769720371fbea96611e44e0f53a496aa5fccb292522c5a74ec43043a6cc0727adf9687c00dc7e7f24f3d7a742fe8026f1289f39e155410d051e0f738c097c9225a87af117548e4dec2594be58d2b9cdc9f536d8235d2f5d619cdf1556a7a7ef2ee5acd6c0a4a782772490c8c9230e9bab5a639ec083df740b331d8a14b88250317f4ac9b591037feed083d041dc1a4f99c45d1e98e26ca4b84b0455f85527928a19d70decfc834b5853f57240c54ce8d2359d093672e392ba569028306a7732c5a199c72f4235c9d0faa27d2c41744bb08a82518fd94db9a07ebaef86ac634c816cab48a1cb5bb955c309b7f1a4e94ee9261676908a7fca1bca3e75054cfef6fcaa92c3f1408fd9d2eb29bb4a45ba2fad9bb1151741512952fabd5bf209bae9329b9eb71a0885b91dd1b923d4c16d7a4a9b29036785defbf4f667459000d36daa204968a3cc294607ff62ff74885424fd793dc513c113f49318c12ecbf4576c7fedc677d2dc1c63288ec0ab8a0f0e1bfda747e34f7c93077acd1a38358935738bf3f75e953f917fdecffdd88fb7f1afdb2074182b45978e8c27cc4e20df5024a416344988ed5f1269ba3353503c853c990dcdfb4a74c74657c3d32f1d969c194914e6dd9308323c4aa4ac0a78265341316a57dbf65ed6c4ac38ddf9afd8786cfa4c1916962867de6a5349bd8f95df6923ce8972cc10af9df8f2268318e4d0480c5123a7eb10011e7c7a02ef4af16b3e64d55981f8c38634b7377f1009d289d924925005b33670aa9a5e3a6f7d909a3823b5f25d65870990afb946e85fcacc5827881d6f6d3b5fc9805b62f15e1f26cf5d0881150b9249cbda29eddea0cd5577b3daec363d608929244ad3f6fd4bdc3c67c3e5ef15eb4b028f4b886ae855d13f2e6e3be8a706490b1501a258342dfff1fb09f1e32c7ed0a7eb2de46ee3767b58f368641bc97f22e5e860ad15c3a3153d7fee98a820d03c12fbc1c8e7b69bbd4bc9a2a1864260d45e7d7dd9142f8f3475ef034ae0b03acbd155cec61ba557bf63a7861d712bd483cc19d3b78004c9466658815136e87195fb74b2b1459524570a56455e7be27fbe6a29ed00370798fbfe6d14c805da1f724298651dacc1c628e09eabb2962810e40ea6bb9d9f757ce903cf0a066bd255d4c153372b163facec924a6dc55ca8f8bfabf4c798a96673ffda7ce187914c06d43607c9379f91bd28fc98a69780e86f396e7fe94110fbfeb20039491c1e12f90c26a374a0658b892c947db46acac29e699c811b6f785ed09249c145dc036c86970ccd7ad7c410fd5080317aa47de73c298c868291d66c75b27807aee988e1e9cdfd2d61c53f737ce0c75726428c613a74e442bead88fa4f11c8d0dc363661b4ea95856698d6035a535041b3567e99d737e15c4a5d9bb4cdb756be40f7bc9b92475f971f790c3eb9cd2eada1d991a02d04517096116395209fdead95c3943eac38712f91c856fc82fee78215e0bd901e95b13724e06d5c283404903239cc1b52240e92cb3a7ce340045a11ffd171c65e83c9beb9cd698eec5f4519f87406439f88cafafdc923fa30cd18ed85350d5023df4df7a024050f90f9a4a2b8deac0b4fac73a74480dba33f10dc84ad9eba04d15abcb8cf51e6753e107e8c1ca9861d5dc1ca5ac635626f65bce94beee32aa921c1d42d5b9a7517004d4eeb84fff30d41499028ce0eee6bc5de63350d8ea9260d92710a576fd9d3b13a334d03dbaf3485b776582019a1a0f3ef4f3626043323b5e7fbf3df3373c514a5b29b752888e7545e6f8a431b94517c8a73147f4d4387a44ddc58ddae5069ab4d942d3b956ee34517a44189eceeda8fcda19168e32997636ac48b64370e48731f5fb6de699f0e35ad6fbc739ba433a806928da3824785ce22cfa9aacc5d37fc5d403265c4e7d8e6b414f714c70bc76a2f0aaa95cdbb829c1e4c625ea198cd39134bced27067d9e4e355fbddf5d61a5b7179444589547ad6d031d19733eb9648a3cbdfacaccbb55ee000eb7bef0e66b3db19bab0f0fef4fa209789c141e1d1c1afc5ca9721cbe886a404dfb33f86b5a5d5194284ad356c4f008becb3ac38e08231729ee15aa533599e4ce0214152d5a7e83a73d39b9fef48c5d576de0d6fa130f40697486f244327a7b3ebbf0e242fb9fdafee9b419f8280e40e4bd4397670b0f2235f7c47cc91de263c2a8805bdd70cf410b1459d2f9f0fdaa4d0097365f1ddc068704ec668e2cb9abf0c0d052d609c63730f2054396bf5667ac54d6dd5e84a1f2092c8a4c06958f6605e2666141ddc00cafe9e019f9be58f2f00c88492078313673a671a767c998bf3461c6155a60ea14bd53c646c018d8d080e7e4fdf9b6753cb546c383e0a16491389fb427cb3eb692243f4e9a91e07f90a3e646eabc4436891f1465586cb1d1fc6e87e002282a78c1589bf34c42057dffb072203256082e51d7b77ee7fd67903c776c9f75b79fc0fb674c1579a05429536a8664a7886aa3dbf97ed19679f56c29c0c4f219189104c1016e9f887f5709429e8d662350526e6e9b53c1a0791e3eb03fdee6500029aa171b9349df74c1b78e971dc48defd9d65cb8fa62faa62c28968aef998bafa49d32d9a4af6ba67461c0f09f007bb4d28ccb435b94198a13900cfcce2c0595f06c0633b718c969b9e4a16274b579f46497703021e60d6539397e6ebb810d06262f748ce0c853612c6ce78eb0d16eac04f052f69d3b256ec1baefc31f8de0a476e3eb348e7b88103c6cf4eb807f7fbb9f48ef99ee21481866d1bb16e90494538fbbf85879360039acab93d536a56456aaccbe7911c119deb441c5dfc44f0197e2a3aba5eec0fb2df395eff530a43ddbe2635a7d0e8be9055c30897887f28da82a6482c98acb62a4eab53bce1313e29e3a3fe8da47cee4fd8d3d20c931586a9bf358840aefca02134a84465506b1e5917384912aa68d6e2e5d901e4b289d09bcd4e6ca2695a50b0e307ae79036201098508fb47256015666c7076c3d389ac8692cf841cc5473a183e06fa90001e8f9235cf4714f7db3c54d665cd8fcab11c4759b2fc41d5a958e7ace53ca24d78c00bc1d5a18679188059fa7abf44a3422cfd5990634c2a674097aa81f288da110a2c5839db3e65283d753bb5ff787bd8b23cd070a5cafa4f51512cffcf881d23cf4ecf28ec55458d6164291f108b03e58d856ac6ceee92291e7f238ce91fde3cfa3c424c8587445fbc411515c4b6d3d284ce032c8a9b6513c01fd14383ff931629510785540cbda5ea8636014317813ed9687da360e7fe32779c550d63395ddd60d533b5b20fe65e714137c5e989fa32d32b3777953dfa475038c72ab19b19888b81b54d4050d1a592819ee8dbe9e260522cfc9d212a7bfa84f3d588e589ce14cd4ce13390027fee808a60ed454a394ebc85c3e6edd8e956634db8fdba0ba2524408c58a81bd66b678802499bdfff871c7e02d7adcedf6cb3caee825107629dc0aa94d4705f6e062c23f9c44f2a2fd3cf5cbd0003333a5b48e8fdfc99600fe7e5d912c68b5b2be3ee0ca1880aae36b3f3d66c782f14cf6a945d0c98b532231bc95c4e6a7153244d6b2d76b0912fb7235a87e36353084fc2d93dbc4a87e5f4df1718ea97c2fd167b530674b7f49860476e2e2006a717df837cccd896f5f769144ffb9ffebc9c86ccd9d1e5f16837a7e9f58b85258185f778ef96daafc9ca7d7c1f97b3df4e09f309ab9dd934c3f4570c5730cdb7b5ba42982cf7b1d49994c793e4bc9c15b4325d0dff978dadf3bbda48e28bd81ac195e58ce44152ef30c1cfec1201d7a5387e460164c57bee1b60cdca2e0afff5f5d8eb4eda71fa19ee9047c13fb3c5b03979a666a5b603216dfac3b6003028d2e103816ac39d3e0eae765fc58efc8d2cbbe48bf762b50a72adf0e25ec298db4c03d9177d4eac7c5c7966303f4a367f5fed9be71559b2cf6a1293b3a2558e46b6d37b3bc911507e40dd0ecee47445b3b2aaee0b2c85e284bb7372b66a9ae91953a5996bac50460208473b538bf0512fe87493928886e5d030b42b1307cf4799032a2af271fff8041331b8fd00006f81ab9a7740d277090a5508c51d3c574347fd2038d41b556b85eb98d3422c6fc160fdf71476cd45e4414f5cebc3d52d549c5d52cfaacedad02212e61550dce6c54e45a3a114b3304785308b16c0045ee2d2e6f8e4b1a757d22f318bd6601f4dd3c339167a5251d6b81ad04be776e49a340281bb0ca6e498e32ce29cff44c0e7c8c91a4cfc551af95ea846c4bca4cddf6231a192fd11a5ac776b3d142ad9ffc78b3886f5559b8f2de1039b47ac1799df8eaf3e9c5100280e086f0253591dd183444208a66020d6f41dabd43b0861ad2ecb6485eaf73c1fb192de0734ef1be166605cc20cabe6c1ea931195bf355d7db44af71e8afe987640346c6d20e184bb81e31aa4f26f639d8e7ac330b1d17fecab8951461f3514bce385636c3ad7075ce80d707febb28efeb7ae87acf8a7630ca305f1fd0904c66c26eb4ce6013a3e7b2b232530eedfac9f0ae22f9c9117759c7e86f23e1abf0d6c7300dfa398f91ae0630540685546ec5e18e26658a3ac5cbb78f1b33296d97909291d07480768c60ab067ad5590b47f63eb1400ace63f6ec2f62c55326b7708c74bf225b580285b9baa90359be63e32e39d3469987f2e01ac889f43d06604b690b9457ad00d84fcfedda2fbae96b6d644d6695380d68bfc655895c80e44dd051b948516fbf3dec1875e9633a26a462bf61f9b8be14bd63d36831b82324ad36c7197e4cbaa34ced3230d868cf0e2495222e0536e7394ca3dd648e8db2c39ff8fa2bb85bccd2727e975b4492cae8a5c002a4f9c94540387cbb38ddc1cde89660e3407ab1abc81f5daa664ca2995a1b57c3844ad62d00df35b946f89b2f4ed856254baf803b62d6168e388685b4d91b3e5e9829b025e0988331ab4b5f1be0e1678c4f2e55b573b779e9192fb523a079394b01802897b2ab8039a7a2b11409f90d94fd262b8b1ee969b56e70e92cab4f34e5c6a783bb131b9ccc57342e964e4a46370b0eab9c0ae17a4c30dddd6dc863cab4736ad62839df36cca3988e0f700e1352454f61f6a06442a5db32344f406386950a9e52404d63bb4b959f14ea07a54466283717ac7136ad6582c9bbf764a6c9c790aeb69ffd9ae235b0ae27251a7ec7592c7c998411ca08fbccbc537ed887b7526dc0bdc3d150b18aa634500e0a9864fa4ee014961801df7b1e53f39ecb0380fe4c3ae96bdee3b60752e3fbd39447163b7e0d6b1325bca117cf73b0893523c7860ac5d1d1e55ea20aa57720d1601af214f151bdd4a43d6f039b38633d961645359875cbd7dede2cd516d9e047528f61a57c127b22cbe217917730b11daee117d2a2d73c614bef4317a4babeae523be87bca6bae5eefa60913ca45bbf66ee52982ed0f7246105c09b9f8245e52d198ca64f842edf3588f8d62738563b88ee0821229b6a83eaaad53f5e3e02c4dac410ddfcb0b56030412697bfbfd5532330cb8e96d9e4abff979521a95f6218b1071fa198f8ef7fc45f4019a26e4f145bb209de01bcb162de684ac76ca6123ddf8bc4992302e87ebf69080c13032d37886423241169400178c1723aa1ba6b47e4d05874700a8ac1c7eaf196a52c127953ded2e6e2249b7d990152a3e43da97e6ed149e14232e8cf84bc76edfd51d8b23cb1e057830fee3efde0399af49965e6d9294b8ef9ce50a8a929c9dd1b452c052ceac3ac9fce0f2cf7a763b1f9579ab92fd18ae0a045eeacd917ec8bca11eeccfee8d2c8f7ce4cc41b73d4b45c76f14b7707e11ba1e1375fc88ec436f7465d984dd2381aeb33fa3c181b54d0318bc03906336dad0931bd2314decce77901e578e00e77029165b8afb4c598adbc45a8a2172ed28317aca5ab9d0d4fb2c1c20b2b2cf1bbd2099e74047a9ceecb0f67ddccc450eb966972c65614c0cc0ff7db892e2ded59227539a09c083e7920371705df9dde75b2e557c27c4421b6b21392fb4948ca2678e3fcb84ec9ab9f5cad62433db322a9c9d1816dc2c4ccd2dae683eda6ce89de39697e03db3cdb54b3ed9d75a0e94267b0790c2c904413df87f2e7d902612ed872ab1ee42bcf77045d10c1bf9bf3fed88d7745f07b09b8eea75720d092aea5d8a655b08b402afaf35d659386e2e328a41cf9c6c65f791871f8c137ac8c4240d3b7e0fae398c7229e425b9135dec9afd59ed66d747e37d4f5837663681c20015e0fe37e3a77ce1dec5f7bf3b1f25b48a0081b4812ea7a72152a6c0bef6025f40520b6752e17362e0c58f8c50e8ee6dde7bfb06f999bd3e3d7e4c67df4ea996160cc487b1506dcfc513b723040a1db460437495aa84bad991301fafaeccbd6109a5b8a4d83aa4007be338d19ac4360a6553a00c5821f60391a0606c41b706387275cad0d58bea1f8b783bb65cc52267d2d4c3df9608bb383a44adb5283dec1c4496f1e5ce84a6d8304ebbe9a00448d05f200b93909764165435eb1420aa7156b800b7621cdb88ddf7496b5eaf29a22717b2995058e7970a9557425e773a26e628f82e21f8f9e74ad3a02bf5ab873ceef8846fd22d939f47764a870029f1e894bfdd2f26441fe1ada392585020d7f71bc12456f4e4b911a20cd6045bf27e1a8db169faac5ffff5b7f098551213a3bd1d631e44c29a34a3de2614722579ade3eb2657e64c4f994f8c6139d016307f118198e0c939d94272749615b3a4781288c9409c6c8b92237f6a7b603a9807e3827cb4e3374fe2c19d0b66f7cab4e15591f73bb03917c4b6f70ac8dee520798a743ad3773bc2d39f1dcd7856f9996d739a83907d827b4300f62a49d1f2f3d8b208c431512fdc0f5a6551035970c05e85d88ea17e050ac40a516f8b8216288deccbf8ba82e5a3f8e7c8608e001d2151b47467429c68d0744e4be5e274ea22d6f0833b11cb0fb88d488f38d9bf805adb91dcde54ccd5c9752cbf1fbd378e69559e8955648fe7868a74cadb225ca5c1d884aa74944085fc498f4fcdf235de189462d969551063b99892dc987b40ff13232be676ab4ac137589f994b669b60ff85ce5383b25768a971e1f33637c590c7b73a486425710ad87541a67a5db4315d14dfb4897541a82833eca5846bb2a5f01fdb70230dc66b1a1741e5eb01b707d908954056c5cd71af7e54c887f6811169b4bfa487c4ddf7032084ffe128d191a7b9db8c385ff67237169d885769bf95d76e8a42371de0ef7f263c123bef20d32bc68884128434c612267d64cde8ce858c8a8cf3d5006f1df0f98a33a5a6a22e46d65a8a32ffb1a8405581312822bc2b4b3555832f13d0bdf0716f377a26e680eb2decaa7371d3b5a5cde8a15f9bc36b7cd41a61c1eb7f3a975c49a94773a133125c1eb70a4be80ae977b374e3b9601c2bc961ff67e49d5982665ec29428779acb824ebe33cfd7987325ebe4f6a79fd138dd23e6252e91a6597b004ef4ad942ccad859656f93af54f24725eb6bcce3163e17c3c7146ed7050552501fa02cf78fba6d6928c896cf165f74ed208c3171b4639f5eb029f2d57107500b0796fdc74efe2daffaea429254e65d05402a038753505b4b3a8efa878b96c45c1594bd5b3993d0667c0921ae9a79a765581d9eeb2c2a9a47cd68f7dace27c25ad18e52569658c73ea8270d43d13086000c3c379dd489dcdebe68a588df115f013ca263a52bcde60c1ce4aef7c4a7ccf894557b5d7e300ea25f3ca8e212787205e741d43516510b2eadafcc732d24382b6403ba1680b669ad5ea630f953d32cfb1ac1d57f052dd399e31f1e08618779815e61486f71117c3c8bc440f298bb4d2a514aaeaee50dab42287486bbcc26ecd4a346bed74f665bf0df642c14ffb7e50949678e0d0dcd3b25bc668e0414ae74cf960112bc54d29e97388862c81e23d273d05b07b14408a84f529717762e929e5822fde111cd88eaec8a271a8bb0f64fef5e8a265e4ecf153c5d826da0f59e4d4a6181f612ae3349d4a736833ba59fcc8438eb25ee9da93def278bf022dc21d78afc31f4ed1fdca16286bf6397d8ecb84423ab354ec3d62f23251d63c157fbf4817acdd4198295eab675dec1235246dfea181c8523a8938b4ea6ce066e086c39511415cf9c577ba07f38115ee79e3b47b41e12597a25b6d3eccc1cc794a601258db8adb19d1f4817bf2b88c377b576de7f22c63ec0fcf90739fe2decc6dcdb53af2b33bcee49b55c0c7348a675e71bf17c682dca2ae99a41d99878bccd7387bc5f1aa3b55d216960e213c209b5be4fe0fa2caaeeb3d6542ca52df1bb674cd958fa484e2877a88cd5f51c737df1eea12d89f7d5454e6d9e0da45556f15155149670e33a57d6c82487b9b8c3b8502de5fc7583ff447b193bb72131d39e233fa42e0bd8c4cb5831994ab29ce3f0faf1a4b3c6c346758afb8f7d9e70487d157278bd393b4f57cf953f8b71e75c6548bb1f6cdf3325dbdc0a249e8b2cde1d922722bd6a8323805a7405a9602e8db51c2374e37483258be63c818623a4d9edb7a8d9c76210a78485ffce6be8dd68507c31b900746d43f46e6333feaedf4dc4a97239e6966eeada53fe5cf448a2bc9b4b56a91d6bf3d932981c429f0d7705e7975af23cd5a4a8aec2389b47e8c78339d43eb1685c279e57a87af64de21ffc4ef95cec23d72815ef58432efcb5c8bc09d1ee2fbad3b3749dcea5628d9c85fb7374cd0a1b3d262fa19a3d8fcf8678c8bf669f9c17ad7e8d3d578c0e0dad277f9f55d3eb9ca68cdc40170620257ef37906ffff10af63df023aeac48d796d1cb6cf389e95d77d88d1906859d306768ba22f8ce4322952299a7485f553fa49d0306739445086e515a22d2a895c97459f0e517c3c7af1bda17cab0ca34a3b76aa0f8f203f73225354b372ff6aed81812624478e1cbb3256d0e183486815f95e9618a7617933498b7e74a192d371becd930aac6ffcaef8c80b61c5fd4b219d05c23e61dc84c9563ef2da14ca4d62b5d67936b707e6b1edf393daa8cc666f06302746c4c8181d331e2cf6b10aec9523cf58f092d3cf06dba1d5da83cfc8aab5f250c3e1534926c71fb76b7139821b96e44caa50c317e9ce6c958908a419bf07d965089b335a0a1c977a6764edd7ea57121ae609330a37fcff2e36357e0273563492cac6a8669170fb5a4fa29554108108c9e40f03f0dc9ca95f47d7547551eaca2579c71637a872ee3406e7b5a71a5dcf715a92b39e1077de881aacb306bd6a6f5bf79dc2b4fa2619a198c5197965cfb02e8009756773b1cc296030bec4747b0b206e17b268bf340a703b36889c26f4210c417ad39ee1776e61ea1269f04a1522095345728fdd52ec6dbc3f3e1e18c1510ccf7c09f4426db0a68949bbd39ba2dfd5bdd364b9c9fced40a4a784be7030d27e34fd8ff04ea1409a41342d0a2020f11ed981f90c8097582cc72dde1c439f7e3892dce7a349c0b2f813cf33b3ee6bc0f1be261e4fcb2369045d98af10a35883028d16e758d28823c67e0168031f66c81248867c8417e17b115e87c3bb243f9b92899901bf760a2f2de613d51b75a00d068b5a9a798369a2cc37824c51fb6bda3d1b43c9ed4d5217bc803ba916be5d2976881027dfbe75da9a095a3c7e21443e8d0a727fe5909f6cdb5a4245d5edd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
