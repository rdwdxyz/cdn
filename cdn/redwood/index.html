<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"248c084ab3093324716577ffb1dde9194c496e626d42d4ac0ae2fdb501ee2d1640111c3c01bf1129bb951cd35683e0a1ddbf4373ef1901a22675555b1de122fe72087e928d972fb4725803642ced1d6cbf2e27239aedf5f9d4a2f2485350961930541dfec9859c47e1a33639894616fd480bfff24ab40ecb1efaa1e1c035185aeb971dbc0639ff6ec2ff30908f36bed19933900701f46aaa66878dde2c0321f1f8397348875263498c428b97209a425f85b9ea9d1fd785c97d0ef338ef07e2d7dce36d8991a0f35a16d28e2adbeb372cfe5529786ddbaa0e8f8c987551ca2b5999b09d08cd66fe06853979bbbd155ca7664e9ecbe6687b93252e2a47ca5d8e2eb8beb18585b525b48d108fb5e30adfc8d7854d29332a855671b99f12a42b7b5d595be80a67a34b0922d9c1df5aeb1c73ec87213837b479c8cee2e9334dd08aa0dbe67742f2a1cec57e51e17866504420ce7457b5b3a3af60aef2eecb7515dc4b00cd3d9975091ea3b50c0671a3329053903a469a4a5af1a42287d45f5dfa2a776e0054c7ad7e30fd05a35d1f6751c9ba495bc68771734008d7fed8a9157fd875dc161daf117a140512730cf6a76caea5809f5a241627fd5edd60cd9c601f65987b00197858e5a218f98159a1811dc60fc211c8a1d82032cf0bec4cc15396d1ae25697a8719b2488cb38dfd8cb4f806605d217e1fba9b6bce46811b9f603b480218779a7b33762a8e866c6f2e1fd77d2494823788fdaff1eea263f0113b60952fa9bc76fa57c46516bcf77673cba7330717ad1ccac357209d74d0bbb374a367f84329bd9fd0720713051e9e934f8b0160d9b732403e6a7b809d8e2953c229f8effcac335599beaa07bd6fc56b1da6831004ad4e2a4aef06d5ebebea3e2b8fbaedb55e852c2f93ed0f46c602a329e680fe8504a6a464ec942abb91ca5c6adc86547d037ad92df8cc83563cb720ff1a65d0e0441b9f81feeff80970e2768ba466bc8ee99c5ed8432e8d77a8dcb0c1d7362137cfe8232a4d2563b52df7315d872be65b9be6569878460c57bcd3ce5c96c315bc79cacbf98698a62738825fa9c6dbd9b1540ea050aaebb199ce41b6206ea6189c2a70a32dd2280a219957bd3eec63ed46535f57ebbf6906d3a69eb1b9556cae4c9ea0dcb584498f64ed3e5ffe9831f94b118f0a4913691244b5bc906ee5a886b450784a974ea03c8264619a50257d948b2ba71dc0142f66c94576fc07cb91433ef7679f7afea9a7c308137a2d74c3ee6b6be50d8c47885f013fd9f50889d4d298e67c524748dc7bfc27a0768244cee574a43ab8f5b02795682bdbc5e45b8acf42c55c491043c71ce04325bbd19b0b919161847f6aff82014b090e79e480bf8062fec75c0a3509844fd9228b25cef65fb49c98439c1733e474e6ca9e66f0ba4f72508665179895c12c99299e824e09dc834a9ac2051cf053ac13fa380d9ef0103bb5b7cdad4295401dc1f9c83631dd3c0e5617a377aa667a0d03de68911c170d44fa54ec24fa4831b528e68acea3196313910e23e25b847ce37d36175c500ff4f743e48b25d3ecf5117538036310835d43867024ed84c48bd27fb1cce596af688c727d11f5cdae17d627a0945b647d00ded01901a1f5fe36997491d2caa6cbcb8b264d0f8d394b5df7d49ea5b5ab3d7c64798b850e035bf9587d14335afffe8ea2aa240644a276adb39383d916b2299ad5d0e2bfb4562d5c87687e8a71cbc70a9780e5aee22d5be719548ecdebc02d73432c9e056c0518341d9375431b6455a8c93368b137156f1b3bbc033fba606bc76424520831a8540c21e03181ee863f429edd7eeefeaf132699765cc1c85c9242b2c51c44993127410ef41174ff43e145bbc623379cad350ccc67ffa7dbf38858a4aa8b32d4788bc16ffdc35a27c1938e487a959f2ba423c1b39004a72bbe76156328c49fbe2d5235828a7705bc7c735e164b15b028f3c022958fa4f5342c9c1b78a6694b5fa11b50a8f7f052da155ceddb490065357c04e6fb5cf23145e964d2e7a41275588ed8b738c49d484a63c6306fc6c6ad9aa288a1dba255b572dada9270ad669b7599a7ef8b4498a5a1d1ddd88d4e5810d14c347bf8723026821e28a9d3a9ea41b9390f5448a2b3492a6d3b509ec4cce3a50e7c8ab27badbdda80cd33f2ed69aa5a81a362f007fe6fe7ca640bec61d7ab6670fe4546adf131136399bff78f72271e9004aef0af7a2b8f855eaa80b371a4530ca6c99012b14510dad3fe4a8696c4708b7647ef75dff1e2045c143f83fe4b22f6048a9ae8e744ad4d340b46d9ab90ec4d79013227c91fe4d9d7f64d47b1475d3d1f50d5d4b91640dd5a54e9ce9f1be4debbb2b2881c8adb54b6164d6b1f52658f2afa211af50e33e6918adbe9f186e5e5aa6d474406eaad39b59b676fb1a3f4ebbb6e1ff098e32dfb66ca36c7726b12df3e64142bf0c8dfa42f3fa116fc17665f9a42253de62c4af14fac4c4caf80d58a0516f12e2f7a80ad67d591a8c23a8d1116b0c46f97e1b1b2984dc7fa794956270315bf575428f6e95c83c086ad28b35ab6fd1f3fe1ef43c6e8f0ec2714b7e3c7190f07ed9acb525aad5d51d8f53e1ae13e714ff3dad44d9ca1a51c19d3861380990f6b34d357d5bed3c8937b80e9c655612133b0e8b7f28636e4830b4386bf5dc2ea6d2bf9745b0c0d45f01d1d9757e2a8579be68772c9e5fb4f2e43b43415213c6820cbe60fa5fb2d65ebf078b2b51c0630ec9add07aa4a76a149c75741ec8fe503a495b93b88ba9c9e85c75dabe992ce4ce6d472338a822d1fd35d2c49e9927e488e337ba8427508fc1aa3630bedbc14ea552fdbcfe09ccfdb80ccf259d19041a1e1d3099956cac1bf62f9d370b103c5431d5b061df2e6d4b16a4e398b2ad392851ea5f112a904916fb52ea4335b32027d59096e6f6697c82209684eb75b33cc56543b682c49d401e43c4cfdb98d1b082925624519ab4a50783eb226659aead04c92b2936dc1516654e9884f6d4438e33b6c37a946460e889bde076cea03d0d6482f460477ed0f334e1d4d96072d0a5ab5b742a8fca3e5aeaf296767e55a68cfa9c34b739fdd03f1b0685edd13ee80de43e4e96f35e813b96d5384187e386e2f8354e22b19c8cf7ed0ad02145b751accb668700cf4907cfaa0e71f34bdf9b7b4b9fb7f93ebe5003f5bdfb55e2e79a3c8537f031d6ca6ca19266f448b6ec41514140d1d0c731b64b8684caead2b52ab3ba30eef64e96224392b7d5d77daece8c1855dc287583d50f47a22879a7ea62ad79bc9b3896512d88dfdc39bb396d4f7a654fe044a5f1beadeab8e1eaffd35097952f77c2a2292016fd64a8a364aae3caeb882eb590ce58df145fcdbb509c4a7f938d24dee0acfe0be89db6415940d7d0a39db8b52da4fda4b689c3e49f2b465e7d6ea27ba58ccc4048508eba2b78459b71ed96df1f9853e491bd88bfbc6f7ae7f05de4cff33b79ee3b691a2dad365270eb1440740172fc81795028cfa45a632777ea183b15e1a46726ee85062dbffe85ae88f71a819f71485e9a4acf1307cea9d1dedb97f714e0290a54981dd66e9317ed90eac5f0b030867ba0c15b9f6fb40ac9c3602db27758e407f6e0188716991bb508c00b63c29ea40a36c495027a38e81d5638db10d5cff04cd1e8aa705b4b239e8832245d3d5164ebbef796f9da4b499eb9a7713f4a45e29d53ef6bda909bccb00b5738ace9d0e926f58811d4b6b83cb6a54f0bc8452c08e77c59f9cf7eb9a14f2d78016c943e4a5538da46eaf64e518577a804b41351c307365ce70d7a43d678a43bcd3e46316d6a011e0b93bb8c83567b5604841660f1ed44291272676949ffca4c2be6baf10ae7e817de7f201bbb8f66547e76b564180890fb98078336d4c9e1b5355b7b7920dd1ba162f1a3aa5ec5ff5fb621c5226fb7309c90842a2d78136702e61b6a437e3c00fc7a857e9a0caeef4a5558d479132b808f7c96bd55736fd85ac75cd9cbef96cd730d8b1c295b1d59d7c9e56ab294537cf4479f55e71b6fc958c05ac11e44be755c7a9c75e6fdcaab36ef430998c7661629c3e5c74181468abef01f280f1e02f084b444fc555a4a764b98b471103af128c7524ae3b802430acbd0e96eaca80610b3d247fb9738c5c70ac896db99b16acf776b8797c371ec39bcc7bea3347e1543ad404d96f751ddaca56b1a2b486da7551224efe23205329acca698f8e3a5375bd91a087a954b6f11a68d1fb7efe1d35ee7b4f7163304edaea7fd2076af40e8a88044f792094cbe1ef4c31d678e732ad71e0052e366b6a46f46f5230153c84724cc48ddf14287a19598b9b80850c4e19ffb64c3c53d4a60261b4df5997ff57b2439e07420426abe77a47b834ff7ebfc371ad9f74a0b4de4f1cbc02b21dae1537de0bf7f4cfef22b5babeb2667a5e0bf6e027396e5b87b2c6728bb69f5a4a9af01da5a32b9bf4840255da35c0eb2309ab472efd582834baea67fe0273d8c24014c4181ff1e3a5b271e8abc7bee24fdf8dee00268848c02373eaacdb315c9d092703224edf2731ab501035036471edf65b9af9830af5f1432c890afd09fdf5afb53558acb0b41bf1e7ff9c827a9ee366963b63952fb956839aed1ab74d399ca55701b062d58c755a7a09e16836303d1a1d836faf95e65c820cd4db1f2d3fe9bd06f0d2bbe7b0d8431252c28f7c21693b1bb6b041d6675ab7c1bfde8050f28d0a6d0991783a0f459d75efe261be3189c08aab2d09a1c0d7cd0c90f19f561ad08b9a2362be492fd52fdf48634bff9048a6f1bfab9aafa2d3bb055a626a5b44c0bbb4ac979a3cb7a5b0fcacee9f1aeff773f7df5b4e2fa0573de826f0b48998bccb6b407889cef1631ce2d131e1447946f330e76037e01d2005c3c988070f6c782e8ce0c2628d5e1f7f322a64cc46c35550ce0044e14582a34ca832d8e937f90c196a03fc58a3083640ae376658e169206b54a1c884115226a67e4b3f38481f2498ec506c64c36f6aac012682a456203305885effa36a54b1b7d102b21f211edb4325b8da580c86dbc1ec6c132017803e5255908a4fcf5bee74af1d69e2166bdab6525b3b8212edc1921a5145742d4d6d3e95982078a2049bf6935e7124568ad32ba504f2d87c73a9b750a12d71ac417da2cd435fa9378aacd7ed53ecc4d6cdc4db2213b173ce6cec0850b4ab354e195a9d26a59130a4a5cf95c71119011677e6bbfaf5cf953572c5567c87fe232b67d9c4c4a88e14d3f82c2152da00d1cec1d213401ea8ab6d2d5f40673693e662ff1dba08d51054d5e1093cbcd35ca827b8e0cafe2d8028f16c56a8bbc968ccb5606dce3ee0bc2deb743e7eb51876a955482653891e050c819b24377865bcb183f1ef806a848a85e23ed8971142e88331c338afeac9c6f397d2ac880b6ed8f85b2f0ef28456794bc4a79c747e9db01b9df7e02661e58c76200c4cc2fca916b9c2ab48575aee925e177813336f4fbb4519f4f19a04b9c9c2791b87aa965f99d72efa03b84486bd9fd7aef00e94831a1a77f7e7ae66b1a3ffa18c632a9c99c65a84c17e4d41f101c00d1818f7280cf041cc6789e847a54c5ce2e283ec60ede1bbcb0ba0799215a94f6fc20835a9c76a9dffc585fd3b52c709f7c12d48ef8b389dd3b605c82197222d4940aa3b9489f3367e7f568ee5d29a68ada40648d051d6e82dab9de96efd2ae89e6d18a7cf94d82f142afc2c4b93c15f3531ea52a4dd04fcd9420c3b64bad98788af4f0293df5b069f095b3accc6f982432e9851c98fbe4c9723188f104e0c2cb22a9715539c66e374e76ceed700feefffe321d188d31988f556c30854598fd826ed20bb1042ae11193c36b4a9c0224dd06f6b2c4c67c38114468f5bf71f0b537af23f988086cc2b4c45aeb0f3e5a2ed4c704aefe449867d26aa0f6daa8a0c9054c43d30f195b9b7a8bd0d918b872e7cf71515c20db35491091ac932fc87043516cf8133a519b576ec66983a23a13560fe50885df9cdac74c34ef77e7694026c015cceadedfca3c927a164c8f69e12e1264aaf39b87c755c0067a02c851d29225855d4c576318f1d7e897fb56e63d757f1b0991e319f342904dcae3dacaa091defeba4485a2a1362c62a012d03a2d7491ce7edeb3942bf07a2a14a05e63a6666e2b2f4478a15e86d231bc2889305f735b4447fd6b290616b9ae576fe352b4b31bba3d3941fc2c46cc623737568794089294dbfefdb56b7dbb6224350385deb1453dfe18b311ad42f34eba9657febf1c03136ee54d7c4c2739ba554be1cefcb72d03111f25f68d0ee4adc76a53691c1b0bf5a01aac4fb73699e9c237d698e3df66513c7161bb6f3fde6041881590503ef43df21e84eec99040927a7b98aaf60d536a121cf9c13107432246b14d9ad4c6b088b813b0b4009b16351f37f5e81be6c71b6168d4b1baa3be97dddb140ed6aba3c0757e0ed8dad8d25cdf23a694dc551f89ef9addf7630e57645a6723987ea60264871216e70b255cca2ffcb15018e726b49d3e1a84a1661c0d3f647c433218fe06f2abab286c4d8ce199626541a8153e87afe94d686ef8fe24411ffea4f5289e18b79435da8723d9805db15b365fb44ceace1219365dc0907cff7138464d2a5cc5ad8a2405d6e892920156df44a2031ac998e7cccd29771b2df696ce145a31d3457331d9863c32c4cdbf0c689c0c480e1c338d55e6aca2dd7ba891d34409c95963b3852273a4c6b4941bec52e6f524b310cc7d5a04f16a3943206ff9e8699d13e0d8fdffc24712f7e4d7bb10fe5f0433e7437dcd64d1c77c8b4a06a4eb787deda8a508cc6143fc38bc62753e7d3e9e5219c28f1d05ff13a428ac9e400c83d143643fd5b6605708937810414b2cdb521880acfa15ecc426209ac381e68ee6a288fd75d6e836a19abea1c9cf18cb3c11f63361b61a9c5200dcc2d4e38e2537eb6d1943dc861a1d098bf0cc0092897d401b7a333eff9fb0f47e2d555cec16ff3d79ef83c3c9e17e87839689c9d0cef910dbb6b960caa9f9f94af762a549a72bf48da1917c1fb753c89e99183813ab4c52471b960395567b733bd140678035b3a6d321b98b0b10ef20ada4e56104ef24291620c44eaaaa6edcfe9871aef750f57432131a5416e3554f788042147beeb8329d3329012139cd6299ad4ac53ec0a44ad925ce08fbf92e9b2500b0e9947b2910829d55529c2e52e1e79a0a6bc32578dee319ef6ea738a00b262da591685bd9a4864161f67d24378547d2278f7b7a199b124a7f8d4ee396eef5e8bee6d9918432e620059f3aa749f62aeec4b1fa7b3108fe5ff00a74d4b3f90652cb2e43dd5c7379493a8dacca2d5cfcac16478e2529aa446dc91273cda160004a15c1b908ad259fa2cc154d54bf85dc15f9415e62b43400ba0e23dca6580804dd2f193333a729f477be5f42c862079870cf9b1174a9c9eeb757e6a113f3bddfcb143e3c6ef3e15cbc8d546a2b4a8c2ad6a6dc3e4a747ef84820e43c48fe25681fc6e4892fd7ea05e159c4a4804dddd18a2f83144a745a35f789933147183f7860ac26eef4f630e44bdf6c66be40cab9d8fcc9d12e5b0e6e3c8b1fbead867803b80ca34e417e02f2f8c93db837e62665707df8db12a0da3ff8bd60613ce663276dd9698087eaa806d2cc0a8e60b53494c9a63bed15701ffb2a92abaf84fb9cf8c49355abe134e24b005b2c0e5fea6ea39067d2b61995fd7d29e02dbe5cee1899e19d25454d00cdd643879a781cf3da2cb13119fd369c908c0c04b729445b28bb91549fdb3a6285c2286cb16e29570ba728a6e7140e57612127524d968742c1befbf5488ad824ad13306a8165d9dc92f28fe6bf265e6708c2847928d0b364f3b7bdc4a66fec7295a98e9dca2d7502d58dd67b41f439561a4decad8568d90e3185f4db36acb684a602dbe3eae5cbb33fe8bae11468d2138b668fd52b91a5034780939225175f0a6298c64788a382694f348adee2fd6ba70b2cf966106ca635b28c4891b04f4d0de79accff6f0b3f23db5a9ed3a0e7ecb8e1c3093f118e1a48e4f2886efd82da72722758f8dc5e8232546855f9f92bfe0970f3d1b2b644dc2bafa182d762635eaf006ab6b2009ea3fc648e9a7ad8a7ae2a7173d220b0b5d8a511dc377b265fea95b98f0703a547d8ebe56624c42bbafcfb0ce35e79ee371edb9945edc6446d98a2c7816503049456f78ed8be6569902847b460864ba220c0d517b8b1abc4bbf24cf37861179efc527b7f15063063a1366a0498d0fcd8cb6ece6dd62f55076274d81f7c747f05664ab28bbc216bc2c0a862691dbb2fddba138201e10f9efcc245fd9ec0492b73d2ab501e2f1b366c6468bdd97b7b5f97241be2743a736ba87c91a3aa054a403b35993e05d6f4a39461998112008115def60e7bb6fddaf3291a44d4f32f1981e10d9c9c8d37abf6da7e94b4ef73708a2416bc12d8c67ac1e645558f47f8b09d482536e69d44ce9d74b4841223c97cddd40510b961b1c559e3cc74018a2639223497c2059b344c99f6ab211a39164c51f7f60c40a741689a66674a580c74c283bd42b762559a3cbda8557d95e11169ab0f12bfc26cfed994520782f161cb52060b0ace494ce2d9f709b458ac44b0a6db67f9771edd6de81a454bb9279bf6e8562859f0cbdbe90433d868700f7356cd4066d37cd110cc9914822ae004b047efa7b7f8ef843d97e964297c81f95c2b4d1a17db8123a298a591a996abb505676781e9bab6c6d819155e37369f47f73ffb44d8d7ed6cd29b749f43c8fa6eff6f83d7f48dec701699066f0961e88c2cc262e6e118271f08d2876cb7fb82ae3a36de5cb369d5c325efdfcb5d931b2ce633174a70e9b1778d12b69f074c88c63d42bc2134caa60f6557e2deedf2f5d25e89edf88322cdbcc2c6e133ce0ac9cd775460f46aaadeaad1c78fb93bf4db46a106d093f694305162a87c4cba4faf3591a7e75fc8d268f6c959e3d5233863c6acc3887a59ff3589dfaf5baf15c80f84d522897bd9da1d99a5a98b48b9cc62e37a7e9e79e95d28afd17e33d929548387f5eb5965db9057be06a7d1840ec02dc98eb2ed1abf0b9a12110cc7e0c92793cc6474fb8647b8de38da3d365ab138816106fe5802cd92cba15ebaaff27417ea00b2e03177aaa1a4f2a6c9d8c46e045f25d105f999bcede41d3221f9617c1cf74e1abf3a8e56deaa4c8269ba772fd26a7dc9675ecb0a69c76604840f9ac610b154ceba75959488e7172ca9c17428ab9e4c5c479fd90d5ae3c8171a4a4ce7bf43c334ad3175de3cafedbc11eaedfafc8fa171616500313b36fb3c418a11660de8b3a67301d2ec180849b2219004eda877ad862160982865c8a2a805e002e9a3b9f9f4c7b26c8d1e3bba96a34ec83ed0cd598b721a4cf8d7254c1ccd89955a709dd7ae6df4f66a51120399526d94e59702e1b8d2afb91289ca5dfae47f40699f7999ba0b681efcc4487bab045bf120be65b8a2b44fa4b55313dea840334062bb03f50b372ba48360b876a5e46172e835fbbaa7d07a3ecd4ef63bff905816915ba2eecbde0e0c186db7a6ec3d9b8aba2f13a1ea9fefecdee6d05f5d58db2b8400f7f7f75213122ba62a147317f3ece718d66c370d5d1e8dd8948c6aa75968a829168999b94785c8aa90e9d3c83ddeb27b715c825acf72f57f109210a0ac914c77c62be94daa26baaad9c6ec9936099eca51cf95d83ae4489146afc68d1e9fe4ffc5f82b90312b613ac25d788420aaf89215dd242aa05e40032742d94e517ef3549277b91b5b0f3e15eded16f319710ca7d79df57b3afea8fa31cc1e6065f1ce959ad64b8f607666ffffc3e911311639e88e99585a1f5659b355f19d4a8c4bc6dd79278e1420e8de25df17601d0bb61b380a6d5c69a4c4cf4962616c122c30d753e479dc5098c8a2697ae2b8e75ff39b4fa4d607a59febd89c26efecf743c803b4305fcbcea5f4cf14847b1169311078b8b9cd32ab8d19162c69f5865880a72690e9254f4526ae3b1304b4076d334354e9e15e356edce2369e9559b27ff39ef560bd1174ba43f6712c7928f3ef890fa2b65c91f5c6850a3ba834550d61c1ccaa6bd0c3842cb7e9bdb0c02454cb8cd45e4237a08759ffc3d8c891dc415b15475ec7d5f51a4fee0ba99bd9105901f20ad5845fb3111d6b25b63a7aefda3aeb79e2ea8c358aa4a4af0f156065483e46647ec60c8b5e41d6808aebb5f5f8b07ebc3ee71b43b813490d13e04114ccc23f9f17e902d7fdd13ee63e7cceb8f493b0ec4eeb26b13ae64fe366d45a51dd21ac43a6f022206afdcc1d9d6e234fbdb324ae9b483f4a42aca52b48b6dd7aed8366fa3a0a8968e5dc0f8831ddee94de4786e4bda734f1d1d05bf4b261bc60c69fcb00b301e165a0e664c4309d802b197cce2a9018b54d2d25072e75a9d628bd1153deba9820ef4829ed9c29dd0a48e786ce2fad061423fab36fe75aa5583d9ef12d2e0a5ecb6a6488a94f8c5369c1f4f5ec2c97a1446d45bcc2ac0839221c5b8efa5c9179d89c161994fb40dc016187a95b0443f7f046504c300ef7f4edc06d3f2bb9d26ad38851b09eb0a0fad01503db657bab98a2107b7f4b2eb54cf1250215a7885c3275fa1e874984fe2c15e54e09ca4c8829651eba36504b82f08f1673468e4817ede0d5d9da4349fde040bf83227cc7db63739fcc39f0ef82a7bfbf8a4bfe3d408c9447b652c8a5132c183a560a5ff33b14782bf02064d52d40ef1affb3a566bdf223f347172d99cad46cf7ff23744e49c557fbc5e16e19cefc971d54e005399c66498e6aaf220a1e2eb59881c0e6580656e4d1ee55a3dc442dd235f3997eebf5357ba7cf5e140cb8f4b958797a2010b36241fb71a27c803852fc675ee1061d4d088db4ba3dc242c76ebd36f150b249c79295b61d7ff2cef2f335d457c2458da06410857def0772149c1776ade5590266bd85d10016055222a4771c4da60b0e2b77faefdff10d4c428fd4270fe2044b5580ebef645ee84fa03d827ae7545dd319fcf120f2bbbf8300e0e0b49905fde72c4161fcc9285e1f88baf238b26139ef45bd18fe516c8106a73f05acc338f74fabd6ddbb2fde8706150c24ad08fa09ce94d8ac7439692c70cbff1161938d6483518469e55e420c49e43ac6be8f48527b40753ee4505a4a50e35b2d1098a721448222a4875f7ae51fda6c4f62c0e2a40e95c17a552c69e0f759a27bb8665141591bbffb4f4002857626ab6e9e1624e19850a74e089af60c3d1527c12cc279b19635b3f31295d1bec13eb141471cc6368e0cfc6fba27a26568295a505bd8063530c1f9af1851877cd212cc91d0ee8f0d56a4f50ddce25765eb88d7de62c176d893b06e1f880ecb19672b97ac36786c51e197195a9942632ceb3ad911c49cbae6681671c1aef7422518af67e4f7d94e5039cd2d509995bdb045f259d50279edfcc43e141dbb4e2f1465cc60d2e6bc4021c9ac4f8e1abfd940039649093bd2030f7412594f058649bf6c4aac33a461fc78e83f139f14c6a97b2ddfbeb4e8068222b6111f8b988655a399f31e4b563f7b111b2113d73ed8554bbbd995bcff339055c6fdd2c2fc97655f940b3f2403354ab3bb7f678aae5c4ac854d7b925f1238edd8cbf5f3cab95b5eb1c12e2f00124596c3a6c7f54b963562d6a88b3cf5fa3d0e915b8c66eeb84768054a21b93e875c1dc67bd11f32a9bbdbc8aa2fa276db813b531356214ad53e28a3654bdbf966db48728d484aedd20a9176b12349dbf3e7453349b0076d6f478871717ae39fdb0ece3475667155f1a38ad899b789c005649e88fd498644284e04c0a8ae265b824c8332c48c74bccb373988767546c1d7425dcef6956dd5d875633a0aee4594ee8998184d1c1f336717c99eb583ee79113dcb9ac9239f363bdb00ba81ef0d3ab2acf6e5b9c8d65259930a1a78577de9955e6c72272f667df8c4b60099a0e6e2d8e482062d08940789e9078a34503fe5137eaebc0abb5ae59e8f9373a4ce7b5bc2adfe18c3c5847ae662865ff8a446e330230e877dce05de1b18f022659f365b75fbdd44b3cec1960d7099d2860f776af49bc38afba3f7f2088a1a584dfbc824971cd2e3bf339cfb42d409839e49e64f2a26d532f82c546996e561f86b2ac337364b7a8dda9a8f66fed6413d385c089881a50953fd82b714e445f684ad34c7ebc87a43c60afc540c17c17b533717ae93f1e7543e5eff6f1e4f479f8e624ec1805f802fe7778d2e2758402f035400f8617f440fb128663ff24db909976bc427667afd72ef97a721b1e3cbaca96a82a55dd3f5203fd657be111429402c80fd1bb5bb3faccc636d910aa668ea595af840d0aef80f2d2d47771f1d01ec8e1ec5020526b2d38ad11c6b5883053cddd90ca2498bf13288752cc518f5d0dcce89936b4240d68a4b83ac938a828523f6206c3839c5a704bc5122c19c93ac730e1bb00cf198dc8e1c7b195534d934e209dcc73d16ba2308ca368838c8a8d6a8bff210e73cb5a463912fc3c1c980247b0cd8912ba22bd63bd2e62688f27c307a369b5f7c85e9ecec14838a3571b2ccba6a7bcde94cb91584273772390c95ab639e23800b181ddba9290da8d6cc0f2e63912407498cfb010014d20d452bdad7aa6fbbc2bec9e0969bbfe8837ee647d94bb4e2c8af72a956d00352d15417b9fd91246a8c12a744157bbcfac912fcf8cda8b22afb7e54812b30c6f8c37f18e8c98ab2c1b0ee0bff44b6fb8040df86d4ce5fa9c167f4a75c2a16171a00339e07454c208c418b76b1cf5639fe666eeeb6b3a32ce53fd51e325d22875a271cb02af2adc1e95d0d960f2efa582f1f227736ce11d5f53d0073e4c93c9b8e5f9d9ae2580125feaf362dee221eb6268efc50a7b76b5c3b969a5d83f6964a128950b75e588aaf627d99f41647ebd21ffb0c53e5b076349fc8b88ea1c76e0d881e4dd527ed6ba0c9df9f993079edffd921f14a1a8fc488f7738205d4147f5e9b3a36286e37d91d4b34b054a0d2c299a58cbb3a70e33d68b38493cfa64e34b3923b1c864007622f571d0e09e8e9732edee426192a64a4db577aad720ba862b01872f9533abb58a45e55b2dc03f6c9c1666f2c7cbce763192ec760f897060b112dfd5ab757fbfbc55f2bb9737703fd73f8b3527d193550fd75afe3af264d3df8becc30f05104330dd5f4785b111d8a28950d688041c4a625ae1a795e4c06003f9fca2d81644f913624b1d37c73ccd0a330463bd2ba10a278bf38782391e6bbcbcb0f73ccaf970011edf18b23a630d2cfde0ba2a0192af123d59cf676c65b6d9266e2611a3754758bc49588fc54478a83eaf7fae4d319232c872fd9bdb61830ee9e23ad3bb97945d82b5ec29aebbcb90fa65ddf404534b239476215086d666d76d0041ddf874913270247526f12f09aa7aae2ac2edd73d6e6ce4a653052536fd1d013208884c661b13b1bfb736f996a4cc7a4afe09d6f7b6bb8d6f80ed243c867c79729ade304e8da63caf8cc57efbe4ef5b3d3e3292c8156cf4661a46654246eb965702afd5542b4153462365f483efe27775d430c182057f81d5e8f15d8d7392a39298820228c3acfd56715682f4bc99dc9c8165fcc4ca39c2775eb4d9ca3d72f5fcaaca271fba8f26b5c6b91453739262852f3766f7002c9e9b81f17d5952cfc4d688ecb5da0b28d2c9ebea8a89c765bea6366c880b58abc9c7ac1cc0b60b191e6d297dd5a9daab9ddad834c73a87b92751a42afb7bb2008bf66b11974267c778b7ded9ef5eb240cd18a787f8fe7d75f17fd0b4959f5f0b5a1a04f1d9af26c8d7315d1b474481f7b7a11298d3910192770b55cb268b779bfc909e15514ebe0c7d4c6b89e10cac6365bf97d7359b724b9cbdc1bc32b57d4f2d100acdb01e58ff39a156a9c8fc882855172f8a257fd5f6eb0b214b54f940152a7948ece9ca1194d0a2e1b1bfacfe8fe083d7a7a899fb9676c9374761e936eeeb06dd1a0b9421644d0f20eee593054a8c672f4db48d2e01611284fba069e66e0f65ad7d10a00ff201d9fc241d993666407a5e1bee1b3a5f47127be25b0161eef919b02faeea286080ea33f2168440dae5a80b646c48cb188c4950ffebb627298b943090cd4aea3386f7130a3e5211d92038437ca2404e27ae0d51696b33071cb89094573ca173d260b342ee97809a48e6990f2784180a27e5cdbdb0f71619c583ca8b76e11377eded59a619111cfbfc322d6daac7ea2a6829bbcc960a65cdaec17a696c88f29a19fc92396aefe9f57bcf5b8fe7dc4dcb5264d9cdcb6941b0d3cb9cd2cff292eb2d1a9105e911d1141040f6ee5f86d35d0000c614fdf08f817bd4e00c739f766f487f21c0c58f1462a3fdb34610ad1283477f1d4536766867f9608e6f8932a1d8d3e0fc2eb24c573e4ab1114d39250c8bb32568ddf98e9d2393b3861d76164158f937ffb3f8fae617c53f47806955c3fa499ed843903d27b7b6ba6a752dd87608e95ff676f1a6fcc03c4e21854baca52b4be7174c42c6310505e23679f8b955a999317e46481efdfa5d8075fc8c2129a21089903208ed3c9a44014a7d022f93ffed7d50cfb9d53a97fc19d9b43575544528bb13e1f3cb93b7d66d9244a4e6f25f31f2ca4eb046bdde869b47c6c02125292ff4b52cd8cea4482714521a6b618fa508bd9a43f03a3ef2736fdc5ebb9d799b88fccf05ff66b79fe85382b082564be88d5b338940a5a817bf0260825d1772fe74809216054011cd2bdc0d5565817c2d92519cd759bc1fda2b2237b9411769849e8d6ac6ee78cf16113ca0f42ed1b31483bf0f68a919da61652a2c38162df4be472581a5377f3aa9acbb787411a36a3908f91c47ebc511a734f78416671954f43dea75fc25b101fcf02c5068c50172aa4d6a2a3728151335bc3b6d011bee7e4803a9848652aacab095fc0f520e8af855373e25ad1e940ed31ba11b5ce69c6c514e2625bdfaaf3bc09a8d3b288297ef2774c8fd0b7dd354ff997139315f559c8900f5fbba4510fd2532694e15cdc34d33862a83ce331ec5222de02db47e2c8286923239b4b8608811add1db1432f2d6807916adad9845489df437d5ed06043afe313f1231387d2a7ee52ed6e086c689cee20665366bc88dbcc1a04b01b60ed33c1caa42544119509ca240ab3acb811ed2ef1c8e0f2beff38bf73a1223ebf200b2de37c211b3f67ba7588c8fb31db3344f6835f8619b23a9cc4dc4ccc7bb4d37f15daa98fa60d18eadee13db80065e61f6238e258df28ea6fc1b914afa52f67323261d6f80b234585ec64d5123869825f46d1b8fd6efddf6b9d822e1288b4adef7ff2073e0d90885df97f7e0cc95aea1a203a58fc74f89270ed63bf99818c84b2c55dd4632dbb8cba79ef660c7563e8cef25977e13bfa0cee461e9288e6646548d9845fc9e27491d5d6eccfb1f51cd86105b0d19918bd29992749acb8e0ddf9a584abce94334567f95515dc99f3d6140bc9af353b437eb8b4343699079898f22fd3b1ed6c8b5fc55d18e6ace2c9025cffe8d664118f5c5beaa3bd4c4c24476024b874f92bd41718390b72e904569faa2d4ba9b4f5064139b227e3748d0f437e5fd481fb4215506e41d75787edcf457d3d2fc6365603fe1e6ad3e0bc9b5fd739d8f4c513ad12ea74f6c18e4d148d90bf6f3dd6f39e8a711d02c7a735c8778a882f0c336b2f0e2d3ecd476a02ff79afd7c7b1e622925c07f6729992f9cd0ed70e8455d430df72803bb31cb4bdefa2c6a582739d1a3b33512c82416c5945f97385f508e3042a1aac9ec904e7c217ab4a21211db9fdb16a9557083c27c837ab883f6268488cd594525f27db23dbc8ac997e2631215cb63ee2ced4a154eb088acdbbefa47a3f96ccef0b3d590cec2900ab0e2a474db0b379af7e0deea3be6870a8e715812d9d2d15e894a18706b94a918172f56afc4266270c49a4dcca780947388fe1524188c5a34536c164c8955c677ac3052a55f2a595db800b87fe7007d9270786644e8d253e11c6c7dd04255134b4a62147e50b8c5734064925cab2ad4f81fe51c4ea780bce87f5cdd80df47cba084c7a0f8deb082136ec9dcdbbead935bc91bbdf3d71029df6c51c9ae06a21e41f66e07e04c29029fea3cffc8cbfab641949b2924c741e4427c1b951b41b7c8ae161596a0924978924a40febdac0a9df5b7784fc503d0c5a7fcd5ddac4826fad2e761998618cf3d8f7bc5f2859b2e7af4947b3e88f421e499f7d62f653371a0eaf6f6bc29b6f3a352633a7eb1c1df6b96dcdfdf617c24e9174432764ad7c41fa2b6cca70b6a543b8218be002e68dc983defa6774cb85b5fed5ad320480e319329d18d444dfcfc674e669d3e327fccb8e8bc100bd56544e0c5d67d299d9d27a521cd793697d82991283a9bca67bcb15b5987f5427fabfc20f19be823fa6ae88a742b2229ab9e884a96fe034bffc95de242ca0a59b29b75929c538584c361796ab65ba66fa131baab5c618124f836a831da0288c727aca756779d4b066d724c1fcffa8c489adc1153c09f50983242dd1bd4adaf8e33067c4b6df6121165d1af9c30ed9b1121e1399a2cee26d3310f720ee9b0f9fdf15fd0dd8b95f295204a580e758477306403197c80a30c17f0850a03428ee6ff38e910d01c445e4b231ca3d1aee85603130afd440aee7f74e90beeecb8983decb740ab30acddf6716e0c2a74f2b3ffb2e91d9a166649411df904d849238e4d193912b3d1f28a25b72eceacf750aa887a42e3d876d94b9ff036b9f86633b4e5dd1865b47caa2ae457c3939fa80c34ae49729df3d8bab84c0bdb5dbc460175fb81c14177febf0303d1dacbaae3dece35a3ae8c28d5feca73258f35359dc116a36962a9094262c36e886f5b2192ea297ed4ffb3bf742fa8491e678be7e4254af9956e351e70030cf25ad5d074d93f2154584984900d1a421739c5d4ff781f640dbc94c005e407259147d935218ed7de13a434d0505bf818d1228eefec18e24ae69e6d6efa4ab2f644dbf0204e22eac17e58aacd44932651199675c782301ce4c56e07c3e1764f6beb0d5a9934d6a65151be1996efc6d3e748a29ad6e2ca05cc7512c9826d871e957beb0a4df894cb4987f967ca782b895353dcded9e53e46d419b0e6fe735bab62ea5ef1238ab409e4b254539272fe948a6b04f9159b723ea6a7b78536173e9fae3c80d5086c6ed4f8c9c5c2bde224d14223167f2349a84e12d8753460aff8e65fbb4f96e63316f2eefa639bffdeefa6393207f12d66f1c2e10f6c682c2f4015bc7de52368b07bd0ca0c28be1e176c718ef6c4eb8600cf6ac2d9fa96d05d4763b1965b55c653b19092853ac228f86d0be49cc4a263c1e0c1e302ac22b8780ab6c4c6e9fb7a056950a5ba9279315763c5df41c8094b5b52894d7117822e5ed9ba947732d63cc6bf59c5e3ed755cf9bd61a2ebe964b170639eac2c1813e39f84f3ab31d9ea52389a9a71c45bd8fe807a6cc281a1c91651480c4962943532ab8130fb953c2966f49878d7c8125d0a21cd355ff896ee2366b1811aca42fea3ccb905237f9d51b55b72f7efc27f31a2cbce4564eec3265a1196a95d8462d8e9279150e4efddec631d14c04c3b3198b26fcb4fb9925f58dd3361acdf5bcdbbee7228e989eb0352fe9a02f1a09e20cb84ae48eedb9a4d733abd8adee11c6247a3971a9321e5ddd54be92ed1b40a72c6cba729180f5ee2bc087ff31aaefc0dd5e517e760b8196422abaf3b018fbacbde8885e77dfa1dce0f16060325b25322eccd7e73a0936d812ab5deca1206957363f8224b31c899f87ee01f78d4b26ca0a19129b975e98c2f6236fa879da797f857649ff18e12b5daeda2a002e62c47ab168134e33004e07fa4733ef3c7f02c747fb60f6c7eca1e49981e935841e2b117b2991b83414423c6893f5a17b3bd9defa0574bb71aabfa8eb55f37aef0c73ade1359bce29ef3b053eb3bf418c6573fa3fa69a1ef76cb4b5a224169b5a90e7811356a399292f8633627463d4d71d6eb39db46658","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
