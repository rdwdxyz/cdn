<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"441c4c2ab10d1ac399d058a86bfea307bf9c3bca94322cdc2e274caa953da961a503963a1f395ea0ab264453be119a2132ec4998452e5f515f9f8208ba8c570b5c78ca68d9649ea92a653e301b9a25c0bd4b90f9f7240d022aeec67beeea3fcbd45feff5e5abe9fc93412cad2e1a92eb920dc5dac1c0333f379e2f50f51d9e51195747eb5a77566f515cd3707e0b1dae2ab0d4d72832ec986dba94978d2d9d0b3b55623c1c71a8ad00bf06e9634f2b3ebdac2a4b1156dc3053c8bbc634a464260cb8f10be1284904d2e08054e93a53994cb7092cb231fe93154e011d1e637df504c5c3669f591b062de5b48c60cffa51e01ead3337f0d2e967925fc4fd2ecee52095e257df9798846869c12a304397ac1e2e742705ee6351dc2996120a3e8d5211f196a8e179b3d5508ee520df57eeb0e2b0e8a0e1e63b19f6f2905e0475f90b3995c635907f1b85228e06188b6c844de6d4e5d6d24a01d34a449c6289c2029222d14e93b6e41b2e2b50140107aded3b0db1de65ec3967ff86992d14e2cda72fae8f8ce92628e79e566450bd2683a6ef00041c25f363b1dfb4d5725c4dad9bb9525821fae0b2a8cf2964186d7036f08cee5ef54809c7ed71241f6cfcf957c545766bf18ccbcef7132296215006b3d37448e3375a7ded65b9002a9756f46337cc88666814d83ec9bc4a8494d7f5968350319a3f38194a0dfa095a39fb4223a4187cf9c5cbdc9beb3718c1037853db1d84147ad0ed0ec7c611b38373e679612098dfd186bd8de08f44e526440d5b914d6f6f9918ac233ef8c3c6a33544be154afc71fd4dbed724e63f3090877d9ebd55b838b85b126b01e234c4b18e9f2702e8c08b5b86781f1c90f62201bee28f5b210cbbb92d0e23d4214359fb5251b3f776ff783fe0238e1f1afe5929e354d6c87ebd040b618fe6d31dd7d84e130264fe79ebaa6cb42314f267918c8437ba3304583dac51901c8efda0bb5e64a1f1635168ca107e31ac24cf3e7f144c0d1aca0bd19c8a95d4169a4017d65cef167c1d35570335fd0c826cfa22d9bfb9944a0862848dde39fa8742f0976377c67d5ce9d7fb44776570766ade48364d28276dfc30520c177097b2d7e8bbd3dab59274864dc991c41d83ada7d9f003fbdad20abb7b9abd9f5255389e1456e902d3dcd3adf4f6cde10febbba009e5e5eff3fba4296ea62875585c3a6a9b64bd804ac5e07229a0f09b60199f89294ad81a9943b4844b48f6c842f3353f7a9edc4bf917db298ce6c83eb87d9f5cde58a4bb1d938080879013f33cb3ace4be8e41344cc328b54ef40ad9274fe34037ae476dd654577c61f4aefe713933a5513a01bf445c1e22cb26a7ba8b2aed2c2f1df9deec0473e648721c0318d80058b4e0ee81c45a71042185c5824b3603441d8413459a4e82d7b60df37abfb16b3505bf2a4c350638ead78c7d0ba726a392cf00a0063fb810843fb9359e07bf0a5586752a4e4756b90ac600a833046076c99172ebdaa9340de3d212215367bb382c4deacb41e7a3fb9f32472a09de34e3ffddb2002524ad1f21c19834693567ddef732737698620fb9f304facd599c595795346b0ed444d415176b6a5f46f52e1a22bee0bada6c0a02dce9a7fed8450e2e524d0820a6d61b1bc82139624c5c438a1c6003fb96d0272027d0f2016e5ec6f930848d811fcfa6940e9cb2ff7ff952f424d6b529c109186b94a062e671828bbb3fcc1593d1c3d564379efb0e7691c5f69572be8f316484517b55aa252fe76a8d83328cf6bec382bc28fba63e73a0192e1f52b81aa283b6495ae4b528578d803f0bd50fa1ed3dbca04c1b665891a51c5be861a1641a17e0a9feb3fbe80f4d315b9cec6bc7b30cf4f41bcc24969086c917c3fe29af5244cafbc42bd0c41cd7d0157c4c33191b0d0d65b763e0e47b76e49900075dc284a1284449ab1fa6df09ede79c55fc31ecede885c451b033249027e52d47f6650aae32823d13dcea929fbb3bb063542c84dc9449ba5200e59d57f0967299970477b6435092f4acaaa31b6999eaf66affac35dd3f486bfa80396411ddf3521ce0e214ec2900c89ea3feae48c63cf08b7bcf8c2ef246b3084cf5e837a55218d8a1219b6ca9a147b82de5f880f83effc793456455f96e2dee9cef801c257ec4ad152324a06d9238fc6ce59039b7a62980de2d81d407636212b7f28690b8f13c0dcdf3cdb46a444ad60b0c7d3e7f045fb0f9ec165f428c9d7fd22ba07a389755b88806203341063514f075176b6e7bce829529d698085a74f4fefe66354bf7b3f2c292d55fd043e3ab5df4d2d48ce690007b1316777b13f5b99fd2484d374b559ee2cb7967018da6be6c0c3a826f8e4af55ff68b16d4814ed14641327183aa6539bc31a509290b9ba1c8a1bbd0b97610847c433f0fc1488431ee890dbd9ae9012439bfb59190e64c23c6ff5c3be94a411f62ea13731b3f2bbe36f2365a23a95ecea41c00a1fc02c377c8e221bc96396c53b1772028ac1d5e91cebdce5c06c21db5dce9cdc6ca052ae2b28c61626cbe9d3cf9033326b46c4cf3e95f5fb12e2db8400ed4acb5d8509bd2f33c45ec72275cd14215a5bdbfce87a5b5acf0a55def0caf31d40d51ad8ba1ce213085dfbc27f6206b7eedb5f737fd2ad666579d38c790a9c6f2d29ccaefa1b4c4b866ef897221d7bb3504209f73ef77d9bac04b203c314a297427c9483cdecc055f289c09f6ac35dc451f21ee386b9076f9a7eea8d6e65c4bfd2db60016630cf81898d8c3e791b038eb26dbf7a0e1521839e1e1447f1d71069e6a3df658ed11e4054d8237bd4c4ad5bb4f8a5b8dd63e38b458ab7a9753f192450a595afaf499d0b8e4ed3adbd734bb96cc81afbcb00fa9a72d490fc7597e5f39f232e73d809020b716c75e95036bc4d031a6655da9a2ace04705ae745492ab4b707791f72ffe403e861d7d69a998a14e836c2a7b12251a470aa40a4fba7378018267a33d58de45879233d995b19e3bb05ecae1bc7c1310e0a69a7c63810fab07b7b3ca3ef20eefa707ff14de7d013986a65a3962b4b7aa19b034a52e89ec831681370e608288c0d51e7323c5a5d3a3f4d3502197fe3d023fee5039f0a4b58c9d7a120b606527f1cdb30b1d7a3364d2a9260cf7f61972c9fa109137a63e41133bc5bf54df6863c6f0e4afe94a679a30532d282a02b1065d8c2f2db15c1d79891b642890349f6c03e388de55ec5387d5cbe1da26a98304c5754f9ae3315c78b5f1cb37a1e8864ed826b15f156642dbf05302dc45c791a848e6d045100e7353b070119b66b9dd5bce456189a9a7ffebb36c6fad37621c32b47d0d6520db2568e1d6f671efd8414fe961efbb9043dde9bbd1ce85c5ebfa5e125567278b32dbdd45f51b1ea30978e339bd2e338c643c89f36789704214fabeec5401ae7dc0c85656e8eb5ed7356c29dc22e4fbad434279a0632a2d74b7d64393e345afbfc99f4403063e3489ce9d3c9a13d2ded015e80ded3009ac027a967fb8aef6f81434793aa882b79ba00037199eb808addb258f3f9bafa77451dd319236ffa8608336aae2503902c4fb1e9c0ac98a3483fa4289a5b0cd49058af054bfe11e95d05d268e35112f36646675343065b9cff20ff40c6edc79f212502ceb9166b6ae0044b747f2620c4347bd8e6b78ae0a9c927e9c8a14f4aea129a5a969410b7fa322917958bc3d7e2d2ed5115c8598fcae2a9281b9391ed6ee45e7845d71bb87c7d16a17c39cf1a3fb19de471cea5ed9739319cd434375ed9d6ec622ce833c050fbef90888953454d814e06525ae0ada89bebf016ad7ddc2e43ab18f3ead13deb8410cb77df2526dfc9405c2274a65c8318b20df6111ace95769de56b23f0df1a8d0731ac9d0c6c2a2829592c440249bd1a9c87a4adb9c08b7cb206b5a16bd2a456a8f298fb5cb9cadfd3d8b117f1b441596841fe41c90ffc839508c69fd245d2fccedb08400e5f7a0bc232ce21c928f5ac3aa0f7295fe693565d2d376101a1dbfc0e837cb795d5735adbd8666fc3fe987b582e6a57d4af7a61964b8eaa82bbc3fd438094104865981274b9396a37fc4d5fbccf5abd8a57c34d4a13f7ee4c74003ad69fc302fabaaafae0dc95c3796c87478cb759405984eb7c61fa58180163788348b7514112cecbb7a3dd08926f53d21713a63bac3253fefe82069d58f69bba20210948282e55761435efba5cc081c75e4ac417431523fe1cf58337233d1eda12a73ac441bafa990ed67d2036ac662fdfd1a3dee9f3d62c60c81d1f9dcc27b31ad1fd2a2e961610c5e585b40bbd0c7a63d23ac033872c39f3c9759ffc39e977176e8271aaa2792f03b4f48f11686654f5d70b20769827333aa4a1dc75557f48d1fd08b13614f38470732f7a45494a1b347e2f8949fb4f671298cafe65a075414a08ec0d793afec51d676de5bb8e42f38220bad3b442e854f75a201a21e1915403cb1d0dc6de614be5814248f754d1b47796945d19dee61d4a6d204664998294fce7693d9de1aea90dd4c31c246e1d9178fa15d5653c26216cf1fbe4853dac47392aad41c20f834880e8cb3fd42a0072da4e20cf2d83332614dfe672928eb94df058d46baf1df73ecd321626213351f9543ff146fe234f0f6ce7e8bfd13cd97950638cb2acf45260708cd8a3c1f2fe21d5f666f97daa9ebea1aec569ec383ea22626d32b04ea48f5bec776ce4382b4bf09270e0a3c0fa63de582d09fedc512a5e2052c9e5b25cc41c087598c86eb745aa8243a51620d7b34e025c4f3acbfbe35a2c4668ce1cfdd8354c6c73588f394b0f4469b23353b56c2d71b37e36a476bdb04ed5ea882380c4f4b38ea51ed97452724a060629d179f0da7d432a6e0663352205f6a7e21cc9341c2c3b360ba8108d4f40d3140945f1da8cb7d80cd7bd5f0ca375dadd7533d6dcb179bc8ad5f2dc2ff907fd86d0c646fac34c2bfc6333d8ecfc58d75bfb73de356b716ce75b5825b8b5d0d87e4ca6721703fae7675b407a107319b94a321e2b4fe25ecc32058748184dcc939972d26babca77b89908305667014801bb0553928e94d4d0b0b7fb9dbe9d2ecf63e78f418945d2e1f4f4baf96a56961b8f66ec1d23172e6baf701b5396890ba8fa90a4939b4e076861f58fc6bca30869d57365dbfaf8a4ec057cc4f7bd13ae0f79033ba28fa2e95951fbdf63a3a57aea302aaeaed58c859f589e2e992f28f7fe71fbb0809ab2d15756911c23e3f995755dd00d0f3ea9f0a242b24f044a9915b2d7ad6d501a376ac76b8bb365ebb57b3578009b381747879353b7a46e02887d5fe3e3bca99313cd1f2f50f6253269bc91b670b0bf17522352d826ebfc013c8a9c2f5565fb161e7dd03b5226f685698667ed543dcc079819e5e432e5dac01a811b914107dfee7d4ef3fc007d4b7dc89cbf4bb92a0185c15fbc522374a10f7251fb5f64ce03e4bfca9a7db48f3678fd61d4cdcbb7e0f753b3f1dbca74068297ed56e2069f628296e73fa68dd75ed0221aa51a606ab7690a9a11af34ee53e170cc6468d4cc32f6d8e7e76fe3b7665e44d5c1a538e7611ab730ce2b5ef981c093de4002193dbffcde40227ad099f562a658fac7b6d3d61c56d7925c2b8b216a8fecf61dfec8724d6c00913a4102ae5c1ae169caa0ddfc3c54c8b13586237824b732ed06066d1d69443a8b41221d871a620536bbd7e1df717779880b7fc6925dacb427b557bb315e8938fddb02af131d238378681e445096a60db4e07ef253649732f662b25274e68a826ba89589a45f6ee18910f1e5cbb48361edc4334bc206fd13cee7ff5e2879ba8bdd70605ff88a99a8a9d0e465797866c5201420d5fefb2e213bfd207b46bbc3fb855342351b37e5efc6630b542fee97cc3970b57e9f2678b64645d5018bf550ac8765e2ef20f38f4d97bea599310b2325f988283b663a4581e169476015799bcea7b0a6977d1279e10bb206c05fd8b8f445f8c1a4d2eab8c654d3639bb8b8f8b24f9d4c2fe6f40d1ad90809e3ea86c05100f0e889da3346c708b3e06f651bbad91b3a9a1dfa2eb8451c88fa5661b0a7fc688ef4f3aa93cfe336565af1226078081e616af90a4d9f183c616d7eadc807c88bb73c4a6a4ff4699177b436925bc47f94188704631aa8fe919b0e9989376967ee7f6378ec82a7bae1c3c1309213bdd33918aa664cd7d869b0fab9badc42467cf241a6535de7e0aa18a108e8315f18e449d5c1121d47cac7c35007ce004b86d559962aa3dc34a106f44133c78fb7e42ee4e35ef9aaf81b48e084d4a5edc2d3d305871d309f0c67307ed4afef6e8739a0e308c078f5216f5cc2c4c23ac69d2fd16b3cbbba0f3ff53806687ce9cbf9a5ef6c5e14330e41d0b6fb38d88062e3977b440278b1fa1c27f7d6c908bd6798e62df0089ef31163dd5f2f6348591acf5b9a6d68099d77645a999e7695aab3022885a672142c8eeb8a9e578a166a874fc06c435c4b0dcf6b5e95d1771b0d060033bc1c8a624daaa91970f343d4d349aa2e9fdad96b282f9054ef15521517db12352267c38f62f4a3260c21e4f782af904c3d542e475178b0ad339d868828f37b6f86394872af7fbce53d4835116b4651312cadc7f2c0aca931802aa6f2758426b5967c6a1b91e702855d45d355abee859e33428e896e288091b55b2947e5c00ee2b2403aadcbfe6909e0fb481540b521979bdb303bda5f227f2c486c62f1a43ed6517172264c846f728e34642d7b7f2fb0b817fb687930f742eac65a864767d909cb2d5d96e0fc9c162eb49b7341cf22c23b86b7315b02b90028e45cbca4a5e02b5ec37e674da47bfe1dbe41793d09f1e423e68936353dd4c30e0231825946632564b15d79a58734bf56c328f67f7ba0d1498fdadd3e573cbe49ab7fb97ba1cef7c5aa98fa6af9d9fcae43d8c86e89ab6f025c05db4dc462cd1be0742b770e3c7101c99aaec9dcefbfcf569709d148c085eeef0513aa99d71f603fc132d8635db9faa837329aa4c2d84cd19f477277f5842e88904ec329236148b984a70271f40dcd4417232f94fe4383d0137850de9cbd49c3459966af39803c5b8dfe5f95f79693f919c62257a46f64d0f7dcf85e7ca490efa159edcfefe73d64fdea7dda3ace29b28c08f2d45a352928fdc41b77d1706cc84e9b2241bf9657b2b3c6c436f22923640d5e4d91512abd1939d12d7d13637765c18f56e55117072eb06d224d6246e6af9705138ea682766af4fd29334b1f710a83e01ab271fa8d5995b633d2c9a5dd43f12665a0fbb523f2f6c1644661067a8608b7cebd612e205a2201f0f7b72fa0a3de694dfc255e86a77bb1069c2cca72cd896bb1ff75523d82a32e493cd87598fc53f80dddcc7100d1731cb3fd45d4a57308843901685e9cce115ca02849cb9eb551ebc2f10155f5afc00d2b020b05af7fbdc9bbf596d9f4777c8b7afa1c520203b252e40353e527c3d82c6156cd9de0883715e7fac8073c829db839f3944849d6f6d97aadbba297ce80e31380f2cd581dc23ceccc676bfcfe078c7b4ee0caa57ac1c0765415be1fe79148a2e100c953ed18bfafaae18a84392f6860bedc1333bb280d585f8e752de64fb06d5b6fb1a958e9b1d4c325a13c3a063986b804392407f4b77be118c822c9dc8d08e36dde9f1c291e15b85062525edd391b3cf37f0c74df15387fecad40c07d39052a670ca7a9c1d7ff29774491fde6a6ed43c0dcdd1a60dc1d1606a7118ff44718cf60be1809a5513d34a3ba63a1e8aeefde52de87b4feee598dede93c709d396bb189e316a961208e9199914513344f6914de0000a528ebc3f0d04726f18363c9530a25dfdc61be86717ce1a82e93bcbfe5237d48a8bb69a4fae9076143ce2fa691860eccfed53c784c22acf7f473814c8714eeb08140abf3ea901fed4b581137e5e4c9f66f57da1e6943fdd8d3b1f1ca33c795ebac8231e0b74f6dc9f4890f1b2a224d99199e0233aa298d55ac805bd56117e879441ae1547c880f866834436a1f601ebe222f9a6c0c096470bee20148bd3ae47ff3f858f6c1edac50d0f32e8263d53f3c26f33757c09bf92bb46a6cf437677d4e0fd3e886fd5a749903ee37e588f8aa4ca6f9cf5e516421e0766cb8be56b16f416cf42d61857403deb801b2320a88e3acd09534d832768da184c81b0adcf684cfe0897a2693521afaa6db3be22f45471f1e7e8c7eb422def3e57f1f256d6b89695af3bd027fc4117b66d1cfb0af26210b0eb252cff95855a45c81ed93909c997d2df7fad1493a796ca73e7db32f5ecabe679530c70985de4e6bd1b24a6ccce838566c36a9acec92b8e6e547497cbacd5209beb41578d92dad923bec589f74a2fcb6ce92b453ea83fb6c33f5244a4956e4421380d253a6f342a768b1077d2d4755bffb60124290a16d375776b1d22735f51606cdcec973cfc8849bb24c1c91e26f8521636d995b2a3f199fc6b38b996d9b669f3fc7403dac0620946d6093014e443d60f2e9e7d6c8591c256621d53051f247a602525af2e9de0cabde8f9a253bc9a2d388e6c7875f9ed21194dcfeced0c98cd808da0a8183fd94c27828159fb1f194b9f4d088671b782459e8e268f061949839dcca3c31eba40b9282cbdcffba9100daf339df2746ca054d74190872033493f10eb66c14eff6ba4e4f8a93ac227c04dc4942e506a117029f4bb237811230036e8bb4a0c220b4f042dd9507b4d50b00b317f9144195d69048fb1b3b7c78145d6c05f83abaf12b4fe19d7b67365368578056acd8ada0ddcb0e0c2c9fe9ae9ba68087ac34ce9701d0d8a03973e48f30bc54e145401173fcb4d2f65d4e41e0d96c009b80d109376f8f79b49fbdc64d0841d9e2881d57ea4e38c88771f412840e8ada4b847158bfaa5c0782e38868f328d2ea785b532cffc0ccc01e923bfb76700f590de7aeab38e402b5f2f0bfb0ba797fd68ec36b20b226addaad8bc20408a8d9b87754dd9b80b818aa9defb384539ac8752bf189addeb06e5c21266dc3a9390a97a64f7a34dc280b234d65a771bac08f62cc84a700fa810da423e42302e193d22aea7810fb9a57f3a948dff946d04a03beb312b1cfb7c31cec78e8dd658f0411d82d3865c86866f9caded07910e6060494b2745697936ee885a47fd898fe244bd11e1c0869956ea7d7b4498e01827fe0e9783ed0f5a9eb67a25e5e16fb61717ac7f348b01b01775bc8f49f47c17407aa7f04fc1ad3e8f5be6049c03cbe51b0a44c9f8af575263c774480251b9d2b97b2782eb8c860ae2a9d92bf5ea769fb787446da8b1accc8df5c972c9ea1295ef26ae3683ae57ec6275332216dec3fce20af0d89029ef3d357c9e07b737ef24ab654030fb4033aa8a8dea6f38de13bc30e37bc3ff817312d0322fd793390d69bcc70cdbfdb52f0895196108afdc5278272ba621cdf393bd787d762e928bc433622c197f01dc1e61a522f1bd745272808e3c3318d22eaebd05688d9ace33a941852329da874c97102a99edc9f45efbaf9caa33517f1acf194afb17e2db164f0ae04eafef16595761f7d1d3173d63f271bf3bf7b8e096b40ba8720746a9d8b2168efdf98666659a94aaecca37f38c8e2dc59a6d72c3b0c5bbf394f8dc8b963e3e8c606484b11f3ccb8fc1f80b2c1992f7c1f00a1aace975880b0c08ed87b163f679fc5be74bd3403769532926a945e26db7b0d05b2263e6e9fc52a8e442568b527745fdd0a2ffe968fcaa58b9b27d39c7100a2dca8e1ca03814bdcae014d812f238ef43033133d496f51a0dd3403cd932584e83f9b47632945ba11b9b5777752aa6ed96ad7ca383f228bd19fa2587daa10cfd72c93f10f33ab44991de828d2c3ab9bcf5c73b33e0449eaea3fc30c01b3b922dae6735eef0b9ce1a2b1438b3b11f3fa2e3617711a4e55db805355548097c37abd71e704b38d53a7948d330b9cbc42ac3f6d2a6b72c139c4295d987d11ecdfc05c89daa3b662c844faf9f5a2587830da8c9797041eebbcd02061e089f4ef6f605114288c61dc6862f83275989b57dcf382bdde82105f019d8fb5f07664443fba38888ba2b39e7189ce5db4be93480aa8d8682d0a0896ac324d65fccdaa029449604e11120105036b868f69a661db14ea22541f68128d667a65495b60104a11fe1b474ae4b0e90e8cedea003823f595feb9ab1130d1089d7a11367e5a18a2df0a4bea5f991b7dc1439668fe00123e29bc56700b0e433961fc99c0ed2c0eaccf33a1106ef13195eb04fab3851edf9f680625e43bfb54fab6b7b041d9c66b9446a7a0907e21a7311c7e8730b8db0f215b7b96a1630c969c6e628286b93034c7c12d78f83f4a97ed7f74c21a399de7bfd19086968a432e488dfe69fd5674c558530df36e213c784b334f3a83df141a456d93288b45739a637163f3e74425281adabd560c290fc38ae98571da4b326102562e07f5cf9a26c11476831590428594e8e013f49320fa5da9c14bc45e7e60388c6cb0dc3149917793ccbaf11bcd1bd0c56ccd7fa7ae65cbb6a95eb1b697ffcedb3447b8dbafa6456f5b98425dbfbcf542237755ee259f7a00368360e7c88db48bebc61fe67312b964758f319a9b6b3959769fa765e99391c60f54fe0c1f5da43e6dae659c390b96fc54b1bed3360168582e9ca7df5d6c2bac42c7dfb8e2d96cc0992f2918e9b817aa882adb71c5e5ce6ae33ddfe4489c8392f6f5ee723ce4569213a420ebf928e08102a11342b0c2c0701012bd980650c10557adaa591ee05f1332e1fc86e0eb132114a55d57c51dfe7afc08dd870dbe94fc78e5bb6f9e0eb0e07a4e8c7a056a01340c07a8115f10e22755a74b332798e84c33291038801d5147a7133505dacefc6c4b528ade6fae28a3217e9aa1213b372424ec45794301b663e8181695b5c76408cb6c937aabfee69b0ededaef191c51fcdff42f5123ab1de6cbdc33901396c24af77964345dd5a94798c169488acbabb039e3ed2b78f62faced57f66e9aaee88bca999720347554fde6f8f1835af61aa09c59ec253c2424529e2758b590209bc4e35f7fdaaa3727a5f1f42a7bc35515ce9cf6576cd8c982b37760bbf6fd45ec00366ebf4c881107dacd087ff718239a4e3c3260b4b66481b425d4f39454358680c83991cba555bddbb18fab5b61f902e66d179457c2bfd518ed684dcc6d45b6bddaff9000ee18aa3392f6139b0167b68afb6a17968a1d007cdc36c62cd0c4bfdf0df4db0babbd880330dbd92c68a89c41f5348530b19dc5ade37d298670f7af9091acdf917b2f99b190a32151c9396a0c6b8c16f93c9282c8161e3efe8dc8a65335d7859978ae20b61f637fc0a242b6dcf23828136d34d3d11394f22821c49bd542768e0db02123fe32cd553f0a7837fb51775ca56a5d084e5ac7c24aee5e0f6e3e1a6fcb11858294ea2afd04d4d2f10816d52846aa9e6ee4bd3cc7259528ecedd4479fb3e37f4b3d45b5c97c34410590be071cb5eb08aa8cd010d3ab4e716b74841fe71b612e0c2b872fe4fe3175a51d813d08348e7f26b4fe95095722b9367c17ea198245dd3256414bef5209b5c4043a671240032cf91ce3c178fa0c40068141d2052c42d78e9b33a50a0303cf4be8495e5071be5283192845c82e65d5bdd8e10c625430bcfa5982f1f0d45280fb5d36ab728d1f88245a6d9dac4137f4152d31ccb44edb10b7fef1aa00ed312d8a1fcb1b89707e7947edc4efa941364f7b4c3cd13ab20f9ba938388504c1875f4b593d964665f660ba749666093d129d3a912b6fd0af29ed9b6c771741e511f2dc7d3370e1f037b86ead368815d5e7385ec5e56ca03e15099bf530eb2fe5bfe96987c3bbed97494d82fda181fa9b00484e1cde8b81bb01564c3312acf669d903d8ab05722923d7ecda1dd0a73fb2f7b87a9a8389542eb1351832b5a727c6620bfb6111fe91b62f2b9f1bdac69b96d8792596e9ed565af231a855f78e12a7e6155f47eb3eb7c1ba39ec1c2ccd2a10a04f8b3d10363d9c248b2e7d4e2fc994c0331f57b1c2e164eed8e9354a6d19978a96e9d512b00c67de3f6448689cfb301f62fe21be3b1fd5e8c297801968216ec4ef680d1077445e987ebfddbab4d37b6ae85cd3230c5f25cf2c928efc7e43b178c2366a351826b96264aa05c88d359e3f4934658364d65e38006a62776aa68f01292158490f0b624299bf7f882b06c5cbab66b620badfb0a3186c6289a8530c2303b6c9091648dbca6aa81bbd4e99641fe5f74676b71ba48d2ee14d96db93c86e81b725f11205f2a08cfedf7aebafbca8eed6b291248d46d6934754eb31d8f08921ddcade4cd180c9f11c4de3369bd9ec1187dcf4400980df8e87ee50525cc0cfe6dd12748e004a7e016de0a16f149da9125edce05a5f293ccd0ac756127623e6573b91b199b1d870e461675c503ba0a0c691f8d0b708755955dd55c3b43ebfc63a740ce5c6995dc14f3f8775ccc7d3abbdbdbaf7b7b14daf308b29190ed7724de7a7117d4f6c031c3a7960b50afac8ffe3e3c745b7870b870368c175a932cd8160644e3d0fced186bab0c000c6cea714458aed97a1b3e9acebe145d6ead3356774de569ba8e6aba2a574bd1689d47bbcf4a3af72516679d50317714d5dcc2d6261655f6ce296deaf8249d4a42ebc66d70f9c7cb12128e2de550de0c7055b03674e3c245ba332ff41beea0cd634468f07b04b616c8dd3166fdadc6bb8401a2f2aa7ecc3786457f2ef4913bf135857d0fa7c5cbfa39bb5452dd76620c86595b7da1a09e0dbde06c831d9987c779760a04c1ecf0eab4003afcba9306eca8f4d1cc1d31cdafa51dc6f9e7e1b92ad79136b8e4a8dc89dbe2058a0d7ea199ab469536de80dd7b251922afafea4585755c8460ac144a0f8e76c7ddad8c2ae65081502848ea203ef54853d665ef1fb50adf6c1b528317d2fa0b127700c1070d90a194427e5d5ac58e894701a29169a3b68d0a031c176f5862e617cd9525c5c227452ced6676b82d24ceca2a7b20e273ee0b1c5b30f894533d725a734ac8bbfa255a968fd3bb69505c9ae8577b67480b9295add56fb4264688adac7c156b2db60d0960f7310bbf1778a5d787bd7309c7ba227784ef972a5d90db210e11f519fd3f1011820bbf64d163f12f69aafd7cdf97b32c61ea72d4c980a073d482b50918fd68e31eb3c20aab88ebd74afc1cb0cee8c2d990d6580f66f8fcd248b68a4a7bae4dbe332a5778ffb766946d4c80855559bb1ddef75bee1628755dc888fe9c38d7ae33fb2feeecc8c66e78d2a70745160e3676be1ae40023e39f925911d9a22357cfc00eea8faa5231a6dd50192302168696f692b0e6b8dd86b21423c91d54761e92a1de563dddb69435484fa7b896095ff86ac138cf0fe266fda06b7adf298adaee8bde2cd2064100c936b9f2ef65c176de10335234954c5b78f2d6d42ab50d79cc71e5ea87895b845d3cd387c5e00a79b1f9440e32e5079c0a07da08b7b35cfff57b503dfdca6f89dc49a80b16e4cf717f1bcfe0db71e4f272a52ed0abaa0508d7f7a557af16fc2263519bcfbb603f835f834d49789f197c100d85254efbe3f30bd02ade1eb7745222a996f408ae776c977fc465646508bc415511394bcd93ba1c347538253ed979697294c3e9d5f81b0acf0fcb4b4f1ad122aae1a718fac7da20456709729fdc993a65396f6cf26ab33fab77750e42b5844dbfbd7951fd081d523f2f20de4da3eea91d4416ec97b135b0ff9a2d843a7c1fb7a8ed08d55e923ebf1cfceb46fc176a8d960361528281e1cdb5cfe7fa706b5f4d3e6b6925ea60629975a480413000ed23cec4f5b7bc211928b8baaf0a8a4127652c289e7ba85bc9a07701da76957a0b1a7bb0a96255edcbd525eb0e9dbf668a5a38771c235a9e8bf4070b4ec39d27d564290807e63567d570a07bfd9831b20911a827a3de05f29d9f51c92b982e99bb74e878eb3fd7476bb29fae83fa67fb6e44a19e9a52ed13b33db47f79e4ed7c051af362586a989f44af5e1766a46e4e35eabf7ee9c89968b95f396cd41e31651a87e76f053e8b3fee8d5c5985e05ecfa8bb2ed5f5c81143616b57e1e021555298babcf6359ecdf642ff4e08bb2220815c6ed0ccb38a13e43eec3dd04061400dd7823d7050cd0d84b30445d1e7028965cfa77a7379e4c9eb040312badb77d0b4956aa99a3b5cabb358a6f373172658e5f24bccbf1b642afbf35784dca6caebe11b093a69f628900cc7f5f3c64d220c544e5508164d2624523ddfb5e6ac034877be956ba0d21c35ef9f3d2ad4d90da71b3904638e8ac5b9825f9479c50797e42e57ea77e1bcdd1fc080a8b115259b5a87f8fca96a554a53ca64bbe6c71f5629172ca913d2ceef4be228f63ecc7b7446eeb8dfa87a2693b00d7cafa28cdaaaa773908614230ccd27602d8cf92d27c34ca374e9b39bbf95b89667d0b679d155ca1c19e379f797c2a014a1cde76661175976060482e0bb831625f357c1f98132a6c20cf772f2963a6b3ef438f54b3877c7385169ab804861a8cd99e450efe779b40ef4617aeb4fd67630a166bd773b7798f918164b19b6d6ee369bd9b5c21c11e8628b73f790de69b7ec61dcde9b2cd70e1cad07f2fd788f82b7a5c8489d2584863f3ded9d94f58dd94ecb5e83018b1adecaf09e7c87a44a736a47d6b96b9a924cee0238d4840f2607bdd3d182373f5347ea62d5528cbb4862c6a109db256867c196595303a31e614a6784c2e5c9dc7b02808996509bf7977b3c0909e8a73bf1d6b38258361b5498a8b211669fb60874feab6844543ceeb2ac1caa32b6affdc41c0230e5e7d92329815009b1922aaa4408432738c7127aac5b306a415bc01202195e8f165a00f5d588c5d344996840fc4db2e1f2b72dacedb09f9ac2b18c84a1fd4f0bd6e19c7d27da6ec695dcc9a6ce5f520195edf59eccd3d16a727d1cac9e475f4068d4e53a40b8590007103bdc2a464257e309aac0f2d3a343dabe8517c43f52b54dd7874830a3e8096204fc24e2977402de3c7f9ac0c5128a6960202bd76c2f3d4de74497dea4cfc1ea272c0e0ad21da36d3705c114754b539236d64389594b6a947cb6368de1db599bbbb694eed478bf730eacc3b57721f6a8c2ee104a2ab55a4c6d740ca9ff4e6cb09947c53d63b7d5cf8c037dd324e865b8424ba49993dca37412f3e8d64807c010fd3af88c78bdfbeb35db1cb76744b366fc2368d2cb0e41b38c40bb118bb35865607399d16c8468b490333be7d2685893ef1f567342cc46f4716b909526b203db625d88eefebc95bba904e496c2c52e9194a357bd92ee74e40f660caee55a75399ce82a792fbfe4d8ec4decbf0e8e162b94a46bfa61965efad74845ed818f3c07e8495cd68f036d4afb1b05f35c4855b477e6cade72a8b8a9450d3432834e2940cb9f97ae4cc2ea47271350db10d6783f4edf142a826d1ca32ac0e033ea2364e98d288ed68b77867a3d6e4552bc88d1497618a759e0534f1ce7f827f4e494062e7fa26752c6a3bfdd56efbd5d5aa25bce273aef420a5fe0aea10f75f7f4f8a9b46e39616b5a1aa4e45c2750828b218f28b645f6e0dd78fcf1f969d40c6c9e09cc6138f8b17579206e7c5310e0abe6d88508a7403eda27de2036a9ae122bc8369e60bb321c2f492d2194a07a3ea102bf8a48f0a1ef0d54d825100e88f3a4afc5b1ee6a2b59ca976ef7653d5ba98f55a8352a3aae3764f6069021a022efb079ff1882aea4298f1ae42056de69ccd9f056f1fb505d85c2669372bb6a1c428f1f3f50dedad261905e292037ec004994f94711fca90d64a44761f0dd1198251ffc64163fdabc5df4b44e86c12c5eba4f1c207499aa15b5bbfa9c6f57f346bebe1b6a13697275bea9368193bb7171a0c818d14bfc1b15c1655a7f959139f47ec3cbb982df0fec24af1f6083b2ba9878b46cc5af18d558723ff1894289f00931666c08ae9049517a28b7541e24bbd8152550480d3525a9751511a2b68249be625ac20ab330fae911e8ca7942327da3d9f4669dca29ac6084586a9d80a5bf7c73a8411058acfa08b8f9771b50827c74350f2f39b90badcb4f53e14ab661edae5646a807866f79500c5a39a6647855edf42b8513428455677252885d0c8a4b61dcdbccf29553f76bac2bb808fe007579dafb3db13c24251cbdf15e9cfe2d10c61193b2159e7440e086ff1dfb914fa6ccb47cb6840b2120ddb0a7278c03a5449ec5d02b5cb7ceec08e7197d5fe698d3c773e2e1af7d571cf7586190b3a4cee3d89163b998e574d458a53d32f95b9afdc0473225d0966ab543edd829dc097d57db8774d6ed43c3a06c82439f6fc99a129cffed490fd2d24f94bdb94d20989b15751cbacf95e64208f289a3805871ef70ce7847250de989ebc3fe58ba8772126fb80459848e9b83b70c777a55fb14ebfeab34fd114b0aab29264fdc95e47527bd0c3231c390d7454a740e888207e9852901b8b1bc79d619a755b0e26a9ec7d289084636442acabc7672e5e4d0b9c4da4a41f394b52084af8ddab76a09ec5e68ce3b0ce678688695e8e5cec63b281a2d62061bb185eb155bd355ecd8f7c7ba566495da8eb118a09d381604faa213f5f37ac1c3ae70ee0e4e8910787eb0431c0bd75c33a892ad7ccefa371a8a960680c1d0d65f6507078d60db966110a5360ec856790dfe228802224d575fc53c92c34e50ff9721075027c86554c59c9957189f1b1fa6b41c4971367f6c9a0debc09773ab2e6971ace5e741c3e1da02e1186658348b73ec93d5ed6209b1b2487bb81ff3f677f973de7fcfe5c0271b4ce48849aeceb25664da36bcda77c85f25b7f1c22011706eb9502eb021d8b83ca68b31aebe1289d9f85c6d97cec1ea6ee9f09a8e571c4a8dada02923f21ea9c869c52bb5a650503c68c321aa9b3e44a4ccb31c81fe3f1409fce04db7f0eb6d0ae57df4736609296b98f1e179bad20d220a95c6fe4dcc2aa020d41f4698414f865311738be63e5f26a38c3f315f5fcefa5f214445e959fc9669ae67206a66e0ccd81bc03ab2fd94c3b2bbfbf00f4b4fcb49168cb4d1e9cd3c575a8ffda17e1a016cb4e35c37862484536e96e9daa3235ab900a98268493023a75067c838cafe29acb65a1af479fa4d590b22fa6305ce9702d22da3841b946f59887a60431afb4a8dd0b5e1643093ab58f595d77fd53d754540cacf5068902baa0e1427be7f1e128695d1be0d7eec825030cf8a4461a0b67c41435bae0085072b60ebe668d8c06f26eba0126f8311fb66d64bef6623b0bcf57bbd4aa29d7357ccee081feafbbafcd6d37c7d94f0e46d6f9566aedfa6b1e9861bb3edc166b1b5c0bb44a2544b9c0bb2dcd43cddbe3fc0084f476e96f0d0c8ada8ec8c4cf9c1346459c1083d60e948ccc6610262e942af99eb96d40e9d673da82bcd6440dabb65f6cfce05cb19952dade774870a220e53ce7afd49d310a1dab77dda8c3cf59b4fdb47a13575038a88a4f54b0f8d98c7edb26ba187ca3dd1e84c2cab0d82229d200a3753a0b8e00b8a43af79db0b012406bec38e9a6ad54bfab40da88dfbf4aa7d1d1f6a98f4846942d12add9571df992d301e51058abea42531697059dcb4807dc52175df89682ca210191b83b81be62ec0cd5fc711b483a27e72f3b5354905044e5722ed0e21956d085b74626968d01d0252704f7395c593451452fd0b84db1b6349a09b46af553f59dc3831caee600372c9b41e69cd5d8bfdfd412f03d5ee0c767387545de0db28d1095019d7558e2b91ac0fc057b01cad4ec1d62bfe02149e91deaac7bc18a743dce7d9d99b9fce14b4e8dda597349033df521b69f2db560577030d1ecce09c278da72b635b712c0a813fc94e51ddd3b3af0c1672281733040518cff0650fddffed93b442f2daa9e497fc9495da8545719fcda38386c1e9b708f58850bc6fe907a1026a98eba7d6c573f07ef342a2083bc44d18138a24bd9ac78cd274fc4cf1cb17840d7f4755da1ff14a57da9ac65769b62ce618d8c7b3d5638e2aa869fc2663ceec0f1d33d4f75f431026771a67f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
