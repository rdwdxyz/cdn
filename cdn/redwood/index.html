<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b99016befde37d28cb7099a6290ddcbd0352de67a7ccfd0e267fd1c7b37d8dc7d9df9890ece98ea791981d70f15b24b269ab0baf07cbb19a87876bc2d3e5111fb2b2b0de305829aa2dd6542f0589ba5a061bee5459de52a24fbbc5b447bb341aa8462d641bf43849ef47255c509f711e5e67414a3daff42d0a98e7c726dae7e86df9f52c6859fe17292609d54b3b3d2e6b64506ee3c8c2bfa7cadee7639116a78b1b76ed4859b718e2ad2bbefe49609f88fc585a939bbef7119eba146425852f85544f0a3e24bedc2183ed4440ef259304cf1a3d1769cc4f5eea8d3baeb8d503d24de2b997b0a230bcaa3df1a6f378d6d0bfbefabf0ffe6048de77cbdf7078539faf959f7fbcfa9af7a95bca5568c4635be34a47f9d108446a4aa22c448b3ff21e82b7be84414d10cc71f2b42e1895e04d793d73c5325d9361512131a771ddb5da548358906fe70407e2bfa91112e816e9840402e67a9ff1fff7a424d872707df9f2dbeaa1ce5ec7b2ff64880543236e9747e30c06ce8bb145cb00ad572a47b410bbb3b734f9d7bc28b2203e4b2397c031d3bd082614c7565b9a2aff463c9c5aa87d8eac30220f4984e923acf6085560aafdd75da85277a22ac4f587a50668dfe44a5919b008f950197650b02b4b9344fe1bd9f55fd63bfee1ee235c82478dd5ca18be0ae0dbd4a84d69b7b990418ed4fac626ad2877e66d6b8e20012137dd64c9c14c43e0f657ada1387f5554d9889c1a4daf237ee20cbf0d32828234aae7c03d69523753d4f4c66c2db7c8dbca2c292e62c5bb60c25fa0693cfbd8375511712f7d1d3922f0391f1392417b9e82b587e953e9f61c72ee1e9d70100652e9d779dcd7c9419e82e8ece5bd6f09070feb7439dc88ecc112a461c06b5daf4655561937d85a8fb221ab8dad99f76883431d2897c1786f40d74868fd9327113de01e7330b0eef70bb7f997ab53314e98bf2715754788b86d083ec3b03677aef1d4a5af8ba7c2b846dff2a6de956e0fd8534573362db2cd938063ac0d523f38e24d6c0922cef9f04776687bf2c6b2d64e9875642109b360bee612645686ce7c734e471a7a812d2268efcc800b661c9388d36755fc3386581eae5376fa86e01c99d284130678a25083498e4e33ec098e0fb9240d69303fbb8ec6dffafbf2984ebca34efdb39286548081dba862dadb2bcddd5f7c94612b60bdf0304534d11357bf0e494be45d8d394e0892f52bd2b2ae8fb49521d8f440528863db0028b5067e3d355ae2276412393a257604f8d121c672b6282e8e341d61a212d3ce20ffff07b6c10e58e31c140351329c59cd3b7e0a66bbe4303d5cc93adc6c93d4bb164c51f3946790811afa5eb696e1bcf1cbe801676d17c1e68e5cebd15d232ea78fdd5c84837740094600c669953494005cfae77f1b254a789e54d1b4c299601220a2f1bb53ea1b2e41c215731fc59e0ec272d00788b2b43692142c177fa27a654fac8f7d5609e4fea72093f386ee934fd1f74e426f7139bb7fb0de893542b41c06e4382652e3a042ccf7b4ce539ae450508f3d9832c506149b8e4d5f22b782ada6ed8faa4964480e4baaa9bd87c5ae6012110337ec2d2f694736a66ae0f99582c74811fae5f49400a315b501d26fdd5ae46e996d2be3bd36c23082973f06e764da3f1a41d349438b55bd252788475bf4fefc8c6babb579adfb4752d26288e6ef34e589367819973ef6e9b1641d88898fa96c613a3ca8908e79cebd75075707fdd5995c5d1a0d5fdf21a2f20d961afad47317af12ae84186854d2371c91298dce0217c52553d3c3c5d3b2c7e3673cb7582a78dc519a40c630ca752a813636574e1b17d243eed75d20e9af2742e14e3d9853913396fb3498d6cf2bfe5e81b0b39d464df050da42e65e7d8bd7ab10a4c4e4745d0db9b0ab3fc82f31e4c562d725d48ad77ee569759e66d430f02b3e01c743b7c30312ca885e83d330b4bd944602f1e9e1997be94bfd0260a241b5f6bb8f78fbe34d8839b3a050d97a83e00a28aa19ffc56767d04f270996261f7a69264b7f503f64de1699da4fea6feab4dd2adcec52827dfa12c533dd063a69f7026c2a9bb922035b1bd4963b29362cfbbc9dcbef8a0ec3a6daeb6c39d57eb8e41d4faaf5cab090a0c9fccba6293baf883d049d0e31793c875dfefc0f45ea047e39a459c840f306b734a6390e895e83218a186a5d096d4c8c87d61da615544421f73a806e574b35caa7c7ec5bd0f57f3c145f39ab0026ee2ec34b7474c593d26ec6119812e943dd2e4f6cc021bfbe6616bd04d9dccdf861db4352963cf7b3fc21272e040c7f3334807005b10254c9592640eeafcba799296f735079fe23b7b4d93cead56c01871c32c6fb3896320d2cf31219ada6e4dccd0a3fb34f1288cbba6660f7c9bd77303df4125c15b8cdc670fb064ae0b373cf322b055e872113d7c5414e9afe1dbfe9189f03766f41642fb139d122a6b0d1c9bf9fa034178a6a9c50c6ed31c08080fa9e2e9af00a0f67b59545ed9647dff6e357600275032bc06193b773b979672cfd6fbfbf040420e1e76e459ea65cf28e58e6a591699f8258438d89311954041a171cd766c77928adaffbf270de92c7d8651ee8cdeb0aab4b7cad557c5b071331912bb8bb4e12851c8503dea4df6650812094c5cd13db8c20c9b8794fb583e36b3ca030ac461e8b4bc9f76150100be9ff7815ff52a24889d2042341b0848f1c24859771331cc4d2f0dcb289b49e519d21d2ab8479b77c2c7b34b65a278ccf1162844e6f55d8596ac45a4d678def1120ac3b66d1c2b24be1b58f40ae4ed1097e1b58903b3fb49cbd75e5e6c4c1d7a785495197e8468a2b83fccb504bc6d498a7f861c4481ba739256f6173a4d96813100868194a5558ef21c3cf5592d61e7ef872ffc32b0a8fa4637ce615e655e17239e60fb4ac4460b1ac4f17b69ddd93cb6d5132a56727481780792871e93c5bb3c01248b005f7f2cbce83a8cebd494f19e16d6986aa77bb8d5a5dfd6ed44bbde7010709c8f3756addf1c013877cb45626f0d2f5b500398f73db20e1c2a45eb7ab985add1de77145838ee4573a2c94a4d09995953bc86b695710961d5c145e1df9102aac1a0d9224701e138fcb09d6481b21fa6b56db2a78e34c19e3f64508216cc180b7ed05fed182e8686e58314d23070c533995eb3705edaadcae978f5e07c4a4002eb23e0ce1154a88c83dc6e2f7716a3f53b53c5ffd8c0cd630cf2a6da2dc4b3a2f85197f775fc9f134d77fd7e68c06bda93158ecb53abe03c1d12b38e5288bc9fa4dd94c384844ab1ca7d6b293fd114de651a097affa58a7068385fb1ceef9fa82e87e893ac4c79cf2f6357e1cff3b8a354bba1ea66f999330a693b63cea2964f4a6bfde716d9b1ef5adbd1a724077260fc83d2f7edd45a92874035eb8860703de1159600246471a87784a8b5f1a2aa6bb00d16e53235ac04e98317b6a2d41b24821c0552a3a15ee763d1d9c0501ff97c478a4a43019c80f21d76e3cf4a29fa011beb514e6ccbbd07f7b166e71754f1d8cabb9b61b13df11a923124683d6cf2f5ecbda7ee3c7da753396cc6c03ca4f9e0342bc65a6e648dee58506f47f817facfced59525a6d51a54de2adcba830ed8d103c3e7f65a2b6a2399dbdb8ddc9382099b10ae4e2b609c116c60423651539db7323904fb7b05d8fd1d1f9d072e99b395d484c138e822df7ef5f8434d251f46842e3f72f8b20473314607bd2737653ad8c918ccee5d79a5e8adb8228a7d13931f74e258917d8be3528bbef2ba1388e11f41e17ce2ffefc6f9627bc8cf2a2237f871e450e55b1b7cc3967342e10b0a9bfc1b1b2a510c015fbd46b69aa6c3823fae79aac514ba978b080fcca4f3a95a971cfb6240d48a48322af8c35e35894214e970284f4fea8eec8364b43cac87081b7e75c3e630a20d1ed24c934ee569c0393df7b5498a835705062f8c7ae7f208419deb8d4fdf9cb0b97d5093d352513934e54c33e45e64bcd5c27f0d7e16a900505730370e9575b9e9e628007410d97e7498b5a37a331dcc19a1c61895cefef8ae19fe42fe767276d6f9c530a108b8f6317536ba0866108471cb7c5a8bf949ff969bfc1e632d22784eb9e50eef934da8ec75824375a20982b50f1827d9fb543bffc7a9705c88af6c4bf8981d1ecd44ab702627da90f0b77c424dc7c0a12bf5b8e2a8c50b9bff8d4401a513000b5f7c415c0555f256ce68110e3f99fdc4e8f805b4fbe32094ee55a285a7638a132f10cd524e28fef3beecd6bdd58dbcc0fab2459dfbd91f8108ca352be36d97932fef86160b3ddd5f88565a4eaaad5c49444f7131f6b70c2c09ddfc66e51508f6c17135197361b2b6fccfd2d296976097cd795aec797e0031f503a53135de165cc40446b66c09ac5e9ee1ce4646a022fb44215d2266908322d04390a1b31d7c63426f9fd8aec5ccfd368a1bc52b3928657e8dbf57aed0ade22612d9344617a64dac5f94112d0650b40e3f4635adfcfc7b36e4eb5a15c3186856d3c3aa7b8101b09d68911a1ccfd8a1827d22f23e40363031109ee80bb68bb7aa5fd17ba1248068f03a394996e1158fdf068dc0294414ed9c88935179b742df84391077cacd8889742cb5464ac1564c0bb7adca633c04169660f878657309f5d17393ec3e675f5b434c640b565d273319fe218e269d1ae8856f8137a714ecba213fd415562443ef7c915c51a4c93776ba0216d22cfca6b28aab53fe98115152e475b6643917852820bcdc88b050adbf94de5ce1d09909c56e0202405b77ebacd71ce10685eba686a1524d9fd8ecc86e73ccf39c4c8c014bb0b27a8d6cedd9dfeebe0835434a9539bed66339d83f24a382d233ef4868f034b60cda1929a7c35631098ca2d5f22ae0dd603211e21d719b4f0bce3bcb643fe4cc6e2bff5da8e6e5946f2ce5cd076833609244cbf418f201ff89d5c55152cc037c177710d7eb9191adbf4cdf3f3d3d1300644754352e75bd2442fd485040bcff10d70e23166ce297edeab14d60c5c0c50e2d90fb681ae0c797b98b1d279aaede3024b8f356ff030e6f1533a8cc91e5ed0e9e137b47e343ebe19e2a1315f489f76df990491ecc32c31ef5eda04105ee3606f7e3540120aa89f7ad7a59f86505bfa9e734b06b43d1684e6e815b6943afc9fc26dec1677b218bdc400a67f5a6f4b28b79ec0601f727dea433689f657d2e682f8b6cd793ebbbade653c963c749afb535d8ab11c5024d58228143440894a2ce187b581b5a7ce22bf8f4bd0dfab7edd09a41c5e3f899575a902e1d91f7e5d5bc397ad5a6994b2de274364ca6ef83d698384c930ae8245c1d033abff92e9273f4324c46c99c0c8a52069cbe626e6beff79c966032f77797f98f6d2ffe918f405067cd21dbeb502a94dc222265f5e2542a084c7a90d5af9fe791a42235657778242de961f3bebeea08a2785c982a77123e74d03ad7435e9a9998e85428d239ca07a48a5bb9e412cec6b86c4158948c7bb97be18b12b2057e4da31e77115f13ce929308706391933cf09d14b402fcaa99d9f70d224ab65dc7a6ec1bf55a7a017ed92cb96bf2100aad7b34d6db2269e95a4b041ed09aebb5ff2b46176131074f50c4e45e7aa78ef86d2f6df55ab535cd8129fab5a96c607c2ea65c724dae8197b389c1d0bc6c438436e679e32363d8f50b95dfc8b6dd3e1d10b8d8225804840c0473f6f4e0928052422b42aed4ba6e0c1ef470b94502cbde1140a8e7c8ce077f0c6dfb21349002bf7a76be3b8647ab97102f5398e8388f1ee84e0801a6f6640209f9d65db451a224e841af749e84f641e1d9395909258162ace26537af0f28b746b44eae09384683978c5631405ed164ce84065498875f013e906bf71bd191c53753d737f08a10c2cd138e7338531cbd0bc609ee5042fe07f1bbb2ab85c3e0e6f0133687c22af2b81188b49209105af905bccb971d35c87937c284e0c066e5db00cdb07339c1dec6c5d9b6de9929d7d837d1fb2a1a5637ea3a5dab483dc689f04fc02e89d9d435585699363e6d0bdbf4e9ca9b2950b13bb1fd2ab9ef7487676b492d3869b26de7039e588630b35e84f08a46384556c7651dc7751980e5156c5cdc7e6ed3098e8b5636f8d148fee4657c91b329bcbf69b78bde3f1fc028f3b2e0752c6c77a1d353e3480c94d7baac35c7a187f43f9d77e447d7836b0ea2bbb93f16a1b80a723662558818fd2fedc5da14456a7a95ffe991aa724cad7c5f4457c586730fd6f86a1647ddf8622decbb5eb82f3e7df07fc8b4c4859de1c9968fb07839df37ea597cc7e4c59e33e92b9f1dca268596ffc6a45c51ed507956e49294e0de8cfb53c7b55556672c2d4c1054e8c1461463fa7d641015763a02d50e5cf6777750f40668a75c75ec6262929cbaf9f0fc01302b38fef1475c2dad9f168bc57d5a482e7e8e7f3011e9109d2ca209fd437fb626a9b7d94bc576365aea7bb90aaefc8544d637bea5cbd529605e5c712549fcbc09fd2c81c08752f09049a059ceda2a3d5ca5a6e0c1ed4e5fd6cb609161c145690d78dfa7cee845806ca8becc56390229f46b2c5ccc189e09ab89ebd9d4cf78bc652d6a614ef21509fbaa7c47f3bf09bf508e36d35f9c1000d3fdc739c908c4f0bf917ff61bf1d2931d228db7231776316e946113443269d48dbe7f566e8eb61fc533e9b80f78b9151825dbf55cdeeedc0189b432e5e5be0943271bb513ede0cfa07b0b2501dbfaab54289c10a3460d43a2731e5ad7e05366172ba6e7e35e2e2e7cb73a63b9c9d39ef325a971027608ba81d8e863681093853bb6876be923f737259ca8569611a6612d51ea5b8a9fee68129d7a2466c84456f63a183aef4a0d8b24383829134b583ca51ee13ea2a3882a448082e1a55761f8853af3e56a0a5b3092e30cb594625f662151d9571333c5b681489edae0fcea68fcfb82e191d2c9e485e7a16a216cee65c8a20bc48d996b585807b2e91d7fe4c69681ee8dc430e99021d1d3085ef8e48d691bc5cb720a197ad21b1b4defe049d438cc62019c9b145b7185681a0c6a9cda5401746184a4e72dc28cdb995cf5222afc52807999ea71e1fb5d2f0fd6a9307324615713915f17602ffb3e548c5340a1d2dbe0123e49b6f8f6a68ce17d9aad216a33eaf95aeaed2ff6be2e7110e05f45a4f26704347728d43525dbd8417b2e65a2ad679c2ea41b7305b8d5480df6a9283a54951b995ae3aca93f1f3d270941e8198a1acdfac965d1cb8d0a87e3156fe3e8c19d9d564093f648e5718df1e4f88c9555e202ac829162a190b7a922c97c2494075007f1c742f1907f7254be49039b2d028cbaffac9236871b12559ce32c9cadd0af52f78572d75fb1b0120a7b8e99f0f490061d744d6f004f94c17317684eaa1bc2d6c74292ffc85071feb95c752f1303a3cd611eb4ea1921a17b2d534205e5177936d1721951e0996b867985b1b905b3d9237a9253ba366136319a7796171300eae84d878a72dbf11840e291a4667334c375c42fdab22a348346f67046beb4ad963397422b3878710a48295fa2172e0cb5afddb7190211d48a06525cd2cedd0e41559b2f803bf1b93bba9c7fc9073f3264653bf6db3c509fc2209a8154fc9dbc201c70954d100eedd26b90477178e730bc61750bcb2325641c82e6d1f2455773bf4dab368b3cf0bbb3c973e3fabfa83e94871b026b99e91111c76d485741440b519f0f8b7ab4d05d5282c4dc95c0504442e43d0fb51f08f2cb647b911e08c840a9b2e0c48bb55148c95350d27e2af0b90af318fdca64ba7e361b871a39484da239bd27669b8286a2b3f3006f13ec2ee6e3bc66f23eeee4d3fb21f529e16c70caad421b878382e28972a240ca86a18b012a9c5f33d673ee62b55166bacf5319683123740ce983cf18a66bf28665eaeb9c2984b567288d4888a661fbd50a82a5338e0c547f5a87df1966ea67989ebc7034d30c18136a772dc723e21e655c62209681942be31e0482c133a5be8431379de0a19dface1dab9a42371b239f1b03b1e1a22622c9184f44d77d0edd1451452914c9587995d45bac7fe6cc0538afc73a9f2a5cb6889d28f1cac44296f37f7ce7024317deda6e9d08a70a023a85d79f138aff6f4f39a4d8140356663935cb8871d3003748fbde4467e5349cb949ad02c996bfe02fe25c0d011c5354c32fe6d2f94b94a51d0f09c57fbc5702463c1b9baadd8905432f7f6475a6614ee20f9fb810ebbb790c07ab66dedf638c8b54292cff72bf90f63df89e13fcc5ef3c38734018c207470787511abf6c93ab33de42f4e2a366d584c2e1374522340aac8798fbe2f7796671ce8da6fe4fd231d043827815a383535c4cb591557e3d984e368d6683ccc686203eee2cb467e3182ba677f84acf078529dcb6251238cf7479f14d17fb49f09dd85973785e2ac0e457b786bde560d0944139dfb15bc0115f5374c5cce0f0aa82316133a104e8c6d154adcfd62fac7de3f5a551f7961937733c7f17a47e59c0e4b5a9bb616e4dfe79db16b33675bebdbf4a8eac33ce52a32bf654ebeddc379a87d7effa58ef3d6eb7e3a4e3a36c07b3de21c8914e11f250313a71cca670d3ec965e8bea51e17e06cc0729409b34ce566529ba29bc41a825d179ca56721d7f7c69fc3c36d1a01e69273c1d7de1c5be4a4d0d9520db26d618fa3803705f66c6734704ce67bf49568e3c77a8dd8b90e540122edfe0ff112dab4d32b9f9bc1ce4988d0679371ff09283a6f251070271757a90cf4b56dc00cf1a3c15fbcaf0730ab52e2926de8a05d81d9ec8edcb0d360dc6988e2cdd1690c5aa5526caa720db18218dac2fe7e28bed5e37e9d28dbe2b6d9e4db66fb37bf3b64ffb755b3342f0ce076da2b98d24268da27f7478f1ddfde6cbfe32aba0d59515f1d2a8a6e107d6bb5fbd61dea55d379ced45fff07b1b0fbc24232b7fde8550916e38e987f98db51ccdfdfa6d7a2d2fbf04ad86b432efb9c2811d628ecadbaf2bac5ac5a7a45011699e27709caf2f8fa86cc9d69130f595977ac6bdaa3e329c6dc0a3cac162c99affccfaa8ee6b703399bbc7906e07bf1cb34cdc8f4a49d0557d82e238b1a388012694877a5544759647e3e6a440ee03a8b87793cf90a66d538a86856996d40678832484a4c41041b4e675de03210b07f89c3fdb634e114a4de1906ca3375d8d51f34f53db6ce26009bc052e34c4221d8ab51f01e4377e28fb1f10ede8086ee0954628988c9b5df394278da4502396b36576024f679e4accb284dfa5d8d0ea123e57e5b68cb2ecc1eb24d7b07ef83215d75fd452b2c4c89aa7a8b908c45238cd1846a8f1860c75668adf84b1ab1df468b0ab8ffeef597e9701bc4bfb31c2d8706677383b035af9e26896a48600675f003346f2c33af6b6349656db43820dc40daa5095d88df2e12bb0e49b31881f066e6bf7e680d789f0b7a599ab84e79fe24c7ade1e3cb7d2043aa745609eb1789ebcb924779c817194593931266f4851eef73aaf9c6d99f2c505b64d4e739f312b057ab5e2acbdd2c558097d55a2d6602a4c36973f5651cb90c629297c21c620af285f6feb39b735a384e72b8a574f155cc98b6854749d19c1999689ac33059fc24cbe1f6845d838e444e963d056f639704962c0089589794ea7f08e395e455bc3e18814c4aa1d48053e87d643b6c240960103f862d14a8982a5fc0a223126e608a1fc33331f150bae70bc875946022bd7f3671a3e4a80d8915ae346c41f1ec89ca816f8807b2bcf2ae52b6885b037845e44b7b1eb5027ada24112c384248adea1d8d40570009dd1036f04bfe9fc9a14e2ad57db9981fcd65a5f7e8a7d163fa6ce92b3d6fbb7c1d197d994037ca92b56e374cd6abf43c22c2b528b6df46eb71cc60de3eb0f09662822d090667bfb81fbd809591299a5f0a9e6209da24917b07bb5ee92d992908862f7b7ec468e0cd2b97c8419e3a10f23c8412356663a44051282c03b8910ed6b2497a041bd0ca2809302d1268793c9f633e31ff83198fff5b875d18162821bd0ab6b9a9096db5adf6437fad4d8ac3f07ae380881d2140d15cd052b31b23b60da05ca1047026d9aac3e95849b203b450c0c2ed39d46080a2c771f56aedad0affe5c829f4de2e8353f061965b24291a7258fe0ab4249356e06d992a8fb516244e3f3f5b8d232a2bc384896564e6c7f4435f3ecaf04b7e508ef9a2a96eaa55c078283fa4a82b6090d23e9e56d9e01bacedc6eab66e18536529a6e50ba501c49236a64bc070c63b384e2d4ec4adbe7820dfa7ccea7ad93e0df8d5229bd4f56db2164a4dee8304b4b3d90c31068842fc6d0d2cfe1923da81864f14b26b049ee31a48eab5258122986cdc379699c7825f8a3aa43d8ffb2f6f8861d7e544ee0d7d21e0230e2b4a8d4d5955db02aebdecc9bf0619b5a7674cb51dda003f5f0b881df8e6b338cf58b581cb584180dc54f8620b05619d63c33c78d260e3c5c7450cad23ee8c341e363113e026d0bde49cc7564081af266580b850579d6354c9984ac05977c0bf9e9429d946cf0001aebbb960b3e4ae9d6e2f957a1cf33d65f0fcc745665f8b9cd5802483d2f2b0f2063dacddb9d95a4f49a54315ba9ec1a4135d15aafeff10b16cc233cef45c6a739a808d998690ceaabd4d3ee9ef902da5e378a2b0e2e0690e59eaec73642aa59db47af3287e1adf5394e1fc832dcbc0dc85bdbada9e150a30f241e6709e035f94dbda49645fe3590d2875f64ecb00b0b7b363c6dc8da9b4f3079d22c4af56317b4125a3fff3905e448bf6a34d8ebb708b8fac5a6efa750072e445b407cd7db5bc383ae7ddf256bb2b1948cb65f541ce9f2be300f78da0df5d4d4caeeae686f11dec9992d2dc5a65bb6a95158d9d75717b24eded726d2e4e81756dc163e7bd09a0e719438d91aaa11647f805c912a754e767a5db7f6e97967bae4a12d442bc0a73017fa7e5b8edb0897f9586fb016a7e70dfd5da97205205dba404f5b52debe65104b5e7932485037bef42f29eb5ba8af7f0245cc3a241e43fbaf864070db3773e5ea16ba6c2b5dafc458fdc247ae98cd257c07c63d26c5e8e7841b2714da65f7535866e48a5f13214b437ce5d8f6d9ac6dacde22a653934924c70f336d821a1f87991d1e888b20577103f5e5e1a6fd919af76ea5a2da8d61f2094848f9fe06682f01865a9be1ddf33c4f656d9951a6cad0e9f3923781eaf4c4ef5698f5f2681b12431ed00e005ae8c8cae6ead6054493997f14620651974f536d399d8ee97890b0c1479702057f85488d1e6257477523aebb90b2e72e7f0870c7c9f39781a33aa15548ada61395907e5cf560e6adff734927847899912af396beb686dcd5e63e8b073a92d2360519936fc8f550165ad0b928d8fb583fd5ec6c7a18f73ce3e70788515cf8dc1708df357f86d11374575ac777209a993b373895ccb283280bd8ecd1b3f3a78d6a3ceca8358d9e5736a8d3a1c3ef18bb60743e781485890961630f753c9bd8318595e2df964be641ab9dcaea94b318f22a0ea0d26e556845f5c4010ac8f9a5f365ab8d35d97e21251876910134292742a3086970fa7fbe185b88e672b5786b8b1c5d527fd9d858d29822290464bf7637caede5f5234d52edb2aab2f861746e68932849fe79db20d89017c55893017450e7058b275bb3587db6ea3d937c53e189c048c525dde3181227ed1b89a374efada91dc5f9ccd05e97d260f19bd82c6ef17c76390b60f2a86a36336e418fa597a3254ef781338b4892dc9058664b1ededf073342ac0a8c9fa316aacd5a5b0263625019ecefc87a9ad7d0822979f2eae538d5b9710b2c7ab7139a559613d0518bdc7a4b26b4a78f095dbd39895e5102e504f6bb3d49dc3dd0adf2c7c6c978150ed3bfcd9dad50d0a63689cfda48ac3974c2e5cc4a5486122113af2e50ef0de6f80c5cc001ea1dac151cd391de6117a1b60fac8f8bda0d4a0a4d37037f411572477ec3a049a98dc532b9255c6382213561e25945f1b52657fbeb99ad5dc66ba783b1ddf65bab628b22247bb849bc49060e82396eb7a96aec6786b2dbe42f2a924f302bcbdb3df0228d606d33b1caefe50776adbb8d9c20d9047555d523ba6dc36ca208881e107d0398dfce34886d65bd474477b1b5bced39fe32e21acd5e4e35c0acd28a405bcd9b947bc78cf74594133ef4724f4f39e2ecd7d8bf31c114efca42b482dabd4e1307a9383c477be5525615c33904cac14a0ad5c0d9d93d752619f03f406633dcd84c5d11bcf85bb5d9e59e599182afca64433761e119f82e39bbbb19ed041e152f9cb28f8843e2c32ce6358483622ac1ccb1e5ccf7801a53917ffa4b825ed21e6f2d62419eeff7235aee75f365f5b7275b99d02a80d2d289820d1ae2a0735858cbde75fcad3266f18a022e430280f28768d397e8c235dd3ed815712664b76cac3d47e56dd533725d97b8d36a4eaafa2069acb8d362b5689cf02d2c9570aa70a84c185430d53a6dd144b971e6dbb036df80054419a17194797a75c411db3fab7e0c8a0deeaf0b11396c8aaa92e6e27c10164006a49e816bf821423494a6e1b4305aa41bd3f660b35fa9f6427f28fb5e607731897b996eea8782cafeb818389d8210ddc3e158aa8e45e8a398e069a0d98746c04a6141da18ddcb584d64a769046ec50183be46a0910dbb47f4dee3e9487c4a7d3f10683562936f3cf62727b93505e89cb4a05bfd6b322b0cf6998fefa7e3ff3f572de76490798bd6cce28d591f38589a55b90f2ef78ffd0b516d0be40fee268af66cd4baaaf32da3592b17ed2b9df8892b4acd296c29e84e6050f0209388eb8cd5eb359cc68a9157923e0fd5614a3f5e61f46f13f3e0d7ae0196b97f86d930d31fb4554a7e80b15a921afdcddbcc44d8306a8bcfb5a623fae9f3222b36631ffc832567a9566a3fb4647a4741505d67d3b606bff52833dea08de3a2f0bb1479a94bcf4e28cd00ad41260e05e8ff1e21b316d67ec1179519684982542635ade6e2517b38b93e608f17d55dafcf9d71e1245c9bd6533ebd20c41ce858ad29449bead696190c1af9b638cdc7e02c60fd5ca274b0490ca800130782b0c25fcff1b9e3b616864c2f5d83138255b7b37c84fdcaededd1c1ef317104596ed2b1b456f70b7c447549a9dc93a79ca4264ebead1697aaa60eba010fac0217da8e5df627626b556e1f0221fe35c1c4c6587ede753ef00f31592cef2cf0de92f597ea353b46c409bc23f788e98ac79c90c90919ec5a287504644b632b015506800bdb3d545e7e40fd8fe56e244aac0fd8158070a2f846a1f03dcc55dcafb1f4c40695563abdaf4341865a87c487b2069d1c7024784ce4b384d10b1057d4ad9757175b46384baef75346d9c53f0d6781d76e23ce254028681f47d57a9b5c761aa93f8edc78891a1d36e1e5990a7c971a1a07572285c62b0cceae2764e09eecc99489d4f732bc9041e26bf4c79a40a29aa7956b6fa019dc214ce2f7b148fd2a066ec83d962cd3880147a24ccb2bbb0f73d10acc62e82a1dfab54c06a0934a505438300d67c5e0af22fe822ed98ffaced9424132290d6bce9eebcb92906735579d0ccaa5c2a9e9ccbc248b926e882cae431b986ed594e7740105013b5a98c9c2742c722fde35da4b19ebfc787c762f7ac018795aa330277171b96571fd1c470d2dfac524331d28814857f67974264a092a84ef3a338a39ebad05127090df601b7c66be16c37cb0adc8836cca7241f84d7a750e20c87b14291a0790caf3f5607209d21dd898604d4a4b5596fe6476681653cfe23195eced31735c3ab8a3913e5b8e521db8c8ed4df8b82e30041597afb15bbffa50620687e2be03eee02ee700790747226a16a691b932913b01e698a5eaab365bdab6f3038758070620a8e5f9b1903a13d62d05d027436131b0d197c3f8f81ef006e19aa1a4b5679ef13edc99333191f1bd6c0420cd55c6ac2e16cd144d3212b583f09022cad74e047e8f48de290c7e9c05dce887a6cbff3333be72bc350eef01cadedc6b628dcacf5605c05754ad48007d7be390f3ae5b28d959fb2b91a8fe4fcf1afd8c517eba7c4ac3e8db87bd6e9da4536ea309fc54699817c1a1c68931bea2de0b1b206855dfcaaa23ddc83e337640e704a757c102761dc0c0def9e6782648890b81de75c65e29e5fd462774cb27f63ddd2789370d5bd9a9d8bb1ff1bb71163762419c4a60a5836303f3c41ed4ac12a46f5d81d1ffa58e93b9a35400b43b7b508199a567ff4d8d3a32dfa3735bddfd02e34ac09c6a6067ba8e675fa0ce65e5e494520c3dd7960cffcfd8ebc5ab18a51f5258f4eca7f0f14d3f01591e1465c15d106f04fabae7345497c0f9db91a588e055253bf3395549ff9958cd5c9e6a392f82a75af744c0c6f21831006fe632dd73b3799ec6e380d4c7df3a20c0176f1beb9b27cf992b3588cf2a50459f39c119b237a696ceea1f5bff4fe95d77c1b277832c0534e83d45c164e420cb7c758d6243a258d167b51be00d94e6372ec00b9e9ebea4ca844c4e62a83a184ce7aaa7589b729f81dc7393fa7fd0163f05717943384a9ccc784dc25365e7392bf2e72c2297d73bb2113d6b624211817630efe4db3f6103bae40e2b27cfec4d33442914b87d065b23147524cfd575e09d2bf773a0bea729c09b6979b4a85f45db7fae5762fa8605cb3aab3370ab7b2c02553bfb81a6960067fb032af8f5ff07c707593e9072b33f09b3a1f7425a9edddff754478ea76111d9377dac80db7aa6f2466f024369fe071969d044c1c6a357b49ebbf73c32e391ff2246d413e1b04f4560e31fe0a738b97d252593c9c86e07c33f90092f2e5383427cb9c44ed9b00ea527b6df084c3bd9191a511cfe6ea62e705e080791c1d774182034ae806af3609ad0c151a166783014c5305e7d904f61e2a1ae4a74de744ffd5b5c780ad65fdf019d1b227e2422a8d1666114e9f43824df09f06b2af19a35df29960bd817074bd7044609b30217703bcb077bf8d6e82347f178bcff33986e3ea57632f5e1e50e158e92d057ee5c490f31181a4fbec5cccc72c016c459f98683536b5965e238624deabcc87eb53cdc05ce13b89209403bbbc2f640d625edf2a474b50fb84974cdc193c987129b74efb66e011e3dcfa0f58849ae03cee601aeb07c4263f79fcc4541b7421b5169222d078d5df32dd2ac1d2c28eaf6d39d1cdac82b765526e2b22f6880957c4c0bbabfb13b8898241d82c06b8f2f514f2b8d1ffc06d1611214bf5b9ca6840affb13a50c97b1b9dcaba6c5b9f10b79bfb68479e894e6d77220f718fb9cac8d7fd2ef206698079bd5710edf02d4a32d83d850cb2dbd240812685f67960ee6504c7fbaf8ae0d0272fb4bbb11c9ab7cebad9a7937a45e3bc677e5d2d2b0e019df55f245c0a23540eed177894f81812da869c0e72a55c6592c5ab07b5cfa5e3a27ed1b79d71a8ce623e79f83e41253a837a52d709b63c93ea963f3c98f3b96702e26660d3cfa1c7395ee4567e3c85ab4acac87c6974a497283ef210d1313d488eebfa25d8e5d402df145cbc79aecad2292b9626e31df2a0eb8f4b84eee5dcd720e2b41b120a04125cccd86c6446f105596e3d284b06f8279c54486eb915f523c420d69a4cde5e16b9f6cdeb006e6a2a4e9cf0e690a4f045f58073ae102382d0efdf6853f0bfd77864382b8d439a719f25dc2ddb7349cf52f29cb152a273b669e92b1c40aacf44a4e581db06519e423abe8ce2acb34da477a52c03f4cd1b06526112ae833b08216ea0eb4f238b3603c8746e61bfe9177358a2191c8d8b1ce4be871b4ba0a402a2593bd6bd2efaf431e860a675a95b023ecb758ff928faea88de81ccdd0de0ad62f9e84ac3e171afdf324c542a1bb6f237a4d241e090c861c485ff490324b82b48ae67dad2782a861ced8ad2853e0ce50bbbd0b05b65b2e97458e450842402c61c4b74b6474a0ecf05672de374b2bed0910e43d75dd5aa1caa945022e68fe71ae42463da5acbe8e9f4e505db9d55cbb3ddcb38353a45ad35683adae1cc24e1bd1f675e20bcc5e11018278ea8edda0a0ce0919df4f83cc82c5727b37fc354ab8536e4cf139a0db2ef2bcb49db69b7a6b5dbee6e1594dda1938391ec77db4c3b752ca2c84b76cff9ba11be0ab550d06051c13158d7dd670cca8d8f86996d92346e4a1188954648979dfe45d3e7c244573a732e8ce85a092b16892433d12ff500cbdf0f91263c51e4f33c3ef25fcd33b838bcee6036b412a9e0550e28da347ed4fb94db086999f2c67e6622fb140ff5126ad7c351b43282f10d603ea774e34dec270b1185c081d744bc6ca93b1ecc9733905df718e421adcf5b058a2c140a3c65d26f341a1eba6b13e20cce4ed99aee885384d78fa970a14740fa2663c3cb757ec7718e90c16fa63c0294daf9f515c4877ed0246d01a7076692b58d55388121b9cdecddd8fdbb818eebfae98ee68d29b0737eacb180295f568b9121cdbdc3494d1c2ba796db539c88f76f235c87a10da9d278ad3267e6a502c8424d40560f8cf290c3f5e67651b3bc45ab685d372eda37f21a57b5d44eeddf059499c4a5dac31e150a0d828315dda9e007f87a9968d834c31f96bf83633376ff770585c951fb116b7d6c6156fe01178e795afde381683aba63e967ca25323275fecb4f8e2af429bc9518fa8e9d162a92bd9d787203c30418e9fa3e3ed02c5fbb868b8f7af85a721af510debffafce2f8a50cafec1abd939359cdd9cf1aa8d5652a6dc6ec79f4d45a013983a158e0e2cba2553503dd2dcfdcf78716699776cba9c14c663d02d45c674e646bb488bd7d574666e4dc71996d278b55d9c5f6ebd2966966e9e374e0eea7d9d7e37c3ebe95d2a5bb4c960bbdc4b0ee7b290ce3c30bd0fc0535bbcf3eadb24232c6ce7b1da8d1de34b3581f720a96dec423a7d8e274e13d60ab9904813c807b4877ff77dfc4acd569264beb95cb59db27b486694ee7c45658b5a1869818ad72c7bcd74a04a1dd5b8091057cddf5d5f7b00ddb8e1e70c2a97666cd12a4994b0353ab31b2d6743794f5be695f8d578bd8a9d4f6bef11be18a7e8cd4a5a92a9332bd5c40a6f6a7decdc7d13560e1ec7e7fd1a43b778332a602c2fc2ff847259b0350440de3fdfd2a3e69b2a2a4e2b22efdc583842125a1136fa666f7f638b54ac0089da20a421eeb1179ca86cd504850e2395104bdd8fd885d4a21519e97106474412d94c5c4c481ae57810aa48a40eb1017021835150413a87db2f66fddf48ced721200d5069abc21672e4986da28ec3c8551285f4fa6d1ddcd83c6fc09ee6a0739136504beb295e5d877cbd3d33ef4ef3f2623bf8249a4c9bcde8347c682bcf6aa2703aa0ecf9266522f77187ceca33689485d2c0250d985f9a631ab557f189dfc6574ef2f6b77b17b2c27ad775a462f8cfc240e66cce616c1c1d64d5b1b1fa689fe99a3e55fa0d70322b0e095fccd463833248b040cc0cc9f1f8189263c2d005063406f2236ca6ccc592943d61385a9a8aaf1ba08d80dc2f4c6d095160e54ef2cef10fc5a6ab4d522166fa1896ca2345c50c936dadba35d73fd1e3122544c127e010de652463572b9dc62fdf2415e19b0d3e710fa92997f257fd02f0a3c87e016eaee4080bbeba4e901cb609b41dc67c9572fb28bb3d9719a0fb27fe7cbeb3db1bec5de1810f8809c29e9e2b18511f54a92d0b9daf6c13f2c3b809bdaebd6b6fecda0d6343849118cf40a4ced80804076a5ea99e90baa7453a705be50e44d4d2328093b540c3e480e231e0fbf48338bf98f0257ba7931e05734c6a116757869d7a880ab94b817c8c93c1f9d7be02ab5499b99244c0f6dc2c2e6cbfb9a1488e745dc485ef779687603f04b9ae5aeee9c2e8e6848a871a9c73f2e132150e404d1ff04caae5ae073f9deb117d971eddf0bb9f2ddcda2985413c74baf86aefae669fe8efd354ea7d7469d160a077b7f533e2e8d2575b26777151f0708a229d115bde0eb03cab2fafd1abb653f2883c44ea46b56934dc8e8a53fe0a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
