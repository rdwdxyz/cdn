<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05706dc20a6514a6fcd448562535d614c4f4dfc5c04157d16f7ae61cdd5cd3dfba110e5ffbdb02336891dc8481144ef3c1f4d4194812b7dfa34bb3bd10bab460cfae8df42f3aa6ee88dda02ae7f94b991c37a1fb832d27bb332f6c1e342c045ae6c5aa10ff71b754fa01e3aac87b9db900ab9eacaac428590f07dfe15205f19c3893133d0011f469b476ac0251b8476a41466086914f5f776ed5a23d0b3d6c1153648d0daf461805c797f966c12e480d1b339b2a9b6ba9dd231e41a0ecef8f202674d0b0b67aca93592763ccdee0a981d6f11545071b7858fa2b7eb7c090f37acd3b49bcf62e4ba2ac8511e353924132dc7d08afe834fed00009f1d3b0fece478a04055a8b7c4e39c088381d549f75843a3dd940f032b271669c78167b52ad420a18ca471a975d3bba447a4856789135c9e70df344e0b41da1cc029f77632087ef569bb24d708383f86c520236bde4714cfe232fc7e246382fc16a3b6d03c758a8fafdb3896d176a89d73df79cd914e68ac65ee81fa987fabfecbc0535d359b0ed29457cdd5ab57a5557431061e2c03467c7e6d1122b25ac9b72e8a9d7a837f6dab6873984238416216bd2a4059c56adf297e7dc49864a82910590b08d45174d60b0259d1cb83896fdf4c536185e5a19b6dfe5b6666cf38fd7ce7866c3b4153b7b940863ecfa771481fa62ce7f69e99ec240156b2c2e412fd412f29c4c3d3789f7c8afe9765ac0795a3e7847935c5f8dec8b3f6ef47db3278072e1c0554e5619cef0981eaffe2fcd30e2868a0e4a794f5d174b05118986c91eb3647266abc08a3bd0692f96a209f538a7b044274e8d7fbe8b7405c75fe7cbf2842e4c536037327914e56f191d8970362aa6204fe63d76e67bfbd72ff6f1eb1c0755f4703e9c1e10a450a1d1678e385124503eb8695788d8bae9f8431da6094892579a0d2cac6439136e27989820b8be090dac728837d5a6da7a8ab4bdfb3ad0aac28c97c32d25b4e20766709915ba08f677b5962a302f44ddef5462e63187fbd5f472a17c8386db6565a85ea09889a3e79d86ea4f1e90a2177b525aac9386db87065759543f3c6709c900375df97cf4cd86b39642319b893e4805495b24b201329f6c02bb7e1b1509c6368d10c41d829112ad9cf517ea518e8759624641d8e6325adcbb48bb4b92420ec42bf1085ad2ffb6746791afa6ffc90771490a37f412b55e048f4c7b3d9cfc8bd2712c6dba36363e8b690cf404f5684ffb9cbd6a2d55bd6c1e4029c9b421e10841716574691a6d40068b0491ebfc119bafab31f352e824634826bd3ab8bda393aed3412ed66b36fbc70d4ff356233edec8f4b91976814ef41d11af0c981a90af89891a4617768a3abf134080a582e2b894ac49eb2872abc55574bdbf7fe474eabca06ba4c3db4ac93e4035fd5e61e65fa4aef77ab01404b83e9bb4d517a1f7d9a4696d5b4ac24bec45e5d2b1ccf3aa5e951429826dcaa7576a10aa3e9187e211ef56949936516704a5a72fc7be4afe1f413c1de6efb410d693cdcc64491e616472dd163d8821d885844bcf1756a00009bdd2bca8b79cd58d3bf0e315813bb4a92edd3dfc5ff446c9a7b66407d6d583c644ef278e4689074b967e2ce0af290494a78de6d7a3d17b84d7c9c8b5515b15d74ae6287d551b1aaac3cf57112394683ae375b6052f1efcad5bef8ce97073b31139455998991c8022f2436b0557ec549548cd76183b2c688bcc9ed07e80e9022076fd4a54afb981dd40b37cb477be4f2120d231aff7568bd9ec7288d3b9a2e92029dac2ccd50f7632d2d32d9d0247dd2c1c79fd5da06822ab522002a90ff0045c746f2ef8986f756ba46824bc3fe68005210fa3529f4e1d8382fba3c168d5b7fee3e94edaa6e6393d1dfd264c9de092c209077caab97ac55912e660b3bf7a54f7122cd9a35b425b144bff5d3de538bea371dec8e154bc3738cee1483d1f814f5bd7c9e08098e5d1a21bbd49e761d8374e107196fb6a8c10944bb504beb2cbcf8a1ff90c7bb23e51beb07ce293fa119570ccf33a62a9f75fe345a5be620c8c82978c50ff41d12d73ad87d39215fbfc4416967e56711ed17fc1d4bab88375217d6a77339920619a2ae32c9abe27cda9a2f5967fb568f130cef6fbcf0799e8dbb2ef5c035f293d314e1954714605cf14919dc02697cb2448e327a4738ae9da0bd663ce145a256c71d7f6f4c43f7fe445db5f082f24636f3e8a006ae4228a1d20c9943b4822da0ada7d7b8dde9c7885934ed2bbd0b94f40eeeb5ed9101335e57b0b01f3235c8d6cf79be60cc0a7e82d2c866b00bcc8dbd5f8fb582acdfeeaba9381e6eae99de368475d80ffd76600b504ea2e23d4d9d81eae770679b56bff35399364dd523b2b5be72da965476f9a65ad7c743e6e914419bcd8934e92e306befd54231098f770d3c71cb05adf4283aae10efdb0209652746f48d2b46286ce30ab50c33893c41d78a96f51a2fd2e0386d6d6daa0d9663f03798157590dc9a91454c55aa258e6eb3687799963ef1ea30a0271d6c751f7480fa9d6083ac30b01e3dad17d41d2660535c5a491dca8d29faefe98f21375274cddfc63e3db4737929119edbeedcda90d949f063238f9ee51196f173a7dadd6c7c7f9c5a3e0237d5056128251c8ab364e3eb46c0f68262ee1a2ff857f087eb60f52e9addee8c061a2127d83dd6b2ba6d31598ce9e075af705784d7a8c260ab929d78e450c6e20a630b2e6df8c6e600590ed39d6bea208f0e2e61c9a4bae7212d82a114aec7624b0aa5b22ceab6694a4416e9d61c71f577496294ab8497d90ee29e334289fe8164551d3eaa7dae027e29ee8802273a12ca84edd5ddac2fa0223b83e96f2caf57c60c3f91d9502a049c381e3f4f7fea9d05fa97259b77b6f51fa837ddaa788cc2f884dbaea40d775c7bee4765fcbd166ce8b5a304decf126d7a460d422c480cfa9e6c9a70ebf577d7db5c2f25677e02762091fcbbaa947eb26e0217685ba65e9e512bbb75f16241d8e8394dcca7af4c333011094bcd0e60933ab937fce646907ee8da02011ee55ad45490b9b2737982d354072e1e559df28fe4b1ec11d31786edc214c0093bfdd3fbe4d4adfc662039e715f73418e9d50172c1176f49a257ed172e6b926486373258e2302f7fb1a889615375203a71169310b4cba101041c1e103562e2d8323bea77f05aea0d1668445d66430e005cf0819cc11934803606f36b2252af0dcd8b209530998d2424609c38b83595f2ab88a0e80372bb0b9f4f872167e824cace976bb9abc3015080f3f376ff9db18732c24f701c05a3d98e9ef4c9906439d1d1ceaa87ae07268fbcc0615a08abbacb7b6d8de3c71acc038b7fd07500f3e9414d64a604a02bfb6141f469b72b020d68def602d870f43581879efaf45d0dc0052690be7f63b9a6eb895a897f78936515514ffe9322fe22253c4c664efc403cc6c0424af5b4c6b90b9d36b67376b4a5266ce78a3ebbfd0a56b8dbc934e4fb2692989134663964da3c0fa1d3ea7f1618d5c89b39072f608ff3bee32fa3bd4052a00f643836acd6dd5dda09c0f53a07a7d2598dec3cf1f5c2916ed51448517b1b926b8d93ff4d1609a00f1429844a4022a7c3c5bec0755c8eb0ec57d552f345938c155c7cb123ce450b12c2cea7ba592893d8d6097262070bc8ea48a1e022f3b1af29d33d29980b4a05b04ae7db77f0212fe9b61cb6e9391cec62e22e39be64ef2d5d3dcfbc11974b64773f9e7e055d001a63f22c6ddb7b62b3802d1adcb1d2add05bd23c8bccc735636585e9d8d67f2a9c6d28663341ee98e0bb528781664ccf7e95fafb2878d4e93376ed1846b90b354e7ecc7ad29ac3fe4830fa1d4a0968807a827fb40c613dc5a72fdbe5f74a44095461da70d7c4152dafad46d8bb7b9a227cbd752aef39a691339a2c632b08f434ba3db6688378e82359c16164621cf787336a22cd6d959dbad94a0f62a6ef6a7c2f09cd4bd84e30728fd2ceb2f989f3a0ed790b4f023bcfdec54233dfb6b5b381b1f3413fd844cf1b6008a1a5ee3fa1919e5929a20cbc976e9196943d1a2886f88815470153b21440023650dc079a65875259ba48a03eb3e0f68619f9d6234052cee13252df694f519d5199b867a61ef768d41e62c19ca00a8a4f07f3dc23446cfc8440bb4c85766283fd39956050d85e9c2785e711c91110c387e1a38e3282da336c8d49d88f173c499b84b31e129f653226c70a6b0907c4281176d19b777900fb440e201dc16031b9f1ea608fb97f1717cd43221977b2e2990978eb72c355d7d81602867455281ddb61a0acddc0df2edc02037779e0746ced38ec6448923d0c620d376458f71761f3dbf476652692d3d31325c2b799b995a5ac6620ed14f8de8a5c01b23894175fcc940c04c22491e2d31794e272bc6ab7414a5cd08803e68cf50c9eac4f1b922f53b9bace52ffb5d8dee5ee91674c68db968d8b63bf19821de9075d0903851390d2aab840a1480b3a2182e2f5dfe86bf5a272993d6c450d22b23fa4c85c5f8c23d125e628342c585d9c77e9dcaebf0cd633307c96cfe3bb211697c316d351428d5dfb3d614812c281b9d91cbd465b2482f8d1cbba8bdf7daf5a47871028f829ae76625be33cf93b326c40413956bd2adb304fdb44c2b95302b3ce08ccb0591fa2176cb50f594c5a38f20c1de83c4f2282c842b64ddb1ea55b1a8907fa2021cf5306e9335d970594b9b88eece446ece321794f694b3615fcabbb83e780465d0814760daad3bb6cded318ca18d1e6b447d5bc94ff98fc8cb0fcd7965e2cf099b2cfa5141639ef02a9751ca0ba91f87314576ebeaf7d69857285e56627227ab631446e512e91df28be9bfb8e16b85173aba1204cddb6ac03f8b1d485413a6644b4520815257b56bfbb6d60de594c19f8863ce8e32777aeeae331eca901f5959497230c89c24d30a7fa049fbbd342a9ba22632cabeb3956adf311e8c9c5da6ca3aa6baa3c2f02ed0cc11e41423892fa127afae8cba46472679fe4ef433a5585428b0f4386c4132269189fd88f9c2eda9c1c7d57f5d8c4936a640a445f99eee2e361333d959349539e8ca29e1f37e4ee913612e1c12b46bd7095bd2aac56682dcecdf1cef932f4c5f40bd7d33386e321e299fef7345a7422943f78610a05fa917d4e480839e72ba4a75e5df864ea2548f02af2a52f8368092cd2d9c8d919dd563f5df7f5469e7a6752f902381d934b91a8986e91078114952769130e0ec9535ce873a87187456222cd28b7dc501af4e1211588d0cd4c26ceec7b2e3e893873220dcf94d9d9f010d27b5cf4cb08c8dbe1302b2383d9a88e0fc3b35fc3a507cb8aff72a5e2de5cc35ec103614f067ac7b66bd3884b63761b6bde2889402abd7682f9ceae621129a151316e34bd2f1ade2555efe45a288f62a8d6be96a2e9f346977a4576a3d2c8f3786b51c28a8c6f4a776b2aae208e4c531b392404237432b47b8044f7d7d5f0ffeab13cd94b3006dc49105ce7a4e5116b231e8139eade123ce8cb8a7fe68fb70c1d70257805a7ed62688ff2f9a9785560ac3d0e17a5c35354d873930fa6da55fe740dac7cce2fa173e9c7234d4342c764f74dab1d67084da58724faf5eef04ddb01f635e5fd17b88697153c5b28aee37d212cf1e0ca6d7e999d4ee697b0b2873ebbe6e6952b3922f8ecffd8b4802c17eb40bf88e43543806118ea92a768b871c6b06595e534268242961e38030b43bc68c1a0865270ce13bcad43d407509f0e1f71a37191278b0333bbeff6dec275bf639eaf9d3e05bf1d23849584dfeff9dcf47035b9e4c2689bcc2ec17e9143fc6dd8111fc245f0ec40021098d52e087827b208272b9c8f5025f70a1bc7e3c0048dee80f2f0fc9fe786aa65654e52cffcf297dce4060ec729870aeb8ad84ade574c98a6a9d6ffa6dee2baaf90c76e8988ac9c6467da79440c3a32b93171188af5ce742130b124973a09786ac8bb753b94a77aaf353a1fbd84d45e99e47c1ba61069b1171b552640faed6c8137613c9e5ce2dc2243193d7a5b1f1e6f180f06714b84bff9c509106953d0e9fc30934dfc05b6382f208a99ec94c45e4c8abeb91d08b0afd78e5a83ca2af10dc52716a5f003002b2d2b5171f42f1b1a9b64dc07c74d3eefa35ab9f82e6c6ed0cccd40bfab91c51c6a3bbb0ca429fca4c941462a210863f0f58355718ef73ff201ae9b6dacd2ec75e2e2644781f50d4b96be9ac67332bf39c521cb4fea07fef607080af517c28682287086c0302eab345260d80f628b365cfe6b2e472c3bb70f0eef6d569964ca796e4013b7c0faecf708e977a14a123a1370014f58556862c85e59fd5fb456bc8cd5bf00853cca0e12a0cdbb6d037290668fe3effbfbfe91e6b813891d3a82a8f3bde4168d9608728d7f7c7b020758fe52bdc85592377077a43a961979f79679715961d2a0ee972a5f24c3044b68e3b1474deae625c53229cf15c8a6ca08446bde6326ddea8de489229292fd13b9cea9601b85440634fe971288e851b04e6ce799fc1b9cda89b62f149c1f9107b1033e1fc24085478c08a51fbbb2b7c685a342457c943726f30a398d4f3164e0289cfd6ec3f712be090e8569b510331dbb91c41a2dbd6b03a8c53dfea78d5cb7de0fe178ff65fccd43a351eff1d7240cc861582870b4a879983405cf143422ef00a358d335dac0abc0e01bb33c396b9f34682c59ff7bf51924a160de258a102de8bb12de39ab6707524d94bdd6fb979dfd5652855f331cc794da73e9b2a935993624baec962b390962f4d3680aa4ccb483017ab7ff33993bc3612f482aef0510fbfbaf35a377435a5a73d624005ff80737351022655ca90f9e518c7124662f008e8d9e6e39409dd000293ea3c63587bba8817d5fa251c887816e168641a82022dacfe74c3baeb64da328a02e30c6dbf5319ba030f4bb1ebc6f5f361fc899c818aafc4f832d4a04671f5cd00c507304af1d3d64945a3c98bb9f063e17b937c130256b289bdfd4edcb18eb350e56708d0e304cf6819c21c9452dede15b5feedfbb3eda033ac36041de3baebc882a3787325f23c7c00999faa8bda5ed1cf4251aadca7185a487f578b1ad4b76b99fe5862b6af5fe33814f13217ad428f5d30e91510f30bf574f4c9b658e5224daee1fd19b3c8cb83de65bf35f12e777f5d98a98a4ee180ea495e991315d770b7d3a28a826f7ee0361402839f818e71fda97a464ce681b87355d135685ae8ba67a05102df1fd44208785e372a3124cd5be11c474e2bcc7da849a9ccccb974d13d6ad2ce9956d7a7b3ffb4b81d2e86eebfa6e46a55eb1cdfe497b96f9022a9e0f7c4c9c9d205b70663a0830c205f1437e698d6a144851f577228c2b5a9d77455966d3db2e5f38bc8712e0fa3b279863086dede262c1faa0086c148545ad519cd30a7db82868e69eea894baf5c3e4720ede43a4d55f3839a6bb4f4318a56ca59904b63791a921135c257812dfa256a948d9241525a28693db88f344f82819b833a1694ce29811f10811766cc1cbc2eb5f9f87c5502b2538b5d36a77e90438114172851e3754523290fc943812a74114724e569a41bbb8777245a6fc2b3d659c49d8ca48bde08d43d1707fbe87959d5019c12d58888f6345dcd7647e87b836b3645055074ff864eb699aedb1925e61f226910550ac8945ae364d3ed9045f16aa080b88f521b1e3f710786880a190b0eaf9b236114ff3c6e89ef52742c1f3485af9b4153fa68358dfa640cd1742ac861233d74baba751b89610ee20f1ac17bac0f969cc7a9241789a752f9117d80bedba8b90c543841cda29320190938c9f7bb8d6e4265f06cf0fd48f9e05b12a135ff54621a92955670ccd9895006c00cc3651576d89cb937f17655757751440559ce538700d5836e23931546e04c5f83749f7aed78150b296296d4a962cc9c7a2cdd5934956fcae5887049839317d592627ab9ded2b2e3a9db0c0dbfd1d07341f31716cdce4ea66a9801cbf1597be32fc10446399f9a4627469239816863a41523066d8950191b221e29dc11481e8924e91c1e80dff109bfd2fb2d0356170d4b79d29e7839ff578580c5f071dc5cc468ee18307e7e197d3aa9cedfcbaeaac71a456ebf6e2a9db158ebdb2ae6b0b6acf05f43102838a1fbb36d9b25f37262ac2cc4780bef9b872c5047334cfd1d806a660fbb2cfdef768a52abd9e1bdd25fa502588e9c7d42912a76d7c6b64674eb6d626731a7732d07057143bda95fce1514f6ef2e6b016cee006e52fa93c20f96fabf71a51a7ead787c4f01a70f8815045ee0335bdc0fd64c62e4ec3ed1a823f5cd012a9688c1e26a1a14e27285d72c167f78de4f514ca233b3b880cd2126178f3b551c6bb88b7a7b10c8b80f14b69f0acfc3afaf276eaf40fbb72f4f6f74814bc2947de5cea6f994bc01c62fefdf53d5a84bc3da88d187629a0748a45ed38fa946c4cb4aac62db0c998143950271af131c5cdea33f1215e43bcf41a2aca7cfb4eb5e92f3390f0c71cb5e5aac80e558b41afb22b9c77ea77e991990c647dd405f4154e3f5b68f1ca583a7c3ff84be0496868ab3e2e1ba225cdbf9f93cf3af60c38cdd00ccf6bc8a63798674de716184fbbffdd3257c440a7edb499988e8fcd0fcea925d988ec2e9758a90cd46d663d8ca7cab8841e27897d9410a54da02fc7acb99b085a04a38d8ed3c7c73e1e6400c5b26f8f45b99a6b9da1b07a0feada4bd9215bca1369b82f37ef59ca66ebfbe19c07e25ce76d48ab4708086369d28532b7326ae8cf57951733e7409b194f5cadeb833006c03a112e193d9c3ad80fd5263b93139536b2722ab5d3c2ea5c44b42c8c8dbd72f8f193d3d22be3aa021c5c34eff94774c689c274e1d3c91f932545c32f7f610128e73a4b38f100624f1a08f50580ac00d5dd9bf1626d064272e6d3ed49a0045ec7fceb991de0f07c5c96609c5fa3c865f862bce3db6029036fb750d25a54296061aba0f707b82519d21b036b6f8d85fb48db1393c29a41e3f3ed20b342ade25c822c367ad123840f311adefd29e5f9f5870843f74affff99e934ec9db3be2de2aa2aa3df3d6e3fd931115ef139155c7e3a3390ecb6eab221286f4bad0512bf96ba2e7bbbcdf0eb6c4034134c42328971d3d023d4760efede2d9f45d2c2e70de51b3225ea018c494ca80d5bc24824b469bcb4e5ab63176cd229f4a6c4057ff9b65eb793c619ae1ee4bb90552b4dcf5f9531ed562604a40dcefa97cdcd63db6530c555f3844c6410cf57d08b09eb02741040e0f57b7774beb28f9cfa0f2e7197471b74f49e695f97e99e84b6414c341bbf62e7755090e07fc7d1d1b0b9daba61cd55f8ce1ac052b245d19c0f6b29b894fdf05c4d769abfd2dc4101b0b2e5439fca1d1301b940fa9ec6020c2de43dba48776b7a5c723068cb21ab85dacdbb88c99ed8b9b3c8360f6ecdf2c2868832e04b33d79e22ce164d1d1fc89932bf201fbc842d63205699230e04e5f3565c7693c9d4f2e23355bb20bd5ab8c02641ad8101398294a8ddc837465713204fb456fc1c070bb394edcfe72b4e6c373e187aea37ab10aaddeabe7084a2caf98e9179030c1752f60387189acf3db8e95639d9ebee0028ec88118b5639d0033f1ac6754930e90e17dc7a2b0bdd872cb01a0b551148c78c98001058e4c88259250d21bcd05b3914adff5f05ddf33213afb481c2e2de57423553c25f88c81fc3c9f2c5ad2c5dd09bcc8651d5d34fb0b492b4485024ca319f2225e8baa4c7c23781c4ad2d9af43f4d5b36ea0d582c2040fcb6595fa5233dc74c88fa02d52126316efa64a773b095432af6fd782f8f62b8fee1fcfb5bb7f40f6836553f382017d1066726b143dabca63363b1b0bc72279c78c27e7d987f48721fb13e8d4ed5607c39b9427a536f58fd5b6e469c9b26b8e29ebc9eeedc36a6e8b133df2b28bb0c3612ac43ea2cf0da6c44094ca57b403ff8b3eec90d50d4817f581331dbba64e9e86beed7a9f9438e08c8c15a3d5441e2640c34dad35957849e13040ce39a4f79e1ecd8353d88a4b4b79c9b6471617e1f4ce82b169e365dc33490979e45fc347b3e7ff5b55a7201776abea375972a19c69df4ec12e9f24bd591882d5c1efdeddd7cb21f57786066645f67949fd24624213850c8fde0055c838951e4e921fd6b9c331528d8b03463d8b0f41f1c03e67cdb324ce5c76fe805df89a4ae9e87b3756ae3a824ea8268fdf997f3055905de76f1165aee034e5d1255f968ec05656e7d8c4775915e7b97cb0cbf357c78fd94bb349e5cd9b187be8e12ed4478f10b92a484c6392cf6da17be82fe118c00cd8bbf98730eefa6616c1ce83166dd7f8d5d8267e17f9be73f034bf2c64b7afde9f7e45dfb6f418811d859c289bb2da5348dabed2fc48da50a4eb2d894b538b707678fbe510c16d5fa8f3f53da0c8ee3c9af8cd9ad639678eb60e2a3f7a25871c96298b3ac5d97591b04aeda8252c7f1c4c8ee19c0fa41d2d1520c343a565c653383d2c156c86686fbd5fca78fc33ad4cc2bcccdb1caa6ec2dee90a458da176dd74c040e460aec5f4b665a2ddee79876821ed8c624db1085f781d3a4b35bad3a10a6fdec12acc9f4f853cd1bc7865f0a8fee0bca370f6d813b3196cd625b5226bba88ca39a1189af91a06c11eca2172475c6fc3d666a80efe145bef60e007560d00d7007bfa47cf73e7d2aae31935e6f177744727f652360d4f47e7e55139db3cfaaa4826ae2d6b5c658450ac6e8d5bbd6be11a3e6e2751be6ed8e45bc978d2c78cc29f2fd457e25bb7dbd9c05bc6166d5853d3db89c5f27cb06773490b4d1eab34804331d1a8a9ae3e1ea7316babb4059625567dd4c598385580c79c83ecc89a0f18be5daf85941b3b22fd68dce3597aa8fc4d87775c6bc5c9a05de9742217f6323843b4c67c1c21288ab15bc6b09e4e8b6304cdeef8d26ff3a4932b16cd2b0eefa871779084f24efb240f10138ed027997f3fc9cf54cd4c2434ee54000f0de111ca81be0801dd941590c6e71738ed327797203f8398df7491b851331b32d5c5e203a3537b65b9b0f6727614050bbb5425cde0d5c895ff999cebc8aa9c0523b608cbc7f770ef665edaa6e528b6cd81eb8ad4e9b33dc0538defedd41b02f3456a351bb2eb140f39153cf16dd4676d1694bd6978821b1e420c13874e0c510842146236f5e91e22780c6c46a809703f475fcd9749308a9e2b4c4efb362d9f1c2de6edaca887134c9543cd409662dbb6e4a812eb737ee9daf8ad28f82668fc82494f64f16349b652b677a3d669dbcb3e2b88c96080ab0d9b62f7e22d512d72e1d632140b9198ea3301eb03447a452c56da2365caef95f6542dcdb3e7d7e91e47602bfa5e760dd5f38a13014f8115c997037f2f8b16d678089b15fe44467164d4e40a8d04d64ef1a88e927cd93b3512d2b111b754e0bcb83138d78766f12b3c195c6aca075104c1b06bf899f2404799063501de48d1ab648548b83b77addcdb607889826463f8afbfccd8d83412dab1024f13bc7ec4a7a10cc6fd5d58dcba2a47de1e2d8e016f0359b08e287d502614712e5d63848663c4079c585159defbf34d82c2c759f6892e03075fd9b7be3767ba2057ae40fa072295c779afe5d0d26ba83d199e18904c7dfaed1078eae2c3ba494e897bd944d1969f60fd063bd71a3667cd269a02429e02a8c14320a4e5469b3b84ee5c53911713967e773250f0a978dfd70da5cf24549af64b9ed231413f1174294d97bf395b55c32bf6d1830b2d8874f9deccad57e7473068cebee023c3391348d595bd8ed71b1fa105af0bc5081e95c90b8958b05886a9a7b32e11ad3a0b6dd53798c15b1ab3dad786f927481364009aff8c82e3fb2a2fcaf297a751ed234f234c7031adae5320b2648a883796becf6cc85ea925be353746f7867b3bad8ee9fc0f5fedadb89c9f0089700e2b43576db6a222b33d64021b9886b384c490b2ac33a97d60e4f4487f9d84102c1fdf7523aa7e46b0adc0c51c89bf32cd45e0ab290e1491b50313ab9368c46888d11d9f8bc0233e9660e3e3e078eb88eed37d3dd16549b0e5cc0256dc5db97a1f9d4e0ffc0f16942c489da0afdd5a6be8f8ce44bb799421971701c8b14c8e4a9c9283382b08bea2dbbcb8e6d57b7811fe35c1db78f3476718141a9d675e9cd4d04a1088b5a362124ab513857b743b95c286e286f5a3a8c9b22111c1a3e020b2b678399934e852bdc4dc11f520c7c145aa365d457dcddf056f6e657d3234f13760b9253016456057237897b393285754381520ffec0cb4684711ce6daf9672ec593b3dde3f1db2e3f26e1bfc79b1f0668debf5865201e633a157594c9a44545e1017cb7d3d11600ebcdf9bdb9ea4ef9dcdd7284090f4908d9ea59af6540401ff5879b469e8dc02467491a16470d851ccaa45136b6f098dfa92e15e4254bd4c17555d1276760b01666df17b771ca1ae1e59556dd3c4e7a7b163fd4d150d8760253aa07185822cffe904a6712294fff0a34c8a39beb1994ef78ed8a8de126335343618b7e4af1f7792e082dd5d6739b06037b17f706e436225b8b8dea6acecd0df74c39fcf9323401214de1d57d38c15a40bb920eb1341ff5a2084c67b2537dadaf72c8135b99b4740a02627fe71bee901561c22f4d8640b5151380554d6096c998dfb8a59f71b4d008de7e941db2777008b5b5afa0f717ff04cbc4a90f15032fc2559aa284cc92516a507b7516517eb478e5d1970065c941ffdf306d082aeb39e87e117334ed259e8a1433868d90fe689a91cbb0b6687e0a4d517a4a699c83945a5f77f12b05fa7600b5e02d3aaf9816fb39bce6aedc0ba5d5a1caa76805a67230d63cf4f133f46d19ee7d3f4456b438476bd3f6ea0d3e69da63f0c306a9095f2a48a28dded28368f999f9736017a7c7062445e3c002fb5ca06e0dc5218755fc4c671228fccab1af5f0a6baa8597f86b6ebe0ec1e8bf97a8dfb833ca767f30d52de994ea9b3a43017ec10569d60889e704ca7d1c358f6e625e85a46e021bb1745ed4175aa9c0ee7e0644d7be59bbec9e01d192593e7c125efe49b6915c3551a1fc1356fd6c8899700db46be318fd847e9f16e6a2b100d4746a758377abb4fb9afe428285efcc5269006b0d3001b06a4000957d26247b5935b157863afd91a41d7ca5c441ece4b22f7a8178fc5e46cf96e2103ecf9db6e0e28933d227163cd31cc44c2c988b508696f01081ac49b4cb18e839f1807374b13ff3c530a890590a1bbef00048490a526e1e55fee5ca50692cb72003bd0ef2ecb64e60287f8814e6a99eb1852f7c148a3bb53d8126f62b56abdf6234c321bd0fc44448e06fbe9dbc2d8b722ff449754d6c64aa14d92af276c1d3d0b6420a0a4372917839c084191884c8932f9d73d45ce1e2bcb9b5463a75c66f734cceb7a7d78321cbc944828923d3f9f24e609c890f9d43cf77c585f6b89e3f401f21f50144184e44ac683464ab5fd9ba47a4e9470adf72f7d832ff7a7da94a37f2571bb84f368ec41948661d40ed80dd6ac47ab693f2ec408c961e2ea3a55260db1afa1c4d3dd1d0d8905f02edd42432482b576b773b08ccf01caefd6fc5189cce3951de90ef3137d45c075e6422fd85546432feaf28ee89a66a5e39e02467f8da1b5e6db1b59a241aa6bea888c90afed02034c4047028261528ba2947a71c11ecab8847a40ac9d7e06a0625d6e7f0763bf006ff89549a8d19684c486c4482fc91fddb89dd7dd43e777100f81944d1b4a2fd80b1caf616ac98e1dfc53b3b31088f3437934d692aef07099a090f9f31dba8d9f77454729173417c86f1581f7047f00ff1418dec58888fc8879fae324ce93a8eb20abaffbbdd08de52e875ae11865394ea0e688da62f9abd7c42a30f8fa9d26fdd1828f139d01c4c3482ffe8633b401b1873a1b3fb5af14d3568bdcad56e0e313909b77560713beac4201ab9099c25e61bfe540b4541855f94542622b0c8b39ef1c62973e396c72e66047c9ebe32aeb5846bae2047959ebb8967dd199a7107d567046c5dcfa40a75b72fe4e3dce4714e2d29deb0a2462b795d735ed35e48cceb5ed00b9e8e93b5403636fb691ab99bc41716e26358f4fd64f2908fc9b870b128f0b2c64e6fd220108a74df39fd95d6caa569435356f00a9324718c51bf1cfef8bce51cfa1b251fe8389b130ab59626c06a3d1e1c49a68fb442ca7b521a09814db18f91be7dcdfc1c88975def4bdd4cbe6488c3a132a20182b8af5fffcf1f5ed986b3040cda83dcfd049f2c75e67d4925364de9e4311d71899bb6392fc75172e50b4120ec80d75d51992fcd7234109900c7f77d72cf7865cdbf83c9e1eec0aebca3e6d66d6b16e5caf7d455bfef49e5ac9d526baa28292086fc014c45e89f337c0981136b057c856247f660bff2475a167a101c443f0301f0e74f512a8e69157ceb2dfc62828fb69477338b6f2b35675c5ac5242048b84ea702990b8288d0a81509a82a240d05f55ab2827ffc58cbd925478e707c0c94602d77e843a3cba2f67188237d9c964a42bb7cc59d10242496e635e181a615f7dcc91ae7a611aea51277e667038bb9e2a4ef67d896e8d09c20b14140789948a5649f6aa98e7c8a3f1928d728c6568a58f7e24a36971f39dbe6093e8f759ed938c9b450b9a87c05cb63290bd71219bb1f843252657b1d3023d047942277cf6c4baf5a5acc962f60f7d260d7a90e6c2a6dacd0e30bf7b5ebda66d8ddd42c613bf3b3f082b7cf3b81a25ba4b314213e966b61ba7592fc872fcc8f0a7d94de1d2bc58cffadfd3d702d9b80a5cef765d13409c4002a3880c9b8782a54c901003e840a2a5ebf87035ebc58292fa30e011eda037cd0291439295f53bac0e60d9c1963e7d7fa78691fe40c0cad18012f0870f825bc51d573c60d49eef0a7ef66c24317570adc3e35e4647dfbf3f0f179c2de8c4d0f454445cb5c3334416c1fb47b49fb8e89120d83261625eb0981d5f4ebed51d4004535a3bb0591c0a1c997e1f63e76de2b2e55487e25ac275c8c0903f552e09e1d1f89ff6f8daa904360ab3bbaf3dd33fbb0178fb3f30e2be9a1248f9e85661d53f4656cfff94961ef36905f41818dc3319f5a34512a227e3bd6b9b2fa5f7456d2265fdc26c577f72903950e81742c82b397c8ab58cb3302acf9e8f494838aef8f18b12b25b858ed6bc56afe1e2377567198ceba461de1cd378ba9e80b8861911471ed94d0046931ea372119f8aecc1921ce4ef4de60f1b3eac201f1386cccb7f672967efbeda19c92162e7b169b4e101b4dd881ba5a58aef09b865a774bb5cd4aa2b801e0a491643409aafd4f376055a9231573f8d1426f7e993278616aa152ec7e4b52c8b0bbcd287a2d8b2a655b6773f38044958a2bcce1058ef9d90500dbf1598a065c9623f8026baeec0c0cb3916c2795552a30489d1c44c065ae829b32bd77e6b24108f87de664d76e3bbdc10df29e8a8d26747370990d78757a2fb6df66896b7b8f83bd050d3ba647eb7f5985182d7a0ffc8de8397280f5751660212328cd20e19d56c42b040e56fbec2e1e09e5c86468d413e466ff18fb7e8e2ff953f7d9b849c8aad23a588aa7bfc85b7af727ae80afa1fd275ebb44f8fb6c0c0efea41ee8b960e99d316a288a86d4194f924b66d80c36caf5c2d98068309f89f4103165792751ff0f5f90706b5ed49944905a3502297fcebc9b191ea570984ac0db0c7b0ad1ec0794e316fce3f457bcd3f22ffb8e61b9da6d44f41a4be120aad7a79d411342ec059e86ddf272624e2dcd519fb9880b9c04fbcbfffe0f23f9696a25f543f368e20328617fdeafd16873cc9da922c89b791d344c5a554b4e2bf71592e2ccefeaedabafa965c7d38a730350c5c4b2c5ef25c72cf228c1d526ec7098a4c18e2d6df2957d074c8ed05ac03625e9b79095a16c75bcb9ff7a1001153fdc38587b8a07cb7d7bfc96f1ea1716a1b92435f1abd6fe5cac7b870e6ea8c4cc0a0f3c3533c81a189407ecdada8f9ee5a0ba27d51e46a41125bea4fcac2993619b4886edc25a0cf6715b7d1af8f033fa2d57eb4c4c9b0822fd57c5eced642e3b439f0357760f07187d630bac7ce3d8f307847be28eef88d897e1a82568ef868de79bf96595c722327e1a0eaa7e7cf3298718e6dafdc045caa3ec9cbb68cf0cf4f67e11eeb4b2360c00d0362450a68ceb24f16aa6602c8113f3c9e2daf37ecdd27b7f5a74b87015f797d3f2c99df4bdb560773f9e021324375af6d48492f1b9cb373076e9bc40ce03c5d31f261ed2d2048c78abe8232f58c73051d1dbd585db98f9d3e479743ca2f342f4e2dfacbba3eae01f8b92cea254c943cb7794bd058d6b1ec7fddecc7f826a19e251bddddb78cdc1cc80c73208d8354f44d88ec113ef5df1a8d32b2133be952c34ed0ba83f53b8d6f6554993099346d6af5a0127a7839f9e9261ce47cda82dea589b752eb1391ebfc04ec463893504d4680d016413eef079fc662fabf5a7f50d694ac9baada1b2e9847aa46b2cb48097d354eece103b385f9dcd72d64f1076edbf07ca175b7c477f78186e449dc5029220263881d2b7774a6369747780111ac41e1d6b12c543ca516adb5e4d796b9625e2e37e7a7599242a7cb76dfe69546482d704d5386a044b833519fda73f29a0cfb4c999040ffd45c32a4182844ff0e4064cf0179783fcebf4af65907b03d522f8b8c42ba0c0ef4502181c269d6fba2a07e01c916c41254fd3dcfb555b07a1fa4984f120b509faaa5850bd7fdb60000548f0434dfd367a954488831995043af743397658bdbdb80615757a90b02aae7f5be5fabf80dc2e496978951bb5fd732af69f322b3afb2d840ac730d19582f708a6456b327cb36125d0b8c8e2a05dc051fbff84a2eb7c674d17864cc58568d182de814f0c7b4ac13538381091ffa794e93d84632b9f94a969151998bcfee87f61f0791fb8279c3e90f0a54520d543c717489a7d2d6b4604410cab9a30a12b2e63c182276cf88a49bacfac131df5cc07c44f83ce52934ad9cabfe882d498bb56916b599145259887f660b9c5a8b329499b3b7197b6e2bc436bc8b94af226e19fa51e0848f604592b29e23c4bf6b2a125b1485489b9f59908216507b280f5d8f0758ad4540e373acd3f02464a85fe151c996024e11d935fc288a65f4d6d808acbe1a2ad5a040efae82c0b36b5ab46f803d610f5c8afb5179764ff72ec76d01819cf7beaaa82065c7e8ad549c057b7a50071e8a717f3d6bea3f1b7a16bb624bd9116b6da4e4f72ac573053ccfe54c53fa3a723fecf75c158f44e6542e78b969d08488ec58530f86fffdb1f35942c49940c32df6e83c55ba273918c2576c7878c0d962975697f8c04fc665198ac910430f6bb4b497ac16167040b53be6743c167c025a3dc2a97c28739aa2209c1744b7c7f35a9b73175cc54cc2d578451309a53649ed03d49d0bf2443203f5e9037bb20008053ea1b1cf306e3d084110e9062c0876d6626ca057c0444322217a6d13467d79dffe2729e655614e81f048dd2d7a7e742b6bf4d196bdb0982e4f67cee1dcc0ab99683e2c91fc94ff7a96ec9ce40b0d781f52d519fd08be7179779825a54a6deb911c8d8c6cbf55cd258761ce5579d6dcc15ed7c49af9a907274174a07439ef3d0d5315b0cd821733e4b4a58710c6681b1ec905055ba882622b151bb713e7efc1ff0dbd1a8ac2e3c10c9e8557d6010f4aa6fb712eb42daa164f70ed58fe655f9f3c8ea22754907f67abb659f922abfc3ad2f544e98b1b719acca55b83fbd806bf3c611b0224dffed3d94ce98aaa35cfc0058256b26815ba67bf109433acf4ed76bc079a889416f3cbbffdeb9a0b2203a3c95e5edc7f19fef8c7c7bbd42307ece745535d9070d46d47e5e610896ec226319745d711b6959901fda78a27845c22e8b5c8dbca22386777f8f81128e8347a763c6a233665d1d08c67e791c03c98ce34adb730c0556926a74b27769db8f01adb4ea0f859f8f681d19fa6befdbc96f6171565de746","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
