<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a5ce94a86512ccd1dbbf6338218ae5e8fe9793598df0c748896995b95dc53753f8ffe5be1f33eea400c231acda2d4e1f85e22885facd507435c919ee5c87a84fa69d516ca96591ee6195e38d7d1d0fd3722228d0254c8e702b02bbc9391a63a31b65a5deac87b70bd1103487ba4226f1073c22d601902d527bc3376aec9c61e6985f4c87eefc6cbb4e135035486e872e726326147c032b16776f20b75c03a180a393df99c5107bc5ecea265207796e786512d0234bd2d9e1dfb6adce76bc8c4fa0f10631903a991b8d9b6f41d505463bf2d3ac1019c6ff4344a005159440a3280652a1a52bc45e2ac9c72d040f4d33a39d1156fff3a98dc71127f6f4b6e3646d101050bff9079701f2470b33b5c09279ddf159e7066db5949dc5eee933f663d8fa403c4e514c14e7daaba9594f37f9fc92d3863a5e0936ad6b5f355e317bb18389a69bde1d02ded17317850c1a2286027701d28ca93e7e458e69b58e4c17a7c5317a6b7d6027e6146ff1fa10cae9ae0d535019799f4aac151763d8a766f164ffb6a81e4d8b4fc6e04c1fab4e49f2529631ea2f825bdd67a994e2cac5589a5c9438c00a254a2dbd0f5f1d8d65ec4728911203393f6b74355f0c098752df321b89b6878a93d8ced44c3ebf87eb73bef46b7f588e4dbac80325b05a49ad982ffe3db1efb8a0a87be3f1ea762007a796889142a346478f449f97400fa62ba94f36a5cc0f93a1d212cbe5aaf8d0c5627e6405ba30986c136bb73ed0a0d260b96f09b893e139ac600cfcd9b3f5827732a3fbefbd3968ec742bc292f92f1cd22f3ca8605c3c477a931273cdc47bf089a4ae8de94ccae9ad3dff7dd87353268e716a70cf70f6ae6aa96555dbde8ec17d042e2f639d8067a3c162f7b464e36efa62b048695edb53b22fe7e9ac5294abeb3c03cfcc71f4e4e54ba9f90c287df686436c382cc8873f3600b35845ad30da3a49bcafc13464fd37e39034ab580371cebc8484d2067cd0459d5634c5c029c7b5e7010c26d426123323abaa27cd71d5dbae75b9a46dff49a25e003cd76e7abfd9862845918b78a8aa15e0f950078c48cb4b00138ab9eda0f6bdad45b85ffeadce340eb09844950fc7f33854f30a57263f0b4291dfb9a0257049a76877029edad9c1ebb6c186772018de7beaaf2cf6696dc06187e7e36dba13b3835a6747b1fd3a1a1cc00370c4a49c052f20957faf6eec1022b7cc8c847da544d1236234eecd43cadbe412828f46425753a3b58026d9784619533b1ba91ee03b09b1da632504ed7718c9e6a6c75030e9698b4b5dbd00d4899bba65e48942d4d74d6cb00842efab62428412d3384da4210983f59c7d55594d982ca38c134e9541d22b5e3bfa90b90b0790300eb3becdf8b09a01e901d94ab338010c8d6c51a419d5e45b5118080e9b2fe9ab6b9d8e74da6dddb7c4fb326495730134a742ba9f147154fca181559f6beedf8e3161ed356fcaf4ee1223ba29e1347850c491cba7095dbac87cdee000d7523fda076d6764687b5134c8f965f52ca927666f73450860cbe567aec9152445deebf4b233905d3a25e9fb41da15ca206636fc3880a99c22749967d0da1cb8d604c13158db9f3d3c1745a73bfc6885796116de9a5a546c07457d791e87bb163d3a899a96faa4ff09288027c5bb8508fc59a446f638be7c807ef18dd58304211511c62c28e637e433fec03be1a40c72d8063567558ec2fd9253eeb348cc2ac060dc4a2a4f77bc7697470575339f1ed25f2b780850a1fdf6f5fca725d1594f3bd620220becdb95d8f1eb6338af36df9adc8bf8ac7666d7a74db810b1765b7e58c1ee44a156e3fe96901eeada532e1782f4d0600a7113c4f01c01ed3bc94a2b614b4b43e23cf135609cb3dc87faf04e3871b356d39baaa61d9f1efde6eafc145a282338ddd25b64e9a8c2976ae1020f219c1062708963916d49a69d54159b7ee6ef2dad95e43414757982beb9af03d4d601253e63e1635633030b4be0443c9ff92d7fed62efee86492c3a9f53961247313a13be2ef5bbc0b26c9f4d72ea324853332322f11db5a14bb37124ad60fb8b6c88535044c1cc31089f80f730e22a69d9ba6685c24cf77e5dd13d8c11bd3815fd518d9e5acca165551a746dbcffceba25f55a84ed856356db5c4c8f60dba13589ecdf361ba2c998e3232cabef899259c1d99b0268158e14acfc6d99f71ea5783ed3881b717043ea58489c828357358e6b983a878283d9f82bc1dc045aa15aec68378fbf72f10ac5422aa6ec7767c35c352ec28cfc2f1d50591f23f16461fccd9ccb343f9b3d49de63681c20c3b7b81a50d9a5e376e88caaa204249704ddae16ea6a8c7bbbe7b1777b2876eaed4eab4ac98b70b44a0f7a980ca54ea87a484392585d82ab9c40c125bb9b4760c6c1724b6d78610995f7c5e4ea25038beb8508c4f63821f92636656b6e5b0df0459b357fbb68a6f22f411719da3043a2f81672e6135e6227a4f5113903a76cc552b581fd356fde41eecee625a097d832edd956f8767e4adab455adbe98390f6c366657b1189de5b46ccbc0d1be1edb9abf4ca6a915fbe6a2459e95f1b7fdb6c65f1d311f71783e409b9a7412e6585839e29047df081c24c955cb88807318030795b00d57cfb2449528e43a6f1485b0833f839cb195a92f03b91dc34dd9831770760c782788533a854bcad5428bbe884ac3044ee38a63a02a1dc4d31e9690a2d05256734c9edc7d3fe693793e365ba264c005ff54e0124972b660845ca97c6419291afb055d9714c7f9fe3a31aeebeec5498a50cc356b153cdaca6580b30e3d1aba56a6ae323c8f10eca753c1d22058a6ba8edfc5eabbe4bc26dbaa6fe1c84a52e34163e04049566e61800b64c4c5470ccee19c0b40c7dfc6333f4559180f70c86b9a28eaf347d792dfc1a16357b38992cd807894820a12280d9d4d32e5a00be0b13cd75202e59423f91e136fb446bba6d3ba454b6888299a004222d9785aa117e70682405ad2f3a48a1f635d537837fa44cc3d2fc82a50cf3f4074fc9e40bfc741b67138c9329f3403825cb37fd67fea1d00ab3c9c7b5c054aff2420e48aa2adea2a9f68bdb88de403a5a16609724a7ebaa98b81817e515467847b8894558c4365c630c6369f71e08b5e1386a6b50ef1d395237a96c6063c854affdb29d27c8c8c45831efef675e5827b42ee5e16c3f6c6aa308964ca5ec5b0630a38d5945bed1df1370248c110e36c53c40c3121a57631de8f804dd4a7e699e897ee60e85258f77fb4287bca002f626c533467ac1819663ce1ba39a1ca7a7082a91293aa4ad3430976c4b0adc3b251b1d934d8f6e2a29ac08ceeb3a6ffeaa8fd2a36e0633e93c194e97433fbf224eae775f27e0e5d42341607772be0dfa5f906bf3538e15da3e10fca749d7fd3e3f79b9ed3382723d85312f6348efb3f95a3ed26847e77eaf9de1bcfb3cb90c2442766636a0b7c3351693c31551511390f7b8bec66f5767a8a3eca695896e60c6b81319949483b6ca03f7ec89f4723393324538be81731fa1adb75f50180aa69eecc1d01b5f06492856469a71af66fce72462068deee7278e5b2c08c087ff50a293cab6da57c3f3f4c0a01f2ed179da2d7d3897a7a9070700b3357eeebfdc05bdc561def11a41d2d4fc5e9f40cd62695a9154273ea8ba6153783496e7eccb9c6fc316fae4bd5ce73070c598d7d73c5084cc85cbc6ae0679c53d0c67c1d66e5bcc402b4b29fb47cbf4b9e46aa1011cad9df7af396c1521bf399d96fccd4d67a3f69e9f38697fa3ad3cbd323126df4791fdf6f96b1afc19aefce26b60a6c30735b6423d36e23fd5937c9e87466da5021d5a700c399836f64ffba996bc03ff31892c39a01ddf0dc8c769b3af8ab1e0bca8d59c41da9a53820aee7a5773b6506f275879b5f12491906680e445bc41ba7a868bd69570405d6c3c8208d413fb955a4dd3dc0c5ef0849bd0fcad340883a31fe28fe01ad1d5b5b471bce0272baeea4144734f4a6fb5c9c1055423354a7db73dc681420a4476730927769ddf8ecc8e48b18294fa246c5a477505eae5e7fbb7d6ec1b9c6fc0b2c1b0143841ed76fa19d32635ece27e80d8bb31aba64f8c42141da5485a58e5d868788044dfeed8942e79de42ac08956efafe749e8c89550635f33e51abf0a7cd1a370f6657faa0356a8abc42f7db8ed9344b179fb78b0aa98410209a7ac9687e91e3a305ac7c29dff0f422113bd2f9a3792cffe975d8345ba01305a9edbada9226e30eb41d7fb4152a886fb69dc976ba029d952ff48d0a3d6c9f7ec90f8a427b524e11078c48cc1353b81bff3648c5b7a1bd64910ab89cbe37e5e9f2ed5bb511b156c27659bedb0d232d7d99a04cef68eb835fc582e7325404755eb326b91697a608c476ef8f8eef6cd6420bf350c23720db0788b660e6b0f8a89dc389a928e73067c66410ef529bda585058915a830a26aaa804fbbf8b26a67efe354fc2ac2e598f0ece54a6bbba20543deee9e5f0bd77f2cf9c1090666176affeb17271eb7429871174775b2d61df56b08fa6c45681f74741349aad4e33bd60c85c1dfbf26b95248ff1182e1217bca54ab390c1140843c5e04111a96b547d355455288d5278219a761d2e8704aaa3cc08795d3ca454ee1bcd1b1bfe68b297bf7f09900f72ff0fb37b58791ad178beb9e4246ff84067619fa4144c264f18aab0b86d12011dc034e5e032674ab4aa78bf6b7113ea5be6401551702b0c0932d931ff02f09deaf06fb8fd21b8ee41b59bdf6106dae23d87a75ab51631a36151d62d74c952b886ca07703ca1adc4648d5c1232c9dd1b5ce9eecd3cff9a3f6e6597fb948ff883f1a6a33e7acff61038e081303093c06122e215a6a337c95e572aaed6dc5a7549a1c766c03e7bed638cb32aa2845b679f4c047927297f25063c2f044aef2df996a1753d36679c65d9715f1b33b1a9c6eaacf03a153adc2e49997aa56b93bab6fc6bf6b1d18623ac1126cdd54565ae6bee2ddcbabca994e9573121cf96c72a93f985e6976e5ae45f4d26e257467f6ec95293b210290854e0e00396f843412367abdfcee414728d5a193db29771309e0ddaee856e0fc54b2c395a9dcadef81c9c9844282f54b5a5351063fc7e679294ff946b21fa4e5f4238f41e0955aa65315f24045813f42523caa4a7c9528a161a4de20d9322ab5ab4a2218c644efa59930ec27c5d3c5c09b6fb8a520409b352eb1d50513822b4e70d0a44670501088534d5a253f18bd8bbf7fd5daadce80259d342b44dbf250935e40052bca7b6511d0d65340fc3a2fc5ac1581276558c755b4a3424f8f7002974664283b9ef9863e42183e1e69399379297dda736698ce603dfa74bd69c8904adcec097e049f5bc01488b8a75e691ad1940493c8a44dc684f2a746f3260f8694b850a7bec7c94cc90d30081f6a51bc27bd2666ac76b1f14b7cd795e677c85c7c1fc226a2d1947207f978cafbb451ed30a42bc6a481ae126f720690bc01d440e078bd642e4827729c13890f364155f4e827259503490fdec3a453e4eb4ddce5fec43fc72008fef0f7f9e23bd595a2cd52c6d90af3931320eabc40f23122deb4412b614ac3da54861537e9b15d2bef30b3b7bc4658926050c1f910e690c90242505a0b27d81aa4d7d9f0aeed96ea483238fe34c2d4bc5d3171546c3474eed796df18c4b2e2a8a15239091e4f5a462a1557c51e16626b36cabb0c292c7b159ba9b4afe4ab9866cdb8c3dfb4a2a93c8a99a0b936c91c6b94fceb324a3e8f2dfdca6e4de9487ef612972ec911c01d56a61bb7cc173211da25bcd23e6689cf505dbca81c3e714d074500fae6bcf3d3723fd9554b91d93b3806cd7ad1e29d023f019eb0933eade802b7fac2c644c00fc2f81f3b5b50e3181ded88a39b16d8f57cb7c1657d45285cddfcfbc9938645ec6112fced89e86c42a18b6d1eb4fee18deb1f9b2d224f29c9c3493f9d70aa7e89d3ba1d72157e911f3c5e6860fb1a3615096d69a13c393ace99fa3b5e3417f178715308d4d439dbe9856dd4772f0de41982f949e432f43f865e946a7d47823c8973bcd9fed7f171bf03d13c3ba299da67eb2b8810f0b45c70edff8c2c6f3440289a95010bd80cc37a3fb918aa5d0b3df724e2d85a389682f1e8a3e97f9b0cb04c8e3d7a66bf6163b182b5bb415aece59019c87477a8d5870dcc43e86ebf616782ba692934274d602ab2394c4a4bf1c31b905d42181e2bd14ec4e5a67f5493446c674852303d74e686de1123ec6e1b06f1eee18fd4bef6a6abfc977e209f7528702be77c7d219154e576e319844202ce5736d4e5a8243978af47125799a30b62d96f67c02ba614fc7e96fdf5b88abcfde7c76df1eb1d177c7e578ab20eb27fea79aab73f587a51e709523c774518f54268f655bbf6bb0b4bd17a99fc59c206c0c676fe974b983ed5d41bf8a90d5a89bf757139e1e4696199bc99fea1be7ccc2494d8797ed1b54e33cadaf84b0486e2a47487b843551196b1d521df2d29d7f17c5158552a0673cfa64acd07bb15a9b1379fb708bd37e3a17ac7f41164e315daf7ea8d1beeef61a9944f4ec540a5f32439be64dba6e176ce5347ba5237cdd38c4543f6c7c037cab6cdaa29b8bc5c4a2fc1d58764ac46b891e82517a778701d132a75f5936395ef14a39612fd82dddb2840b1440160a51372abe422bada253f8476a14cc608d33249b706257d0354a82d233b4b6860067cec1b4e7cf25821e5dd0e7e5adccd981e4e9e3e41ab93952bb78dce0f9fd94667c2da974d2fc0e0eca00d225d8e371345fbe47f3c5cf752cd7f1cd1a4a3e22958a9c634ab9376d8b929a30a603a0b61b3cbc304fab8f36b167ffc10e67cb51e5728c790fe532496e542901e5e1664f1f673bbec556c2c02ef408ba1e83dbb5ab3616d30b6fbe7e6e63fbba2b835236dbf4a7aac42c0819fdbfee7bc2e05d249f16f850998eadc8e4088a90748fa202db3bc7c6a8a529a57fb1a8ae0bc80bf4765e5eb6dc5403b187f2213d12ecf5d9b5c973064b6484e88e1b32c8bcaa4ea8f56f8242192b5983a77a8f1a57565b2e2e598ebc0100f7ceeb259a1d40da607d227b0a98d8f987e6f55a0e8e4f9ea9144b323e744f6ccd9fc304658d081ef1512a9ce38feb06419408fb02256f85300e187f954eb4290c2c5346d4368cf048e839edc645c0337b146c2c7a2de7881d4bf3faf1ba8f971b252015dfab21a8f2e6349aadffa08288766ea8a1ff91cfcf9101c08cfa56358036b55bc34cd009df31f07c0a7b883703a40b335c1f9e3ae7028f8beabaea060576e52b91f73dfe7a1b7496ec283d794c0f1dd02b284ed233c4bfe6df4c0645650e8b6a3274e93a934b89e614e1655b33677ce4b7868608ec9ba64c73afdfb84b60e113db4c0d8cff1d0fae9bf52645d71c0b5953da2ca5310a7e46e59f0d5f4701be7916899eb47429e014f8f0b4bcc7aec1ce79fee99ec2290eaf803b58b4ea9e68628d811abf1c6dde2cfc3911501fc19b8b8a03e0430145995b4aa52eb0b7a06ccea8fd3c36a8480429d357aa540021215a3cbf45cd4bedeffe7759fa599933e7badf7b9019d16a0915709d9a520ed7acde30940b56b23ce5baaaa0a37182ad6e5debec75ddbedf936206550322da43db8a9fbbd15f36fd3ce2766c75ea33de225606f541d54cbc5d61935cb0e412ede19e6541125badccd356a2ab904d5475eea60a29874835f7d9fbf787f336341b37468eff208ef21db798efdd6d72dab4811b916f4f46400ca11614089a87fea6b567b037e0a0d6941d84dd43772e0295b1edd36da0b79ddaefe8c1d42e2761278a3f97d8670574214615b3f2b80222e1346b259ecc48226b8b41a6f23c019afee2af9170c846f0435bcf8101c9a57100e57f3e59cfef3e07935b58d262c5bb9347eb1582240349fe4a1bd3786c175f905a835d600a1230e59ca6d552470e6a2e8b8ce7944a56ab61df3047ea472eb9fc01207980148e24ca5e1da6bb007117037d7ee0846192070000b7cbec0500be2883da3a658bd95707edd8b827f424c65c24ae1cc7ecb36b1ca078eb32574c3754de9cfa772f40fd1a4ec92e7ef1abd7801391600d1e8f7da7af4eca3d8ce1011967b058dfd8ca5c0052eade5e6f771937cde9fc1edf05396edb1bf8b808e9d83d82ce9138daf8dfb250deae9bd1a381f5065fa59b85f645aca677bc3704373b0efc36c0827f957187c6a9bef89ff69594d13bd32b44acd705c1d31553db2a68d2830848c3a2a9f729e7dbd2f4143e5e6e25bb577dcbe0eebef4a30302b8f58dd2458620957f9d9e4fbbe85e9f3aeecec7ebdb7f95ab6bdac30f1e68314dfa839ca426a51db7c3e5db8103a5978c4177df0447ff73ebfa8fb6b3c1b404044358997573e14c12d928b568c2b8b9b4eb1d2d5146e922aef193f79d684a18201dd1f3a6b6516c34026c349edc4cade451c3be51e3e06d243e91593730e33ae483a6b0f6f337f6a1b40d70eb566d1847922b9c6e28077a8aab88a841556c59fd1f15c1ba5086bf726b275be626c907c51bc4e7117da293b8b69582b731a6adcbfe4403cb5f3309b85623271e35708485191f0849847778f052e0f13d8491125a7ca4029b512d061e6fc88a41debdb9e5749615ded323a34e5d2eb0396ffdfe9d64c00b759f4a56c41beb3351e69d7eb715cf4b092c987683bccaf7361b482b8c4d50f53bdb165baef69a3cdbe0bcf5aaa389fc74b9646b2cd72c2385001f962083754b368464247f73c276b3554826dd928eb3d92cf5133aa123369adcff8c507a4221cb82c34ee5fc80a292cbfdc42fb552ff73bb2c7d7596020355a3aed0ba8ae021682421b7212e6544d4b7a9a4a08f66257027202668c9b6862e9c951d22488428f9e95f4e08b8cb564135baa03fe4583b773ff356b1ce6bb6459db6fbafe3df5bbb9d4b56fef46d815d70d8b6998c8d2b3e59c2efa1b7d0c847df585ed0f647c55c67221c4d8ede03d4ea496319c8f29fc972bd9e1b07833a2472692d52302b91dd0d234a0ccedf517d09d11faaea48a5cd16b1dc5c64e24927c47baf8795d959398055ee3a99f08bc08a4761a4b03eaeea773bf0cf84b4b6da96cfb0d890322be6dc7ca3db116e221f1213719474df1c980c104ec6c26e315fb2046866adeb4034ae8ba19602e470163fe024a6da079bb1c90744b16c81af3f4b97285c229f2e919b87083ba122fdf9b1778976bb414e31a4d4d6da606988dedcb420a3c44d41ada7dac1d286753c4bbe0a730d88acc5efc7cd8fbb0f0eb9bb84267e8f6812e25716fcc67de5a4e181cfd55dd4e639c451f7bba139a2d3badabc983caccb8190ea2f22bbbf953c66518e802dd1a4ff58fa892bf5d9cd274a7a7e0a517f0f592354b3018f98d0d01edd6f31b6d93604ade8b4d5ea4b0e9afb04cd7b47851c92ea0772bfe34bf207d95780dd4d23ad7d8384821d476ee03d2b02da9594178c6d02b18b60df4269609913a8d6311d5dfce2986b80c02b6b7446f5ce4e79145d5787e2cf129ffca4239adf2950eaccbf9c462b78dc7f59cabe99c5e30115bc0f7868ab8d2df82e69113e5c9932dea0e774a3430f627b2f112def1c42907dba969f3256e32f06cc52ca65ecd14835cdddd614fff46241c25b739f7a56bb31608f358c91928d16bb7837b732c13144cba2015619ee61bbf78488cb1c368494534e7af95691b06e26bd8e2240ff5203d1c481066f4bf2714799068b5cab0ed1a2643609be5582cd66566886e1bc053214d94ab5ebdfab2106e06d57ac33d2458917f1b8dd64ad7f4510f13a42c5d915427a7881ecac7fc7412b41e86cbbf533c2b522f2acf90bb107868e13f42fe8243d13722a25fb1b9ede7fe7e4f7717b58db80e22ce33af869e15b6ef4fbf4945a0f3bbf80f3c877d028fa7d403a7c2f0dc2073748eac5e311b2dfac7246f5a0bd733cbbbee2002deb12e8cbb0c8480a0d77732a1a5f0c75d97ff49041cd0d106e1b05a11e15efe90bf454f368473b692022814b354c022e32a5c80fc35615e4edb60897a396d05e833f3e50ce760a8ecb8f32083507fa8e272fd74072283234698643126c8e32effae18abf6dedbd9a3f2e890a784e361789286fa02567a4ef3d7632fc13b0623624fd457811c8330e5699c9363b618496fbc5dd0cbf46cb097a7c33a7136e2995733366a563560acf65a23d946491a7bb780bad8de36fb7129c7882cbd02555fe2a6a004e786972198a02ecec0f5c4629188fb38434b7c194d4978ed305ca291781f1494ed9a789c22b2b3b47974a5c6816381886e810dc2fefbe02eba6595ce0f2a9f1b7c506e01e54e6a57905b11aa46e638a54c6b365501ddeb85d4d8d58d7d64d407ec6cf05eb29d5ffb85c548ae588b12c590db1282b0c08074adbd59ae679fcfd896426a94cd91e0fa98fbcc362c2a87c1939ebafa75f3d5f28990548cf7fde4ceb7db7ff2bb3460e7a3d10cb44c7a3f3e1a2d738e671072b6861535177a0389af1d5d1c5ce6823351a2e4605decb902bcaf3c9c098cdc7be4c9708b617350740dd842ce15f5e85375ba0a929f1c74409c6708f58684a1c60117388660bcd892d185b53a37a098003f5eedd76b88666563cc1ccf367302cb6660ab406eb29ae642df86e55ae768d355787acdbef550a4c4c98d81b51ca91e70350256a06da9c5043d2c589e5b93e61807fa0ceaca74781d6aed5c55684e4c7b5a77a08e84941ccf8124d6bb52a0c029da6f88dbe8075ed7ab825791bbbcf56163374dfcd869899221cb5ecf30d8f8cc56f00b063ef519987df5e0f1e4a9e5587ce0e074578617c3ec3ccc8a3553ee5bde2ffdaa1a5d2f68c7ae55a8c94fe1a8d612161b7ff5812b7f53a6423950bb29c45ca1173580a033ed41b23f7c72f6100ce9ae7b5440b773bbc3a06d3138f26aa9578c268000ae46af04a45ff52771f60127d1f584b856046db96e391eed9688e62ea244ea91dbcb812af3d682cdc961b7cccf9d8aff4e22ce2cb53f3168873da035323b83dc4371d3cb5dc4ec89156c6dd8b14781814ea52802dc41d1b61a7bac669bc98bd8a59b59b0333dd3a846772882628b7f96992d608a6118e784d5a1e7cabf65c3b59b3e92deaf390204caf8f04f0f2808dc57f0fe5bdf0cb55ca171f830fef1e674620cb6408226c533b76f4a11066d7937b1eb4f3cff3236c7089ee86c827f76cbdcae7b2ebca0ce9f56c69d043c3a6e08be63e3793d0e122f17928b754a3fd320cbcd6d79afe9e1f728df50a422c6557caf13f7ad78d687c2361b53b734a39ff5448fea52284d03d5a9c51d12c5a61b45e3e317224644726be94b36429dba0a3b6a0d15b3e28c94d7663ecc8010c2072963e471e87d9ac4998d57b27a60621e80bfbdf03f09d6766492e5da898a9cb36cbfccef3be444d3577a57be8ea2a0767f39bbefff42abd713ed49164032d64181d91cec4e28ef67c44c377502448c6be5b3419e7a84ca867f8e5e1641ae02b84d01e50624e33130c312c6996c94a8ce3837cff7e3b82457c0f8c56fdad57d87ae7d7e4e0445004e9514a32cae854160ccb420f2d467705e3a41fa0bbd5ae9b694add524eb4b2997f07521c3890e54ea459c36d59ffd2997eb0aa2fb6aa9a44f3407baad4fbe294827d16bed7eba8fa3be28fc0254bcb6407613a97a7bf7823a031b63a13981d8deef6f9f28bd8611ced6fbaff367daca58067c8e1c0ebe65d8a8cee8260fc7ed6eecddf572d1ed9992105cd0ce124fbf6855e3d58599903c7591fd5c9911e49954e41d8269dae936fdffac4d34856eeca1c8106193d8f486c21a5d3e664a648febbd063b727fdd908548778952dd761de18066a5aaa25189715cdc24b9231736b0dea8e11091c50a3e8fc1c03990003f34017476ee0872404b65270298efbae2e2092147369f8e18767c42080b573e8ca1918c4c82f6118a0bd7b507ea512c53b521e8fbd451ebb0cfcce5c6fe18dc9e354f0088b0197fac576fd107cee5ef9ac37eb0cf5aae595287db86496aa8ef3e9cbd6db3852b577d04fddaacc1a80be6be15d7aa3808ea3fda16aae4d3e01c4b762fc544a297b75a7bc1fe62212f93f0dd1f72f46873e3497ef534209c1ab09b452e71eabcb9a9d0b3b8c87dff1291312ed3d2fbcc55c87874bcfbaa34c78baa1f0a26cdd96468a772d5244210022ac68912dcddd30235cc87ed07f1bbcd84e201595aa88bd88921001a959cc7239d032fbe400728fe86b37afda619be7a7ed7bf974e46760815fcefef78a3432270b10d530226dae2a4067a811cf164090d842fb9c38007fcf47db27dda09dc08b37b2a99d8207bcc1364c81a502bb007edfc3deb7fbb3498fb19ae0344cd05a6ccfb495ff3af2cd38485b5cfdbd0a0beabf428a53fb65d8d30c0fe559239b772f8f4766ec21c6ba85b3a0d17c0e7162f5217bef8b946a3b6bca16e88058ddfb451106d53c4533738e0bd6c1645d7d491eacdcda318f55f80daf4b602ee45797ef2ad93d0394705fc07c952d5ada50762cf8f2e550a382d9a3f7a22ee1f7a7dcd1509dd8300ec3ef649e2c18d51d58d38dc51e26856b8e7732200768fa3faa9c59371dc219ee2301d4bd66b854b9d1a66d6e682ca3dcdfcfa67405a69f679fcf516aabbe002755cb47d65d93535dbcbb9ad0902922369c069146541f98b3314ec1c8ec963d6a6132a8195bb356dbd3eaf866bb4dc20e9f2808bf19dda90db24c8db62e6028f8f050da1d281149e00a7a992f476211354570cf2ced23696a17cd4db38fc24b58e9adccc978e1c8f315a0d1b104fb1720dabbfbe3597044281ec11cfb43e0e6ad728ee11226659260874e57e971b5d3a920559696bd0cfa9c46c66804ce2956e59c333d3b3a8e66c0b6ada5dc5adf2be76120cc44a4ded28a926386d788e91bcd5fcdd95e693cd4c41189f68e464daeea4295bf52a06d99097efacb1337a085c15a7137cbf755b62cdd7424ae3bdd55af8d1171c2b841d520a6a3665c6fb289ea3f8a1f74ab1a8ecf6d5daa8542c92bc2fadef85410f63d77168650c74c32729e54c813976b02773611c92f76694c7924146783262e70e6e3915a33c0c2092e65e7d88e01131cf03393660155f0c821ee0a5931ca935bc399480954065a05289905dd66a8b019d6ada705104c09047627ae8b632b5de3c5e1cd5896ef97be8288b8ca87383248dc214ad5db6be23632b34a7db6e11e9839872c199461248e14f862adc432113b3aa77c7daac45d6f5a0457a605ba6ce621c40e6ea052314add743f5610632670fbfd5ca1da7e65b860ced50a3f445c438d8a1d3c7393451b2cea89ac3b8f30bc8a1e5aa320acf9800219e4a9e03628a3a5cb663e4698ddd9cbedbd7e5125996820d0f4c59e3b849614459a2bb28b9a2e3d7d22562df6c0af5b12d715a882d0a003c398cb7344697b9fc475c2f04d1ffd6a9380e8214b91f04b9c8b954db31131d52124c0623c7df820db4aab7e0585a10a99de0e519bec7da4a6798b44a5a7c3e838273c5814f0a88572e04f3e5c887569f6d2da86ee7195380ef8f1cef1e9d8284c029b2b77739031bef9fcef88897fb2114373f98374f27e8754ee1e473f7fc6d1299857a96b5ed5ca331d92d8c91711e91334f7b48b0f16314f25ec73f66469026f92bf594982b01acbe8481a190c6bd8e19b593aadaed77f97a0aa685f6937884c91ae6b1d9ad718fc7b9449c4e8340374e9b27677c494f2cf823d92b5b588339602b0b0f576345df269bcb6507f2e31151fd60753b24a8d293a236df8908cb9deea9353848c94eb564d284d6702b98a6e91cd3db60108a33c943169b1e9b0998a73b80c5e5f6c0da72a5974f6b70901e8f271cea390705c5a234c6bebec44ed3bac9b8b5a7aea6abf8ed1a8d07120a5e913683f5457a342b978e19e7948e914da193b0036e47045101abaf953df536dd7bb891d1aa026fe474af2b7b3dd3570b54688010358496c4b556306903ecd47ec68b1c7f568138aa311ba7a9e51f7c47a464332bf3efbe07c703d92571acfc60d448ce2dfb13a712f7703d6ac7aee7e6cf30023881cd28d6c320af0d33d5a56d4229b9026ca6a70603b1e624e3e8a603d9eacd199519ef709721f91857343c79eadd3a38ab7c534a0e408b6f1b84f600432a49ef011aace5af0efff364cec23b8d2c6fa6b38bba319779fe6a9c1d96d075180a4c208f0e5cdd1015944e67b097a377554606d401e47c725af75bd0341975b6c965ad58a94496361407079e831610affb7830d113334cba08694c33338e21f89919d3e67073c1acf562beb4a307a0e98000fc02fad95fa4b2e1d001d34f1a6210d4d322da1ba3fbf35942ab22e3a31a1e6f2104981156555abfc48f58267b786f7d7d7f8874229bf6a7fe97eb9c1260ecee2e9fd50585375da3e814df0ed616df1c795f6b0777a26097fd00eedee3b05f39ef9e25499bc71646d40d56fbfcf8405b292a0f8197d842f4f2042fc5feb38dd023db579fcf057c4e05513ec6a2cb939378263a395198a88b29090d3c2c5ce045f0f50584091544edd546b67e9982f86226758f225be75bfd1624b64a5acd29c8a4536410ffec0bf803fa4290248d17af75f5b5c19892e83e914f507ba1c48905a88397408dfc15213fa6b62a57a39149e1ec923189e6a49db8d9904ee72871bdaab745e0818a66c5499a1e3cc2f9b90d8050982a9b93c993cb5b185a3311c0fbe57a2876f32aa4b2834b216bc96a3c4ff8b6383372b930ce7df9efc6d809ca029d10427a52c7e663f37fee8687de1f1b584a4be5ae4a239aa9c93c0d45219a5bfc92dfbeb70d071ce07e9fd3ab68affd1e140c6133e47e09f13d895e31040d2ebaf34e9a393e4ff9c4d1fa355420266219c75c5646a3780ba329dd224f9106dedaccdfaf79168ccefa7b2812ed7130ec95e85933c071ed743a2de23cb7ac65d2634c07d3c58c686437a39ee2d9e21c1b31c3f050518ef1fb3f52e822c934e37a735312dd0950e9d5f144290d7ee89ccc7a1bf4e7e29d7d8999e6a265b43c3f895480168e7e324a7868a674bfc83bf7bf5671d588a0f336766d2fb3c8f6c6c4805e566028ee5526d300f26c79e2b984446d58f6ac5c8856d45b6b1c9331d71914a26ee7eb153d578edc4ca624688f50680ce21f280d2c71fd298fae167ef43753e703824b83931ac95186f92504a3378ba3284070287d2a0e0cc65825d1563a5386aa7ded46e397a61aff118769fb00ab3e3be2e5e419c871fafadf9eb943650e158bebdf4b63a4145c606a4a7e425680c27fd77ab9c5da0fa2cfb2ca8e549b21633ce6f53a9ee57494374eff9411449b5f07977ef9978a1afa361a9a285026a151185a4dae9a4e5e3359b377c50752962fb1aa3cc00edb14de1da23e4643573ada81c9f972b9afdfe5e4539774ba24fb39359a284b4c4344f021f1318a088ab4ed499083ed9548d61c893f5e3e7f4474ebb38404df44c1e328ea2c131aaf150e092c018bd4faef36f3ff8a21b6e9482927cdc9a2d666836e7356afb2a997abbb636b54eaa6231625f45dd64111df471cb169a4808648cd55b5e7ac2efb6702f7214ff56c0fd1f9299e5d288640c29eff618cccfae4fdb55aaade264e8ece4605fcaed493254114a1a2641c16112415faddfbe338e14d34279a14a1963d8b57f9d1d91615110a1be1a921b6ecdfc3bb645c152b422b94ef16f46f0b4b7135484e394d72125487e65d19cb86037674bbdf1db3d936d82527fa7d0e343941b8633fb4ee1e0b9724956ceaf41bad3e9b27f7a1f22c798b1a3ef5051d264c0ad4f1fd6e857a52307e36a782fd218273353afc494245dedb63ffc44c3449cc0b3b1ce9dac18e23600365bb30c787731cb8f62810b7f1aff8d268606c4d6cfa4ae73cb5bb19f1db27c528d46ab982c8f89dd030be0fa2b67a5ce627390d1e95d50357d55e27fc32e531ee372cbf268301e28b4fe5eb9d5a4f10f74ea4cc669030ed0dc929d806d755e22ac57c7e8b90e1a5b40c01e2430270b289982e1c6c4da2bda060858ba055804000a12d17bfe5b4490f05849d85c9bd25eb321cb364647a42dc6dec77349477f80ff813f0991b7c227f4f5a155fc56777c42f22ce68d918ff7fac087af6bc26a61ea09e3368b2b88c4c71291cce4ad190c507ce5d63d385a6456f79bf5f2b7901ba42ff2736dccf6f1b18f11f097d5e5ba99fe72489df914d9f509fc131aea3981b62bdb8cde973dae5604688378344f6d22166a0dc4936b1f1b351eb53d70e41f9e81e3fcd3b4c02a256b335f5667cf6d1715d199fdebc8d27cc88b32dbadecabccc84e1bb60f090c2189b32f6dd1d8b12272d111f78f09060fde80d5e28a312fd5dd35c107afb708f855173ee243338da55a2d646d05f67673b78b72042545744362c35acb073079a0ebbe1e83a8b3d399ce35521117615516a5ca7f6368d79b8d0ad0082641cece6517b6990ff3fa0e7c21c7df9c866ae485dfe49d894b14368c3d96a2f9fb3704570201708df1188bd8507ad2ef0fa9de547393447cbc60edbf3b3703efc4f0598540f8082f33e5528cf0c190d46ea1a40df1a94c6a6859fa3cf8808fbbdb97f91655e273b8e177824feb35c4b0a4b20e9c36606b1e7d965b4c38ce122eda159c8e3eadaa6dcad9c4e9beb859c0b1fc246169629464ce2468a24b5ddde7b8d2fd4fcdab03e1c8c2ec979533878547d36f7eb5235699b013cc56d870853df39ce7a6af33e6e3237b0485a0a70fb0c198d43ce9c218843dce978cfede029bf250fe431b4faf95a9fc62dbaa9638edeb7ee2b78e108e450f7fec21ce6e519fff15b9f720407058b2d49494318f3fbd2e70f909f593dae23c9ee4a2af29c39f0a5bfb632c986dce8ea8bd1c345435b9240e7b48725c86dace7a0e4f481a6f335ce358f054c67854f3fcf645b47788e421818ad91c984280b15adf82a03d30aa6d0877a1ccb94dc019598beb4f59092481149a529d0b3df804ba2fd37b16e3fb8e5ae82cc105b13bd06c6410fbb1eb8c403820d55f31768479af59e459efc7d3d97ea029f9c65cfe63ef18566e2fe2239caa7041e4d5c77af954e2ca393121d0183d594a6ada0059616a1b0226b5e36885248546488aebbc811d633da36c2176e709cf26066d49925848180531b2de536775a9f634d9268142071c623c4fcb5cc2a3e3b6617b4ac80623bcd9a4219e78330796e857cc9cd788dcc2847ea126d8f0224a3287af03dd6e3b38050c492e4937867e0027caf210a77ef25aa6f4feb0f2cd782ececdbd3db4abd4caa81c8e8a0b4098eb0c0c699277f633552a5ec158fae04a9cc2bf1b2689915910824357c31f05317ee824fd211fa067f4f7c283f1f716a8c9719c855967ae9d004756397dd0d3897a626c889560ea540eb4f1136bf1c04f0b8292957262432f4f047339c6c0bb2a81c6a4c8bb24e7e7b6fe0ddeab9f38718d6b9c68b03c5c9f9d9abfd8267534936a939053b49d7b3bb245337cdd10ba2474e281c11ef04881626c8faedf9d6ce80cab585592a531f1085b8735b55f302d1ceca8834616757e642e28f2c9ce4b07d39a2be01a876b49a1e78940d13cff73fb1f92436d1c2f5fbc302c3e428ccacef40dedd07a64d7ecca4e9a385c1bfe6f1c1f9fa4bab7a130a65ced72be381f1704f3b12967adf766a7f64bd254a220e3cb0ad259030ef93e3a7cba95938daaf28c23cb880954f6f3a83265cd6a2e590cc47a6fdff4ac5a0c795937f5a9e42fa2992c808c323c560ec7767042303a3ac42832db0c65e4f343d28282de503305841918b40d207a66d65f08fbc8265769c5b7d17383a6202ed937870c361e4825aee1ace6d1f40ccf06ef4c5cea8e70a0829b7e7d5c483e976796eda9bd86bc533694ee52092f13ab98f834af57809c0720de20efb2c01622c8e7f69492c6e06b83b883bda6a7226d4731f6e4d2935355349346351dc48bcc57b2780c4f9954519747b602c1074bcd97101cda0f2ab1917cf5086671febbd0333ebc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
