<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a32f6387832c68a0bcd84b61b6899f890efb2189db0131fedf49bd06b2f57e989b3bd418d329ee1c693b96ab4296698687e832c857de042243c42545bbff9f77026f83a0e7faf3a2b2c9423e554f85d62a86272daf6f6f6064afc1a91718df74e615dd35f6aef646e28a3c55033dd3601478f3c6bf1c5630c2da585352dc70828de3259bd62723e5379a2f8ff503cd442b42da663a97d1e7a06f3b532f0b1df59af0f7be8b71d239a4d3b2a5d9baba98ac26a13999ca272294ed52a9b330fc0ed5e3c1b737f17b58e0c1a0993817d500515fa76d8a09319fdf247a2f45f061a44562e49636da5bb4080c37187e3a2b804b858ad3ae41aaa3bfc58e66cfe8477667f1181384aa435432e591b5bf36e98304e382d87a5be61d5fa6e55b30b052c93b836ecc434e52d108f6701c70e3ab9b213889c330fe0ec4ed99493feb372beaa00857b9879f8e1cfd97541f67c5f6403163e4e3ee8732f55fe1ac98b47dd24a8f4b041404b63f581e2b6ea78cd7c953e6f8816f7dc9681c600c2e6cae5208786eacefe844aefb7de96fc22f8786305730758e24d969c4db262b05052cd73edbe81168d8676db411025a8f4c53482b751ba91d3e12b665428f613ec51e53711177eafeb7f85fa74d41bfe798694c32c1e5711bb5b5540f0cea66d2d70af748caa513bed48ecf6f8622d37fcf386a6c52a708feacb7049b0556bafa110f6d96c95ed6bae3a6decb9aa3122e8cbf64315538d6e28e53b7c70b3e835d9c1fe63ee520c45b549ed48a469356ce4c219456a08fdd7dc8a31959925cca0f9a98b4130ae4efcd52fbb07a357692fe1739d4933e733d75ad325f3291cca9e15e5aebcae6a48ba40ccb22bd4205c628fe30e667f0756d45ca59e863b52502563a0c15bd507070bbc529daa2555535fffecebb85b76a3a05c2ced79de17eda1a585650db49fdf1ddd163728df9155a8c7e53e0ab90ffa163c893de0d062457cce7fa847e11a67095e17122c4db855c44d3927dddb5ca077a120378659a73421bb5be22d3c5150fd4f75e7a8df8cac74ad72c2a4816b9ea6e7a337e959dfea3dc680dd6f50fae667ba4a0e420dd284b8f64e4e51a71c2220826d48ec663e1983f7ca1b367fe5ace289eef29a9b2a3d70742b91a2183b4b92f5b401f0a9fa5abc36eb4a02627dfd30e9c563ab274d8850694c57c334f8c4dac9fdbc5006abb7393df806cbc70177e9de01009a0d1925596b42203af71f723d693a5e33d8360bf0773eb12b9871782bf34dfc8012a4f35792102bb5caeb82ca39181bc2dd46e46b82bc09961c05a7dc33e8fedfe852c7ab10ff4d9c9bde28a6c3c4ec43cdced9009d623108d0d7850cc617a8e8894fc4d726c7552704432f2fbcb6e47569cd830c2ab12229098d1c0dccf34f2edffc1f1045eecd6f562d3d492cc6a31ad64458cdcae2e7528661fa76d211a5c46c9a6aae8253bcd8b3bc5190ff4890230fe61b4faf5c5eed876b5ab2c736d679a66a655aff40d04ce1eb6bbafcc8ebb347daa270a63b370bb55bec3026307d977cfc4cbe1cb6f55c781fb359755e574d03710780389e571afb620529ba2fd3613902aa2117582aa6426eec66bc2752bbed7f06281cf17886b169c2f663319d988775f00926e8e21a30854d6f05bce6f39bdafc816f6d599155b2b065bd1287e67d56171da9acd044f84e6a4a62d4a5936b57dffd71b4c9fb381f341cd139528a5ee9d3a4d91ef9f45a010e655dc64329a3b0e7fa28808632ff5bbbf4d91ac0cea7126daab4ccf2c05972d740b9aaaa6b1a94b19f1368093ed276809347e88db3885005285d56bea18e4105fb1e0198c8d19be9a2720b039fb6da0b09445cff723a18133429fc871444bab252e658ac861e632064233d5cff2a376f99da6bcb2f6734ec0fb7752902942832a77df46eb1ab7997e76d16dbc2fcaf3c8314c74942d004b423408e112e8c349389762a25e5eccfe8316289e379d4622df4260982018ebc9fe586fc3c0d12036d0bd770f5dbd02cd5e06e0312d96d1a57aec0796aa6646663b4fb964851b7ea6e5fb6efb9447a29b30a61762ec9906067d7f760b612ec813994eda6123d333b217e3603cbe022eaf7bd5314c944c2a494e391aef484a5d812e44d7e24b2ef67b5dbda0aca09d9adb1c5be1b0d3450502033f49da995b4e736eb7ed5eed9d40236d0ccaf9fb78287b222ce525983a0a33ec0c2bc05597118ac2282cc5a585c02ec07cdb304c7158dab5c357615f555b42459ce0497c062b11197f86b30ddf66a910f4c6b196e501bf65f569f131b16a9cb4a28fb37f3be63ce10503024180da9fece3c93a32d11d01f064cef6693781f36d1d6510dabc39618423ce616188f9320ec2fd700da31716d52628be537a093c1f76cf3d0ff76f1d076ff157299f21d880ad7f350fe9b6092f82ed2a8ee1356e06d3d968e0c432c2806310c08263c8b34f435aa45e194257a77148a0548a51ed2065238582e126cc04016a3920d2f4d5502978687a06c56b29f0ff18cd33e53f0938c50aee53c4b5a21787dd6e824f0794c3d320a3441a2b545c339c9d2691b4d5acc5c48e7a371f1e807c0f64d6bf920e476287fe4dc1f7274e6e3ff067ca072dbbb193ef2c7cf548c11131b32f9eb46b0dafadd6f1e8a38edef47682c906d3882861aeb66fff7ece6912f9edf10c9cbd8f9f8ca82640af3d3b4d88111eeaed61a26ce388f8f01cb9c3b8639b311c90e997b17af772a73126d2cbfd1140b28443356947b218a46f5f0caaa6ca8c94786deb9b2ab76ca0cde07f656918c64c54455cea5338e4c786a2773bf4811df0d37fcdf22d15e3e7a3b39679b6a94adf211dab6525442621dfce84f8c143af799147ec692008a08e76ca30bb3fb5fbc15e7078c169c1b8a102703a8b40eae3520a84814e30e4ae22f2306e770eb5496edc62e359b861c8880f783dcccc49bbc177e1289b33ba130d0d16b1f70fbe5198cf2c04fb64250c36502d4b3c4cc231c35982985df113f210efed36d8e737eb474d40c4ebd7f0d38917d97ae3ef72da0794ea84001cbca9cbf184f61e3dfcd604b44afa087700b2b5d358047ebd3d694f5a0e192f1cec578684df1fa36761faef5504c6fb9f12de29f1fb3dfa3aee4de962d5aa5c645dd3b192f1ecc885c74ffdca1b7cd20e8e6e62422823d974a788296f37b118b4c432efa59fe5764ac1ba64981c47624eee3d0ccde4a8d383f6622bd07d66d2e8284a5e4986209251ca4ac2174fc2c07e4ed18fe0c435e343103372a735e3ec12b03c08f5ad6e5c89647c77527851d157c550a12f67cd040ee97d9458abbf11737b5cc30b86ea64fc25b89a1dadddcb726993efe2daba08b3ecc9418226261541c3d5c96c891405df57bc57dd32ece8977baf48c2ce421587fbc760484b75b53a1aba11bed7cffb5c1a1ba5c228008c8d68e47c44bf0d9f484cf9574b7338f31da34cd82869b87192f4b278154fc0882d51af4c4d4c0b47ec602011bd7629848e55f507a6d5b5e6b73585b80f482fd22bcfd19fc8fb03a504b01904107ab07a057b284cfb67d99bc3a516e6466a10007da2a04e474a66608d13d57ded5307c94a20c2532957905fee85a6679c1f895481aad489c6702ad80deef7baac6fdfd82d046fd5d8dd1636776767018c1b93ca721874d8495f6df0260e07bf609a18a7299c00a7bc14d66fc01c5b6ba6e37d7a2492c9a4f184501f56897ec8441df5c4765bc62a3f2d1d6c351e5df81498a456b043902bf898b6739da0e23af70566fbd6ef05339f77e97adacace5adf64698a3c463cec05e05ef2255a57710fbb83a222327d6e1106de3694893c2e091f92927864a83040b904d5156818c3442a49c0c2f6aaa9509b13eb424a4fd048d3895baff0486ef4346333e6f4961999e9138ed581e0826e8322c96ad2450406def806c80d5993bd994be9230e3d54f3c6ad79ad66786fbec74517e3ea9d364c88ae5126dae9d868ce7a1dfeb264a6fb0043aada33912c6edf4f63574af82aa12e40f53596324e5b07286e5c51c01bb721b33add478974e171ab25d5bfcb41854f5c3b6445bb769d20dc2f8e1c359ae71a2635507e19f4a61fc2e4bf1b3448c8e3f6f112c59ddac95a567ae76b9f7ba611811e113c93a75ddfb5086865b4ad9e8b62fe01b992877166bb482bd30f08b2f1d7ac05be7a89cc1b6ad90760545b2e9f78ff057a8d26ba514f40653f1b06097a034837789000f6ddd4ca89190f626016e25d5d4acbec696e677d756d9424c9c2889d152844d5361338b33a7df31720de73a520959694783ba8cf559c8bdd9b647b90f0b325bdf052b3b42b61f043acd793aadf7b1497d00329131c189dc455088fe35335d3c78532c30235b96dc6d95b5cd1cedb6fe186a494f13793e6aba805304cbf499878d7713a9736d5231eb4210bedd34dc40a9d733332de356230f6e574ef263c7fcb715a612363873731e069d2a6e6ab069950750c04d427dee9059b63071bac2544e1e14b15030815fdc2ae52f3ce33d5b2025c8f2b0fb319fa9e5836e506c800b5afcae99e0d433c9fdb8f997f00d6c54a8650c01d4b1d3231e9577e18f70d0de081f806f824479202036559da016db5f40fa34f2991465d30ee77d5b2423fb9db5e739f7007c5d0c04366478734ed7b0273f6b0334feb4e71f01f527856fbbf20e878df8d77c236b1d21b91a3157e89b7c3c8f4811f04da741577fbd5938ca4deb14017ca4497a7939bc737f614c450bcf88cc32ee7e02fcce7f7f08ac2929c671ceeaeaf9a2c6c3618b6b1c7b566f383023495f3c47d7f4e14034846ad07c691515b7ea70fe69988f40f0f41f5556ff092c1df4c86d50f562c193e97408c27f41cf00844b79ee07a7f0b3c53c91cd3ea11071120288f781e3a74f846b0175ef6d7df7008c4a08a8f464549da19525a4a3c10171d7678e14d0624f109992930d497be93c1121186ce231b7a834a89c29870177b1f10236fe727321c29844141cb871b5e0d4c4c6f4aceafd9d3dc818a842838ec0879319d28df8617e57e0f85fc256bc29512a4a63660b16933542e09dd84aaa53936b44518f512b7aa615eed269291df1802ed0b1277b8740d371547cfd831759abbdb3ba3843b77e1afbb8a3d7472bd6cda75f7cb1ba9c008fbafece322eee559a1ba5ca264d22a4f9a481ab87cfd9aca9cbdaa7135eba8ba390a111dc69f8568772b963894037b0c4667f344c3f9fb38f8f9b0713753ff016d17249197569cd17bea8e6def4ce335d54a61b464564c9cf058a3c4a398e4dfa3fa62e1c2e5d160fa3bf8bc5949b354c6322e78228a25466d45c5189275c9bb33ece22f99830a2130c5ce1a138fe5fa034923236b2c427ca3b02d9f6a83e9f2b0fd22bbf6f66fc08ecb511fd8e0f3ab9ef7e5efc43394456a85f4a8c530c69404b85d5b0b743b92e5259c57e05a38f5bd28972e68408247a46169e8cd4234714439b7521ffd95933a32c1cf1117787f6c5faaeec07616a3358edec62905142291d41eacaf934c98965dfe103adbe1b6905fd0fa12246cbe4a8f87c16f1965ca78cd3c5246f55d2728ebdefb0e6b09e4098b3040952d9251224b71811fa612049bf7051e64429d8e5f83333a485894afbb8d2e1e7c7ea633d85055d180bbe5a036c22ec7a27791d4102db09762ad2ea0d29649773dbabbc56dcfeb369b47d8d1c6eeaed29798f8d62743d186556601ffc767d897ddc2fe3ecf09af0ee6857ed7d2b9c69a218ee6ca240225b7bc4f6c50a1bdea88444ab4a4ab472a37e76ec07ff3a37cdb27c8220b2968691f22ddf6921ec2e298d0feea217d1f24afc5b845e8c78eb71a8031c30e662db1a15556d5c3e94d55760e8e5972d75cfaa8696f342e8fb9120ae5020f371aaad3efdd3c92d986ea4cad2f392a39d8f79a891a81ad6a5dd27b9a5c8230b945af658d35d10b9c760a4904d12fc203e4ae9ad8f830957f7eabfa83fbbff5b23087314bc67339d229840b21c3989aa38f9527cfba6bd7bb85452c7036d9259194fce481340a368d0ff0fb4ed616de01318bbc7a3730bf8cb702962adb0fb5c8ce9907e6278b92565fbaac6f412ff4bcd08f078be24a88c8f1a8247d57542e27ec1c9244af4c9fb87ad5ab758dc97ffd54983ce93b7aab691736c9237aa1df4c46663a1fa0c719bdcacb492cd89462ae577abf13df025e10e5fa63a5cf52267a26e6fdc9a33255b6d6ec589e980a3b7535ac88560b9ee1d1d53c73e75fed854847bfea5120e7422de8b62581c11ed5957f413805fbba771fc4d1505a5ded4a64ce5c0ded2e88b1322dd4383fa66f275a3311d2d7c1b75f446d65e657170571dbb4b917001cb7de8f3f51c4f8ab9f7442af8bacfd0c5c01867a50091af1e8f4683728e591a8d1a8a43b21caabe7c5b217b1ba808443713676297d5a0a08c41c0802c77e01d4b656a1da85df3a38e70a8aad1be16190f5c3faed54b2b7ce54b35d876469e14e17b344f15a7a30915dad1981281bbf675d085a802075ed681e77229f872ae350a41900d653713f4bc54ba090d7ab0c800f30592a4a8cc963b763de7c60da54df6443762cc50febd0e5dc9a8d8dd4813cda2e5c0dda896a2de9de33079df62694d9fc4a0898437d445e4d738ec74c60b09188ca87df2ebe182fe9dad926bcd43433310036563605b2b18d2913900f4edf6618367c36bf3a9954461f5dc5aa4eab0c85472c4def4127453863ecd507afaab56abea76e4f2b5771cb9a7e7b919bfa442f55d9026eb3b1da091f1b24bb63a755fe926efe2e89e354da9a94108082948bf2fed298e2d0d14cbf0c0b68102c3626e9f8883c4ba05bc9f84dbaadd67dfd5f4dc60a51da595dbf9595e1ec0b9b1fbd0703d82aacbded374ef588274180e9d2f8f1e587bcf65db93282ddacc3af2465bd1512b7abf172565ed046278abf19636b96a8a5d01373df91e800019b47e4832a6f410d683b0bb3407a162ce363db824e893f4aee599856a9cd9915ce40441da424376bd6f5862b90235a6e839ab95a2e09af2e656f41c3e4b1bd1e166c39bf97dd49ac9a639d46fa0ff2e9d25292f8a717b0696af9c55b3d3aa6fddae1bd345b068a6a0a2d76d7e9a9dee75f703f985bb832af1373695bed46b7ec5458e7850a81ef7eb4c275be1f5b32ce7dcf0f99bc4fc1d212024da843254c6d9ed8bc54ac87d96a6d69507fcb09d7e1220010f2567fd4b33f8a1ae8e0eed96f05d6924de4518ecf37cdc374aa18760c4f4d193626a77655b97fd9cdd0da0a313ab3ff4323ab459f2457439b5aefdcf498985dba910b4066799ba9b98bbd1f4f65da326fdbc06a5825a1641f7bba06bbffe01bbafa6ea97f6fcd5e4c1a4a3968405c53d6b80d41da6e6434f34a82d1cfe5f799301bf53cc5279ed7950fdc60c4815ddee9cdf943cf0dda45547f61d5e79b051d7bcda12d4b77e719ffb2725975f48b25e645ce908c72e5d01c43b208bfb33f774eaeb5c8b501cd1a5071111e49479bc4586fdad7c40295c050d21e181dd047e17893d4a2f97c79623346bf6da234e044a819234069f2426575bce48842a1a1a00fe605a665618a30859c50083622ded2846795221ae80508ae8addb6063051b557a1f922933cabd6c02fcccf0478ff15960d24d1c2ee1d224e90c6435018e18b8b4c878fc06ecb33897519f41631497624a734da8b0a4377154f189d2acd4be6d8b1e4dc9d9628c10ea9ca24c8cec2539a2f490c8f6c1bef4eee99805901376d46216fde6d7ef1fb74f57a3e8a8a39aed5ca6fae5a6269e212ff428a866eff035cbc4c4b243c7664c93ce1f2b6f38c53c2ad091af905866b6f526cab5ad679847ad6a43e21b9790daf57764b9226b1a6b03dd634ec5e7083394e70bb4fb043c75064ff319d5b3953dcac8d4071dffa63677716a3219ef5f33fd7566530db987534b093494ad170726127932e6445662b5f892d68580e5feaa8a8e8a7e037387a5d6f04b138dc1f5ee55af3adb323838f73fece8126ee7ce1533ec01999c750f40f9a719fe6c67901bdcf41dd97946ea6022a6d1d974455b64877a67cc74df0d21e39bc50e90847181df1128fdb4b32eb3c7c468d7b90ffb5f85f7ecb81c1014e1b0af0568002db42dd0b175fcb1e1ddd90fa72f413d094684a9dad5996a2db7d83321531f2a3cdf99845d8d1706defefc526427d95a6b9ae09c0870a56c43b6ffb991d4b0ffa08c4ca4b4ee65e9025e31e85113d1c8ec821606eccfceaa8a7446cc2a609cd2f3298a25c71a09dd067206394e01a10b49eb133c118311cb548b9abd75a9685d57b44be170b366bdf9933770a6b38904daad626778025dafaba4a1cca0d72c5b80ddf16cbbf84b541d868db9b15b7ee22b50fbe5a80af87849d84d0e537e970e3f8490165ada0430b6a53a738913143d23f9d453ee2c7189b4de7366d92c22276adef06defd4cad7d18c0ffca9d7ccd9462e704a80833cb5f190eda926ec21a45b4a2c969458f9b97d57dcb7729062a4a92f6ed2b9193291351119b67e84988eb898d3c2493910d84e55c71128f2071b5f658e8b1e623a60ed7e310245231270e331de4102d5ae08175d00813875cbe04ba0ff87d8e06ebcbf32dfa39ba25a06ed767c9d66cdacac38b55940c9165cef04b86eb1fefaaa49305b4ae231554723a6247632bd7344cf2df1abec34e6a0c637c5789b5a31536b2c9cab7b76e103b0951ce6469dbde5819f8bae5a0497a04bee39e2626d61521de25b94f41073715262c3a53ed89cea1a1a21d2e4988a9b31f6072c56d86cd096cbcb4bb75980a464b09cfb5128352e924732b113a179d1fef6787e2df8c265cb589d51d1b948b9d4cda5aa7b05c790b4dd6bc2049bd579759ecbd1b95bb63da280f0232c0a0954666ea0d66647e797c3d7219147aaa38bb96a1a748b8fe5d1827cb5d5b07ea4bc59ed1fcfeb5f77c0666dafd3dd9d0ae33f93c4538b9af8859cbd04581e5cecb0555d366a928d5e4631ed0b64ac3344703913b53ae2acfd30af8163ff1fca78403c9d2eb8cc5f59c37157ac551ece36cf702ed4f52d1b358bfbe432e7f5b3edfd76b7223e9ae81e54b4ed4d28c3711cd1d61fd383e721251807190ef3a82ea4f5dcfcd83d862c1c003e6c447eb1a3f50ecd41d35c7d9c364cd309247369b93c20fc5137ff589140dc1386c890ea81c664e2e4535265a594168a1e7a0e241cdb6ab349aa7b8636ab062a6e64aa0ad04c2a27a68c01594174b57bf7d2561b4452bfa1e32ae86fab5e78a5302b4ccc004af3343b6d7b293eb057b0ae4e7fcd556b45e884f43fd275bca759140f532fdfc8da3e4a4dc33d94875c65ac3d80d4fcd8457e8b705c197b4f03795f98f4b8412998fed21e2c6c6724bf6bc9ec45b3e6a364eb3b0f7b871687913b0c6c39f463eaf38de5d5cab3df2ca88828c27397ede5b22349a557342434dd4717ac3d4890a13911a66b8cf2083fea2e25547a2b524bf517404e901ac5f56f2f5d6c06e3aec36adf3bb5e9d79138417201d282c4de851f36ebf39cf49f9a3c7c8a04aa6e48866676316bd437fa566c976026b02880629187886c9e99b690fbdf3002ef865fc27fd6d7a52311b135305132274592120b686abfa7ef5a1b6411777eeb3eff175e199693e325832d42c69d9786e4e52e50a532512891e3b278144c62e71061c3fbaf98bd331062d6d6409b649a016e99d1c82f9f851339ce642caad7bbca38ab8f9c640bedb79c1717b44d0bb4c04efd91fe79360f42e7f62c444efeb787bd13c8e25f6618fd45b5b4b877ba5e8ab5200dbc25b9b5b32c235dddadcd13636a6ddb5550a76fc0d7122b147f330ef5ca5d7aea01e97dfe407736c4a764ff45511a1a6e31dcc3c5b95c44fcd1bb0b2d48ea4337b6d1e432266befc9caa08e8a5f7c3da901c86289ed7d1f733ccd071e08f3b1cf3a58a5708edd8032f60434a88102f0444e2c0fdb250303266e4c3943e5777a2a91b53135a78db00444ece6b6520799f4cd609dfa6257595cfb0c85a2697c9bb96830be19b3d73b25d7aa45f7b057b15989c7e2fd3b40b549569c31ca4bce7ee552ee6038861d755584b71237cf15b9d3d4a8f33888fed6ef500f90079d954ae30a903a210cea5546da16a22dda3c1f9df06d623de060788b9c71a24edca0e3f6e61ef2ab20002d656eb4a223977b28bbdc2997ee364e9d4ac05d73b1286c2362750ec5a255f17539c812970fd165bd2cc44a279082a58be9a5be072aae52c39f7b4ddac1c730aebd70ba09163c0f4a98e6f110f030c4d9009961401aef718b619201f1aef32bd27c12ba452911f6c276060d3007487a9b46e2080811f99378d31c37d6bd2f1ed95a89187ee3ac92657741c7e4231ceba87ead56e44fddd63c36e2eb5370784a67b00dba991024fd3f816c9dad2e41a60aaf05f6abc29e0f3f3cea599dd0b94565d2f2da5f70a4fc139cfa897f7e9ac42da1d52efbbf47e032944ce6a621b543ad3ea4d5c607032b2c0495f937b28b117194a3b44be741d6a54aca46947ae118be3f659de062143729f379c785b13189c3d61ab2d0c78e909c63204b8a88e372d945341ee33dd9e2848c83d0df130140ba4c11f95527da83669d18a5dd3598223247ca2743da0f7c661b34bbc2ca13c3c33bbb8aef8c2706088f5f69b9e9be0a0b91ce5996dffdc6d9a5e4a20f823d99fac9c2056faca2134391bf7f177e241930a47d97741c73182c9962f73adb890f8e69e4323f329aefbbaac64914781969e3fc6cb80eb4011e86e0fcd3cdd34ba4714b1e9bf0a05ace8a62dd376e10904efd1e13d56ef64ea5561a2c466fd75c4a25e588c6100abbd82f4480c8933a774536788965f2341bf14165ed47f0b74fd6c3238e4b111880f6f0c76cf1cc7a4b361f2ac62130b37f372778912bf81a3682daaad160108659a086d3a3d0fc5e45a8a7e114ba42b60cd7fbb6c4dfb6cca21580075ed784999189d91a0692bbeddaec8745633bfe50401bf945b1fd4ad4563817fc53625e4024aa85d828e10b3a3ba496a1c1f570c756c924e7b3b50911e37e600975c8d32972ca82ff414f5337722342a5c032c15ef53eebbd729ef58e850ed9fe9c05be9c3a6a4d4a6d8d7196649bb28dbfe863c28164c1a87c27c22babd4182eb643bd220691bf9354035357be68a53157c0fbeee12f2f30b094d8b588742c6c1ea53713f54179faf061a3dc9d6716614076748139117a7c01f860653b0896831a718e2b9558b53831116ab1e9a643183cc8ac90cf29796b96804c6556841bf751c89ebe3bb807e2e42ae3c5b2340a7759cf312217840a571d3f16e646ca26bb1f5e0abb88637e857a9a8a3afb4e2caafe223d0ac5f4194646ac00e977b1bf36addd6e4575a29d44ccb988ce3660ea15eba8e881fd091b0e86023bbd037efe9386905d3f40c021530c2e56fc5e071330b7163291089645c886999285d01f7c835d974eee21708fead510a5fb0dc7d3ca7aacf317157d988e7cde677a49b4025827076ca1033d9cdf06a6ca2605b4c7ed6f412f0f260a3d866d4df5fdee69d73f9601740c8edc88d782d65ae47c8bb5d844e6d794ad95a62dfc97cf4aaa3a8f99bab9688ac39244bcdc8b3deb6e1294805c2ce22b22abc71f5a4da3be3d50df470222f5f9f13dfb677384bcae0d886a86788526682745dedbcfb69a34719c205969e44bda7aa3842291209ff9512c80bd9930598f69d8a161f2e8743287b14880ccfe722dd8b489c4dc268052d92277f8da9dbf0b130820846cd17e981274929e4190e729dc27ef4c6af2d85f5060289014cca419e77b3cca8faf33e2b21f7638fdfdd04d35be4d4d56123d9197f7275d43c08197ab530b563e8c9746adaca7b8b7175cfdecbcd38e966151317fb6409bb50575957d13531168529ee93c560c8df2b89fccf340b84ac9ffa165c7ea17528f1a46823ff8ed8cf8906d078a50cb47d8437eb578071f1661c5ca764798788a79ff7d763cfe3c2c7bd637e3e65375f8a53b92084d237b00fee6215c44d43e3568062df60749e604a87caa05ee92ede376a1e35dddfd8c05de1d5e5e93ae73ca168d9f9a23b8c11511a0b1ab675440e803a897cc068aa746fd13a418f9bfde603232e4a3d4190d9b4d51f715759341b0260b37d9090d37329f341d6276ca3de2a81008ab795bf0040eaf223f935fd32c00f4551dbd742cd4fbb66dd715524d7014cd724aa04701fc22e995c0ab07e8ba64997d5f38107a3e4b9ba20c5190d1bc7b2c04be76086e4016f1884474936760ba8611007e2172f10b3083b5bd9be0bcaa5720a7b890706e1220df5038260cf26ccd6c6b5c796342294943d64c6ef3c440c74ac12e39557430cda1b5f8465c1097e32f2579bdf6435d0d879b55ee6ad0b66fcc63fbe2eae568f910e42c9c0dcbc43f956e9129b9719f77f1d0bd10efe0f37329a6f5db5e11f3d2e441661350f808a75f5b6f5d64023d9c8004fdd6cb6480b4f414bd53ea2f546f09d47fa72c6b18f3b8aba4c06da95bf24b06e9ae3ff1b04aab921aa3043d5b73d335a87663a0031b11603075143fd474851e3d2d212f5bb20094504804cd843272705f45dcfcb235f66a18b2fe21dc0048bc2315af0d05f21de4bc37b59b6a3b5c732762b5d85a2b90c7e0a43403bcd2ca7549919b68f90b69e6ad9a0e91c924f397e0df3bbd9b63306314ec3abacd61992be460f08f565467d76cb7c2a32a7969153a9499996dbdcca6cd2f731d50881955069edf34bd3c63cbd78c22ea7f6ca92c9c404878da7452b88ea61d604edae170ca7d0da272187a5d2128c36de82000885e0f24b16d86e23be220e6c0e1fc5ca61681bfde75b479ca4f71a7b968566894d8bd26e6b284041970d0281acfc7712200d301888706490414b5cbb1a9faa568a4325eec2964c28a5faca4a0fc02848c978ffc56fcf1a8e883f6ac80533432cfbeb92a4894f7db09af54ec507cf8dae8ee08102454297a5646924336c543d447911548aaabcbfb81e9f55b4dabf7a7db4c0bd1f405b004faee8ac026f697f026357cb35adaa654c479b8102aae40d5808fbfd29a2bb2f198014e1c676cba731ac234e3c8501301c50e5f8f58dcf9d35c8014cbccd2bb5fa84f844c6fc97c3a19c561e772a60fe65412e4c8f6c81e58686afd6c7e66f6d84607011ac0b28cef114c2ec841c2ed99e01abe38a0081ba26b6ec08c15c5a80bdc9dab2f864c2d9e6e79764d8d6d22fc8491fe25bc7255df5d55a444f5496a7bc177861f9b02c0f146cd57eb2922a87956c21983cfeed3f9dcbf0ec224d61034f9055b9982b60580526d24a448e610fb45ae053efaa91fa1990fe685fabf61f7cefa6dda3acaba3a74d75bc8b60f81b8002ee9b0af52f2d588c0b5adb8c6292a54eb9b1aa3b408f311ca43aeaeea43d3d4d34b9e9019ba03d6ac98f1e3e95a33e54d4b8763a621828e2b86bbb06853b5b70d0a90b460d1274ad46bd4e87d70152139b1c874fd36e292338266c37764f1ec449f3996e21def5c6e61850f747a11d525284ee5142472845c7ee752260edee6c1f3423f9c7868f3e5eeba4351e031f4f812aa3f1d0167bbd03a4f7886c25e1ba20d602066e8e537659e383d035ea897f5335375fe2fdb1191902e26bda2f0989346e29367790eddb0ae5656397954268730bfe7505038d84c5ae2a6877a790ea1076357471a1afabaec29f5f33c589b4581fcdd7a54c47ec0300971174886388148592cd341c6b1a401ca1692f9c5bde303f88951a72fd79b77cb62bdcfb880ba341ede9f3a82d80404f80035fc2d5e259e48d325d52b8ba34ab6212f3d91ef26e35d9405fa93c44253eba8bf273334908b43ee4117379d471b2419af487d76b759f2c7bd24ee2fcd34fb966170796b4f62b207156f39871a4d718ab3e7b42d95a6e6722314af6bac027050afccdc2f6dfdc2dd9bf159e9e68a7e6a4e7c22a53369b5e95c91fdfbd75f40de74f232abe9a7ab8d0de9d5e3c0883c7eef7072e7a9307579f9acee8d0bf973c7386ab8f74aae7f2865e88f58f3a6b4799217ced7142905d4ce6eab41040518e9f8422f945aa8088d98022c396bfd3e0f8b8c7e461b6523d082d183a54a7b9bf1904c51e45bc68febc381c523e184f619afb4f1e9006dba2cd3e9ac562267d1a31c4af00e3ee52fb65b03c2c43b02d609f00f36cb0c1ab775f2f9db9b3db166c8861a658dcf6950ba099397ae56d7befb691ceb27eb1745d983f521ea8befcc1268f98b1df2d3f9d885171ec320a3660772c10b292d3ef0f2aadd46ce55fe8dc7c579a0705947fe4ff77c630aa601f7e1cdfa3d3911c16dbcf57d841930dfda38a7a206d31a2e287e5002965effec950c46c7c017a263b40d26c585900f62d45bcb8409439e3f094ffdb884903033548b52748181e8adfc38ac0914c213d606269255433962473810b7978c54325adc65c5103a07c295e9ba996db135b923753152d69c05e5f0bc5259600058c9645b33a121a9a16e314b9c596629b3b2406a52d86f80f7df48ada8d4e232431000913c8dc7e89374d286b8ec8a00548463e7896ef41eaec002c3e5a03075d34b2a409e980cda3031efe8e62f1c0b5ba551adbe8010b8a9e2d95b036ef37b5fefe90b394be6124ee62cb55053c41f5719e525c0e55507d5858ad70ca44021576d256a854d5adc1afeca9de747591875aacf96063c0b83f7961f961ade438c8be16e936c4fbbfa69f69d12986bb2af8e1a6163f856da99bed62ad8406f311e6ed31ab1526804e8c82f52b8424499dc0081adab50b29fcb83cba6ff67cb5058531007f04fa4cc30f2c60bad5c813b9421baae5485d0843b481f902680b94808785d2f7bcad4a2a2561c50975ecc1a8b99707d6afbe01022750c43364f6255c5a866c56fdc15096014ee5268f8e8bc01e0b9c6429ce38a567732173b5ba5d6d5d955f80b22a813d662d454b675e336ac5b498166c5ae724beaf2c4c5f11bfc4c2a5f194e06c7428de56248574b5f4252fd27be72a222c207f40baff956b28eaa47df4bdbb328ebe8a5fddbae5bb2f1a282cef9fd5c0ae350584d26fb592b046a0d37a8c15d9417f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
