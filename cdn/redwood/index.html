<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93a44bf3db26684bef02b296b98c8637888596cbfb819c7093954b495a4f6a5d5a32c78589370f3c55cb06666af1d41430d874aa40e65f5f1bceb19f570bb4167a36b692952d64875101d1f4ecd5236b7723397e591f213e2a46e9c7a7b20f5e9140e6aeeb8023c295859efe22d5e3c17af5df3df083b354e7f9d489998ea28748d80a03117439fcb69a4668431d214dca3eef8754739c1cc2416ec3210bd279aa6bf4f3fc7d21055d9707b4c4790b9ca671065ce259efb55d0b7d06ae602ed6fbd38938a6acce765d0b1f01c84671da78d2e14d917c84dc1c56a340d4d6dc5eb1d5853e1c254eae193096b0291891473afdddeaf310c85d9d6bbc3d91a67c89877856c140f50c96b7d09233d577bce2b4d01f96e901bf0114cc49941a17ba325d67cfe6bab60af26cfb0cbaef7a92b533022c732b216d334f231558d3c6f76672e712de23a749043e49b988808899e59842fb4a4db88457bfaf3f64a1b2651af180b96c2d6c476f4fe5d3b6544cb4abd0b50c4520026bff1897ccfe9da98d1debf74108fa86890b9cae25ce6e57a27cdf241e7025c0883a622ce8c2c0ce89349be642aefd1efc881e38e96f97cc504460da6485800e30c847713ad92e951e20530e0ffb64e7234e31c98ae54513fbc8764a7b77e04478d2639a5499cbacde9ffb80153a1c680a3e8c67258d140946d03b568acad3323b58a1ee71284041c33b9bc664e0e064bf59dea19b380e0c262741cf906ca69f19b3880b2c33be790f331a6b53d687127b9fc2d5cfa1b00e3568312447c44b18c8a57a3327755896011b34723c772dd71c8121a4ae411380ab507e102b4886e4903e507d01356eb1ba4f0f48abc73c2f104d4a45fccc6d86ca4906203b77e2c42859a2e612d90bd513669d25ad143fcf74be15d47b4534f7ebb100de77c3847ac5720746bfc6c21371ca265a35ed8847cb2f6eeba7b425e7a97c91519ceef957e61e07c9eda81541422c3e07eff99022ec30c2e1a98c127b2478fcc6b134ebc204263c51f0595e60e9c9a5051d3c43aebbb577d4e5d98a7615ba2fe21d3167df63ff63020e38d5c0f39e30568984b8ca7ecc0599f7900683284f0aa925898419d44a81ca202edd695fc1b4cd3f08c9350500ba7a545f36ad7abf43bbff27b56ba76142152e6f1d39c339991c696975c2de6ef4fe78e2e98f02509ac66dafb50b12ed8c550f79c24ff4c3fe9c51660d8722f5c85075c5a15767735a7f3aa1220e0f162e64cc7d3f319f342a9f55e886018ce96a257eef64df2b39e2b96e0925607eb34077df6de112f39ce34edc081963614cebf5e20221226e7e808a88b9a7998b8b0f0046b5276a3af29a7199eed88729b168869adbe68dc75098ad92211f56447fd7f1e1c74fb221b155bf17f34345376abab5d0636e2fe95f0b355f6c14e351980db2e459d1ceb8255ae29645e58ddf41f7f694e6bd188cb3b7cf682fa212955462a72d72d5c8bbfda42c94cf638750c375daac628f474dd08fcc9473e202e0fe4a45e2f90e708eb7d585443c270a24a8f6dcdcaab7f65452a00d6ae13d0783b1b2f46110894d4ed2528cd5abdcb9c2d651e00c4121a075285ca7b176db700c9219e2efc05cb5f08cc4191538baf7736f27f75dcc8aee3796225e7017c92e92ec08d9d734ab7534669d849d2085fab0cd72e1fa91317dd867078d3a73d7e5e2a99484ce80aed9b4529f5b4035982d4b6802e394ee07635cdcbc5713568678ee00cba22996c308d415c13c9e6046ad4c8174ba58d3c662011b1bc212600a1c95802dc3d4891441463c3644ad9eadabb84e575177e319b9605ad87fb3ec4402dfcbb73fc597ae1eca1d72a32acca8744cd8c7990372936b893b0552d644b19bda2e714f8d3aadc74ea79e05c4e610f1af1098f57fc779010ceed0caf9e72e482cdd4c815e021a5c4fc8881859028938ed7f95cdff196f71458d1ee5a24de5f2259d5fb68789d23c6dee539aea4606ee435a5dcd9b674c073d89573ba576fb1cf05a6e7f2e1fe026384eb4d3f851df5ec84730d0deb0974c599de63ad4e42cb0e2279a406097cd8a03aeee00c16d65979c401fca3ada8285c18c7a11127b1992a0f85a22a380a1f983181f12adb10adfe261d5b1e42cc50eedb22107b7ffd7f6b4bde95fbf7a3869d60bf050edf65e43af43ff49748b162b08d87e6d6d0ec905ab2f34c6e1ba563973d319785c31a6eeb95a3e22a6d0048675ddeca55c880e1a9b3c2ac63d88ce0de577e1497f0b05504db9aac3303821b9b3854b1cb3e2f5b1c1447a5e10f64b4f1fadae42683115825a831aaebdb214903eabaf4fc598f0cf5155d4aff689619e1d6d17d553af82a90291809b60c50c0035b87c5638ee5435c8261ee42ab10e13d9ca9b4990fd9220d6080c1d96815f7b8eff64affeec43488bafa5c6b4745f5ea25e74fcb38cd563226dfe62b57d10b399109f494675db8e27e3f64f1f81ea55837227a738d1194da9f5c46ac29d65dc64f0c1a0b2a83f12acef912654c067201a84cd1316767ad5a39e6cf6d8a6d9b75152cea441aa64d33eab06012c981e524e2f25099cfd279df894650223f3a488059c40e84a3d159976eb3d21d414579757c6291248890f21f9836f60d3cbfcdfc3a13f3954eab25a32895f8cdbe61657540527b6188e8b9714fb2cf36bb32dc000cb2b9a6c557c06f8e6c7dddf7b5661a63a15eade3a598d90dd457fa12ff522a0c46f068845633d60d348e5dba34d2eb0a189633230653257592c0d75cdd5553ef01807c0f8dbccbc050e23b767d1f1ba9000fac423bfd284364786159bf93e33962f44b17bbfda9d72332f2dcaa4c14ce5e6468fa153d176faf8098adb545e4cd1a7c15824d5d773e8afffd064faa26c15faccb18fb7d9695329e748ada71783c4678588ee77e1196d3cb880868d6c37f66d0ddd2a9a65cf1e9e893cc83b780536c0f653ddc187afd2f507f21de5f3c9c60dbc069574b2d866686ef9475cfc924a2a463d4159b78bef91173c59c1feb9ba9bd10c10c69dd10783c0f8cd959f62716f2b9e40126fdab5cb07864c5e48abd84f66dfb8dcaf152f22f59e60efa21289e25f05f27285cbd8679cfca61a02e96ceb69949f52e2aa525a284aea2600edd40db73c4285738f5117687e3a1f61cb8c6b79623991d03d284a0ceb3e4b9a5d8c90f72218e12e6f8c1c45e40cf5e04ad91dd1ead57256f3ed6e8fdb8665495fb2f41461506142f01c3e5783697b04f23f8a3c8af0c9ec7aec3cd79b2684420e35a9005754f58d372e4984b3a5f57fecb0e1482c2429880acd16ef10e1371ef352fda47682c7004999ad9156ddd7abff5d0061b9f0a070a28989e0c280c8b1254a3be23b4fd6989dd3aed0a390674397f560196a82041b94dd9cb39ee164d5b3dc1cd6006e374742508aded5cb47b6605d1194c08f89c1676278301e0d23c4297a10cdc9a068fbb84a078e1e3cbdeea9f9e21fea8733ac639840594d49d8465a2f9dffd13f24ba5449133c1fa1eb1c3ddaa8d8d56c5c23d86d06bc13ddcf0248252a52336ef5eab93a95a4476c4490d78609eb1afd247da2c00d48b8ecdf198d55d40bad921ff57cd152261b774b3ee3324f4abe051f8af105c59bbd096bf9ebaf939efcf6759121cb71cb650e14c1cb806edccf79cfa35cd87d3524e186daa2c48a214498b3501de095ae8277430191feb86dddd8302d28efc0cbefcbca4d2f01bacb9b79e118d2971191f35ddcdc571a74d60ea6ca689ed6dbca9404a7784601f59029c95faa562f16e70ffad47b39d68596a26bd8422bbe3748254bf2e406886eac00ac142b02c4568110adec00e39e8fee476fb1a5746c2b1e57ec09978471309b20c90702be173425eda5f6c75a5bb82e43c72791647aa039694bcf8fa8ee91106f1b06b9512a8e6bb64f8aed1ba5cc48bc54642e4e180caf7b5c08f4e8d7123ba443c15b0ab74a9606445e22a1444dbc441d11a3f8f78611c2092c0c8bac55fcd552d38931d68ba1f271d2f8b5403a3cd11bff31731822d40f839f172a90ad8e6c723ac2eb3531d7687e5ad301f96d4fa7a593973701461e46173e907635fe363c2cd38b049835200a355ad75259c97bfe4dcc99d70814614867b49fa1c7f22d22d6700e3b9e1d2a4c4dd7a786c9a93c7e9428c0d9c37eb20d33b81b7b73e57b8d1ba405206d2b2386515b5d5c8f8cf82ef4149107a91ae2219ab7d745b3896464f26ebfdb7522043f86c1dcf5a0320b897913689146abcc4bafee26a7e096fbeb310039ef392833fea08bed35f9a5d84d4169de165aaced1fe8098f8003701fb09f701bc8c59df12e53c35441177d51e656332aa2b70bd7ecc9ac85a613880262ab26c9451a7cedce5457703d0d871f92fb3a5c8f4eb7634e1ffd20c9f53ec1a1242be8fc198505303a51221b69bc8ec5c10167c4b46c187baf62e38f07c2d5843b2f7c5edd09d97d618ce496cccdbd853c10fe62699d76ca10872e168cd44823d677de01e8ed568ea01b5dc7817b52a9a87b4c8ad0fee819b4e193567f4fbab87332bf1d382e954b0117bcb05fa34adb55170555c226d72647e6de934a78af74397e08aadf6c06d33dfa42f2d469e6305ab1169c52e941b6c122bdabd98fd4a37b1cbe7918dbe1744635e6969ff767c0c8f5fc89aade2657f6a5fc45c2ac3dd2ef9e642847b862588385c86c2d34a1f88d878cf3cec087f489195480d0ec11d2df73377743b454c2529decceeac2fc5ffa28ea81028275ea02637a3d6610c976d25592ddc54f85b8dfe603d8d2f8d881729f68b292ab9c98d291aacd548ca74c027ea2ba3d2016b564d9c22227e9a9ca339db0c646b76ce082063563234cca152dd0ea5ce4c7de5cfb03fe498022ec995ecb113bc283f40415bea2b9606918b14aa0604964445f6f7b0dc05fed55a5715cc4fa84a344d4511f296c658ea568dff8755b44a510220b873383ae1f15c4ae3bb771ee41c622b8f8562d32e0aa747b5a0e9f26bad48bdab0b1e0a6211b42218e75423c077a47d18fbd81324eaf800b497eba9e294774f99ab3ba33edb37dce8a45778965895cb747d5b9069d32070a81f700fa4143a79a40469a15563da2bca838c2a4e315099c47859f8cde882d419ae41ad5117297445d2cbc1652ee09b8874c309e5ef7a043d85f24582072b59109f60739d809421ceba6af75f0eabef0a8350a89d784458dad86356ad157c4dfc7b1084bb6fd7ac30d8a41f5fd373127ad4fc172ca1768a424380c05d9e9bdbeda486f2c66ae12a238e2853027f06a7199dfb1e0a790e44e31c8f308c5227c32ee4c4d0b11b76ccc5eed4155202dac345944299dd3f940dad243b20396dd91825ae2edf67a2031654651b63230d648d1d61e79a817340c13f32ce809dee4e0f5255d66c45fa4f5e85e70a677c9cb964558f5ae6be0dca21cb6db0ee408ff741d15c71eb14542cb645df27dd29fe3ecaa181b230c35b849f913556983eb9bddff79be2b48d712cbd4bb9e2e68221b3b7e1aefa44faa59231d86d4116062b0f2acb7461edc2b67588ccc3f76d413b8ba9f3ae17c981180847934805a92637c9782bea32f62a09e6a26b8702d8844822364741c7a19417835048fd811f5833368b4f90ed68b5d8d6f0a1f4f7d298f92b1c3348f7a7b1fbab7ec3e72614bfeb3214ef105c7ed1c37600ecdb92519983074132d64ace43fb85d5391320a0393a9d72b0f704547b51c8e50a1fbbc80d5fe959f7dc6e51d954ee630208ae6ef4901073d3fa0036b05ae102538b598d99e26032f73137c2355115774d557d2a586d64c9a45607e35a4e63ad8475f193485a39e6de57b54ae1864ea105c6fb2465a5aee4693eaab0e72e775af6f6f45c1058eebb17fc1540597b41713aa880c0f04a0c1c7a8cabfb346700f3ade4d53dcbc3d2ce199c5bd6140521eab60006218d8ecd09ee3c733f1c52605fffd94b1a22bb2eeafe6ef2551e77be3aefec5b9a845622adb09e9317dd43b73b8093242418337e235b676a85f318d77926d3537000b483b8e3769a97f0a2870820fa183c14dc5361d81d623ec2bd762aa64d2cf77d8ed71885a48bced3f506c2bd7c6cc1ed3b625897b04c202416b173a74c0f44c768c8e539f695f6dc38c6ecd742abea6e125a0321c30c1b5cfdba2707a548dc48ac6113dfed8cb23b686b3d2d88ac605422b5acf8d1f8c1fb245fac342be6805be509144b73b5d2334e65c119ed1bd0229a2fbcc1ced44f4ef9579337460cc4d4329acacfe02180cf7c2c20056499bc46d54af40f6d96e313523ac6f29f37fa3395e4ddbdafc2de7cd1327e74d4c79830600eeaade2d6755d16cc73a5e67bc0156aa32fa15e23267e7e2458b2e24af725a111ee34904e8c236b64ceb4a90c90fe9c1675861adce9d71167484dc18495e06f0f1ce8f59b6862dcc192fff08fadf85c05aebace4294ece746f45cfb99e3a3f1f077e63e64392e6cd334f745efd0d2b49d4ec090c6ca3496095228a376feb0d1c89dabd42e9fd04bd459991e9cd397c16ffa4e6363797aae801ebe66bf368fc42c53f7885b76ee9dc44f809ac53cd73f149263465b3be3049319c93141e8bb2a6386fb8aee97c1362ff062e86b66f18dcf80ec06841dfa2483d90ede6fdf67dcc91463fcb2ffcbb7295d973a40a76e7d6346d5e55dee02d94cbe3bc019baf54648708f7b38e4da25d54e2ebd5005d339c27c9628b7694d7ca0d92ede3cfebd080a87d1c575f4130dc9493800b7bf2834bcddfa8756c916362650e343ae1e9103509ae57af94c68b11b23cd995f5f1bc53ac5b4823e96a56852206131907a8b4f94ed8e2d325ac6fede23fca5a3d402d1ccca825399824e355a2c99d22e1ecf64034208dbb9023b97dd966633b4343d7327248f2fa14df27846699aaaaf6a90f1b3dc6598b9603fc65723b369461b59d1d74859bbda566f9c0ec5ee55c6d9132f3c6f1ed79252ce83d56fbc10e7b62cb28aa0382518dc4d0961ca786eb00e042d777d6076c9bc6516268ecc3256386f9ba3c950658da5b73b0611fc89c87cdc03d07531af7dacb09c25face9035f2e46d79e9ebf68b78608583dceb7cc15762d18e0f04c18f90cb72675890bc3f232a0dc797386838eabb5acb779f4c013e2a31f6ea6d82ea71962b6ff81244d4d15a0daa8e6c0adb6325a8864c36e4d5f0505e9634d002f551dd074d00fe0b53fd20cd32830b9c0f6f50f0ad300aee1023eaf74355808ddefb148b06dcb45676c281cc009099381942120282b3e6bf304f805b12bae49d517dabdda44071976927fbc398750a1fbb7f0970cc21d55f6c3f15213784b792a3d0a9b11803c8c554978f3b7535fd6416ebb92a4c8fa23cde72ed4eae03a3a2c0e7fb40255b429517e2f5ad733c11a21839319e17933890fb792cf6c7a4b10f50c309470a77442a8acb329f34ce90b0753c7d3bb3f4d8092dc81d58b83e6ce2239d15551d2cc8493b400e20e1229f73bdeed4b63733014bec82b8491f69f8040322c63113ed6340bc3e9fe287cfcb7f0e0cf4f838fab28c8c73914dfbaf3d73ab0df2c750312f689de5bb2eff068799e9a6e39487e4cc2a1a824d18b9690712559423962e9c27c08bd0510756b8fa35ffb944095396000a5d256005d078331cb9288eb1dd325a4a82550cc7be20d012178cf720f8d6b1d3f533d5929a4d81fbb78b0fd3759066b471a0216892b803d39985a13af184d2934a99b611925c4797da44c6c4bb3b02794ea2c29e7d8012505ae6b10c0dc56d73e93dc9b79576eedf5a310a4d68247128f2f23decd19012b74d69cb518992822d70fb1e18f386c97990518cc3295b4bb7fbe98f8a7d7e8220db02657918c7a9a7c4a327a77acc4806d612c2e150a8703c79dd0a468f2bef69a4d066daf013730881485420f7423b7aae8f77a4b84ccd9eae0a0950bfb24583d80f01da689f31f206de21843202c577f32d3918c2058dfcafdcb7b562db1e42b14f6a9d67a2f8605dfade97b77dc63c5cb3d7b41eba8fd4d00599a447b58a7d53d0efe50bc8cd585caf5310598fe9fbed3e0f4aa91492699af7cca7da1eced7127a67c1b460eaf99365510961976289885affb65403fced067486082d03fe0df630a0516ccdb0d1b49631f3e0153f28e8b8d19b9430c566471a1c1de54292336a653ba433b0cf4412a71210ed079dddf2ace90e47527a35f1a8639319b632d15ec891263ab960545af93166ff8cbad54637864c221435a60cc0c6c368692411ecb2cb3da23da9b3362fb33d9f1bfe2910d6d32094711e5eb8b4f11b7a4dd4385338523312f1f497b89ce11091851d8c69487768701333368604b86a4563c9d94e29b6c73ac387512c820a9468786033e73c00ea843edc22b2f3fef7b721b27edd6e094ccc898b9f9aaa98c206ba27c27ea58810863b07bdbd48d27faf90bb2df83fed1d79add711d516ffc0f1f3b9977d0ddd9fc8e5af7194e0d91d5b72a16490869a35d6ce355c6f51afa63833cd94de639b5d993b3552739399a5257d38e9c2b021c9f8e03e70343b3d1a779237479ae23ede07a3bd64beaebdc865dbb295b952bb815cfb05b6df8459057f222411020d401dd480fe4d6cec3a2bbaceef38180f3cdd8c8c2c82fa13c3fb1a8a8fb50f6082ab26edaec82255ccced803211df60e74a067f840587f1124d3b77d45aa173c0f464957aa7a5884ab2d94bcc17a5bf38f80b3dafb648c7e818e08a5cd3d240b5ccc68a764d203365e48268e8936950fb44676dc5eef9ebbe5802d0fbc644bb40d069ce391fbaba55137d6d67716d108adfd87e913ca3a946fb211df2dc4538559242eb65d53c22e0688e9b16388fabdcdc37b9dc9c96f7cfe747ea4ca61e35224deda93b1a89cadbe6979b84fed267261d99ba2e0eeebdf39323818e40966fd472068697402197a5a9aaa50cd8718a3e90bda75286dd8d5adb9d19fcbdcf7d24fee75466afd3557ad01b2ab46189942766d0d065b55884cf705ed8d9638c793a4f7ebb5158e0893c31ef8844d3adbd92ebc384f2fafc2a0199cca46548f5db6f21b74e63f55453b56b56d922c4cd45cbc6baa9d6a0f5eeb6808476db23b62e86a4db80e0633beeb19fa5622d545c7998575453ef0158dc25e3a2e14cf5f88799fa32d08a4c6756c48f69d76d0df9da6da69c089fb54b90380825bc1f5830907a93054dd044dcc1ecffed1acec1af50ac8706583910bba7652cf533c4a5a86c95c4455141f6ee5932ef6aa521945c2e30ddf97f410cc9d0642466e6db53eb2d4f3115a47a483f0597dc0f8d41209231149f063428b9de4d1ee9f7955f771b01c0d88c7a4df6f6de5b34c67f91963a69213dbd810fe5129bc849018e3f6350c1933898f797ee70f4c46d5deb0684f6963eac5b2300030bb829a8e6a14512235703a8f8d1da5ba77c7d649084bda142e688eda264ace65fc94ea4f5454c1badca0ef0dc2aac86c5175bef15856262c1e47e5819799d7251d7117467cb2f6323cfb760272460ca9a25d47cc322ec24bc8658fbe7b94e39cb87b884824a19fbce07b5e3d3ab0661bdc25bce34aefcbc44bafb6da66e25016e7a78b9c9b3fa071b98ddc4300778d1051d59f7ffc4444c04e4b4d3b0cd5b4b3cbe41585a6f83e0a419ef49627d890057cd01f8a4570b3e65def8e6959def82f89c86aed7f2e186485ee8d62c6320c7c882a6b09f19de730e7e88a49625c3b21ee5d2fa2a1b6de79b6484abc2262b00b5456791508c3c1643881f78a6f15426193ebc4dd19fc70a49549a1ef8eb300b3ae7c014cf24b3e444640dae20a25da71ce7a6593bce56f60913dff751a0f6edc647c7d539d2ea4cda60bb430e7a6df7adcb7c3ca9a4759f039eeb097ed828b3a69a93e94e04f5263fc0408b9f906c51e1a675949ceb8a5cba0df677802a03484ca7064c437a491c4e1597b02ab590f6fdf1963d413f2be6ff21ac3fc83b6e73438fcb6723346fee97a40a2cd1dbca3803c64427da86f9eb7b2ee238bfd98f524d6d7bf15474c317a0a66cc55f621476ce6a9685ac2faa4369e62cdff02f0d89ccc95f6b396f6176070ec4ca46928afaf569551eb3c5af5d46dd54e2777026f1ff3593872a99bd74ab4f7314c745fabd1b6ed3bdfa3628a6c026afa3aedf5c451eecb9d68cd9438388007bace388dfbc92a1413f3e4de30e0c40acfe0c70d7a1bd6c510749d949b8ae76e6c88eaab61f7fabf89a11eefa193ffbbb70af362284d5efbe22a148ba2c63bb9b4c1ab95b129348dc798ba89bb1a47b1ab4b3093afde6ee698040635137ad604c76b7c28cc19f6ebac7038c8d41c39ff68fa0efd136874230fb3416671a3e28c779c40c65c411af52e8c44157929cc0abd9e145bb1d9e9e198d6fcd15f679a52a1fe1a381aa3db2d24520323f64d1b7a663276771577b1b23fb9321a3d4de9e31ed99aaf272e736f4c2cb0e01283d1f0c31c1d629749aad894bdec168c76e580ebb77a403aa9418beec53474343a311aa89ef711e82a4483482a49b1e303a4c45ab6474014e2f2e6501f901a68413932e9654245271b27b3d59466f30b0685863411a73cc2091a242a03e71608ee720000ad00c63db9a81b72e2838fadf7800a02d3b9cc3407e3c8e783f0cdb32111e74ee63f5abf1ce557d20d2b86bc87baf63ec8780640c61b98dc8380f20c0f365188861fcd29591db88c9e2e4cb78f7408c947abf4d9a6755f62b56d306ade8cc36dfa30bffecd079f0e8c02b9bf678a4c86df3de3ccc759bf06679e7a687ad911a3d4db4ffef139d27e8d74d4585e38c9729719ac3e10f7d6ce7bba11de950c0a3df35611b05b6c4e1705b927702f041d6df7cfec146f83a0d41bc0fecfa3afc8877d1a5f6124042a5d6caa0d6cd98d820414744fff3e0104c1cfa0e7e1cfa3399cb6045d1f7f12902eeec5e5c32f76ba167723b80a1fffcfaf10d798d431c16466de6d3813658217a5811d5d56802abcec979bc34b42510a42549b9123621c02470fc110521c6a65d452888083d344573184278fb92cb1286bd9a1a1597d0e8da1bb6ff7505e813d860abfff540b4cee564c0b0fd0e1365276375a7ffc75c67a6b22a979e5745acfddff25a0d28435e020394f3ccd757b08b45892409bc900d217b6bf05209ea8f1d00f49f2c2ade7101aa62095454c7d4056b6656f05a85d5749f911b3fad100eae48a291cac968636395b1f06fbbbbd95eb0e40f598d5128de117e0e0e391fca8467ac451188392aae479e0d1e70af80c8375b471c2e4588a045aaeca930a4cd7c888e106d51fb37a36ef43f359d55b7a5525ad1ec3daa3e6e526f46e37d5486a24c22d48563db544bed116f88f11f1edda794907eaaff888b2009364c0b2d54eee0e9d2eb0ce34cc8f23204f4331c6c3420d41abc6a2e4366c4f634c56e400e85fb4ec9cf886897c7cd00942b78ae4ec21413d687ddc89ef5877580dbcb8428658cd0c34555b6b521468dde72ae8d695a5eb56f4bf4a04cb11efc3bf8232c40bad6ec4d22cc40e336ad5b839869373ae4dcc0a9e87b703e4f5ce40ee46477d44751b3c2fc759418f05b4b7023ff61202591c93f4495242459d4b6c68755db96a1c0a0329d992bd33efd50cb0e65a4498a00a775f7a7238148566773da338c6a4cf7467d1cc5e3e67b34c7457aad4bcbf68a29955fd5b8e00ae34019a2daad929f15e9defcb21617f480c013f1b757930f877c0ed49c2f5b4eb08f6ac3a3295ea3a5ee926e8723c2087ec5033990da94af24e21424f7f73efcb975c2ffe585115bd6a3b0acbfc32e57fb2095108da445ab25198705ce55dcde0e759fc9034b7a59e1419e168b4eb2abdfa986b98e8cf6fe531e8048092a2f24807ba5dd67aaa7a2a38204f762a59266812e195a3c5f94b68e55fbfe512b72ee9807e6f941c610f69bccfcc042915ace362e3c21dc64b2652fc20ee2f665052bd54590e5d998018af7d9fb7f88a9a55e671dd4ad6aee80906f0aca7b60540491cf696084c59b09b040f89ad02e218c3d68e353da464351491d748596d09ad8df86d5b409a435d547327956e96357b289d993cd0c200214c89f22b7d3cf4d473da0a32c9a07295fbfff61e7893edc4c8711f7ffaed591fb6ae6c8a610e20cdce5d4fa9301c13b689164a9d0cac92c7bd7e1c09f0cde3fb65d4d4457b475b636d2235561278d94f702ad2140c272a0bf993f8777c8e5aa420e2cc70f593f669de27defaef3296d575806e1636b9d2702de7cdca033e4fd3237c8af6f1265259c9d1bd1145020336e364ca3d23c15a532bac6811eeebcc8c1ab2c3722472fc6b7ca0c161c401cfffe08b09c2e3703afb303a5ddc18c86d647a45c45e1626af0f9f0936930b265aa2438f6b51528626e4494f425221aa68204ccac684c0dcf138b8f942206842a5d5ab71928d26a1f6698e23aae486db1816e009eb180ee855bcb359d8152264ab49b1496e4321473b5cfa922183b16523131a8dddd829834570724c4b60cdb7ab809c9a663de17d26f03cf6cb9f65c710f989c01758bd43bd2209f08c76a7c9af59c4c87121f6de11d16c8761bad38e51dec282490e7663e014bddc613525d9636bda4319fe6b4bc86db33e5b227cf961a19728d35b9d877a593e2e8855045f78aa566aef2b26e8f2d935b7ba30f90985b5675a7e6c04b3ab123a03798b4438662d301c8eca575a846f6580662c830842afd548c849fc075c9825dbee6bbef464d291588d169c4314d57c5157310e87b7593c47940b29534722c49a036e571ed29cd05e3deef64b10e86e8b94b5f4eb05090eed8febbcc8f41d034ac2c344893d0cc1375ca75297c46ff68cd51d904c9b95f116cf39cd6a5c3a4cbd36e4a0517b5f0e9adbff24b431823222ddfbd21810b07e4bc39b183ed080047abef951bc53f29fad610bc18c54fd7828101acc3f354772efe67775212fc3ca1a16faf854cda019bed19badc0f35e3133221e191c4ba9754de655dfd4e7c7244ce7582fc0b27f34c10cb89d3b3f95c3dda29e323b21c276a3c691af0873d7e657e490e393239c60c2aa3bfc90b1ee1b055357b77d9d7aba2dc6bd3823718c3c5ec1bbd8b62acb9943cfc5ff2f470831ee0d8b8d84793deaa767c98f439b387a16e6dc1f1929b9ea5110771a6e7b015d940cc82647d7c64fb4b99a3ddb2fd674f6eb8bb1daa1b264f90d7dfea092160490d438fac208e47da620415835bc3ffab0fbcc71b5ba459ea8a47e23f49a144d428f0c7ab6edca9eda889ba8d03fbc7aa691acfcba7a527f510f6c3a7461360695a5b583813fabfe4744559e207271a518017bda9bc77ffec1b9eede32540a4e00390fbdc0e185ed5ff20428b256ad0ef5efc1654e022ccacca57f547bd431a764f2e1ff874f202924a97fa9d5dc9fa492c6cbd6bd1e619d2eb51f261ef6fd557a0d6b1c27e6cc119cfc90d5810bfb4218b4aad579c0b1e9e1f558a559c14c4dcdbffa902e9902ae3b984574bc3fefbbb0f93c970622f68808419debfd0c21de5c59efbc1e876534f3bae237fd84585535de6c0e87047012039e77c86b575823a92ba2d929fd357659b54b775cc8a9b704b71edb4640efbfa21219cee1cdccf8021287f2963b7fca8cf9164d6473426b3f2b2723adae553d348849c7652a42f9a79a24444f01a7c551130b2f520aa8cf606c926ed3cba186aadd458ca977172e0a47bfdba2e43ce7c222f4a41d866cef1567a532b89aaed71b96ab2efa601bdccdea5b1bf3928f7c6acda2e3f77912e93b91e4e9ee3d4f400802d96a0f96a26776f1a800cfd4597d9d607ecdc957dc44873e63b9b27d26d614be618ba20489784a33baac7d40f9534665c0449ea3de81384218d5b99810b896700ab2a1853f98c8cd5b0bf71fa6592d89298b049c59c8052be035d0fb234d306e8fac6f252c8b5f21744078c7d5d74397b3c39f12efb1b9df109ca49802aa3bfafc47b94e9beb3870bde0d3ab9c962d5dd3e82383946e3bf870c1df1164617e08b28da05055d3b8bcc63c95fbaedea0c6ea9f8eb5e8d513beedae7d8b1a93118bae76f7af3137f53a3c7bdc097c6f83a2e270cfa0654c577a3edbaccbcbcc94e519a9ce189d2f0faaf73cdb52225198a88c9115e95ee859c24e2c82a4bc9c964bfd425a250c0f9050c86e9fa94c6394308126c964903a7bdb3116dc27bd4270eb4ba2839cfdb01dd4d12ca7968c1ee17a05f708a6b2b1287c0a03c88fe58d4b434a5284e8e6157206539096334276bd3ba2aebb01f391fd612d94647302035f1894aff0f7b797547bf2a40f2e3b45a2d6b78fb1a3c1a8a53836583b87bb8f0682e68c62be96bfa7ee3dde61424867da4f401b5f8436fa079dd3a2793b8ff0a899533810e62639527056b1247a0cd7a0854a8fd926d4853e046c5d16e8313df35ccd53f3c3e3bdccad9307a23dde6ac285ccebffd7eabcf578b27a0d09caceadd12ce0a2989aeefc923e956425c9139f1a4847580ea6a32025fe5f7ce0329357e4c964275dd34c4ad50af0b64e84d30fd278634525f7e9a7b4d302856b83ff6b4f869313d57c32d9b25e41d9b24245982af74cbc417cf23930b37d882ebc750290f2513c92c9da4237604a214035ae1b6c457338ace254a62dba8a6be6184b7120efe795210531d2ac52c82ffaa3cad2fb4bb10553f4cdddacc1171ad735c9cacc18cc03d0e8988c012e7c335eacf8705ad207b57b36ad0a8f28d8e045cd3507e8803b590fc51081fce7c5a7e3c4f10a5f53aac01040424c611536b1b881ff1e52ae1c8337675e1605435d0f3f3cb5a5a0cb220c2ab00adfc141f4fa941661bccfc247b0620ef175773a24cc3f6761d47a5abd38c0cb29af7523bff7738a1aa4dfc47991a430c82963314600f4ca2d4419de1ee58028e1bd6982ebce0c967561d3a62708f4eb6a6a0996422891e327884693785847b4006f79b562114fc754b7004fdd47f5e70e28c3d3584d7e66f393826e4417402f5083184e3c2ccb17f58ac89597b267769c88ed8850d0065f33b51e248accb875722bd2c2e5682327d93b468942aac7184a7892723b7f71faaf5928a420f223d0195f66c16688af5dacb4632d2f589f21c6c8867a1933632588a0c983de58c7a3a488098b89c420567f21fac652033569f1f9d6f598c9c723a687509afbcc9f5ea21bb3bfa9eb539a23daa18aae5299fbe5ba0b21042c6ba17f4aecef0be54810a975d781dc0f5ca65d289486348272decb74bf79eddc561d3179629aabb15989e77d5a569f36d4d0bcfef3485ce7c11654747dd15966588ff346d3be39995cc3b803638ccfcdd55af59de0f2a8ee122f8a45681379c50ff800156051ee36c559e4078702bd99189966cc65c5aa2d409085fc9682ca40e2fcf0b209e6e1bd40181b27f9cf9ee35f91b29c73e0bb076361e3ff2bf94a621ef8c68aecb0339fa4d6c047ad30c34bbab022e3f4d707e4205049ee6fd3b0714b94861f2ca15f39c4c54f46444ab90b41412cbb1ee6be6a09f131b640bfc6ceac9c71a2de0e7e20fac6f1ca4f6c3bbd66f4a7e4bf040a8119691a2f1b0c81a7fc972589dd4d45a50895d56ac1880091746d1a8d349801033159ee7135822899c3c4830fc9c52ce77e52e9d5a65c7a3f073cd31f4874bd33eb200ca1dd613330ce5c543d97983e9c2d7fdb851046c42d18d8ea820186c4beeb86449c7fa5e066c53c4e10a60db3226b12c3e30098eecc81e87a180a07a5b1ba0434784d72ab8d0f2c9dd97b548c60e384299ee3bacea17048a4a45d63b7f0b6eaaf6b7e681aca97fdca3441417a337bc7d74526dd5ff36b2b235f46492af805748e118942b28f90f9de0439db52a0859931580cf8e5fc920f90a36b3098d6a6f504db37445a6eeaae4cd1aacab5ca7c94c82e45f569a773edb82d24c20333bf3ecc9c263f712fd5f2e4c27d9f45e2d41299edaa617151ced5096c229af74778a488c5302a0f3e60c6f25bfec5e1bad28418f9142333a34efcf88614f9f49ef26f51ce1cff1fed54032feba31e33e2d40c2a2c06d78d1ab09c33a3c8760b1f26a608d7b7b6931e12bbd29a9735d229dbbb3b9e915d34782a0f8358a1ff60ac6df4155489922f8a54ad1d43c9c17554a4248341237228bbec51585a3f6ba71f0be3b9d15c316c00107eea47d4d351c829d67762855243468e2206559b889b4bf297e320a195b91a8d9d1ac7b064ee4ff7cf1b6155930f5b604855a309846fc2d8d139ec545319a33424931fabf7c9f444c5a90594dc4685fb527763572625b921730ce1fa117fc60840b9f78a767a04d2653626873f2f8b058aba6579b850fd8998cca2a8de7101f437e4e2177be9297a42c0cd8aa8290bb697121e8be94f5544ee21ef0f5e4c4ddddc8071b93a843caca5c413f67f30e1f855f23efe0acf06b889f98910d93a4dc95bbd91f8d2f9118b4e45a137263076d53a17482577205fcb544813d67468a546778ab07055a7d825ac4e0b694c2364a97b037189d28d73db0835a04ea78bf7c876592685069b38f17efb190648fc6e126eaa8ad7a31df0bd22ecac8eb6cd9b7f0489a662a246542e19f74acb4770f042a7189ac2a840d09a8ce4d40c97068c353d1f12ed4c1a72488cfe45c85d4b465e489ae22f486299db75d761708bf3e1d4144449ef06ddd7723044693083415e0ff913c75e93af170bf463331cb2bb9acbccdc162c4706ca0d537868c0a505c6dc99dd6a2171f02b8a52cdc58649e65cfdc73ccb9ebd3f438846b0121b5d82689daff484ad115930c60c0f1af1372038dd234aa30e9cdce30ac141aaf66f649be507ea611e3eb1aa9c3fe6d029a2dc95cf1e55fdf9e4548b2fc8a86ea2b0bff3733995591b466df55a39edcb895bbcaa4a668fab68e702ff3878748b0c77a5602d18a98d84e3f3be50b285876d1459f581733cfa221a81ef5da79a1d9cf822d7f3a1ef1ce283d512c4b89cc517343b1dffbf41a5d0dcf4e08e092ffa96c1ea953bfb84f613df6d5ac26631f6ebadf284d5101d4e469d60b3d135afdf483015bf6a992182ad8d589f13e57d171790ea2a198eb25fa7c9d47af0e7d8ee8998d2aec9a5714972f54c408a6f49a07377a6cd9b1b3ef6fbe7326867cc2805490fb5b837b5240bad582ca428b21ace0bd3989fc7048161f479cfb098b790dce6d49f959498a02fb295077d412f44fa071bb6b88ed57189c9cec53a0b2fdb80a09e5e25eca3533bbd292ede0a01cb6bfba10b2a87b6c8fbc2e3549c516d8b15017f299c22c666c981682d46f4cf13a6f8732eec41a9b2a0509d50074782ae82bf8d51ef557d32db72f28bf35a07a5af6c89967dd43664a466128e07cf4064095905d142f928e188972b3a3fcdc033f594693d15c466b19b268ceb8891e69b2bac5b7e9676a14218b78d547b8cb1b3a50608d75e92d797c341e3c846333990ed6f15c158e7db6807e1a2b7fdf3dec9ee04a3b822ebbdafea451f5e5cb01843a204fa3aa9dead0be8d0f5d6a020e5cccc4c9e608dae3ffad7d733ba21522aa56ff702abaf4a548aecd78d7500676616cff29b16e8afa9872d32259e2dc81f800ee36a63dec2cf0f194fb55a6c6ac7fac247de7277be59f36ef43d61e8dc184a6ebd588d1acbc25a36965c29e88f6d2ed8ff2e907f4786fa62791b04e71501cef1e1f99cdcb2d5c2c155849c277cadaff7144ae1fe328391a1bfca0c958e3cefb9720f346115e7072749ffb8d0b1766943ffc8c5c2f0ce1af8988247372994f69af91330230dcb5c6fc9a394aec9e90a4677ea31cbbf92cc330cb278e96cbcadb4d271d1a085c24dea28d369deaf7eefc1b7ef37faa61c38d24851da13fac04acaa78671cf88bc91a9e71f463649a243c70872c3ff5513012f7ddcbf01070fc1752a8709550ff375317396d157937eaeb55d9d395b47fe8725b9755d33871d2754625d362ef6766944ac50d0e681f5d3806780e0f58ef7ae6400f7fd7011d97c494ba42ec4c414c4911daaf4916e1b36113d7438a1640a814f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
