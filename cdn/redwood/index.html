<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"761db9ce866d5381da879e0ca1c4af6c060b25524ed54900c04b36613064f6962ef3b7e28ba5b8f6b6ad4161432b457c59b1a28fda57d450e4613495f7ee09c5f0ea6e5a7b38d5f10e9a904a9516d91ed466dd078f103cd2df0e6860bc06c61d9e281dd1cce979ece4a113d9b0a45f0d6a80dc879dc4ab2f833e2cd625aeded159211c0eb1a5e97c80aa6a6d8e51659afa5a4b78eab1e4ec81fc3e2b2eb81db218949ddaa24e886696e17cb92293b02a4a819563166cede12ccc0a828ab4f108a0edb59845b593a68087fb74322a3dd5639251520ab1a7454e6bd11775f32922bcbd91b86d3c936f76d9de2de30bb364de0beebe7cbb553c59fb7612f1df3ef206fb70636aa9e44a6c04df149a4476021d72b4e5af4a6f4842e7e0841e13cfe249fd96d4639c503014e66f1b3300e153a2b1b46ed21e35d18f75a2ad2346dcbba290a87a8c1c3e13738529dca6ff341565b3eebbbf886462e4f491d2e9139016e54b417e6e01b4d48a6de57afa5a0c4f18522f11b3126755791f946131e6c100afcf1d3eb42ce02f06cfc1af999f14b2768f2262a63144e859c7897bfbf3a554be8bcca1f9b6afde7ebbf09628258b9aa7da24aba4fb5fc600b5ed7757db6eb92758a7b146c15dd6e85996dd3ab8c044964b76424bd9a7ee42a569b22cb63b5b08ad3b0ae206bfad6bfdc01f20c8be7ae5ebdd456d303feb5256d24bb121d703e9ab7136863fdd787e48b5729bb199c5665152e7349a933e0f0d7758367e5417f33d75e6878d7a28ae03862a24d086465dcd498321cce9e3fad2e79af9e77baea0961fcb70bf37fdfd58491a5f143e8903bce1512c0c857f3ec48dcef0f613cfc9801d473fbded03001e452e5cb6c486aaaa16142cf13162ef6ddc76228d4b28794b5c684442050c3a940f46944431dd547b5f91d8bfd03b985265e196e4e9eccaa54b85bbcd7c04562d692e8d9bf2564b2f8e8334d379ec874b39eb86918c84fee0ab303dd249c133acee10ed3ecb3b1ec77900c0375453a03d3f2c0e8ceac57ec5e0522b5c85906b934e03878d3d9d015860ecdfe46b010cc65510a8cc92e9d2b280dbcfc38f155b71820ad195ce33a31983381541a362eb35f6d64af55f1bdf0bd51a3a096344a1b5989242a0e92d3d3061aacf9d717e043fc29d473f35a5c74c7c5003f3ffbc5f71ea9b07f6af731a00e4c19088b4717bb5d23661e6bb57df7d717b5b4762efb2d05ba8df29a60a7fdd59903a125dd1353162701cd38345c3cf8ae0ff5af2ffb01c59b615a4300fea88e05d508f843218ef1f031e20af34a43850ff06c775098b45c61dfcb67790b79d975661b11a9914a022ee41a7ccad4487aa7f06dd7ed3632752dd72dcc3a3953f1baf02a06700632c44464fe4ff6d5f96df955c487331d12f9f1607ae7a2be1af02e079305ba7be48683a71c041e1195ef489dfb73d8963e0e52a9b3069600b852d8515e429cd0b8e166c5cac2495125e42b6251a6623620d5b273bd0defb2819b9f003660b7191050ef62297515f3ce28b1882aa53de9525007db523db72a2c51d10d7383824b45541c85a3a97f85284403c54f2451d8addaa20aa027f4f11c2a43a11c4b67cf9354751eb34550c826cfb6152d9b8618850a616806836319a7e3db8e6c5bbb1b373c03b24622b2fedbaa9ac46736f6e2abd08f1203f0dcee90b7b0fb7dc5a66f29bafcf977d0f4e351ba9af87ad68eb6e389ec0ab66dd24f3152d0d17b56a5324de541ee673dee05e4f43cfe3dd92badbfd388005a9fb349a855896da1ad3372c972a518a7c8ba7fa9889066f33d45c8f725603d8cf8a0cf53cd709390115a235ce4347aafddaced06783887cc07f99dafc082541508abc96e4f34997cfaf05636f83626e2b75ca3feb65fdaa6bf5456ec7b666a89450d53074b1a8478f1e1c3f35360bc06f1a27cb59ece967b31aa220dccbcddc012debc005747d1518dd815e9bd20b1c4168098ea23335bae24613418db7a4550f6e3123aa3de6f7bd073f2073066afb8034dfdf869065b0dea323499261383c3445c8d48aba7a77ee650bc63aa97e2a640a85c6c6ef134c2703d421db989a853aab7febf8e4bb8253c47424c2567840b4e83dd31c1d03beaa43d49fe616d364ba5962687c2b8afb43e9e08f3254fac74241e3172a8e76c53e895ba54f3c30beb9e201d98d4237d0f2e5c022cfe4a8259675d6457cabc8adc6b00b7e152ed3439b9f25e130cdea9ea3806568d25dedb27ddf71cc8b5869f47a31df46e96b5966378ea8ebf194d17f32358bf956f0620dd6e82685655b5a6e6e2e854197dca451bb033f7b1fe336002154434ea22d05cf80318c38bf5ce278aaccb4e126bf1e6cafe8e9a87ea442dffc4a5d2ab17813c61a6c07259e5e1eb5df704665ded207dd96521f692646cce167881d41a67ef5a0cc86c8a00c1cb4f08bef2e1596fa9ef5d61aa759554707aab05a3b03347a61baa79098f1f85fd12614fb39feade92dda393d814e8f3b8620a377539931470679f8d57687c2972332530d632460682a13a330ef15ff9153a7f0fe7a2a04de31cfc3d767893ee36256b7f9619b0313310d363ba74e5aea821d3cf3757114791ce0ae6794d2bc534e61067aeec12464c3da3a122286c7fd0deeeed54359cc01bec76756123420cb8715b766e9389506f8e03014a842cb4d4a152ccdb2dbb56eafdd63fac8d07b5a31665c0fa4bac938f00bed65ac8d1cf717ee69454cf9771cb59588a87fbb8340167667b4709983e0fd653f01a83c11715d22254135f43cd047bc4e2edf7c14fea90afc0da51efed35ee27c0f9df07dffe8c0065fe8e189f8d3396da262047bd6b69192f67154ac33cd2e67e37c35de848f7f7803d9d76178c64dbfddd479e7028cf9149c3b803d3e704d55db5d9a7c49e9f5d4f34be65596183c7beb01ba7ef7a9ed03757c262eb56a159cfbba7dc5e17e07e5db6cc10e51372449962142d5c47b6e3697936c418c32ee5df80382341dbfc153d8faea9504a2f9168bd7c34cab4be61d30487770acfb0a8e8473eaf0847e33ac9bcf89e9b9d038bfc24f7a5067c19f553a3efed1baab7f2ea219cc6455f36230a61ee26f4f3a91facda203c97bec7bfb60d6ea79e23bd4b4bc918c52f0eab3d98cbe3ff0580b1eabede6fd9ef1347b0fd732b9c392ce30dd115d6f524100e4afffb9969d21758968bbae8635be881ddf5ee4a7fcadbd014646cb77abefae990de27981dd4bb0baf6f8211d5dc187cc4d3190505fda12de9d1b6abde6ed879db1f0cb012e2b1dab6f0fcdf2f57333c0d68b34c977c11431930ea321fd2b5c310daf76140415710d2272b31e547c068fda7aa6cdefc8f66e4a234465eafd2afeba7f520166a799ee00ed19f2dbbcc8bbcf15fc39a5916684ab1a6fd77e2c74f10019d3925377f36ecfa57859a763e7f7e31b16484c1786a693840db59430c73a8b3f6150a31d010592f685a12a3a44a938bc8003628f11adf9ac5c7df78e1b69a7082ce74f4dc98837076d8491d67113f30074663f4580086876983eeb1a03eb20a64f35e3ee3210d88dc7686a9001a2e1602e3317bd9c21ea5c39a6387618395d3c71c85e43a122801f073805e42115ca03d06ae898f7f58fa4fc530d62f589572845174c928e422dc378856cbad22534e531e0378754d470c8f5df44c9ce895139cf97f53525cef5458fdf6761b5b2d709fdfb57588e459308d35a20c2b1472b9f840a9b7a44ba2801f01c9e6477f316ea19c02b9e277a8cf209ff5633ecbf4b08037aebda8a171825e59d4f15612c108531102f0ed88bbc910793ff852aa4ad21697661c85c873e901040a4e97f80e6820a11a7a39b24a6ac79fd9b27681b70a400257f4733badf05ec67303035a1565179d56fff618096721e802f27082b9cf307ac492eb09b0e3975f3805b6b3fea19b355597a4778d447bfc14580ff51c38339600fc2591f683f8a2cf35142715dd738928c9a150434c5c182d36806e4efd1077d0693a8d122e530305bbb953a537e93bf6829db01ee1f94c42af62a800362827d1c79f93c4367222c6ae20bcfe64c1551064c51aefd04cf01607f904f4cf2f3a483ca7fa9894b9e96e9d23d03df86fd80fecbff1e0414a085b36e04680c44518b28b09caafa257287fd40cf67430af49d9d1afb3298edaf0d36efd7169760627effe6b2133d9baf8c304f3c58f995c543a2a56b61a4dfba3b3599f885b489c9984f79be8965fbeaa95e2e8f3c91d109809e9378bbc849660d9d6a370f929f796fe40016ca046a0c65520b0a4f33a14d631e9905a5faba98dc3dc4f521e1c4801c4fb0d0715083f103dcd79755f6251f85de455640408bd0e9d0e824da7e8d16a09f6624577ffa01fafaaf847b6947e61e6bf91e2aa2ee979a1c930c3010b2a1c2f10d91d241e31bc3306f9bcafe234727a40425690ff58e3313f302ae68b1694da51e019e5d11006af9be8692a87f29a767847ccbd4d10c591b60c6e0cda851631b7f0827cbc9ac0da2fb1d313f9d88036ec5e1fa12331bca6f057ecdac231f133ff691f62916802f8117d0dcf6b52b608336084a36605cad6d586b6b7b679c968dac8191641c12479f2f607e3e0ad67d813a083345f7ac722b4fd2fd32c7a804cffb05821c252b650386ad8ae529b4480421b8f43b3a469c93237f0592115f393233a2737c922dbb37a8b416491ab8481bcf62c56ab80ba45d9ce5f1d88f92203a98eb7b64c3341840dfa176b85856eaf753dd4f8e656696666fd91ac542aaa018dea86a5b13a7cd478820cf5772c0ae1b422ec5d8ca93d8d42bf5285bee7ed22063d94ca3ecc679b80d42caf424ed2cdcbcb71e28a6d6e5a6422cd0df2bad76dab2a746679282b02651c7de02d9bd33b5939169b607f45aa28106ba8b6ae9b8d853e957bc0f5b47a5abcb1c5f81b4e16825c5cb0a09944791efb79206bf45eebfd7afa3358a4272192db626596c527eb16e2ee20f4b37c99dcee120d6fef6f7977a389a0e82a6b77ccbf576ab83a33e083ba38fa58c62497c60e33487a51017443c3ce80bc682141074a4cd56aeaad38e530847aba84258d02f674b6805eb646e2f33b1cf1573e6794a433563069ee62531648df24d3a6e97ae3412b267b31dfdeb7af9cf3d5c14727f49201ae22ded0f3ad12a7c5a11b918dec95f32995c32389e9e1f4163a6bd257ffb484cb2a7e24beefdf58a17e7fa1be71829b346b37572af79898a9bd32ad77106f7aa855866d9344fe6f8f48fb722dacb5ec1e56f663558ade29161e3882ab72ae250d7a6bed731804fd070436ae57024a7aa30b490765261731e73654dd09bc4ede5dfba93a8820414005dae923dd15e5bda054eb19363b5d7b589b7aedfd7a19252aa6758b3fdcec8965937960d5c3d48ea25b075f2b727f8b8f20928dd0328b2f6890de5ea3a01a265598ef9bbc696d543cb7c0c3744ea750e7f8bd7446b10a0970505883a4ffd4b284e46b9b168a859abb847ff1168494aac9eb17476083464d001cdb5983d713e6a0a4c9392a50955169531d070427c70738cea0592c467ddcc597762fa79393eb2be00bdd9f8e562e627cf991f3a549405282b84bc34ecc2439472a0ee8e5f822377bb2ba96a541d901abe7a8eff641d2393f4bc1d5f37ec40be689fc7e1d0ab078a62d20d869a4d0aef173c9939f7c60fc67748dd8bc269ac6256da4ae0ca1dd7bee5eba2a958120318e2dc1942203d4d5861bfb12cf7c6a9152fa12e87f6986f9fd5c17a8a65d5dd1e5a7ffca234072bfc1bcaacdf0c3fbb8334d0cebf90e7e146d72c393145e9bc1b61466808c957632789a33d2d92c011764c3407c2b299a2f3d5b33f0ae33cf1e9a2e9ed2b6bfbbce60aa0f813cd016cd5b8d874943f188ae5c1299a02c31bc83b81288585cd8fc337a17abf4ac9e306cae49d282e582de0e9ace9b38e43bdd5471927f3b0646930d1a513bb78ac6e57f506f0e1f6c101f2bd0b57440d9fdea190cd10c4d4326a722f5518d9edd260a5783617aa8a7a18716624212e3c2d49cd538bc662f2bbf1f88595352fcdd2b067f25a801671feb4e1aa32d46093ac0d2d684ceda9b8424047f0e6637af9fda6340037d5a920d48ececa2adb91b2882487034f3c197208d85978e1d95c0146c8956dfad54b63c8ec44e621e9a44936e71e3823dee8e5d7d3f51fb28d7cdbba9527f399cc22efb2f56e57cc7273d7dbae28f4648c9444fcf6706373a6dd7aaedaf1fb734fb0d82a1448892e16c0e6fa2b3c541fdc729703ab83abe72de900a6c23d61051971de8bcd4f62052aebdf7c95792f1c87953bfacfa08fd2cce6ee6579fafdc63b61b2f31fd60ea19908ff6fcf657bf66a2eed8d36eea0cefe156c90d394e2a5ebde7579dd7b661395f963b8c974178ef36a4b81ba9c43ddff307df388643e0209dbc61e410dd63fe5fb7f02590c00e7e88fab73a8e45df4456713883058b5be9595262c8188ae74085472dfcaa3e8e98600605c0b0f277640a404cea68231e6668b1e5410a133ee1908992f934d7a6542502f52b16d17e501c33f2b4f68264733433caa0ca9c7dedd7ac7c9713f92411e652cfa8265579f392ffbd044b3b73ba50ce82b0606715fda704079986647516386c4a525efdf615f22af13cf277d3156da33a317429c30aa91422843c9c9d66d19806915239b98aa74f1755f3511742a21b66cab64418c3b3dc844e2de886ac2469c1977cfbf7b54e1117002101e28eefc44804e327361e79ee5261090b2994f082f44226852e2fdeef67d8fd642608076c58f041882c35b72718f64272dfe63ef4b6c826009f8d8bfe5085994cc5990ac257e0d39f8c01bc047a5e3bd31981b44268900dd2f0427740eb404242a15b35ea612de03f58701e213011bc9481610224d8ee9f3abe40bc97c47107f27cc821f7d35e745a7bfcf4cdb3b0324b7eec37dc7c75e6159598c704d881190925fea16f51cb9f682fc807898d96e297be61b28f0073f6d4a5501f1a65ef7c6ef371799a708aba6edc61b0c5413644ae164550901840760f55854b148d9df8e73b4fc0cc4fe2911b98cca13aa6120df49e70e996cc4f31e4af8d583479f895fe06a0e69b848c30f2bbb0ac8302401a857d8f99c8db12e3f2f7b5f9dff43d806cd59207e3636c5107fce6c02f915e65e5912921a837d4b83eb8193de7ebc2db7ac35961b75e3568dd02beb2f79423c42800f5e51da3867aa96717f2a81cf41a03aae0b4c81241e2716419c1254d4ea4150da8fef73fc60f9a8432fee38544ac63365c21b77a113e89310206aa39905bace4ef4b87d8a30da9a4bdb94e199d419a67d2348cf4a30f6ab04953417eb002078304fd7b4a86c8618d54b8c8faa98b281a6ea211f9d580487b0d9392954f20ee1d031e823512151937bc43e22612a269c1eaf3ba2de4d70127b736656fa33e907af8ac7e989147ddd66194f49b3ecd664c0507c9ec4c01cd65aa6f7cf3cdfb7963a0e442948888de066066aa307c41699c0eaf1f0b760c34a987847b419b51fdd5ba68c657bf48f4cc22ccac12f6b5dbf6553c4eac44aefeb0890d3b1c9206eb201eb489fd98a6172da48501fc9ab13ab88feec271d3d1e065c670979a8f329aed841ca686bea51f9f9747a72e31cc894eecc5c999cd5f88b43cde5aa30cf1dcac61aa3cd60ea0fdec863ac8e76edf316c64f468b88ac72f213699ef556b637ecf8a63243acab7818dc1d1e356319867e5fcf097b299c8f44338ac3b0d7c43bb83562cd85ff377be94b67d1ecfa50db84e74361d127ba33cbc37bbe6cca90add0efc9f8628dabf74cab4bdda9c0acd010410d63bb360a8fc30bf9fec6578b96b2885404ea63ba8cd3944a50b219e7fc83d6f643064a07892e50a8f5dae76565ec76ec77a84185c38fde74a56fd66db550a02d3ebf124d29ef3c4a8b703591f9b28b7df90034140076dc6faa11879fd3e3230983b0096b96de6f7069714f8d8cafc77573fe55d0d0c732a6e3d619b078eb9db5d0bd39d9a5dfa28e42e656616779f58f6d9ad11473e6d7752f8bc9ff25dff4b91863e20d8da78935d78286a66e7d79a442fdb9f0b76920eec2a4654282418dffa968c37aa8ca714fce63ed945298fa67fe6af68667013f5b85dde129fa572af46e899e5bf5c83756301885e6e7ec6c0b65c7e8ccc2c53b560c227586453d8a5cb3b407dc847a4c8b0a82a7829e27c3c6c5f6a81d2d28e97fdf61b6e568b2e004ed28f2fa7968704cb1b3578c8b6ea337b8b4bf0900c3cc87275deaf6b81f198d06875caa3c70975c2db45aa85e661974b9415512e3b7cc2bce284055daa81b0d189d7ce42e06e7c2fad35a658c6e12f62cb18bde831ca2085b1d4abecc2ba69aa2c9dc22e6dac694a4d544ff6d737cb69393fc5f17dabd2c515bd77d5177e3c3e9280521b1cb5c714ba3c6a0e76931cb9f48660fb03316d78571c9c28c626ed1e405c9c575e55d4a4d975fff28b294e84a737460ca3a13f838d126f69c600b3fefc7bc991f17939f8ce3ea85acdab5c2f51884a47a0764b1a0bf118f5a08e981ba3cf202cc51f8eace06887c41679b690aeabb2abdf5b40aa3a13ecbf88a048e788b58f5eebd50151805c3a08476fcbc070c922dd0b4dc5012278d97aecc39d52ba48bb4fede6cbc54d93845ff3fd489a870c2cd0b02602f6c0f97c24d9ab3bcf8fd9b1bdfc231b55444bac377bc021ddf18b4db7e8178406cd6824a59c8ee420e2a2e705befb180011f605e5cf9d93c7f9961b4c7c7ef010ce42ffbce9b17361a426f3c3ad59f6ac56a55e732c8cb9cc32cd4a5857942dcfba4ded174b9fafcd39c5af7b64c39861daf401f9275ec93095fc6036df1707f5fd733a5bf55bc65f3987f97c1770ab1ac4cbd474b430a6ee656f09e158973c8df29ecb722f0d58392474f774e7818f6d9f1a8cc13a202faefc46baf457f94f36e50483cd62626b5bb334f1fabbc272d158322ee2285123e0f14f03ff9a57dc558406e30b571c74bd7001670adf9ef84660abc44d5a69ccaa622fcac6a273d7e41d35f8dcfdd024314e7351b7339c57fc0168d2535d93ba34b26c7d3790ffbcad4c3ea8cd7440f7e2668b44b7a7029b58e49006710756926f9183ada902902d252cd3afc0ee44c0ae33b1fcf507bffd2fcf11e70e43e501aaad0fb8d68b3aa450d6f5fc88008c6018f6ca242ef3d7193ed4b93e5bbb4ed2b6e7e09970e9a4053c316a9377f2ff85fa2339a8c674a6795370a63c0081e45c480e71e332f2f31a4cd7fcd4a2901a501cebf0682b9a10f687f3c5e0b471e2e0bd5be5b04dbd861afe1f559e42d2c3a7deaf35532c54dec5dec0645222d85d91564aa0b8794d3c986c2a181f8b75534fd10b777a478379e34abac3dba195ea3da2500e15c7f64c61e4ed037c4199ebef9a26137c31178100cd0c45916f96509a2dad6850ca32355f365e7086b955bd3ba4c8d462291283c7800ad9c7a95269561a64acae28620df3959c604739ea56fe987e1b8fbda6a815264abf6c42b368e6683d156b4f3cfb8e378724145f2c16df15b679892da810180ced9527494a726a248156f1f8d6ca55034983d850ba2c9fc4fc20f3fd66c5ae47943c5882bb814e6427b7ff8af0940cd04b12762b6d54fcf683584f3d4c0380ced67e37c84af6268712ebdd933d78c74a951deb4f49744b7cbf84a669cbcda8c8bafde084b67595852efb15e37764baf4d64ad1449bd0002ec732fdcd4322e3559970bced3cff2f8ebd8126fcf46a7f3885333fd2872e12a3555d8d244e0c41d5eb5d946cd2d625367129df054648f1f40a22b4a6f02b01a2ec8cadd0992c3b44a4f0877a006ef1efaeb44a1e30f5ba431575ad5d1d520e2027803318abf0ad1ae6c35d7c6b30963af2c5ccd06d172f6464c6213d9dd2ca38d2afbc64446202e108170ab42db1cc390066ce32d0ac4419e54abb85607b65a9f867c08d05a556919a67bde4c75a712c984a9d3d19826e338574821d6d4ec3fb526abe0ac7c1eb454f91a32195f822d1d52b25a24555545a501f205c064de1e0ae6836e7f742585d82cef9a60cd8266d39c34fd212a2e07bae95f420655f8830f634da1a254133597d8b60c935ae01750ac00c3f7cba075ee1d6c0403b398b8b085cabcd122fc9f2624a6b218e1d9aa82fbe2923c5026fcf3cba8fd1c91d35de7cdf0229ddcd212d8b205ca9a55796a71d7c9f0f538b36490aaad11d13a7f2d75113f70cb2b9b8934be486c5806b0d2fb234eb1fe6819f2ba8c8f2e06b2670e058280579f1be18d0a45dd151db0dc7c43ccb28be94534825d4ea897e3a3f5f5e343dd5e32997cc6b25068f6edc1180ceb34400dd9224abeec00cf25fa00f70e6c741d2bb1ab078e71fafeea1de2572e271ab2bc31c265b63ca4275a128d1ece8bccdd8e447c8527e450389ec7d6bd1d8c7a07b23c0024c9219b6e9467647c274bc1a86ffbd83bf62afe0696da9acc1fef7324ae4bed880c2a52823854f30d3eba20a6d3d58381aa7ba5a787c64f35361fc1d5f0cab3993e0405f474be7094bd0863048c1783874b00c3ef9d0301bb45bf5260180ce2d72172f17a11d1acb2cc0a829b4dccc24351745e8c6def8f7694005715304181362684c8712038da76eed9772aa26c94cf51326b23e1e60fa893847ddb9b8fa55baeb88eece03b204a8de40af3015e2954f9ff6ae73c44853f1197990137d83ee0e82bd8c23ed6440c52becb001b7bdaf152a14429a576e4a8770c80c0bb01702199b05d3fcee97e68be5a7b6a7aec86bd2486fe943733cee3ac2a0f41d57395ffd4e50626468a16ae4acaf6358da20c62f2a2e1f149580052a9cde03b947896e167fe6d5e3eca40dfff6cc328170c80262640376f25d55846f9c3b7474000d0a52f570469549281bf88a19209f6f4a6c57ad9592922369e7efd9bf067e89098e3c071c56c29b15e4101ab692593d8ce4f18e81df6e18836fe49ca00827277072e508269e57813e7daa5ec5f3cc8842e180a759e20c8ff6727a097d1b4e35eb51f551de67ee7fb4844689b3abdd3fca9e10f7fa2e6f858ea7823e66f0acf73e507216e3ddf26da0c9e0c9fc0e0417cef0d660e612b56ff119df062483317bbb70296a2e5df04084cedcf43df1cff6de44114bd90f4860cecd776f822f208fc23785982eb7def873e8798ec3e0bca3030e6b1b06cb8710df662b636be9f35807719cc7884cd525a0f2ab85e0b3c08fd3477b31969cac21b5788093cc1323b30ae17bf6a5af1731331fdc61441b3a6cfd5320633cad40ad9e04b10925b08895e7e6c69fee593049a91ba9f71a8cee2604efa4b431a2d5a7a7e5e3c1e6322d7bf747a4bcbe77c9da312f6bc0037ea40e50f39bd857648346c1231c91f4d28b6c398e38f213623e162a9c511feefa7d95979babdfb48061c42df5c2c0cd1bdfa322341c0e347cebcdce743bddbcfe415757374a9f06c251a6b923c0bfc539528a9fff2ff75e9f0665fbb5d379c1c75f8ef42be050437ba909d11367bb28ececdba16633e3548e7ef86e81bdb93f24618d6e94594b0605e8412e3c66b5e1763f68e27f5a4be8c87c85416432fc0b3472257f31e79b2bc43cbe2ca75d370893be1b89d745d8a03e3a35afa2f7543d7539011b8658d689a078b6a2d568e9c5aabb2b02220fe514f8a9227f018b2927b6fc4edb2fe6807483bdd1eb5b0092bd08e9feea211451f4b6653151b531bdbe1f58a9578df0f18a5ad8f5888183d25561bb4d467785766c5a523b6cf61ef3a018940d5c301858472fa687792a7431d94828943651a1002c06824509ca5f89098e4d523d0c618e11f3d56b48673b24a18f929bddb0d6bcc9993c62051c7a53b4436522e800ce4639bad80ef68126968e2e3298eea560278db51670fc2af0cf576e7cf0b087c1f91a3f86b08ad16902a8cebdc8c8bc6d32ed0ee2b277c6579bdb8cdf77989d249a35b4bb17abc4af5afbb795b7a67f92c923b1220467a16500a27ba7f565f842ea2d7ffe43e37d95a3be4a404368ccac8b06d313b5ac1178afafe4fdbe71bbce20358671a5f0ff8547cf310ceda72606ddfc2314eccb0620b1cfc6085ecbe8c5e641763c7e4f34baca4375f276010a20501a480be143faa778c49a93cab11d0c641871fdf2da5812ca9028edf480511c3e8990e4b93132ddb729a7a57b8f002d4f6b6827c0e0f892611c21dfa5eff5e4d7d287e8f20a88ccd2cbe7ef360820ea1dbdf8a250b60f5ed76b79d82490f143237cd46f43dfce29d262d12c9bd747919323abc8493004205bf190601b27c049a601d6f6acd59bb45ef8bdf3097539b3ef5d16189a7e6f4b297a1339c682d4919c47dc125d4cc40b241cd83256ad690a9a7d6172e5aee1d294f013dbaf753bf5b8363dcb28f0a2d25ec9d368898eae6173d5463174fee7661f8f74596035239d78da1602c4ca6ce5c1fa6d6d38919e45a4900cd7d84573b58039f6d0fe799b2db733006e14d94f917341664e844b31bca24440a94d5d051df733d6f847d61c101b2f3ee1c5a6f804dd28f8848ef0c4ff0530f96253564614ecffb3676603b49d446351b201a528c6d79fd7eb81e2ca321c2c63c8cc02bd8a2687bb87b1bdb7820cbeb21ebaeba36f02437706a7ea5dab16c3772ed934ca4e40acf1c919376854cde990653adb9e22585c4f899ad57be1972b62516dff6d79237dcedacf019f6175ec036ca3464e0769359fccae8ec64c999eb851470ab51dca5018e2cb3e86361bf1eef546b033d8a2994be09c0b0c553bca6d494cecbaee9a8afdb4e365073bcb6c3892e6911dc71770c8f8f42b0ab31b7fbe47621d7e0465206c6ecd6fb26707a4e4788c880679264e12b5600bbf01d7c96d5abc62d8503da1d2c08ce4170437fc5c0af862c88c6dbdbcc89e3041d3b197c55bb70024e6c174451689ee0375c7e20dd264e5a006feaa33f0a4cb7d3a5ee5f82d18a4f923bc510f0e91d1b5cb95067e3cbf9972c334448d59337e38164f939b90b718dc2f520b7f56d724ef1f9e999ca008c3b4755fa870c38da91614f9882a7abe550971ed2304f59924da6546abe7463021e5144ba647d3556a4a788b0dd4e95dec430f02b0444f6c6e2a3398500c31b5effd8b4406241a5eae3162056fbdeb60f12cd1534a422b3797d746cfed0c4097f6670ed5823ca6b7a1c279b1beac8e17ea023089644e4965e803925128f9c44b56766dd6d86dc0d89419b66c3517e7a13dc82820fa3c2600e28b67af6d57b25f0bba6f497966bb4c998f48bbd77be493ebda24a72e4f08d06aa05317fe9b3f2bf050da4c412b94c9cdb6f71e497f0eb50ad54ecb2a1f4cbb775443e291bca6fe6c2018d44e551285143a70b531b7106ca85a58a0aed780ac4eb76bb86e93c339a0bf45b51b64e756f0f13af6fec887d2bcd21efab5714b98049820afd606fd38e1e3839ef9662d7b64ad0c570120004d2b3e5ab14b6e72336a4717f8ebe124af53bbd1fb3bf3216fe8071c5a2c8a98f55c4bc0ffe209bdf4960f0cc820f7032c7e1d3750a41d6532ef1ff264ce260a584189957f0c19e5aa156f6721fab2eb05f7e3cf404cf77cb0d2cd50c55c279a153419753029615374d745c18144ac197572b979cba9f0fb7ee2a6d2f64cbc1c51d7374a5bb9fd77cd35a59f8c1a14abd899f996ec6e0523f3c54afbbebbe45c73034456b4cc9a9513356a2b29e375fc8a38abbe0732481d2bbcf1b16deb7b116221b8ecf06834a0f4804d718701923c0afe1fa784c2effaefd5f2d4da2501ed86b6b1bf04a59df9de4df97fc8d865b31285271425281231db28269a0e041825acc546fb9d21eaeded6f2d14c9db9aee9948ba4b45854a28bd709e3eda73d9f9e4a453473d87c1858c8689d5279353648ae21a545bae9b8db6550dc4258db47d489fbe4940de7efb23191fc3c79332f30983a671e248a12a88d6a0d4b9f70db2a91cc5ca1d3d9b26243c17c2ef0efb7cf02b7acf54e442b65aceb9c8c11c5897034faccd762ef52120ad3849692d9953f50034811e29d6eda00a48acef15dc4e2c8e4cb1d7477527d0aeafabd9d215e01dcc826eedbe59aeb6a15c62d20104d011e7f338eaa163894326c85c77584d2b24e070803cfcb535e2e88edc7cbf8682b001b0deef4df19f7756c82e8770937217f9449b6742a48d241e39eb7b37bc7cc1d3e654c182ecce40b60bbad868b2f9c2658f8445a57b5548412cb3b5c46b8408ec093828c1408fa0df62579c9c73c2f96317e9b1af328ef177e9b64ff500ebdd49d43c0bb503343856385de449faac6840b695c6051575d65f7643faf36c3a2430d7bc89de7a8d169a1e9f76473a46a27d47db7fe44874fb507c7b96a2a3340ea4a4d78de16c50ab547c61d68999a065570cb4d4d519f05a3f89902c841fec622b2e96228482541a2e66770aaa2049832712ce63ee68a6264fc832639b1abea02cfd050865afa9fb862b71923881cd53b276c66fe6d22d7e11e15fad6ac3e70ff165d49b839a813b2238927055e915e736810d3b9c38e0e292a87feba63384ccc7c761f8eacd3d079f7ffd6cd05c93e114542cdec17b5aa5ab331ed7622d7cf6dc27e086873796f0cce70de91224da537e202818711d38e72cfbf6288a8a3e96f96f905228e1b5f543d1400b10a6ad61d49f44415d9fd7a60e93bbc2e16553d109eb9a13c7f7c07b22251af912b5e77421789e35c738f52f4f99253e34bd9cecfa8b99696c57b14bf7524779a71ccde2962d37afba9b5a6cef234c40548e30592002acca02d4afa026e35aea1651e83e912691f7f66b757310b22d8e6534f0c110d91bbd9009304fcd48e1b82f022afc2ef88dfab2a2c2c14149373f6312ec295489a2e5999584418cecc8e4987f180b2e03189c17ca1c0627b7f46e3b00e00369add74ec4fbfcd111bdb27929549b5bdcf420d86048d8f58d6fc2d4914d33ec157f903173e8d1203622bd063210765bc4b36fe021358eeb49d834221f3a05d0d5162bb61403ecc394840fbf37a85b3e27c91ee7fe7d592ca990d681334487a2674ff97d3d1356125c3ce186bf0a22af591428d340941d6948076de00b667238bda989a04529f6be3594af2ef0e365c73df4abecdb81a92479b0a369c57d7f8d12e381f8c22fb532e3c2122c654d493bd6ca7316f3742e1092d9b8804aa2ab028a90472b49db69921ca63f9f375264af3dade0e804da0a22a4ea966447c83679c51836a35ae1fc06465154f09d9eb84ba8d0a89b3bd032ef3b4cec1b00b444ae67f764cde19cdd85c0d8eb00734306fc36148124a323b051bf7047927e7628f380a088def40a68f0714dcebeadf13ac48f0f01c76ab64c3707951703633eb7e82e6be0f75be24159481ac538ea725091c890d2b52a98ebd0817f359d957e77cb64de9c6ffa2c99f24f2cf51beddf0d3ed88504a6384a576c0996c239b9409aa7db5fea3897970f9d88d771d92a687c143d8f56137b7b0ba24b4b8d5f9fd40710d9875453f9d9c48be375128d50b60999342f5a4fd30b0c73c21e4fd7247d3e203617e02a75d4099b9793d03d4ce1c5b29d249372ed8ec0554f3abbd7091c134950c1ef905aa3b1ff9543d66653d145cf396aa71b766bc601def26da574cf891db8ec3a9a8868abe0ba46d21716bcd191551504155ba9616a93901f6cc6c602a38fb077200146f207421d5114c0ea3cdbe5abde5d6fcba6b0682a18bdb5dda794aec082b0aee023e5cefd990ab6e9e2154512fb6e764431a917e2a1245bdd94070bc8989d549dae0b0a669d467eb6be7019251f485ba58acc3d75571b9a7f3eddc06d59027bbe07edfce8e87cae088f02fb2552b28b38472ae190fef544e69549ef3d9b17d23b5a3a434e8f7cb41a816711b476856cb5fa7f12e392876c26853617f7364e8bae8ea78baecbdba9fbcfe4ae1f324a1df26aa915cf14dd6326c42cf158651c1e0aa577b7a962f70d7171f891633b7b386edc81929039a319150e0354ade5211e10c0d80390acaf5b2ea5675e905e66d5c1039d733f725ae82422f26b35427e4392c381d81f7665cade012128bda9d22c86991d2ef4a279e9a41aa15d2ef1ac397db396c7cd38187748a9a6020d9caacb79bda70a918e9420cfbd4a9ff6769ae56e2d26fe61a705722fef1c5db2e305fc5c3ba58daaaab0dd6884dc5c410bf10416bfba723941a945f8fa33dac940e8d489c72eb842ae72ef083de48506ef47c7fa1004c783e88da4fd11b9155cf370871c0fc11942b68ebf18a0bda19375e61f228a34c79dc98d36df2d9d72d3ee573cb2c4f2c5ec16adc4df30eafe356433cc3484d1000f834da1d0ae9841e7f72c46b832dbc94a0ccff2230eb282900c9e1193d527fd6b4fea1ebe8d7e89cba7a04c8a33d4c8db74750617c0f457bade4b94a739fd2b105ed39e5a58497d25ec981b861fede6bb67104ac358043171699eb9a20353860bd7100cb82ed4ce7e2a789a52ac279743aa1baef7e70da1826139ef130848bf988c39c6f8e74bfd18d9f77fd5ee6e9dffbd1692900c2a8d5bbe9179f424a4b9c258355365eed06c2754c749bdb3cabc3466785334077273bc28a1cca72ae99134c16a805b8f8e7730f8f18acfc1c3b3476ed2986c9ef9254039fe544864821aeefb633117968375dddcab80dcf958e17a2760a8dceb7b62825ab2a2dcb50fa444f14eeef21cb79e9c3b0837b30f672bf3e9893a1be23640b5068a8c22d4f1ddb56f933c736000ad7424e33dd714b16f888038386f87a539fddab802a9bde5d2d91cd4aee95014aaa4f7fb203b0fff6d0b68070f2b804637b76e8afc33857ef24490f9b5d66b96e7e4759f7957c61a86b086282740fa784e045a64d7e62e517b4ce9dc0941076bc7ab67c62ec09b028e24780360c8e76f3471d7686aefc79fc1421893751efe86f159ac6f192d9ea132ba9dc6b9ccf0deebaa35726abea0fe82eedbab7ab1a7b0a15106ebadc484acdce56c83c1c96af5fcc1f7101a0af84936a32399a58acdeed109ea626546c1b231632dc40fc3347ff98d424be02bafa0e0489292526d0d3929e1dc5c193e08ffd9113401e3e44966be319e3a04c98c572ce5ef3ff24e553f98a52e742aa4d84103b1bab620e652ca33e69d5bc93ae34566f9a122db7dd993d0b9d6d79b682909326fa7e844d611b29e8d9d1ac824552b32010411478a360b199fb1aaeeba29d19cf8e9285b0c55a57aa9283b6974cd07b1bcf5f026b516faecffd38000634b51bc48f402082bca52fc7fa79b5539279103dd160f7e7e9f3f5f51b783cb38936ebaa30f7ae6bd8e88fad987fe0b6ed4e8fd33ac050ac2f01128b220116f9cf9ea8f8d603a64752ef827582cdb0e5c20691e62aabba9259552352e009f0ab3ef722f3bef2c8c1362a787b5ce328d93fbd19c372905e77f1f40cdf0454114315e7e22a06f3e0501aca279e3bb260efc1a2be68159776a09764fc73d86ae2647c2f28d2610ce8aab5285ad5452a2dbd4c1cb3d05f4cbe489fe4dd828c7947f930b7a426330154a07f6b003d731df187b7087022a229c99f34322e671ee27396804c48ba6bac1106338e19a8e0070bd7276d2bfd386c3ef5ef9eda5d1983f098d4669e0b325c889edd3801122e06401f8a06c9572f46306c12c465494cc5a066eacbd06aca42695fa24b178e7da79d75dc02cc076b897888d66848f20f4bb51abfacf81dbe936f56d499995686772cc60d762ef3c9d2f978e44535e065a7ca9c8a04ce1f194df1fe4e2c53c9753f19aacedd903940e76df9050d9eb034cc4db24751e3c9e4164fb617bbc3c1a10b0fca71f0149e8bb9832af167bc223751dd89551c48294953b90509192857ecaa0e86ba09bbf3df066255b05275591de57374ff927a8bad52b33e89ac6bee10344d62efd4bb07eb124a6239d1a258e045202103e2b181c1c288287f1131c568a7bb8784d408dbc8378c759cc403ea2b88290d38f568b59ba781f01b2f7901516c02aa791c16aff2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
