<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f8ab51789f43f4af67e85dacc935c3ae6b83d0b1792246aee8f3be068607f714f9fbdf25345857dfb26f3fa47709bdc6b4ba5187891b4cc04ed6a256d3eafb470ec85863ebf44b757b9be712123d507e9807ffaca8513d65bced3886e39226bed2b1089356c9fa59a324ecf6fa5e150ea43be85798f09f32dd7d906ce0d545a87ea3c1068e3ac2ae5bb71c382cccbed5f45bcf13c3c54a3ff157cf6573c57e6ffb690f293f6f85ea067b864986198345f89eeaf833793bd3388954dba62b8dfc900e2b1595c04b4ca7d454db1cee87117130e1ebf86f17e6a0bd7252d53dbf9c46496822cbe07ac586e85c74240ab12ae916cf2404515be0684ce91755de9938fa526dacbbaf740b94027b5c5355013f3f0eb3423ccf3f187014f2765c0f2f276a8c775ed41064334ca578398883e20f86857ef51d4d300d752e6e23a9ff35d411d6f41c2b09472ee2ed86092b65af61fbc3d27f8dbb041c45c7279a3703a297e7f4f7cf14389c3467edd870da838aaf7939fb68fca4223e8b28a32dbc4ec6f751e3d79f3c712aef62d5fba5f89931fbd417a0d91f46c8f411fd570f851fb5f6c1de8e306ba087b0583d4947a84420d94fbcd71d571c04082252dc5d0c239702c68ec7e836c99a04767d749445b17584b8fd622c249f6e659e6103d96da5f2b56de28eed8f3411d664d25423911141b9550a36a16429c4a06c20ed5b6ba6efb0613b5e91b265af15acf9075088854297133ad4583c2eb5945cf5ea82f8880d0cee260c4bc288430c120cf248a1479097da3565c3d150a8ec17a4efc63137417ca74f01078f1085b227d2b99cb0cf105da8b9a42792db931ab97c9f22a5c56a5c10acac2582b1bfe4ae77f8a1268401a3f71a25af8b77b80f3ea9e162bf63502aac932194f34451997c43fb1f65e78b67f29b2e9e9180d5bf4ae4b0320d2ec618700b9cb10548d3620c8711b5c05ca3a2e28b09bbaf9a8882af70b5a8b89448a5fcdce83d1ece3e4a099be2a022e0e04e32cafd2d33bbd36fa3b920302bd124db9c53a1b08f696505ae970791c174e9761ed8790e6ff37ff41a23e3058438f9f664d75700f201488df3690f92b5c22d079fb93dbeb85ec274f7814618c5a87c4575f5d5f3da8ce10b49f916fc5d06a9c1db133c7224ab005e1a3cb2d0705904d6b62c3354a73570675a525307492a8e8a6a0d2095db318c247a398c3a3a89fe95603cf155046f7743adc99e5c302677181859798d994f593a9bf9f1358d977dd870d6464f8feef69ed893ed7259e7dea4f076cc928ed44373789c79068431a4e8c3b5f9249b176e88f8152c1a584a029165392bfdc6a573f7e68fd14eaa61c0cfb0238c0b0b2196772dbb491cb52eb4adfa8337735c074fdcd3c8d7c6d469fddba25be6012ff4dedf1090d08a66ffd51af7d656bf3f7a69f6be1ef4e3f490716eb2620bea1745fc4b1f70dfe020a9c7ee6912f983189a811e79b3296ec9b720b3a87a6c2b58f26e9217bf276051e7aeee7bb8455fde05e22ac1349a59aef7a59806de532fb466cf7119b8690738bbf3952aae6fedd5ffb6af0a105fa4d54c2b6817e2326fecf7cb0c1e2ce3a5b687ca52a82115492f1cd4fcff97029558700e554cc3d16b70b586c6c637d6c0ca813671d225d07e68f9c7a4f667e3205a44db4982dbc46b7f66150291fa36a0886156552faf581687e9a1933ca6b4809254e797dc38151c4dacd95bb73470b021ae77c2a6ad8fcace9bb1f004401a14ac898101fec5ac242cfaf3c1353074a6771e88ce8fa84fe247059761718ab10409c7fbc72ade26d51378b6ac5ff9c8f0f51abe166570ff241741f1131abda94388df73f07a667ec6dbbd52e371254ced838bbfc6d29c6ccedd9eb8cc2ba61e4922f387c0d0a0f96e10a81d1484bb48ce9d562af5d0fe7ad0122e7ee26ef446dc8c53a1d507d550f629d6f953fd8e07e27519857685d98eb4f8ed1292e378f7e99551ac6f6d7351b72cd3afb642f759ae486f01b34efdccc0ceebae0419e811e3cec38a39b1b6f3e4358303cdf9c3d48a63af81642a2be87b5466666f514fc20dcda22c5ad3b39b2060302c5c9ce8020f49c98ff32bc56405fb269b9ece65d0f303b81221252b3da95a8432f1d5a134628a023efc519add94336a655237b4b0559d6512a3a6b54e16e229d06e2c839db0ce8833464f6cc02520e8403911d3258ebb79e97a15d371aca3d776e62c3636e61c9a9a0321fed4ed5a2960d8f593e52c5c14f30070aa63f447e1be45fa31ba1c3df12705d0d1b682ff9a9636bd5f720ee5c03020fee6b50e3c6f6a05349c97a75ec5b28241dc01f7e395be89591cdbbf81a843bb3c66870b1609fb1a76919f2c17454c4d3bc6f441ba68259cf7b656e9d31a179ad591453c634bb08a08778acef025ee6529fd6853d64723d69997d1b86f544d07d29083dcf254a2de9b662132c7427a6b3392631391fcead5634c03cf7b5645455fd78f2af0403da2ff1698a4ac153e98aef8f334a4b6052fc40147faa4f976f0cd19214de40d0f5d8d8378cd629b78e9c7cd7daa09e1b56e9e49a6145f533329b295a1e31e560b49f8f98877b98df935df49853f53b7ff7a631c5a9588bc906747b432e6622ff16334d7b9493a45f02f38196233017368d75a62b066a35a48fbbcbad8aabfa45f82aa5840449c79942274712bd79c10e51e1ca28a1cdaf46265aae28ad1422d0e4fa588f1495216f3579a5f3d99501dbf708dd89589f360d4c212ad718327ca2e04a8136a4afb5918bcebebaffc1ed20fc62cf66d0779e2d9557d8cf8c436254035661f0b36a5e8cade7044106736a4cf1ffa956db751f4b90e5a7b9ce9a2fa63f53c95420e73c62739a63182decbcc2e841bda0d377e4d4176fac6599d55b41560015c2b2ff9d7d9c4840a7fb0989ffb4e26f55baa1c28cc721b3e2f27e69590e0ce571e72b7a6bb028d4b0a51477482b83ccdd9e894fa1072d87a2a51fe7bfd35101ea3ed8fe1edcc1a6533c2ad85a57f655801aa0ccafa260c0c76ba9eab076b35953abca4f39be369a35ef060c10d091b61345ab8961e655f64dfb4ccb72cfe7c65160db78513a80553a45c8a64b49efeeaa50ab3a8085b4ce7ac21321f475b65db125b10458de68f7bb85f421e8e80f66499f3c31d37cea4e6d4a97e882b3a3f51819ddf0dea18a76a14fe53a2c41056dcea2906ab9258c747995641008572906e9e2907b5c587020655d8bce090e8df1b9cfd649d18c87c99af7b62d62851749d2373b69f746a9f3db042f46f988e1a599a7d2471f322874961e2c04f9e04df2bf42d9bd25551599a90cc026b3e10f570f31d612f8967ff23d7908b928b0958bf4bb531f476bdfd0ad1903bd939c3ff9dc118c9537fd8588b5bd0952e20c79a9a7f7dfed267e3defb6ca14cbb90a8a5fd5a511d206e8d6324c806852ae9dcdac376ecaaa013991c12bfaaecd32a754f59e4a828875695769c7aca76ca342a2700822d172ced89d805ef32fe384cacd443b96cd429dcc76e60246df3c91e0329871fb7fb48e80cc730e9e5d76b515a05cabd54b8a84b090c26aa944ee1857a18fa09fd2631078d78a090b0fc063ee508226a832a84859d77d34321479bb0bb21a729d8aff2c6cd3bbc91f278dcf9357eb76c7cc834c7eef6744d8be7b09e2ab0811f7938ba95d60dad6ff260a35dba5f1d5ba1653f1bb0088cf07ede56cb8661256595e338e55b3693d342830970f4119c68bbc285f8b8aeacf3a08bfa4426a02a7b37ff8fdb6e01db876696baa4200a39ebc73f60f5a00d2e039df4af9ac7d8da56f64730c3300382dcd1ff17777cb87cd4ba758ed2b3f50df02fa3d0f1c41f2f58d7e3f205eb36e08db9bc50dbb28e585ec4e58efaa07246a25581b3ec7bc7e930f055684344ee843845e9e1e5a83d47980ca4b26c79e686d606bb62b2e864bd0506dd2eedbb59415716ccdedc8879215e44a4fbdb775433c04d6121457f400831b5be04446ead411ab33ac8331afb5cc205130701d4b949ad8b38b0406e0a08a7b283207253ae18b2e1c0713203c6e2e470906819129b879c9dda608eb55518a21c194124c558e8d5022f0aa239cbf5679f0ed8cd020267b2826c9f912401a0108cf61131f4f2e7565c5b54c0e9fd8a18308fc517fb3153f0713f4f4160cc2fda022f3457deeb373565702b116bcb125611a99c0cfc5902298177c6a866b8276290e9498b1a8d72c0230934c1563baa593bd4129d6be1b44049cd79be4cdd8a4670a09d08c06ef1508c808a33cb8139e8fd7857d86457dfe4dc86123e187ceba9ce48c25e3130a673983c5f957478b71303f9c4862462e84fdce4b0b5c3852703e391e02a3c22e2320138e8310bf95964ea3d304e229dc78aa3e2e730df4d451aed4c8c2229388cdad20b843c287a2217b9f3d1e1e894ada27237e91718f41433f2ceac666bf5aa44d6052f441a3deb5a5bddadd404c36a91efb00c3ee62b3b0077754a64590a021ea6994a91bd528cc765f521281c17f1a083cf7ce8819e5c73d01c4e9b80c2d035f04393db155f9353ac579148fdb814f83fffec19954f10aac7bc78700cc6d8c033862b4e190323aa9821b5d5e034850722fed37db2d8ef83199a83a1baebc20e105e40f23e56865df141dd15ffa8e1a5a216f1a6a746a192463e8c93b3a5ba0f4e74ed4c8885e92742679dfee80e03317f90e1fbb77bb3902016363ae2697d111689d60a2a20422f915e6bd43be2f8beff6a5e99ae5eb2375971f8af53eec7ddcf33abdeaed9c1da4ee399e8c8d707b4283b9548580ded69c9bd27037e53f0848e9d67e6d96750a26db4a497da9fbbdf0b18e3bd82a16931766d30e81ec52eb7807a9a0e21ab01bbed05cc267631a489ea58ebeab4bc674339e43bd5cc6451ae3081bc8875125566bc1f76ee0bfa12a73e3ba97cfee64235dda2abb575faf2a2fc5387040c23510ed2a571023dfddc83881ab438a0cd9aa0b2fdafc99e493750825c44430717e32c9b63b3bc02ccb7d9ffef5e62654e071cac4e4e28b4d9a636905d3e68a16c9672d77ebc385cf409d5a6fcb5fc67557c153ad9574c94b6362976e7379849049265331c80cc9c8c869451ee81fb72934f8066b99ccaff080f3adf496eacf160c89f0147b4a276e7b3aec4012d4246bf9fb7a6d2d1103678121882f04219d916fa4c913dc56ec1b20e94b25880bac1efd6ff9f07541070ed3a03c6adc83830e9f27cacbf25d4e380cb39e5b9ade24139893baf846754ae90d9726b16a4d201b063d2b3290f35a12fd92b358a46a7cc060c4a30cad5ffb6b7d3af3be35b9db70ff354de28525934cf1b641aa5b3fa010684dcd7ce39bce1edf5c739072f963c17ad9defeaa31b487f7fc68e37e4baa7abace99e69e68487b31362faa03033d4253f5ec6edddbf5a58b16f1e4d29fee82fc2ba9ef99a0caa265a2bc2b8cd54f9c5bb5ffa77109df3fc1b9a89a4f4a4bff824cbb31f0ffbf6145e525697cbc3d941deef5b465f8989da70106cbb735855bbb98a77979af8c091c725c32e7d774b163eb61a27b01d2227e9f3634f35ac497fd9eef0985412fed9d0534b9ace15253e882eb733f3419b39fe1071149666add95c961bfa7e4a58a42f3744c6c004827448de9738fb1cf8b5f636eabb0909da2f227df29a7f3cdaf2f9b999a6d542e583a8ab5673f1f63135bd4032917d571291a9bbcdd7e88a67d6dda75f6837548ced34859f6ef174349c62f2d838ddc2b436dd6ba8d914757f7693b9ee2ecc699a9fef7eb3c92bd067025e1e9320b366c242e70492b19adf22830632541ea7781d9938619b45f27293da3d48ddd91533b1aa5480e4a28ba70bad47a2ea319712b86e18c83c81c1b79848e8048096b7f49855f80f3914b67355489a67826c3d2c2d659858a2be4d619a17921f4f0f4642ab03b8af3dcb20724a7e69fc4b7a89456b4b6d9a434a1d34f15bb8978464797abf0074f1c0e8edd2a80b0de9f89b90fb76f8e0826dc002df39f2e8f168e8ebab6bd16ea6050c67722344c016757a070bfdf9aee8761b3d657c64e6417d6d5dd6e1616c5a3776db5b52ddd018664fc51ac38a9b5ed93f03c8c03f55c8e955f29387f91c5e0b64af5bb37cce4ebf456bee7dda96a489073e323bbbfb6a8877a075c4493f3f16de3a22e13b9fa9ff0b6c0abb6d3ca7c6410103d45a002077463f01c87c0ad2f3a0a7f62358c1740b40e39ddea2ea87c3e384f781161da2cfb90332fa7cc9bf325f047e2fd40e45d64a6502b02ff23e8fddacdbcf52dab65cb930cee7066bdf9a5375dcfd96cfc6189f080faef86eec4460c4abeb23e5ff38c58fc02732ce5dbd6c9980cc6097684f10aecf6cca2ddb64379845c7700a842c00b7e5b2df61bce811b36303797a60672b72a62a6ec6dc1efcdceca17c147ebedf5b2ed750ffb8eae22dcb0208d8e3b2e3790f456a014c1279fb4bbfbbb8e097337892159f3abbfea47e461fb54175c34cd935d8b7add9c3161b12bd6f77ca7c9566b307d5017b7e0cdaa25dfc7d479710fe4ce3f30444612f5f70b194931afe8fc9b557c89c877be755ed89691265c623be13eeba429cab5da72ccc48a64febaa0e00af0bfc2a4f4fe873ff29a0ec3f5cd6684ca1f266d21eb5202be527c88b60e655d81128b729421ec2f5887492fe86765504f594502bee4bf47a3339590b2fe1349efc95a8c3967d8f6749910e745e3e726cef415db7c749c686947c3e78404388e42fe24b9212d23b91bc5b0166b9baf65330223c14bfc34aeed910dc6693372d4b830c6ca6cec9184044038b2f077ae266af1869be0fe2814ab136a32ff803b7bd3256aa0717648ccab89902369abf0a00e323123c87ce163339f1dd1afbe856c6cb83e273ffb431be1deed3db005291318123d878e734bead79c1cc62ee86c3a6b081a700ac60959ceba90bd1a905b349b32b7ad687a0e8ce149d58618c7731398420c097729c851e8ebdcac92a70a5459954bba0111b7901977dee5574eb75d44dfc9e5e713b7c166afde706c2d88cfb0dab8acb195186b3c483ae9067ebae4fcf3bccfcff5f9fde02170e55ff54cc4ef706af83de96ab1c9dfb90404033e9aa3cad2fb8f47c800c798946015d6cb3702e26923f7a7826af0650cf38146dbd9ed97bbad36223a77432bda326a209fbb7e18dad7f6e796ff5a784ff983b8fb1a1eed479710c8ff88c53381b236d7b1f95c6f3cb76ffbc7632f9bdf194957d9aeddc8a2e66d5350b79797e55bbbdda7204fe6066b09eb857495bd46111b1f98fa23655e364b4f12d30b1ec170ef0ce71464dff99aad343fa9a52a88e9ffeade39b711e0a7ffceb3cd20886c6126c09a3ae4cd3968fd3bfe04393835054900244ec5f7f2c3fddae9d7565ed6cc029beb5cb5d28200b8c6c1fc8fe457873d2702e305fe9c26303e04821a1fc70f460bf9fb60c9d4d4dfcc4919b4fa83b83943abccdccf741e1281e7cd80eeebb44fbfdb6864182d846b4b3662a052f7253480f482fb736325eb567945a082c71fcc22fe0ee67974703e36679a6851ca5a42c876468d91753f89ab430713c7c846b3265de626349ae930aecaefb9254f343aad05206b72480a93f68475ea793c1545819351dcb1d3cd573c98ce00c08944e772bcd037e0d6407530165064a78866533f9b682ec42b66d0d919d7b37fd08eaa357e6d002192dc8aeeb4029c775bbe83628282c4fa6205c939e33c87e4d194610c6045b77dd7934cfc9f0615b56375071c5f265d539fa0386709f294c43e2718037ae28091053884d2b64dd990aae89531add82f91d2910e4b7abd6684e6f2f16cfd6373013143a51963609c1276e32f44b014fd334cfe98046ff06419e68b93925c3872020634a5682baa1ece993d4f7dc1f4eed3be27f9fb23d28cbc998cbdb052ce89dddcc77da4ae25555613de8fa0b8f657d3641cf37cec8adcc26b26e22836b07894a8be85bb459dbc9ea73d41e75b3d60d187170f634d59c4140933d02080df022cbd8addbc85681da4b50d6e01ef20ed48c40dcd488df386868e9e24dcf83fc0d73d922a41e325d6161e1ef14aee70c666e5d173424fa619dce08084a70093a4ab0557e249e85d70b45a6ced14b1434a0fd37cdd01804b4133a1d5bc663ac2a4479558ae147fe808d8b4a3d0787bbd65b1c2dd6aa8f894871ca66f1fb0eb87ddb343a94676c66cd16cf26c4eb13e7231d669bfbd4ca8f3dbee156322c2a590fb9118350d46c9bbbef42f95fab75d6bea62d34a0893e208a72a718bb767a7e176bed7f77eac1115ba85c7cd304aa46ca1916b80baf594811b1636e05eaac705e79a360407b4a5427c7088c1d0424e0422c3483fa0ac29ad6a55f6a5626b0fa79ac7499501aa0836b4a120f30432203200404991dd403db265ff4762a346e967a6d42bd55c09d4e7e1bd1d2e85168ac2e45069e3aefcdbcdb885db66c27773cb404aaa7bac54fafa167e9bfe14ff5c8390049b8d720fd07e74a65440b61b2299c5c2bd01123c751e9be2b7625b8cea6a5d88934671cb641bdb8c95f92b3f88a3a7c891eb20c0af49d0bd600b41f6f68c6942391b38a917cb1b52df842141cf6d0c5966d78d12047230a7aad6eb4c2345e27c922f5b686d28f8e027f4ebeb52fbe3334172bc641f53d01a39409eba2a12955540b20a5869c2022d36ab5675c9f696350b77159bf9d3d8f35088052a6fbccea5a2eac050c03942f8dbdfc8e811fb58c772b61083c9b54223984259ccbc4a7cffda29e0468a2126f35b46b18ccb3b511609cec9f28e547fe037d6f9b9d21487d5b7a71e138247013ef2669025d8578be3ac34648ceb50ead356b8f3a49351acf72fb2a4ce688a7a442dbdd736fba2f8fedb21151cff9bf9d8c993b1228427c89cd149b3edafafb28e4d3b2c1dd33d913d3de15d0ecd102cc060aa1dbd0e66aec8547c9ddca3152563cd34cdcd04e45b5082ff7fc57a29ef8a7b3ef83729fcb9e6135711eafea6a0f4c833a21a12c0362cc6edb2a4671643dc34e349f76914e70902579c82468437d739ace99b0035468702c6323bdeb75487bae2a129bb9bd958223ae25bca9f58e2f13e2dbeec68b65760e1628ad46b747c99a9bcd44a4ecf15c28419b96619c07c1110fee0c1746b7a5c2c0c62a9142ebd4791e8be85a1d5337aa9623cef3d378a9b2cedc9a0cb99f9ff62a3737de1592b4266b0db1cf6d7c418fc70177a4fc8010779a63565cfb747b98844830539629abca306e2f322ca933f9903e0598a9b5b62e9bd6ba621c8d6ac438ed0217bb15aef0178e3ae9ed81b088bb6fb50d2c8ebecc8af9c119b605a25c796f493495ae716ca94b849b1f0fb17d38b430667904452c2f9ca6131b771a2ef93e12a2505316d4cb0a5d7042265c03cde939c0da087cc088761568c9a1208468ef1820ce9c1b9816b43d8906c0e10e08101af51111e6017e663e83410bb3576d51a53d230d6849b4e0790ea15acbd8ad87af3cded1e066681623beaf57ba9add5d7df9460c31d4489ac933e61e898063a75ff7019abd3959cda52a6ef1f6df2e702a91d6d3ccf025df19ffa15372b83f4ad7edd21d51ae8b2c31bfeaff15b9d91db662824fb279311e5323388584c8607cb4b071eeeed922bcd38fc297db16c968e6263823f86b561102af2edac3272d80debf0f0ed9b2f88c8d3ad533b12c5f59619932d056e5bcb4371befcfbc4c9c12001fd09751b1e2a02d420f932d5fbed4c9d03a05760405f4336e27245980c08b324d7a7a2b97ff4db55b757b8788dd3868bb7c6f1f36f52d7ba89d9b3517a8ef2d6f9c08df285b65aa8d50248e0b1171d68c766a17d7bc80cfee616fc2fa02cd7cbeb21b5d282abc462ef59e88285ffc8505bfe6c565a6f1631656c4a27f468b10262ad404e6c14e9bf719b4900f62c66968d80543c49a8e411424ac778ad00f825630413ce7b6d3849177cc022b0cb3b25fae5f4c5ba3965929d9d51a64b454798031661234cc0622fba69b8e97c593fc1651f0a213a7702697024f872a6c63b6b5d9b8330e69f121ab55ff5d7144a6ed744289ad4a43dec447b5a1a490b0a87b23b2e5673c7cdaa9d2b9497b84636b6ac9846bea0ea288b9745a9a4f1c331631fb7f6052f1681cd87ea1c57c9f2b7131e7fb4f84b93eeadcd2e04c79a568ea25fcf09a97963e5e0542a2da50c285c685cb8bc5d081bc42db3edacedd75abc520d4b25c944c0bb282b33978c99f18c6291d3c01c09ac1be00a904974cf3e5c64b406860c39b9c9d704b5082acd20f321fbd76fbb5a6ed4807d0dfbdd90efdab391163e057c7bfbeb2d8e538c13aa3ac56e03ae38d546b6e831e9d5a6c78aee5478aa30d274fa15554212c08e487f2c8752dad1dabcaa5218c852e3d03f312733f76b4e852e683304ec051c5befde5c172363d6ed04a523bb406268fea72f5b0e03b173d7aa8a8bba2c756047a1979f62cd792f46304d1e3c3eb97e28693f410b604cb3e458cebaa8f095d8e16dbb57c0ce48c6a008052b554f54507e4ec1740c7619ca09da00fcf81761862de8631cac7dcd5ea7126e58c1396436b01d2c397e40ddb2d450edde78588645b3f416b1b6e22111574b2f7c820f61b58fcd19b1d9774ac3a593241daa04b2d3b6903c1974451c38acbc662822cffc1f60c7d3b6772632fcecf10c6c37c105cf6e86bcc8c18c3c3ef41c2d4efaa5afca9fd44cc0226a04ba9c0dee0f682d8469162e6deb5b369911b4c59c9cd4aff27903e169aedcadb8fe3651986b1d00729bbb2cdf3d0c4794173a40ff5002dec229b4e52788fefb4d87efc1c2339e732970b3bda78c6460415e63adcfcdefc7de9a6503d42f73ca09ccf1c2bb1459c00ab34917f691cc6e2fc8f12399469e66a877323f0c1b21ed9df7659f9106862cc553b982223f41cbdba17f65ca5b286e3768f5f556c81bc53bbbe34e022b46e5d1aef956d04af1170d34ad2c14e2a0efbbe69f7acc430e8f0174f0809bc53ed001be66c1f94fd97cc6e5157c2fc8b0065df8fce8e6a7948d9d2fc12ada5c794ec8fa984a167e2c9e89d0e31da66c5d9dddef1da0e75b9cc624444ede2f7ab73150edb9457e400da6743a1d359f1b392ef5192bdd1e13981e8f10ad33fdfdc3f00a2989dab78e3c5e0fa9a4f85c69607ae909335e73dd3277d2757daa291380e9fc47decbc06d3858bca8072d11f943fe3ccc222a09a29c31a52319c9a1f367e53c4f8489f93a6cf95d3a957ceac8630df6c3890ae1ccc71380969e8c0d6343cf4369b4eb5c8fabf1de07fb9544fc8edb7418d101463e3f11e197f3c79d03a17c6fec18b783bc9da5eb1708af11e4e3c5acd0cb3f2c1b2108de470d65b5cf3f32a733ee727dd52ce17e1fd69d0eaba527eb9c87a96231253aefd094163f272539a33768b6eee059edceae6d5593c6a609ccfb960bc4a04fe4d8cfeb8341234346aeeb6810002e627fd7cd16c9a10362623527fe14859bb94db25cfebf1bbccf6e9c45826e305a0e73cf9995d8b1df5f0bbb6b4babccedc505ecfa510140cf2b88f18a8e8547e3c0fc2fc7ab5a543e47c56af4b599b8542e7c1286010797eb5bc827fa2c7420c0ed5adc9e6e2f7c7e1525ad3b04654f9dd0391b15d600dc907fd99006eb661a527bb9423a3e90133c08ea666e978955cd017a3a86b3c51376add75aa8f596ff67d6f999c61e1ef768e56f9ad47d03e1e38e698eaa2ad4eacb3a429878efdf64da77c91c300a00956e8fa9582f50fdecd6f15dfa3bdbc7d0dceaa77274e209bdf4e21d5e27113a0a2b103717dffde76638fcd9e359fcb11d14cb0019d55ebbb373a083717514743c9df2cba08edfa21b24e7e6eb40ec734f9313f5ea8fd3534e7f3bcba1427eeb764dfeeb25dd913070b1cb419a676aa39f178226109126c95196b0bbcf3238f34a2f600f3776216927eef65737487323281986e5273fcc1325b3ed2afa1520a6925d8d416cd5b52222198abed68305668a50a24d911a7d007baec24a07dd9341c3f8b1243ef875238b880b8caeb609f543552d3567d4b4e071426b0a130c09cb73f28cb3a71b414ea2c885a5f9e5c8ed973e095c00cd3f5d6e2618639890d64f70b670c11a1c45493c98a6f318943e33278e711efd4bc51382fd5408cacfb3ab0006441398708a7ca78c6400685c7d080918bb539d8f974696b1fd98c224242ddac7e0d576e6bdf7395d655a595d80fcc236e117ab78abb594359bb363eeaae8746fa8d55cda915ab8aed332a94bc0a22bd13e5b7311caa7e2860d3bb43cad775f7e4837a3aae91011a3123f07dfb97d3a8ec3bb5104d5319b74d7717a0a1429d3095c51cdf0015c2b15e771dafd36573bfb1d63585d1cf69776ebd00ac55a1971816b158119e6270c5d75656f18faafdeb4fd9b397d8fb5a443afa011bcd23a9f19057887eba736dd26d975db115a4dcd44fdeed9c0314ec8b9825dc31f0bfec689e6a5b002ce9d2e48d1446cd1243bf7827b7fea23a57446d10354cdb32bbf7516f02080b27136783ffa4f3ba782341ac5ef344401a895c379f6d8e550ecc3ebc2e0b8377583e78dd26017fb97c275048aa0a04b569e3c6ae767aa70d8ef1cf46f0204150174002c8e2b75f2844948f6de94247042859db1e20784ca994b640eab69be1fea22ddd88abd7bebcadb4f05e6b9ae5aac5bb551de8487d64d36f0b66093b6e69ca55aca5d650da22309d0795de6fbf88e6d84ca5e79a1ce978bbc531dadd62d0d179305f2ebdf1e25d99b02758903e893f4f7924b64510447a3e9ec5d5dcf615a646349fcf91f0e66ef33f5434b1db7f9ca9cf51f32b47f7e3746e3cc9d1dbe555d31e77ab4aa04e19f325bb00de31c9beb29664d0c0c00ef693bf89c05eddcf65c2502a7dfa97d88e1b3905949089839ce7ee37f1ae790e69bbdd24144e3fc02742c77491f164c9a5676bb9fd14e8b72cb678943f0ee66ab8d94db763f32de3546dc07a0f26a7e8e41c01d75266ba98c3ba0e54e53fe27fd1feaacb3187e8b5d7e00daded123cd70cc47c30f7e92c5f0e61cb742defe2cc0f39daa6090630ac7832b18c5de95eb6dd2ade31fdb7c8e307a9ca9cbac13a7cab9e45eb4b030defdad5f5d66a50e12ed4fba4f636a73d358d8ecf17c024fa3c82014ed48637f173c659665b87077838710ce4b5f306e149499aa5a387133e16301ef131686275b2a1e8393d29d76e90fd6bf82ca4a36d6f5606cc2afcd4d540aa73a87259e8a4f39b43a4918d5d9a8c9c91ddb482ef18573ac85dbee8dbe64bef290f0fec67efbd28bbbb4ac15e1aa8131e2df79f1979ecf4ee6c81c11f96f59a2072f83ecb0a3a3ad5ed066c0201ada0698b5d2bac521471ac2b110b1de9ceade4c16e5aef9d882d6bedc3e99f143f780abc87f0574c183df17dd4ce12b51e7808074612410c254b322978d4a70ae383e463f2120e2a0b0c27b0f4541f5328194d01f9385284d9bc72cc4144fa34b67dbd1d0e3a7275444e15d8d0c07c1b6034983a71b5c9646ce597161a63328d8e1f507ff6c11ad0b2b8993dbbf691ec54c1dcf771d549f9bfedbdc1f5b7fb6734271c8a4256cf0bffeb512bfb5a6daa5ba39eb338c9e6f0728d4286bd3f5e4bb9a6f80fcdcb6283c1570f98b4cf346e57f1d218d4db0a67c0e8827f5996a563c19b89e6588890b285b018f59fe51c8db19c78ed9e26852094a7eaac3f1975a423122f6879a7ddf204f0662b70b493bd1c27f1ad4ce19cbe7da15e610e4d8a9e7e90fd1ae6c549beb75e2e434e64e03f40d35536cbe12020a9ba1e0bf6d7c2785d0006bf183601c5be33c93353bfa70b656ad798579714b538aeea5b8547b32e8cd5a5c415cda4ddfaac70b472857e96fca5b09e677c8ba2b4f245a64fbab9a2a4cc7ec5a4c761cc3427758a7409e64d590752dae5753bf3d10150c8cfe2213506d0413844ef836ae744860165ffe4cb9d477a0df33d7b191510e4f99f28e08933b685aec943e382c3dca84bb4470004ae04e554dd05be98621d08bf7a0583bb94c7b9491d7c205628ce8b0527dd1c10e74bfa7c666b8aa5b54e17574f4bac54e3c4f496cb7f7fbb08cea9d1e5d7ac1536eab2e2a87ceb44d4b1ed64bc603a3c67aae6e4535551249f8680ae2f91d5b40cbd0b7720af434d8e6fe55cea05ed8b6a153f80fed9ac1af5056dd63cfe052c1d67e8f0a6e2ff0e1eefbb8fc98222cf37bdbd1f5194efdc4b2f8fbd65f15c5efe8da092c59bf3cb780fe82f8dfe4c5252fefabbeb668a33c0c3300ad1cada7e1bbe5d3db1e9125fe8eabc7e3c4850fb5f6ae9fa99bac2a30b606e7deff1be24e7199aa6bebf87ef62fdf256ccc62a3100b1124c77711070696d53414a2b3508d7a09390387bb5ef3171c11a564bb0c729259383749541ec66e641af1fed65d8ce03c79fd3bfb23f7d76185b850883e7d3fe50a3048570c1108cfb0527d0ba27a8d47efa8c9f5d95fb9ec64fdbb35044e49d4250dde157cbd8af1034a403688f4b0abb48ef48c91782bf59bd9487cfd323b3d880d1b240bf7f523e353a655db1f628758ae5d0589d9e66e219cc80f0460350893671b645af3f6c9a9e4588282db144e1713d50b0445aecfad84cde45f5f04d144f03ca8cbfcc1d0806434de5fc92cd6b236313c2f18a47aac882123e4b99e034d341027f5841c67ea62c121eec5e028893749be6d487018c3d3aa1913fa4841fc4e8d53daa47d79516010f404f20efd09990726119f0bef2e1c88df959ce50df6fbe33eb1599816be2b8b69427f78602182f91718e1ff26753cbe114456677537da3c9c7310bffef9301440b94d36335e5cd6242d46f94d9fead22570359b6f0d1299e1ba633a29fab50c311f070f865fc1f5dbb7caad5bbdcb9858170101ca3af5b180386f901e083b3bf33b8bba20397eea2a63f9208a65bbc061600423989e9d12354aa1fa6b470bc8ef6d057248a53848234191951edd68b2d37ed3fca2ff0410a05efdc800e002f1a9fcdd7588efe5093cf233c1321cb8350862cdc5d5f20e6b9e85cae69d94ba6cb7d17e0bf843a26c530c303ba85c4e20aaf61c1bce4660ca1253ca6a6c9b6be75597aba903a6fbf55232c18bc74c024dfba716a418d45d267bd73125ba0128f03abbb6450626ddc32f965730d151f2c8873ca0b2a166f6b2d712ff8abe482ba54e4f1e847bf058ab34e4848d19e6daf116b9acfc73b07761563e1bd1808630f813336e92c8af80d381d1685183205c972bf70d2ead1a90752507c493d41201cdf7b8c4a50266137ca9e06e403af9abdb0c9d0a30338f7246a9504346befdad1c13555ac6d8b2529fa61f871469be78e8600af2e90b9793e03a78aae32692e7fa6d3c0a1d267ebd980379049214814c9dda3f241c7b98e92db4dc4077ada8fbfce97e6cc21ca28afb296f2d61e33f5e08713a30fed2ca739ecb4e9c0f5a74f2ccaeba538d940d2b1d7d6092b80a753158cedf29fac016b8edf731e4cabb2b5b6ac29d627b07bfd385c168d84b05af071d6b616b040f29e125f832246a1b3d81656582531f8e132cbd5e63e300da47d3a7ae81b1664324f4ff52f08ccc2ee830e808f5dba9bb9d2409480af28fbc73f676b8fd72a1652623ca7a6f04c0f162608a43a6b44567b6e5bbdd8c4a1e97b884e1900117f806ecb9cec0f07da8cc30ba9aac4f4d0f26d0209cb5bc22b20553733624fb5127be07628a75bc0427083f34d4c77b650026bebb395a5658a4ca60f58223ecf7c89a29ce6ff912a68ef47209bf49ada552ff8811fda9ca44d89d651c07e2f9cf3c9e7567f522c28fbebfd6907d39c09f45038e0e98998ee595256c086105378578e5013ba7f31824cf03210963dfe49f133e4971390a4020f0bf99922ed48b7360758ff20f539769d0e25d1dd54b4e32d0b940a2ce10af6f71891bed43b41ffd6c36deb116bf22657636b30ca2ef13aab699f6f3c949125e12ab981fb99b5c0cc066c5d57d59c777d562b486c358e01004855a431d29d9daff9d2d475c9a599e88de6bdf549dd62f2341343d485fc1264d8a3150a2174203d080113aa2fe56ca7ba125039de25bb6783c468624a3b35dc74b59b9b659b75303a17165a185d524e23447cae8ba0c228bc0145c87922a9e80c2245fa4b02a419276560ac89ff0283e585952c1996d70b815cfe48133bd60580624077c8215680aec19e29a9187d02eb8277ff68103a587212e9f5573b7f33ece9ec591d7576f8601f0af6c90e547542f90dd8add3ce41ff40f99bab50a5c4c42a12bd99d60c3c74924eb55b9869125e328dc1401d5a769064fe75ea26c3626a952fc5b93f6792f58b69af44c45592982686ba53e4865d08cbc0675f933a4257ed334ba505f7c903e70658107fd6cbb0b82591c6884a47da1ad156cf912516823193646ff41620e0d753563f35956042ea8b0c3a6bc1b6dce74991b05b3faeefc1078ecedbd8858491fda4f627e13dfad9cf441e39cc32a2592cb12c55426198b9e959ac73132981e1027780c34643217f3cc7fadc3385fd7a5de28651e8124b5fc711a716ba15f7f2ca9c2fbba61ca512a5a562213ea6271ba50e070e3efe560b958c8f478579b3681a21e006e93c2cee9fd07a057979c39476659353197e1fced1aaed98e6a24141198ea3ac579acbb4e35ea418ea915c6470322218c6a500dec48f9260ec3b7614c4ed41bb79bd5fe42928028893de328f64ccf934af750abd3d0edd2433aa8445e981a05dcff8c46d9176292bd2acb2a870b562c3bae2e5961535849bddf24c011bc90fae9199098d8b9f7d55b3e8edc558bb1e9ed0eafa475b34c1839da1d24f230fb396f8a225c465903168349dbf141d85cfbbaeba19345ba35f52c9fd5e9b1f6faf552facf431c6bf544ff153e4439bd9324b3f2bda4ecabbdb5bd35f5260777ab15253d2b3b02ddc090e33e492ddadbc4cdb2498619a29dee697e26a86c854cec7d5e2ffe83dcc1ffc7cd3731702be4fe38cd9a045b59a4cd6d9f58aa4f365e141e03fafc597bccf62da41b388dd149aba0e4b8085bc1b22cef9553ae112a89b2d2a08a7cb2c78702aeb03db7c8d751ad2befa6d472fd8824a42dd1b2d5f8af315e9d3fe6ef996caa81399ba9a80f24851290b339e0edce4efa9e737adb55435b39a8da343ad0a8a4a280b79223baa8a47a6da901a0ff05b0d401e116c2e13f71411047557ec5535cf2aaabec6fee22f5bca01115d32cebe9919ffb8e70dc31e933632f4559d9395c5806aaf82faf362f6619839bc6193982d7f61860a56ec5cf61e60986b2cf014a0f4b1de7b7e222e6e098acdd754221d1b022d18c3a27d6c8015b4dabe9e60a206f139f1abeb2e78786aefe79a4b4de18286a4d5ba830d79fc4cab5bb7c0cc32671e6e653c087e1e902424b0f4d378fbd207e6ed68dc9b0a43d379c58dd66a784297ca190e51755b849f0627b14f7c62d37ea964521b74097a6ee31b33defe5770fb321475201cb6803dbad33be8459ec4ae9a866a239e7a7638db752df6edb7df78ba0719823e216b2dc07e943716938dc40dbcbd510ba9a01ca7d71cb200ac27afc994819753eb73e572f54cba63a52baaadf7305ced3e4c911b85b935a13635058e2a19a6f1da2b2797e45c0b198637a1a8cee3b58a3b2c4700a9ee768ff8b09d53d41b5ef386071a352a8cbe56203fb569b0cdc3bc6f3b4a32886ed4a6576b53cf6f8ac0900cc166ba23884fd937f44e112ef07f292684df561890a4547a5f7002c78cf864bf45471ae32742938204cc531bbe03c37d027cd82392bad17b4fdff9c1708e53021b605c30b16cbd9c11fcadb11389507183a65810ab2f04bf53d419ae6e20801ed27e2adea19ec26746ef26f50c74974ba3d09d09daf9f525a0ab25ca7fa55639779685776f5dd78f6258d2ae5a0b78f3fc9e40ac27ad78d005fa291da753273061c5cee24030921c8e772060635dea40afdc35b8fabd757d65d16af1e1d8031cd86bbc6db8e27405c1923d02ff86e0e0203fb393","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
