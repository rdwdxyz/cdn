<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29aff729b7bf1b2040fb6794a195ab197b607eceb4b793e5cded69e68b3e14f4758cd7125f6a4a9ca3da936bbb3ef7a18948d49f3f5047016c5396e41dd4a2d6772f96d20caaf1ee6e80c40d174f63248310e657f254f59246f8854fffeb6377548d4b7888e1dc2f2561e1c69f27d7967883a9ae10bec97b353c5d7031f5e34a30a6bad0c73d155cb2e9fa1cda4c1dd58e0ea15b1de0805cc1e60ef1f54c2a2394586826e88089d2360c756b794e84ff0a1a8dd55c06a2eab3eb22ac7df7d53f3fc8badd5adf35c704267f18306c5360b439e21f581ef41db339642ee2bc39a80e903acf86822b6dc1daddb5ce324c3c91b1c96391ccc21344281a5e0460b1a92f85237af3570a8b59db00be4a6f6d57ae2c736cb23b106569bd8b0789e74e8641b2c9d26c8a6b1b4448a4af490cf544de60d37f13f86a7012fa858ca319ceda98e0e34609700dad60481c43b622d49f7db81a313e35f6c4f8ff042b23c76ed88b1b6080534214ab0755bc475981abe9dd0104e1ca4911f359adbfa0b034ac7892f6c854348b7ac292185d1c14f148a8ac58dbff573f3fba491fc414456f6c731ef9143467410d322719093d704d9bf49aa181a0f14553714d3eb54e930742d11af2d74c5ace9d5e56db3b2c4b7c81cdaa101b5443e852fafc953cf8984efe98eb91db7fc12cd196631e3894cae8e5098a8ad919933900e35955cf36722b41ee693eee029c1f971209bc2bfe50e40d668185245714ea8ae918023a6cf5a25c800964734ca6c3abe1feb9c2a98484421f044e31522aa00d87e43fa072c99363e80ab00644576963ff7b3160f4cfed9e7f91b0794039bf2bbe939ecc795df27ff330ac0d64eb3111c8a02375860ecb848c3fb16730d802df26402ac6d45f49aec4c9e9ebe2f3801fa5e94f4e3115a8f0683036d58f02091753e39772bf10c184eb47409ff38f3cae3aba585c83f5eee09126c25f0c28132534e3a4d2c934597246c63c3b820d0a536917511d2f0b6a9d98cdd7a1f9e2225599e302d9be240094f2679b4b5768936fc87736b2d8083da853266e01371bac20d548b11ba3da2ade49ce1ae4119d5dd2da3c98e25b11cf9426ea718aefb684cb60cef3f40752552a773909b0adb297a713e759271ecf00183e2a826bfc15468cca0a81fb42d572001e753f07e4ab95ff8b44e0d1d54113a60d12144c83a63599021489416d9f58f0e1a76389cff5cde5eed477833de13d6e9efd6b5061d987982142068024b20fa42d07a10f92b01a8efd8580ee1a6e61c6bded65da3443cc19f4b0b724508d760085e6f90851b5bb4c78010f9bdb0194da3cb3191b3fa5abca926efeee56eab7b103545a2dbed3c5343cafe0193b15a9706aa3499bffb147555d43acc360fe565a777c20b5b8e21784e2b6514b7f7b682e62f645ee1ae9b29f0c126e712e2ac7975df71f11d916ad7998b82e7d66730ab6935f4a6a1e283a54507e10f346418674822ff68a26895e421d6c073bd56608b110fd4c59cc47e473156e5b2ba94c5fd128117b2dc4f6c43d77837223817a1c83f3a5b1fea78c752890cc433cb0a2d3f55b95886689cbc7089c929e851846f46ba2e14f92b322b4438991c2cd65d150ec01705bca8710ba23bb2f4bd797ee8d22aa432399b97f23274f2959b97e7a7e9fe7f5679388c03f4405458f9d223dfc3f4a8eb5fc6a8fb9da87781923076ef0c32fcaf8341456e0ccf9799b4c2dd281c5a475c8c7c524076f771469413e06f47651a0326737eb1751e29af9c6807bfe987da7225dd9958c4c52cd7e4fc85667918391e4d752b3ac3be3d72ebe6da40d000ae0c6c7bc503ef17e0654f85d1dcd625e9518dc4ba058c9f25a9cc50f5ab64660b5684b98f9e2722563b4340624a3b3152a466f5cfb645effc4e13520f2ed61876af641fb23beab2ed839f4eaebadfb24a2f5aa938859edb910ea7389466cdb286883a7afef1a3faf456ebbc078e77373edec2a5c2690f731dc352c9840df9978b403aab03d2137a77ae18d555de138edb2a938968efde3c53b97be61352333db393b1283ba3927d7b622cb10a1782b289587be7d5b889ef7bd217bd080c66e7fbd6e95aaafcc2e441d1cfe2f617611649a34f3f39f17ae675d2a4fe672678f52ebdf98f2a9cd84ffde1dc11f5b46aed7ebab9820695fabffac46b3405793bbd3860ab8c5d7a1fcb04c1ca89654215af376e83bf004e29564096f77e7216dca66c57b498949af968e56dbb2a3ebaa2aa13486d2b278bae5aa88fe5f67ea4470b02a0ba96edbe2e41dc3e12c46acda47180d69ac61d540346d43d0f3eb68a3f3c81d4bf3c8cb92667c023b0c949daa6eb48351e6e36a417fc9918b084d0fc9932cf9baf8ca77a52b4f657a10db93df555fa29e4281d3ee91c0ce7a8a656472cf3468939e5db99c4530a9274261de262828f26065640fa3fdf10b4acc26766627373d8eff45015a4ff3404173ac4ce5dcb174394d2dceb805ef8b0a7d6810867460609235c6be06e86fab7e01e792c8aa6035fdf5eee698b72be0c60a17bb4400dadf5a0fbb67b30bbb42cbaa3fa33deef90b150a8f88e6a7017232828ddb2a1e92057ef9e0ea82d9a16b3c0f989526c3aaf74b958a025ff6434fbc9e1b40a132cf0f2c5261f3c35e2e166ab0be40199d0ebf0c575073ab26d7b8ffa24f3452eb9581ef961649dcb4783cb9a172b44fcaf7fcb419ef6dbccc9adfffa4fbde54e99ac5b6063cb7f1a1e50c1639395fe4583fa768b75b80a5bbcb680051fc432b9c02bbaff6de9c3280b615b7fc8f7068b5517489a6493b89fcf01957c316b91b7482b43b30a864c6c6ce2566c3e94a43d5817d69ef35d6f822420d59ee97c65864024056c0cf55cada47a0a636b245ab798cd70ce5884c68f1b447045ee6387ca7b9249ffbcb5d26e5d35f06b7d531fcdfe62903fe7dc3dd793a12cbd12df286373a3390e36d75790f5603f63cec56102d04feeb0fd623c20c6eb489093a290672b77c406786431f50cb124813af65b782678bf9a862ba4dcb355b9a52e78db9fd459cece6da4bc34a3a39a13e02c3de75e0d0876d0717ef8002459d776b87f02b9c73e247fa64d45a02ffc19944cb32dbd5c0a80c7b660092f6546787808bc6f0f0384749c4da77de3622ab0185bb87d080d0d7129b21e607cea9e91201dc0a68596d4c8c60f4664496227f8f787305159a95bf0b9c6dd6f16101112f3a97aa415bbb1697149d8c16a41c981d112f2a87386f9781970d4bcbe03ba1081824db9f660f6842e0cd5e99606baf39bfbd5f98be5d26e81f5bf1ed09db36f8f08f4e4c087a1b736c106638c30fd6b2e4019841f154e4d7de4cebe00474d0d76820369bb6aa3c324d26b6b80a6c22d774230c222869b7bdc1a3b89aa963c2fb3ce2c72645024e1bf4774b6ddb44212609a4c8800447edb89251fadb38c8c4db7b10ee34467d75f05beaef49832de34a1a753c56d8feafe5b6d9249d12f2581136a4351febeb3bedac2d2a34580d9e5c82ac5b18e13a61b68849b0029276258f49cc3cf5583cbd0c2106dc62410e3a3ae065868d7368dbc936e0d11cee45729d4cc0204009ad20af0308c54a3a26308420476626e29f257e35feaba0cffaf5ff2a48e152b4d91903cceaa935c9593c3cadb5e705c4866fa4e0e0eaac7b0de7327513cc3e022fbb94eb04dcc622716c1444f56b91d31d01e4887370cbf2b0e2e3dd5460a13885e4f6d2a5fa024df9dea4191111c7475a9a09a2612fa11c4d851f618db3afd8a80fad63701ca322e9e6b6453eaf0720a0cc419b18133dd79cbd749be389c5c72c303f4bcc366a7762d0e108827ed6233f308a666d8fb8abd975f950d38d33739003474cc7a0d50a3f56e66e978bce0a8053c01ee9c4162e72c0e1fd5f89ded8791189fe07ee18a264b6cc5c6588b9360e0dfa2a582de153e6108c12273605e75c595128f0c11e0ad74032b68ea61014c40f80876b5bb9285f952f30bcc44a1d314ac32a9d0c801d529a3e51a145df386ef873c9e464a7952e8f21d9b583b13fee48f3642cb93c6ced8955533f2da243a568bc3baa5f9bc2066ab7e84899a357d373b97bd6c6f42e85d1bb8086bf266828c8a42db65cbba8105e8123fffe1b90e3ba351cb0593cb0d7041890b4892d0753944355b8d4385d670b01247b99ddb5129266dceba7edd32c704f6d7fb8b06ee2df075d25fbd0ea5bef5b64348e780d9621adaf4171079aeebc623e9995f8fd11b52c3e24a25a555774cce75ae5cdbc9ce1ab5acff26cacb2089c47cef18bd92b2ca5b612e44b1de04f23e75f9b290f54eb646fee9ac8b2be3bb0c9cc1be656f786ffc1228c7a0fd04ee71230fdf73becbb32b99bad1e4d03ee284b93d1b97c18154cc2fdf3dd990a3b63814999ca0b03a7419f1c5f6fbb611c8e50064e465f747f9ed15ad48264743a76fcee31a8590debd7495e7bfd4a7f004cd3c9a375ddad9332f8e09dad3a74f1c2de4c838e0b97a17621fb7deeb3d7a99b643508fe110007cec03757755b4709dbffc77c217fcc64bd71f510e8994cb8ac9b4742753a01a897567944b5cd6d1d7dc02452546ad1d54a772e508aa00d5c49b3e4a3cf3e276083109064edad5329d2ddf883468beb29078f8c8126e7da51db13d1d678dc5fb7c8adff54ed216184dec7fa845b6a9365accf0949cd0f94507f9642f40c7a53759e1b917e88ae459c790cf1d03c4ac7c4d9663d24938670995ae992570eca66010ce29017c69856f6ec97e1308ea24346275785c3883db3f0557092543c879f24ebf22f1c1bb0ce635e6761dd2bad0befda1df93bcf558a2882150a5a19071b1e486a06dc9d51c4685ab70587a7715c2d096a0eb025a067e36877f2f6facd6604bcf17fbfe24ee0805d411c016adb6cce01f2ecc82b1f59c41be9ce5eef58a4f1d49485265f5b1f4c3d733b79d2cf2cc0ee0d54ad17a787a3293f77a17992c00647a249bbd2ddb82dab485ce20b339eb4c8e71df51a69f73b8f62c6b89113b2db01903a11aa4c03e6ca732f55f883e5c9cb2582f1324f5fad981c20ed237f1b7a623616fa1318c97cbb4b877f7dd06e3b40d0cc272b04fee0deed92fc520280be9a30c6ee09289ff362e3d6cf62746f7beb44348edc9015c38c407bff2a9a57a22468d34363f0dfe97720e6073e8c270b574aad965cface9bec001dbeefa1e85d6f12a48173e70e6e6eeee516ed36816d233b7c9a82ed556e9856167ce2b14870b388f1407017455ab1acbb40e311a80ec8eba8931f6313df8452017900601f99a6822191044c6818f249a0b7ff9c8c913151e1c55567537e97901ad22fa1ee876b731f9b680d84b6912e34e022af5a6cdea115cf1bec84bc95360f6d6732f1bed0d5fd879a12d3feb2aff3c797c34404285c23ea683552b75c8807d0db3e5f6bff89d495095a852e846005bfadb758a6c8a746750449794b3bfae98cbb62e43fc42cacd57451c7932cb8a678f20c2bfb0b8e9ebf91d85cf9dba6ec73ac9d5d5c68980a7a68f69c0dd3df5dc4e36df43991c292f9000c8ff41358d167bcf8b9a55b9fc433f527375a7c91274ce5ba00930416116593668c624ea090cd2a87a1eb387e6faed87ee5f747c2dc4d76fecdb80541bdeaa44bb591added1e3e569992cef0b25b77f81f996f1dce663b08fd908dd08cdd86d6c37a07ffaacaf34473971428fc9fa3436ef2c93c42e150723b3d9a427b48276e0910c9140668ea74f2c23b2c001990c7462d08d43c7c2b65d117115672ce5b8a85bed6c5071e0ebe423da12a844a1635f16ed9be819a2f8f951c137036535b7d8b4000b1415abe75a823a9e51beea695c75670a3ef6cd8dba19c8821bd6a8f60886d81b8555d50531eb59ddce4233802c7e946c5a974720ea5db30f12b4f4b06e2d041c33ce8253f0942b59525eac7a7f8c0b0fb316c71791406918e7b95f024f658bffd789a3d243148110dcff82507c06a3032184f1bdc63efb2dcfc3bd43146a5715e4f9f67a222395cecaa84a958ca050604a6eef20215ed0a357448bcf0c19a4e85e15815271a994913fd44da78224191e630c5236c081c50fdfb0f0aa407abff7c911967e5822e6c7edc946d081e3556990947c916085b79911f20e43de428316a953dd82ed90ecc37d5979251fa6674d10fa31ffe9deb2b8d9ea008630444e5e9a68f23148a0bb2aad70cdfcb8ae52c04039fd0aad413d2886798531ee78c5f2997cca4863eb7cda48daf243116b00a1895cdf572cc77ac7e18b69fb7d6ea2ef64941b8d9259954456928ab5cda2112e6f2e92ab3ad85ae9c343d78a46d14822f47036ce079952f435738b5623a6ce3277d562b05d500e787e2f94064424d4498dec315959584fb31cd6237dd20d05fd6905d941bba223c8c6cbadbf6229cb332077b412607dca7ebd5db79979015fe147bbf571a6f311578da5fed4e8732fdd82913ace0c5ac035dd3b00b423c22787faa186e5ea6ae2dbe8f130724c9ff6182b909fa814565253da675ac5c1811d2899d866704495976658bcef148e8a8914eb7234f6058f5603518cc3de16b2699bf8e49862d489c0f76ce74024ee644382428a08917ce7ac0b30a90eae733b78710345e48aea6c8914a368747f5260f0bc968585fe640e6290f198834e7c0b2bc327e1f9686b5142e3b179550f8fe8ea51d18974893fac623e77b9b655c0af952f093d73fe580f767783fc3f37196853369db3b0c1e31876db9a554c9b6d4aeb86177b1f2f75bc2654e5868293aa924181e0ac5b90b22cc047b44b327ac99e22c7c655f8178119e62b20f838419f1eab510679a62401f9907e95fa0fc645baa99e62ace9ce05e8a2ef565120161eaf2cbd0183ced23466d1f19e7047d3513ba350c838ef95a28ce7ce56dfba1d0c547f2315fbe1cff772315e5eebdfb935929b70b65758a05055f8bf9354bf8fe15ab4ebd366d7425ca6daa5ab0c381e7d8a5968342e31b6737c80f2a79f07f022e9ee7c5612c5aed73c84a760b16d04e837b38233b8368f5ff3f11859fa95a8bdb4b086141e46e718ec810dcef7e269c6ea6a7650b111f51a4bed9a12ec7060e9cf2973d89eb3bea23ff1a26a9cdea3d3515f98141876e586c9e960d003c4b179b85aceaf40ecaefd3d76e8070aff026e549f0898b8f9ffe2870dd96c72a5332c1613d357be6217f51fcdb90aebd77b4f5fd2e743ed5469de8937c3e73a84436c7f9ec984a83974733788edcd0cc96e52aa894c5f38aecc7eb98929e034ba2a0f08b780d0a77fbd115b526904cfe78654dd1e93f31533ae098e7d262e4f6b4bed98f3f3be810236bdc1ca655892f3258202dec26d26bb588c731e80ad45fa3c5d1ff3f9ba19698f23bc994f3c04627b3062986eb284f8b31df2e0e6d5d940dd770151709da7bbf330d87dd7f0327e86455a277741af2e3dd156008cdc81d7a4a40180c21416ef07a11134709ea024e29a70429e0151e848b0248c17c5e295af24cdea5928c4f444d27ec5a0976f0f008f3af525ce35bdf7b03e3098d410179c5736b3db541b53cf3fc787a609751b06057b574e4e11dd5f9e4b3730dc491a9652463df7b1f4fb17c001029de114a42ed66ae0c79b4ff6b3f13d7c6c03d492c88abfb216e077a7b3a2ae89dbe98052ce5df4d5c22220d7cd0b4467a7db49044b3d76e1c7cc69f0b960655639bbc03046c9df7b43c3e406e9ff0f793c311da17ccfe7625f10937b3ff8b92ee8bb42cb8e9004097a7e8a30998de670f5fdcc6ea9d3c08f9dbea8d6a72e9963ed48a40bfaa31a44345bb047f366b778dc7dc1b9fdc27936176401bdcf5f969423c37b17a09269b3903e05aa543b8ad6dd8f729cf502a32e47124ebe9a89f8f479b4161b564cf9786e3e93095af501522caffbae455fe75c8e7901fe1d59fd4d12a7fe4bdd6fd6670c8bb8b49e944ee589dd3022b638a6d63341317af31d5ee85f5a40763dc4023ea4405fbae69d03bedf65a834151abf5ed81e8443975a1aae606daeeae108fed7b991c13d933af16f33c241cf028c85357bbafc488338fc4a592011ef7be1e3a4d7a38bd20cb1ee663b937250e69219975b63cfc72a6e166f97fdb518ba82bf1c7cca041d07bb34917b307b8a7c3700388345b1fe7c7d23f6b72b2cb2b7eab34c894b740e87e853f7ce4c7f6abdf189c4edea57bcbaca475cb92ee263675cd4d687d97c7954dcec2071778856dcb87c8879f96a3d0e2908fd9ae5054c438f7f7ac2d40a820dc5d12dd9667668cd50a4cafe8cf9b51eb577b5524eb82e6f57ac21e431f58c6064d0110d7ddccc124795b31cd1e0648d18588997ce403f188c8e87c140eb750a3e6773ddcd0496ef1c70d0ba109afd8698969d01b7feb68f29b2d4fc803e384fac31228aa3c559f358fac49dea0efb245a7cf0916d1d9dcfe5e464705eece03c359ab44d159334470cae84c1fa4f13100c34162dbdf5a368cc5188dd95ab68ee7a899f38f5e8b56910d5c72994c3e748ef8eeda8bf78905e1bca3112d69bcd367a2e7c5c545de62330266b1bb9e8ae41a64a3db4e76566f326902e5ac7bce68e22f23a6bb9202a8ba55a7486daa2371099cd569b4f26ec1aed4a3cadd7c690ffe909ba61717e0906c15ca0f359ca53d8f263982f5066bd0d52f36788cd3ae6bad50e8c97f004fabdf66457d5cfa7ba9c9a76798a6aee3b1c3e662977357f38156ae36da05bf3d95a3ca83d06f47c1b770bf69c49e317de5bc0450a9317d07a926447205c9b79406d634ac79906c5bccbffd3bf2cfc0435f47c5b04eb28c75321ff43900f9254ee0b23bc1e968518144e118cf59e838bc7070a31e4f0640daaddb62886a61324d7bbb7c2a7ac3ce7ca1abd36fc29ab6e65d5e9c8a42bdf1cd3861469c2fc348c18716632205ac432c6c70f7db3f4d64c017c2f22173fd1f6e46dafc8092719da90561667c0f7bb80727a24be28c4e0752293c2c0524986bffe3b15c5d4d743733c1b2d46ed24f0326561faa1faefca286e3f2d7f0f89158ac46cbdfb647f637f74ddd35922a9bd6c29d19f793c75c79d6f1a3e1b76a2fbf5fdbaba0e4b3e23861480a75090d7831cf5b44dfdd4fecb0d9471ba43091b0591709d59c0937d6306aa9d703bdf3a5f946e288609dbf9b49a8cbe86d23105bf9f270237f55efc79ddca66074464c1d10967f9d4b7671930a597dd181b66d34ed93c4be2263fa7294dca6eb452968f1e9043ffd754b8ec8f30f8a7d12e154ccd4360ccd87a2a746294a28e92d69273e90dba68209648509f53389cfb3b27c1273e7d65d378387e2029e737bfceb3b9af5588df7cc2396e53cad36f648c1c6bfbee3219129b1b239815aa2cf85de1b48ee573a5ec9c7007a1fadd43acc9b6ff768229269244a2e6d41fba8e1d2405f7272ee1d2582fe73327cc54a9a1dd1915c010d0b3d6bcdaa03752343f548909541288a383018d066f178e5ce4df167e5b6aae0d7d4dbe30cf429860c36a393662f493ab4938b8bd8d897f484b145cf9d5dfd5fa81459a320cd479afebabf9b22a4358d7d980ddca8af5fe61807c44ca68219ee9c0d306292df8a0cd13c5ebd4763696319f118ec6b15c0c4245edf9d061df78a38016bd3d5113ede4a444103a5611915ddeb1fd24e74ce5f8d1633a52775e950166ac373f5479424967d806004aaf3d62f9707ce1ec18f92372148e312723444c938bf65e7dcdbb30a8c4022480f7c4548e18b8a66d64c201677ff3f223995d83ebb7dafd03d2a409d2a6b7258c7416e43317b14ffc1858fbf8d8a82dbb9594cf53b755345ae7f6f6ca427813dab5c606b04888c32f1ae5919d81a05cfbd41c78e1e241cb6f275df99eb3cae94d7d6a6369baa27a0e385621d43195c9b41bf0ee0ec837eba70920fee1ad672bd04ee8f667e08b8da6eba40c7b8229a20295b91d0613058aa801e2f5cad76284a19ce99910743d1b987721e19cbdd7338f12f2f93e420eeb196f904b2d40d6567eb0416ab97d9e6dbbeb90218d978c131dcada3525778cad9f2f5589d31788746d5fd2ea36e0c3da5bd2c29985553ea386e433637937c209dcfabebdc91d2ff9cdfee51ebbcb154240e981aed9bd038489a925e01d3f34c3f55aae9abdec637d9a772a72113d9db280210c45a09d2a8f3068a7086671c08812105cccd9a7633ac9ac596a253a8f288ed0bdf0cc288286d2c14155b04e9d37cadd8b85f2d2eff1954b4d78cb9ce0c7de95d428d6fc9ef83455621c443578e29df66289e515315c37ccae658c55d52d1b75b90d8d1ca54706d73c2702b28c92e859314d87257513654c13e6ba3f375004349162b12b437ead593649645be38e727c1fafad97417b9bc1863a8122fdad022cbc40a06fc3af4411e94a16f684a24368a32c76d91296c2744a77a7f006f4bf18103932559768b787a4ae298a81f191ca92e12c49f1bb48fef90522ba9771b5a6a41dc0f278722264ca5ae493ec6365849e9c1b1d9caa93004c130777c733a5f0341b205dec62ecbdef2bbfa4daaea2bd7f99ab71dafbf12195130bc5055c2216e4f4b409e93a1d884044d510df6895b5a11938da826b7f428fdb054abc50550a1f2e006f08979f1c606da48559b1f5a2d80f26ca6ead08759cd63c8fda5de126d86f4aa6cd9e6d5dfa2c213bbfc76cccb37c07de4452f90cc60c7fb3d165e0fd847d427afa0c612aed286f268b339395ea3c6f5fe7b02172ec8c80843d4c136c606e06e6726431d9035365c1cbb80b9468c21ed7287c3cb5c14edd581d8e86619772f05717c7bd68641764a3faef80fb8f0409b7692f46411d242cb79d87a94473f37f106dbe1fa49c7f27ccb925a0c6c09f569cd4527e1703eaa45d90644bbf70030e7bf2c99285057a5f6bca500cef702e72f9329ae9823345073729e98f7c6591311c791ad0ca4c897d68e08a9a2cc59b24fb6c61224121fc053e1d27d716a3f112c5e1708a188e884ac30bd63678aa58bb78e714b0cbfeecbc12ac15077804aa0c1f1ea8018ef0cf4f1ca1435f25acba1b20de1d4c6563808afcd64f027de92b87068ea09740d6658a254fdf82b75ec9b4ba74fe798261c6902c30dfaa965c383d80a8fccb1836203851e9d528c11190dac55195dfada545eaa51188b3a76f1e632d675d7b6e5bd12856a93f669a73c9117405d1bdb6abf84fdb547d9b6d2e0a01f3db7ab3487f358208620e16a5845f89d1647e3ff66521ae34fd221d7fef4932fca8f03143353c48ee1a9cc8e52ad6ca5c0b7e3bbab3848f8ff30c83dd374b8a7b13d77b9396f99551aa36682b0988fbc616a85267b054b07a416d04f47c5405f6476c766ae382092da865bb191deecbfff652ed72de8b20e179b22f1b8c65e0ddc999d452106be186c989acdf11922339b2aec9cc64cf8b4be5826c98cbeb641d790c58a4661a44921bc4d3113b1eabfc8717ff44020bfc4f955b4a21895f8f44813ec3b6925c9aeb652525adc706a5b8bde2a17fa407dc4d4cc55f0a0f5b69968ebe1eab691258c7e676048bbe0c3acac08d90d8f4e71a1fa0d517d2e27ce13eae86d1d15a5af5927773b90337e16dfbe5d80dbc231a885cea1856cbfdb7fcda6c7771b4639070d0b7d11572722b369ce6a543035520b95aa77b84d1d2f11dc25c11ddef673a4c0fc6543f5ccbe4c901096fda254569e7c68d2f7f707e18794a2bed6d78a64a5df942a7e7fadd7f349ee570d6987b2da4ab9d08f83180661fa9d52555bf025125ac44a849f6cfd3f5584fd88caa9c8230c6f3e4fc3b8c09fd580fdd73201adff1d917fbd988aa22f0b3c9243bd01aec5670184cdf9407c3befd286e2b4833533090b743f457d36a64414160d3135def1b455ea45c042833f73a66126eba0d9b2846eeffaad63d783619e1cb6bb86927e2f9d37552a87714eff2910da0e6f34b06f4f35e877243bb4f93b9e7e9abadbd3501fe8d38ab1f74d633f34a84bcee388a358d0bb1b24e2a678fa490c58574576c8a7b95638dedea1b7e12e08e4c45d4aace9335177f0be3fdeab250c94c3f8129e3c9c440c3b1fc657c0b13bf73cd0bad4e620859f896a64be7fae692774b1da64ce59f409861e44ebecc7b590d8cfbd9621e6c2945885f3c40d0db8631bb3d5990541be8925f5497c069c036b57b82b24dae21fb45a2d5f71f1108056593fab6e38fd8ec478b697ec74e0dcf802d50c2d426883f8991d79bc4dcb0b0fbc8dea9c7ea6abf0855b55f1c7cd20c67ab35478ef244a0a23b063fd8e37106ec6f4c98699903e9d832736e7c8c76730a33e49dc1fbe189eb411134c5c2eadf7efb9b2e99976309bfc3d7221874c2d460f41ba6b14a81929d5249c1b4504a8337d6b5e13ade15e60cc6bd31deba4cb7e1efd8b2313cb0e791253d92855a777c29c8ba28e3a9b25bf3ec1ca32248de3fc79e0f1fe40ec60cadb269d91264add6b6fdab86161c471e6340f8c159ee5d207aa2a709e539aae475d4e35b1671374f9fdf714167dbf642d49e73a4b47652ea28b684ef2ddb7921a9580211155395beb1d43e6447dc83a3f8870669011c7bcc8a63ce3356741cfc7e78f9b2a85a3353a31d70e18f00134dd67645d02bd4d37848e8f4003afbca5a92eede8558c075bf452f8cdc85d773f4b0a2a920beb31b08ddac98f48c041d50463d8b87dc601b8d6868fce059ef00e9e843e4324bc5229e523789800054527d8e0f15d8e6beb8a2aa88d9d16cf49f68774e96e2838dac67e9320cb72cdeeb3e88ddaa999cb679de0d2427d439caef4188d27512345b3ec7081ce83e867c4d148b9bf6f4ad6ec99e699b3a0d3211312b543449695da12800899bb516c7d5d26aa93c47ed74762cdd928a27c9461ba5fb970dd66e22d4a29cbd7992e4605da5ac71f7cefee137830ef5d6cdd50dec08e20a9d2f03e445378483933faf6f4b2da242e084316f3b7fcdc334d4cea39c0eb310068672804fb4576dd152a9ad506552aa316cf8571e6b41fcec2c01d7d0e15c4a58348d57ea3ec60af548f364a3ded9ae1a3a815c4fd8dd02008770b23a7b5d9bd1b4ceef7ead6c853b7e51155ed0690d060604c06108aa6c980a04b0c83ee0fc0de9bc07beb6bc9dbdc8a712d6eaff1518d23915bfef28e819ab9b45f8a40090b210d00db56d19d45357b305ba792aa3e67e8a243a00584077907b5d48ad386fb8f8860793867f93c953e2fc0e86ca544d590fd1796d68a791596c79238ae7c8052f28243979fec232e09c65d700ff70d37f2759e526a159339c12c1da4203705542632d94b592cc2718d907d857f63f2557b667e9dfc41f0cb124ea13976d2f7afaefc14ce9b13fa42542dce6e6846d6f56692e9f0b9800c9552b370a38648ba0ae8720b00119bacf686fd252dd80b8379007faa3aec7f7fe39ac46754b7c7f4488d49ac3411091d2b9b8bb2663ef403d55687975b95535d759210b88513dbab44bf901acdc8ca64bf0cb6e042cf84e7c52cdbd5f5c79101823443c85503e46beef88455995a4912f405063f1bbf579b836926917adabc18f95864f1a125d178366cac1bfcdd9e0e1c0b864d627d91272bd6204ea9ffac8b8e5dc97ffed65afe2686b420f80e9cf65cef937b3b2f4a756ac6381cd9680b647802e2996801e62c71a51e763ad9146c03cafe292e38f3ed9f7adb55b71fbc2f84dde82f4237ce0ba31e91fc27637df7e9f2159d9a7193a80890e684020115a6e5c64ae622773a8073ca786c2d3f1cea2e5483530cd93711496f6bdb34afccb25bf9fbb82be4ed90ed48b0476fbd82aafce5ce1eab9f7c061380ef3a32f1a83bd42decf07f1f3bb72be8bdc3e5255f81139d615d5639fafa7d0830d776124e863f5d3f4ad5b7ffaec25617db0e4c7838560b83bde6b5f232f1d5bfeaa65935a6ab018ab7ba9a10fa519d06001f9ec5089c64c849b47489b8bb9ded3efab6136bc6420c5f6bc4d3402d5b6a94e03615a2b5c55d4c4ee04abd7e95cdb3a35902a38db12bbd2b6dfa25546e0ff35d9b1444467c1bf19d1c051683618cd5b9b6b0dafdf95249d126c275950bcf45599fe27c85e3683f8876898a88fa5bb5ebfba9eb38c416745d7e01bea79daadeddf9be34e3a26a82679d63850d6286cb3180f1fa2212e2f2d3fe2e9df5a2d1ea245a04ba92bba6b9ab9d0e0a9e42a6a73166fcef10eb87bff3185a38cc107566bfcab9ae482b6a059c4589745cee9c82e2a251dde92f4d2282ecf31b6eeb10b369cc1027b343fef5fd5c7b57e4b20c1f8de0a5551491d1fa1a2ff54935ed1b38d416af6c261ac610a9e401af19b137e358aedac8777fdbe95f2ea73f2644b2e2cc943362af817f8e14e372e826ccb6459958a790eaece440db904117a2deeedaef21a7b887cf42d35818a27ce9894f9278173caf8b64f6959d33e67f0e085b537d6e070fb3a4f71fd655f6dd1967e992b5b9c8a407cb889b4e52a6e2219085e2cd694caea4887d265ad9d157e39e6890b44b5d617f78803a87c0a6f1c575135bae5f0bb192648fe8a098704b9cdb985f6026408083e731bbe9990f3f6e6b59aa9e86f5289c81d3fca7093692e3abf511ef7d6c0d9bf1511a1b4bdbb64dc49bf40316176d80453589b45cf7c146cd56c1913574703f36e7699a627cdd1458781e091c51642426fa5771dea3bb3ab4c20c587aa4978e87d403e52572523ded453ca2a1b66a884202af44a25024e9294fd485425243c8a896c3433c64864e802233e8c836f0ab92fa59e33caed7a9e7e29320e49b2be8cf2015c5542d77e895546773459d2398b84d73872684d006c1592a73d2f86c1e1b8a43ab31f83e4b20fbb261ecfa1366ced7bde08413285e232c87ed8dc2825450588ba6fd6a1fbc5e12ca3ebebbee53b9bee5c83cb8557a3feba673c1ddfd2a777fbf19c038e0f3d505ce30cfac5aef8e7bd5c1db8c1e4f0a4a48ac67ae76fa614b4d2158263f12878004d0028379b917c15733ebc96f029c79f4d346032b6b7a51d4cf36c385b9876c11c41df42b1fb2931cfcbc6123041d5475c198f8a92d3b82c7eaf64b3196898e4890b4c023bf3bdd88b103094efa092f5b2a1a0eb08e23ecb292f95e6998b57317e4a04cba20dab8ed51923d416792879c97ee24402281dff79b3395e9e3f22e17feef5ec0e39d93874a903f30847d7341b4661b9e944370e7a3d23a4057022aa06178a179805dc4ec105fd29d0892304ba0f83c864f75dda2e927e492317d4d49e79fd8fed45114a5c87a751a62d22c865ab78ba736de96be80a747a2a26dbc0f1298e62b5b03612b7c2eed123522f3683aae2ea79758282cda83f8c9187cb06b58ca02d08116fe584d45237be68495a20d8fc15f6dfef42e21743157e42b0cbcb551a22b1c4f9d0c6d99af5b3eaf8d98443b066a5110fd5ecd853cb6c8bf2dabdfdaf050b0bbda8a7674b70c102e29b3fe4d1c01c214be9f5164a324b5145bf54bdab424250cf205678d2e24a31ef55048a1ec97554431c549a308cc96b9f374bca969d149e4ef72b85fdab776c2c99d8b7a600a2d0d2893a81ef21acecfeff7971740381ae6699153acf830d7653fc17553fee076eb6c7cbc68026358c1e67530d44bf1be45a7bc894764bfa49e8b179b15556f5629f6d50fb04cd9fa51a8c8079671a58bac52e3e4c18ef4bd1a5d12e8ca09ad647a798750b83e431d4d3dde64d2fc717bc6e0697427716e713a58a2311de5ac5a40475cc5455347517e4d50a1b073b11a08c75f0ce99bb795d04b96947fc3a306912f134c03e61b50285a1e4948ad2e802783a32f424e83604b1f8fbf35f9478295200f52ae0f676ef24fb51d4812cba386a45c56fd9b93b3818b9c0f3a6189dcc31fb43e1011a616a7bde1d9144e16132e2e14c197daa241702a16c3f0fb0cce72edc7d6a2ca0abea93b6c9680bacfeea79898421f8432dfe857de89eb3ea33b2b5b5326ec647c60b51b79c81e443a25b6c6523d54899451f1b4da783d508ccdcc3822b94d5e2ffa4bbd45a31b2873c6a0d8fbb6df51ada1f6d91084302c409cd35faa71956232bc631c367ec778a6f30fd124e105c6d038a2e3361177eebea00e0e1f5f878bb34c862ab54cf60c5488557d218e2cb326352131887a699c635374cea8670e0c967f8362151b0bd773969644011f3e59c92a9ad9ff29de9c954b8d6a90a1c0666edc9dc137f8117ad4cfa91e792063f972db52fc1798f3b4f557a3548e13a2f1103998b526ac04e6841afaa4f989501148825daf5b5865fcb14d5763727e028852ca9e69317ee354869dc2889c271c53ebe0302dc0e1e691354b41cb2a6ed62af55b3315006f5d441653c41a327c27766551b75021d08f6b94f586ebe55ac6ed709276ecbdd88e3012159321bddb42a5d34f62f123081b673da7b1bacfd8aed714f21700402d4b5759a9c048a2c1b82fdb53eea78c66d91abe8a94922afe0c29fbe313e0b8d411dbde54eeaf579abdd7454cf8e616fa384df3b14c7a8d9351b078d34c1c726d8119da225ffb157cb29b73bedf3f420534730a9c415a6268153514650b371db9c18c2b68c622d808acfd7141e5ba871107bb0591343674e14bb6ba4351ebc949288008be03ca20a38b0e0eb46cc326a0f35a15c4d5063d1c3ca1e11e37b5528d6342d2dd44c7ccb962aa09abac8f678829e61331ee78bb4e6b217708a36c32df1b1532a15fac5995ab1a9cbe9bc4c0699ee57d23fd952a1b2b6a581f6dce5c625f4fd0fd86ccfd29f2ced04e22297af7e33a7841b29f60278349d7ce38ea9c688e11f54056663c1dfa79aa17dcc62f2c4b68ef8a2543c338452658705159b2712d122b8f2d3bcfa1fd78624c5045fb2a6eedcc15538c83dfe167bc932d80424a7a7f6fd78392b604d7eb43968886e167ac4466e4bf3c6788ab82a12428e9f2369ca9248fa6d7414285b1804586f6a6a645a1cdd8a10f0a2433ad3027b9ea7525ea0520624bec241c149f2653c24ef75e1e9e269e517f297622ddee39d124c6e15e97e010c9835eb6462e143263b947d7c818ad826fac8883e515bb93256e012e3644f495419e8d8035425c12c8bb7e2cb261aa603803ad582f5ea2e57b7fc6e6f5bf4e7d6358dfc45734dcdb3a495b80d786b4585133e34f5df2d01a2e673ac41a8a2aac301b639371756afa7af7bd732520117ac23f222719ca187f4851c887fff18e7182c62be575b2d19e2d65645109bc93c7d1eb2b5ff3e199368e611679ddc7422d0f2af8e6c707378e7c9dedf87802946e668f3baab1fe737e20e116cb539ac5897afd0051abb35ce2829cc65da48c64ba638af0a7065c6c5f038b51edb270c6e252be701f363fd4304a3025c95d1066b46bd0119ae106e35f2830dadda394f8f4af5b397c6b3fdde0dbccfdf60ee9ebfcd79bf9ba8c8742654b13b1f86e32c0af892a91818f3cba1fe2c7e9a7f9b7e5d8cd2ae02ef7fec5f3465da4d6fa168cfb457023a9a0c8573b23291e3412f3ba9738a2b769300bededa10b955a50d7ada9e16296208b6173e2cb716bcb48350ab3e043029154bff6582febbe54fb377d65886da4c28e82c450822323086c5b3bcaff9c0abe68ffc05f16c2d5d45e083f7304bc216720bfceccece2b33d48309994cf4399c197e2408f5f772e1b4b7ff59ef66219b8bb85cb206cd01af3d55ec17dca12ff5312846d396ea29981f3967469e725748aa04d79067a26b1ad23024fea7e6e1ab7e6a6b9f27d1436c060043ec78e3d30e12093ca75a7744afbdd288f9ad12792b54249914caf311df6bc317a0693353f25348a374774cd06b6ed3db8b55577e0529c08433389473f98e87e9e19c9b4020c808ddebe69b23edf02fcf4bfd7da22ade80cab2b1bd4c05a0223baf9c78426cf7e47bb59ed1908dc58ee343df51ebe662c1a008fdacf559e16b5232f774a5208b00ae4c400e2aea8ff5519add48a0cb2cfbb7f7904b39fc7103f3883e517b05d4227551d9f6aa96863d7bd09c666a5b424f68c1036631473f9f31f5aa005992593cb590edbb2324e997bece6d98a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
