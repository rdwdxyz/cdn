<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77d50fcfd7a06495670a2e3f33cebfd73612fd998a5701f8b4b77483bda1b6df221d02b2aeefaa02743ec9071cf2640e11855fcd57497c586868c1df79c67dec036badaaa5dca67390b6c2063d9c34f0bd0ce6de3fc757f4abd974695c96e19a9212586ecb694ef5a0891adab0240adce8e2061f67d8e760bcc61162136cf80bfdadcb99aadc430a7dadbf75ea89ad2d678a403fdb4a9a514b7fa9279f0d2fc0154d9dfdde59b0c6e3f26aa58331f3305a989c77cc0301b52d3c7798273efe46db979015eb0d580450bcc239793ea99bdbbb0deebcbdde767879470c0c1d5926d5a4fd158551961d6dabe43042126676c792d0d5fc5513d0ed2da04150125d06ef3b9364ea13d3418a0e05f5411221ce9b791936828a9c7a3509fc6e52fb861175abd5e458cfc5ee51d0483db8c34cec05a5a581dbe1cdb65e5a3819dd0e70bffb6fe8ad352f0ed29d2c157a529786490a0e3b616a28f8872af0adeac61b9fc900d655a9aebdeca10320da39bf8ebd755734f825a5ec33d9074694886bf8901a5f368567ebe33163dcbbbe067dfdf624155617598ea0a110a66c0f944e060aaad9924ff4410a4f35e4fe296ff749696264dae69387f0efbe157e3ddbbdd9dde959a61d6efe250bc53160216898a90af17a4316d11c357a571d84749d57d1786d95e79d1e12002533b1335e93f45d5d6902ffdda0849866355461f59481533bcfee2ca5f1d77ae783391300904be3c0aab5244247ab719842f80a855589203ecf28162afa910552d3aea2a292fbe939cbec940a7167f3ad91486bef418bcd3b3c2de0571ee9c1420e7c0543db33c861b20e8dedfbf3b3bce3aa6d5d9bdbb851dd8438985ba315ae26ceef5e73c88bf587e96019cb9e4847fef258e1761366307ae9d7735fdbb9c91f2aa51c147060bbc72732214bb5115252e5444e05b67f24ea88dd10f3ead7306414f9caeae7693c01e04a1ef5b815f137525e906cc1d7d3135fdac0097b50bece78a4f02d09536e4c7fbbf08c99981e49a6bab210c25031f51d97b807296d48b07150635472551ad4de0e0a79973da5c5dfa887a954e087adb43beeceab5a4db88b28e871bdfce5446b3a4ae1f296522d1c25f591dd945f4db4dbf381949ef994f89328fca09b4f6a9113d90cb7e6fb4b859cb47b5c21597431f49e5c49541ef22c625b987a5173a9108ea63f58ef4ab085a9e8deb776eaf9f294e0d6600a3c5c2456fa9a32edc3bba2cbc5a63baf345c7da6d760b81f0ca8e975448bd98828c5e1644f0ff7b5650cee1eac6668011fc76ed32719481199692f355c45c1f3594cb2b8f61fc38e204b2f616cc3d2245b8d9c6f5ab14d22b53d8d197bf272952dcc71863a2dc651b266a4a88cdd15cbfa0ab873cda5fb8759710749e8dae9c38ecf4af7cbf649c7c8eddb7335f07dffff2858d30a39d337e360b5cb6836fd585a27645cd44120d6f9be0d26a48a6ea444cc3132676a516fdbb04fb3383c751f2c8cefaf86d2cacf113118ff4adc18bcb6deed54052c678486406bde5b6a931ec40dc04a209e23f798e08181068dd206c4a6069a7a287b4b1353d87dc6263859aa3af1ebefd302fee34140240bd5d7aec73ef307a98f965a4198223977f00ee924b093a2ad554004be268ce7d50217fc9b7bcc2f10eb8de52ddd92351e114b6ce10f6bc81d3b95895c62c25a5a34dc78122564ba5ba7644291106ae0ad8ab8f1752c4e60698591c7155c9e42a0b010030257a73aadf5508265cd3b62fb40300b67bda42a08c105b6106e5ac421f31e878e993f3d051b26ceb20849316693b02d4c7efc56a2af54b0832e6cfa90d6de1f5f994d17b81ce7bb41f9824f7c3a43cfd9b08500e1b049f22e43d4523ee3de921420b55734ed30dbf2c16cee061ac1fbd939000ccb7787c523e1e2537e9d83bb9a39467e83cd5dff11b4db16fe0851153f595f2ee9838105feec1ac2229d3266aebf8353f7e65848d5b7cf26bfcdc2011c193b4e5263b0bd581df106d469ddc56acdaafe1a990c5bd45bdd003f0fe0d952263115130ed58ad7cdcf696a66bbcb41be168e75c9a2cbe5513d666d409713aa567950e8bea267d6342fe82ccfdcbe2adba67a21017ffd1246bc232c2b9c10d51b732416f22d13e92ae8b3e9248c4a43e58fde34a17fcb7590442a5301bdcf708ee029c70be58913d8d74d749212877db847f686ae7b567b82e07c2be466d632c01d85a703eee3d2779af91db8fbcb9b8995cee244143dc5c30dc95172ad148eff9b8fca9526b689acac0b304a44ae080052d68c648a0191d5d2d8726e6f02331b0760be7ab269625ebfefb26fe2e2ea9176da18639961798e440b5e356b75c6030b30848e8a57d34c87d8603ff9e3bf6ca16a92732e69fe307678c83a1eb964725c8d9365ceff8cf0a53555f80834b68c7eb520ba609e6b7e1a7d752ce5512e91254fa3731cbee39f7ca054a2590a62b7a2f2172cdd7706261eeb73f26eb80469d6d1c5a0357c39db4abb2141c22639fbf08f9e176302c2917dd0582403ddcb205b858bbb94128ce0f333d9b9b469f120b5beecee95b60b08838b50b47c48ec97ee77bb9a88bd96bde2a64b18c01a01259de7fb0df5a9317bb8aedc7185c69fb7ac3835edd46b5d9bf0d196726a47be3212f0e7129e8acb1c80f8c372aa928d260da80a36b83aecc8f02bb5b383d2d413321685419830da1944287faf4c820bf3a3c0b294434beea872814b3090bc2cc3c3982fd7afa4b0622b4d94c89f2d0f394b0d28482adaee453ec6a9b15f41126daa643ce8b4999bb96068849f600cb7b45b8084e6eb0690fc26bb84e71d12a5960105dab92b96355fb914a3c4348556e40f8e6456c66ee41ce449827910f19047e44360fd73bacbdc9d9c750af4ebf942443fb7dddcea94296d3b05caaecaa143ef90f522bb0d2036df7b825de8aad20254cd803f23e55d85898e89d7e6ee223def767c56ca7fa01e8e22d41136a6d8c2bdd9054584393202d354b359b460c886abddcd47121ce6fcf214507a01b26be918b2462feab409033f785d2bd3734017bd66dc9eb878264d7c407d75353f6e00949fa01749fa862cfc7363493352cb96a2c9c12812ca5d8f5b5814cd8d11f95cd325479d310b00111fe26890620673abe96513f59fea97cf0a077bcb1f073032afbadef0188d336e8066fef3c078940a6cbad3759bb3fb1a4773943dd4cb03a81942b47fbdd7b1764979aaa30864d2f8edca702dbe3a14d6a3ff101cf9e8316df3c58d3e4854805b4c674c7f8432f1b0d36091e7f6daa269f7525a1cca3745698fa06b490810493bf7e20f465a95f469114c6d0d618c93980591b4ff6e9bfb540e6311390ad7b29b0b2753f26d26244561774cd8a1df070140035491b71bd7ca4ec52c0dce2d2b3a51d3390e0d848fb41592776910e3bfdaf7048a58b3719546188ee384b755c9264297f85bb9ad5e973c61cfb3c1e268dc044a8ade3d5ef45763928de155c6852aed0775b401960c1be2517521b58ae3d21ab983c99d190d5f8d044064626a7cfb49653cdbb583c28c1f686a59c527eda94ebe854797e8812226d9fb10fed69c551b6cef4adee12b51266d78cd8bb056a88a5ea32532b63f5a20baddcb369cc3cf5eaa4c24706c136af2f97c911331f34ea77123b1c387ee3ec979cfdf30253a304e5e96931bf25224913d38935b4784c9a69ca60a7ff778d34c3523f8e4ac06075370c595d8102a52096a323a2288e746ae8feb8417b1cff76cecf2599085c60c3ea19750989a371e502a4f41b234d2527a682f92c5a7b354e2161f10484a961f05eb109e9f54e8a67db2604d931eb35f8a3af483a2a60ead536d0e5c492a664cbbd6dc5a435e2bd44b839c840ae97d072e4abe3954a87d92ff0bdd815a2f71fae1d74fd8ca8754103dcd984084ddc17ee2f8c11aee16644f15ecf54b1291f10a55f35f700389014c923009f5c52d2d1ced93e0812ceb7c1cce8d679d9b7b9c49c0d43a3bbec71e25056048102d065e13255f897a7ee3aa604c159840e4f8b819cd16cd1e4b0e8f98493b402b1c29b05f2e92d163a5a2d24f47e2f294a8ba69cf575dce7190e6b61f4555b9c32d68d9a1f4742fc9454270d38cf1ca90e24599b50f63792e5af747f500053b7de3ac4b3a58aa77aa798ce79a7dee91733a10ed05fcd5a65397c9ef34491225426d18ce98175cbf18343741806da0cba7fd4c06d802ab8619920ef96f6ac114e4bdb5c0c4f362ebb136025c30fdd48c54f3af911bce5e1924d87d1b62600289a10922a48eb62db641ec67616da1f8624dea10cfab3ebe5286c7f2f36c0e4cd5b90b0b8480d660c4c047172d001521ae4966507259cbb9503ae5023551ddaf0608ff4ecc05c6fdcabe4915a35d700b339528a94defcf6e5905c17f00a4e47eaf9b061da587773a8e6a34a6d55055d3488304e0f90990778665cfc426204c817c29eb04d400eb31ed7d6c7858665660227273a6bbe86c73f63e3f2f99b3e06a6e2874b6c6d00321f5b5ea19b7a8531d7e6373bb910bd8cf87875bbc822c04d56f1cb3a4f5f51bf33238165ab7de7dfc663a6ac717f833ba9381089550f38c5189598d45ded66823185ea6f5c4d58ae7c02a3cc80f4ee8f6199118bc1f828f570385e98732e1bc4973c2352b7dac64794e635c5aebc27a8984113799ed098049c85e9fcac97854b37087235342c4437f411097f900fdab8a1068e24804ce6e6951397ce8e42613558f3adf827d1cd3e0a8ac04399a72883d21e79fafbec7e2f51626b35e6d15e504858066e17ee617587282729891e36ea1ba85ed0f004e12ba4cb187df537388fb381959532a1934ab14afdffa7afb6005c6ae630ed68a41582a556fd30be968ff8b7f120756102d1f6f58dd586f2d2eb09bd5aff09607cea654bd99fb6db9cdc84133d172b650d706283ccf36e00a35dd469d270c01d5d9f020db45b5cd08be5a28c0ad62d9d8545f6bf7f1f2d51d43ea05d8774d762927e6078f24c9d9d5e9a91dd0749c371090200f26d87a7bca63f7f06874f9c9bdf47f66f09540999cfac11c82369ff7eaea9c9d1d051bce6b6084c233af6ba4b15a143b634dd8f17d85fb7d5183b630166b980ddded877da2737bd6474e98dea3c7d527e8255c1d19a5d3cab87913c83dd9db4f82563b8b1546c4128127a2c567d938da5d377117a5817530c23e5a06a590b93b82c4a2d73770df7b83f80636af748217872cbc264384f9ca962e9e50bd030d4288297c790b18fbb9b40ad10fd5c90a1a7f8e9a72a031acb7d9c423f91a6dc18ed6a227d1d901714fb47e93d664a81dfa1a65f682ccbd307a8b764a1c3de10940c71edc8ab379af4bea209d64797cee26ebfbc74ca06c25de3aa96eabcab3d453bf5ce1e155553325c19590c8f7e5dda6664609bbbd0db2143c56cfc622b6ea9f3f6551953770ddb7bd800dade8810236d197251d4b62175a5ec3235663ae962c0efab7e92d59b0981b34af240fcb1b285b90668b4ef26680d7e5cf277cbdae1afd79a51c69acf248d719b25ccc91ab92e6343d0d25a6b73085d16d75a8fd430c0e31afe1db2456db28958f121851dc814f4a4a8ed5fe819a17c926c9cd08210f4d335b205f32451e838228d600de8a04395deded9f6f1cd11d9c7226c4773283025508e1483443a87ba55977cab1090327584c548cc44a86fafc2b824da9696407e96b2a206f77c79193ba709fe690863661643c466a37d6eeaef28193848d988aadf0898afbc68c3fd656cc29c377aff5b9306ce562ba73c2b3068dd9312a9736c933a94dab83e2bf2c7637ef5181dab81b527572b9584703f37e231491c23ba75d06ea13df93a9656f9e79c169253e17a3674b9ac480d4bc45269077d3e840cd9e6adf6db0cfbe13520932333735cd781a7aa9bf70777f4bc1071e28aa6a123e8607984b647824b8f13edf72c20adf1d4358104888e2630c3ddf189098bbb8399e50a1810aa9ebb489b7c4e2a86a37ff1ac191dadccd67b4c2ec842e030c957b1adcf2e1b6b4a0d663554665ca3d830c11ff0ff7aed9c718797e1dc9a3eb53980f325732cbd19542cb5758042528ba70db89e92bd700c0f06305baeec035ebae99c221336dc390d00d78eef800da3146e2252ee1b636c0ad1a86169727f042bed30c7e214adbea04ae4ae8da490fd1978840d993018c1b39a59180d5c487caac6879daeb5e1a7403b6aff7448ad1df32d79cb2a6be766fd8951937ed450ec04d09ff2a5b7b1aad2a37cef18f869065a3ae5f6a94d9093ed51b7912403f75e810a7e9837ec14f40e8f7569c7dbfcff7c8e27fe8648fd4cf325e339c2e919886ea6e2e787f1420432e98f5a897839d5e2fa682fbeb3288da7c047933c1c8a027b655c566df623c48cd873c44d6686b793e476859e130895e636a4578311870f88a468b52817168f8116ba6538f1985c72ea39abc9cb688bd1f49b3dee17395502848ba55691d303fefcba708a065c619ce21572d5f6b2499501d6e2daf095f344801e4e5f87c416fc04a572d5116b94af07651d13613f145125a9ad3211faabb6438ed95bb1437e492276b21fb13f55d0d689e35f6a965c03c4e03a688e480e484774a1c768abd0ff4d0dfdd966f32272aca8d5ba6aace03e029f0f0ebefa397051c49bea2b160379e269244a72d3ece1717ba3f5228e5bb6f9378f275cf987109478d8d95c6ca09da7e14bd6adbd89057fc706ddeedaadd908ccdcc3c30bd846d6145642a3a4edd132ca843b933bb9b6f2c5253ae9775f0d2dd994f68312b89ef62b3fd1c059229da46bda426b5a6a3dedcefa47c177668d9d1e2dd50a59b0389138fe81fe78a26d69f8e9e8533ab4c458122ffef5109ac2ea1d9badb36ae79d81c1591737972df2d2b46449fc6011af824ec1eb9524029ef6a5f6f2c4bd2a4fbf35ffc86c7b0edd3ddab5e3043794adcabf2076057dd8303f8ff0efeba6666cca9ee8646e6773c48b3b7338f3c09024f70c63be212fa9a08ba7278b92f73adaf38821a6cb3fcb92c1b14d096fdb2dc01770953ba47db84149cacdabdf3ac74c4b0e006f7832042bcd9b2538dc6ca0bd301a637143ceed3783b8a47c052fc385b9f7ac34e5d95f2f0713af10d51e68416ef1181da21fcb697aa4f146c3c6bba8aeb980eb7f24457159e9a086dbdc6e7e2380432fef80e2f649400c4423456d347b32e280c5f97ee24bd427f24cd486a14f63db558a1bf1f611e8c6dc1d71dd12ba114ae6dbedf3a550d0c59c39aaf52b895032fe0bade2a4d8ec6c67c6f90073eb3fcecfb52125fd4c59e7eabf01a9185d62d9967bfe0894cdac96c44d0f2bdb319f6c3de1212d9536068b076f067e0d80b6a323ad1cc5dca5432fb0a4f9dee33b0e4080a3b4cbe53efeccd80862362dd515c3a4f082f223a3a70edcb509c04dec22da87d68cf9b6743af29aa0e90b9d1d6076e2fdf67a6f1073d62c13457b75178bad2b86304a53c07176a3d0531325607e3d94dbbd44dd15c88af9e0c4bc3d7c16a84b91a779da438084d9803207de74e25760a7aebfd502cbd22276b1331c65bac96303c9c0e3af3cc40df0b29d43726a1889c0a7324eb366fc0c954d3af8316483c30adb0e2c17496d169b1f96a0973cc9e3a93152d4aef41326c4ca272595a11f972e416c3d3b0b74b4dd50abc96883afb8167d4064c7083dd0edd1b29f375cb11574dd9f0ceb87cd9491cfb2ed3eabd7156063e03ed19d8d37143ce011e212e5f6758a592eb18c5607cc6f03e9f02c01bdf59709aa26ac8dbd1bc59e3b7892aa71fbfe2e32b14dae8893f6bb4746e4663dc70449b8b19a964b1984d0863ac7edcc1b8a3f0802df1ad1e67639a376ba567689dba555d7be9b1463282cfd46d964d7ae3e4c99a14b6f787cf9b53357ccf7dcc584150250f8ffa63494fdc508e471558a4213c2f8b458d3361fccbd74a439cba16fb6cb37baf38b867c744805eb59f732b48f29878c36bae003f5484761ba8a96b784a4a40b2b6880ce1bc046e992168f126ebd742118b5cb502aa8484481753dd9c98592f567cb11a6109af6347f0a0836cb0a77a4ea4ce64b6ff4385750b744b9257119b551bd96909f81b9d829f10abae516d212be693e6258ef097a9dffafcf07f3915629f9319f20286093d697727aa9af677ebe72d5d70c8e5158d8067a088b99ad1976c5a4f503bc7fc2127602042185bddb349999cebd78dd21a1e4ed9f8050e1a19fcb2e6c0e422db0765e76b1c5cb12253614c67a6c2e474120848854bcd3c1e462bdca580bfc8e9bd23eb43f9425d7a3c02e34111af60a8e7714aa2e2df484d8530d3ac3fa9afbdaa76e6603844c9bed4f4a0c1cdfcfe2ad8971a9d151898026d2b33c78eea9fef9dbe89b5864d01370f8b160e9bd5a9c117ee35a2a1439229d3e4c6e9dc6b8a1b992c1f048bcb7dacaf12bb2c51cdde9e55ba18f5199be6543ac0b667cee41720b4d3d4c5d2acbd1610a823cb99e2d143218f4477b4a8ff834b7d1195fb80548d639519b9ae84a91ed787e87c86c1bf7967e8042c306f593789a5a57a51fbbb43160a16af027d73e1c51e1b9ea87f7f5f4ca45b62ff0a25c706c7e65173a3c2d3f889e4ada2dff52410ca4a34b633c795a61c3334e21751477ec32c62de26c65a2a4984d0e79821a6c40881a1ffaeb405899922fe43cc3edf14f763fb00c3a607533f9b628ad8e6628e4f4493989f421830b4361dde6ae7ee8eabb06d9a0d6fa8991046760c81355618bb804d0d054a9285e1467210fb41ebb62d18ac3c63b7a8aeb3ae7b0c181277d44250b057d886ba3feb11a1fa2a4ef736e8a1b26acdbd92f1a4af4020fc7de6f3fe7661d24dc8d3a9729602d1db98d5fa74f085cedef4205a185cefbdffd538e67f55a21e6dd87940442b02400169a9451518192d453f70d8bc6294c72cf8842e97106b125dd2263f5d534e631b0539c1575282843cc91c09a16829a4649e5894a4b8fe43b1c558dcc26bed131ed6d2a9e67c5bf2b0e4765b76a4f59bb01cb88f0a7b65aa960daa7f7900f7fbbf85091f4cc17ea6ec419b0703549d6b26b11b133eb8f08b53bff227c8167300fd909344d43782d5789e9d953974f2da0fbec71e131ef54c66b32349e86a90d6bd322e96de63bd76631087cf5ea2c33b807ff330d4ecc9bd47589e0a8ad1abd7df86d290be7c417a711a5a9147b3d78a78f287d3b860dc7d088287f92b9992950739fa970ab27f4a00423a5e08861e8c6f168f807ef3d0d0f0e395975ecbb8271f09bd208d44d490b678538aee162f638e68ca3bc1b98b37eb8b9d735c6cd45aa1d64b72e8df86fc34b6525c1f930695bb9d485b95cee5d07466e24ebf1bf3b89de33168e18d4c91b06f4bf9d1455cbde73b9ffee4c8e3e32d8c09110a80298c68861d918e8852ab421a950c7406e24909a4ff678089f19198ec10b513301dceac9157a0e307bfe0b7e836b463b2d2e826cdc4dfe076a7e87f2037f5b0c0c8cd7d9eb9957ab382b837e51379e368ab4e66ec9fd4edc8b497650f9eee980a4aa00a1cb3c5d26954f12d21c9da3b4d35f2630ab291f7dffbe1f0e4e70d3178db284234ad051e9c48a802b715760be0d389bf7464352ad21dabe678989afc80adff8027cd608490d8a28c699bee844c665b325769e1cd1571548eb67d01edd8de3ac7abbffaa89245bfef41671055f0003528f7974cb597532bc609b3018052686c1f052eb177360c918c34a4c362a36b2c061bfc22a91509f3199961317fed33398628ac1a5c94dd8ac93cbf63a84c628fcd75aa951a26c486ab556a5dde41475911f277a34fab041a784f027a846d034bb61153d2bbbf0e9e3a28153d6d182c04b1f464bffd26779a522a86afb4365427e7dfc22ec7421039aee8795b681793eb623b1c6e31b8db410deadc5ebf3f07a8940993ecc629bf5867386060b0a4916b83df4db08d04771b2a0ff779cd80942142b0ad00a79cdd4f860571cc050f96975aedb546d4471573d21d342b648ac507d72f5c7b4878adc853e970cd044afebb750ff927ef41b726435ab6727eeb3dd32e00cbc536fd903af6f51e1cd0e73395e27a5dbdfd77c95de1879c527979b39b8096296bd28c8e83748808c3f41e8880997ced6144436e428aac8facbae1d6b1c3cfca0bc9cf7008664ece37445a98c5d6da4544d2c713f9cab35088edefbae24369d40526163ca1a9bd6bd7e6bb513766fc3448c836325f3f3ba11cf85aed1fa222e8faa1460c704ae374c3c24d5aaf5c8c42f48cdb79fccbcdfe95467b09eaf36cd10b887692c8169eb22b59b67cd88898c0adb61469a27492585f9d097702db6846e8db17391badc0cf59611365bc33def4bd48677fafdbcaa21706b93b79df3e70f58bdfd3a075aaa6ea7f30d054fa39e43f772ffc8a572a2e23fa393c1b50074e8b32fb9c0581562a4564962b937d337666035639de586ffb04ed8d5e8a08e4acfb81bac2e2a8907251573b71909e1429be3b2f2261332d3dc2f9ff0f5335dba332c653d2e7d52453f104e24ce2b8586a2c631ba15f6a41fcddf969773043a9069d82fead779a5b28ed19c0689404837a940bca42d8f6296a880f219a8ae7c61f8ced82461ed94bc91272ee5146e75cf29e8bf8b9177306d9ae937e2c0cbc335272bfa1054569c67597a760c4cb64190351f42ab426cda595b5ad5637e3a16a7285d9d912e940d561941bdc43b24d2c0698941a13a451bb0cca7ec51b3050aaa568557e85f54a8f654faf9ae450a00153f2ebd1413b198f497294be0c2173ed35da050bfbc39456580f4eb99b39dcdda1e6f7beb3fd29773b0087fd963cecb4c661d7faf5098d2e24b6d595eb3575132ac3c18dacf4c674369807bdfc82225ece3a9e52abe9b3c4685bd6a4803049a7854df67d43a267482d6f9559fb257e600f78f24c76bad7b2f1f42beddc838c22237e9906ea5006820b2cd6a53552781fa67eebdf058224b9491d8631990c2b293ce0a5b56f747f94a262171b77b720848039c492a5cae810d40653fe7a34e561ed5b014bbbc5c4802e9d002a96158f337246d77088cffc4b4c749f35d9bcfdb55b86399e33a6ec2427a71030afe1a0300e4be1008f5b38271d30d14d667e2cea2e04acf5abbecb70adc4f0ff9d067f04eb0a812136bdcf4a0ff14a6c1e64345c00bd256c56fdd703552cc923d610fc35efb30f45aadc304ad387441aecb81b8e229b5ed8c3cf1772767e0251e0c044c42452b5779e0feff128f97f50c0452c59e0289e1981de95fc779d704dda78b25d4c18a5831395debdf9074fa52149ae41537ebcdd5f5e8781eec9386cc2fa5bc78c63e108f6169b5a36b78f990f104bb6272e33e755d1b187a5af4ae93ca874a66330a8bbe592c5e2ceeb795d048f57cac85a52db24ab860a8943204872d228fb5760e47e0fc5caa9073740936ae578e5b068aedf5ea144e14754e9618cb37d2a66bac5e7284d1e48b1481a90d6e0cb36c200fb2bf738d5eaaced8c1f1834f7fc83efb8a7190ce5e9b490fdd1ceb049cb8fa5a318be060cd06b23bc51e37e12a04d4b3901d71fc23f560672956d84361cf82c156f21ba5e1a7307d67b35af5427ccc47bb288c4f04d6a9a91fe39e639d8300a1916bfbb9acb84375a0bfccfd4bf334746b7496bb319f0ff7c9e152cef8b65813f9908823baeed360de94191ee21b09e10f4cd5e14a4190b2daec1870722df11e94d939be0b092cd3e23dd0757739ee5fbb886669e3c339ac421ee506b88ec3d8b942bc46ae541acc88d7f1f077cb771fb31043dbbd92a2a901ff58f37defdb5af66468daf918a85215a168198dc2d2d0228286956ddc518e209e147403859116a44068acf5ebd3b5bad0aac87654e01d0a654565bcd2980ee153aba2bdaab087142baabe51f84cdd88db14188a5a6e119629455abf1661b258d7cb39e435c965aa83f002e78f88d8e3bde2e582ff7ac09df1b5ec23644bfb61991877edc6d6a9081164d0d1ed94c81df8b2d723a9e9cc6a04a51514e8a5c0a4c1624fee6de6e5c731a7da7085f2a05883ec4b4b8362e99613106717ed02b5fa22a17c9200363aca9cea907f4dcd4303d6d330fc7b789db50302d9adcecf3065eea63ac98467b931562d2d7612c608bf01e855f859ed80c43980741105abf83fbc6890ba17a5eef7a8b953d2435285025f80d69b81feb29fab9020a719581fbbee8be84567366273dbfebd0bb3a2da11d34115a7e9a96ac19bc6b547925c1d4f26f2e19aafd74179e7c4438b51c2f1d7d944dc82d78261b95364619b1cb0f7f27d11ad056bae66c219d5e2cafc88891fdebc41703fd124883a7f709d30a56e4353764f3f41883178dcea3f44b6a41caa9baa16203258b9f4e44989ea93789258db0cf30539796efad3e3b7e079fca63566bcd0c4cd6a84862d8e4f8a3394e2ec5459370b58a4072122fa3226270c1eae0714d5db4b0c187082d562d5933748fd0727db38080de0170863a1073f74a83b2b6c36a63d9843a790a25f70646eb005702bcc16397f477bc3fb5545d5964407aa588f9c6c95db88e64c4fa886b7944d68ec3464f31dc23e44bf14d168a7ba67fae86b14764db527d00f10b56b7b097bc23c0d97e5db6a02b73b5332a00dea875bfda91c653ce06597060e107c08160dd4e3b3fbae6392d6dcb4c0b668cbf1147a3c36769ba03c497e92d5d1260affd73bd488c4ddf565d62b90c4f0d80a57f8306ab0fbbe2b6b797cac198d2ca90420423665a868feb0aabfd32b70e04aa9670d34bbea4b45d226b80ffe3880feb1b5890dabfeccf47fba812bf28170a5061a00ff6ee00465b2d33b33ebf02c4351feac31bc40f44936100bdafd99f63a3ff0e4c1e1a0f3c04ce04acc1c5c38a084b01cd2ce3f563c895cffa5367e435c8252e240a116007831f17f916f27d57ff97f2707c969dbdc723a51148744beb1db13090a82319a8a18f1fffd90cfdd796c780c485d6728e2b457abe981b53e2a76efd3e664de8465126fe4a30286a35465101251e872fa8110aa07d4fccac30a20d6f1921be193585a59a6094fe20e5096be5af6dd5222e3880936c3eeae3ad57db0965cacde536c721862cd35c839d4115397008b4b95bd5bf7abae9d62a869c9d39e4f728dc253bef962591f44b23f5bcab1db6fd9da014da7d6a6e2908a2d7646f072700afde64d3f9ecfd0ce0d405324ecf53ebce13cc88ed1d0373d3ccca1e5a4d35a47c7a609e224ac1ec8c6fe462568ee8b5ce969749c11f38349838beec99339807a84060e0b956820ba0e21c0af9683a093ecb7208f7d67a8bfdb11b57670bdf0bbc226335246c963193747f6afa377d08e917db6be256d89dc1ec61902bab21ae82f89bac0654ec5b6212a4bee98550b8edbb560dc2e67a005ed0c09133218b11a75d222b4d963a92db3a259d1bc6de6aa5cffc933d8753ba70f41b57955d57040cdc274e4cf342c36298ee6c11ba73900dd23cc45b6c28f3ecb13ee8b7cc50a214d916355d3826e592d68a2ad8751c9bfa2b110fff6d8464d37fa48f4436873848db532ae0ce95ff71b1846469065b36597517575963486b23ac4ecf960cd2143eb494c1fc0ef690f83d57d8760c3b11b6d6dac9a5030e6a9a566bf53d35e731d2f5d5874d3e7d055e0425783426833bb2752bccdcf1562237892ec1483e1f01ff4a58c1e22cd496f33f84309b3651a189414c1fa30b8538ba2d397a014ab34eb541f4c504bc01a919aa2b9fb2b6287a899e10a82d6b0aadea4a423808f9b521d081f307f571d20e0c8c8dc4a1725be2f04650c1c57a62da071b3c079aea5f9c18613ec7f007b4ed2f96ef782d67e3cf62ac62467e6610964e3063130af9b91e65c64d52a4e10a3c583bfcd44fc75de032e8c406db686db4fa00932dcfb711d2869f4a3779ea7457dbb5109d74f0185101f432ce22c0d4567fa686e0ad492dccaa731a2ade74823ea396cf8df7cd803e38326220e7047350e1f72c319f93d587f711e378927143b53a456489dee742c8dd4a8b28a8b5758a7ae685dc4d28f54935ea3b6086b101e014e61f3fe4a6e19afcc61a8707efd8da8aec681e601519dff5fa6b7d71fa95aa7c5ab613066b57fce5a7b1122fda353d4d4f45ccc4834e1fed6dd75d92a7273ee26fd8a0e96232bdbdb9c194a0542726488bfe6bba673203965ec892557570ad2878557a7408a2a20dae9dd6cb5727ea3b130ff97be46ec68c909f0c548d3f22188fa05c7f526bd84735b354c2e0a4616e60acc669690415a22a7804b0eec05a06aa4bcebf4136a6d4f1729965bcc1f231f9865a12e6c747b8997ea93cf6ef27791812d96778eb7930b1e1e3f49d83fbdaf2050c1c4d5ebce5a12814fa7fa5b7d318cc2ce12ba52fc9688e6c7f64cd8085ab1b1ccdade733992722b78b5dc09900ac5d0baf722cbbe0a1b3b919de3f3c673d8d7be892c346ea6d1a4e721ae13d271d232733e2d2f24b56e7222165d8e8504ee5365881a6ed880fcf6a0ed434b709144d4c1edc2f80b8efe56a7434a1230468176532da52c53e278f2d442b1b3f70679a1a66646dc80726aa4e2e947886187f3518d7b3a7c23082a19b4c06ba94bb441d277b18b8909316ae4c7b0eb7434019708af84c31dac89899776656ef11ea1ba7c62def046513d07faafb9ffe27342ef7f88100600b212615924c15affe93cd8a6ff9f7a1f68fdb068d3855c9da6c244cba93d9446a993502f39eeb869550f0be49bcc7ed634c85475be1f969f8534bb273dc656918feb63c65000d813e49695b19e0195413b97c7ff22158c04c6ff16e4640477e6443176c30782ebbccb4f04271f143a70426996a4466f0cc5bf5278800e4091b6a5de53190e7ab33fc48e25356e8fed4fc0a6376308edf85358518fb567bbd58f298960b7bf8e7a8ee3a22b9e124c8396b9ecf5031a090dd92e2e832cd2b56706f12fad30662b6fe7bf975a102cfdee0dd9077fc81792ea3ce4c1ba042ee1111bf8a228c8c049c0f9126907c2363f9bff6233223fb742681c15e7e3149d49f1df46477222823b65b770a77ea0fe854272ebb7c3293b392bd1428cde19d65e6daf4cea4a40882cf6eae2440cbc49d4d25061d88cf77aa9cc07e3ad34134dcadc13e14b4496ac09172cbeba1b45e133468a18fc29be25e4e8f298b161e36e8236ef84d4be9f00a0dfa79970c596374224172dd67682eac4fc0c944837fbb82375a470fc5e6b57c3ead8ede80c9bc5343d0d04cac6a42e1800ae8a25c7b5e4012cea3ce398fa607097a5746ee5f612aea7293111b725666da0403ddb17eb09ff86857e38f35580ceef07f49f613df337bc4623de6824b8f9285ec3789ec42994d7dae876224a42f9cf75aa359ab496e9fe4d5a82d0b506db090c667d2b29a37dcd42f7b6222d3f5bf1ce3ee932a97b16f05d15aade38cfb7afe80ff1e73037802e45d33fc118b585552b4b3590345a02215d4fa70d7715fc2e693521042edb2bf2021886d50f1e167f262b896d5ce11ecc11b3f5076be5ac8dc9ee93504a3b6b4f1cca3e04f1951145f303592931daf14875339485752013cb1c55b075463625c0da670934728cc81c294f07c2c99a8455b0f5d9998d66a3e1f6fe3c72f60f152220672d4aee6829b4a8b55a3350196aa17282f9ff88a7f5b370e6c7b3deb2a21a8bdb92bcafd03fbd4870e3fc0812d7f983d636a3eaa987fc4c5f57a0d35499cabf0f3c1bd8a85a3f3d2293eede3dc9abc88899f7210300fe4ee8c386e8a397b4e7585c6cc6d78d3a395f899bef291bef1ad861a2a6a458b31e473285bc37115c0d2012a6f9c0cc6c3313b8dd9fa0e32e022c6363fcfd22d36077452edb01e08ee058220460e6a3fc64b0ec5adba764a928f1a6d67ca697da8054c3bd3ccae2cfa3bcabf975f2fbb25b4aa22291c21036fef8dc4ebe6fe511e1f83cde3b9d365a7c4ebaf327498426b009ce44628dcfa189e9592759f06edc780924e698450705d90179722e45cc7ce5864125dbe682db3ede4f6fbcd09195c9723e942c6a8236c556fcbfa8d9e373c4a8381fcb2ba35bd6c4eae5373121bc209947434252fcaafa303776809d2048c3fe87e6d993ca2393c6068752ab6c90c83d4e7285c029079e974a4734e3cfb8fd808e19d54cec75d88356cb9d0da9a15e8c85116a82bea40dac6eebdf783e720625add3d3a3ad87631e0bf77a95f0589cd9d5715e71199e0add330f5f75a367fa59f4ddd91492694a252eaeb0919a46b6218a3ba29891c212f9ef1ba2e64040871fb373fbf6b91f23d4c009da2f405fde086b96e0a2ff26af1b125c8a3614730e2f51a47dfd6c68576bfd7d8b19626d86baa90340574d65dd5c4ceeab31bddbe7a17fd1cc8a6e73fc3a653048da813baf54c0ff7fd3173407b534ff00b7137356e34430baac659f5ee44db0d6ddceaf588d460b2e135eba58d9e213e6e0da7b5b1ccab2808885af59d6b992c6f48d9c93f0fe93f58b0e3e0cd72fc69dda0f5166ca0902bba0fd338bc9fdc17b07f6191a651c193f0a4c8a29e1957dd5847a279e7979f4178a3ccf6818252f87648c4dca409ccf27159b8489fc0be85ce7321d86fe790dded7f46f30df3108f6f5a4d92cd0a301d3673ff2e16b3e2f650fb818e709159658e0d075b7076c5cb74a495ee6a5ee509352b98ee36245bd362f9d2e0d6a6f3f0605255d388107b512f9c4e29789f67a3944214fa7ccc4797453acabae42d84fc7000625adfd56a81d49c6f4a3e3ee091a87f8c454b6bbc72d36d7f9d11f0440fcf8d3cbed070504cef92f65992d1c51c0e51a74bc9be230202b3e7bce28e5400f933bd36e38b943fff1f621b39c40d544bdf0e4ee22763a70323654296e4f62832d414290132ba8d1ab60faec439f0e072e53000432aea77444c844e5987b36abcbddb606d84d3f2d61079e0d2b308172f86bc916460c6c2c90874a748c15a2230896907eb936f12ae006b2fc420b0f101f9b2a0bc225cc6a6a73064358040d3a6b9c44a78caf2f7176a14a4fe905fb510081c18a5cf0ba57d588c626f51aa8f1a30159aa8037dfe26ffc2884c3e7b655848d612afde6e93bec69cbd46caf3c34b080c8ff9d9e184b8ad07ae0517850b8ff07201b0af077785a0d9de106f0231d29c1d82a2a7c2542392cf0c49da43786a0a4b96c817cd774cefaa9f2c9c134e84b301cf50225ceb18a2cff372145ce5d7d255773ea8a281c5494dd58d2761306a5bbe63c2636de14bfc77303dbc8707931066d730b8bd506fba9aecd3e9ef5e69d6d3b8c5071e7abb6e23500ff655417c4158dff6f9b6acf078b6770f3029b125f85e4da68092d420d87a2485cb919459e0608a06ef640a5a508fafc0185cc5eb54cf11d42c5178cc1ccc39f9c88a115df1a4da89dbee56140dc946a4f673149b00787d4a0ba3c94e9e506932101af98fe2e6e56345858b00a04490396dd04d495560e896ce90c7df11027f1c5567c572162eb55001f0443e8cc1cc03a9ac89fe1e3fa28bde0beb66e4644cbe845bcf1970467b5bc9fb53b5812b579515c7f125a26b3d149856b3eacb913f0172ac29178305e56651ee2895637528ff3bb245962f56cfa7cf5b7007d20d3d44c5b81f27cab7fde531fddb616181e980eec1179d420fa99b63ed4f7e2b346a24fa1b6b505c8d6c496d407a345909f1c01a4423c60853fee2ace8f2f3ef7d6e2104a60a27a8838f5c1cf6196f0d1c6c13e6890e7a8cc5576f0ad4b34174c7bd0e5883c58715bb58fda418ccd1369c058e41db4f2136b282680b6fa3a968df217c0fd8dd6937b05c99a99991c4ee6080bf7010a8fe431f9b582a16ea114b23740c318c428244bcfdfe9fdf37777a0be18685cc2ef202e321bbb25d45fc4264b451d1622be2cc18164fbc0ba40b5774981646e6b66adb711a24f0af978eb9e564317e0e033ef1461304689ebeea799ec8355a0e4838c9c393c3e9df407a17849426dd8bbf867492eb43baa15f449b5e99e79a22230e25","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
