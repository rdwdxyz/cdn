<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e7735f98a3aef0fff25344e30244ebeda559b756bfb0657b626fefa70d066d87dcdd2d6c04c5456ec14e1c13197df7b571f47498f0cdc58447abdf577b54fe4df56c37cd7cf1d86eb5b0f7ac93425c664fdf0fd56957e650498254b3b495d46cba18da5f65b74e8fd66be4a3b1ba2888c4a0d2de7af8178d3713a0095c356face99f4e12a039ecdb1c833ee0f032da411ca5e7b8b698430117fa4a95132bf69d92c78e277541d31c2f1850c495b81723649bd60fcf2c93002a5de75fc1f94df6b71ddfd19b9ebfb2d6772a55752e0cede63c113c561c0a22507ad64ed7443b87fe8677dee5dd42a843d6e3d4a2ed8776a60ab563bcedf4983b3b8b04332daf00065a5c9c6356c170a11ec6da725d6c90e808d24cb724f47838a1e91c56dadd5b0dc544db473c950f0de44b1c1fa05156d33544a1ecafdeeed4a151b7530e0001112c1b4f118dfec5ca79ed3187b4982955b629c57c8f719c0ba1c1b2f7b038b7807b511ea53c76a5452066d40d330e2f7f3492122e214fcd50f56115ee7b400cace835ea5dc14f3790d1afd1045aae4d09b3125e19205365148fbfe0f08e68c70aaad37e73a0347eb264960044dd64eb98eaaa3029e2933e741f8a9f73d02890b0efa098321158369510f661a482e800a9c21fe319448b7bd12f1fb18a383ec7a86112dca08cbcfddc670ccf0a31bcaa4720400ba5048a01346fc3591391c0dfe680050359955d5656efc96f4c56c8e694b71e62a69c41bbdd061aa2940614f1184ac14bbfb3117ed1d5da72e616a29c39fb1e04012748a5b9b01856fd6ea9e2adebc289bc73cedb0088ded4ced26fd72d99b73f90a8fe5cb65f4836d6cac74382d42ad8fce4240f44672ff36a4b8acf1ceb3f3569dc6d94b1590f35a0db7b38f7d17f232b334f5ee8fecc6a954be944bdd28ecafe014beb2a0d9714f8a5a5aa8470c4432a660b660f4abfeab556eb66decf30b2d27cffb4f9b1b3e2c5924739f4fef94db2c89ce8d5b87905f5d4f1f186ef2a0b579b67152ff8fda9cf3ce6882b8cb8e7ce7f188f9598d9fb8d150b1142582c4100ffcff31d4430102f414a85cdf5f412f688bca998e50c2db1bc1f6b26dba22aa7a274bc655890ee74a163699bc753479cad9d428db9319c32c088118ab4526a5ac3271052b33a182912452a0cdb285bc2ab738ca4dfa53f1596725971050d7ce7d313896ec6e15592c0df4f3285d29f9e05d0db04e8594cf4fe4bbd72824bb46a153d9dab61659e4d1271dc22bba356ac273e5aa4ceb6e8baadace68a7cafbf6f781004b0c8a836e08a6ff065ecac5354d953f958bbe1b1d924becfcc63a7a66ac2ad7367294a7b41b77b9d6a7bde8caed67265763aa0c15076562b0c68e21dbdcd0a0e115d221a962dbd9e0820239a507fa4fe54cfab66b71b5f67e9ecb63743410ea3414e9acfaa9ead8ab3692033715856101040d0eb7df5e6833a2a92a5fa3ad61489040955d88bc92c0647a1fa0834cb43846dfa3e189eb70fafe537b3293f5089e6d17d2a69d2071affe3be5191bc8f41c56e19c0950a2629eb8cfd7a6af4ead0502f6d9e8ba71c51dfd9dc675c354161410b11c90aa4a131ff012598e9fc578ca8377e9027078021ce2e80de7352dda4289413a0762708d88c949ec529ef4786917b38b8ea8b58d9bc3909cd825df1fe66ab350452f9e7fb462ac146cfbf2dc9790ac09c3dbb326fce1e2d3e78b8136134ded675c1a465f6357cb13fcdb80143d907d6e4177a8fe5ce05bb23615957fe7ba579ceaf1caa8bae3d789962c1109450fc7c39df9f8b4a6bebbd659f7febb514e20c596a283e0c05271a0b2ca30f18b91ff812e718e778bda5249c2f3031edd9fe9752d53a00182e7adfe2333d793e551c92bf98e1c4ca70368fb2d3927bf37e7196d24d3948b2ce5218ea985cdd28e6f2d6d04a872ebf1d9d4242a6a15f46678264b30616ac4ff18c5eebdf3fc77872f798dd5ec6c701aadd4666932b914d8c5d016bc8d63414f8be34fe4d69db74d9b420f2268de3dc322c4cb5295deddc45df928b8bc2d809d66efa659e24d4529d59e28e06c344d0a8f3a970132e31a7fc3615bacf2f96f519375af039efc99342302c5b1cfc3376c98e39cadf1b7988901ad49db36c50db578adee27c62465dbb7ca5ef1a102124183e33bfb2313fb3f2fd612df7f0fb5e3fd05d6c1cad08991075be1cfefed675eef66ddc884c3aa70056c5356995fd31cdd1c655feb5cf7d71f9a0573389c773737961ac854bf4adf216a4150eba157dd573c9acaf0d98b117baa9c80c5ce3f9664b7aa0acc3275ae3f5f47baffe254bd93cafa29ef6c77aa416ebf6f3839e3d7c7da53f374ce2ebcde305ce8aecb5800da201566dfd6fa337fcfd65e6c666fd34fa47989aa7a3a4f958917b1aff33dc04d673dbb75e9835198d2a6b3784bc413b24770e2f6cbd9be655e1303b390518175c09ca39f8cc6289921aaa66423f3f4827fbb6a2cde5ca1e6010d35363597d27d56510e364d9d63bcb0f99c72831786cc1c43409a3f66e4c9dfae251ea52d0697a3bf57ad01e91c578baae44708bb28324023d791fe2270cf98aa48b8bab80a76a37cf79fceb85a5fb6fac38bf64d9efe5c1c9a70d20fe627ef6213b57888d9d646c028940d0d128a30b23af6c43b6a8d90ee0ae239a9cafcb856d9f882ae6e12360b58458cf04925cab7d145e99af2e8234f9125de8537ce823c5e9c2b6bf36e2b5fd7992a64ee8498a99efd3de2844fdbb8c297c30a7bc8a8c9f4ed6f02284214dd5f06ea6cae8518dfe74fadf2eb24bd55837a6fa872e6e4b53eaacf9c812c933d908d1aac57d5731e2531c81e7b986587c55dfc39bf83121eaf71250d24d3ed6064f54263081ee97f05c2730e9e0e2a91b954fa234e211448803b2ade92f4b14f8237ae1fc8e464c06d97d5d10c5e9e5cea67c178c2b9a0ede297e33d1b96935ede9ff3e6f64c543ac9d2f52128e1b88b09a26a54763fe8b4a22bd3b2fc2ad05e7efcaa7ebc71e9e73f2cc48222aedcf973021a9e0dbc773207c21f6b11f49fc1082703754c0b436ecea9b4aad07efe098ee394ccab31c3e289875715590c66c3ccc568fa0060c709cab82fa66a83718d55a33eceefc94404d7f192d391bd27268f9d34a6c8611269e785df07f759f39f1a7b3730a58847e37a900fbed87bc5af348f9f8b0402aa4c5533cd9d2c1e39eb4a08259af6dcdc96ddbbecd9d693c7be86019b28fdfa689f8ff1c221dc8cd6c0d61c304261d37c905f848052ee02339eeb65aa5c72da616e24843e47bf60d9e4b5b738ea86d0676cad5f58e44782c9ba28b62d3cb8df879475e0bc5bb6f069bff7e9e2464f06db14e9f6431de05e892c57031005237b2ca6bb3f7459d73d0187d5f32b0369d35bc3f641a2417b527b9aa5825a2f08f56e2e1f58fef33aa7889512be80c8b4420c332e18c6c2290a13ce3cf69038955c1cb911c2670a7605258586ff49a38d21b86e056b5b9f5bcc31665e5bbd30dcaeeb6bdb844794a8184ae8440cdac95666717647df1d8a6d7464be411d43f8e3bf60a6a3553f0eeb0b835bb8d502df1c8bbac34305fbd2d638b6d258992b673a678e726a3df8f5c0d7681cab66ce974cc631dd82a02c62f37fefcd182280d9e6b3da84a4ffa091095cb5936916e4170b8020571fe60ede5ec077b5b7ccb55c0e05f26bbab97dfd64e2da3930a08bd846e6566a26fdb6c51491beee2b429bf00751459aac433dfb5493cb1251c40e1d19ee25b5e5ca1f0466d79a1999c747d95f2433f172fb876ea877a9507da9a2bda4c38dff12470c952532fc642f20736808057ed4bfc71fae79f110dbba5ff79e8b7b2139015ca6924744d5f85e782a201cfdcb710fd2c5c937eaff2b51b6f3366c40912a676f7390de94e9db4ee341c30a946b91aa985d1185007d5a4136364166eef60ece8b4e888f34e1f6cf62acecf7b8ac72d1f9b172b2b5e114b99307ac49d711fa3de6250c3f1478b9d0313050adf917cb40825703c9c1fddced7e3646ef143044f4955abbcab214be1e0173ecc0404815f01a44d4f519e2c5af39e1eadfbd85796e53fb015e47bb0721b3d16afab1b14dec473a9d1dabf46b26f2aa3ddcaa997219ef86ca8cd89afd804f7023214006e2753f7a08abbfd990fc408a5a45a2d5048923eb215090f35c3052c50c68f9c7ade57e3e26d1ab2af8965926fa449391a3454b58cdd95aa27bf65d8e55ce63a59cc89d5a71c3943f3d5bce7422472552d89ee2219da8d1b1af02d13ddfeb922af99a07092817c8f37ad4e23d17b1f9c0050b09b386001038cf1dd952bf1ecbc541f97e34466dd57003a60dc29230bb82a9bd6023c9612088b124b8f5f209e3eccff3152d0fb032a6887711388a4de858221be123a2e162b2195defe8d7c82e83a20d1af980c2434ca22171980e821169c895b5a205edffdca0eabf94a4885e33a222d456bb6726b15288e1c1e932e0dd491e998fd8fa237dc73a50ef8545d5424a37536ff69b959a85a4f99b65574edded13094e6a8440fc0f4cce8dd412d5deaad22458f07194f209ebaac029a9fa68e79d3261dff497699173baecdafa592aed2bcf0e7c0e06a4672b0f5df7cafd219a4efa28156183dd2f5000bcd77fb628508b5df9066eecb5b2f9d0a72b20aa2c446a22b3acce0b2ef5d564e3807b376b655837dafb7e91d499dcec44cd1623e0a6e4ade22f7ca86ddf8d825e0c93cf1d7711d1cc07be4fc6f9b35bf50f37b6b9d79c38241460c62fafb3c77b28bb73dd6c94a92da7c544117e6ec0a29289f5dcd236419e1ca67fd314824762114d1abe712ed82848463969d1bf01bc1fd191075a1234362babc90d70cbe74124e13c4e521b951f569b1efa04e0199da1c72254479852245551e4a376a1f0527edcb0cf80dcce61cd9aa0073e162193c4028c6a30fb9a1c50d536e1d172cbedb90373eeb1a34c8acd0f3c11e8ee5609e2c4106f9c44966240b33bcddcf9560759185ccf8e1552510e6760196f28643aca5e242a85c0296d3951be20d2baa16bf1f4c56991fe5323569b66abb65845749325bdecac97ee28dcf21a9f588f0fd8d00c63ae126e7fbf8dd9fdf3432a65662b0fb5dc80c30308a549789378c0e0d30ce4ff3b393b4fbc9c90617c6912f5cfd4fae51cfde10c4d17240b8b30ec69eb4b2c1d7b251ac28fa04121c9e74a968499d9b8fd245fd20359be2c25bf0e2c74cdd322b2ae1943604e6594e1aed7d7b35339ecb300b1e472dbfa1b29110d688a151d9b16400ba4688f8302fae402671d1a49ad3e9ae6d618155ecb1f7d2f5ba532ca345b8a4aa710c87d9fd1d5629644ddb3a6ef288b11e0e2b0e7b27237e612d8958616ebf30c0643eee20334be8abb876033970c67f3d186dd80220583b45f40bf5025c6405575e728ec58d8e8b7bb6cadb9deb3a0528a463ef15d7887ad83a76202c8db6af013bb0efb5e66c5be9ac390ab78d084f8a832af4362b1c09f7c64c9fe15dfeb794419a1142f61ad6c80a65c7949a1891fcd69d89072d5903ca31ac04c5485d19fb23a32ec97a9bb119d142168510b42a4108b27db1ff1d834df3c561f1bf175aceb7083fd1089a382888b9e702e9f8998e7d0bf652620464ff5ff98bf99f038d198092d3fca6574c66719d2ba59afa0dc9f8bcab9b806d15aadf8e12bf1709471c80ba3ff7fb2122c93921abd66f4afbfede34778fd4247bcebf8fe2d458e8ce3ba31d5c85ab674d766749372a133fe5003cd4b4773512c49b7a40b75aab988b82a94bfe05a9b15989772100baac27718b599342dfbfdc878673c5ff51ce6965ab379145ed9f66d92098ac039126127cd714858d66ec7d6966a63524057f3705b6ec31f7fc5a9fa835cf3a450a4b63dc33dd48099a212d4a37af2b7b1eb7e0b0e9915f750784e6f53c461bfa0dfbc149e1c8b33099b00493ecb36feb69bbd0a11c14d51373a66e17689a7af7a2b2081100bccdd46edbd820af50931bed52c40a7c22248bc0ebb9d8e724bd4990e26daec47c162b6e7d623071da06c83d83a165bace7d0f603374581448ca500df3e0476a18ff31c82e4f8b37f22783c494ff6403870866765b8641926e7894546343f3f59f6ac7565986920562c5ccf5f54013b6d4ec1b363e69f4f7aa5a65835ce651e6cb54b0d1de2f50db6606e966de00d360ab5d506e1bf136cf73bcc5f23755d96295351985d944fadbb08a8670b40c6d0bcefea921879456014c9bebda872d117065eae1b87e1e283ad6089351988ca16fa27c6947a4a63e47e93462d23099ae5e304f301ae2f1c448d4d2e07b5dc0f5bf85d05bb9eb7d7f9453068bb0abc4dad0c6bfcd74e0c08795bc9e817b1ebdb15a88778e094b17863c0820b1fc71a9f8b61ec8242e9aa9b1523b8678a7274c0992b57154992e3b30004f2aeac2b9f0b3bd7740e81be8ab376b8adabef2e4381cb74098f218176205db2ba3b0727faeaadc84d34ec12f48924350c0fee1c7f3c5ed0edac514a546fc4d1c3da713098fa556acbcc9854db60f8682a2d22b8f99c63dfee9e0d477e233cc656f6d528722063b0feb87342d99b0a9882d4f8358da1354b1e2c8bda13b8168ad7ded98c705e26af579a9537b95665491c70f7adcd999a0f8eaae1a9f22c7c6dcf28c4bd0d5d5a4e107e2b28cb2d18eff371e3ca8b068f93a1a1af0a7c05acf9d75aabefd50db4e81e0b7f3bf02783e056d26df2cbb18039f1ee2844df0c8d833d42bdf8e10017b78037a0cca03af445fb87c7f470483411ea1be40fec6ee35a54e290b28a186c72c3f503f8f4456a7520ec69206eb25ca47637b7c97f099dcdb2c4a7525e97a08c64e5473eac90988fa89428a0c58d413c6b58e219ddae728e1232849e80e2a6f9b5e4b4f1edeede545327a0c96b390daa90e991f8d646fa779a8c92b95bc5f465338cca4c076301d918ee6f6e9559493d3b2f8e22d3c7107ae8771461fe230815c1237216a6bc312eec37979417aa077797396f3127db634952a991bdd74159a482e626e4810fd8d53a4422c039afd0f27d9d69f114eadd7745853f311d7f3ec6504f8288f7db379769f6bfa71e98d9dbac8b4c964607970918a8efa2b48ec96d28c28154c03242068a57a94f130e7e3991952a841d1b3e8a1a5312683ea332f2d64ef13f4f7a51d0f3443fdc9ce5c879075313f62deb759a60002f4269d62eb61e008a362b7e511d553aaea7196b37100ec461cf8bef7e6d2ca13c02d9e1ad540e9c87e25f2bf5e537ccf35f2972a589b3412e6a780f2f6dc428689ba8a8916f255e7ef8c3073fd504d0ebd782508b4e25725d3b0231608bff30529359102c147fe67af023cb3feb683b04b88c7c94099823f611541e1f6119dfa73c46109b83c3d8eb219fda692d8e225b0fa509faf679cd3ddeb8d59b05da21870e787c9f6785b63b9ba95b3426ca2c4b2ace82046d607e536aa625e871d6230b7ca1524721bc29b5463c1a3a373b752f4855460f81065af147f6f66fa9765397d72510bfbc8f6feeff2e027cb7457cbed2e67471f8661ac8a2bb664790990ed98044ab7f7b711df67ade478b074855ab74587e9c71d5de73fbeb03ce1f3c8a8f320dda64e3d6fc9e03721a103d10fcd69d5fcd6ef4ac970bdf794412a9ca50a656bdc82e7ee40599e7ab0eeb2e77a1bea77d4a4689c716f40033b958d924701fda2c830637cedf45dbed9510320280f463449a0e1a640cd5c7ab659ec0e99e279dce977475f7c76352277e5154d412cd78a01882ad1968d26b441341650fdf01d534fd576e955a5006a833024698a23d18617575e8b87763cc90707a5f6a3bd1411ddf1ca0e3385c7d8cc600f5827a7f27c99310053fccc4d4cd5bf64610ec4a8007f00e68e96eb53dd6e0d8c81a6cd0b4291255cf9c8afd5af47d073b49db0ba140fc20a5605f5178d40b5f6a90de41798dc70aae4e06877c24265edf84cb94ca838f261fd6d4967886a321f8e2cfc0fc491213f95d1b6efe7833a6469f26474c760acd3d916932c7aceb90b68cc471cd35c55611da41c28c8488ff5dfbbd7a3b89279061c99f5724f9c39762c72fac09ced36baebde915648743b4f098b64322cb9bad93d842cbb4053fc62eeddf5934ffe6b61130047a495726f43be034dd1e7cd10703cb5d6b9d97ea6abb5c5b7a6daaf881a423ef277cebffb23a2f67559505f434382245f650c0f1b695036bbb8de4de73915049d6ba5148e4fd749a091e198a572879b1835408a43227cc4b447e3267c8148bc73495c616491c2e7efeff94487b3b0ec6218ac45dcbdc22cb09637c01163afe247289188711440ba951e2f52551ba95fec573dbf8e0c657f2ad140c439a20335fc8d530cde8e7caa21240804f68c067804efa4d7f093378c94491e208be242e9769733f21cca36eaee422e527fbff2dc4f756870698b3460463c6f1649441da9904c0e28375b6a32b07c56312c903251144161573aedb5eaef7f3c88f6b4990fa15c11f33dfd6d8e48ec25099553d1bd319f34ad3a7231d1b12f983188de7ff44dbdc453426f379893b7252e04b2a4805d2edc30481a5a51c6be0f30d288afa349d267e336649b552866deb15a5354b19231bd26fa544651e575a7b5a6bba65e113dca2ee1ed9d9bd1deab2c1fd264aa999a359fc493cab03af93369de4c700d7d1264e8143ccf918eb5b3b110da03c59dfb1a74a1a22cd627aea052116dece38d92ee6acdc1c4ee7c4c26ec80cea55ee945b09cec4fb1750d5961896872c86329144980231cc6a848f08c2db881f84653985bebb4aece8e12d547827512cc0dc6ac397a2c48d1f3c2de5e997ddda754f37a075738c300557fc08137a2350535e17e59a553ea79742dc7c0ac0d44733488f3c60f4519cef92e6aa24df44eb3f12b8cd14f965269ad08d77fb8623abe4cc2df3b60240e35819e3e8ef9664822238fdc0ef93d6a906b705c44fb9499fcc7e6eeac7a9af16874b9b081860920ab43daa2fe3c13caf4aebbb904012182bb54dcad24ea3be2724de4af762bccbd420b8786e3c045c5d9779efa317c705f176c0573766a43dbae4fa33c3e46f5a13a002312f168a0f2e0e66e7567907e42cb3a0742e7a64336f2d8b2a3232cd26f8b6954e58d1f333b593a0043cceb2bd465336fa0971b85316bed6b9a247bb54fb58d3f51ecc5859f034576e22732089136d94842a7f54fdf6560e8bd3015fb0eb13de0a5057111deaa98a921931ff77dde6b882c8d63489d1d112e1c631d66fca8c57e1532fd585ed07b0e5b93559ceff5302bcbffe3b2901944e03fa2ced52bd3406976c32b0ebeaaadd11a46b32d7e013b48528eb131e0fa6a9e5cb69a35496efc8f88d01a4713cbafc0cd34a7ff8bee762c390607dac32b5c32f78964ce9eba0eec99d3bb58b066757d0e3516acdd8ded1428ee5a14be195f76df5ad496a47f9fca1e64f914e6d9e5cb78409ca8ecd4169d0ceaf33f6f69be6bf1b333c1e28e1ed582a0b0ce84e899055a50fbc068520f7b899126a8fc87eecf91d8ebe66661089c88afae21e78408acd6005680b9ad5633f08454c60a35e6cbafc9fe132e8e13408fe3eb5cecaf56f8752dea1fa6b7caf68ec6dd84e65e5adc270e3b5861ef182eaaff00c959f2f411bf2e76a824f582643353e1e9fc60d4ff1a9c45801f86cafb3fc60d8782a7627c62c879a004f20c4fbe2c2ee0945a621900f32d41ea0be6bba10fc52a018981c6bd0675290690b79bda3078d46fcde238d58f0f7ec7302d99d27285b32ae83e9e36636634912ff599c123a3ff8e0ca7db983556205b7efc86c2cd98e733d0929ca81f8e78bcc3e18c44c7af608e0e6a14771c04573236effaa24265c9b7b072aea79d3baa1acd8fd4c3488a5a72e16a6bdef7974010027a43d6ed425339fccb8eea4f996ed21811f907aa553de89a72938c1defcb2fef535247bdde09af9253552b85be9ff76d81bad1cb9a6cce08879106a9983d2cb4cfe28d336b165971aea1d32958cdf757cf22e7c906d64aa211ee717a572dbbba1f756f546a02930b11f18cb6da626a7a14b9e9e0287726ea3924b68745c084be7a9ab3b7597a81b73e0e1eb482ecdbca15ea1d1e518363ffb8bae70d676bbc72fa81cb1fac65f675c28e42e4143acad858241453fc726b1478da9696aa6444a7d87edb08c50aa29f0446f0cdfe2ad445825297287644d4f8dd9ed14f9870d42f5de63728e968d6f2c9759f4878842804a4ae925a272cf69c2056343f4dd8107286f44c4168cc211b2388f90cf6044386337c0d6da0082bdf69d81f4349b1d9dc21acc8a9c5b6da06ed473e9540400b9503945336f13dcdc28c875537b679066cf98cf5e0107786217c62f2b4584062df2cc489cd6c7b52df76e4e2c4cba281fef3a14fab16ab2c8784ac5938872e4c15f6b8a29111151d4530466a32c9503224e7a12b820a71d942f1ea38c938479a1afb63d69f440b874cb2c264bfb04880910f6c6b03c2a513cd5a4ba70a615caac7a832b8593017d9ad9be36a9bef9f768bcd546f7472548146c09c84f4d2e212e0e53bc54e1b69d9708d205ae17e831951bb973c7e6e6e4f780ea091fad25ffa155c1e43b0acfa66bb0d81d657b2c46c977d4fdc0c0402cbf4a4fadee00e430a4c52a7cadf6b434618d4d1cae3f57f402b00c244710587996e12448ef7252874a57cd7e3d34c6e18567773aca806f14e9174eb93d889ff6d72e55d4c6c8f2e721e99c490078527fad8b3eba6a3b06c8c03fb4a75d6b79535a939343d2803c51f14e7438e1b9630bd9b984fcb4eefd678c1b45a35a1d3e57ffefe1b96f8d63842cf35577869cca5ad2ac5ea9fa4b9369f556f121e5b35e4a6a2e2a96824e3c6d2d1c0df1bb06f2d43780d63a9c1fd97843a93c6cb980dad8c68290203277e5dc3d922d6431268399280c2c8c49c6831fb36714b6373c87a8046d860d5296c4e7fb1b528fdec0ea0f4b51d4280f1e5ea325d64bf473abdb2e5712a5c28dcb5226e5c9f11ad85c27ca951634f2ce971f948ef9d51899e08992239ac079e7f8d957395ef5423d90e50316fd3abe8061c3afdbd08868e8e933eebad07376e0bed4a27970375990e45d4b6b0f12aa128c3af160d2ea60cdf568f8c1a547139de83427dca7ede1c304524c4b783f7e09baae9f41fabae06b21c7990528c3e8b0f7be6bd9a00cdd755f792d38cac77a991d3792c7973d6338ced1c6ea31e8e651af67a29006c0eb457a44b153cf4424720430d96f9c902d90ddc42382d56a556346926100f1c785071c322b492ee68b5c9e15af3e9b0fb819ffa256ce70723082668b1caa6a52ff0b85923dd3f78bcc4f9076290503ae4f66e571d548efec0cf55d5d28f9b283dd6a6c10e2911b814380ff7a27e5496ee2206eb2c7384b1494c1bc3e44e491e67ab0e83312a06ce3e79e65902e2485fe5604dedc327a063d57d22428db7828931fa9ba5b8772e70c8d77fb02aa1f5bfc0d283dc09653830e259f974311b07f99c39827dca8677ff4a4bca5cab4eb70f73a421bc75966f1153d6fb287c00215ec95f8abf71b0bc8759f1db17a9dff4a82d8b669d6eb375e78a48a02176dd8ac562b2978981aeafd553d772582c9a4546c1d9296887649246d7e2ebe0ddf159b54c31543bab874b96245c9eaaa924d45f6db5f4cf6991461147056ead9a9806904068f90c8fb745085f8d945db8a500a0b23b89fc172d232c54b5c9b6f212f6a5171c2f3cd27ddd079f8992d86bd6b1c0b51bf7eed6bf5d905a1c3d80d4dc96b0f3de5dd83d47e2e49f48497e2187f3476e8b4ec1cae863268be6907ef2b233cd4e70f2209cf1f50dbe9dbe5f21a6f44d75a31f70af7e27fdfa410717dd53b4cd307bc5b3e4a75f0138b977750c1941e260287d184465e167848fda7c9ac60a7f9e51f3872f62079e81db98731b4374dfe45d5029e51df31d93ccfd8a61eba19ac415f6a7380dcaac11ea8e13799f48314c8369d0d3cf6dc58db4e09e2cfe4552c88aef9bf6354fd201e8a9e588d1a1e1f10dda8e2794deb0656f971f64e79be202083d01b19e667e32420b0f031be859250e3e57979495533eb09599b30092ea5b75180f50b4b3e09813c5a99a8e55f27c64faa7af4bcaaf18d43e016a307472367686427f1ff4dc2712732eef26aed98c3db419163a8b63677d089cde79944b91208857162eff82638c53b32642bdfc6d70c79a2d1f8f002234538bb201f3b3d8107ba59df0da0d9f1aede403a5d1437281180b73121526a55e2a2a8577b65363a0a14a78039768d376dec5843498dafd7f40662b846f6de5239b635c8d752db7f13c122d0b72495f94cb2a738ddc39ea962030ae1a6be38ff4d15d75febecd860d825e867ac4cfa9173393067d37c9307ca33ad838557659eaf702e1c009acdc592e8f361d97085f353deb759794e166a827e6c832ca95b0296dfa99bb7f0e20ae0230b758e46dea9be6ee214b5ac978ba1163af70909c12844ffb70d874822c64fd9aff4e1e34044bdbdaa62ac83b73271d8f65639969b776f0454fc374e4affa9f64cc404f0e88b83466a3d7836b23363a10f22b462c60be1ce006f7dfe6bfff753ac9ae8224ca031cffe672f4a7d325fce05cc6f384b810a53f045aeb8a08db1c774ef8bd2da74123925ad2ec39b22ef1f80d231827298889158e80238b03f1eda1780dfd11b34ef248dd42aa3d254e25cf68ad6c48a4223a68211fd68a618b17ee1acbf552ba95e6b78fa3987f12e9314727c8d532e16a66cb15c3ee35d3a6c7ab0fc6506d9aefb9c21579bf35479abe9d86787f8dc60f0c8f98c64bc207ed94a2604c6edba702bc4a7318309ba199a9c96543b309263936cfb82b99c544bc769182088961777462ce71020dd4f7d48e1f6aba068fbc7e954fae21f30ede68de55e167ca8e01593a7d41044beb975b071883528e6c2f0f89e240bddd85e99f883b471d25a51047ca5afce01c39fb93924329cc56955a2a41107de80b342bfbed92dfc2834d21150dee065e1a4537b15192261b497b87b8c4dbb2a74123b907409305fb2506287ed2905874b91f0efc70b8c14d14730ea620c7be13027bfa774ad8087d1fe5ad28e7a1dd072b85958678b75e0e6e4a0fbc205a246251831f9f0465b1a36094cfeb440ec32cfda445663c7c65bd28db52c58e54cea1ca2c1f2680345095b5a34eb16140eec011943f17c6a4d0ad1f0073fd189778b30915702c5bba1f48afd7f330ef901775f6286c030271bd3590f156ec2b41b90d7a669a79adcd2ebdb5f45607a8ccc8db120f93e0423bdb38aecf6ac096fe7d2ac727bc5681d1357105fa17182e14f587380a052f1b96c4ff58d08d3fd365eba2b0400204057ff872ff3d43ae552aaf366a650c42b9c9b29ac49d13330d88a914f09a8fd90601ffa8bad1ab984534b553b7b34c7be877274ba7e3a59ec6fd16c51e109f06b0824572c01b7a2a2737d3d582e3d5063df29af6a1d91bb3f64d9e641d1daf693f0c9f1db8c22d3c0a08253cb1100604a7e3ae4c3e382e5f1a4de4d2487c349958a909f3cce67f543e9958786b1820e450ea7f867cd27fef23bda12977b4a4ce14eda0b6ad0c8bf42dddd38c694dc34ec510756cf9493f11acd8ec89fbc1634288be49189d8ffdd78bffbfd3436e6a462776924728c26c82c98f3b9b8bf51a6edb5f072a70601f5d8d7b791fb9be8a834d96d3799f7d4a75020f7d38f9221703782d2d3f7b727d025d980460e4fc4752b548e582185030c5101720329d9a42b0ef60b28eb56061ba2eab1cdc4ff4331eab4cfb3de9e729d496a2669a7c0b2a219cca42e1780d1fc394b8c03905493bfded5d1bebb547edec91514ec59bc10db7d1c01331ff1b4f8adc1d791fd4dc39a27f92af9c33b7ca72994891db9ddb220542b3d6cd878ade266a68c6f7bbfa7c20fc3d191296a809e46da5549dfee05b1377ddc6761a929c816b48e9108aa1fa3562e53eb210f6a197861f38f2d619a974bd408fde65f9042fe83ae513f5de0998e867b885a9f27fb8b11c64778faf78328a481a089ad90eb1f754926e58f503d73249a7f9e3bbcfe0e2a4fc997bd813924e05eb8a2e56ba9ff91e246d188ce3e948871027e6317807916d0499c028e68f17643ac9a864acb4d0d315a86e89830a23e226da1afd0a6985cba4865404950be97ff23f61046304d5b1fe6e74087ddcadec0a48561a5227a3b70f896ddb00e8fd2df8494489aa724461d7105b9b6ca523f2c21485dfaa7ba1591e9eafb4b4c2179db7b2f1a4f742dabb3bc43fddc8c9031d566b966fd20a0a9f145cf993789cbe8e8bd9c3e3fa3223f90bfeaf62f70bf24efa840c20b6ee6790c9920fb2fe158c2503e7329344567d9e8df8641aa0e726c149530910ed86991619577fee6204878b276ec30ff1bc43dec37ae1a279de363120ebabed2667c7546784ad92d922fcdc97476a7a861348cf0968d631cd29f0be0502cf2d57b1ed97aa2ceaf2d357095ae980a5e96d2da5daadf73e93770457dc8f4123b1d2ed3615ee32e642624ce49af7cf23dfbd3f97757ce76afb40b08496844dc078351132deda95edf175cbeb59b8f9c4ca604cdff7b4ef1fe4a3a6afacdd3ef3f1ec6ae5a55fb97b4c2c0697cbae3f32b0bb2f56ab88ef1a44d95c27df2cde5f736556170edeb08b7f1b54a6464d71f0ec4b9e1e702469dc4a160dadec305edcfd1b98b0627793d49112f0dd7481208bfe73cb09f993f77f6112f46cfaf4bec821bd5d81a2d70ea565d81435ffc9ca2a3bd7f1ee266d33eba90f3d2c0479adb82d9dfd55b9efc80ee5e1e1550938ed4cc59e791d5c2a405b7874840dec3eea8ee83ed3f0989b63861d9aefa6f809cac19982a0a63a55ec20a6306350e9246c37f55f0e6b1e9a7d7394b22b57ddf49b92cdd2961bf2ba386dbf0900a394619e17d5c729999a858752076ae5b8eb4ee9e830a6be2d9c08e6e7a9c2a8adc3670ccfd0240fc1c95d97830fc1aeb3295c2d8a6ef7c10c5566ae4329a7dcef058a72f70c7ff95ba4d0803bd204f7a878379d2edf02402031c1a4f36482c1362f0a13c1eb248dafb9519e4a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
