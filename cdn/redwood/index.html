<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1cf72ef88d767a9500fab64b3d6d8387f6e08351facbca2d8a7bb7911a7ae906371e4e64f50b96aa9b8052e49310980a4e4f3baa22af27be6e7b7d8482d9d91ad1789aeaed79f997c24cfe2cf2389bc4866d3ee3ed1b82d89e553612c1a0caa0d6a1ead7d823b81f9ef31152356f197e6edc99c935fc40abeffb35733c5e40f7973975fc0a0e2d1f4ee119b64bb760e3a6f586591ec1cbf92d06413e52f4ba584b5b0593ccbac5948c935f6d350a2d6bbabfa1573a437229dc40423fba4cd0cfdfb534813c35e69897c6f17754922b730e0a8e3e90b3bcf7773c4ae05f1ce18abad3915d189f75c5bb4e38ab9ad8a7f62e3d8883013eef411703f1341f54e7635dbe7d8cd2ac7301103b1a05aff9bfa9c1e6a53c60043bc54f60c56c9d6becdcce72cce5f1e6cc221a3efdb144d1ec8b092660137dd61ad5a5c2dc5100fe3c83492fe445b1e342db44bedc93ed4281ace2cb995e46addb7ed12b9465d637677154aa929db1f26e66c2d7906c60379aef10cc3e0251d0b2e1a64c0947374bf7906fd9b39b503f4e7aa5d8fe06dcb3667f3240db62a223217667d9c417001c713578f7814455a1dfaecb4aebacbf8ccf65e88b7f00db8e3e5bc4976ba47952d0c7c5200cc5a315581cee4f41d0c4ebdb6d0952631d2baaddf2ad119bec0f50aec6b08a2e76255bb117aaf8f4f9246b2b8c41e59485d3709911f4196c786a7745c804cc6c1c5dbd8cd38a361e5fd4997cd1d76837d1fd5876e57a0d3a71866f89c82d65ff2670a9ec31bf0ca78e6b93766ee7732306c40aa2d954b7e25e5e608e3fc20626f4b715d0daa450fab4bacd8db4a73cb183a5097e984b52c59079efe2c3fda127967b0abc2f36c47e806f71f56c93663cdcce89e1c1c6af3480232185eb407032bff6d63c0e05b521354d9d857122666646827886523f5ff55c88fccd3a1af06b7e080c125d2ecfb65bd2f40ae9dd59c11a6438546ecca57e3c27af1fca10d8003698fc969fcb05ce939ede53305f4c1985988d15dfb599fc98f086c22a2a34727f3b0095d42a410001603543d78bea29f7345a790048e220bcb59cad7c87cd1129d143ae6330eb294131d4667824ed9755cf4940fd0d74c8075219d60748f4f83fcb4f013808630a00ec485d97acd857861ae13e5c2db7c22493cdc9a7942e5727d8e7a150623d9e249a77b69bffff6fd8ddd5f6b45f610240a38009043b253ed757268e569885defdc989b6e920780363a95fc6b8b4989b408d3bcd4dc1694bea08c94c4026cf8c7e6aadef50cc0633f64134f93e7f5bc303812b9e31dc42b7caaa92e1cbe9ca1148a93029299a42ad311c85185e2b508a8b297ca918060e250359578f93088d331a4ad1e257b35614d6925d1a5a414cd48dac3265076440c66e30f7e476964a15d9e54ee54bba59be660a16e98ccd2663e8a04998ba19bc5a837a537aa4451726b4bab0246591be97145f1dfd276f6c73e2b88cbdddc15400af397de84d6c45fe81457642d969f2f2757208a01713170a09506ea768e345925b799d3df793cb2f7e68e0eb409bb6a43c41db1066b83d16e9e91c85d6317e1ad9e47579249df45878a2f0f71ef809fc42b1060691eb70eadc139ea52494150824b2f0d931a01c0fa5f54f83fa1dfc9bb9fd2f38b3ddce931a862493c4c2a6e6b662629456d3ec9ef445bd281b85f6ea497a311a09ca552123283ae8e7ad4179cd96f42a51ef1062a823ad46a68f271542ffd928d8a67ad8136f20b21cb6ea17dab285ad440cd7ad5af4b6e68577d29a2ac01baa98f599cb11dd103c245eca5c2561b1f6556be84a6468813b487bb08fd8b06778bc9a37f4ff6d3c9809f49058ea2c9673d8fa4151475c641f98211d6035f85a810a89ef1109a165d0529179bf9c787950ce3c3f680294e11272d9d97477542953bd25c64afd82e830b42b5cb8b71b75c1691cdac60715ff3d777d742e2154513a566e00e2a8d4972532247e3f8c965f87c7915fcc6594b4e643bca4177347314d3300fc8ec159207e67656e87e00d2593f8d338f1fabf7eed5006d0138d1992075703a0cd398b0c61eec0987b6a074a2efe6b7285ddd141ba87e42a2361f4f5273797cf28bd03055074cc61b965df7a11a775860b850d48a1cd629ed2ae2bd03fbe1be7d171909c16da1cc6e25ce7fdbf622cf86acc40d71b380a6a2713050bf3765ee101be82c12498888a5857fb0bfab4a4cc9450dc3cdeaa2a9a1b4841da2b3ed067065d7032acb685c223696440c75f2a8e6f78b6cd76b9c56e97838186a86b7b44529ae41061f6ab45e9cc5f2533d200dd3773744ad86b95482344a05ca44ad16ce2894c714d7ed5691037a65ce0f1430c9dbc2e1fd95d58ae9855993e51861cf1b293b29bea10a8131c6a815e9fb94589b15a603f93d54f1e89e758e9292b721020980730b043a4f956b29f161eec88c3eba8de17144c09921c0a9ee8e0f56d19cb84e0b594ac59a5aa7407ac806dfa74ef4f92ee41a4a7c0e4c307e698f282b95cf687f51dae40dc6a068a137ad8d234d504bbea98148147639dd6fb33a0debd6a14895710b08403a83ad3905b4b3198a91736656e7e065adf1cb2a6b1a276529fa77534aad16c98e5add064f670f4c4fa4f38976b56b82fa88a98302d67dac84736a5acc8f33db74bb6c16cad20c0b58937bd40639acb647c8007ee613a9b571c82c0cf2d28421e9f0c9d754d4414a8753ad3a4c2eba07f27f632ffde22e488f955b51a23f011bd6c2998c299328a3b079a797917e0c2e6678c24aed22c5454a6473e7e3f05e718cd574beeaded9f79ae46a09842331598878a92fb838cd4412e57b6a0e022c528c2aa2ca77cec23c9aed0f6b906e012f1fab1b889d5e2b2e7701cb19b0faf711aa294277106c9bed35bcbb2530a65852da525e04a58b2d7bbe2d23032bf3fb10138b7f565e96abd6c37638d6102512d792c7616733c2a6e885482440f459c4c2e16b8585fcbdf899e8331c18cf058208b9a71cf4772d6b5d49b800c5db051f29e65605b9dce4df8862aefde920a3c797e9a9af9dfdd2b8d6c472f7e56be5a112844f453c2e25fcc7b82cb2fff3470ad605dd476af78ebabd615ca31444e824f018fd13d0f57d0d672323a474b56511710916e05bb1f11593d0f7043957e4c56c33ad5727d80b778f5913555963122d655079be148e67a03f6be77e88c07b3149fe8db5afc79be938ca447b761e38a147706637462f12e76279070cb5daf79c2622791e40c9a6b0b9d96ded6efd6f6a8e7a99309c0d9609968bc0732934ef28693a9c15833a14e16340d73f18d1b8809c0d16dce318141b056c4b01e5aa5c4fe74fb5744addf6fc45fdbed89550e5e7ac45e630d48eda22e82139eeb256d1ab570f7030b2b211da29508c065bdfe6a587ec21557adf85ef1f9c4f92c9e1edf579c3ae1428deff1dfbaa025f9e3970bbdc9d5dfb718299c286f77f18d6afd9e6bb045fc3ac6b324039be5f4a0a503932d95e2ee2cebf506dccdaca221280505a51c6cb4957f4bbf9ba995a60c0db368edfe8af1f63847f5dfa594c350f0b2addf122fca2f78355336b7e379e038d99088c38e207e6ee2d2810a8622c9c1a14295081eb568bdd8b322ce5ccc3f45e06ba965af8fe8d01d65f02c6fdf69f07e15560a511ae1f1579d7510d93d8dc9672d5f138aa0de7b149446e248f189f99aa0a6313916b43e3993ce213dc5a3c357834e4523285c65bbbd5308c05cfcc0bb53f4e7f1807bed2b46419228c145d305bb7b676e7c3f2c36f4f9b2fdd1069e13acb7e976fad571ae44c7beecbec231a083c7e952e2b54465695d4df9e7a9c9a331de610fe1cc806fdc1306576153e85108de437c6562dca03d151a12d1cca3ad1c90b9be7640d16279d915093293c0478ad6bb59adfc459b9e0252665164f452eba76679eb2aab547c160dc42073a448a575780d82b6827c856f02980f58306bb905969408c416fcda62a59480afeb855cb439edd44bf003292f4ebd741cbd882e05a268b5892e1f77e6769e3cc0e7ec67ea8fa026fe577a94868ffd265edce62539e629cb739dd110665a7e4c5a04bb8bf40a5718690a3da95612210789958d128c52bbbf1cea2078a69c9127f0a3b93ecfc2aa94f40f9805c8735916e701a40a0bed346bc54cd7cc0c2cd4ce5bd1807daecbeaea8f9d6af6d1c79560c0a9d92898d4e54b1f3dfbce045c8a62a648ad5214029d8fa8e05e823d9f5620de4b148cb4a69d9d1cb149d923eac8b9c2ff1d3965241ef23786298aff1cd42dc797fe17bbba73230f428beeee265a017d26d567dae8c1acbe66337653ae9e357029dad1522a3fa579df57b35b109945017f98f9b1e2f6fb7bd5d6583f53ea4a1a384120696b82a21dba820aec08c961630ef3bcd9296ab898770eac1df5b14587c851dbabb33056c4d51423b3352b98b1d79db7b010c2ec7284a72ae811ab603f14617b389c0c1ed0f42d2b9d5f7e3b2386025d1680795fff454663f0b6e229f113b52251254c481709d1743025c2ee00e0f604434a5bcfaec054ddde99609a83537539f72f462d668ad809514b805ad96109f7108c006a400666f6efa293b98f56048a776496cb9eef26b7b789320d87c2c9c813dd0c164a80dbb15dc777cda250658ce3a0de646c59993e5b5c6282b739e5ffe76fbbc54b1b55e28264ba9c44e1bdb72b57980a1906c9ae1d5dd0eecfd58677b61208e5c83330fd5427a1e012ffbeee68ba1c2640020c1dfaec9f3ecd641818c5879f64c33e7586867b77e1b2bf139c4b4e1183fcb27951866938a2d28d3a1605b9c5d33fd0c2981cc449193bef2eabcd3224a67f3d5823d51e794c8284e4fe4df388623f557ed5f5e270230e55403cd173fb1ba2ee2b46ada6a8425b30153accb60cf2e52117a3bc6a6bd160a2c9621fe3621b24a222c442ab1c28fb7b7fdab79fb8309550b03ab5fd2e3451a00c79a3aa4f1123e50ac4960d3434c1ae8fe020e50b49a6f04142b07ddc74bf3590fe070bb6a8f0616ce763c6c496f60b7768ce1b9f06e468798d2d3c9d1b801a2eb96a429df6702a459abcca89f9fc754fe8ed644f47124b87859e12b91ba3298a00b9ecaf2be93b2c4a0b56921bd6d2b954a2a37af064bdba0903bcc1d3a5014d59b9a4312a2073bd43dc42d46605ad2d5d702f9b57a47a80128e341c51ad264ba86138fde02f7213a0b9dfdbfa344238df584a3b5e75e22e805196617de9fa5b8142f1bd365b33fbf8df4d6f1f7d609a30f28622bbd6a6df939858121a300b2ac1e1e3b61bbb3e7fcad038f0d3bcde4689426afeaf6e0c8306779e816dbf930642e237546e23fe5add79416bc7ea2ed848ea2a7742499fdcd6f0ee063a003da8220ee151e56683a67521e9f30346d57da61f5c650e6890512214904e7e62b37b003ee23dfe70eec3a54e24eda3c4615ab27d80a7a892ee9e37da185bd4e1facb2ba41a07eb9ddc59b90316112fc26f3b6fc8c22c4c4741157457291c23c2ad859ad81afc6cc959ae8c4a5a00fc2a32e5a436dcda12293d943bf726dfe8249dd6c0e9a103e0f23aaf524cb81cf89f2564c3ba52c39532c03e2c41ccaa7a47140e0344d1c6750aa5a4adc7460c2a09f23d21c298ce92aeadb8765414895e6e0c85955dc9c33d4954d8ce7e856946504c3438d6116112421cd01e8b23577c4517ec66d475920ff5bfbe8c419168e611d97bfc9dbf1ce29a5d1cc8fa80fdb8073199239a45f3721f0cfb9d74c71ea6f4fd3a37b40dae7272e613c78823e64be567c47b4c91106e886225ff26c44d70aa2d24802e1f98fa4f50f03df74289d554295fc74c1cbf29182654da6f5e1641f662c351d3de297d4ba8e4e2adfbc824674d2345a3b41d9acb6aa4220c0d9c70a3187c8338ca7742149f51104b26f9b3b7064f2051b6b027f7d26be953367abaad97b297e4ca790c17ba3cdfbb06741790436268da49cb5b8bdd56688f37aa746d58f348286a9f3b30e6dc50a3fe2ec4f962d3130156bd4761a11dad215d9222a1121e71afc958d9d790d13a3eef315cb8ea7a63d69baee79864a6b822dd5b8b7f69bfb6aeaea1e8ede313dbfb54e71180e2a6867fa95877a585838f618e63a6c95ddd7e6cc5b64412716293a815e54f27f20827fc7e9c7eb458e67146ac7a1d71a42a4cc89925ef7feb66221d1e5ff1a38267cae634f7d2bfea1cb0d51cdf1f16697ee20800f64ab9f50d33b45c2a4c59ad24b5929bef5287f23d412e136fb0dcfc86530bc57f055450b1c8ea3bcd8d199028e80d14c3a40e867313b71c26648fc27ebad7cf4edd680635d4a7e446b521ab3c463872c2fe81a7f194bc87a33dac1544421ca7bc95674b63221367bfc43bd750abbd58c490f65788d59a2f2f53ce97ebab6288a7eada1ad2de64d01c295ecbe39b67c0b18ed8b2afc9ff42cda4a1527cf507f42f9a1988e36779124eb99682d8deb75820005479c2ef6d8892216398697382614d6834593ee9a5ac54f25a045b3f96b857502da2bb1b161ae9e1d764c5236cac8700bfc4573dde318c93b5861664dab2afe0e5578a8847d78644f627571406474be3da34cf253244663160c9abdc079e10419d3b72713c428259b91593d1ead7e4fe8dea32f0c859f5f8c77ec332136888ad5344c61540f951e9deabf40761addd78f9435e480cf180f31e73236f7e10dc00068f0cb062bd05ce12ccdf8f5f249f750092514598fff885ee9b743a8bdb819ab933b2409cd2d3bee18bfac17d545773a8bf9cd255ffea25d9fd0fdcfbf0ffc3b3dcbddba49ec334e6e9bfa6f4b8168e4e9459b76f9246674c52a11b1872e3ebba180f2bc11842692326b878ecac21f5083c6351ac18a3a746e24e707891d3dc950ab5df4789b7395272d9a26651b7b0b181771561778ef74b32e0118a7a1c940d02c91f103e715827069497df14ffa5b7cdd31696769a287b5a5ee210000bafab7281e01246d82216bb5971967a5be2c7f3b25d1d7f26d890160b260346ec887c8e01df3dc4dc7d8c817d60f8dbe898fd06ad759c1552c98c3a38c82d82486c6cd34dcbc0fbd4e4eb0216f58430dfa40c15f0eb32f0280b8ee4cd0c49fdf24e6dcb3458059097a81fd5852ea4d2dea8d610e9fac0ba1808e168b4a03de4bf9035acba1b16702c174211389cfe53ed04921109d3424ca589c2fcffd2c17778d899c4f1b59c4082186687215d4caf2997d1dc3e97f40e9f31cee5d1fc65db176347b83c5c68d0a75fbdcd571b87f183e6534ebfe1d26acf6e894f7b0bf1b6cee6731f40a68391b158c3aee7de8e7502c141a5e645c9f9f1dcb2d099b467c3d8b12f269cdd3820f28327d4c27791ef4fb4fbe2bf9bca294282a7a64915e7ab82e7e67194b100cd29db6e250391ec0216c81447a2826fe4a7d31b5a54b3073958c2f3bce182347dfdd7137b0c28e180e0b8b68242d2f86efab5e6137a55625edbf2696a1029c03b4f5794ae55dd2342805d3832ff061d87d9e6fc8111a9b3a0eb5df93cf56c3a6912a554c347b5a065a51a1f244f5eefef4c88b792d04589487d6576b537365f0b88f4f157ae5a48ca662214961f6bb37b44483d0e4f6b9b591ab88959f4fa35eaac0e940b51c86281fcd61fddf4cf9637a846f5291293df4370acbfe088242f7392d5ae005219e2258b02b1037da8f69bb54c02c03b328d5f120a4ac8842ec4e29bfc5881cd5845115b36d48814656bc6fd63eb7a16da936b0dbcdb8307581b085924521035c677a744455fad0fc6765e8deed7148c0d25fe17f7ee0c43bf9adc4800d5b4abfb8fad464aa3b77619841afadc692d6482a23bbc4e8b07730d665ee55ee3ae03681ae34ce43d8e4c5f6012e94fb09e36cf08d3eab388fdd72cbae9683973f57c0999768823bf4e5e4f6fafae04781667b82ab127a722871c7f5713d41bb0f2b99a48e288be1982f8ebf9ab87fd56af4719440788abd57137d9a20b1dfa6f895bc2671b7d5fd701e7b37b798e1f1f95c7b1f2c7270696de0ed13bde15ec93745a33b5fab886224eb40f4e0ecd9f1b4b8aad918fbbf23a90c8f396ab4dd3ff7cd6067f49edb677a5c525c9e80694b4e59eb29bb2f8fea621f482c292a0c32750ebdaf479899a82c8a5fdc562f9d84148e33ad5a76a5deafc70a625c8523fb9f837782f4b863f65562457ae18ca073535952f26a2ec9ae04e1dcbe642629dac26f5a89450fa56bdeebac6ffaa0a4e8f89b2fb1bc56a6c48a5d63380e800aa91269a6e5792409a87e2dfaaf85e20f328bf940ff0b883cc7f5613e3adae4e5af015a63efab7a996cd736268c196c54482f90a9671c46b2efcf43eba16e54aa73099c4cbf15c4b9cd36d62c6f9a47cd70909077447ef457d77477e8e5ca70d075f95b0a9258ab47719c807d8dc4368b761fac22b1542bc41dd9ccae320a62afe17291f4637801d711f9236d4e745ad9603e8d39ff589d8b40d0cdb5c849c9b402f7aa26e169683dd0e963b1661f6f408e2706c17e77b807bf6dd32a71c549e15f3f97f98d1020356eaa17a8bc6b4d38b3f2888f69e30096b76ba8066f394ecad5c02b63ef0868634056a9b21cab0be336f3b7c5e070ba7853cb3638dc77e09153547f9e98e1c270b26cbcdf274c9b2de34a95d048b9d56ba6b48d4a1315c18c211b006d6fdd074a03d526b86c43a3bb6ce38858d0888505e7c5bdba5af8a7dc6b52b24c0885615a5ce53e099a92582351a9c6c836f3826b48ff726eb87e61f7c1bbd12812471d1ab8836cbd3762dbfc4beb0b47be5296fb2d8c42a14d025c97af9f970de85f3128b74dd2f158e8832f417d0c093ad841c5e7eae7599b6f743cf96f503bc3620d3aa04575db8c40d7399b008277c292425f6d9aa8c229aedf7babef79d9235fa034036bb5e4aa46a478874ab5e456a6ccae327dbf3f1fd71e63e755807b91ac36e82a7eaf35e99af8aff71028eab19b84ae2b0da06a80c40ac96446c76af62e22c49d7b16e12f798c998a69ac11fd73bc16d7dd5edd9816edd89975a2e789aa90ddbe839ef60fef816eddda980adc522bc0d629d73498b55857e33fc166dc37205e0e9cd8fbd2892fe23d4155fd4ed007ba6cd5d150b8dc99c1aadc7948884c1c5cba1ae383c9729f7dff403ff9b1b2b6b9750acf24d2a13f74d3411949138469c9d9a9bd1d5ac88a587b94f23df998e76ab9544780fe26abcda8afc7e8b197196a7e397c7972e96f62b93629d7ff6baa4383e89942143b882fd62c102c8925008c46b6122356fe0f58810c747e285314f30bdacf4a0d2255ce650d159a11d978563c3c2eec1ddc2e2c215786ed8627fd0fca258683a0d11df3d6e49dc7957d9d091ec460a06a77097ea1811c409de0c0b2a65dd7baa3b509abd210b72da271ce0d2633eb98dcca290cb4d8716851f360e674ae17549ee70c6ee8e075eabdabf380e4d753785c07a072a945b89fb23bd2a1027bf7e2f72f86e4e7c31f1dc5c0422cca7c5b964871e4489f3bdf8ee5c1e16cb19ce706b7882cd380ada33949ea4d40a3c9e3f3098b83d4c2976333de29820a1504347d636d442ec175291e6722420a50dde6eb4afa0b8a457e6f0134ea5fadde55dcfb6c0e99dfd4a75ee10e1a60c300b77d93e296a3a74f6ef6dc34cf727a28565976547fb60c4534235d697ab2d236d616d6ddf23058361def5bb3a04db66bebbb478eff659cc0f6dcd91cf1bd54b633b5c3d3c19cb356c5907237401e6a37a7fdf758d4ad06a526ed692d2ce0ed4fdc27e39211bd698fb2f93b1bc51ccad6b7074cf5e51bc37f8497d6e4792dc30dc66ab81f156d4de654ce182de7f690b9b69b9d436e15c3631517940e2f1e290be65d5a8b47718d059e886046b04da15ad1fcd5e16e50be595c6022361de6efb5f96689a3eacb42ae68943f9e8a9b2e1767fc73ea396b0bf0265965614eb86c46dfee227b6aae267b030b4fc7a5d346fec9c6022381b497b249550da477bf579b10c5c043ce7da599c46fe69acd1db14b3e198d4967493b650bbe00558a45971fed5ae4f62a58a5ad293090ad31e7d6bc25fb4886b22c719357cd51ca0c611c78dba560d3a95262f68ae04b3e362c383de18fc65fde27a855df5bff847bc7cb7509b010f4d5a0d386079556851fb0cdcd035edb3ac515f6f0a9542089bf6fef76dec971c36bb993c6429bc595a1142c2f05847a6b77b0a662caad60c5ef06ad4c4e54a49d38c66bb9dbd502c4b555fb25ac8856a3441c69f5f7b417aba99da478f6663c6cfc12ee0751ddc2fa9d829655f0236b19fd1310182027070e07e63b79c0c333e7fb3d20e7c4dc573fb4439670530ad0aaa4c0c53f7cc016616fc2c790b094c67c0108c174b927294dba910064b1ab36b0f01366345acf0eaa649e752535b5159060bd31df7806fc9670d324ca6e62f149387204c16fcfd7029c26e01ddcc918cde1c2712e2656cfdce4fa91349007c18763e2e59f63fe8d78cd03ebe00a66bcbd9f69b93a9382a7c6b596e6ca7a22308a0a3d122a336060f6e0bbb269bcb9804a86dd1d0dc99b8a517e7b0e7e068680b8a2ecf504e692efe72f858d2b0018899cf2d3ef599dbe84abada89a8a031ae6593be2a452b7433ae0393346b330ab3a3b3562cf8cb3ab2b450d15e11683072aedbb66e6f112e076354b1c9c43075300b6c8f59cb1442abf99765776917503870170c4f1158acd53aea2f166e8547beb678bbd10899f8c77dd47c7f7689ee6fd78abf88e6fd3aa9372974913be679cacdd5529dd2b1e0632b2060138acb30144eb015c78d09254c56c9df0caa507b5f5933dcb912efc8e195abaefdd3651a47e4d44ee9232f392e252fae00472dc325d3aa149cc95819d63a081531319e9a1f7ab639fdcd1fd42b46bd57527eee14929ec7b0f67a3907af7022ca1f622cc369daaa1d2ae515047b91a8483ddf1905a29729db3caac19f22c391c5d8c91443c637869caecc4ad3123060e0b9b61d2a21c0c5d17662056034537f70a8e26bd21e432661243c104c408d02ef74f68fe4907b705f8e4049baf268f5eafd6b1d0eff0063ea0216a4be539b19f459da33a4161e274825616d135fd46c37beb69575673bf3490b07db56823607e443541e74adec1838b065c5b0a2714330f8768b005d12bffe8258f8919ac7df246427219c7d6bf9f2ae88049623d1d3e54c2617f62370110b081feb56d38cb2cac117ac12165a196b2103a81daef23c042e76a641d204e0b1cc2a1872773da7cab56c1a2f8702a40f582850c3f409beada107473f2100072164813273bd066a641b440be97b43ae99ce678df905f1e880bc77ae6f961b7b03ab0da6f1fa51c74280a4adfa539a64e185e3b499f49e9469621fb1533c024e4470a81ef301a854c65a7dd68112c8fac7363d13261d0a5bde8901d50e83078e5a59d2bb68c3260e54f379ef7763d32dffffd30d8b3e3bfe913151abf45eb31fa55480b0d088c50fd038896cbf8cead5984b5ec15feb1a959c187b2365d0a23ec21d563f11b01514fc4b159adac4533eaa09bf46548541ddd2c8ee2196460f7da6ea76f30265a6100d42c1c274fe03a037aef146c7aa5f7435f1e73974df797c5c16cfc3a2b2f43fa8c48d5deddace0f8f65e95b2b4d3fe377ed3b4f9bac06dbdf6a146badf438aed189b1f050556268c537f93ec4681e423270722ded29d68c5ca8bf99213ae07c45f15603ad43a9e58596f32c213d1753335a413b9c9c3537494fad95e33cd1f82c943b9301194f20bc7cc65bec2ab9f5711373237eeff52496000d77b4d30b8d4cd2e79057450e24d71c634c116d706943eb43062db0d5643272fe25e99bdc0df0e21349f8579441acbf9d79caadf19d505d7091f0baee39cec0355a320f4fe4b96f348e2af906dc645e159b297a5ca4a6e942ccbc5644093ab4f356174fd7715975a441062069737b29976763f754232f0c87f403470f9a78934b0c5a5e5abf256cb2e285e9a2c80949b9d1e8c0f939f9955b31fe78f5542747a3765d2716bdcc4d7812174ced656dcc45a42dff497d3b36502cf20cc5a34144faa53ab504104569704ae8dacee27d14160c94d855d6701f86378ceea09db2b8539305d6cab13ec6c43fa75b4950a012a1175ad75c22a3ff19c5097dd9356f5463d628c0a452ef618237f5c589f50606507d7d9f34a7fe6703f7e54bdc291e379301eea7fc22e6b841cbb0263d25c78773215b943ce4fd50bf9ee5da372f5e2e8683480a40c55c7e485de6529cb56c59900a43fc5a963dc9b7ea9bdcf21b54376ad40c2d5294ff14cf084f5224c4f5dfe9bff2b9f5dcb42424e8c9be064f734c35fd56222fa431c0f6b21dd462fa051be374c35693d41f87271a8b3ba0b7bf6ed0bc446873ea6c32a21a1bc7315cc5f96f0ec0282a6ac1cdd16a0c323d5b52e8db7ac6259c43ff98b0e3568dcd2dae0d806be960d14ca02f75733c960167a103ac8d9bbf87f449db7a4d7dc02909703a8110ea731ec94c0dab99c5f4690d9a70b1b80147f9bf280946dc2f6e385ff859033e00964403357af048d1291df049425babaeca6dea7f2df6528ae115d37db2b1b87def78540b50766a4916a898d06398d521c50afafc284aad2b93c21e883627c10e40481f6fe5099c50784ccda6f479c295fe1cc38fbea87b25cd84ef6e0e2d0baa1435e11f016dd2079d1d55730faad92ed49cd0c7d376e621cfb630f58f29abaf3bb15d9b4d781faf902a9cc587858880ff066127cadfbe06291d6a7d32b61d69302e22f9e1dd1f2267a328b3e28eae9e1bc7c29cc5056ec7e8278c96897144a3065303bb37ecfc66bc360c436fe951c2d5306232d9c6c430a32e09d5872b5b8a84048d5c597aa08ee695533021e164c5e81b6d927fd446041226d1a7b0127661281ae24314706a966052eb7818e8c1d5e204f6c555f94e09a39f8c56b980d738ef940bf729be9eef02ecf86322aa347f21d663b8b549ed8ceddffe416641b1d1872e2788c7e078d367c96b30bbb9ee164893954546b5dd081914b06a422aa96f899ec07b5c68b493a2c5b98e46c30e73b2a3f023b7848c61699185b358595ab03b0eae9536f7c2944249b29b589c29582c9f63de2312eb84f8e0ee050daa61bafb13c87aca326eb9b825de72d36c9549add854399dbc8db7aa53676792677ea0eb240725e8959cbd9c0edf0300582c8efc8c45127677226b22888de154c7e4ee5162294dfca5f168c64d2892895214913659e827b0af4d9422af86b5760f2cc77bc445a3b1d3afa7e4c8a9f4cf0fcca9e4b7bbf5c0540732b7959ca83ea8c72e063e38d0de72de5b69b782b18876472384a697a151a7af09e7b33ef25f39e3fe8b396f81e608a848e2ac0ad09cd31ecf07af3eaa364aa5378d005bd1588b1855a7e9c007d47044b191f933f17d00f7d87c56d1c1f8b12c2d640f0e138234e4e40ec141d20175a314c35142ff349ba68ff6e340ed098703bf9224815d967f39e89e26e000e9ccb7422107ceb300751f058d150b6504a35a91a32b1a9c37642eb8073de02c49de0f119fec9649a70d62053f5bd03288227c8211a53fb251c9fe531ffa1a7f81f8c1de285a72362f3be66f3c186c78e813737d29146175ebe8ad14910fe5b30857990f08882e9099c7ef67718176a554e5a286390055717ab86e96ffe4ac45a91b1fd35d67aaefca5f325d18e444316a0df0757bf10a7cfe58c8cdd8bbdda04afa9034b5f3460f6f04d9e02bc94c3f8803e6386381f564cd0f3160bb3b8321e81212184fe135d8d2fc8f1891c268afdb504d455a26959aa273f7f141b98ed8500396bd4fc9ee4b20dfeb5d4e6bae179600776512c5ab832f02db96236f75d89d2df2c515d512cc27e3b7f859ee1b6d64872edcb288659cb08235fb36d94645057dda699c38b3ee995cd1ad06918ee14ba962e7dbb2df6d3ae781a086ae4a8b16ca5077e9682fe2750434d6d73a483f8311c2ef00cf4e7c11390550e02c2855057c9dc83ba26f25b3bdf99f63ecdf82208365d633fbf663e7f37acc16ba51cc17a449fecf11c9de640c607cc0fa44e479459a6cb9c6272f02349e69efcd02930c85b7347827a3b5439222a5be3d6dd25c44c30a16a8b17c1642d1e2274c3dee96725cb620848e0eea0b94cdd8449d4655ee25398a5207d37f604f35f61669dc74a6156e21728b4c62102a904eee4a7666fb9185585b9fd4f63eb907e4efcaa3dade81a4616167b9f9fa7f8810f342b1971382f1d44edb30379642f29c13506943b2742da4fb8acdc03f8b2395291fc6b483e655263fb2e63136f7a6d2948bc9677d146fc84b121d09ce65889a813e3ccd11667eda2c1800eca756b2288a521fabba913cb3ca1994dd304f0c6ab44e7a17b565ea2aa870bc3c8ae52ca7d6ad9a02fa18917a45b4f3bc14755ea80eb6ef08507f441ddf42cc3deff6764af8b2358519bf0ebb5c6f5bcb45b1095f0420cae9e8161563ede6ed330160600811318b9e05d9743ad11715bf7b194bcce79fb38357556f1668a22a76d5deb47fc9910f79014eee02f891a94829fafd711a00ba049f04704df904c0f80e738df8595cf7a014c794987827a071859a05ec208e2b55a1bbef9ad4ecb821d6da15a0977876a03c0f75347cbf02e21647d5b485b8e1af065ca4503a1b75be76e04cd13b1a81988bd6db32a9a6e7f4c9c01a95ab2d3371020bac8d96efc3e12b847a004b7a65e4d3758bb090bec23eb13045c5e7b917e970bc226516c3684c8628ef6c9832e6bc34e7f470eefa8a9d526096ba27db67c0e04776acc405013a2d02a344248f5378c4369bf8fb365d0484beeb0dea87d69130f8569e780fb9dddc7f24b8ce513ce915a068be02b62871e27b112d4d1f61afbea8e7b8a26d0e02188b451e6a89d49298e911d41af9edd24581a7aeb39fd5de64a6c4d3acefc3ef8a98d2698ae3fe216fb1d9e946286a68721cce291b5a52ee21b8b55e891bc0c5f79fdd82f24e41cc6b6eedb885200121bd8d988196a7bf09dcff35969f9e255d3f69329ab9b81f26adc1eff68340116d1fc1346acff58d182ec347c3d978c31c350c2794d9378f8afc7c1d00fe4af4336d2a1d036aa161ca2658592ef6f9bac95905c7f189d9758d87a649c276e4c1884b51f1d1ca0d7c3e4a10dab8a967ff89c6ec3aa5da1abefd4d5d5f117c0851890ecd6d5482d3371a83fa45c442c50ba981e6e46fe98e5d8205bcfbb4fda4a54ab9efc0231bedc74ae108f1fe6809905d8013f19fc03f94069af408ec665582aab18c88e3681a6e17389dec5abdd1b6889ee3249fb310f4c7dbd4c17048b4d9cde843245457685213d1f5b763b654a3c360fb0a9b8ccd6c7560e18a20048bff972191e43fe1f0cea2d40f823ab3beb72530a842f151a7c928de9b8ed220cfd25ca075b80d1e6103553e5a48d878e641a09117e579ae5c878345829093b31477fa93135f4a5d1fb0a745bfa804f4183839c0a2968a25ed9d49dd6a91de8e725aefea47a3655221150a1378a605f02328b3427a103dc7af51dff58d099d8425590f0ab543dbb56e23f674dff268f777964126d107b2e26b72c8fe465f29f060ca3fee54f6b1ccadaf7205d9aeb4d5c1798731ec0e59b2b4e321dd92b5725fcdde81f2c11d2f30256545792819ad3c693d73e8cfab52297eb69f29bfa1baa9d6309a6816b4a72a236b458eb3a6b3d1f6fd43b303eb2c6d4d3a249abaeed969fe54598d984abacce1812b87a4f843a628ffdaf942758f9104f56e42183b0e53f1ad67a641f2820b479e2b9caa8d0de56fb0b5a7f8f34a64ea0d8131cf23f18cfdabca1db64357f33047f23a1df0c05436bc0b0ac801f3b20a4cc3acacbee323d8b51e71637b279b4059950c2ef2f4ed5c210e89a8f3ebe1067e92e86ca27d757274af2ba26e454f511d7f0c2222914b29eb494102e2980c661e342fa2ab5ab17e408ffbf03028b78a4fa37e0622d5316ca8358763629e8a867e436b4b498acfe0355d7c6cacfbd15bf9032d5d80dc11da5ca4fcd1e3aa5cf58d7efec1957558ed3fc129eb0d98d96cedac20a6eccdb2e7cec5f247ed4ba56efff955e2132469ffa3c594783799b03dae8f80482f0f6359f8b0282903e3d8881017b924bbbb13a821f896fad1bf3b3f5ecbd40c25276a68e4a6f5184466318d91c733f9cfe27caa5ddd382258f1727132fced8bdf5655e91ddab13ccaad094ff59c5cf3288e363debdcf2c67f0ae62b9cba0f9ba50410d74bbebcd18317079c03f7d424bb6fe6dbd07e8658e18143d1673c3f2b86144c00dfd8d271bacf464816898ea70bbd6771e1370d04e245e1e12241f2e81a272e0c45132314d707922ca9ad80f230cce8c01efee705026a5f01987211dc503dcba8229f9ecc55c16c5008b3a16a43d81e0a6810a45dd862897d9d1e32f02ae3bbad100676be6e4f2c3565a42fb2b017073a56f0a534e5130f211cd1cc7fbf45db70d84d4a3cf7a337232148fb79ae3ff65c0bd5a3d62ceb59744059a29b18984b0a48942bb553d939ec9cebee7a5c3d43b48b3093603f88fc7b29a182087dab3d87cf6efd131d9c2c08eefac721e2426f977be021fd102568c0d36b2b8d77dcc611d0c529b07ceefdc7937017e80c20c90202de5e4bef4025078836a074d99e0e8497a35fdbe50b23db5adaa768e4be3d3b95a64e0258b3e671ef88f8cc6fa875ca9d061df33bd5cd8b87be63d99e5bcf8b9da73e94ee23f3b0b067fa8ab9e61a984652a3e7dfb35a75f1a4f9eaedfb7b31cd9f34c2643d7a12bb8d1b093fdead262744e905050da77ada1cd3bb245c269d7946ac9c7e83d89c528ba7666869b6980e5a94f298b1788d5fbf4c7ebd1acb9ff5032e558c2f1d8346cf20b587510c0fc27ecd0daec6e9563c6de22a3831dbc90418ceef1902d9dcd6f730dde0478a781a71a2556d0f60c647ebb7929421c52c070eef1ed9b2a84432cad46427d979e44fe904fa4d2f22a8a35a6844a37fffbd518a96069126ef5e40e82ce4d1fb1a04b4912cf73232a16874d3e2c1821d79645d38563146b2d419c355df0c70e878c2f5f11be74a7e19fc9848f67483afe6a6e42caa3b9a4d8101333495f4e456dd9e3eb6a59e099c10d9c9b8739c89196be0840744a0eb84ff99e90cae98ff786e236c1f51dfb1a3ba73269a0bedfe44dead98f4da06f7e218745542834fee6075831db2f8802a924d388b2663a59537f6bd94672beb813de24aeb37454c3fade138441afcc80b92bab57bc5cb64a1f1b01d9d767db8a8af8cc3a2960f3659beef1e04306ae5e5bddd5c383f00dc32c484a87e8f534b5acd4d87daa3a4b2fc9593338f5ca29653513c4ccc9d73d4816e73799de17652b75418a6a857ccb4e985fa4043f8f956f99c01c12420c5370be50ed07443afe5df0610a5dd382e1c44352f37208303cbb080a8fd087ed483e388a93742cfa30c30da761f6a12c46e40f5d6d62d5f4d970e0b957d58b640c6dd4a0e7259e163deb1be6b05e8a0c330415467e4979088c26171b98dec95b744de3ebf49c7969ae18c7d4b3466e60b8e60f417783217e9dd6758c68daf3d58e7bfa92d9794710eb5c7898a0c8f17f9f9ab5356e1be3886ff4c2305040dddd6f7d4b7ee4357f7391f63b9be9751077fab116ba19ef9333be57ea63a6355c03521e5f23ee575c9938dd457df2d9fd468029ffbc49206507f30e8cb33b212bc54a48e15e0adc22fcc50c03a553104691bcaaacc6b0b36c6145b9fb0751aa6f4575031e38df7adf07ed41731d51bc0f538d759334b0a2faa79069fd238c8e607f21d57fa58f74b946925cd4f54a4ca51d6871c945dfc3246313ee2b2eee58d9c1587ec1b934ac8255d3b775536a72f8e0343663038b1a2821184eac0ffb9e12f8d79410aecd2dd0a063035bb36eddba7f9d653a79a36d7f96bc81e743c7eb929cced779b0b2270e748628f461ab4b08f759384567eb92a71bba977a813c772f4d2ccabdc49dee280d3c67e74a3d8e5a1069b43a41fce8aa0a472e23fd1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
