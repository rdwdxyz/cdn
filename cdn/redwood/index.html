<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"906756f6cae2f6ab3a0f2a4f2030b5a72a86c021b669a828fbe5bddc272f98bfa623b4b553989a84a2dcdc4218da42399beaf8e7379df8caacf307a38ab3176f7970ffd9cb84b5b3c2bd0664fc5959d2a68f323e9d9708485ad78a4c2fc7a07b74720cc1ad91d2ebd97783fa28ce3170aa3917b421c6a70a8b84e8d25812f150cb0494a1f4a604a2ec53022ac030b2d40411c5ed2243e1489895089911575c32a936a39de128dad57d5419ca09e514c868af6018ac61a352ed7e8ae056e1540649a49a40677086f4c2dc2618c0bce8f426f1e5528d2658626e90cd4315342190a2ce3375e05936ccb9c95133c4a5daf90f5854f47d7d80b892aa4b296a963eb000eabfb0816fbbfbfa7481ab4f3a50748cc98f49f709fa847c7fdfc090998797aa6ce3837d8153789b8e8605bfc58be995307a3958a6dd755741c1e010c5b6dbf34fa9b69d3966bd22656fe4c68215f8cc2a3eafe396fcff1e60cf93cae143de4dd4541b22d7de5d3a1da735838f66446e9f98923f31c41d9781b314e2b6244a43b7872a98d3f41a27b56bb4920457fd0bb9860a65b39f5615b5e1352a90be5365180b6d71acd2a637cb6abe20de216b1774538ce8be0fffd8ba256c8ed28d45c23ef2286c840b5ed275b009d85d3f5f08a74345f7dcd70e954777c9a03d829a173e70e64de5b4df7d6e48bd83e61bac6f30fd9656a16b0fbded89414d682a1987b0d065d119a96f0f2cdc85f57c9f66df0e63b173cfccc2ae4e26a788d59f6b03f8573e631c84db93753ddec547a3a95f99ce79a21347d58588e421fc31038911a9be7c1df38084f37f74b35344401263e8d46a129c1341a6bf32776c1ab7d0fbdbee96e62b8bb15b8f8de93f319e5efd76231441fef31f6933bfb0acaf8333afd0c2b71413119913ffca68b0b2a82e8d56400eb340249b557443452fc9d1075e6d80753ee92a8b79691ba82929f735e0ea89e5e93e56eff8bdf8608381abc25f763fad16da24f68251698756d829db7297e27c0d21431626b86458f8210973e44fea17251ed6df6648d5e63e5342c95f6752249baa28f81b9182482167e6f79e6ae08bc52e4b2e9f717be398665a040e9c0ccec9616174080fe5f3f49a527fd75c4f319b683cff81095c682af55e872f63dd55415363aa0a0d4c1432fcaf39faecfcd58237702207d09d1fa5324eae7b9aebb1fc57cca4f7053203d1b3ad8ce72087e4b1a1a72413c926df6eec953670687c1a3b4a6e7377512e7d6913dcf8e192d6114d99cf8a4de76721908fd11dac6c39db3a6961c5e857f28f8264e3401f7055e4bb79ac1627f9826f84fdc48c65c73e0ef161c1f3f35c7268c6a82590f8d37d237f838b44644db38bb79635ca9465e01ed0a55443da725b08590da34077b425ff8dca9f9c33916283b7d96c22f7de1127210945550137f5bcf551e58d1b28604950ae42be71cd2cf085626c8c28d23bab2248c0dbf02a59d32f9a5018e0d66bed25dbd621cbc26f687ce137724dfa20e0323781f54379626b4b450c8ae589402c47cd181ad60932fd8803071b8232ad191de9c5953217f929074676c28bd2059bc865bd260170997c57c7a326808e18d81931549c34edc9c5b80672046b341eecaa0838e215334f796b8f1c3c02e2ef05559189a8aa6e737484a93a6cd78cf27658bd0bfcf638b263a6347929f15ef949c8be1f1a9f5bf517403e31a060107b37a15c50d8f8ac4804aba93ba61fc457854162ecbd39fd8e4e4863b73a0c69f797db212b9ad148a8ff645f5cb8dd5f2187d469b9102e4e32a84f2733b0475e19d9cd1d32b7dd93a4f7eb390e90ca1b64483c2f22ed2ebbec0031d8a52c785d17ef601cd94637a088d315c03ed8cb89615ce572fc76812e623265048510835eaf5fb0a5f8a5e4f643f13517a6ee04e5152c91e91289bd589834cb2e0358a97cf11ab3119d71a3cc9df0968e7254dacea8a50f8cf87415da7d2ca8ffa38d9d6025fc41c569327e69f0be3a7c49ef54688d6eb61c38f37781f40a21e276e9894f984ae94ce07e92820a855fee2ef2f31d750bf4cc1fc0944ab48df5917bf09379fc590b07a4a43439bc64967aaf96fc6b80b84e3e5a150c42ad2fb7dd1e0a3e81b3f8af83fb3d857e5c4f190f98e015019b42f766868e5ff0728bbfef957efec7aaa743d4497eb12e252264d7e77ead6d3fccabaf0d591ac4f5d6fda2fb32f57c16a3ef35b2a7c7be994a5f1bea27e2049d7b6e6bf287a22acd398e2ce14a90434facb9ff056f53271c35b8a7fd4ade3403845ceef8a2410dcb49bbfca8a8efeae4dcccda54d1afe6d2ae3b72fc4879c7a7211913d31d454320aa974eda6cdaeb44c07c7f2905e0bad8b987c644483a1f9f13511082a0deacb79edf42e3e5537189154e1149732afd720b7e3a9d80131f4692ae2065e7af8f703ee7b51b46928976dae3f74d07509f9f3cd904109906784e8f3dea0ba179e2e880ea67a15aa9e010ca2af58464826ded0402beb1c63eeb255dca5c3525b577b45d539dad7efdb9bca525c8028da21843fcf9676faa7f605febc427bd5e2809e6c4567dd4acaa86c237484de637d021288f66358f166f2909debea5873392c3ca1b9075eeff0aee18c8cd08cc1c0021f0d3e2d90ee7343e8495888acede87e1af323427d2dc47e5db6e124f10bb3dec155ff5d77d5553b1123a0f3107ba690549459c3eacd0c91218ac3f2b6f6262a3c68f71f876d9e84b3b7ee49ecce4bd6f1e4e9c7a12809969ba46e3c61dad139d97d5c3188e4d421789f02c9f82c7db8fae68d7fb742bd1d622525bffcfab668f8ff0cb439ec1f4a58b15d0fa768871568a9aff11ae86c87d8d48de73ac7fe666af54e6efde5111fc7b11845d59cde896188b59e97a0b1f941998ef162776b1a47d18e00762df6e89cac819ee2ee96311a212d807529c269f1b3fa3c1afb4b3b7b4c6198d2aacf9e20ac9b05e62fff3ee84324631735845b6b93e52001e7b10fa9c744849921b40a5222e67c69ff98d45b312b8b4ed1911fcbf0abd30d522696a26eca67c82dcd2866363e684c5f65427ba410d995227015096fcd951010a0ae1d57a60ee15ae9758065ed5c6712977aaa87debebb1639d4c24fcfcea060590073ffd9f7cbebfcdecea88d986c06abe9e27ba9b7cdab80988ac83673bb71ec8d0049eeada44e7c438196528d6ee394a8fe554dc18a8f49aeaf30e60bdeabc38932108ebf39d1e76467100136bd3964324024f6faf65213e59706d9611e10bc2dc7d8efadef69871fec7ce007755acea663a3b6693795c6a8f64b5273d6daa438100b492dffe5a36aed5f51c7815464df164dead600f739f96d5974c8fa57678fdebbfe5a4f30959d3dbd9464b97b336526d90d455f47feb82086fc35b609e5aceb6c709d33c0a07ddbf6ce76c7d5cafcaccd08ffe51fa51662d94c3515374213298a60a572eecac08d8fe32cd25c3f1d1d45b54673f83ebb5c1014322dfb697c0196c841cc4c8e63356bd35da80c25933b6b1cb0669483fdc8e253b3e9f4787c561a0ca7d38a374babbaaaf1339e28075de4b1f96661def70626dd89383c431ce420dfd7783b281fcd8c13404879b6e2981bd72ab948db70702a8941ca89105c2ac3f5319589eca43a32359f8ad1e8786e54bb35ed44d009e791af0de681516bf604c1b5e254f6e8e1fcff345a46c84b2282b587800d097a6667f02e0e25fc4220cf8a5f90cbde93b771c8e4c1bfcdf5c5697afc2ab030bbb2c95781f5c7f40dc6c81c5858f5f986f54a5a61694cf9a8689360db276a6ea035f5c9394321d84d90c38705d80fc22d69e111502b12f15d5f398f7132161b969a9e61ae409cae7c1bba10953cee19faaa760e5a7d5e82c2a2a660ada618a238ae26e1fb3346b1b61299eedae947d6c63ef21b9eb8e816a636c203708f1d9b7590ef0c5e679ac20975f07fd5238b7d0b3bbfff03c6a5c65f5ddcecfa9e7e8067e52621fef566207eb9849cd5ac992b5e23d1398283afd38c2686579e6c3950d397268bbcb9e041f3ee46a9be671756b96c22c16160d0ad658431fe6241b14b795eeb2dedb9253d979340cb4c9de7a2f1fe5889c03d6e3fb75b460ff4b1f148b463e7837fe99f653432e8b8e4e0dcead147d79ba2d9c8e5b1db9cb1bb6a3467e48bb73bfa7d1a1a8f4080a71002d4f7735964f1848e49d489c5815a5a64cb5f5daa4a1d692a23a803dd76e4d27d8a7d0d353e6b311fbb0e33106bacdb955cffe785eae3fd712ec2a2e521e36bbf0cc2634fa543dc9fc8949dce7ed86fbaa807cc554ab78767472660a5fc17afaa8e3f4cfec1c30b15be0f20183cf7ba49c6ea9664fcadf974ac79e8a031f8e1f4f6e76a1f81f7fa9ac093be92b645a2c025ea1e92876f434ccdd12d7cc8548abeb4acd788dbc1cbcd312e7f04b08d0521f02c2e9115a61f47c6d15dfee66ee5516ad222a5a3147d56af0db0a076ca05af14a057b0f1fce78c54ee0d5fc5800a3b225562392426c27d86359eee0fbf7d4d693f91a57434f35b9d0d7314bb1a89751ec17ed9732c871d1b3b6e924d96b449bbe8759f168ec071c2c41c9ddc50c263817cddb9c76e8e32ded02dab767ec39d2891b2c6a2b3939a763381562313b11ddf5b6d69b32fb29f7edb80f0de628c4e44349e5dfef113eabdebbbd0593511b5801643be76ea41219c70e5d106f71ad4b1f9aa475cda4a34cbd22d3172f756fb63082eddbbf2e15a9a9c54b8ff782569e986e4f7ded0208b80d9458fa15d25aa0463056157f98753e9c26124ee7858fb93cbce695c147b4bbd8c39584d838310cc2139a86083cfd7fc8630a75ff2ea3348ef11cd5e5a15d558da77c2f20671a3ac17ab54562c4670729a1c98e9ae7d64467d95758b4abf0afbb7b3fe1eb7037150a6b815489ceff12f79dfcb034c25ad141adedcc7c978c23a335d0cc563a48a9ad1bdf145e5e09ca4389274a322938b46ec020957c347a0c7a9b70c547b053e0ab15ce04d3f2a81713c403709589658542c9d2f664b6f16757ae708db9a7564d2edef0c291a01f720cfebfa73281d420a16604446c687d1cef1469e16f3d95861e127ccf1ce3e99a5941a1beeea452df89991ff7d9e2301a46030a0155845bc52260352862cffd5494b435f1194eb0021f28431fc3de9391d93aa667702825151fe1a1e3c9fe3338523f44dd857acb1d3cf133c6050d1d69a4252526a2c577daf923c0c09d193d1ff28bb1bb34933c68f0cc5f61436de652cbf3473578e044385ad2bdd58ef42f463cc1ae9da1da46031c05acdb01e03e2f75c5d41b4a49eecc7850a88d317ca46c323efa0a9474d232f8af91ff765f086db20758c88edd5d3c97f46103d98cba0158d46ea6d454d392b35d7f348c2d3ced61b17b44e66aa1bfa6fc182caf484adf627b74db1d84a59b71a5200257aabfc4f1c3be3dbebe7f47ef0eb718d28952f724d35bdbd56e71b091291a478b8d7b1daf542ea1c72712bbb93ec7c84eafe33a4f212c79c729d5662f3d902db326f24c4dd0502dca02cbd45c7fcac09458c2675e110c12ec4b0dcfbd7c3662e63c328175af51e7c9289572367104f33189e1a77d1c3ed8ac9dc076511b006bf324e50693a18a7f30585478e18637752557f2adc7a748d6fa16ad868812448f57d3d3b4b5126a5fca7206b18966f680bd68332cb9b8509c676b091d035e279bf442d5a4d04b25bb327488aa3a9aae51e878cd3a65077fe605dbfa1b2dd5d197c410932cb561b8af925ef5ed521f9239838fa982b60a83b43118daa81b8707db62cc2ac22e99089fd0306ef51cc5ad56d192db853bb7526a6b749d19695e247e12f224898220f6c94242d9bdacaa8fbfbe389d670a9c30e7cd376f0f10f8245a93f31dd46948aea7ad0aeba83b077368ea08b55df44a2fdce780cab7e9fbbcd696e885cebb46f4d4d3c5cf569ca63c97ce9de9bfb3084f45daeb17c26ebe34476f49eb5ca04e9093483a04c304cf007cc53654ab9617f070e64bda77c389eeca2f229eaaf9f00a48e9ad8da04dd22bb9ee73392b38fdb892020d3c2c0f8f403cbda8df618febf7c0c3aa9518b3bc8f4c4ac5d9eaaf04f2ce39523aaa62ddb17339c115029eca80c1f43c0862766be840a8c8c1b36b66e6cb945919897afe0b075b4130273f952d18716fe394e541031a3b7386cd4c20f881ff3bf42ce3bb3681fbddb05577a9a6d4be6a5546ae0f08ac945ba5ce4a7f1997d752b1a4f9b826b1df7557d41055a2a1bf4c94048eb2e7cb7a52a89def185af2fe74b154d334d912a2b07476a7f4fea2f46c2ec8e7687f2a29693989764925cb93adc31aa0ba53e9779f7983ea5c233cc3050e3bf3139ef497fb68ea22ab1a9502e7524c41ee814818feeae986bc07fe2bcdd97830f747692968e8f3a184258494d620b1b5ae66a08b442e8ae2fc93213b0b1bf5784f0ab58f575d93d279c00c59390b230e898f65eedaab202d4271663163641625aedc063e7541d2ca56d3e1ece02db5ad73d492e19f4dd6e45675d0210849e40dc422f32e4072646c55729c5c02c3cc4f768c3784b6b30080ccd3b138e21d7dae0652007a754fcacc8172a48713d8603d401a8b62e80c08da72e6caabbc57acee10bfd8fe09c35e58450a4cb6e033460bab49a0e8d297a84910e7dfe97c49df49c1ed731424a8aa18c5c31dd1bd0178e48b2e6fdcf8ea14f4c782062fe69ba4955c210f9e270395073b2a132307746a5219716999037824062ef943524ebb8b4a1c2835c29d62002924b5ba0f8b1681ee30ce63588b0dedab6ac1907ae2d92d6045fdad029e62c9f3561cff646824c773e777ab9fb101cf60c0741bcacaefb49569eb4716bd958711d66b4c28134cdf7c1b3ba634cda6834ad8850eb0ba69523bee7646ff397a843561974e6ac4949e8e8bebf1a16f95a329918fe84f9e08bb98016b052ca0b77162000b5321f9a7742dcf15589b3217605196f2bd31a4f3b255973fb0ff5587502f7b422119872a1d2e52f7455d2c9598573e5458bff8a9d932e6ba3cc85eea3b6fad2525739c046ec1c70bec7f4093692de6a983a6f8e59643562df41135b3a7b0ce6739aa3f4216eb0e608201ffcdf15b6b96221edfc5f960506cd165c585a39fa26ba332303148705ef0a6c003f1eddd50e6913318892944df86b777b6971d2ffcab40ac9b0b252736d1e53ef061ec28f7c8df2991d81a4cfbf609d4e481455c124e3766fd1a08c7fedc3a3c620ede913dde3396f181f287b49e12a090baa0b8e577b6f2e21fc132a4ba127d746a6bbbfa3c6290c21411f13cb98fe1442f6e7784b37cff7bee12ff023fd94b7ac13a73a1e745a57de09ca8c7883b495177780fce36dd43ad1431bed9de4f7b3b25e63e03a7ad4358d8171625bd659394ed54c64338c38db323a8c69bc24b56e29a97d5502e25db2eadc75e364becf6b0e3705a929c3acb5e519dd06d4f148b86c22f25fa1cec61f70af9a01c517f8b7f218e3039d5cb8c3a6302b6b82ec5bc88c75b730db4552601adffbb10806d0c18bd4c1199c9800e98357253f3fd68c929c6d4859e01e37e1656964214978bc25b5227bbda6b8becd9fe3965eed98520a10a0609968dcf9ba46e824c1552435467d4bed46fbf6260d3340db1b3d52bd508e9e3623070b71868b522b31f535827cc8ad043758a278dba13192645c9085e6bd427943af694156412efa4147d5a94b7a98681a7b277a972d77adb7c10c647a5f93d9f5c98742f07594422126b656447768ff961115a24c0eb8856d27db4a41f4d180d1960b398310b6290989658a5892c01f449b420919e3be329a16ca98e290c57fdd00ab6ff184be0580e1d4a0ee66ba6e32966ad3848f9b4f854d59b8975deb7d60b97d72bdbc246758c0201ec788e2dd3b3d6e96e8cf33cf8c31a9beecfd45eefbcf4833be094c1d0ae5ff04c0bd3862113125a5d40ee642944739abc459c01fa45c31b6b3f1fb22e45e51b9d03335f3724b8ee02735dd7dcd3bffa4a8f1c465481fa5609d0e8f6a088e78bcdfd14f3e6cbdbf24f9123d83b30e65a28b25f81a9665ff012da8f66b22160c054ad2749da29eb59986bace33903c878ef36c3d408b56a9219d0f1fddc5d6ff9d5426e25793f279027e54d4b3021f1024f56c282a226ee705549e07f2c5bddb3b5c6ba56d2152126d4e59ce30208090aa568109e3675006d69b71ae992b978cd87c2ee8382dcd938aab6b91375c28375aeec329eddc14b4565fd59d0139cadccc86c5b443aac27c2a06add8f61929a753237916fa60645f0f56d25ce88bb99072beaf232dccbf0c23a0082bedd93e9dafc8e92aafdf086b7e99e379563b7ed528968717d4bd9d59c1aab95ab81c5c744fd94e8f5a7b10602f63103e12b35253944add3f75453feb668cea124a444d262193171bd3e8061afcc210c42f261279a0d08f3fc7e98068d6089eff88b15bf4d744130ea7fedb6dd9a8303a87dffb68ec0fbcb8b4d2e0ae46a2bd5377c1ea101d8a52e0bced35e75e498a7a06a3ecee820ec3fe4aedde212ae40c84105be7d15d19bccb1d5f3d65bad5a7b508aab99cbaad57cb9e4bfd1cdc8d9e7350bed8d059123471a93e3f44778a8373ccf4b8b901f58a3e6a4e5a7c56806007aa1cd44891416670502e728fbb51beaa99e58cf145452e18000b0e91eeec4e3d402a1d415e16c124c63a70212cbffa462f16108767f16118ba0c5b29c244d8632ee6e529e5c6827949dc5a0a37c62171ea9a6b80cdded0995a39b6c30f73a15595677a43f966367c5e992a04602509c2257aa56f05fa11d506d685101e09a4531f198d2f80d59fd80a05e5b26fde8aaa5e4c545b45d1236d9bf976f2341736d4c2bcf50a8b01df6119b9313c4f5259f8216d432fd34effe7cb26a3b01eb9d1f8725dd872ecd26c68627b279981f5b833d5f1f893bb0adbc1d0bca5c95d9fbfed047e4bab0c6ffb9c284cb925058d87fca9fb5885a339ac4c46be258c9a1744e31f841ca2dc940070b068b9ff6b9b3a453570d911e1f901f409ac24559fc5b118292a7e46b0c612c76266d0d51e0e25c50ad245535848ec64671042a399cfffaa5d6197e934d7eb9da673c7b95526a7f9e7346c61394dc9b879916e4876aec4782468ae4d74f31a3c74855bd5a856dc13abe0008f132c72d7315543b8fc5c2432f754870a346bba96b6e4ebb29e335292bfb0b9623d5c470ac489d3b202801c6824d93c018712df6d9fb034e179b40c7ca2fafe3f12f8b7fd5770d0fb2234b2acf85f9c2058f4500f0fe627f164df40212a8c660b67e03e2aa57e08c59ad697abeee5aa98457c67247e0d3ecf2e1fa059d70d28dbca29141b2e9ec9f90dc19f56209267907a573b45e4d33e786d9db331af18184ceaa3c23ca2524558345280c71dd6bbb1e7deae9fd7a92583e7bf7d2c9e061b4f0927e3ad828c4d1e98c380400febcd5ae2127939deeedfe4103d80d3289ca15728e6e532d968b20dd08c8faac6e997ceaa8a5311dcda85d8c73a062915c1c8c20baf1558ad571fbdd2e3bb0c171e1f941374e91cf94224569b7be652e06c287d9708b9fee234dfd2739820662a62d9c95f5443808b0ebd75ab2a4f455d7f2aa467ca9ba2125f697b9131cb7924e83898fdbbf0c8b909a32ebe04f93dd0f9cf7d2fe83177a9ddb4e37e4c1e93cbd3361e09786c6236536dac730112961f5a4ad4f82c3f258fc464f2a5761b7af1f6e2b672b0d8a45eedca1a33bee327100401d9e80005900c928173038391dce64f4e12b11db4d82893f9a62a13be3ea3991d33c40b4b754c4da714002307d7adc0a40a33ab915532a2b0e37867954958e95084ef72a93964ce7d01e9d42fa11e8110e9abddc4a8a28be9df1b043e27a84df5a58ff5eb7133a80c5c1839c33dcc537ea30a6b4072b679badd3a12a0fe8dc05a3d08540ecf9d116199368b246bbef682d1fb1a4e079c55f64aa4e2f3d17d4690cd4372d62c2d63ae140adcb7a932434951e3e20a688a554756adad73892f368abbb633996805a8e025a87ff496097dbb725b12dfb57655227fa4068b1bdd725f3e20c2de9e18c1012c4555629bdcec602e050e2072c2e1513f68bcda84cc4d60df278ffadcb64b12d237e14a49170a1a7433946978814e7469a49ce5fb034f65a94e05b01ad2613c7c4272f374e62d0faf4f7b4fe463224bbd8e537222a46df2aa5410da08c19e9b37bf4ab6dbb0d9c81bb80f327df76af9147d8b2dbe776a4bf745a94b18e02a51f434ccbb44292193a2ac96a325a3375da8a4f8553e6d333ee18528f52ef73b47d5a9a40eb6ff34277cdc4777e211234ee476f2ebaf4db78196a8f28848ab9da178b6655dafed1412898aca90659fc14eef0b42728e480fa585e97900b64baa869dc89320c5d64481066a0d3cc114c9ac59dfe09498bd5a4d2c5f16ab980ffdbd46a93f28bb93895a58fc1d3818ae110a980b14848f9a2866c68c43ecf8968372d2758811881e250bc327687228d050cbd05b1108cd08fc448006191e84d33024f4c99e574a4667060f750e0f6a7bf67727fc3a24aa0909bd223a4285be832132614a8091b92e5f1036bb31b24fbda1a8dfd8abbfdae72626538d96a060cdb821c74596199b2484052a88121746a630a38629a5f1408ada2905a651d724f24e10769846dd06c35f26e29f1a8cd97636f2e899888977961753e26a36ea131b1ffcb15c26e8bbdca4a5634a31147665f81656e43f2c537addbdc34ced0054e3fc44ea8e264076ea05addcbc8760011ff125dda9d2e49ff1493a82beb6cf3b8a46fb4a28a012e25899c36478c349a7238179270069e4bf7439532ed1f8661925e605a9f7f6e974a6da5572ba38d6e0a29d1dbc58e13bcfc8b27ed8a2a91c66bd0235ac70999a89e0cc64e44738ad99151e98c08ab895992071dca08e643cc0d266d3ef422a753f0f08af2839d66be650b749cd21e914e0c130494e868a261d17bd79ae08468c3d7bdb935aa4c12b995795708ea16201fd4f807c3f4c76262f19808de02cc7162993430eb0daf6d17fe4f62b6ef6bdbd841058e0675910f64b32c2f2fd9ba3639f01af6759574b423bb15eed9e10553944d214e92f13f7df4503692ff21fde6d9b1531e126bd72befa1e3406e84059ff719cf2c345500ddda6fc0deaed9f4768ef890c170d80e46666726e852e11d953d4a373c4cb1edf168c30df32b861a5e6476e0e29d19c9bc44273a53af83e931d5ed761cdd2fe5145005d9e6125b399e88256c1ee9136456c5440cc6ee9f6b27fe75da037dd35023100ef7c2eba83537ddc6ca5c64763d21db8fd1881ec9a3b4b827bf15b8d1bc6882af1e8f42f96655c9332e9767dd76f51612b7c42b91fc74f702299ddefcf5e885799de04212335b1a53803183d64f3fafcb2f3194b37e3d86e1d9da4c07b95e698dea5538f584ce847f785046ae3e2c5c939d69de4adcfd56a09393c7a22fc26602d7dc0ebdbaa0a359aecc0c7221675ca740bcf6d850b7cfd00bb7fa8d0baeaa6a8a31b5cb23f4e7f3cf1fa413a7d28b5d1f6336cbd77f25ed16e51732afedc16629e72ec78071617b3f3dbc294ebade44da193c13d21018901fd707c19f466e7e4448b2b4b7bf7fca518c32081ef5b28e23b54488b0d4c092331be4f5ddac1a40e37f8c0040b16fff1022a09961a377744a11cb62c9499a79231bccb7847f3059bc7545d0c27489f50774eb4c75c52112a96884ead967cdd74326121f82fc4409d4d5b9775f6f23fb1c454d6b799eccb3491bb044606c9400be650d3e7fd79e54ac0325a04b116fbd33dc03bf44915352b2417971a0c01c973ac4c91b864b576a8998dbc3a12310d790614626ce77ab062a5ea0cfefb8689b2e8874b84a85789a12183ef7ef99c638cedfd8b2b30a62dc423431d21d020920be3f401ae02ef015480dd2b844b7d4278fb4a06008141cbd81b7ef903eb544b2443451855ccf51064b09d41db86fb413123a442c2381e69c0a474e68137927e0a77517c445d85e800ac0ac819c75db5c463de0353578601a3601874dd676a14b2e7544b82a42a025aeb5279e5e3ace19039fc9c145b9a9dc90c1eea9ab2c633f0c61a014ef7b3f07c01fac39495e8e67db8fc4255dbe25d771379bc2e955b3c510fa22589a05ce4c1d07399f2c0edf950e63fcf84fc225ec2ba18fab5f8e044ef59f390a08089caf6ea4a7a5bab2f2b2a8468b803d60dbe7630b3c5e099408ec37ef57f262b58357a0c3163c1e486ef4646076045f23e56f459fd0ffdfac43c51a2f4f1f8888397bf772b1a888924735b80c705cd0446e3b0988c693224ee520424491dc2e0d2912337f450b92b5d055e64e64429d7ee3b0b0640e7599ee3c85e7a2246081570689a504a3175cb656d92ec32a1a102f2e26f67e760791d1a5a7c977a1963ed7490d5b7c8be157d0bac7cb28a82dbea4b9b0328d534d1010c5ef5f133d0ad850d47486ceb4431c097886176ad417d9c094dbae2c071330e388b43157057b170dd5403fd67213d9d95c7638d20a32846957e55dd4f9a52cb06ce86bb4926487320c56a655ab713114ae2bb9242004a97b712b13f99d0f3f636c81a7575f5b47e339b24e781ce830ff11a4e65b584ce073d49e4e93b426cffa401827b77583fabd31453869a506060e88b8a596a8380ccd869e4cd6e5715c0a9e4bade12d37536729e68f6c63873ba2ac8618e6b14770f5b1140227a6729aceb091fe8c8bf1978a6e495496fa362ffc70a26a72ff2fb2b449e5e19de7b1c00a1155b778fa770e3d959c870a528e03c032ec8d5c694ddbd63880b502c43a78f154eb361986c91e866964b64712310866424722304a04e7cff796ab28130575a228da1046c6cfefdc5db42d3590924ccbbbf389a05c90b9a9338718bf255c4984ae226d8672a239276148862ac5fcecd88c2790918453d15f76872f731a3ef29b1bfe2daeeb7a0f5b367a273752cedbbb0f7e19fc6978b2eea24786c0f66700bac4687fee33c5d9f34b3e56f87699e1ac3d19ea793d15dc3f78f3cb6ea27fa6644bd1997a326bb7dc9dc5393fbd62a013df1f49a79fb75b546a05cf4d283b3e7ae5e5f4e3f9778d2ed7bbad1c908a6b31117fe280297fd1c3cf3f943c08e3e6d98c8d57634f200f1df07bd87527e4f50fcd2494ffcdf6d8a6928c89e900a58e1a5033e7050fa923ca1adfff18887f54dd1fd64a90f3f452755ab3192805dcdf883f7451c29e741a0647855d14b7e77e794fa4a65a7471b4bd70027a2e70687b412f0d674094e03c9e93c6b99173dde5a8a9b11ac53e48d3f08f8fed46f271ec5307a1a5dc732a9eb8e1b04b3fdc278ce918617f46cbdabcaedacc0b4f2188758ae06eef659d1c917c38fb872f24929b74a19d6c21aa5f853ec62f4ef8a3b5dbfce80b9157941eabf020733fa385b9115e5667bda26201c62bf0b608bbb02dac21d686081877354c246a25779348f118b1afc76092d00d1c9c5eba7940d46f17a7e6b3dc81ac96e00dddd43f544299ae0cccb055df76a7da1928042f9104e2c7475ffe31a488c5fe4b96baab2dd1de7e067bb948578f86a60c5c1d2fbb07e57f42603a01a16753e6d737db1fad3a381caf2518c70a1e6c40426f232f5dda3d5094a922ef321b8dd184972eebbd5efd8d3c28dc5574f0ed0b5eeebb0a705d9c32c369ddf1f464a31290b1581aaf708ee99a9c274c004eb706342d059b9ced0d76afaf01844bc4bd87694d5ffc7eda1d572327d20be40792cd5c870da778575891fac43450d15377b69d8c71f214055aaa0b7916437baa9fc21b2063d8757619f9096ef2181d83658b686966ec8e9d0e3f6a1feac4d0c5b5ab7b96d72e2082d0942e84266dd7ae9418fedbcee48686e5b8ffffa5226abd16a6e93c3b3afde6fca338fe8f8b33046abee81b879a7552b22fdae64d487cf8fddfe5c97f500c0079b0c7fc2946922a980d9668c663ed4b41f7e6acb10f9720ffada628fece023fbfdd35e0e243cb49fd295ce9873f2d691d002eaaaefc8f0e6aa5c0acc609c54cec7a5c684e3b58ec8692c2095b6ec76dd9ca4fdf40e9bcf6ec92bba53a6a8f5b0d854dc4346ec4f543fe2eb8c7f3854b0a7ed8f6ebbc512d66b481913b99f086406d94b58070d1abfcdd42afdda0099b7baa3185998848ebf9cab6f80f3a9bdc1be96d3c1852563675b7637df99b3153ea81ae90f447e4f6576e82e953d9e6e693960ee761e6488e40048b9de1c30ffa37695bc0990f066eb1d6d9b7f41a8da9223cc1db9cbe43951dbb1cf4f57e21d96ade228448f1229df235ee41fab01a7c0f094874e9b20a760e84c15bc3acf8599b9eb6188db46c5a7a2fb7d3b5cf9e806470e4e6e966c9d57550da346d0717f1da0e4d033799f33b8bb7a0f78cadd93c3b6dfc98e6c8898f1e8298e03a09fded999b5b09a7d41d4e72c402f43d3731f2ece8831601db65ffebe2f5ac9dbc30c2a532880355604e023a8816214221cdae00d0d42598e915795f94edf07236f9a2f0df98c8c468c004ed32766ed82c70ec8d05e968360716f023d9a35e1b67781350eee88c033c2ca25c0cc876b6da8266cd145d7082b552bb234c3afa2ea193a299001227657208c51a8d9049803e191b3480fdb100f169ee1866e808611db101c5614ef72a4283ef22bf9bfe65d93b35a1ff3b0600ef8b57d1d12ca2f39ac03be13236de87dc80f7d9fc56f9ea35abd46a5e2b6d90e5d0538030ed1ac6bd0b656e5e3217be7aefa099b30de675505abcd58b28ef402151d5c252cec60c4e83e302fdae1c29373bd00ea3c6234232d55fb3372072ed989ab0c9d793950bb97883c53fc76ea8ba5889472275bf9f72bd2ae49871e6d87b523fcc6162df2bfff98bae5e62b9c6b294884a590262e0c499fe76346619e6c223044778f806d201dc62daf7cf9812c801f4957312ce82ef9a83245fb6e7df86e2a8d9371d630e4a78871c6f9daaf40c407f1c2151fa3bd005f96e35d8888649a470f0a94edd21fd75ad0f864cb33b603340a48d09a6bcbcc0dfbb7754e640dea34ed8f90575bfeebfa6536ae575a156fb49753157a4e807194aa038c0aa7572110be9e42a2bd0c63e4b4a609fb9c70ce26e097717704bef520def9a2e163ba6f8ba549daa412b8c82ff61beb1e0bd3b2a527bfbc4fca2743bd2df1b3a83229d5aa810ca88c98c11e03a5d1024df8718132ca3a46386faba6c7dd50e2a05d06694324af93c683eb891201fd5b700818a3846c2be0abba216b17d48d4272310ac260ba6769e6bdf9c17949fe67dc8c3475c6a8c5b7141e6fcb5bb836147ec1db2ae85c2cda5ff0fac931c36f66b58e54b14de8a80cafec063c86f51e81dae4f4491f85060c831f4d79fa4b7fe86b07b39e71bc76c98dea1dd84cef4402924c40a9377226ed153565db4434d8e022cbc4a6db6a25e6353b57bf0b5e825f67a4e78c8c678db663494468de062739366119634f507e192aa5f7e8680722ad0e6171784c1c0e432acb1ff8dd2bc9cf54f351a01f15348f86997ea0961219227d22eac311083c68b90a6e13dce52cc3d3860c98a6109c4f0c9dc62083da6805f18cdebd3104edfc3fc6a9fca095fa660bba71eb9a0f18ce88ee7268337773267530922d5e1530fbba8cd31a5733358a19ce6e8402ec12b7921bcee6f8619fb8e16544bc46f37bfc2edb4617c19571bd3cc7176c7252a1c2c9ba16e29c80fd335dfe365a6a135486e98099ee17ef65d9b39f123f72e8c0b68440a1763015c614fbf0dffd4ae30975b10d19692d9c0a27b4b90897008c2eea3ea3caa7095732fb43fe5f138f3437118251fac122ed8d3aba68917336f74c18610694ecc699495fc3fd5d48af945d938e8d5d2e6397a4ee0284f88fd6979c2e5bfab1ce2733bc5a00cb754ad051ab013f46e80b9671aa2d71ee31f437b72d229b163a11814a5fe20167b5d07825b76b5a6362cad2b016600bf69df458e71c8ded20ce0a5a5e286df31199077ea56b8f686e62479f05f5aff67988958e5ea5cea6247ac2525da3d36e85158e0be3299bedc8991b64a9586b2ca88d0f092d9ed14b0ef9e07e8a480a17af94b26b86fe9ab2dff0fba94abe7d8a3d6df47fc7fe19a9fc3c49d395b65e67359070fd0c7d794a4e23394867ccbc982d6b74a227a8f9d15d0d2e10c6d48f820ef21469033695830e16ce3ed0d5b3aa04653f10b465536bccb2ff76a71e64a884800954070894a3809137ecd992c6c4ad44db2bacd7cf3f69b888c9837158396fe05c0cc1de59fd8a7477af2a6ea47cd04c6f785954192f6c8b5105c2b020fe0ee2aa63c2460ef63f3357ce612e7990909a6d8e2b6282ead0ed4d808af9cdd543b80f2eb04c0fe7b8169422ed53491def75a04b4258f8ea0f93492b767ee4efbd1b689ee57460bd8faa4d5e9a4b2f1c2ee249553ad8910caa899f9c8e96409fd7bdadac3094733b267e2fb6c24bb40a1cdd083ba54266e8bf4f3272b0e2d1b59d1a533766eecdcf5abeb450312fe7f3d85f2b3163057ada01e36854f86f0885cbd814325d268b6b2c1fda7dc137ac9a2bb5542167f4ccc560ef81bb0db5957a60a7f8a51160dca122f2731ea7925188e09acd0cb04b14d4cea0b6e0f0ac50f506ecbb44bd6dec30bfe82e1d2bf08cb97ee34dfd0fd06b15d71207ea252a9f8c634c5b11ac0f9f7d1310ee821192181c957d1021591cee27767227c584de6cc680296af1161e2cd262170dcd0148169424e4b9a4826f248515afa830d29e7e62b826b14de2ee7a71bd8dbdbee3b986461cc5894301b7d813ef1b48931cd45707e0fe921435261887bdfb3c7b901a36067aaaad2cb19ef21da77fa51913b45c766e2b4f17f9d84c593514dce912b6cfe589dd03e576a43c3da053a537c87c633f636b484bea84cd12a90292b9a9ecb06fabad84139989caf494d95da0985f0c5931a6138c469c891835ceb1f7085cfb173180f375d4c0ba4f8a117490b627df207facf2eae9f487fa5bb49bef34196f07f7c9654206c6b35c78299e28413e7e2e0944864dfbb7b3d4084f275975a72f612a4db5f1a28baa2dc3d4ddd7cc59be5ca7cdae888e7a753b1e81feb764f37453782fe3fdcf402d4571e593199cf8f7752268b92f152569138f39239b34339f89337d6354e9c5ef173f18fa67ce51bbec2c63c686c6cbfdd59125d07f9ef68ac7129744f8a2f98df898661dc15c2624fb6a3146d9506f761e1c0993c8fcf521e6051ce7d2fa016dd7fefc800be6c43cb96a5f829164de77f722392c25bdc0b4a172fb3eda79ca2a62e8cd6b7dac3a9b7dcaa9c819eff895a35c3b2bb929f56f9f36ce4a4a118d7935a7080f44a6fa7be2653d959c4a621187a110d880bd78364a73481c274f6971c7d05f86d413c3230e7365e26426cf9f1f6cc75e4fe0ef4a49e18e27e72db757a838dfbca71389af806892ef2351bfe83b9db1f6bc0d6ca054137cffefb9024f268516409245b6ff1f996f0fd57059b87d2ee245deda590d63f9fffdd0348e794f5c9c5168c34fadcea396b1ef3fd05a0467612cc7ceaa2532388adf99be39e43495bae573e9d13ab5885f7b25cd19070ee9322ab24659927b84d34fadace288cc46be879a77854493cf0c4e9234a3ec8e6a37493320b70babf21c25768eaba06762561b3e1a6ddb62002991429f971cede0ef2e85298433e856015512a5b535bcf6579496678f2b49e2ed7b418612120349fac3db9af2bfb6987d85fc12495faa98b9bf8c5933e8d1d4201c76e0dfdf348d143452b4a549e15408028d89c3f38445a5824b75196e24fbb9db4e752c94f8d59d0701bed340f74e1e52eb7bf373a7f8530d8176977e036f4e528c52ab5d69bc450a69c24f9259adc7bcf3a3c0c1b6953005ebcc8ca4411dec5fcf463213843b7cff8a010147b360e56d5ff94f71ea6819a5dc36ed09f29b53593292c6ef500e265df21c62ac01049227fe3f2822527d88645290e9f607cb3557d45e26a70719ac286ae410ad3d49494","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
