<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"788c8432224b431279bc3418fbefcdfffdf844b8884fb4321cf3affc79a2f6d14c632301e1efb84dbfca74c0422aa543d1e9e1881ae44fde779d5296d817d5835708327d9e8e7b7c2bf03f628a8fd046f6c626235bca584d2000bf3b61bf3b11c99bc49d6af7aae070bbfcd112d3589105d5211a750b316563fd1058df3273a713239458a1c5bd0b20bfb9a9f29ef30dc7d44e4195a7c41bc129c5268c5869da4067a4042383dd78c165bed9e4fdb8d7c6d7c2a4626e4a8f83d1c678cba8bc734b30e002a13bfc0485fd96ed21bf78c08a3a32f6a898094fae5b0959f256e47e07f9b31844e489dfe32e976227395702c4e69211d4f452a162f56a1c03c7d92a7047c5aa0af59060f2d6fed9a782a21df23c5b39de916ac98288d7a7103beb7b3b1a793cae581111a5fe0320f369e29581f680d67ccc5655df5edd790fe620868b910d4b29433f8e23c043772606bfd9be6af190734202674891a40ebc85fc41090a64fddfb49cbe6081523b70349f941d8a23d8121eb821bafd8830dff8b9d7894e11ad5a4cddd4e241ba2858480fbc61a33929c22864023ed2a04b0573aa9b45baf9d218be563f9f17b891b07f7895dec4bb212868af6e94e07c9d275d46aee9048ff8c32e0b4b6ecfd80aa80cf9a9e362f9d74053f20259bf7accd4523ca7e3c796425c4a78d95b4e604ba799c874deb5c5e15fd2bee4f170240ab67cf0a2c771bed1da65b82d1cb93f23a30c6a0e57d78f1b7d9243e33f68a62481e4d38ab64ff7ef487f039ef8dd9836feb8471942207b2581da8b8f532b53d346643841416fa938d64f223e13984b99642b2864752450521fc8066afe51866efdd978d6e6b07a2876ee608982da729506fc55e42e6f628b26315720c255a2b5dfac67cb6d1e332f432c3f62def10ecbabf4fae0171c2cc5f20efeb0cf83c315c625ad598285af828924d1b5a8eeb71819f533cbda71726313bebb2a0c87ccb52f7bd02d3943b92a50821c26c96c19c14f1eb5be2f6cfadd9278dfcb981e3769503be6fb81f2503ef3f6f547c5c1e0f310a9635b36c0bfe05b4ece578f079637fe3c157b27b3ade5106e49c0c10540b1813d3805768fe1490feaa3b6835b317486dd619a11bf7e0e657fbd9fd7cc223b1114293cd8d0391b2ab3251ce6e4a4eaa6bf64cf8b3a06106f2a41fd1b140cd14bdc32a87d90a9b1a85a9688506ca9b346c0336498fcbd1381f97c8fcce0e634079d33424de50ca6e9618c7060b9848dcd82560d5c19a5c6e3d828aa7c6397cec68a6d12079fa69a51ad78a1168a873f4c4af32ccf8d7df42c969c2b1bb899257bd9674750a50d62a08e840ac9fbf6e462a3a134e647421869fc4a53eed5a589935b82439d37d692186d73131c28dc0d6aabb2b792000b13cd9ccca4e5967e9db6693c1d350b66811ff6197e8c07c7766f996e05fd37b040b42f44f2fa81721ef72e729c3226253414465863e4cd4648e7b70f687dd59126be908ca92b353403a169b29cc7da41fb7887027fd50c76fb27f251077c0b439c9e2ce8bc026fabc254558cf69569b3a7ffa72ff792cacd4dacb9ee57c451173602a92cdf01e05d8340eecda4daf542d346c48b59d7aa8ba2a5e3a789974007d536d2ddaba29f553b455e95f3074532594fe79371f1cd9a9318635d23c53710039900805e69b73c90f488ddb313300b676f66970439d0ed29599b9ed5cab4d6c1d2b155c923249871a4fedbc56accbf8fb1444695c52cb629ff478a1542af76c7b15cd199facfca588bbdf4a1ff933762c1987c1ba30c60c923faaa3a7692aec2676c895d1e25b230656bd9ec62bcc4d5d56e9047e54597dd89aafe066120902a092da233bc602e19550b211b696b00adf4c2be1fc0987f2ae9cfa34dcba461f776a40b3932441d8b55e35896d84161eff189da223ffe5afc3993f8432ff9b3a1ae2e72877c1cf2376c18301c72e74a2976c1a04990ae3eeaadcb59c4ff93ee8939303fe03ce13161fed3b3f4fb380fc9b6bbd543bd6dca4faa027dd4702faf3de05ce26dbf63c1009d314197e3f2a827a070b8e493ff04ba7d2fec6e35ee3c0902869c43f1ad6755f07507bfa9bf14f253a06def2319c1906f6b64024c75322de65cb02c0b0cf37795032e6b091d75ad339520c8dd8ffd13816b1853d89aab9cf8d6503203506cbc3df5681acc55caa963e173f2c4ddfe7bc86472a3debee74222fee74cfcc0af77bd5f23ecbc1f849cbd3c02c4d044cb5c0f6a18e364f03c4055c123b5d4a32331cf0a5329f497959f720629ff3ed8a067bec4d31fde6c6bab388fff9f2da3e9b5de130bbf789ed79c9e60d87b6068ecbd78a1548f0b1aa144c79557cd93d5f4f31fd41c53e3972ae13d18e7878063a9f54cd92bf005d281167859743eccf36f2a17ad11969f96af1324495b2361f572c1c6f5409846ef57b2351a94021c1bf988e2bf28cf1cc5b8403b5e17d704d5b8f7e63b06ad759b22c263efd95f353a08c0fb0cc77f0cf82319a2014981c7490b06e64ea68208a43b1c5505dd792a31276c6b4f3100772d9f838a5f843aaf38db783967d40739cb125f0c20086bb3e79fcd5345485dfaa31129e3948910f1df1b6b99bad2ac785e35796e1fc23dea695c63ded1e06545d74a0707e6adc09ca812a0b89c4784d1293be270936fdac933c6eef4e1a18f0be0cac785117586827afac0518e0e0c82cabf507a4e5dcac0078a269da9e8f2b89aaf988dd43cb7970efa49edcd77795c97ad75e668bdcdde07ada5bfb7c1892aa40ae72dff8516c0d1e151f807e51e7bac4e59e6ec8bab100a620b6dc4486d609fcd093ab60178c572183dcbb98feb099db1056521076fcb1fd91e3afced4156beb0667bc69ed63dd1c8a83dbbc45deef9ca3c75c14cd0ed74405a53f66698a05463b91245f640616f7b25fef5460af87da68388756322b919005ad12908bf86e238ef8d1f05436f75cb52bc07f385c8a04725be541fcbb14325914d3ccfcf20ce084b81d6fb2923e6464286a71a668e23ac982dcd062bca5fbf51fbaaddcb1a5509e096d4bb03b31579414edba8a4642091dc3b700ddff32da207531dc3761ffb383c0eefea76fa67bda50278d15606ba75839a1f85d0f706cfa97fecc6d61475ade1a4b7441acafbb69958cc33931fc294f3351466136546128f1c3dbae85cd80d86f27ee41d424d63e720e77a449cda8b66a74f543a5ce3ce67be4f3f93f57c4756ea16c06ecc5894f0525cc7d6fcc5c982e0a959a4a9c90e7e189190b9b4ab09268ecf3e4b0ce3b18fe68d4ebac478d79ea8a057bef58a003656879a910342cd06315ef53bf7bc260339c97ba1529ca75e8e2067840b8d99948ba768d7a2ae9464f991572c0c6264fddf5ba8fa65379fd28cd477f89cb8f64cf5e8949f17e1ce2c41281c55e643afb936c56633e4893da672e6792a5f97d57d9df35ae904cf5561fe73f5556514688b7a1b4ac968f6650de3b82ad1ac69051e0b7b9df5758b5b713c15170732c5163f569f3ca6cee2f69144e58e51badce50eb06e3f803183b5c5b86d390dee3b277fcb8547afc9380b25fb20bcf45e160207241d70bda9fda4a217ea324ed8f3b770b569c287a72659d1659acec1aceae1c1b19e311ff1166e22165dc2ff28eac5c04f8c23b41539c45a036bb98cb8b67261ca6232ee6555a6869ec315811db9b4facdfe76388fd8ee1ef608359938d081c9f130335f94e27cc48bd4e0b8d435539d14c7ae72f9756055105576633c79aa2132309f8c44005f9e6effbac8479e46ec010677f0b60abe1b9fd254b06e6ee170dc113598002cb4df8c90975397a762e2a81cffd19e194e7a56a045dc78045c1d3de3f3deaff77b65a365510a759208f212704330ef4cc086448b4d3a1639f24bbce9afc82334f05adb43092884428613688f23f0ef8b9167c5234b53d7c299c1a6be6d94deb9bcef83d6f7e957701452653cf398aa797345177d6dfa8f0c8fe4ab117c9545ba33e14bab7eae4d9ed6a71d30b2074964a91dbc513d66dc368fff6d049b507e44bc5efe80ebd67273f3150c7da9bb2fb7dd245d6770824500e55135da5fe63eb64cac0ac9347710d562d852030f02e857bd0ac12f6bd0a839df6cb74ba23232b1177520e213c4b7e2e637336789a1e425b4b6639c56f67f7ac22933a1cb02cf3f57e17cf944607807d58e19286432615ca73ccc7f2006260efd9e880a5f739845e226233cec3fe3d97cc84ec4d0670a4f16bf26cf207b8aadb46c3a90b82f9c55bb8bb6408eaa0741d3ea537ab17f460aed15812e0918b28de855a6e4b5aff9a7f078054be2224d7f6843ed9f216a041032d8526a17bcde4a87a7c21153696764fbdc627487f0879348b3330652520ce3fb85005e347bd79a27067430b09bc7685ded9f839e67b2f52d36249e166822ca1f07e11ec05a9b45e73fe074e4a558a03af86bd15bfcc5aec465df344a11145312dc556ffb2be6c1338c86ffe05d57198cbfd8764e2be5bae13a748d05e7c57a74df8718e135d4e8af906499f737c77597931082507561287a18b8098f00de346ee34c69614e6967b63cc1eccc9bb04d80182a52283e085c3590f2fb7b9abb5238737f6fa9c4865fb32e4f529b4e4c52fc5046848386a8e2bc8dfc2135aec127199f61a72b639ec8ea70e0a25ce02633ea2d8315e09baa7fb5c40459c8e1a1aeedb05c27d5e2a5a7f082138842313b5746f0bcf9d5212f3c57842d825875088ff5d01b0112b4e719471d058e6676cde4ae3ded50109b9501501442ceac12baad476124053abd83001a4c2982241a0bc364734272e88a5cab0e56a40c746fa901bf38c4bf26fed04b9b4936453f3d435ea74516e1e6b947c29dad6e8bc5af42114e500d9ee1f213f9ca56fa0dcd1b40775a55163197288391bbc14af2fee89a2942c933909c39d0c3207ddb14a58b552a42688ead5a7e33bde6c6837c12d5529f48aa5e99e1d00cad0af062f340e876aecfc420439754c5f039cfd4c994eb650943601264db00cde62a39f8fb6fe151bf1a3f76b76eaf5a1b01f9fbe4cc96d237bab517cb94f9741953681576ca3a811136675290b4436c0a4e87ce6ee5e88ba20b9470737296ca3e006cfa98fa85dd535858733992dd817e9e531a445879a221b7d5354672866e9941d41ce00b8ab18c87006798a7e1ee0a4963b60a47310f1f875e36a6ed17d6e19906e1c74aa29c6687590033ee2527dc5a9c83ab08af396a2d5e835d1200a62ca1df0c3b896fa2cddea004a7520da76b66acea332d6242884e047b4c3dd19d5bc2409c0bd0ae420c1a32f3f04479f05d823d84533ead2e121f6d02e8fbd258f59f7b12b18000d154bdb7144a5d83527feaf6cc39efa71a57cd9e4bff3ae06df25dd017f7610ce0cd145f85729c2d05b90b9268688b6729c85c0584372df2aecf2b53f875010d1667bbad7de79568c250d588bff2d0069bafab6d312f0333e6a324efcf9b7819953d166d5cda21a71db32f7bdf2289df1ad59f8ef07a9b8528810ddbcddb425afd452e1901fd536090286e520c1988742fc733c6bfca19dbe0a7a73742e01d2ce3375349d7109b366f48d8c0740627632b8c20179efaf1587d72cf183bc23ebb4861d2904538e91e2c1a8ac908a436dbe96207ddb148256329a6f9e96ed5a34bc6c17288fbf9d61ebd7c7e167d295818191654a33776a34d7d082d2ddd959795a449e8f7a9f77a462ecf29a3d3c725dd5484e5e9475fd81c3ddcd0d23996bc14c17da47d38a6953b51c1709b91ffd075ef0f418166d708210d63c12658e5ab90f94f7af22180010cfcf93052dd9c96b9ff4df87dda98e691e0b5184847430ae9f5877c60463a9eef05638b1da084ff3b0305ca3431453bb7f17f7753d8c65edfced97965f824107284a3780ead9ea3f458b40a93adad1ba8838059f2f208f646bc1e3d3b1cd73b86ac19f93c87e3d0ddb3ca51596c29e2d7642bb79876bda3a6cb50d935ee1dbb85a294b8dd230a53f074643ccba53b4d40b61bc83ff5e6bdedadea941d345c1658278b9af62ea069df16638fb762e08710f387b59bffb02db4050e8e1a10af858997ac191652956ed1eb48084fd4e76ed92ebe7988f8039e97c3bd9af8cf7995452fc37fd33b720eae43b02e123c4c3ee4dabaff12874a0e3d469ef7aafaa6a08b6d18005008d71c4d7b8fcada09fe7e2e9a6cb0de7bafde2a5b4ccb50e5506fada0c3cadf45e83ee1810c58cab6f084df313232bc2edc686d8a3a57ccfe045e933276e1560af99d6ce42ccacc2297f95caa6f7e8a7dd4be2093192a0d2171e08ca97af75de2629ffb36bc9845178450e9c6671f9b248918abe5371383841facf2c62cdc4846cedcebe053fc61c52a6844a14c3e2d0556c8a159ff0bcf4aa6f03214219c2a36b082381d803420fae955de6300047767b4933ef272d35f8a9a3bcfa59e105aa7ff25d23baea4e7ecf606e82c20f2659b24988bf4bd86c4f2ca84514e9ee21d29aae8b87df0d4cbfc3ceba3a7f0242a5c96043e2dea460bbb56291cd82caa72db7353e543945748ff634ac24a6fe463593650264ca21dfa35d21ab71a3aeb4c65c7393a626e1c026cafb9e01709ff9f2c0a8e28f275cfd863d477c663d379be57862ab95c7e161e44445efc651fde9cef9da0b518c79162faa37e9f0e66b7ffbec0c832ead2617cd8416fe7840695f0a861a295e76963d568e839dd5c55305b855da7c11efaffcd45a5048f35b9dccb84094aa54d119daaeeec8f97520103db28aece49f5d2a9ff16d9d87e62454ebed7bc538a391e373fd89a92956179d9793087aa7b4305c784436b67cfa3fa5829a4e82b641b11593ce6862831c416a9ddc0b7496dd8e58162d0ed6026670dab31b2dba151c301d7c52017f21078d798a8c17c5e903c76e2b8bb9ee19e4646e98d4ea744be8a10bfc2211d30ea07fdc4deb9a3ab4a2fccf3419c9a3f2156f43e801976f204f080b8f06b9e0d018ae70c58e3d79c0ad890ad56b2aa3272f92ad6368c97e70cb996d2b3d65287d2223e1c56ada87eafacc098263887097dc6d07cc8a95de39e490f7fd5923650d6b883a3215278fabd92145f31593460ba9306d05d3069f618de311f273a042a20deeb11f566ffc85d3826cda85bbd3839d90e24aecc36d988a7c4d4ac2e276388b5f40f2008f68969a96e324635cccc88c8a475ec719d121b81817b10f857e8261ad6727110e0bcad3b1f9a6b56681b32b9062c11574e11b01b9210f552e37548404fa52fc5a850161932061ceba4e9c6581583478f92b947b4db4ca4bc3d120a126c4b989756d49492729ccdacbc7c3eb03f9de737d9cc3c16828f18fc36bf7b1544eec444918684717e7aa4dbc1aa07959719bc8a2a08fac8d9a2aab0705bde60de3f4322f600e730592b22c4ccd6c80c63ee9e18a55b0b319cfbbad5aa42f6895d359cbea80dce7a50aaab1aa0ee36abbcd6345737703922765af99db2b3fcac3041b4804754b90024dd19bcff5a6eddcb979cf6f49a181ef18f647890e2580fd5e8e1416224213c75e0f197aa3ae6a0b12c2eb9378adbd37f4b5f6adfe9c5cf5766a4ce62ccb20fe26da77f5139c6af5aa923eed0eb21110c40537147cdaa1b93fd4e53d1099e76e6a24e50c9b3ce98e9fc738d4685eba9deb60667dd1509b3b60dcee21effa3aaf759c7a25daf16c9493050cd95534d2fe102eafdff3a5665b04514f1c2bf001478246c959c99dbf2ff7c84ec85ace76cfea36bb082ad71cacb6ded4b208f9040d0d8d5c9cf05c8c42cd673f6c8b38c161fbc05fbb838a30e4f7ba79b23d5e93ca7619e57d5f861845efd6927089087a505cb5921b6cae7cb40c863325fbe073331b75b1fd153b4c16e3fffffcf1f6df6301c1a12c01ffe3d00a4bf28684ad62121e95c39d5f136d4bb63f9e2166f5e94903b2046ad6e7983f0aac336eed2af2293730408133cfe51d298909b91cb9acd2fcd311e79abb0690f6996ebb269e1fdbfce9cd831eaa36bdfb0a22e671b9c4cacf3f1cc10b15b5094675615c1eb49eb495f96f863a9eb92107c716587b39edd17f859d7aa9cfb4c06ba0a21c6e10ed82449e60550a02427edf0c3edeb4ab6a9d5759091351e8f65f59a244aa434e960ac5a759153d0ec2401686f576883ca2ca5afddccfb3f06bf10571576b7450494dd166029c020870a1cc1014d825350e2b9eb7f0a76ed5a6b95a223d64b2867db2ce6c229b3bc93b648ad88751badf8d7eb1a1479a1fc62f17e2cb6f8f95d6a4881fd5a1c9e3a73a2c15e6676808a34a79b5b74a0341d9dc75b00d487a36365424e2b956d777a34e14cb8d929222d2de9b7a78b3972906513729bccdb603caf8453a3852a81e47507c836637bc42c7f6afa52409c4687cd6ca5f494ed14c10e51927f4a7be077acbacb1cfda665c6c35a811dc2fc804dc98d3b7870e8cd18e58a316e4f214420f323624be4974882b206bcfe2cd7cdfd1abe7e2345ca00cf860ad61e10fd9da5e306b5d309c108f3abe5ff67142fcaa3399061a18dff9089c985bd975e4ab7b8dc505fa4f6678cac1f9d809c649d1fa36d98f6832dde60d5da55ec3f5effd1ebc2ec8c0b2987c8291a3c3dc8b4bfc30823f9f5f16c0a3a585223a74317b750f726b3d7e8e89ac6c96551b6b4ca735a66110092ed06b3a33d3d9ecc9b9c5a553762507a594a858c084abe107e9d3cedc1cfeb5a0bd2e20dbad08e4d4a96f8eb315a659f0c159f45ad550106bb9925a308102872ec45b035d8d2eb31f33554d9dee7785f61af66168aec359e4c5e4dcbe1e23d26d0e8de2f5a0a77541c57a040f5f84862d20bce1c985837ada0975dd2b7e1b5b62d4c1972dc82630b8103efc2f87ee4d1719c8c15c304ba2b1f6ac4c06bb2c77e2b6cacc08325f71bcf586ef378ab299c4cc543aa3656f4da6be08e41b1bc54ac0dafa25d0ffd9b71f1e967f9c1c1a3a7c5a094b5b71be235649189cc76d7efa7bcda55c89d9c75a32cc27e1a94adde30a477cbd7bb09145e96bceaea5b6de6ff0d7f319b4b0165c734362f1660bbbbe24106013ff047c34b9c6880ab4bd27f9f042d005afef072fef78c94a335f7b40d6719694f00bdb643be4a39de8830fb6036c12eb7d5f38d6a4ac8beeea16ccf41a52b17b2fea81deb778354866f0dc4a0945a5774a1dfaa943a8c52e5522c0b242184fc474af227866deeca41314ab7baec4ba567ad302abb160fcc3b038821b4243eecf5396fd61db973761d0795e3417e16862329e880b31e6f410b8721fba3e207ba6c609e21a634a6cc618f015bcab467ec3cb9047b6d5945ee1609b365b738d794e19623ae96fe955732d91712bd5b42763ec12cd0c59b57ba97677c2f85148950882531c21ef532dfe277ad8978b517c5d594656d734404fa985d9d9e2787c836699f3b43bef85f90cbadf1e62ba12961bbdc6a8a216edb85d22aadddfea422f9457ea08a16e3c222b799146f0832b04ecce4fa1de113d6decb254066f661a2d7746ccd4e526305f55157bb956df8b57e50d5c5fa53ec713addfc5a4986ab56973f18a51d292b961c8761eb296017aeecf5fb2fbb8b16ca1a23dda29459c238abe9140d2a015f58874039c9b701a5cb04f870395e539a174b57d06148ffdad20f4ed178fc09de08a366f0a81dffb2a965066c5979c8b577a93e1cd2e5e8ccf46b08d39a97b46be824fb2d834972dc384b96cc30a98578ca0d0d9735f17ee0f97133daf7fce3c2d20506c2e11e45cb699bed4a8cd5115ce7eab5bcc6938225170fc8edeb82bc685821f671b83a1af28316c79618a217b1486207fba9e53f7c590118ef3a62291ef0d62239ed41c471fc758f824d13df69bc903248485e3821bb813a58a85d948431137a56a8cb5faf280fe159bfdedbda00ffe6cce053fdc72754f5ab0bb358b7ad1cdc8dc2f9985f68e99018e208af6d2ce9b8693f43bba0d358c01ec563460668dfa35a930d1b5574fb5b9587e5e2ce5db9071d2b1a68cf109a4024035b4ae0fa01d53f55df2038fee6c47a3f7dc924d52f8987be63ca2e425bb1ba9cbcdb27de3b65993c37668a5ffd86b1fa813f8a4fd2695da92061fb81c0ddbcd295591048729aaa07af928202256d3d41e4766e9fd37e4343c8a998f1917b406b7a960d13bc91cedad395b9b34cfde43718afb50a7282435e95214e515945bc2c9f3e314cd734a29747fcba0585b6a4443f17541e2598a587fcef5059596623f031a31153a95917cda5b8fac8e2a33031d8946ea729907af462146aa942035b28664c10198557a6f62aa8ee23d3303207b76bdf52e9d1ad8f12571fe55c9904916c28ddc26657a6e9c477788d0d904544b921aa1b8849e3d72e3a1c18a3d12e1b81be5dcceb5e451d6fccebbb8603118c270f96ad8844dcf5cb499bb965338dbbcd710d6f15c0ed34727d65994c1b873fb58d2651d5ec818f8002764f608155b4ed4bafb73156c9fe4b7911db22a6adb370d3e818d898fb4294defb899290759fcae934c854d265f4330c19e8ced62c438136d89196bb57258d59f9daf1e69cbcd37ddf7b4436266610fe9c50012198b58764c3dc75dbaae42b446d69c539497494caf87bcac5dfa67d82e462bc2523b7d8c96c9703dfdfcfe0f241d4415ae79e540a67f5b856ea3b722f2719df1acf2a6c02467373b1b827e1c093ad7c762ea9a5b3594f5b77af271d9d4271a52258677ecadba6df74f64c884caac6845efc93c592a7616caa78d929abf05f16b810e4b39ee626a82626f951e8202ca5bb9f75c9747184b092589c875f3d9d601c962d8e300af220fb295c7849678cfb58107216364ead5e19c3c89b006c6da47fc82ddd0618325011a85635e95b0538b679a663accaa4c4cc76725380d9e2d2af8bbd1f14dec03a5022f5c49448acbb751be503887afeb96ed93f5d8b98727c11a64e6d240077df37e997f0e0b828356cc8510ef134776c4b05765c005ebf73bb2b72fe14d7bdbd0d8a9a1e25b7a4cfd3fbec029911b77b8f286151b7b6e0c62893b04191a86fa2a8951abee12396e89a00d1f3028a98720c461c36e6b9bc4c3925347ca861bb55e3aa98cc02b25419238985fa5b38e3898c2680719b71fa0ae0ab36b652ecde7d3976565f265f9bcb2464ca29fb3f355611df3e652fbbbc15ba14dd126b31e33e97298edd94f3ed0d0b7a9ef1dfb93cf81a3e7f54ce399f31f009786a0b6fe463db2e93bc0f46e98e7176d054a0fdc64ff61a0dd937fe6dcd5edf8b6d2c0c93865b980777682934a533f984b06f8995f0bb5c080e870d3b0a651749448e1e2d65548b7d9f5e3d1219a733c3ee080b0142990f011e2b325eab40ac44a1056e73eb36ffa71e9c4638d50519818ed97d50f5b2d9907db6ad909192edc15a1b0ae63a0ef785818de0cb3a8f71c3d208f410fc099ec935d1191e37cc0066144fa895cc65ed6172807031f07ba8d6c5f06985df3824e36cce273c9beb7c99ccfd580946bc0dd3f0d73b2aa75dcb796bc7d0c0dcf2008ec3e352532bdba99b45aec581ae44ab5f65974e8cf4ce73a4e710329896bbf5e04a197e86ec41a242d30db4162126e00d8b5169db997c438358bbcac3477f2c60b7294643538b4096b14cbe833614a173be837d52bcf9d203471ec152852c75d7280b251f8ca35475b2e6f93b4a4f622dc3a0aeccf1eab51c84505d669d66ab9fe41e2c9da7f9642444b5337f89ff13bb704b236a8da75f3f005a4785efe80f64cba440f35a427479dfe5ab97075e46e518a76b1629c66025bbef7cd0e23fbd578892e9a625ec5ccb8fc5effae4f4271578e070eaf9da5576d52687d7edef4929e60b47e503848fa016bceff01726bcbe9d5aef506b6fa396e9a70a0ab6c827a74fb433f82d3ab4414bb78dde7bb157fda67c185cdd1f0bcf80dc0a8230cc97407044cd4c27ae4d9b943ca048aad90521e7b3ab7d851ef5fe7a71ea5242542a265baf516e0308ebf0480198977c37d44801dc2ce7cfa5c7a13f346a4a21868c81c35d31013fa53aec49b58bbcf914974f565494c2567c1c7d5a9d08d4542b63b2c2e1ba1aa27c502a65a0b18bd989d1e8aa9ae139f42c44c4c83f3a8678c50211e9a3e7f9232dfdf8459ec34fa6d4e8e051986a72f1856c74449fca6950a9939d5901aaa972caa15615eb6ea71f20d74f860e467edee3d5b4f48e46a5c0e6e816928a5dfa8a91724bea545d84945b8dae4e829842f53a426db77194e5e9703b56fd06085b1e95577e9d5e490d7abc8e6f3486ff407b1c3e263f00fd75dab9ebbcfa30606291fc74bfe62f8ad690c04450a63d8aaaf150535962dc7a6fbc877f9e7c117ac01206b8c9d73216d7cb41c8ae31a04c8863fbe671b24008ad6b75333bc20784206f0e0308d4abb5c226717f3b744e41db46729c3ab45125715e2752cae7b4eef8a3e27d1a954d489663d464ab44c52708ebc425c788d15e1115e966793794650bc0aa65710f12c27014ae3f5d4899acc66a8a957ac4b92b942edeb12e2c2cb0b2c48c95b403691d36cf097316a6bba2345cc5439567d4a629d7be8e4001d4d8e3e09e13cc6fc34ab0b3b755082ad2be3d85210239c4c7fb454aa5dfa785f9fb2181da8330c198179d09f9a5889ac5d2c81aee6265417bc983498152af2a987b5d26b43969a2a3100e46147a28d11fa69f1b4acdfc22752ace38ea3c5a608c928be23adb83b8c8fed8d41c00418596df6d5ba0b635504566a7f6cd556d7e7e13d9045438641648c9cb6934d8c18cedb66c4f4abfbd90e78644d330314bc17d3aed55f34f96cffaf1a6ba85fc525fff2c622d86adce074d37698f89ef98bca265bf4c62853888b7152a39a483b9aba816656a94f0440394edba1953ef93091916b963965fd7cef14190723c533f778b90cf41e25f5f2962a4a7cff9ca526f2d16295bf5d598017a28f8d9cd1ff904b411fd571f540d05e21a052b7896853ad05c4d004932f84f29268d1c57f2eb9612d72d283de39b7f6882172cb870daa97f71d9d4529599a84d5b60dd86b56edabee2b9a465b49cc084454f6b91b0812dc2133eb4c5788d57f9d9fca1781bb7b0b480a4089f936ff1c32c2161316647553288de0e0ffa706ba21c6cba392bfa2258236763c7bdecef83135e415b22f080749db60f4b85aa276bafb3bf63f663d3fc364390ab5c97342cefe4aea82d6844a29a4ba5925a59d86029c1d508395eb21192cf6493c71926a97f655c3596b6db600ee90ebb6745ed66e94ee5237a661162b5a1fbd118d79665848a2525cf5a4d6b04a86fa8fc1dbfc1a190b23fa3c64eefda5855386f5a465e9075fc445c2a86f760956a570f2e007d898570cdaecce7a8682a2fc60bee1a60d3a423f6b5cf31929b1b6a32afd2c6c3311a049ba758d5626a265732fd6b61f4d7021806d283027f0bfb74cadcb1622466882d8301f19e7120eb976d9131b6c10a2aa4f5fc00e3e4bde4cf8ddb69f1103ac27d0315f2001b3b47fbbf6de164a9330cda1d05312681394d481891a19192e9b9efa327faa349c53535908bee7df0cc59ba906bff2387d98bce9f3cda7bf72b8b7fd90b99840bcca6d44ca9e16d955698a6134957a8453822af0ab322b45888e1d113aafabe1bfdf52972da47f30d0784c701cbc5ef994edacce5369f67ea062e6dbd95546a63ecd277312fd8760be15fe56831d0421f0dc56d9b2b26b9b44a6b016c37b1384e8f47f34d53d00aab8c07db04796a9e7cb48f1fc7e3ffa471069feeca45da8d445113eacf1169cfe03d24fe21075d52334585e05f532b15f96ccfe6657eb4fa1b367e79cfd880e916abf256aee9c98e7e0ed6ebb9f01513723c10ab9599698aa3da5263d2ede8a84d5cdc5cb44cf6fc06dbde03b2938b20c182bdeba5e3f9f17089c79f2fe84d15d9d0a5dd08d204321122dfae0235bf3fdfcc876b8a3bad6c3ae863c8009499938b9eff3fd0696226ab2f2ca063177a245505b3a924e2bbb069efd3dcaf5abde5d5de1d6186bff08020d3c6c9ab7b55d7e6d6bff31eb7be22eb44826cafc551f7ef3ac25d67f67c4243c19f3c8c86e30d3642452d6a0ce5db72c3c1021f4e250b6506bbb2f7974aa8c596528456d4acbe1bae485fc839fe1dc2ea154b5b418411c1d1c1721a2c18195a10842898a5396fe7933f7373aa68f52e42c3b27c4a0ee68e8993707c1d532d5dd7fcd8452d555252f6c1c2bd0165ac012b55dcd0c1485458e42c732f670aac1a53ec5eeec1ff1e1c0e73b43a0c8c8b6180a9d4a4843001b7c1a6234d22fcbaf85de6d37ae2d42bfee362981a8896c3ec7209ef27ac3fa4a7527764f8f0fb880e801be8a5c7c76e960387dc89819dad287e90671226c49bab879b658ddc54b1bfd6609af26ce0a01bac4442b98279afca5d7d3c14cc4750647635b18b2d82107aed7a46d3e0d506b468d42b56ce1b97151cae06b47eac6f373815905dad06dad54c17c7a40b335c87b9157a478c3d6edcd4b7bb0a5730d01e0d77c95bddfb319cb790dcf5c6ff20d5fff75ba93e0114d2abd14f88ba924596c80bda45c341ef9286e186020123c462798ec6eeeb6a65b6cf4d20876ed98169b9a51347e6457c504693f6c4a9c0e4c3b5512a228f38385b697c82e55b59e2cacca725a234cf8179f0ed73ad0ca68ec153dadf55b34a5acd115137e1afa373464da2c7c6a269874188802ffc65aa3dbf37b51588da8d5750e2d971ded0961ce26972deb7e6d8128084576bff4764fccd8a160259c50ffa43d6a10c8efc708efa2f517dc198d8c1e98aa92fe103e8d1bb4d58c87821b8812e55816e3deb4dd8c78d718cf56439099b5cc5ced4acdb54ac9294d17780be0150d11028f59bd0cb165c1f0e51797e3d31aef299a96b8372204306be11bdc2a8c4084fb97cf18cedcdb23b29b9b7b09f2d29e58a4775bd493667939237cfff05e9c0e9fa4050fa6deb8300619c7783c35461ba8e48a35e4c4ade6805a5035236deda994901f7f81a688c2fefd32af45f6ae550afe77919430ffedda5eee3c768bd64104d9efffbdd196017245d3b5a903b5e0589978a6b72aa2873f091693ca6d86363144b08a52bd302528b9c810cefd5d4e331d40352aa37f5a329089dc8ae7ed4373e98d23c1b6132c0d78d32b28704566e43ba62ffdbc4f3663522a17e85e89212e09f91dc6ffa0df8bd77e786bf19ce51db79c9134acd1884337398959d71848e8c6f3ecc4d20acb2412a8e9f1591421e18ac9f5a42b2d831901d28aaf7eb8f7743bad729014a46f2d327f29ef4976279dab6333d34259885ee691793e19125ecab872a8cbcbc48b8d82f33115e15ea0d7cad0641f41f285e2a24b672931313fe49ff981e274d8c913afd79eb87ad92c042b743d6a0c7bbcb854da7bf1d8068fc438b4ffbe892d3b41d18323e4070d01bffd766f9eca31252224d55167897a4b0b4e65352fe80721b527663da49c02a782ffa009d39ee463183a687084f575af2dd8400c97979c28ccb9d7492c68844aea7acae544d1d7622b2a024e309d30b34e50206e9b4e3328fafb963f8b5408a9be7b1c5dc003c69005c6bf70e8fd00f3c6ece0abebc695eba8ed0794c5426799845416ba21807faeacb8ffbd17a36f1fa2920a1ece549a42cecfd40c060fc2b346bc5aa8930b3e878e1697649524976ce403798da9d754e1b532c487f9e70c25eb94e2073c1b84e2ca72ca39ff018511ed529476787730c0bea66d4aa33ac8b65c83cdfac04b673aa1eb78c61437f4d104269da2f49706cc77268f096c03b4dc711d5b51868f3c109f20a7666d8fdf3821ed6b6aa70bc85362c327fe2f40cb0ad60af514c2cb589f4cc73da4474a3903f357948100d3bc6be09f6d8eba08b39172a4db12641be0d829b9351b9f5ce9577bcf608f099b6798d7d57cd6bbef05a07ca0b5f661a85448e8b98a5fd23d03824c8cd8207b96764814be2b53845f16649ac5cebd6b5bd8b6ea3133444310af938ef024d335d930e40c2c1f4a239cb31174057ae6757de5ca01dfd203c71929eff33582ad02c22d9fae1df8edb8dda59f5a7f01391aa1e25a0a5d6a0ad41260f4873cd56bf0fcf23efe792e7a5f326ac280fca471a85614e44132d4d344e8cba0001697a7bfd4e2e608d99b126660b9092b969cc822a52d30542acec788e742cc218874c04f765f912093d0b6f257e0da4a947c77cc4f5aec5b6a9ac6f28933564f3597cf4107a77d612b277ef2eea6c0a1aea335957fa3eb0c1ab33b14ad0c9becacf85ad209e6b0a8e29e80e741aa3c7d730fe7741ad4298c7b8d519f4a4545760b08a2551b1d188a756ab4f69d51d64b9a07db3615bbde61ffba24d2b01da03e471b04210912a52556d5eb9967ef28506f95e100ed7e7dd21ff3677efbdd1994ef602b797c2742c09769d50e8e8020b48aee7b98caac1b1d7e9f8fae66fc94f10aad1f7e464e0408ecce81b8c313c99bd3c89dfc7c6b48661143e242d94ae287276c925bccb1b7bf46c6666b8ba5b63eee5a176bc358a3099078db00ce6f0118fd3a7abe7dd194cefd820c839c7c0841307523b0e00916b75c486d3d735aae236064609824613bbe6bb5dc26aac2f3857dd00e4ce1fb57a139393ec714931f07f967377c442de9e1f83ffe1e530ced236a56084ed1ebfb9f30ea8eb698d3d1bf85254ce7097c117dee40ae52a1b8d03a70e20de60701e5592ff07ae8d1c1409208fa0e550d01348900bf3c39a81e008ee24d203e80b09e7cb24cd1f593783d808ead12d138bbd838e9bd3546487d84ab00a63ed6b62d55edc36b6aa2c0ff2c30f6db2af8aff839eb0c05bdad53e5592d9ca9db1bf09bf45b6905d3bb7d716a5b9cb63f8cc44af921fa93e4d931b477638ff30160786a10de4a3a38f47c33bb9863eb490852195cfc1625b45877041e4fe4c9044a71b0767933e74bb41d49aff7ed782f5c347c8a405b18a69a8cdb600fab551ff08cc0c461606796deecec5c5cd56953ba1f6c31029694e77711c39f5334089771f0610c35bf97080530050091bd372702c022bb24538887f7c2b5b60bb7ab7401bb300c8f443729299f108b0f985efb088d1ed991cc44b99fab3043aa4882a54d963f7f5aef4d2f7035d0b50e892337498b79bf5a1c18594b1902013796f7295d21f0014a2b6a65ff231bd43cddd7144746b328523ddf7f6bc9e386074ae0d0f8ea8249ef948a00da2ea7c12a8398c16479e212eedf3b7388387ad4a98c217f705eca8986654448a8a47db90e643c895868a5b58f012d3266031537d7884f21fb8a225010a7bae8ee6e3fe55398119b44d3a252b5ce5352155b97f4d091177b617ef5c3f4afd6d5d4302ee29d14c04b158db8f597efcb1ea579536edb0d16f92cb08ba7ee1c75b60a24bf33b8b69df2910925970af7125e11b42b300a7b1292d2af0db66b179283bedc8acd1918496c47ea1cb86d4000de47377e898948dbf2ae4268eadd26405a8a82b69f3b790821143b184b56753fb37b80d44b47f42746662ac6a241181b8790a8b7946cf787eafb9d1fdd95e311ccf72ce2448390ba1191aef73fe9800bfd9fd5890d15e6341ff4424ff22db7ce773f510dad6efdc89ff2aedc527d818ae3156b4df2e0133b4586c597e8ab6d660fecce03744feea45b621524f3c9fceed955783729e7cc52ccd2fc51def57abba247edca753da02c13219776e93eb669f22e2d5373fd9abd5c3706d0dc45acdf5d74d063af3efffd7e86e3356b13ab593f2557f18b2bbd47abb05ec6f9aa2c47af351038dcec574f5bd622aef7b626e9b4c2ca49a252b212659f8363b0efe1761f1bc8344c637cd597a830372e23663680271f8afb5adf0abc044d3be7d347adc74ad67076f5491f07fe630a8a67671c824c55809e761f3a4a65152dd977e980370e8cd52a83ff114a05a504ad3e94caca28f917b392762d1d3fcf91d67f92caf82848ed3f809a8f3ec4e6e1968ab3c0cc3d399b3ddb1da5788916f45964dd027a7abfaeaed652797b5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
