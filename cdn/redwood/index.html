<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9de60b3992ef3e25f7df02f8a1fcc9bb0a1bd2a4a0ea9f8d411048e466d81e0bc278afe8ecf0b8301dbc871d68d8e987c55655010dc680436834b0c62854ae88d792917212e6ad1e64cbed4005558c5e1abf564c6e4e3a77a591bbccf60c20e66f82b992d6593066170f5aa495910a473af868145d5f3e9950bbc286ef827f4ede4b565a46ade3ad746ab3888fae20399a13c0671b89a70c2124df6cfb1401c406d0d26f78b156b3a1e481545fc824478d35293ae3af48f036a26b0b723260cb2cc76099e369482fb8c239d0599fef06fd0bf49244755006ae7f05587bf15c13f7331feec5250f3d17c8198249d5d40ff7c0b7545da4864f5d5d5fec4b6164f83d5711fdb28d6c5a35e4bcf2acc26fd924ba1fafbcc07ad17ea6de92615b68f9cc5ad8d1996b85874d923852c4706f7eb106ba6ce5d8f701c81565321a53c1f787d28893f01b19fdd69919d032c58812a9ac2755e58e2340995cb1e997b333476a2294fb8b167fa47609912ec022f89b1ccc886d123c6e814815117b4874539e29fcba5523f0f768c5aed812764c9621a076fa513f833edc2ed6245f1e24553ccf86232dac87dceb40a3c14dbb8420261a59c538870ca6e6f1492224ed3be64eef3d56d7ab38c3beb90ce96abcd1f6fbd428bb8f4dbaaf21bc8efa6305beb600e4976ebdd93aaa041f7ab1e08994f0baa1e15d2986953a6a4d53d20b48cc51e000a04555261548a4543282f4f66dbc20133b05ad159980d68193513a01cf032db837f01b9fc149986e9c462e8d859d700e8f14cde606d9759ff56ffcfec5bdcd3a0715200540c65107701d5b8af803dc872c0292cb816e6b7d821c305d42319e82dbc89c726e20cc59b861131eca803bb72904d61a6a10a78e16dba29b16b639a8e720639eceb80d8f4e209e22e5d3e83cad25d0addef82fb75c38c58d1a6d41c90f1a0c5a10e6c3d27cef6a6278c7591a1ebfd5773e50164f3e5b1e5d4293d940fd3e162767da1c6791b5d5ad34805a3d5f9e71425bb746eae1318cd17d10d67961469385a82d99d36f03ae813fce8198d6cd59245418a4acb2f38d67acc11c2d5934e3dcecbffbb8d49562e8d7d5377623a357796527c92078fcc6b6fdde136f4dab59d62165ea91d0ecf58b501ea9802cf0ab361a87e6673dfd1a0217763ac1f8e57b82675ef6314d764401fb9a9682fd84d61fbaf2f7a7e4986671183cb6e7fb698ae81656ee7dfe6498be8b9e7386a5e09b3740b1e748d5155b4d1ccea092f6be3ba5a75d006f8893e764738f8d65c916c12b543ba400161f225f21a58d7b56c0e959946971a705c8b7193e4dc44ab365d9a63bce7f5e7843989d22111f9d0f659a4dd265b988fb5891ac10bcffc206860340a2233fed03946acd5fae0edaec385b4feba78e4f8013b70b0efe3a14269a2456c615055583f6650670771e8658d4f6a425c29c9ffdf7c0e67ea217e4ee92d8f7ac4131bfd80200eb6bba43032ad0f7011eafb9606ad8d11d95a146750414055a2ebed6d5a0cf12c3764e422b998f9c0f26aa0b4225a8621e2d97add8a58625dbb1a1b91470dc85c3adc48522f93e918daa77cb8fe0763e6d43a84b05c7e756a036625feb4d852dc9b5780b8ed0a032d4054da1ce8c7fb72bdc23088f17f8ce85862654a9a358a4c64b2064809a4e7685a823154b004d43d9021c8a2ca94b45fd3f414f0daa0e25c0f630e49cf3dc54a65f9a0874fc46ff6d482bc97fdd7be5491f9c6b4ba0b9568aab79463c1bdb4c27248072f7f6c08939c5f6546b6b4a24be3a1b581577c8a5a936fa29d0d0e4802af9cfd3fb5db1082a3a5da9f2cecbae8a21427c8903d1019b30fc7732218e179a32ac6297013c12b1184b5c48f0436a16833913a6b39c75dfb3ebf98b2e3fcb0df92a099c4bb4fceb751323ed73c6e0f3c68a730bfe7bac2101b4b216eb1f258f476fca3529372eae3e1626ab85d5c30481d66936732be6e2b26b776aeab8313738b9956c5dec4f5c4741a51aa03452d45e3754325d9653a40652c27de6ad0315ca611cce2aa6f36f86799697d110391b3307db0ef028aefb4d5b63ba9db2ec2cdbb8b401654b41770710ec41c822662917947d14d65d5d60c4036b67f27685f01776e119560bc9af4383f1b13de8fb7aa91bfd7bf5adffccff1f2e3ae6e67642e32cb58ca3e285deb2dbc615139b19a37534b8ae3c21afcb81664800ebdaff1a81429ea888dd0a178b2ef62333175e8cc625c75e5006c27fdc7a96131b82dc785c2234afeafe82fb757301731a17954170a057ccfe87ea29b114a8368bc504a4b169a38ef4e2c6c37a6eb926a3be31bf9dee15669eea1676f7caa97c1ec4e8c0edaf05d726fd1f80bbb64ff740b8cf4d789daf143b1765b7a583326347d6ba0795fbe649c8b231cdf90cff606e81a2399d0afdec78c1221c7273b3bba2a6bbd590689929c13c16f0bf6413fea8786a6a260aedc4940bda9112f8073ddf7ee5bfd00946903a9a58b21920c8a3d07582f77dcef9f392c3067af388782bd2032345bee04e627a9f38c5a95c557da6be655472b7c100368c7097f1ba60998269b0877973946e462bc9a35b56fd87c706baa0ce8e942c5dc225d864a644ba413b66d6f323e003139f52856aedbadbbfeaa1b930e6566fbacff2ac6be039ce340881466f5da8728e70c78f5a5bc70292cb6e09d703da366320c9ce2c2a0cce14a0675b70926bbb1145c5f32d14efeb2ef45dc3c7be818b779f7420bcf5e772240beb9118d96e7121ee8153e68507874482f3a02e5adf4f9b38595a1f1766510f4d44655aeeea5bd18018d44b5169bb153b24381e32370128a136b8151a1565866e133d627ed2afe93b24bbb44e0f7201ce2850615b0989a7d40eb623da8f47b97a1f9058e0ef4c016d512602f83766c5537e5c32bcfc8e7b3615b216eb9e2e1ec13b7feaec6556eae3d4cf628af76ade5781dacd9e75eae4039685498a5e441e5e8bcebe3e018782fd29a0387a97dc19b2fcd90bb8f7e4f50c77c4e41fd168db54e302641a2764b38a2c79d138dfbbce6d86a18c5226a804a6bb1d61ac1738774df33ee8582af82a744618c3fc9accfe80fbc842c10450b432ce38ce8882ce3b8fabe41da8d33bbcadac8cfe0f64450b7be9a8453db3c72e0723a4576856592b4007c49b7b67f2d6621a68f1f4442ea04f1b7dd000c394cb65cb7c7df21c4939c5b0f88ab29d37d65c2a7b8868a78d5979180dece30119ff72fa16d2f9b0f4a85071ea984aad249361c6fab07b9a742acad39dcdad45615e9d3f11aa7f290c23a45b81f9f2cee8667c32d5d1b97eec250e74cfb8bb3e7c22dd352fc6e05434e762de1ba6feb193e2552e0104d95368faa3055dc5d5a9722ae04fabf2270ae9c2d2a48e3f342ecb78f12fc7955886101e403e90a981056b980b19508b79cd06d19a3492c790996c0f34fb95a0165d1def64d1d7c73cac355043b1b0a18ca64a616f0800297cee484f5bd80b011079f3fc12fb8d99369529b8c0ada775c251f1699cc8a78687fccc717546a3c738d8fff8e19edd896a303a5626c43c176508e586d961f7635aaacee715d05fd38c1fb629f5dab9e35ca1e631e35f9d281ddf293358145adbf6eed153414e76d33b5d92228329db804c7770079ffddb785a3a173c77e2a4cc0056a3cef9520fee70159e1cd1a5dc6aadd5da4c14fc085959fbe324900fa17b9b862b1f0e8d2a54cb3bc5b7c4ac88c78ddf805ff1e267adecaf867825b3b62419106bbab8a540f8bef0d0192bf0b1ce0e1072318562450a823676cea1902d1a05c203e39a1ae722a2bda042f395548386f3cdb89c383781dbcb94d87b4d73e85d25211d4508c104c8df3b90238d754afa2d71b102fdff7763678dd7f743b7867e3aa763a263724cb62cf23e383ca32e99f8f67bf84894a027c42aab1c4e24fe29a9abcf0d3cf95a4a00c9af4524eb694fe50d4ed3dec221c5c8348ab10943c1c469640426ed06f79533d50a8af18533adc4cec708e7ccc7e3bc71807ef5456fa0f28a0fcb0a4fdd47646804e8b645fc5c9a08cb31e2d137b7e31bd32c09b5fb28839b82dc70efeec697bce4b7d0761fd3896d8da4ba289063748a18ea30ceda7b8714423fb7630bac9d65fbd7c58031dc7b2e6bff26e46853d221181b386ec1ff068dccce74a717d71bf49fe046e3a2a916b47a699f8c923d662ef06356c48b8ef3c2fcd12098fce1e122f9a490c439898aafeb1bf22b390a9f336cbbf76ba7d6cc8e3afea95d1fa3a6958495d4bbb3d248842924afdbcc920c12b3e18da1563451587eeda5e2379869a5824265fdf9a80986f76e1e930572715f67d88f39ff804ce35d4b1c0556e8db3b4b7add4b47b9d1e4bb2ceb2c10454e8e8ce8eb54ff62c18963d3a3c6af6e1bb821ba85ddf6423c9938c95ae21cf54c2bbc072d02a2b2e4cf7f0056abf0a4ee3a51511e6acaf1ddc22555144234c1c8df78015a43784812facbd62d0123f833cb95c67fb0da495ec1296605268a92e344c0323b6b32c3099497de337d4b2d90b0edc6646bb43e86bf77470ed82e74b05bf20c30b9937191b39102082d31ed6e69ddcc520277b0185949b67455d9bc2b7a4e138aa516ac18e12e719af7c0f58c1e0a99c10a510677a0dc5fe343fc42e9003330fc29e433c869ed19257c4bf9d78704e4a41e81ed665884ad9fa5de45ba4bb8f1ff627af0d658ba0f31ac515bbd77bb8d995ef5f94d8a41bb64b022a5ba29b9a761d35552873df2946e59d6810c8ad41ce951eba46d721613c8e510dcae01c14660d2eedc7a03c63b2fda9a1fbad7d963fd2285a12837bdec090c84d46d744e4c1d09aa1dfa113c22c5c6c53702f7884cddedd593f7ad7414d35cd0a3eaaafcde412999b4041a1be8a98fb981934d34b14f01bd1b48b4c8e92579e810604c097adf9952565db78c5ff01cc911a93a40736915a6c3ba0086ae9abbe9fe69313c03b1d45b052ea0fa12734f63c89beaa06b1a8ff241ff226ee0f058debc5a2cc0d7a4dce7b6e068cbde3c18bd7e203ba83dc43ab320182c2008b0c03b613aa752510786ad936700e20748c297dcdb7adbddd5575051e6bfeccedcf9c0c133483b6bbf96ee94c1774bfa349fbc7996aabcac6887066359168532ebbdf22fe74d0c036e7da967705bbc31d36bc39e982863703af41f77ed650dc1ecc3f730aaa6bba2cb0babcea5152f5593f631bfd77f5692cce9f47cec50810ad1a435068af0ad6d24c80c7b2544e1596af7f0281818dee1b425abfc032fc077d955322eeef7d5b9c1bc0896a3017b720a0791b4140f5aaddfe21e451439b1f69fb8c3f93a7cebe227e48913d6d74e003f6493feab26b7c58fa3d3052028aa8a3d12ed5c6f13f61d32a0c81440bfcbb5655cb489fd343fb9cba1f73d8da68b39ec8a262e4b74522885c28802d0551ef6e1a972fab794cdb6d6966b7bcdb658cce28217ce4143b94da4ae49fa7f666dca9dcda4a973f6f0794a6ddc6d13a2b1034e8f6ea93dfbb4d312254e02cf6fd15af79f2da3f934683ef25afa1aed55a5d141d8ebe61fc0a014ebfd131248b67de42a2fb8bb3b82d800b841765f254830d76aa764cf3b53f802a2ec0c07abe35b3b2f626b33fe1372ee2e20827776999c229912edde3f433610f1dc0a4400a409233c535d30e1276d6efca5f79a6285808d34d7bd613fd141b870dbaf15c86d1cae716a8e216630efffc48a387d535b7e35d27a2a10aec000a544c4995dcbcdc61d211aa256f87210d0431987fd34d870273d519100074b6fcf90c5e9352eb6eeef143afca7a152d39d25b54b4b43ca07662ae40f7bde18ea8ecb6424af9e17bb973ef26836f44842720ee86b8ca313c35bf12855a9b2d6b743584c5793d00942514f4fd73a8e1c5e9d30859b78c64278438b527e283984f4dea05399f4b520a36c8f9cca3aa3c5527db09835c4be857b7600e8f623408676621797d968745da135f312c09d435efbf3273b8c3e0484cc8dcdae1086b6fb8a3eebe3a0ffb8ec2fe9411121732f5db85201e1035c0b801e52c6a8487486aa3a80f9eafeff2cd8f208d85a526ac0ee6c6183ded28fde9e088905fe1efa5db3ac3e9ef4c405816cc45bf2c890b2d924ad15fcc6f9b081c0adac66f0fe8bf48d75e8f0cc7b05df2b7a4d23e53d9cc9d34ad0a39d7bc7645b71619dc49ca92fff3398690255447e7bf993fc575ffdd6ce9cb154117076eb4eb3f1c87f787646588d31e0e8116b09a06ff691911b21bc0a6a060cd89ff3d90b195409a62ae09d5070e6ee43811c5241be1307f93d3b1c4a91ab96aef68b2db299327d302d14c32dc1d9e33d3f46d5a13d728709b651c23eb1fc0f208a5b65b8355203b5a656cd06139581516434a45b5c87c80722ff03c6f94c414dfcbaafb65ab4ddb1022e2f0e1d9accb9be9e50c53059751efb935c931a488ba06596e137749d2c73f048203a73ace9e618bc60e036042cec6837c346099734ad4d2817e99e80ff879032e34580cbf54d920a604d4cc3050bf149fa84c8fcd43f1757ef9a6058dfd7a8aff1b11765f5640e6663e6ecc87be550daf708ef2fa4a7f93e631248578c6a88d8c9dd50165bf4324b285eaa6ecdf59942f9f3f53006d911624f98abc2614a88be1eda1bd95decfcdaae75ae90630332f31277bfa8d61ff956b169c88c4af26732da3fb0a6fd6631488f422857b1abb672a9a10fcaabaef39800e2172945922902fbe347ab86c0bd9f2b14deb4390919631c1b8e62a00691774ee4716e1bdeecbd8079ae6523fd6cdee646d933dfa73f0b8927c0804ab5cc3701708a27103267d5eaeaf47dfa89597ec3214d5cf1124a5224c5559e11f231b40418be5498cfc4c55f1ea1081fbbc7ce02caa1d7e6200d5c79468e438298682936ab7be5e5470b571872b083bc4a5047ed977935938ebbbdb6d4702bc73089d3b6933e39b138ec1af650620d007554ae7c8ced20e70236928c08dbd003259779ab0c0ec9bea525aee9aa73d127c0e2db18187a3995f143c4b9e31d903ddf3418a39e7b41bcb5d8817438b4b48e9b2ca82320ad78d96a10fd7bba3315c4138e2cf2ed90adcbd1947714d8e198238d7042e876ee03e9db2a39000e98df3cfb10a30011fe10654bc90409b9bbc458043cc642aa2d0a9df936b080580980f482b1ca38c2fd51fd1e967a69bbc3a6493c0cbb98c20630033e261ef0cba3ba8b9aaef739398ed3a7ce563fa8fe42f80fba328d52c715a1caa3107557f8a461d5f942f947ad898f1b07e171c7a3ee1229208b3bf8fd1264af1006f8b0d884d3da55ca4d0c96c0261696ca5606df4032b16ac05d127467bbc1bfca83cfb01a2de20c0124b9435cabfe0bf96a5079e0f733c73288f7bb658d0b89ae4c1518e165e1e49f2b682502cba96bcd494a2f878ada2a8fadcd0a3732b5748602dcc88ee799384e1ad9e2a3838b82969902f6c0164a103b3d74fc8e7889a0f0a117f6c8519cf23108f3e88f4c782cccaa67686071c14c6b0d5ef552e2a3fff5d561973e4634128169584fe739877fe233922a5927a04bc71eda636727ebbac54b319edffccb90d17aca36e6c63474206e72224a919d688cc2cbf4a6eda684e4111107aa8d0309f360b1d0f627594d61aac6442067fcc5e4545cdd0341afd27721544f081281ae7fa1223c09cd14e5ce277d03d1313ae4b65cd9a46d0bd0bcaf23d35609d938c24d7c31000e6f2c3acdefa88c202180b5e6684c486e9c04fa5933ee2dabf6df17566910059f57cdd654ef6c05ddd7722c63123e689e7a4ee751872b8cdfdc97f4737eb472fc3b51db1ffb495001c62cd2c631e611f12e68d5ed4d3029ffc3be3712feaffa71050af54104c3850181db16677d9339f987e87f4b0983fc30524a8dabb752266cd51f3fa2c5a5aae4908e471901679880869ca8db6f9bc6bb8b8b3e264fb798a7b33a315b87193ed04b2b60b826622224c39c75ec88930646cb6d7cf52323e0180c5f59f4e07d16727bd4efa5be095ade3f284cea93d1d73c6de21ffd8b155209355ff4e25f58259179b02c537f0eb00174d10a6e8fb40679973181310402b5ec1b12735aabd4cbf86caaf9d912ae5bb369a53ccbb97760e79a4875e4b764158424f8a98d5efe2d9b4ad83775f7522f8fc4d83b0eb140afc78fc20013853115171222656935d9ad119fe0c4d8a4dee0d903a223f09168cae6abb4c987cbe719f06eb8a28643e3beeb1f4dcbd2c8aecbdb68aa57967e32f426d4df4cfa9e3fd7f3c7be2e25f84b606bdda72be9fcc13a40f54836f839e4794ad4d79ec616e9657cc260bddecf6e5d5a42eee30d390bf115499409872dcd1f156394ca6ff402737c113f465e44c44256c43a81ae40cf4ce7630f132d3bbd67a11f4413164d1b4ce26b60ff4f5e14d706b39d7d846f64b2b93eb2dd3010866d6d3a0a2de1a672e3f4967d98052132815f7181ff23ae9daabd4c545cf139916e5a9025ef2ec81407d74c02f2ea2a7a6ab57f830fa225b7ebe5b29e0505dd64cb844ef2716c0847884ab7cdfbced2d90740d3610fd7a5a9aeac3944e38716d52be12e0f20e1329a0c1fdcfbae09cf8e0a9451d0da430b9dfd75a90265cb479a98fe6b60bfc187c67bb0b9588a7dcae2035274b035edf71e0b297364f4059b3d5168ba0ec40111d779a388304dc811310b95a3c769e5e679c25eeef26a2a742061a691a0328221cd576629eb22586f1179b9ee07b61389df08d5cb84e77cd9fb7ea708ab11d27300e7eca509380721740e89b4084aee918de7cf929ab53db8f32a6c65ba05b8d117120afe4f7d207994215bdbf65d78621abedb870d64626f18e84ead0b8ea45a671427e11506257af495d2d6b9802703b0c41cb54a3892ed43e1a7bc4272b7746562f3060ca3ba49505a96cb2007c4dd802749bb8d3bc40fdc95c8657473324409728af30420334a091a0c333e43ea5c0e1939f2d75e86a5571d18527f36143965f498643c041d2f25b8c64c807fccdbfe8910478edafe3ae0bfd5f563f46786233faea991ac3e8a87d6d8cca6b176aac0d1da8080f0ed5da1948e4452e97bbd22552ab88d7574ff25a6fe4ac05de9af3a1b61f5259e95157e5574f576c1d9a5726a0d1ed0a748a0c7c379b92a6fdfa780cca8ef195e3fd8338c4f455ada32803c2ceae54b914e7c1fc6216fc0b93ea0c0e40c03d429dbed0f963ec67e780b915d93115a7ecf08d4d970454f3c3eb5d4ecb2ccae4acb95d891910dc5661fc9af9472349d3dd6b5fa8c897f506b01de78d207a1c110882186501b85845699642279e900cb6a9721c4333104e6e94a2c6f53a5660cca59f2ed2f07b2c492c6a43e469251750d0e23a485631c8939496e6191c9e071433075f16ce419f1aa24f2160d8044e3a407b4114daf931a818c6a673df0ebfcd61ff497a675245e3d893bff315e7b36d925d4ae1a8fe2f3dff3932aed186c583ed6bfa8efa3edf2cef6e5c18740c97fafa18b3091d5f54557b7b7194ce5635d1964a66761e5e356653aa1e373afe89f3562ea8ef8997cadb50b8a65795afb07c26112c63dec38e477e74530014fb3dd8564c9163b0bf7977083d8274c363ec4814b32cfb78c21c2a5fd898fdde9babe9fcd9cad16eda420ccd7c90349cee39653bd9b4a6409058637154cabe2501c8342bff9a03e5da4cc8868e9cbb82d1fa5bc77ef6e3a9514a8650703dd75dacdb03df53971e501861ab2d488cc45eba74d717df78a757252b6419b9d492b552fd21b826da868e9e921c6f596ada6627009b96e3c0b783ee5dcc4cc39da23df1b244e398c4e86a1f958ae9c12d871fae3de5c8f09c2af92db915224422db9d385d0064ffa00187c04b57d8fd77600d800cbf42359ac69b96108fec7b46c24b1959017a3ed2bfb6bb244d2f5cd736e89e6b6203d2d2501719f3be078bed1ceb372c7252eb91053dfedf3261957c9a20b7ad520e3b53c2025e85b4cba481b6942d8005ca6db4f53c4b92077ba7cd58b1847c90481116e8994d3d6148b5a34b13b154b8a1cd5830f73f7e365f10830c26244212e941a5ce2bd795469e106e6108b394cebabf607b24f49bb650b115a213bf4ffc0d1c9df2bb72f27caa4d7cc5d64497332334c9d9c25c88929f28d88552641ed1a1018274c46fdaa6d51b9afc1c48ff823df73027295e8f1364692a4276548e05dc5eb3540cbed69c2168ff8fe8d7bdd23415dedea4b08cc3e76b107cbbc6a45db58919c90f3d6d4967b68b6395717688adf185065b1842e16743f8cfe2987fea0826f992d8cae7354aa5fcee366e5e1a8e95155115e2c2ce364278858bc8c846e66672cfd1450dbba97e32bba1fd8d54e5f8f4f497613f85b59d05c9e1f098932af120c51c20fc0fea416bb86c005398c674621a6e3160deddc556abefb372255b28467d3e4d14a590a2ee6c43b21420a0c9ad870725f4942da6ec8071379686a1fa3eeeea338f8b5a42c3aded0c0175e1ad02097e5da103990f17fbb76ca7fd2942643bfe620728144f0ae8641b39908117d05b4b0309c548add65cbf00023c5aa26b0e5754a1766fb70144ed33eab0476d2db79c247047b4ed0668fe32471989073e556e26e14e85f2f94e1a27d6ce85e263e961ec5cbd81a2d15ee2304b1e08f6b5c45795506f6d991cc4d97e01b7a331445816350248bdf668663a539ca57bbe21b1c94a1d9c30fee93ad4243343444817feb2e8b65da79c974311812f013aeb84223b6ace8649371dfc8c7cc4e27117cf77238fc5664d718c66b1337530999878a73281c44747ba8bca1c9e2778d7491a690b2b43a708539d4d10bb6a3dad29494549b0e22b3babe71c4fb30a966a61fdda1d8b2793925001e6f7b2ed23680f9711e1231c9e9a6e6bab86f545c9af2cfe9988fa20d440c8bbe42d6d02fa3fc2111a9e5201c185929e710b487e6b83328e1c7b0ce1e7f0f5a288f9f70d4fb877b2feb4467148d4b6f5ba70d09f2e40184ada7a28d145ac591a7c944c01f3a6eada9214f8d15790bfb9aa01761c669ce9ee2f5f601fb00da2cffeb605640a4ef44a7f9c524b4e92bbbbcdb7a2615950f49345916286d3b400e2cc7b33aefdaf8fde71ece1cd9acefa4f721f0977a26feea8b68d64cd174f4eb8df2a69ec29d2bcdcd8614f4113e6d77936b4224bde1e8a3e0d71fd23b0cbfbdf0153eb5ed4af623473d43ce7bff818ec086631bf4caddea1e5c1347c674706a8f76d97743485688f9f8a4788707d22f8a7babafa5aafca21541c028dc36afaa0d8cea6d9cc1c562147ffa1823aa5bc72017c41c2a42334872e182de2a79f3cead92768b42067dd550795a6b72aa982ab7b4381b708877af3073dbb21f5e799da79674a9cfa09b7de7a9d0de586476b9c3951b36385d50a20dadf90c44e63a981626624e80428819a05712b814ae59e8ccd3ae32d22725ed9fd9855da469817aab26a396496b5f062e04f0ba4fa718f69a209cf502666b44818e4027458886d69a258566cdf72fafa249dca0680aef8c148d53d192ffe3a897d804a192a1afff96fd4d8a81b26934a42000da81523dff81653dcbbec64fe7b09882f3f79c6fbb5c7573a1458a64f2bbf37f45089763427161d919ebd5ba732ec427af97dac84a6c8336982e6c919630c80d9b574703314c394879cfa06c4354b068b09876ce0cba732e03d3c7c4fb54f97ccb5ca6e6fc32cb33bb74aa06c931adfbb3f36f65708db78fe1295794146588fa443a83ad06385e4517703169c75a76b6376cf6868a0d24a2a32826a5c8701504ccbcab07ce9be029ea7721dbd2b4833f56fa4929072cec77bef99be0c980606082afb71f57eb66b18083473607fd91f9fb7da069ef8b2e154d53f4a5017bdad093f065bb8e371e039374f7378d6a096ae3db9c5b9a8777a5527ae138b7b205df083005d1dd3759207483d9915c927b31fb7445a5132176ef71f32590b70795a62a5ebf961fcc5cdbefa6be888c79d9c358c74232be4e5b75d352fd56489dd154631813968a25e685747a924364f1aa13b7a37bc658e8f2043f95a26b038178b7ff83f705fe94c509ce2198d1beb1c2c14b7f7bdaa157b04224cf607455ffd45a3524098a4cf19be11b3195d84c2191d8c961b1b44aa8680452297a3c61f10fcb823d19846e08cf32f3ad2b505eebd942a9d31e03d73f265eb1a27f3a2ad360785b54b1deab475ede7c2c7f7d66b8e8f57bd83a3ae85952a2dd04cfa83e5ef1c89168be71527f33aea50968d097fca3c60e7ccf69d121d4e2691820f0d5a53a2c19e60c83037e3f6bef2c3e1f00af9d376db151d1dd14195f15f4805ad2f20d1f955a9708be07e62666d14ab6e1f629b48759f2b0c61c2ab11902edeb1f9f9ca1a4ebdd1a5689184c044f72d2b90d8f9ea52208ddb3d75bc11475fa7f77311cc9539f9bc3123f7f62b4a45bba376af08a4daab2cc817c29f5e4fcb71caedcc26d6c398ce3cd2f96adfd23da70a8baa2f8dbbfd156f2b21a726bfd9da81e1ee5e969996efc757c3b4cd1d2237ccb95be015082a1f0c50c14f77a98a3db60882be4643669157fc10a34bbcc905d41fe99414e9f6f8b95a5e023b38744c665ddf01ed980c3b50cc2e68f4e4510a3ee22fa0f50e341efc0380e83b97641fb0b8f6fafa5169da32dbb4a1d7f35d6c7adc949eda92fa7052a331c2f8e47863c5db0d032339aa194aed48856926cb506b7f4159e0e08274a3929cd040b9fa19189b014de46fd0f173ef99d1824ff25eaf4852c59e2d5994a545ab8d3874f38dc0113b801d739845ed71a96e99846a532f0bd2e976effbefa8d6275aee829e07943dc432e541de56bb2c5573cfc00ab509de812f52d8790bbc4544a057d028971fcadc428c0b841a734e4d3df8eda6b806b915ce0fd50c2598a060501e4089fab7f154a4325e1eb536b32a9a02945ea6a20bcdd72a5d3887fef4e58966a12b2d94cb5d41bfa8ad4f7745d5e22ccf1438c12e8eabf9b6afca984bd331e7733aaefc88dfee455f933c6dbd717fad80161232c9e1b96a2afcf75e708f9f66d5bf2f1955038ab67563268879083ab7b9c12666877592a1fcaeefa7fc3ab1579fcf3cca8ca23cb85285d7ecfbc654b9a94b50a81f631e43db9a7e74e1bd18a5aa8fee5522280b5102804bd09415ad0cc8acf6a83e258d118ca8eb5cac6610f88e14eee354e51a99d0de123fb47aa3b7f2a2b8a4cdd67512b6079f00346f2343f1711cbd0601ca96eb01c905e068e0d7304cd2f97cfcaf66c1fbc631b93c0623096a4508278f2f12ec28e0eb441ae5836836b3f80588aaf701ae3e0fc659647f187389b3fea88dd352e232dc79dd14fd91d87c3c81462b5872f2fea98e438c0c62ee31f01c7899d37d175dc1eef8a920d8643682432a4a0a662456c3b103711d5cfe1b7c365a99ff91d3d93676e4919501de5cbbf5bcd86e24ea0d6f4d76b2c24193d7340eea37a9cb8986ba1e44a62f815e02a525063577a6bf31203534a3bd344d0510d25e1bcb79b5c35f1e41a2e0aee3b22a694c0768321464b95f752499813af9c01e5b46f2e04f3891f911698e4a748f0c25310330ed03ed2b044f3c0d698941c2d28f1ac76517149f197a45e53a19dac7f946a6496e8d07cc5ab0f0b61316d81bbb59defd94eb9dd23f14f2afa171495392d7c2abd52fa96279353a09e1adad67c579ece265f4f1392033e5aca0c8b6db27a093193ca61d44d609f6137c3601e4709a99bf16d70302f6cbb09c09f955f298e125c6f91a79b3e1d2a4225ee7cd4d6bb71025c3490faf533344beaa8596eb18f98ddc384918c7835535765ea410d842ade6842dedd0e3810251efa82fcad8a6d7c12e56ca0a3e8fab756194631ae5d5f897a53a150fe0f561105e1c0b70ba028c1150cb890651e19488c9867c3bb9a9ac1f3a2b447643f29d314ed5394010c994719192d7326a72462791f235c1911f42f883a0436d5a823f36de090894712e743444f2b9deebd0da1a00e7e6feb394ba9b35ada31df1b9f5b4ae0440d9a9aab6dc7f00f7b82aa8afe7032b83830e8a223d2a37902c41161d230c9bb88e20c12da83de8a81a0f667a043a6fc6ccc3e3f07eb1b4e94f122e8d2183bbd6d3694159d705f3144f036d089a2ac550b2fbb278a7f125583c6e4b878ceab300502cbbb33d0fb7359b79e794a9b9d1f6f0593caaa10278e5f991ca0c2ed80d22dfe23b4fc55791e9927f8dc00491f01bf9f0ab5d33a14a8eed4aeb31f4879c1ca360554fd56be058210ed0947d367652232e8b8f7880ad5a9bee7b98fd4dde468be4e7df860edc4b2ddd974627c10fbce688da8a7ac0c1686155bf2735cc3067f09b7db4a11e41e25958d0b9ea0e35e83f15d013add48873ee7ac054b6b72493fe166806dd8ee166530d4181c1d8dfbb4ee24ad5c404978d651bf4d524da8bad4af0d1603d3f9416c8a256d8ce7c65cc0e75235c5c6f99a1c166933ecf50bffadcc8d691fa41e837878dd91784ef5bb8d380331a50f9a3fcc02ede51fe8c6323e336dca2126258dfc1e984a37d1ee159076c8a1156c6e3d51f190910cc05ee6f5ac7b2bc4470e70f1f2a33f18885d9046e467937a0b3393a29ca1a9d4726628ed2ee274ced8499f5057ddff8ae6b6c4032ed990b32b6c711d1c921aacf3d12ae67a4b50f21a1856cb813f82b55ea06a049c50c42423c57e7729d2f04e15f77de6e16948bda870973d442b2a00b949966390a15c70e970b9a592d6bf783c77da4593039ad91e20e9994916f3275df27d845be305b76dfaaeb33541827d7493f4097c40e38dd361a15c36059b5203b511e9aed6efe792bf35bc65c2da376f47cdae8e7d3b6377f763dfc4eb1bb6d341487b7dbd3e7fce7ad1437bdbbcf4b029dec163426b4359bd00101cb6768bdd92325a84326d7d62c2d8f57e8006bccffd6caad0290007da813b2b53aa34e6ac109707c4038515a1694da94527ae4f863f4144657e21fbe77cd5b92f3f0b9815dbd28a78333369142223b9b58c88a8b96fee8a9bd8012691d244f6968587f50ca96e5831676e7e74cbdb88930c364f30c1530361746b18d3c2c704f08238d3929f0c62808d3a41c606854c5c3dd54e66279c8cab58c94880096549d75b3f6247e280fc9223046439b872e4fe66f4426a284f0c74dd1fe5dadd5c1f1d617a0e3b6ace84af17783df670b27581328264d8752932c84d9af5b831f53145a72d89d79ce5329c7b5422841e0fd732fa4fab85ba0ec4d2a5887663ea617fd1579ee2282a5c3797d7b0e48ff93e0c2baea8c4ec792555e823ca4e11d0ec6189f80fb398fdab5bb8a3a75a869529e595999791b62112c322cc18e735f80d806357b19b4ce7d807e1d6a43dea8592e2e948ff26110656b30bd35bfdb121d613066161e5b6acb54f8f0376ad5e8bb074a29128db9291107d20c079f3adda2dd64e17e55195b38eb57095a730edcfb56d3e629b7303a1ebf42d7f7c30f36c9849103b202194998a084c55ec99be4a9ae7f8c0dc6c95c7745ae8803b6eaa77116ef822c7123dfec00abdd46055629c419a69ef4b5795606f7707976c3def90da41b88f0db94778a8745d65bf77bb383e2586f8a9512bd0b4b2924cee1428d046f2d9ba509798add34732aa3f1bc1182d7f501f61aeceb976f7a450961dd15aa7ab9095607cc5f372e2e19acec05389593be27fdfd162370642ead84bc57b37717e98ff7bfc19b528f8dc5814386538c4f6580e2c39847bf93e39e5e2bc3deb1f6e68ac5344a03eef72393f0b0de9337bfc8f3d04b7ea2961d16a56f06aba1a223ad984c70abd28456dcdedcddb6697436e539800e400536160c0549f97841f092cdfb84bb3f415a3a856ce3a1efc6294547b4ef7248ac506e1c7160f6dc93f071c8b5b653391435fef34f5e72ab6aecce9285aab0abcb3d06770b3eb0a52c0daedb8a5ff513f540d11ab9aa80596d8ba138dc26d6ee2afeff6cb2b2b9f149252adcda34ccb8d946ef1b4e23d8c61ad4bf5026877c739628aae4ea3b055b5c4b259553f953885165e723f15ae90d200f71e852a746c15eb90d80524f72326ebb11ce87bb7fc71e9f96f770ef444edc0a3c3f08fa149d323f7021b84ce200bed2b18251fc746f2d73075aeb61dc1ba52d088fad07d9ea5b63740b0a07e05d4fa162fbc2a356714293f217616ff1bc58a93c38c05117cb662a135c4a63943f2e07790509c3c74eab5f34f66c5f5b61d67c970a601a800356d56963e4b915e45740026daee442ce630ef4cad70c2e3779292995f17ccbc9ceb88732159d32f6c430de47cdb7a044a75756930430569c39187f43228897176923bfc49c5bb29838ab3767083b77bd31e3ee3aed3bd4a6f7ad72368966fcb3a10a2d60da66447f7ea0597ac17c0f223060ae0d70e6f5cf5e33328af0600e315dd096f8ee84b453bae5f965fedeb158f4357c34c5b1ad45433b72eaab4a98c2d9f77a895198d56a1eba9023aefdfbb39c40d5536e896c1698719dbf668822752e50d98b9528a58d4ebd2cef2b24db5e2a2073493436e2d13ce643f5864f65ecec510ec545fdffaa6180755941870537f3ab9c024fb9f7857f224423341729f211909cf292acf1838b9ac97539a1e90d9a6c15d5e96a2d48a1fafa7b1375c2d75a34c531e8d97c57a400b0e46337128fe2578b861573f5f19a43a6ff4cc1ed1f30ceed78e23ee6053faa90f8a7c5d0136feaef309316e794eb47236aac1c8f32502bba706bcdeabb0cbf53de96fd432d7cbba64cb923bf0f3c427eae3a3c8e214473ef3611aad0c51b1f406646248cf26baec5f005cee45eb6a89450b92775cec392bda50c726cda8c9b5e7d1507abf93f4552177b6b2b895b860b0585741325460f9b527f4dcdf348efe3cc61903e7bd3696248fc51dc0fa3432b569879c8f7f658a0b025cc5f855e8e7f5c24d7059da74f95bf6ff7d59b6e7223ee4c4b6f65925a7e596c6a640384ab0dcd84258519126772d9bb0c68c9643731d556051caf912662437180774378486180d2414992309c373d61e4eed3fa403a80525f9998376bbdc73fe5d209752180724757db7dcd0266efd3622840e32a8129a2ccc0430a8b2b8637c9709b69c13d6193ed78bbd42e01b4a40b90aecf8c271efefa6d5c33fc15adf93fa58986c035c7fe98bfa8b61e06e7c139d286ce1f4958652150ba574937982e6f3fa8cb0bffea777d915921b27584551ae05e5406e1071567d0be5edc29bbf2443e0cc1babfb27c678fffd9069238e152d138e5da5556be05d847c0eee571d50940a6b1b1e16b147a12fc6c49757f9735da18caee487a66e07748fdaf2ea844155f990ca2d0169c57168a51b0c0b4a959594fa3e2cb42f08fc700f2639540b050439ba5b2f67be21f83273201edd055a070566621c2058aa6b036e2f603bcd552fa2818af8cb461b17e98a3c897c191cb82469a8d77f696d467812c14fb236bfea951167a2d93820c47eb35f547c1ca521b433d3c5b0dc2afb673e867cbf63ea4f903acc62363eba48b2a54b70748e7c3dabbac94b043dbf5ca820d8a89e9a1084f5e08855b17f12ef4f2d1c9749368335c4039459f73172a5e906092fac2cb6b1692ca44e34b11274c966a7056a87843ac1f0a0034a083ecad2cbb16359f92b18ca1ea1312a23dc1c2b82fa7d1c3bff77305751d8fb3839b0a54b223d9049d218ad119ac7c50a3cad20829f8a57e1a1e2519c029277f3197fe7e2e1bafa40019cb7ca20bb5dc012653408db3da16d96af7a3f47cf7932b1708926ce60de8afa07e162f45d709411d622a7ac4f1c503748ceb5ef5c9b6e50163a802201c8c06cbaed23ae6649e3ef788b360225e6c30ec735184a16cb846ad5732520ce7c97e3cf67b41f314268ab08dde0c44f9904dccbc9e015b50d466085ca5788c9d13871ec1b03dddb2f03bf83318ef5d4eed5594cb7594661fde198a66cd183c9137915bc712ca3671243d9b39276d589a5e0e95914f2a02855962dc1d0bf4c96ec8d77aef8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
